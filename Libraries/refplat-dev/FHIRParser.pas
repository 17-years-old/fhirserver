unit FHIRParser;

{
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}


{$IFDEF FHIR-DSTU}
This is the dev branch of the FHIR code
{$ENDIF}

interface

// FHIR v0.3.0 generated Wed, Oct 1, 2014 09:30+1000

uses
  SysUtils, Classes, ActiveX, StringSupport, DateSupport, IdSoapMsXml, FHIRParserBase, DateAndTime, FHIRBase, FHIRResources, FHIRConstants, FHIRComponents, FHIRTypes, MsXmlParser, XmlBuilder, JSON, FHIRAtomFeed;

Type

  TFHIRXmlParser = class (TFHIRXmlParserBase)
  protected
    Procedure ParseElementAttributes(value : TFhirElement; path : string; element : IXmlDomElement);
    Function ParseBackboneElementChild(element : TFhirBackboneElement; path : string; child : IXmlDomElement) : boolean;
    Function ParseElementChild(element : TFhirElement; path : string; child : IXmlDomElement) : boolean;

    function ParseEnum(Const aNames : Array Of String; path : String; element : IXmlDomElement) : TFhirEnum;
    function ParseInteger(element : IXmlDomElement; path : string) : TFhirInteger;
    function ParseDateTime(element : IXmlDomElement; path : string) : TFhirDateTime;
    function ParseDate(element : IXmlDomElement; path : string) : TFhirDate;
    function ParseDecimal(element : IXmlDomElement; path : string) : TFhirDecimal;
    function ParseUri(element : IXmlDomElement; path : string) : TFhirUri;
    function ParseBase64Binary(element : IXmlDomElement; path : string) : TFhirBase64Binary;
    function ParseTime(element : IXmlDomElement; path : string) : TFhirTime;
    function ParseString(element : IXmlDomElement; path : string) : TFhirString;
    function ParseBoolean(element : IXmlDomElement; path : string) : TFhirBoolean;
    function ParseInstant(element : IXmlDomElement; path : string) : TFhirInstant;
    function ParseCode(element : IXmlDomElement; path : string) : TFhirCode;
    function ParseId(element : IXmlDomElement; path : string) : TFhirId;
    function ParseOid(element : IXmlDomElement; path : string) : TFhirOid;
    function ParseUuid(element : IXmlDomElement; path : string) : TFhirUuid;

    Procedure ParseResourceAttributes(resource : TFhirResource; path : string; element : IXmlDomElement);
    Function ParseResourceChild(resource : TFhirResource; path : string; child : IXmlDomElement) : boolean;

    function ParseExtension(element : IXmlDomElement; path : string) : TFhirExtension;
    function ParseNarrative(element : IXmlDomElement; path : string) : TFhirNarrative;
    function ParsePeriod(element : IXmlDomElement; path : string) : TFhirPeriod;
    function ParseCoding(element : IXmlDomElement; path : string) : TFhirCoding;
    function ParseRange(element : IXmlDomElement; path : string) : TFhirRange;
    function ParseQuantity(element : IXmlDomElement; path : string) : TFhirQuantity;
    function ParseAttachment(element : IXmlDomElement; path : string) : TFhirAttachment;
    function ParseRatio(element : IXmlDomElement; path : string) : TFhirRatio;
    function ParseSampledData(element : IXmlDomElement; path : string) : TFhirSampledData;
    function ParseReference(element : IXmlDomElement; path : string) : TFhirReference;
    function ParseCodeableConcept(element : IXmlDomElement; path : string) : TFhirCodeableConcept;
    function ParseIdentifier(element : IXmlDomElement; path : string) : TFhirIdentifier;
    function ParseTimingRepeat(element : IXmlDomElement; path : string) : TFhirTimingRepeat;
    function ParseTiming(element : IXmlDomElement; path : string) : TFhirTiming;
    function ParseAddress(element : IXmlDomElement; path : string) : TFhirAddress;
    function ParseHumanName(element : IXmlDomElement; path : string) : TFhirHumanName;
    function ParseContactPoint(element : IXmlDomElement; path : string) : TFhirContactPoint;
    function ParseAge(element : IXmlDomElement; path : string) : TFhirAge;
    function ParseCount(element : IXmlDomElement; path : string) : TFhirCount;
    function ParseMoney(element : IXmlDomElement; path : string) : TFhirMoney;
    function ParseDistance(element : IXmlDomElement; path : string) : TFhirDistance;
    function ParseDuration(element : IXmlDomElement; path : string) : TFhirDuration;

    function ParseAdverseReactionSymptom(element : IXmlDomElement; path : string) : TFhirAdverseReactionSymptom;
    function ParseAdverseReactionExposure(element : IXmlDomElement; path : string) : TFhirAdverseReactionExposure;
    function ParseAdverseReaction(element : IXmlDomElement; path : string) : TFhirAdverseReaction;
    function ParseAlert(element : IXmlDomElement; path : string) : TFhirAlert;
    function ParseAllergyIntolerance(element : IXmlDomElement; path : string) : TFhirAllergyIntolerance;
    function ParseAppointmentParticipant(element : IXmlDomElement; path : string) : TFhirAppointmentParticipant;
    function ParseAppointment(element : IXmlDomElement; path : string) : TFhirAppointment;
    function ParseAppointmentResponse(element : IXmlDomElement; path : string) : TFhirAppointmentResponse;
    function ParseAvailability(element : IXmlDomElement; path : string) : TFhirAvailability;
    function ParseCarePlanParticipant(element : IXmlDomElement; path : string) : TFhirCarePlanParticipant;
    function ParseCarePlanGoal(element : IXmlDomElement; path : string) : TFhirCarePlanGoal;
    function ParseCarePlanActivity(element : IXmlDomElement; path : string) : TFhirCarePlanActivity;
    function ParseCarePlanActivitySimple(element : IXmlDomElement; path : string) : TFhirCarePlanActivitySimple;
    function ParseCarePlan(element : IXmlDomElement; path : string) : TFhirCarePlan;
    function ParseCompositionAttester(element : IXmlDomElement; path : string) : TFhirCompositionAttester;
    function ParseCompositionEvent(element : IXmlDomElement; path : string) : TFhirCompositionEvent;
    function ParseCompositionSection(element : IXmlDomElement; path : string) : TFhirCompositionSection;
    function ParseComposition(element : IXmlDomElement; path : string) : TFhirComposition;
    function ParseConceptMapElement(element : IXmlDomElement; path : string) : TFhirConceptMapElement;
    function ParseConceptMapElementDependsOn(element : IXmlDomElement; path : string) : TFhirConceptMapElementDependsOn;
    function ParseConceptMapElementMap(element : IXmlDomElement; path : string) : TFhirConceptMapElementMap;
    function ParseConceptMap(element : IXmlDomElement; path : string) : TFhirConceptMap;
    function ParseConditionStage(element : IXmlDomElement; path : string) : TFhirConditionStage;
    function ParseConditionEvidence(element : IXmlDomElement; path : string) : TFhirConditionEvidence;
    function ParseConditionLocation(element : IXmlDomElement; path : string) : TFhirConditionLocation;
    function ParseConditionRelatedItem(element : IXmlDomElement; path : string) : TFhirConditionRelatedItem;
    function ParseCondition(element : IXmlDomElement; path : string) : TFhirCondition;
    function ParseConformanceSoftware(element : IXmlDomElement; path : string) : TFhirConformanceSoftware;
    function ParseConformanceImplementation(element : IXmlDomElement; path : string) : TFhirConformanceImplementation;
    function ParseConformanceRest(element : IXmlDomElement; path : string) : TFhirConformanceRest;
    function ParseConformanceRestSecurity(element : IXmlDomElement; path : string) : TFhirConformanceRestSecurity;
    function ParseConformanceRestSecurityCertificate(element : IXmlDomElement; path : string) : TFhirConformanceRestSecurityCertificate;
    function ParseConformanceRestResource(element : IXmlDomElement; path : string) : TFhirConformanceRestResource;
    function ParseConformanceRestResourceInteraction(element : IXmlDomElement; path : string) : TFhirConformanceRestResourceInteraction;
    function ParseConformanceRestResourceSearchParam(element : IXmlDomElement; path : string) : TFhirConformanceRestResourceSearchParam;
    function ParseConformanceRestInteraction(element : IXmlDomElement; path : string) : TFhirConformanceRestInteraction;
    function ParseConformanceRestOperation(element : IXmlDomElement; path : string) : TFhirConformanceRestOperation;
    function ParseConformanceMessaging(element : IXmlDomElement; path : string) : TFhirConformanceMessaging;
    function ParseConformanceMessagingEvent(element : IXmlDomElement; path : string) : TFhirConformanceMessagingEvent;
    function ParseConformanceDocument(element : IXmlDomElement; path : string) : TFhirConformanceDocument;
    function ParseConformance(element : IXmlDomElement; path : string) : TFhirConformance;
    function ParseContraindicationMitigation(element : IXmlDomElement; path : string) : TFhirContraindicationMitigation;
    function ParseContraindication(element : IXmlDomElement; path : string) : TFhirContraindication;
    function ParseDataElementBinding(element : IXmlDomElement; path : string) : TFhirDataElementBinding;
    function ParseDataElementMapping(element : IXmlDomElement; path : string) : TFhirDataElementMapping;
    function ParseDataElement(element : IXmlDomElement; path : string) : TFhirDataElement;
    function ParseDevice(element : IXmlDomElement; path : string) : TFhirDevice;
    function ParseDeviceObservationReportVirtualDevice(element : IXmlDomElement; path : string) : TFhirDeviceObservationReportVirtualDevice;
    function ParseDeviceObservationReportVirtualDeviceChannel(element : IXmlDomElement; path : string) : TFhirDeviceObservationReportVirtualDeviceChannel;
    function ParseDeviceObservationReportVirtualDeviceChannelMetric(element : IXmlDomElement; path : string) : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
    function ParseDeviceObservationReport(element : IXmlDomElement; path : string) : TFhirDeviceObservationReport;
    function ParseDiagnosticOrderEvent(element : IXmlDomElement; path : string) : TFhirDiagnosticOrderEvent;
    function ParseDiagnosticOrderItem(element : IXmlDomElement; path : string) : TFhirDiagnosticOrderItem;
    function ParseDiagnosticOrder(element : IXmlDomElement; path : string) : TFhirDiagnosticOrder;
    function ParseDiagnosticReportImage(element : IXmlDomElement; path : string) : TFhirDiagnosticReportImage;
    function ParseDiagnosticReport(element : IXmlDomElement; path : string) : TFhirDiagnosticReport;
    function ParseDocumentManifest(element : IXmlDomElement; path : string) : TFhirDocumentManifest;
    function ParseDocumentReferenceRelatesTo(element : IXmlDomElement; path : string) : TFhirDocumentReferenceRelatesTo;
    function ParseDocumentReferenceService(element : IXmlDomElement; path : string) : TFhirDocumentReferenceService;
    function ParseDocumentReferenceServiceParameter(element : IXmlDomElement; path : string) : TFhirDocumentReferenceServiceParameter;
    function ParseDocumentReferenceContext(element : IXmlDomElement; path : string) : TFhirDocumentReferenceContext;
    function ParseDocumentReference(element : IXmlDomElement; path : string) : TFhirDocumentReference;
    function ParseEncounterParticipant(element : IXmlDomElement; path : string) : TFhirEncounterParticipant;
    function ParseEncounterHospitalization(element : IXmlDomElement; path : string) : TFhirEncounterHospitalization;
    function ParseEncounterHospitalizationAccomodation(element : IXmlDomElement; path : string) : TFhirEncounterHospitalizationAccomodation;
    function ParseEncounterLocation(element : IXmlDomElement; path : string) : TFhirEncounterLocation;
    function ParseEncounter(element : IXmlDomElement; path : string) : TFhirEncounter;
    function ParseFamilyHistoryRelation(element : IXmlDomElement; path : string) : TFhirFamilyHistoryRelation;
    function ParseFamilyHistoryRelationCondition(element : IXmlDomElement; path : string) : TFhirFamilyHistoryRelationCondition;
    function ParseFamilyHistory(element : IXmlDomElement; path : string) : TFhirFamilyHistory;
    function ParseGroupCharacteristic(element : IXmlDomElement; path : string) : TFhirGroupCharacteristic;
    function ParseGroup(element : IXmlDomElement; path : string) : TFhirGroup;
    function ParseImagingStudySeries(element : IXmlDomElement; path : string) : TFhirImagingStudySeries;
    function ParseImagingStudySeriesInstance(element : IXmlDomElement; path : string) : TFhirImagingStudySeriesInstance;
    function ParseImagingStudy(element : IXmlDomElement; path : string) : TFhirImagingStudy;
    function ParseImmunizationExplanation(element : IXmlDomElement; path : string) : TFhirImmunizationExplanation;
    function ParseImmunizationReaction(element : IXmlDomElement; path : string) : TFhirImmunizationReaction;
    function ParseImmunizationVaccinationProtocol(element : IXmlDomElement; path : string) : TFhirImmunizationVaccinationProtocol;
    function ParseImmunization(element : IXmlDomElement; path : string) : TFhirImmunization;
    function ParseImmunizationRecommendationRecommendation(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendation;
    function ParseImmunizationRecommendationRecommendationDateCriterion(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    function ParseImmunizationRecommendationRecommendationProtocol(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendationProtocol;
    function ParseImmunizationRecommendation(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendation;
    function ParseListEntry(element : IXmlDomElement; path : string) : TFhirListEntry;
    function ParseList(element : IXmlDomElement; path : string) : TFhirList;
    function ParseLocationPosition(element : IXmlDomElement; path : string) : TFhirLocationPosition;
    function ParseLocation(element : IXmlDomElement; path : string) : TFhirLocation;
    function ParseMedia(element : IXmlDomElement; path : string) : TFhirMedia;
    function ParseMedicationProduct(element : IXmlDomElement; path : string) : TFhirMedicationProduct;
    function ParseMedicationProductIngredient(element : IXmlDomElement; path : string) : TFhirMedicationProductIngredient;
    function ParseMedicationPackage(element : IXmlDomElement; path : string) : TFhirMedicationPackage;
    function ParseMedicationPackageContent(element : IXmlDomElement; path : string) : TFhirMedicationPackageContent;
    function ParseMedication(element : IXmlDomElement; path : string) : TFhirMedication;
    function ParseMedicationAdministrationDosage(element : IXmlDomElement; path : string) : TFhirMedicationAdministrationDosage;
    function ParseMedicationAdministration(element : IXmlDomElement; path : string) : TFhirMedicationAdministration;
    function ParseMedicationDispenseDispense(element : IXmlDomElement; path : string) : TFhirMedicationDispenseDispense;
    function ParseMedicationDispenseDispenseDosage(element : IXmlDomElement; path : string) : TFhirMedicationDispenseDispenseDosage;
    function ParseMedicationDispenseSubstitution(element : IXmlDomElement; path : string) : TFhirMedicationDispenseSubstitution;
    function ParseMedicationDispense(element : IXmlDomElement; path : string) : TFhirMedicationDispense;
    function ParseMedicationPrescriptionDosageInstruction(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionDosageInstruction;
    function ParseMedicationPrescriptionDispense(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionDispense;
    function ParseMedicationPrescriptionSubstitution(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionSubstitution;
    function ParseMedicationPrescription(element : IXmlDomElement; path : string) : TFhirMedicationPrescription;
    function ParseMedicationStatementDosage(element : IXmlDomElement; path : string) : TFhirMedicationStatementDosage;
    function ParseMedicationStatement(element : IXmlDomElement; path : string) : TFhirMedicationStatement;
    function ParseMessageHeaderResponse(element : IXmlDomElement; path : string) : TFhirMessageHeaderResponse;
    function ParseMessageHeaderSource(element : IXmlDomElement; path : string) : TFhirMessageHeaderSource;
    function ParseMessageHeaderDestination(element : IXmlDomElement; path : string) : TFhirMessageHeaderDestination;
    function ParseMessageHeader(element : IXmlDomElement; path : string) : TFhirMessageHeader;
    function ParseNamespaceUniqueId(element : IXmlDomElement; path : string) : TFhirNamespaceUniqueId;
    function ParseNamespaceContact(element : IXmlDomElement; path : string) : TFhirNamespaceContact;
    function ParseNamespace(element : IXmlDomElement; path : string) : TFhirNamespace;
    function ParseNutritionOrderItem(element : IXmlDomElement; path : string) : TFhirNutritionOrderItem;
    function ParseNutritionOrderItemOralDiet(element : IXmlDomElement; path : string) : TFhirNutritionOrderItemOralDiet;
    function ParseNutritionOrderItemSupplement(element : IXmlDomElement; path : string) : TFhirNutritionOrderItemSupplement;
    function ParseNutritionOrderItemEnteralFormula(element : IXmlDomElement; path : string) : TFhirNutritionOrderItemEnteralFormula;
    function ParseNutritionOrder(element : IXmlDomElement; path : string) : TFhirNutritionOrder;
    function ParseObservationReferenceRange(element : IXmlDomElement; path : string) : TFhirObservationReferenceRange;
    function ParseObservationRelated(element : IXmlDomElement; path : string) : TFhirObservationRelated;
    function ParseObservation(element : IXmlDomElement; path : string) : TFhirObservation;
    function ParseOperationDefinitionParameter(element : IXmlDomElement; path : string) : TFhirOperationDefinitionParameter;
    function ParseOperationDefinition(element : IXmlDomElement; path : string) : TFhirOperationDefinition;
    function ParseOperationOutcomeIssue(element : IXmlDomElement; path : string) : TFhirOperationOutcomeIssue;
    function ParseOperationOutcome(element : IXmlDomElement; path : string) : TFhirOperationOutcome;
    function ParseOrderWhen(element : IXmlDomElement; path : string) : TFhirOrderWhen;
    function ParseOrder(element : IXmlDomElement; path : string) : TFhirOrder;
    function ParseOrderResponse(element : IXmlDomElement; path : string) : TFhirOrderResponse;
    function ParseOrganizationContact(element : IXmlDomElement; path : string) : TFhirOrganizationContact;
    function ParseOrganization(element : IXmlDomElement; path : string) : TFhirOrganization;
    function ParseOther(element : IXmlDomElement; path : string) : TFhirOther;
    function ParsePatientContact(element : IXmlDomElement; path : string) : TFhirPatientContact;
    function ParsePatientAnimal(element : IXmlDomElement; path : string) : TFhirPatientAnimal;
    function ParsePatientLink(element : IXmlDomElement; path : string) : TFhirPatientLink;
    function ParsePatient(element : IXmlDomElement; path : string) : TFhirPatient;
    function ParsePractitionerQualification(element : IXmlDomElement; path : string) : TFhirPractitionerQualification;
    function ParsePractitioner(element : IXmlDomElement; path : string) : TFhirPractitioner;
    function ParseProcedurePerformer(element : IXmlDomElement; path : string) : TFhirProcedurePerformer;
    function ParseProcedureRelatedItem(element : IXmlDomElement; path : string) : TFhirProcedureRelatedItem;
    function ParseProcedure(element : IXmlDomElement; path : string) : TFhirProcedure;
    function ParseProfileMapping(element : IXmlDomElement; path : string) : TFhirProfileMapping;
    function ParseProfileStructure(element : IXmlDomElement; path : string) : TFhirProfileStructure;
    function ParseProfileStructureSnapshot(element : IXmlDomElement; path : string) : TFhirProfileStructureSnapshot;
    function ParseProfileStructureSnapshotElement(element : IXmlDomElement; path : string) : TFhirProfileStructureSnapshotElement;
    function ParseProfileStructureSnapshotElementSlicing(element : IXmlDomElement; path : string) : TFhirProfileStructureSnapshotElementSlicing;
    function ParseProfileStructureSnapshotElementDefinition(element : IXmlDomElement; path : string) : TFhirProfileStructureSnapshotElementDefinition;
    function ParseProfileStructureSnapshotElementDefinitionType(element : IXmlDomElement; path : string) : TFhirProfileStructureSnapshotElementDefinitionType;
    function ParseProfileStructureSnapshotElementDefinitionConstraint(element : IXmlDomElement; path : string) : TFhirProfileStructureSnapshotElementDefinitionConstraint;
    function ParseProfileStructureSnapshotElementDefinitionBinding(element : IXmlDomElement; path : string) : TFhirProfileStructureSnapshotElementDefinitionBinding;
    function ParseProfileStructureSnapshotElementDefinitionMapping(element : IXmlDomElement; path : string) : TFhirProfileStructureSnapshotElementDefinitionMapping;
    function ParseProfileStructureSearchParam(element : IXmlDomElement; path : string) : TFhirProfileStructureSearchParam;
    function ParseProfileExtensionDefn(element : IXmlDomElement; path : string) : TFhirProfileExtensionDefn;
    function ParseProfile(element : IXmlDomElement; path : string) : TFhirProfile;
    function ParseProvenanceAgent(element : IXmlDomElement; path : string) : TFhirProvenanceAgent;
    function ParseProvenanceEntity(element : IXmlDomElement; path : string) : TFhirProvenanceEntity;
    function ParseProvenance(element : IXmlDomElement; path : string) : TFhirProvenance;
    function ParseQueryResponse(element : IXmlDomElement; path : string) : TFhirQueryResponse;
    function ParseQuery(element : IXmlDomElement; path : string) : TFhirQuery;
    function ParseQuestionnaireGroup(element : IXmlDomElement; path : string) : TFhirQuestionnaireGroup;
    function ParseQuestionnaireGroupQuestion(element : IXmlDomElement; path : string) : TFhirQuestionnaireGroupQuestion;
    function ParseQuestionnaire(element : IXmlDomElement; path : string) : TFhirQuestionnaire;
    function ParseQuestionnaireAnswersGroup(element : IXmlDomElement; path : string) : TFhirQuestionnaireAnswersGroup;
    function ParseQuestionnaireAnswersGroupQuestion(element : IXmlDomElement; path : string) : TFhirQuestionnaireAnswersGroupQuestion;
    function ParseQuestionnaireAnswersGroupQuestionAnswer(element : IXmlDomElement; path : string) : TFhirQuestionnaireAnswersGroupQuestionAnswer;
    function ParseQuestionnaireAnswers(element : IXmlDomElement; path : string) : TFhirQuestionnaireAnswers;
    function ParseReferralRequest(element : IXmlDomElement; path : string) : TFhirReferralRequest;
    function ParseRelatedPerson(element : IXmlDomElement; path : string) : TFhirRelatedPerson;
    function ParseRiskAssessmentPrediction(element : IXmlDomElement; path : string) : TFhirRiskAssessmentPrediction;
    function ParseRiskAssessment(element : IXmlDomElement; path : string) : TFhirRiskAssessment;
    function ParseSecurityEventEvent(element : IXmlDomElement; path : string) : TFhirSecurityEventEvent;
    function ParseSecurityEventParticipant(element : IXmlDomElement; path : string) : TFhirSecurityEventParticipant;
    function ParseSecurityEventParticipantNetwork(element : IXmlDomElement; path : string) : TFhirSecurityEventParticipantNetwork;
    function ParseSecurityEventSource(element : IXmlDomElement; path : string) : TFhirSecurityEventSource;
    function ParseSecurityEventObject(element : IXmlDomElement; path : string) : TFhirSecurityEventObject;
    function ParseSecurityEventObjectDetail(element : IXmlDomElement; path : string) : TFhirSecurityEventObjectDetail;
    function ParseSecurityEvent(element : IXmlDomElement; path : string) : TFhirSecurityEvent;
    function ParseSlot(element : IXmlDomElement; path : string) : TFhirSlot;
    function ParseSpecimenSource(element : IXmlDomElement; path : string) : TFhirSpecimenSource;
    function ParseSpecimenCollection(element : IXmlDomElement; path : string) : TFhirSpecimenCollection;
    function ParseSpecimenTreatment(element : IXmlDomElement; path : string) : TFhirSpecimenTreatment;
    function ParseSpecimenContainer(element : IXmlDomElement; path : string) : TFhirSpecimenContainer;
    function ParseSpecimen(element : IXmlDomElement; path : string) : TFhirSpecimen;
    function ParseSubscriptionChannel(element : IXmlDomElement; path : string) : TFhirSubscriptionChannel;
    function ParseSubscriptionTag(element : IXmlDomElement; path : string) : TFhirSubscriptionTag;
    function ParseSubscription(element : IXmlDomElement; path : string) : TFhirSubscription;
    function ParseSubstanceInstance(element : IXmlDomElement; path : string) : TFhirSubstanceInstance;
    function ParseSubstanceIngredient(element : IXmlDomElement; path : string) : TFhirSubstanceIngredient;
    function ParseSubstance(element : IXmlDomElement; path : string) : TFhirSubstance;
    function ParseSupplyDispense(element : IXmlDomElement; path : string) : TFhirSupplyDispense;
    function ParseSupply(element : IXmlDomElement; path : string) : TFhirSupply;
    function ParseValueSetDefine(element : IXmlDomElement; path : string) : TFhirValueSetDefine;
    function ParseValueSetDefineConcept(element : IXmlDomElement; path : string) : TFhirValueSetDefineConcept;
    function ParseValueSetDefineConceptDesignation(element : IXmlDomElement; path : string) : TFhirValueSetDefineConceptDesignation;
    function ParseValueSetCompose(element : IXmlDomElement; path : string) : TFhirValueSetCompose;
    function ParseValueSetComposeInclude(element : IXmlDomElement; path : string) : TFhirValueSetComposeInclude;
    function ParseValueSetComposeIncludeConcept(element : IXmlDomElement; path : string) : TFhirValueSetComposeIncludeConcept;
    function ParseValueSetComposeIncludeFilter(element : IXmlDomElement; path : string) : TFhirValueSetComposeIncludeFilter;
    function ParseValueSetExpansion(element : IXmlDomElement; path : string) : TFhirValueSetExpansion;
    function ParseValueSetExpansionContains(element : IXmlDomElement; path : string) : TFhirValueSetExpansionContains;
    function ParseValueSet(element : IXmlDomElement; path : string) : TFhirValueSet;
    function ParseResource(element : IxmlDomElement; path : String) : TFhirResource; override;
    function ParseDataType(element : IXmlDomElement; name : String; type_ : TFHIRTypeClass) : TFHIRType; override;
  public
    function ParseFragment(element : IxmlDomElement) : TFhirElement; overload;
  end;

  TFHIRXmlComposer = class (TFHIRXmlComposerBase)
  protected
    Procedure ComposeElementAttributes(xml : TXmlBuilder; element : TFhirElement);
    Procedure ComposeElementChildren(xml : TXmlBuilder; element : TFhirElement);
    Procedure ComposeBackboneElementChildren(xml : TXmlBuilder; element : TFhirBackboneElement);

    Procedure ComposeEnum(xml : TXmlBuilder; name : String; value : TFhirEnum; Const aNames : Array Of String);
    Procedure ComposeInteger(xml : TXmlBuilder; name : String; value : TFhirInteger);
    Procedure ComposeDateTime(xml : TXmlBuilder; name : String; value : TFhirDateTime);
    Procedure ComposeDate(xml : TXmlBuilder; name : String; value : TFhirDate);
    Procedure ComposeDecimal(xml : TXmlBuilder; name : String; value : TFhirDecimal);
    Procedure ComposeUri(xml : TXmlBuilder; name : String; value : TFhirUri);
    Procedure ComposeBase64Binary(xml : TXmlBuilder; name : String; value : TFhirBase64Binary);
    Procedure ComposeTime(xml : TXmlBuilder; name : String; value : TFhirTime);
    Procedure ComposeString(xml : TXmlBuilder; name : String; value : TFhirString);
    Procedure ComposeBoolean(xml : TXmlBuilder; name : String; value : TFhirBoolean);
    Procedure ComposeInstant(xml : TXmlBuilder; name : String; value : TFhirInstant);
    Procedure ComposeCode(xml : TXmlBuilder; name : String; value : TFhirCode);
    Procedure ComposeId(xml : TXmlBuilder; name : String; value : TFhirId);
    Procedure ComposeOid(xml : TXmlBuilder; name : String; value : TFhirOid);
    Procedure ComposeUuid(xml : TXmlBuilder; name : String; value : TFhirUuid);

    Procedure ComposeResourceAttributes(xml : TXmlBuilder; resource : TFhirResource);
    Procedure ComposeResourceChildren(xml : TXmlBuilder; resource : TFhirResource);

    procedure ComposeExtension(xml : TXmlBuilder; name : string; elem : TFhirExtension);
    procedure ComposeNarrative(xml : TXmlBuilder; name : string; elem : TFhirNarrative);
    procedure ComposePeriod(xml : TXmlBuilder; name : string; elem : TFhirPeriod);
    procedure ComposeCoding(xml : TXmlBuilder; name : string; elem : TFhirCoding);
    procedure ComposeRange(xml : TXmlBuilder; name : string; elem : TFhirRange);
    procedure ComposeQuantity(xml : TXmlBuilder; name : string; elem : TFhirQuantity);
    procedure ComposeAttachment(xml : TXmlBuilder; name : string; elem : TFhirAttachment);
    procedure ComposeRatio(xml : TXmlBuilder; name : string; elem : TFhirRatio);
    procedure ComposeSampledData(xml : TXmlBuilder; name : string; elem : TFhirSampledData);
    procedure ComposeReference(xml : TXmlBuilder; name : string; elem : TFhirReference);
    procedure ComposeCodeableConcept(xml : TXmlBuilder; name : string; elem : TFhirCodeableConcept);
    procedure ComposeIdentifier(xml : TXmlBuilder; name : string; elem : TFhirIdentifier);
    procedure ComposeTimingRepeat(xml : TXmlBuilder; name : string; elem : TFhirTimingRepeat);
    procedure ComposeTiming(xml : TXmlBuilder; name : string; elem : TFhirTiming);
    procedure ComposeAddress(xml : TXmlBuilder; name : string; elem : TFhirAddress);
    procedure ComposeHumanName(xml : TXmlBuilder; name : string; elem : TFhirHumanName);
    procedure ComposeContactPoint(xml : TXmlBuilder; name : string; elem : TFhirContactPoint);
    procedure ComposeAge(xml : TXmlBuilder; name : string; elem : TFhirAge);
    procedure ComposeCount(xml : TXmlBuilder; name : string; elem : TFhirCount);
    procedure ComposeMoney(xml : TXmlBuilder; name : string; elem : TFhirMoney);
    procedure ComposeDistance(xml : TXmlBuilder; name : string; elem : TFhirDistance);
    procedure ComposeDuration(xml : TXmlBuilder; name : string; elem : TFhirDuration);

    procedure ComposeAdverseReactionSymptom(xml : TXmlBuilder; name : string; elem : TFhirAdverseReactionSymptom);
    procedure ComposeAdverseReactionExposure(xml : TXmlBuilder; name : string; elem : TFhirAdverseReactionExposure);
    procedure ComposeAdverseReaction(xml : TXmlBuilder; name : string; elem : TFhirAdverseReaction);
    procedure ComposeAlert(xml : TXmlBuilder; name : string; elem : TFhirAlert);
    procedure ComposeAllergyIntolerance(xml : TXmlBuilder; name : string; elem : TFhirAllergyIntolerance);
    procedure ComposeAppointmentParticipant(xml : TXmlBuilder; name : string; elem : TFhirAppointmentParticipant);
    procedure ComposeAppointment(xml : TXmlBuilder; name : string; elem : TFhirAppointment);
    procedure ComposeAppointmentResponse(xml : TXmlBuilder; name : string; elem : TFhirAppointmentResponse);
    procedure ComposeAvailability(xml : TXmlBuilder; name : string; elem : TFhirAvailability);
    procedure ComposeCarePlanParticipant(xml : TXmlBuilder; name : string; elem : TFhirCarePlanParticipant);
    procedure ComposeCarePlanGoal(xml : TXmlBuilder; name : string; elem : TFhirCarePlanGoal);
    procedure ComposeCarePlanActivity(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivity);
    procedure ComposeCarePlanActivitySimple(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivitySimple);
    procedure ComposeCarePlan(xml : TXmlBuilder; name : string; elem : TFhirCarePlan);
    procedure ComposeCompositionAttester(xml : TXmlBuilder; name : string; elem : TFhirCompositionAttester);
    procedure ComposeCompositionEvent(xml : TXmlBuilder; name : string; elem : TFhirCompositionEvent);
    procedure ComposeCompositionSection(xml : TXmlBuilder; name : string; elem : TFhirCompositionSection);
    procedure ComposeComposition(xml : TXmlBuilder; name : string; elem : TFhirComposition);
    procedure ComposeConceptMapElement(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElement);
    procedure ComposeConceptMapElementDependsOn(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElementDependsOn);
    procedure ComposeConceptMapElementMap(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElementMap);
    procedure ComposeConceptMap(xml : TXmlBuilder; name : string; elem : TFhirConceptMap);
    procedure ComposeConditionStage(xml : TXmlBuilder; name : string; elem : TFhirConditionStage);
    procedure ComposeConditionEvidence(xml : TXmlBuilder; name : string; elem : TFhirConditionEvidence);
    procedure ComposeConditionLocation(xml : TXmlBuilder; name : string; elem : TFhirConditionLocation);
    procedure ComposeConditionRelatedItem(xml : TXmlBuilder; name : string; elem : TFhirConditionRelatedItem);
    procedure ComposeCondition(xml : TXmlBuilder; name : string; elem : TFhirCondition);
    procedure ComposeConformanceSoftware(xml : TXmlBuilder; name : string; elem : TFhirConformanceSoftware);
    procedure ComposeConformanceImplementation(xml : TXmlBuilder; name : string; elem : TFhirConformanceImplementation);
    procedure ComposeConformanceRest(xml : TXmlBuilder; name : string; elem : TFhirConformanceRest);
    procedure ComposeConformanceRestSecurity(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurity);
    procedure ComposeConformanceRestSecurityCertificate(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurityCertificate);
    procedure ComposeConformanceRestResource(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResource);
    procedure ComposeConformanceRestResourceInteraction(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceInteraction);
    procedure ComposeConformanceRestResourceSearchParam(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceSearchParam);
    procedure ComposeConformanceRestInteraction(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestInteraction);
    procedure ComposeConformanceRestOperation(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestOperation);
    procedure ComposeConformanceMessaging(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessaging);
    procedure ComposeConformanceMessagingEvent(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessagingEvent);
    procedure ComposeConformanceDocument(xml : TXmlBuilder; name : string; elem : TFhirConformanceDocument);
    procedure ComposeConformance(xml : TXmlBuilder; name : string; elem : TFhirConformance);
    procedure ComposeContraindicationMitigation(xml : TXmlBuilder; name : string; elem : TFhirContraindicationMitigation);
    procedure ComposeContraindication(xml : TXmlBuilder; name : string; elem : TFhirContraindication);
    procedure ComposeDataElementBinding(xml : TXmlBuilder; name : string; elem : TFhirDataElementBinding);
    procedure ComposeDataElementMapping(xml : TXmlBuilder; name : string; elem : TFhirDataElementMapping);
    procedure ComposeDataElement(xml : TXmlBuilder; name : string; elem : TFhirDataElement);
    procedure ComposeDevice(xml : TXmlBuilder; name : string; elem : TFhirDevice);
    procedure ComposeDeviceObservationReportVirtualDevice(xml : TXmlBuilder; name : string; elem : TFhirDeviceObservationReportVirtualDevice);
    procedure ComposeDeviceObservationReportVirtualDeviceChannel(xml : TXmlBuilder; name : string; elem : TFhirDeviceObservationReportVirtualDeviceChannel);
    procedure ComposeDeviceObservationReportVirtualDeviceChannelMetric(xml : TXmlBuilder; name : string; elem : TFhirDeviceObservationReportVirtualDeviceChannelMetric);
    procedure ComposeDeviceObservationReport(xml : TXmlBuilder; name : string; elem : TFhirDeviceObservationReport);
    procedure ComposeDiagnosticOrderEvent(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderEvent);
    procedure ComposeDiagnosticOrderItem(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderItem);
    procedure ComposeDiagnosticOrder(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrder);
    procedure ComposeDiagnosticReportImage(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReportImage);
    procedure ComposeDiagnosticReport(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReport);
    procedure ComposeDocumentManifest(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifest);
    procedure ComposeDocumentReferenceRelatesTo(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceRelatesTo);
    procedure ComposeDocumentReferenceService(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceService);
    procedure ComposeDocumentReferenceServiceParameter(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceServiceParameter);
    procedure ComposeDocumentReferenceContext(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContext);
    procedure ComposeDocumentReference(xml : TXmlBuilder; name : string; elem : TFhirDocumentReference);
    procedure ComposeEncounterParticipant(xml : TXmlBuilder; name : string; elem : TFhirEncounterParticipant);
    procedure ComposeEncounterHospitalization(xml : TXmlBuilder; name : string; elem : TFhirEncounterHospitalization);
    procedure ComposeEncounterHospitalizationAccomodation(xml : TXmlBuilder; name : string; elem : TFhirEncounterHospitalizationAccomodation);
    procedure ComposeEncounterLocation(xml : TXmlBuilder; name : string; elem : TFhirEncounterLocation);
    procedure ComposeEncounter(xml : TXmlBuilder; name : string; elem : TFhirEncounter);
    procedure ComposeFamilyHistoryRelation(xml : TXmlBuilder; name : string; elem : TFhirFamilyHistoryRelation);
    procedure ComposeFamilyHistoryRelationCondition(xml : TXmlBuilder; name : string; elem : TFhirFamilyHistoryRelationCondition);
    procedure ComposeFamilyHistory(xml : TXmlBuilder; name : string; elem : TFhirFamilyHistory);
    procedure ComposeGroupCharacteristic(xml : TXmlBuilder; name : string; elem : TFhirGroupCharacteristic);
    procedure ComposeGroup(xml : TXmlBuilder; name : string; elem : TFhirGroup);
    procedure ComposeImagingStudySeries(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeries);
    procedure ComposeImagingStudySeriesInstance(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeriesInstance);
    procedure ComposeImagingStudy(xml : TXmlBuilder; name : string; elem : TFhirImagingStudy);
    procedure ComposeImmunizationExplanation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationExplanation);
    procedure ComposeImmunizationReaction(xml : TXmlBuilder; name : string; elem : TFhirImmunizationReaction);
    procedure ComposeImmunizationVaccinationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationVaccinationProtocol);
    procedure ComposeImmunization(xml : TXmlBuilder; name : string; elem : TFhirImmunization);
    procedure ComposeImmunizationRecommendationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendation);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
    procedure ComposeImmunizationRecommendationRecommendationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol);
    procedure ComposeImmunizationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendation);
    procedure ComposeListEntry(xml : TXmlBuilder; name : string; elem : TFhirListEntry);
    procedure ComposeList(xml : TXmlBuilder; name : string; elem : TFhirList);
    procedure ComposeLocationPosition(xml : TXmlBuilder; name : string; elem : TFhirLocationPosition);
    procedure ComposeLocation(xml : TXmlBuilder; name : string; elem : TFhirLocation);
    procedure ComposeMedia(xml : TXmlBuilder; name : string; elem : TFhirMedia);
    procedure ComposeMedicationProduct(xml : TXmlBuilder; name : string; elem : TFhirMedicationProduct);
    procedure ComposeMedicationProductIngredient(xml : TXmlBuilder; name : string; elem : TFhirMedicationProductIngredient);
    procedure ComposeMedicationPackage(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackage);
    procedure ComposeMedicationPackageContent(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackageContent);
    procedure ComposeMedication(xml : TXmlBuilder; name : string; elem : TFhirMedication);
    procedure ComposeMedicationAdministrationDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministrationDosage);
    procedure ComposeMedicationAdministration(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministration);
    procedure ComposeMedicationDispenseDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseDispense);
    procedure ComposeMedicationDispenseDispenseDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseDispenseDosage);
    procedure ComposeMedicationDispenseSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseSubstitution);
    procedure ComposeMedicationDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispense);
    procedure ComposeMedicationPrescriptionDosageInstruction(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionDosageInstruction);
    procedure ComposeMedicationPrescriptionDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionDispense);
    procedure ComposeMedicationPrescriptionSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionSubstitution);
    procedure ComposeMedicationPrescription(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescription);
    procedure ComposeMedicationStatementDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatementDosage);
    procedure ComposeMedicationStatement(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatement);
    procedure ComposeMessageHeaderResponse(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderResponse);
    procedure ComposeMessageHeaderSource(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderSource);
    procedure ComposeMessageHeaderDestination(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderDestination);
    procedure ComposeMessageHeader(xml : TXmlBuilder; name : string; elem : TFhirMessageHeader);
    procedure ComposeNamespaceUniqueId(xml : TXmlBuilder; name : string; elem : TFhirNamespaceUniqueId);
    procedure ComposeNamespaceContact(xml : TXmlBuilder; name : string; elem : TFhirNamespaceContact);
    procedure ComposeNamespace(xml : TXmlBuilder; name : string; elem : TFhirNamespace);
    procedure ComposeNutritionOrderItem(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderItem);
    procedure ComposeNutritionOrderItemOralDiet(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderItemOralDiet);
    procedure ComposeNutritionOrderItemSupplement(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderItemSupplement);
    procedure ComposeNutritionOrderItemEnteralFormula(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderItemEnteralFormula);
    procedure ComposeNutritionOrder(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrder);
    procedure ComposeObservationReferenceRange(xml : TXmlBuilder; name : string; elem : TFhirObservationReferenceRange);
    procedure ComposeObservationRelated(xml : TXmlBuilder; name : string; elem : TFhirObservationRelated);
    procedure ComposeObservation(xml : TXmlBuilder; name : string; elem : TFhirObservation);
    procedure ComposeOperationDefinitionParameter(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionParameter);
    procedure ComposeOperationDefinition(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinition);
    procedure ComposeOperationOutcomeIssue(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcomeIssue);
    procedure ComposeOperationOutcome(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcome);
    procedure ComposeOrderWhen(xml : TXmlBuilder; name : string; elem : TFhirOrderWhen);
    procedure ComposeOrder(xml : TXmlBuilder; name : string; elem : TFhirOrder);
    procedure ComposeOrderResponse(xml : TXmlBuilder; name : string; elem : TFhirOrderResponse);
    procedure ComposeOrganizationContact(xml : TXmlBuilder; name : string; elem : TFhirOrganizationContact);
    procedure ComposeOrganization(xml : TXmlBuilder; name : string; elem : TFhirOrganization);
    procedure ComposeOther(xml : TXmlBuilder; name : string; elem : TFhirOther);
    procedure ComposePatientContact(xml : TXmlBuilder; name : string; elem : TFhirPatientContact);
    procedure ComposePatientAnimal(xml : TXmlBuilder; name : string; elem : TFhirPatientAnimal);
    procedure ComposePatientLink(xml : TXmlBuilder; name : string; elem : TFhirPatientLink);
    procedure ComposePatient(xml : TXmlBuilder; name : string; elem : TFhirPatient);
    procedure ComposePractitionerQualification(xml : TXmlBuilder; name : string; elem : TFhirPractitionerQualification);
    procedure ComposePractitioner(xml : TXmlBuilder; name : string; elem : TFhirPractitioner);
    procedure ComposeProcedurePerformer(xml : TXmlBuilder; name : string; elem : TFhirProcedurePerformer);
    procedure ComposeProcedureRelatedItem(xml : TXmlBuilder; name : string; elem : TFhirProcedureRelatedItem);
    procedure ComposeProcedure(xml : TXmlBuilder; name : string; elem : TFhirProcedure);
    procedure ComposeProfileMapping(xml : TXmlBuilder; name : string; elem : TFhirProfileMapping);
    procedure ComposeProfileStructure(xml : TXmlBuilder; name : string; elem : TFhirProfileStructure);
    procedure ComposeProfileStructureSnapshot(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSnapshot);
    procedure ComposeProfileStructureSnapshotElement(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSnapshotElement);
    procedure ComposeProfileStructureSnapshotElementSlicing(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSnapshotElementSlicing);
    procedure ComposeProfileStructureSnapshotElementDefinition(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSnapshotElementDefinition);
    procedure ComposeProfileStructureSnapshotElementDefinitionType(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSnapshotElementDefinitionType);
    procedure ComposeProfileStructureSnapshotElementDefinitionConstraint(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSnapshotElementDefinitionConstraint);
    procedure ComposeProfileStructureSnapshotElementDefinitionBinding(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSnapshotElementDefinitionBinding);
    procedure ComposeProfileStructureSnapshotElementDefinitionMapping(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSnapshotElementDefinitionMapping);
    procedure ComposeProfileStructureSearchParam(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSearchParam);
    procedure ComposeProfileExtensionDefn(xml : TXmlBuilder; name : string; elem : TFhirProfileExtensionDefn);
    procedure ComposeProfile(xml : TXmlBuilder; name : string; elem : TFhirProfile);
    procedure ComposeProvenanceAgent(xml : TXmlBuilder; name : string; elem : TFhirProvenanceAgent);
    procedure ComposeProvenanceEntity(xml : TXmlBuilder; name : string; elem : TFhirProvenanceEntity);
    procedure ComposeProvenance(xml : TXmlBuilder; name : string; elem : TFhirProvenance);
    procedure ComposeQueryResponse(xml : TXmlBuilder; name : string; elem : TFhirQueryResponse);
    procedure ComposeQuery(xml : TXmlBuilder; name : string; elem : TFhirQuery);
    procedure ComposeQuestionnaireGroup(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroup);
    procedure ComposeQuestionnaireGroupQuestion(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroupQuestion);
    procedure ComposeQuestionnaire(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaire);
    procedure ComposeQuestionnaireAnswersGroup(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireAnswersGroup);
    procedure ComposeQuestionnaireAnswersGroupQuestion(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireAnswersGroupQuestion);
    procedure ComposeQuestionnaireAnswersGroupQuestionAnswer(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireAnswersGroupQuestionAnswer);
    procedure ComposeQuestionnaireAnswers(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireAnswers);
    procedure ComposeReferralRequest(xml : TXmlBuilder; name : string; elem : TFhirReferralRequest);
    procedure ComposeRelatedPerson(xml : TXmlBuilder; name : string; elem : TFhirRelatedPerson);
    procedure ComposeRiskAssessmentPrediction(xml : TXmlBuilder; name : string; elem : TFhirRiskAssessmentPrediction);
    procedure ComposeRiskAssessment(xml : TXmlBuilder; name : string; elem : TFhirRiskAssessment);
    procedure ComposeSecurityEventEvent(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventEvent);
    procedure ComposeSecurityEventParticipant(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventParticipant);
    procedure ComposeSecurityEventParticipantNetwork(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventParticipantNetwork);
    procedure ComposeSecurityEventSource(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventSource);
    procedure ComposeSecurityEventObject(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventObject);
    procedure ComposeSecurityEventObjectDetail(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventObjectDetail);
    procedure ComposeSecurityEvent(xml : TXmlBuilder; name : string; elem : TFhirSecurityEvent);
    procedure ComposeSlot(xml : TXmlBuilder; name : string; elem : TFhirSlot);
    procedure ComposeSpecimenSource(xml : TXmlBuilder; name : string; elem : TFhirSpecimenSource);
    procedure ComposeSpecimenCollection(xml : TXmlBuilder; name : string; elem : TFhirSpecimenCollection);
    procedure ComposeSpecimenTreatment(xml : TXmlBuilder; name : string; elem : TFhirSpecimenTreatment);
    procedure ComposeSpecimenContainer(xml : TXmlBuilder; name : string; elem : TFhirSpecimenContainer);
    procedure ComposeSpecimen(xml : TXmlBuilder; name : string; elem : TFhirSpecimen);
    procedure ComposeSubscriptionChannel(xml : TXmlBuilder; name : string; elem : TFhirSubscriptionChannel);
    procedure ComposeSubscriptionTag(xml : TXmlBuilder; name : string; elem : TFhirSubscriptionTag);
    procedure ComposeSubscription(xml : TXmlBuilder; name : string; elem : TFhirSubscription);
    procedure ComposeSubstanceInstance(xml : TXmlBuilder; name : string; elem : TFhirSubstanceInstance);
    procedure ComposeSubstanceIngredient(xml : TXmlBuilder; name : string; elem : TFhirSubstanceIngredient);
    procedure ComposeSubstance(xml : TXmlBuilder; name : string; elem : TFhirSubstance);
    procedure ComposeSupplyDispense(xml : TXmlBuilder; name : string; elem : TFhirSupplyDispense);
    procedure ComposeSupply(xml : TXmlBuilder; name : string; elem : TFhirSupply);
    procedure ComposeValueSetDefine(xml : TXmlBuilder; name : string; elem : TFhirValueSetDefine);
    procedure ComposeValueSetDefineConcept(xml : TXmlBuilder; name : string; elem : TFhirValueSetDefineConcept);
    procedure ComposeValueSetDefineConceptDesignation(xml : TXmlBuilder; name : string; elem : TFhirValueSetDefineConceptDesignation);
    procedure ComposeValueSetCompose(xml : TXmlBuilder; name : string; elem : TFhirValueSetCompose);
    procedure ComposeValueSetComposeInclude(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeInclude);
    procedure ComposeValueSetComposeIncludeConcept(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeConcept);
    procedure ComposeValueSetComposeIncludeFilter(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeFilter);
    procedure ComposeValueSetExpansion(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansion);
    procedure ComposeValueSetExpansionContains(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansionContains);
    procedure ComposeValueSet(xml : TXmlBuilder; name : string; elem : TFhirValueSet);
    procedure ComposeResource(xml : TXmlBuilder; statedType, id, ver : String; resource : TFhirResource; links : TFHIRAtomLinkList); override;
  end;

  TFHIRJsonParser = class (TFHIRJsonParserBase)
  protected
    procedure ParseElementProperties(jsn : TJsonObject; element : TFhirElement);
    procedure ParseBackboneElementProperties(jsn : TJsonObject; element : TFhirBackboneElement);

    procedure ParseEnum(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList; Const aNames : Array Of String); overload;
    function ParseEnum(value : string; jsn : TJsonObject; Const aNames : Array Of String) : TFHIREnum; overload;
    procedure ParseInteger(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseInteger(value : string; jsn : TJsonObject) : TFHIRInteger; overload;
    procedure ParseDateTime(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDateTime(value : string; jsn : TJsonObject) : TFHIRDateTime; overload;
    procedure ParseDate(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDate(value : string; jsn : TJsonObject) : TFHIRDate; overload;
    procedure ParseDecimal(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDecimal(value : string; jsn : TJsonObject) : TFHIRDecimal; overload;
    procedure ParseUri(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseUri(value : string; jsn : TJsonObject) : TFHIRUri; overload;
    procedure ParseBase64Binary(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseBase64Binary(value : string; jsn : TJsonObject) : TFHIRBase64Binary; overload;
    procedure ParseTime(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseTime(value : string; jsn : TJsonObject) : TFHIRTime; overload;
    procedure ParseString(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseString(value : string; jsn : TJsonObject) : TFHIRString; overload;
    procedure ParseBoolean(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseBoolean(value : string; jsn : TJsonObject) : TFHIRBoolean; overload;
    procedure ParseInstant(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseInstant(value : string; jsn : TJsonObject) : TFHIRInstant; overload;
    procedure ParseCode(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseCode(value : string; jsn : TJsonObject) : TFHIRCode; overload;
    procedure ParseId(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseId(value : string; jsn : TJsonObject) : TFHIRId; overload;
    procedure ParseOid(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseOid(value : string; jsn : TJsonObject) : TFHIROid; overload;
    procedure ParseUuid(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseUuid(value : string; jsn : TJsonObject) : TFHIRUuid; overload;

    procedure ParseResourceProperties(jsn : TJsonObject; resource : TFhirResource);

    function ParseExtension(jsn : TJsonObject) : TFhirExtension; overload;
    procedure ParseExtension(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNarrative(jsn : TJsonObject) : TFhirNarrative; overload;
    procedure ParseNarrative(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePeriod(jsn : TJsonObject) : TFhirPeriod; overload;
    procedure ParsePeriod(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoding(jsn : TJsonObject) : TFhirCoding; overload;
    procedure ParseCoding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRange(jsn : TJsonObject) : TFhirRange; overload;
    procedure ParseRange(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuantity(jsn : TJsonObject) : TFhirQuantity; overload;
    procedure ParseQuantity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAttachment(jsn : TJsonObject) : TFhirAttachment; overload;
    procedure ParseAttachment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRatio(jsn : TJsonObject) : TFhirRatio; overload;
    procedure ParseRatio(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSampledData(jsn : TJsonObject) : TFhirSampledData; overload;
    procedure ParseSampledData(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseReference(jsn : TJsonObject) : TFhirReference; overload;
    procedure ParseReference(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCodeableConcept(jsn : TJsonObject) : TFhirCodeableConcept; overload;
    procedure ParseCodeableConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseIdentifier(jsn : TJsonObject) : TFhirIdentifier; overload;
    procedure ParseIdentifier(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTimingRepeat(jsn : TJsonObject) : TFhirTimingRepeat; overload; {b\}
    procedure ParseTimingRepeat(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTiming(jsn : TJsonObject) : TFhirTiming; overload;
    procedure ParseTiming(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAddress(jsn : TJsonObject) : TFhirAddress; overload;
    procedure ParseAddress(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHumanName(jsn : TJsonObject) : TFhirHumanName; overload;
    procedure ParseHumanName(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContactPoint(jsn : TJsonObject) : TFhirContactPoint; overload;
    procedure ParseContactPoint(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAge(jsn : TJsonObject) : TFhirAge; overload;
    function ParseCount(jsn : TJsonObject) : TFhirCount; overload;
    function ParseMoney(jsn : TJsonObject) : TFhirMoney; overload;
    function ParseDistance(jsn : TJsonObject) : TFhirDistance; overload;
    function ParseDuration(jsn : TJsonObject) : TFhirDuration; overload;

    function ParseAdverseReactionSymptom(jsn : TJsonObject) : TFhirAdverseReactionSymptom; overload; {b\}
    procedure ParseAdverseReactionSymptom(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAdverseReactionExposure(jsn : TJsonObject) : TFhirAdverseReactionExposure; overload; {b\}
    procedure ParseAdverseReactionExposure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAdverseReaction(jsn : TJsonObject) : TFhirAdverseReaction; overload; {b|}
    procedure ParseAdverseReaction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAlert(jsn : TJsonObject) : TFhirAlert; overload; {b|}
    procedure ParseAlert(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAllergyIntolerance(jsn : TJsonObject) : TFhirAllergyIntolerance; overload; {b|}
    procedure ParseAllergyIntolerance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAppointmentParticipant(jsn : TJsonObject) : TFhirAppointmentParticipant; overload; {b\}
    procedure ParseAppointmentParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAppointment(jsn : TJsonObject) : TFhirAppointment; overload; {b|}
    procedure ParseAppointment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAppointmentResponse(jsn : TJsonObject) : TFhirAppointmentResponse; overload; {b|}
    procedure ParseAppointmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAvailability(jsn : TJsonObject) : TFhirAvailability; overload; {b|}
    procedure ParseAvailability(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanParticipant(jsn : TJsonObject) : TFhirCarePlanParticipant; overload; {b\}
    procedure ParseCarePlanParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanGoal(jsn : TJsonObject) : TFhirCarePlanGoal; overload; {b\}
    procedure ParseCarePlanGoal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanActivity(jsn : TJsonObject) : TFhirCarePlanActivity; overload; {b\}
    procedure ParseCarePlanActivity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanActivitySimple(jsn : TJsonObject) : TFhirCarePlanActivitySimple; overload; {b\}
    procedure ParseCarePlanActivitySimple(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlan(jsn : TJsonObject) : TFhirCarePlan; overload; {b|}
    procedure ParseCarePlan(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompositionAttester(jsn : TJsonObject) : TFhirCompositionAttester; overload; {b\}
    procedure ParseCompositionAttester(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompositionEvent(jsn : TJsonObject) : TFhirCompositionEvent; overload; {b\}
    procedure ParseCompositionEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompositionSection(jsn : TJsonObject) : TFhirCompositionSection; overload; {b\}
    procedure ParseCompositionSection(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseComposition(jsn : TJsonObject) : TFhirComposition; overload; {b|}
    procedure ParseComposition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapElement(jsn : TJsonObject) : TFhirConceptMapElement; overload; {b\}
    procedure ParseConceptMapElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapElementDependsOn(jsn : TJsonObject) : TFhirConceptMapElementDependsOn; overload; {b\}
    procedure ParseConceptMapElementDependsOn(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapElementMap(jsn : TJsonObject) : TFhirConceptMapElementMap; overload; {b\}
    procedure ParseConceptMapElementMap(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMap(jsn : TJsonObject) : TFhirConceptMap; overload; {b|}
    procedure ParseConceptMap(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConditionStage(jsn : TJsonObject) : TFhirConditionStage; overload; {b\}
    procedure ParseConditionStage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConditionEvidence(jsn : TJsonObject) : TFhirConditionEvidence; overload; {b\}
    procedure ParseConditionEvidence(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConditionLocation(jsn : TJsonObject) : TFhirConditionLocation; overload; {b\}
    procedure ParseConditionLocation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConditionRelatedItem(jsn : TJsonObject) : TFhirConditionRelatedItem; overload; {b\}
    procedure ParseConditionRelatedItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCondition(jsn : TJsonObject) : TFhirCondition; overload; {b|}
    procedure ParseCondition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceSoftware(jsn : TJsonObject) : TFhirConformanceSoftware; overload; {b\}
    procedure ParseConformanceSoftware(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceImplementation(jsn : TJsonObject) : TFhirConformanceImplementation; overload; {b\}
    procedure ParseConformanceImplementation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRest(jsn : TJsonObject) : TFhirConformanceRest; overload; {b\}
    procedure ParseConformanceRest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestSecurity(jsn : TJsonObject) : TFhirConformanceRestSecurity; overload; {b\}
    procedure ParseConformanceRestSecurity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestSecurityCertificate(jsn : TJsonObject) : TFhirConformanceRestSecurityCertificate; overload; {b\}
    procedure ParseConformanceRestSecurityCertificate(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestResource(jsn : TJsonObject) : TFhirConformanceRestResource; overload; {b\}
    procedure ParseConformanceRestResource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestResourceInteraction(jsn : TJsonObject) : TFhirConformanceRestResourceInteraction; overload; {b\}
    procedure ParseConformanceRestResourceInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestResourceSearchParam(jsn : TJsonObject) : TFhirConformanceRestResourceSearchParam; overload; {b\}
    procedure ParseConformanceRestResourceSearchParam(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestInteraction(jsn : TJsonObject) : TFhirConformanceRestInteraction; overload; {b\}
    procedure ParseConformanceRestInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestOperation(jsn : TJsonObject) : TFhirConformanceRestOperation; overload; {b\}
    procedure ParseConformanceRestOperation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceMessaging(jsn : TJsonObject) : TFhirConformanceMessaging; overload; {b\}
    procedure ParseConformanceMessaging(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceMessagingEvent(jsn : TJsonObject) : TFhirConformanceMessagingEvent; overload; {b\}
    procedure ParseConformanceMessagingEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceDocument(jsn : TJsonObject) : TFhirConformanceDocument; overload; {b\}
    procedure ParseConformanceDocument(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformance(jsn : TJsonObject) : TFhirConformance; overload; {b|}
    procedure ParseConformance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContraindicationMitigation(jsn : TJsonObject) : TFhirContraindicationMitigation; overload; {b\}
    procedure ParseContraindicationMitigation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContraindication(jsn : TJsonObject) : TFhirContraindication; overload; {b|}
    procedure ParseContraindication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDataElementBinding(jsn : TJsonObject) : TFhirDataElementBinding; overload; {b\}
    procedure ParseDataElementBinding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDataElementMapping(jsn : TJsonObject) : TFhirDataElementMapping; overload; {b\}
    procedure ParseDataElementMapping(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDataElement(jsn : TJsonObject) : TFhirDataElement; overload; {b|}
    procedure ParseDataElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDevice(jsn : TJsonObject) : TFhirDevice; overload; {b|}
    procedure ParseDevice(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceObservationReportVirtualDevice(jsn : TJsonObject) : TFhirDeviceObservationReportVirtualDevice; overload; {b\}
    procedure ParseDeviceObservationReportVirtualDevice(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceObservationReportVirtualDeviceChannel(jsn : TJsonObject) : TFhirDeviceObservationReportVirtualDeviceChannel; overload; {b\}
    procedure ParseDeviceObservationReportVirtualDeviceChannel(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceObservationReportVirtualDeviceChannelMetric(jsn : TJsonObject) : TFhirDeviceObservationReportVirtualDeviceChannelMetric; overload; {b\}
    procedure ParseDeviceObservationReportVirtualDeviceChannelMetric(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceObservationReport(jsn : TJsonObject) : TFhirDeviceObservationReport; overload; {b|}
    procedure ParseDeviceObservationReport(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticOrderEvent(jsn : TJsonObject) : TFhirDiagnosticOrderEvent; overload; {b\}
    procedure ParseDiagnosticOrderEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticOrderItem(jsn : TJsonObject) : TFhirDiagnosticOrderItem; overload; {b\}
    procedure ParseDiagnosticOrderItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticOrder(jsn : TJsonObject) : TFhirDiagnosticOrder; overload; {b|}
    procedure ParseDiagnosticOrder(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticReportImage(jsn : TJsonObject) : TFhirDiagnosticReportImage; overload; {b\}
    procedure ParseDiagnosticReportImage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticReport(jsn : TJsonObject) : TFhirDiagnosticReport; overload; {b|}
    procedure ParseDiagnosticReport(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentManifest(jsn : TJsonObject) : TFhirDocumentManifest; overload; {b|}
    procedure ParseDocumentManifest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceRelatesTo(jsn : TJsonObject) : TFhirDocumentReferenceRelatesTo; overload; {b\}
    procedure ParseDocumentReferenceRelatesTo(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceService(jsn : TJsonObject) : TFhirDocumentReferenceService; overload; {b\}
    procedure ParseDocumentReferenceService(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceServiceParameter(jsn : TJsonObject) : TFhirDocumentReferenceServiceParameter; overload; {b\}
    procedure ParseDocumentReferenceServiceParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceContext(jsn : TJsonObject) : TFhirDocumentReferenceContext; overload; {b\}
    procedure ParseDocumentReferenceContext(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReference(jsn : TJsonObject) : TFhirDocumentReference; overload; {b|}
    procedure ParseDocumentReference(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterParticipant(jsn : TJsonObject) : TFhirEncounterParticipant; overload; {b\}
    procedure ParseEncounterParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterHospitalization(jsn : TJsonObject) : TFhirEncounterHospitalization; overload; {b\}
    procedure ParseEncounterHospitalization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterHospitalizationAccomodation(jsn : TJsonObject) : TFhirEncounterHospitalizationAccomodation; overload; {b\}
    procedure ParseEncounterHospitalizationAccomodation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterLocation(jsn : TJsonObject) : TFhirEncounterLocation; overload; {b\}
    procedure ParseEncounterLocation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounter(jsn : TJsonObject) : TFhirEncounter; overload; {b|}
    procedure ParseEncounter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseFamilyHistoryRelation(jsn : TJsonObject) : TFhirFamilyHistoryRelation; overload; {b\}
    procedure ParseFamilyHistoryRelation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseFamilyHistoryRelationCondition(jsn : TJsonObject) : TFhirFamilyHistoryRelationCondition; overload; {b\}
    procedure ParseFamilyHistoryRelationCondition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseFamilyHistory(jsn : TJsonObject) : TFhirFamilyHistory; overload; {b|}
    procedure ParseFamilyHistory(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGroupCharacteristic(jsn : TJsonObject) : TFhirGroupCharacteristic; overload; {b\}
    procedure ParseGroupCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGroup(jsn : TJsonObject) : TFhirGroup; overload; {b|}
    procedure ParseGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingStudySeries(jsn : TJsonObject) : TFhirImagingStudySeries; overload; {b\}
    procedure ParseImagingStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingStudySeriesInstance(jsn : TJsonObject) : TFhirImagingStudySeriesInstance; overload; {b\}
    procedure ParseImagingStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingStudy(jsn : TJsonObject) : TFhirImagingStudy; overload; {b|}
    procedure ParseImagingStudy(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationExplanation(jsn : TJsonObject) : TFhirImmunizationExplanation; overload; {b\}
    procedure ParseImmunizationExplanation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationReaction(jsn : TJsonObject) : TFhirImmunizationReaction; overload; {b\}
    procedure ParseImmunizationReaction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationVaccinationProtocol(jsn : TJsonObject) : TFhirImmunizationVaccinationProtocol; overload; {b\}
    procedure ParseImmunizationVaccinationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunization(jsn : TJsonObject) : TFhirImmunization; overload; {b|}
    procedure ParseImmunization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendation; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationDateCriterion; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationProtocol; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendation; overload; {b|}
    procedure ParseImmunizationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseListEntry(jsn : TJsonObject) : TFhirListEntry; overload; {b\}
    procedure ParseListEntry(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseList(jsn : TJsonObject) : TFhirList; overload; {b|}
    procedure ParseList(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseLocationPosition(jsn : TJsonObject) : TFhirLocationPosition; overload; {b\}
    procedure ParseLocationPosition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseLocation(jsn : TJsonObject) : TFhirLocation; overload; {b|}
    procedure ParseLocation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedia(jsn : TJsonObject) : TFhirMedia; overload; {b|}
    procedure ParseMedia(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationProduct(jsn : TJsonObject) : TFhirMedicationProduct; overload; {b\}
    procedure ParseMedicationProduct(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationProductIngredient(jsn : TJsonObject) : TFhirMedicationProductIngredient; overload; {b\}
    procedure ParseMedicationProductIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPackage(jsn : TJsonObject) : TFhirMedicationPackage; overload; {b\}
    procedure ParseMedicationPackage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPackageContent(jsn : TJsonObject) : TFhirMedicationPackageContent; overload; {b\}
    procedure ParseMedicationPackageContent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedication(jsn : TJsonObject) : TFhirMedication; overload; {b|}
    procedure ParseMedication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationAdministrationDosage(jsn : TJsonObject) : TFhirMedicationAdministrationDosage; overload; {b\}
    procedure ParseMedicationAdministrationDosage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationAdministration(jsn : TJsonObject) : TFhirMedicationAdministration; overload; {b|}
    procedure ParseMedicationAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispenseDispense(jsn : TJsonObject) : TFhirMedicationDispenseDispense; overload; {b\}
    procedure ParseMedicationDispenseDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispenseDispenseDosage(jsn : TJsonObject) : TFhirMedicationDispenseDispenseDosage; overload; {b\}
    procedure ParseMedicationDispenseDispenseDosage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispenseSubstitution(jsn : TJsonObject) : TFhirMedicationDispenseSubstitution; overload; {b\}
    procedure ParseMedicationDispenseSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispense(jsn : TJsonObject) : TFhirMedicationDispense; overload; {b|}
    procedure ParseMedicationDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPrescriptionDosageInstruction(jsn : TJsonObject) : TFhirMedicationPrescriptionDosageInstruction; overload; {b\}
    procedure ParseMedicationPrescriptionDosageInstruction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPrescriptionDispense(jsn : TJsonObject) : TFhirMedicationPrescriptionDispense; overload; {b\}
    procedure ParseMedicationPrescriptionDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPrescriptionSubstitution(jsn : TJsonObject) : TFhirMedicationPrescriptionSubstitution; overload; {b\}
    procedure ParseMedicationPrescriptionSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPrescription(jsn : TJsonObject) : TFhirMedicationPrescription; overload; {b|}
    procedure ParseMedicationPrescription(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationStatementDosage(jsn : TJsonObject) : TFhirMedicationStatementDosage; overload; {b\}
    procedure ParseMedicationStatementDosage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationStatement(jsn : TJsonObject) : TFhirMedicationStatement; overload; {b|}
    procedure ParseMedicationStatement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeaderResponse(jsn : TJsonObject) : TFhirMessageHeaderResponse; overload; {b\}
    procedure ParseMessageHeaderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeaderSource(jsn : TJsonObject) : TFhirMessageHeaderSource; overload; {b\}
    procedure ParseMessageHeaderSource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeaderDestination(jsn : TJsonObject) : TFhirMessageHeaderDestination; overload; {b\}
    procedure ParseMessageHeaderDestination(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeader(jsn : TJsonObject) : TFhirMessageHeader; overload; {b|}
    procedure ParseMessageHeader(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNamespaceUniqueId(jsn : TJsonObject) : TFhirNamespaceUniqueId; overload; {b\}
    procedure ParseNamespaceUniqueId(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNamespaceContact(jsn : TJsonObject) : TFhirNamespaceContact; overload; {b\}
    procedure ParseNamespaceContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNamespace(jsn : TJsonObject) : TFhirNamespace; overload; {b|}
    procedure ParseNamespace(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderItem(jsn : TJsonObject) : TFhirNutritionOrderItem; overload; {b\}
    procedure ParseNutritionOrderItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderItemOralDiet(jsn : TJsonObject) : TFhirNutritionOrderItemOralDiet; overload; {b\}
    procedure ParseNutritionOrderItemOralDiet(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderItemSupplement(jsn : TJsonObject) : TFhirNutritionOrderItemSupplement; overload; {b\}
    procedure ParseNutritionOrderItemSupplement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderItemEnteralFormula(jsn : TJsonObject) : TFhirNutritionOrderItemEnteralFormula; overload; {b\}
    procedure ParseNutritionOrderItemEnteralFormula(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrder(jsn : TJsonObject) : TFhirNutritionOrder; overload; {b|}
    procedure ParseNutritionOrder(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservationReferenceRange(jsn : TJsonObject) : TFhirObservationReferenceRange; overload; {b\}
    procedure ParseObservationReferenceRange(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservationRelated(jsn : TJsonObject) : TFhirObservationRelated; overload; {b\}
    procedure ParseObservationRelated(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservation(jsn : TJsonObject) : TFhirObservation; overload; {b|}
    procedure ParseObservation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationDefinitionParameter(jsn : TJsonObject) : TFhirOperationDefinitionParameter; overload; {b\}
    procedure ParseOperationDefinitionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationDefinition(jsn : TJsonObject) : TFhirOperationDefinition; overload; {b|}
    procedure ParseOperationDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationOutcomeIssue(jsn : TJsonObject) : TFhirOperationOutcomeIssue; overload; {b\}
    procedure ParseOperationOutcomeIssue(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationOutcome(jsn : TJsonObject) : TFhirOperationOutcome; overload; {b|}
    procedure ParseOperationOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrderWhen(jsn : TJsonObject) : TFhirOrderWhen; overload; {b\}
    procedure ParseOrderWhen(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrder(jsn : TJsonObject) : TFhirOrder; overload; {b|}
    procedure ParseOrder(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrderResponse(jsn : TJsonObject) : TFhirOrderResponse; overload; {b|}
    procedure ParseOrderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrganizationContact(jsn : TJsonObject) : TFhirOrganizationContact; overload; {b\}
    procedure ParseOrganizationContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrganization(jsn : TJsonObject) : TFhirOrganization; overload; {b|}
    procedure ParseOrganization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOther(jsn : TJsonObject) : TFhirOther; overload; {b|}
    procedure ParseOther(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientContact(jsn : TJsonObject) : TFhirPatientContact; overload; {b\}
    procedure ParsePatientContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientAnimal(jsn : TJsonObject) : TFhirPatientAnimal; overload; {b\}
    procedure ParsePatientAnimal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientLink(jsn : TJsonObject) : TFhirPatientLink; overload; {b\}
    procedure ParsePatientLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatient(jsn : TJsonObject) : TFhirPatient; overload; {b|}
    procedure ParsePatient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePractitionerQualification(jsn : TJsonObject) : TFhirPractitionerQualification; overload; {b\}
    procedure ParsePractitionerQualification(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePractitioner(jsn : TJsonObject) : TFhirPractitioner; overload; {b|}
    procedure ParsePractitioner(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedurePerformer(jsn : TJsonObject) : TFhirProcedurePerformer; overload; {b\}
    procedure ParseProcedurePerformer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedureRelatedItem(jsn : TJsonObject) : TFhirProcedureRelatedItem; overload; {b\}
    procedure ParseProcedureRelatedItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedure(jsn : TJsonObject) : TFhirProcedure; overload; {b|}
    procedure ParseProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileMapping(jsn : TJsonObject) : TFhirProfileMapping; overload; {b\}
    procedure ParseProfileMapping(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructure(jsn : TJsonObject) : TFhirProfileStructure; overload; {b\}
    procedure ParseProfileStructure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructureSnapshot(jsn : TJsonObject) : TFhirProfileStructureSnapshot; overload; {b\}
    procedure ParseProfileStructureSnapshot(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructureSnapshotElement(jsn : TJsonObject) : TFhirProfileStructureSnapshotElement; overload; {b\}
    procedure ParseProfileStructureSnapshotElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructureSnapshotElementSlicing(jsn : TJsonObject) : TFhirProfileStructureSnapshotElementSlicing; overload; {b\}
    procedure ParseProfileStructureSnapshotElementSlicing(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructureSnapshotElementDefinition(jsn : TJsonObject) : TFhirProfileStructureSnapshotElementDefinition; overload; {b\}
    procedure ParseProfileStructureSnapshotElementDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructureSnapshotElementDefinitionType(jsn : TJsonObject) : TFhirProfileStructureSnapshotElementDefinitionType; overload; {b\}
    procedure ParseProfileStructureSnapshotElementDefinitionType(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructureSnapshotElementDefinitionConstraint(jsn : TJsonObject) : TFhirProfileStructureSnapshotElementDefinitionConstraint; overload; {b\}
    procedure ParseProfileStructureSnapshotElementDefinitionConstraint(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructureSnapshotElementDefinitionBinding(jsn : TJsonObject) : TFhirProfileStructureSnapshotElementDefinitionBinding; overload; {b\}
    procedure ParseProfileStructureSnapshotElementDefinitionBinding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructureSnapshotElementDefinitionMapping(jsn : TJsonObject) : TFhirProfileStructureSnapshotElementDefinitionMapping; overload; {b\}
    procedure ParseProfileStructureSnapshotElementDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructureSearchParam(jsn : TJsonObject) : TFhirProfileStructureSearchParam; overload; {b\}
    procedure ParseProfileStructureSearchParam(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileExtensionDefn(jsn : TJsonObject) : TFhirProfileExtensionDefn; overload; {b\}
    procedure ParseProfileExtensionDefn(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfile(jsn : TJsonObject) : TFhirProfile; overload; {b|}
    procedure ParseProfile(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenanceAgent(jsn : TJsonObject) : TFhirProvenanceAgent; overload; {b\}
    procedure ParseProvenanceAgent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenanceEntity(jsn : TJsonObject) : TFhirProvenanceEntity; overload; {b\}
    procedure ParseProvenanceEntity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenance(jsn : TJsonObject) : TFhirProvenance; overload; {b|}
    procedure ParseProvenance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQueryResponse(jsn : TJsonObject) : TFhirQueryResponse; overload; {b\}
    procedure ParseQueryResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuery(jsn : TJsonObject) : TFhirQuery; overload; {b|}
    procedure ParseQuery(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireGroup(jsn : TJsonObject) : TFhirQuestionnaireGroup; overload; {b\}
    procedure ParseQuestionnaireGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireGroupQuestion; overload; {b\}
    procedure ParseQuestionnaireGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaire(jsn : TJsonObject) : TFhirQuestionnaire; overload; {b|}
    procedure ParseQuestionnaire(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireAnswersGroup(jsn : TJsonObject) : TFhirQuestionnaireAnswersGroup; overload; {b\}
    procedure ParseQuestionnaireAnswersGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireAnswersGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireAnswersGroupQuestion; overload; {b\}
    procedure ParseQuestionnaireAnswersGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireAnswersGroupQuestionAnswer(jsn : TJsonObject) : TFhirQuestionnaireAnswersGroupQuestionAnswer; overload; {b\}
    procedure ParseQuestionnaireAnswersGroupQuestionAnswer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireAnswers(jsn : TJsonObject) : TFhirQuestionnaireAnswers; overload; {b|}
    procedure ParseQuestionnaireAnswers(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseReferralRequest(jsn : TJsonObject) : TFhirReferralRequest; overload; {b|}
    procedure ParseReferralRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRelatedPerson(jsn : TJsonObject) : TFhirRelatedPerson; overload; {b|}
    procedure ParseRelatedPerson(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRiskAssessmentPrediction(jsn : TJsonObject) : TFhirRiskAssessmentPrediction; overload; {b\}
    procedure ParseRiskAssessmentPrediction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRiskAssessment(jsn : TJsonObject) : TFhirRiskAssessment; overload; {b|}
    procedure ParseRiskAssessment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSecurityEventEvent(jsn : TJsonObject) : TFhirSecurityEventEvent; overload; {b\}
    procedure ParseSecurityEventEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSecurityEventParticipant(jsn : TJsonObject) : TFhirSecurityEventParticipant; overload; {b\}
    procedure ParseSecurityEventParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSecurityEventParticipantNetwork(jsn : TJsonObject) : TFhirSecurityEventParticipantNetwork; overload; {b\}
    procedure ParseSecurityEventParticipantNetwork(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSecurityEventSource(jsn : TJsonObject) : TFhirSecurityEventSource; overload; {b\}
    procedure ParseSecurityEventSource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSecurityEventObject(jsn : TJsonObject) : TFhirSecurityEventObject; overload; {b\}
    procedure ParseSecurityEventObject(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSecurityEventObjectDetail(jsn : TJsonObject) : TFhirSecurityEventObjectDetail; overload; {b\}
    procedure ParseSecurityEventObjectDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSecurityEvent(jsn : TJsonObject) : TFhirSecurityEvent; overload; {b|}
    procedure ParseSecurityEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSlot(jsn : TJsonObject) : TFhirSlot; overload; {b|}
    procedure ParseSlot(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenSource(jsn : TJsonObject) : TFhirSpecimenSource; overload; {b\}
    procedure ParseSpecimenSource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenCollection(jsn : TJsonObject) : TFhirSpecimenCollection; overload; {b\}
    procedure ParseSpecimenCollection(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenTreatment(jsn : TJsonObject) : TFhirSpecimenTreatment; overload; {b\}
    procedure ParseSpecimenTreatment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenContainer(jsn : TJsonObject) : TFhirSpecimenContainer; overload; {b\}
    procedure ParseSpecimenContainer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimen(jsn : TJsonObject) : TFhirSpecimen; overload; {b|}
    procedure ParseSpecimen(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubscriptionChannel(jsn : TJsonObject) : TFhirSubscriptionChannel; overload; {b\}
    procedure ParseSubscriptionChannel(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubscriptionTag(jsn : TJsonObject) : TFhirSubscriptionTag; overload; {b\}
    procedure ParseSubscriptionTag(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubscription(jsn : TJsonObject) : TFhirSubscription; overload; {b|}
    procedure ParseSubscription(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceInstance(jsn : TJsonObject) : TFhirSubstanceInstance; overload; {b\}
    procedure ParseSubstanceInstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceIngredient(jsn : TJsonObject) : TFhirSubstanceIngredient; overload; {b\}
    procedure ParseSubstanceIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstance(jsn : TJsonObject) : TFhirSubstance; overload; {b|}
    procedure ParseSubstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSupplyDispense(jsn : TJsonObject) : TFhirSupplyDispense; overload; {b\}
    procedure ParseSupplyDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSupply(jsn : TJsonObject) : TFhirSupply; overload; {b|}
    procedure ParseSupply(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetDefine(jsn : TJsonObject) : TFhirValueSetDefine; overload; {b\}
    procedure ParseValueSetDefine(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetDefineConcept(jsn : TJsonObject) : TFhirValueSetDefineConcept; overload; {b\}
    procedure ParseValueSetDefineConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetDefineConceptDesignation(jsn : TJsonObject) : TFhirValueSetDefineConceptDesignation; overload; {b\}
    procedure ParseValueSetDefineConceptDesignation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetCompose(jsn : TJsonObject) : TFhirValueSetCompose; overload; {b\}
    procedure ParseValueSetCompose(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeInclude(jsn : TJsonObject) : TFhirValueSetComposeInclude; overload; {b\}
    procedure ParseValueSetComposeInclude(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeIncludeConcept(jsn : TJsonObject) : TFhirValueSetComposeIncludeConcept; overload; {b\}
    procedure ParseValueSetComposeIncludeConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeIncludeFilter(jsn : TJsonObject) : TFhirValueSetComposeIncludeFilter; overload; {b\}
    procedure ParseValueSetComposeIncludeFilter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetExpansion(jsn : TJsonObject) : TFhirValueSetExpansion; overload; {b\}
    procedure ParseValueSetExpansion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetExpansionContains(jsn : TJsonObject) : TFhirValueSetExpansionContains; overload; {b\}
    procedure ParseValueSetExpansionContains(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSet(jsn : TJsonObject) : TFhirValueSet; overload; {b|}
    procedure ParseValueSet(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseResource(jsn : TJsonObject) : TFhirResource; override;
    function ParseDataType(jsn : TJsonObject; name : String; type_ : TFHIRTypeClass) : TFHIRType; override;
  public
    function ParseFragment(jsn : TJsonObject; type_ : String) : TFhirElement;  overload;
  end;

  TFHIRJsonComposer = class (TFHIRJsonComposerBase)
  protected
    Procedure ComposeElementProperties(json : TJSONWriter; elem : TFhirElement);
    Procedure ComposeBackboneElementProperties(json : TJSONWriter; elem : TFhirBackboneElement);

    Procedure ComposeEnumValue(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
    Procedure ComposeEnumProps(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
    Procedure ComposeIntegerValue(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
    Procedure ComposeIntegerProps(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
    Procedure ComposeDateTimeValue(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
    Procedure ComposeDateTimeProps(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
    Procedure ComposeDateValue(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
    Procedure ComposeDateProps(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
    Procedure ComposeDecimalValue(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
    Procedure ComposeDecimalProps(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
    Procedure ComposeUriValue(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
    Procedure ComposeUriProps(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
    Procedure ComposeBase64BinaryValue(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
    Procedure ComposeBase64BinaryProps(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
    Procedure ComposeTimeValue(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
    Procedure ComposeTimeProps(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
    Procedure ComposeStringValue(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
    Procedure ComposeStringProps(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
    Procedure ComposeBooleanValue(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
    Procedure ComposeBooleanProps(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
    Procedure ComposeInstantValue(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
    Procedure ComposeInstantProps(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
    Procedure ComposeCodeValue(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
    Procedure ComposeCodeProps(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
    Procedure ComposeIdValue(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
    Procedure ComposeIdProps(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
    Procedure ComposeOidValue(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
    Procedure ComposeOidProps(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
    Procedure ComposeUuidValue(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
    Procedure ComposeUuidProps(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);

    Procedure ComposeResourceProperties(json : TJSONWriter; resource : TFhirResource);

    procedure ComposeExtension(json : TJSONWriter; name : string; elem : TFhirExtension);
    procedure ComposeNarrative(json : TJSONWriter; name : string; elem : TFhirNarrative);
    procedure ComposePeriod(json : TJSONWriter; name : string; elem : TFhirPeriod);
    procedure ComposeCoding(json : TJSONWriter; name : string; elem : TFhirCoding);
    procedure ComposeRange(json : TJSONWriter; name : string; elem : TFhirRange);
    procedure ComposeQuantity(json : TJSONWriter; name : string; elem : TFhirQuantity);
    procedure ComposeAttachment(json : TJSONWriter; name : string; elem : TFhirAttachment);
    procedure ComposeRatio(json : TJSONWriter; name : string; elem : TFhirRatio);
    procedure ComposeSampledData(json : TJSONWriter; name : string; elem : TFhirSampledData);
    procedure ComposeReference(json : TJSONWriter; name : string; elem : TFhirReference);
    procedure ComposeCodeableConcept(json : TJSONWriter; name : string; elem : TFhirCodeableConcept);
    procedure ComposeIdentifier(json : TJSONWriter; name : string; elem : TFhirIdentifier);
    procedure ComposeTimingRepeat(json : TJSONWriter; name : string; elem : TFhirTimingRepeat);
    procedure ComposeTiming(json : TJSONWriter; name : string; elem : TFhirTiming);
    procedure ComposeAddress(json : TJSONWriter; name : string; elem : TFhirAddress);
    procedure ComposeHumanName(json : TJSONWriter; name : string; elem : TFhirHumanName);
    procedure ComposeContactPoint(json : TJSONWriter; name : string; elem : TFhirContactPoint);
    procedure ComposeAge(json : TJSONWriter; name : string; elem : TFhirAge);
    procedure ComposeCount(json : TJSONWriter; name : string; elem : TFhirCount);
    procedure ComposeMoney(json : TJSONWriter; name : string; elem : TFhirMoney);
    procedure ComposeDistance(json : TJSONWriter; name : string; elem : TFhirDistance);
    procedure ComposeDuration(json : TJSONWriter; name : string; elem : TFhirDuration);

    procedure ComposeAdverseReactionSymptom(json : TJSONWriter; name : string; elem : TFhirAdverseReactionSymptom);
    procedure ComposeAdverseReactionExposure(json : TJSONWriter; name : string; elem : TFhirAdverseReactionExposure);
    procedure ComposeAdverseReaction(json : TJSONWriter; name : string; elem : TFhirAdverseReaction);
    procedure ComposeAlert(json : TJSONWriter; name : string; elem : TFhirAlert);
    procedure ComposeAllergyIntolerance(json : TJSONWriter; name : string; elem : TFhirAllergyIntolerance);
    procedure ComposeAppointmentParticipant(json : TJSONWriter; name : string; elem : TFhirAppointmentParticipant);
    procedure ComposeAppointment(json : TJSONWriter; name : string; elem : TFhirAppointment);
    procedure ComposeAppointmentResponse(json : TJSONWriter; name : string; elem : TFhirAppointmentResponse);
    procedure ComposeAvailability(json : TJSONWriter; name : string; elem : TFhirAvailability);
    procedure ComposeCarePlanParticipant(json : TJSONWriter; name : string; elem : TFhirCarePlanParticipant);
    procedure ComposeCarePlanGoal(json : TJSONWriter; name : string; elem : TFhirCarePlanGoal);
    procedure ComposeCarePlanActivity(json : TJSONWriter; name : string; elem : TFhirCarePlanActivity);
    procedure ComposeCarePlanActivitySimple(json : TJSONWriter; name : string; elem : TFhirCarePlanActivitySimple);
    procedure ComposeCarePlan(json : TJSONWriter; name : string; elem : TFhirCarePlan);
    procedure ComposeCompositionAttester(json : TJSONWriter; name : string; elem : TFhirCompositionAttester);
    procedure ComposeCompositionEvent(json : TJSONWriter; name : string; elem : TFhirCompositionEvent);
    procedure ComposeCompositionSection(json : TJSONWriter; name : string; elem : TFhirCompositionSection);
    procedure ComposeComposition(json : TJSONWriter; name : string; elem : TFhirComposition);
    procedure ComposeConceptMapElement(json : TJSONWriter; name : string; elem : TFhirConceptMapElement);
    procedure ComposeConceptMapElementDependsOn(json : TJSONWriter; name : string; elem : TFhirConceptMapElementDependsOn);
    procedure ComposeConceptMapElementMap(json : TJSONWriter; name : string; elem : TFhirConceptMapElementMap);
    procedure ComposeConceptMap(json : TJSONWriter; name : string; elem : TFhirConceptMap);
    procedure ComposeConditionStage(json : TJSONWriter; name : string; elem : TFhirConditionStage);
    procedure ComposeConditionEvidence(json : TJSONWriter; name : string; elem : TFhirConditionEvidence);
    procedure ComposeConditionLocation(json : TJSONWriter; name : string; elem : TFhirConditionLocation);
    procedure ComposeConditionRelatedItem(json : TJSONWriter; name : string; elem : TFhirConditionRelatedItem);
    procedure ComposeCondition(json : TJSONWriter; name : string; elem : TFhirCondition);
    procedure ComposeConformanceSoftware(json : TJSONWriter; name : string; elem : TFhirConformanceSoftware);
    procedure ComposeConformanceImplementation(json : TJSONWriter; name : string; elem : TFhirConformanceImplementation);
    procedure ComposeConformanceRest(json : TJSONWriter; name : string; elem : TFhirConformanceRest);
    procedure ComposeConformanceRestSecurity(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurity);
    procedure ComposeConformanceRestSecurityCertificate(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurityCertificate);
    procedure ComposeConformanceRestResource(json : TJSONWriter; name : string; elem : TFhirConformanceRestResource);
    procedure ComposeConformanceRestResourceInteraction(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceInteraction);
    procedure ComposeConformanceRestResourceSearchParam(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceSearchParam);
    procedure ComposeConformanceRestInteraction(json : TJSONWriter; name : string; elem : TFhirConformanceRestInteraction);
    procedure ComposeConformanceRestOperation(json : TJSONWriter; name : string; elem : TFhirConformanceRestOperation);
    procedure ComposeConformanceMessaging(json : TJSONWriter; name : string; elem : TFhirConformanceMessaging);
    procedure ComposeConformanceMessagingEvent(json : TJSONWriter; name : string; elem : TFhirConformanceMessagingEvent);
    procedure ComposeConformanceDocument(json : TJSONWriter; name : string; elem : TFhirConformanceDocument);
    procedure ComposeConformance(json : TJSONWriter; name : string; elem : TFhirConformance);
    procedure ComposeContraindicationMitigation(json : TJSONWriter; name : string; elem : TFhirContraindicationMitigation);
    procedure ComposeContraindication(json : TJSONWriter; name : string; elem : TFhirContraindication);
    procedure ComposeDataElementBinding(json : TJSONWriter; name : string; elem : TFhirDataElementBinding);
    procedure ComposeDataElementMapping(json : TJSONWriter; name : string; elem : TFhirDataElementMapping);
    procedure ComposeDataElement(json : TJSONWriter; name : string; elem : TFhirDataElement);
    procedure ComposeDevice(json : TJSONWriter; name : string; elem : TFhirDevice);
    procedure ComposeDeviceObservationReportVirtualDevice(json : TJSONWriter; name : string; elem : TFhirDeviceObservationReportVirtualDevice);
    procedure ComposeDeviceObservationReportVirtualDeviceChannel(json : TJSONWriter; name : string; elem : TFhirDeviceObservationReportVirtualDeviceChannel);
    procedure ComposeDeviceObservationReportVirtualDeviceChannelMetric(json : TJSONWriter; name : string; elem : TFhirDeviceObservationReportVirtualDeviceChannelMetric);
    procedure ComposeDeviceObservationReport(json : TJSONWriter; name : string; elem : TFhirDeviceObservationReport);
    procedure ComposeDiagnosticOrderEvent(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderEvent);
    procedure ComposeDiagnosticOrderItem(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderItem);
    procedure ComposeDiagnosticOrder(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrder);
    procedure ComposeDiagnosticReportImage(json : TJSONWriter; name : string; elem : TFhirDiagnosticReportImage);
    procedure ComposeDiagnosticReport(json : TJSONWriter; name : string; elem : TFhirDiagnosticReport);
    procedure ComposeDocumentManifest(json : TJSONWriter; name : string; elem : TFhirDocumentManifest);
    procedure ComposeDocumentReferenceRelatesTo(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceRelatesTo);
    procedure ComposeDocumentReferenceService(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceService);
    procedure ComposeDocumentReferenceServiceParameter(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceServiceParameter);
    procedure ComposeDocumentReferenceContext(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContext);
    procedure ComposeDocumentReference(json : TJSONWriter; name : string; elem : TFhirDocumentReference);
    procedure ComposeEncounterParticipant(json : TJSONWriter; name : string; elem : TFhirEncounterParticipant);
    procedure ComposeEncounterHospitalization(json : TJSONWriter; name : string; elem : TFhirEncounterHospitalization);
    procedure ComposeEncounterHospitalizationAccomodation(json : TJSONWriter; name : string; elem : TFhirEncounterHospitalizationAccomodation);
    procedure ComposeEncounterLocation(json : TJSONWriter; name : string; elem : TFhirEncounterLocation);
    procedure ComposeEncounter(json : TJSONWriter; name : string; elem : TFhirEncounter);
    procedure ComposeFamilyHistoryRelation(json : TJSONWriter; name : string; elem : TFhirFamilyHistoryRelation);
    procedure ComposeFamilyHistoryRelationCondition(json : TJSONWriter; name : string; elem : TFhirFamilyHistoryRelationCondition);
    procedure ComposeFamilyHistory(json : TJSONWriter; name : string; elem : TFhirFamilyHistory);
    procedure ComposeGroupCharacteristic(json : TJSONWriter; name : string; elem : TFhirGroupCharacteristic);
    procedure ComposeGroup(json : TJSONWriter; name : string; elem : TFhirGroup);
    procedure ComposeImagingStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingStudySeries);
    procedure ComposeImagingStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingStudySeriesInstance);
    procedure ComposeImagingStudy(json : TJSONWriter; name : string; elem : TFhirImagingStudy);
    procedure ComposeImmunizationExplanation(json : TJSONWriter; name : string; elem : TFhirImmunizationExplanation);
    procedure ComposeImmunizationReaction(json : TJSONWriter; name : string; elem : TFhirImmunizationReaction);
    procedure ComposeImmunizationVaccinationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationVaccinationProtocol);
    procedure ComposeImmunization(json : TJSONWriter; name : string; elem : TFhirImmunization);
    procedure ComposeImmunizationRecommendationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendation);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
    procedure ComposeImmunizationRecommendationRecommendationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol);
    procedure ComposeImmunizationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendation);
    procedure ComposeListEntry(json : TJSONWriter; name : string; elem : TFhirListEntry);
    procedure ComposeList(json : TJSONWriter; name : string; elem : TFhirList);
    procedure ComposeLocationPosition(json : TJSONWriter; name : string; elem : TFhirLocationPosition);
    procedure ComposeLocation(json : TJSONWriter; name : string; elem : TFhirLocation);
    procedure ComposeMedia(json : TJSONWriter; name : string; elem : TFhirMedia);
    procedure ComposeMedicationProduct(json : TJSONWriter; name : string; elem : TFhirMedicationProduct);
    procedure ComposeMedicationProductIngredient(json : TJSONWriter; name : string; elem : TFhirMedicationProductIngredient);
    procedure ComposeMedicationPackage(json : TJSONWriter; name : string; elem : TFhirMedicationPackage);
    procedure ComposeMedicationPackageContent(json : TJSONWriter; name : string; elem : TFhirMedicationPackageContent);
    procedure ComposeMedication(json : TJSONWriter; name : string; elem : TFhirMedication);
    procedure ComposeMedicationAdministrationDosage(json : TJSONWriter; name : string; elem : TFhirMedicationAdministrationDosage);
    procedure ComposeMedicationAdministration(json : TJSONWriter; name : string; elem : TFhirMedicationAdministration);
    procedure ComposeMedicationDispenseDispense(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseDispense);
    procedure ComposeMedicationDispenseDispenseDosage(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseDispenseDosage);
    procedure ComposeMedicationDispenseSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseSubstitution);
    procedure ComposeMedicationDispense(json : TJSONWriter; name : string; elem : TFhirMedicationDispense);
    procedure ComposeMedicationPrescriptionDosageInstruction(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionDosageInstruction);
    procedure ComposeMedicationPrescriptionDispense(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionDispense);
    procedure ComposeMedicationPrescriptionSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionSubstitution);
    procedure ComposeMedicationPrescription(json : TJSONWriter; name : string; elem : TFhirMedicationPrescription);
    procedure ComposeMedicationStatementDosage(json : TJSONWriter; name : string; elem : TFhirMedicationStatementDosage);
    procedure ComposeMedicationStatement(json : TJSONWriter; name : string; elem : TFhirMedicationStatement);
    procedure ComposeMessageHeaderResponse(json : TJSONWriter; name : string; elem : TFhirMessageHeaderResponse);
    procedure ComposeMessageHeaderSource(json : TJSONWriter; name : string; elem : TFhirMessageHeaderSource);
    procedure ComposeMessageHeaderDestination(json : TJSONWriter; name : string; elem : TFhirMessageHeaderDestination);
    procedure ComposeMessageHeader(json : TJSONWriter; name : string; elem : TFhirMessageHeader);
    procedure ComposeNamespaceUniqueId(json : TJSONWriter; name : string; elem : TFhirNamespaceUniqueId);
    procedure ComposeNamespaceContact(json : TJSONWriter; name : string; elem : TFhirNamespaceContact);
    procedure ComposeNamespace(json : TJSONWriter; name : string; elem : TFhirNamespace);
    procedure ComposeNutritionOrderItem(json : TJSONWriter; name : string; elem : TFhirNutritionOrderItem);
    procedure ComposeNutritionOrderItemOralDiet(json : TJSONWriter; name : string; elem : TFhirNutritionOrderItemOralDiet);
    procedure ComposeNutritionOrderItemSupplement(json : TJSONWriter; name : string; elem : TFhirNutritionOrderItemSupplement);
    procedure ComposeNutritionOrderItemEnteralFormula(json : TJSONWriter; name : string; elem : TFhirNutritionOrderItemEnteralFormula);
    procedure ComposeNutritionOrder(json : TJSONWriter; name : string; elem : TFhirNutritionOrder);
    procedure ComposeObservationReferenceRange(json : TJSONWriter; name : string; elem : TFhirObservationReferenceRange);
    procedure ComposeObservationRelated(json : TJSONWriter; name : string; elem : TFhirObservationRelated);
    procedure ComposeObservation(json : TJSONWriter; name : string; elem : TFhirObservation);
    procedure ComposeOperationDefinitionParameter(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameter);
    procedure ComposeOperationDefinition(json : TJSONWriter; name : string; elem : TFhirOperationDefinition);
    procedure ComposeOperationOutcomeIssue(json : TJSONWriter; name : string; elem : TFhirOperationOutcomeIssue);
    procedure ComposeOperationOutcome(json : TJSONWriter; name : string; elem : TFhirOperationOutcome);
    procedure ComposeOrderWhen(json : TJSONWriter; name : string; elem : TFhirOrderWhen);
    procedure ComposeOrder(json : TJSONWriter; name : string; elem : TFhirOrder);
    procedure ComposeOrderResponse(json : TJSONWriter; name : string; elem : TFhirOrderResponse);
    procedure ComposeOrganizationContact(json : TJSONWriter; name : string; elem : TFhirOrganizationContact);
    procedure ComposeOrganization(json : TJSONWriter; name : string; elem : TFhirOrganization);
    procedure ComposeOther(json : TJSONWriter; name : string; elem : TFhirOther);
    procedure ComposePatientContact(json : TJSONWriter; name : string; elem : TFhirPatientContact);
    procedure ComposePatientAnimal(json : TJSONWriter; name : string; elem : TFhirPatientAnimal);
    procedure ComposePatientLink(json : TJSONWriter; name : string; elem : TFhirPatientLink);
    procedure ComposePatient(json : TJSONWriter; name : string; elem : TFhirPatient);
    procedure ComposePractitionerQualification(json : TJSONWriter; name : string; elem : TFhirPractitionerQualification);
    procedure ComposePractitioner(json : TJSONWriter; name : string; elem : TFhirPractitioner);
    procedure ComposeProcedurePerformer(json : TJSONWriter; name : string; elem : TFhirProcedurePerformer);
    procedure ComposeProcedureRelatedItem(json : TJSONWriter; name : string; elem : TFhirProcedureRelatedItem);
    procedure ComposeProcedure(json : TJSONWriter; name : string; elem : TFhirProcedure);
    procedure ComposeProfileMapping(json : TJSONWriter; name : string; elem : TFhirProfileMapping);
    procedure ComposeProfileStructure(json : TJSONWriter; name : string; elem : TFhirProfileStructure);
    procedure ComposeProfileStructureSnapshot(json : TJSONWriter; name : string; elem : TFhirProfileStructureSnapshot);
    procedure ComposeProfileStructureSnapshotElement(json : TJSONWriter; name : string; elem : TFhirProfileStructureSnapshotElement);
    procedure ComposeProfileStructureSnapshotElementSlicing(json : TJSONWriter; name : string; elem : TFhirProfileStructureSnapshotElementSlicing);
    procedure ComposeProfileStructureSnapshotElementDefinition(json : TJSONWriter; name : string; elem : TFhirProfileStructureSnapshotElementDefinition);
    procedure ComposeProfileStructureSnapshotElementDefinitionType(json : TJSONWriter; name : string; elem : TFhirProfileStructureSnapshotElementDefinitionType);
    procedure ComposeProfileStructureSnapshotElementDefinitionConstraint(json : TJSONWriter; name : string; elem : TFhirProfileStructureSnapshotElementDefinitionConstraint);
    procedure ComposeProfileStructureSnapshotElementDefinitionBinding(json : TJSONWriter; name : string; elem : TFhirProfileStructureSnapshotElementDefinitionBinding);
    procedure ComposeProfileStructureSnapshotElementDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirProfileStructureSnapshotElementDefinitionMapping);
    procedure ComposeProfileStructureSearchParam(json : TJSONWriter; name : string; elem : TFhirProfileStructureSearchParam);
    procedure ComposeProfileExtensionDefn(json : TJSONWriter; name : string; elem : TFhirProfileExtensionDefn);
    procedure ComposeProfile(json : TJSONWriter; name : string; elem : TFhirProfile);
    procedure ComposeProvenanceAgent(json : TJSONWriter; name : string; elem : TFhirProvenanceAgent);
    procedure ComposeProvenanceEntity(json : TJSONWriter; name : string; elem : TFhirProvenanceEntity);
    procedure ComposeProvenance(json : TJSONWriter; name : string; elem : TFhirProvenance);
    procedure ComposeQueryResponse(json : TJSONWriter; name : string; elem : TFhirQueryResponse);
    procedure ComposeQuery(json : TJSONWriter; name : string; elem : TFhirQuery);
    procedure ComposeQuestionnaireGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroup);
    procedure ComposeQuestionnaireGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroupQuestion);
    procedure ComposeQuestionnaire(json : TJSONWriter; name : string; elem : TFhirQuestionnaire);
    procedure ComposeQuestionnaireAnswersGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireAnswersGroup);
    procedure ComposeQuestionnaireAnswersGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireAnswersGroupQuestion);
    procedure ComposeQuestionnaireAnswersGroupQuestionAnswer(json : TJSONWriter; name : string; elem : TFhirQuestionnaireAnswersGroupQuestionAnswer);
    procedure ComposeQuestionnaireAnswers(json : TJSONWriter; name : string; elem : TFhirQuestionnaireAnswers);
    procedure ComposeReferralRequest(json : TJSONWriter; name : string; elem : TFhirReferralRequest);
    procedure ComposeRelatedPerson(json : TJSONWriter; name : string; elem : TFhirRelatedPerson);
    procedure ComposeRiskAssessmentPrediction(json : TJSONWriter; name : string; elem : TFhirRiskAssessmentPrediction);
    procedure ComposeRiskAssessment(json : TJSONWriter; name : string; elem : TFhirRiskAssessment);
    procedure ComposeSecurityEventEvent(json : TJSONWriter; name : string; elem : TFhirSecurityEventEvent);
    procedure ComposeSecurityEventParticipant(json : TJSONWriter; name : string; elem : TFhirSecurityEventParticipant);
    procedure ComposeSecurityEventParticipantNetwork(json : TJSONWriter; name : string; elem : TFhirSecurityEventParticipantNetwork);
    procedure ComposeSecurityEventSource(json : TJSONWriter; name : string; elem : TFhirSecurityEventSource);
    procedure ComposeSecurityEventObject(json : TJSONWriter; name : string; elem : TFhirSecurityEventObject);
    procedure ComposeSecurityEventObjectDetail(json : TJSONWriter; name : string; elem : TFhirSecurityEventObjectDetail);
    procedure ComposeSecurityEvent(json : TJSONWriter; name : string; elem : TFhirSecurityEvent);
    procedure ComposeSlot(json : TJSONWriter; name : string; elem : TFhirSlot);
    procedure ComposeSpecimenSource(json : TJSONWriter; name : string; elem : TFhirSpecimenSource);
    procedure ComposeSpecimenCollection(json : TJSONWriter; name : string; elem : TFhirSpecimenCollection);
    procedure ComposeSpecimenTreatment(json : TJSONWriter; name : string; elem : TFhirSpecimenTreatment);
    procedure ComposeSpecimenContainer(json : TJSONWriter; name : string; elem : TFhirSpecimenContainer);
    procedure ComposeSpecimen(json : TJSONWriter; name : string; elem : TFhirSpecimen);
    procedure ComposeSubscriptionChannel(json : TJSONWriter; name : string; elem : TFhirSubscriptionChannel);
    procedure ComposeSubscriptionTag(json : TJSONWriter; name : string; elem : TFhirSubscriptionTag);
    procedure ComposeSubscription(json : TJSONWriter; name : string; elem : TFhirSubscription);
    procedure ComposeSubstanceInstance(json : TJSONWriter; name : string; elem : TFhirSubstanceInstance);
    procedure ComposeSubstanceIngredient(json : TJSONWriter; name : string; elem : TFhirSubstanceIngredient);
    procedure ComposeSubstance(json : TJSONWriter; name : string; elem : TFhirSubstance);
    procedure ComposeSupplyDispense(json : TJSONWriter; name : string; elem : TFhirSupplyDispense);
    procedure ComposeSupply(json : TJSONWriter; name : string; elem : TFhirSupply);
    procedure ComposeValueSetDefine(json : TJSONWriter; name : string; elem : TFhirValueSetDefine);
    procedure ComposeValueSetDefineConcept(json : TJSONWriter; name : string; elem : TFhirValueSetDefineConcept);
    procedure ComposeValueSetDefineConceptDesignation(json : TJSONWriter; name : string; elem : TFhirValueSetDefineConceptDesignation);
    procedure ComposeValueSetCompose(json : TJSONWriter; name : string; elem : TFhirValueSetCompose);
    procedure ComposeValueSetComposeInclude(json : TJSONWriter; name : string; elem : TFhirValueSetComposeInclude);
    procedure ComposeValueSetComposeIncludeConcept(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeConcept);
    procedure ComposeValueSetComposeIncludeFilter(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeFilter);
    procedure ComposeValueSetExpansion(json : TJSONWriter; name : string; elem : TFhirValueSetExpansion);
    procedure ComposeValueSetExpansionContains(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionContains);
    procedure ComposeValueSet(json : TJSONWriter; name : string; elem : TFhirValueSet);
    procedure ComposeResource(json : TJSONWriter; statedType, id, ver : String; resource : TFhirResource; links : TFHIRAtomLinkList); override;
  end;


implementation

{ TFHIRXmlParser }

Procedure TFHIRXmlParser.ParseElementAttributes(value : TFhirElement; path : string; element : IXmlDomElement);
begin
  TakeCommentsStart(value);
  value.xmlId := GetAttribute(element, 'id');
end;

Function TFHIRXmlParser.ParseBackboneElementChild(element : TFhirBackboneElement; path : string; child : IXmlDomElement) : boolean;
begin
  result := true;
  if (child.baseName = 'modifierExtension') then
    element.ModifierExtensionList.add(ParseExtension(child, path+'/modifierExtension'))
  else
    result := ParseElementChild(element, path, child);
end;

Function TFHIRXmlParser.ParseElementChild(element : TFhirElement; path : string; child : IXmlDomElement) : boolean;
begin
  result := true;
  if (child.baseName = 'extension') then
    element.ExtensionList.add(ParseExtension(child, path+'/extension'))
  else
    result := false;
end;

procedure TFHIRJsonParser.ParseElementProperties(jsn : TJsonObject; element : TFhirElement);
begin
  parseComments(element, jsn);

  if jsn.has('id') then
    element.xmlId:= jsn['id']
  else if jsn.has('_id') then
    element.xmlId:= jsn['_id'];
  if jsn.has('extension') then
    iterateArray(jsn.vArr['extension'], element.extensionList, parseExtension)
end;

procedure TFHIRJsonParser.ParseBackboneElementProperties(jsn : TJsonObject; element : TFhirBackboneElement);
begin
  parseElementProperties(jsn, element);

  if jsn.has('modifierExtension') then
    iterateArray(jsn.vArr['modifierExtension'], element.modifierExtensionList, parseExtension)
end;

Procedure TFHIRXmlComposer.ComposeElementAttributes(xml : TXmlBuilder; element : TFhirElement);
begin
  CommentsStart(xml, element);
  Attribute(xml, 'id', element.xmlId);
end;

Procedure TFHIRXmlComposer.ComposeElementChildren(xml : TXmlBuilder; element : TFhirElement);
var
  i : integer;
begin
  if element.hasExtensions then
    for i := 0 to element.extensionList.count - 1 do
       ComposeExtension(xml, 'extension', element.extensionList[i]);
end;

Procedure TFHIRXmlComposer.ComposeBackboneElementChildren(xml : TXmlBuilder; element : TFhirBackboneElement);
var
  i : integer;
begin
  ComposeElementChildren(xml, element);
  if element.hasModifierExtensions then
    for i := 0 to element.modifierExtensionList.count - 1 do
       ComposeExtension(xml, 'modifierExtension', element.modifierExtensionList[i]);
end;

Procedure TFHIRJsonComposer.ComposeElementProperties(json : TJSONWriter; elem : TFhirElement);
var
  i : integer;
begin
  composeComments(json, elem);
  Prop(json, 'id', elem.xmlId);
  if elem.hasExtensions then
  begin
    json.valueArray('extension');
    for i := 0 to elem.extensionList.count - 1 do
       ComposeExtension(json, '', elem.extensionList[i]);
    json.FinishArray;
  end;
end;

Procedure TFHIRJsonComposer.ComposeBackboneElementProperties(json : TJSONWriter; elem : TFhirBackboneElement);
var
  i : integer;
begin
  ComposeElementProperties(json, elem);
  if elem.hasModifierExtensions then
  begin
    json.valueArray('modifierExtension');
    for i := 0 to elem.modifierExtensionList.count - 1 do
       ComposeExtension(json, '', elem.modifierExtensionList[i]);
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseEnum(Const aNames : Array Of String; path : String; element : IXmlDomElement) : TFhirEnum;
var
  child : IXMLDOMElement;
begin
  result := TFhirEnum.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    if StringArrayIndexOfSensitive(aNames, result.value) < 0 then
      raise Exception.create('unknown code: '+result.value+' from a set of choices of '+StringArrayToCommaString(aNames)+' for "'+path+'"');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEnum(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList; Const aNames : Array Of String);
begin
  ctxt.add(ParseEnum(value, jsn, aNames));
end;

function TFHIRJsonParser.ParseEnum(value : string; jsn : TJsonObject; Const aNames : Array Of String) : TFHIREnum;
begin
  if StringArrayIndexOfSensitive(aNames, value) < 0 then
    raise Exception.create('unknown code: '+value+' from a set of choices of '+StringArrayToCommaString(aNames)+' for "'+jsn.path+'"');
  result := TFHIREnum.create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeEnum(xml : TXmlBuilder; name : String; value : TFhirEnum; Const aNames : Array Of String);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeEnumValue(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
begin
  if (value = nil) or (value.Value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeEnumProps(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseInteger(element : IXmlDomElement; path : string) : TFhirInteger;
var
  child : IXMLDOMElement;
begin
  result := TFhirInteger.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInteger(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInteger(value, jsn));
end;

function TFHIRJsonParser.ParseInteger(value : string; jsn : TJsonObject) : TFHIRInteger;
begin
  result := TFhirInteger.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeInteger(xml : TXmlBuilder; name : String; value : TFhirInteger);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeIntegerValue(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    propNumber(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeIntegerProps(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseDateTime(element : IXmlDomElement; path : string) : TFhirDateTime;
var
  child : IXMLDOMElement;
begin
  result := TFhirDateTime.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTDateAndTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDateTime(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDateTime(value, jsn));
end;

function TFHIRJsonParser.ParseDateTime(value : string; jsn : TJsonObject) : TFHIRDateTime;
begin
  result := TFhirDateTime.Create;
  try
     result.value := toTDateAndTime(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDateTime(xml : TXmlBuilder; name : String; value : TFhirDateTime);
begin
  if (value = nil) or (value.value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', asString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeDateTimeValue(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
begin
  if (value = nil) or (value.value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeDateTimeProps(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseDate(element : IXmlDomElement; path : string) : TFhirDate;
var
  child : IXMLDOMElement;
begin
  result := TFhirDate.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTDateAndTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDate(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDate(value, jsn));
end;

function TFHIRJsonParser.ParseDate(value : string; jsn : TJsonObject) : TFHIRDate;
begin
  result := TFhirDate.Create;
  try
     result.value := toTDateAndTime(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDate(xml : TXmlBuilder; name : String; value : TFhirDate);
begin
  if (value = nil) or (value.value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', asString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeDateValue(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
begin
  if (value = nil) or (value.value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeDateProps(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseDecimal(element : IXmlDomElement; path : string) : TFhirDecimal;
var
  child : IXMLDOMElement;
begin
  result := TFhirDecimal.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDecimal(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDecimal(value, jsn));
end;

function TFHIRJsonParser.ParseDecimal(value : string; jsn : TJsonObject) : TFHIRDecimal;
begin
  result := TFhirDecimal.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDecimal(xml : TXmlBuilder; name : String; value : TFhirDecimal);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeDecimalValue(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    propNumber(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeDecimalProps(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseUri(element : IXmlDomElement; path : string) : TFhirUri;
var
  child : IXMLDOMElement;
begin
  result := TFhirUri.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseUri(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUri(value, jsn));
end;

function TFHIRJsonParser.ParseUri(value : string; jsn : TJsonObject) : TFHIRUri;
begin
  result := TFhirUri.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUri(xml : TXmlBuilder; name : String; value : TFhirUri);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeUriValue(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeUriProps(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseBase64Binary(element : IXmlDomElement; path : string) : TFhirBase64Binary;
var
  child : IXMLDOMElement;
begin
  result := TFhirBase64Binary.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBase64Binary(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBase64Binary(value, jsn));
end;

function TFHIRJsonParser.ParseBase64Binary(value : string; jsn : TJsonObject) : TFHIRBase64Binary;
begin
  result := TFhirBase64Binary.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeBase64Binary(xml : TXmlBuilder; name : String; value : TFhirBase64Binary);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeBase64BinaryValue(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeBase64BinaryProps(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseTime(element : IXmlDomElement; path : string) : TFhirTime;
var
  child : IXMLDOMElement;
begin
  result := TFhirTime.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTime(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTime(value, jsn));
end;

function TFHIRJsonParser.ParseTime(value : string; jsn : TJsonObject) : TFHIRTime;
begin
  result := TFhirTime.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeTime(xml : TXmlBuilder; name : String; value : TFhirTime);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeTimeValue(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeTimeProps(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseString(element : IXmlDomElement; path : string) : TFhirString;
var
  child : IXMLDOMElement;
begin
  result := TFhirString.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseString(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseString(value, jsn));
end;

function TFHIRJsonParser.ParseString(value : string; jsn : TJsonObject) : TFHIRString;
begin
  result := TFhirString.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeString(xml : TXmlBuilder; name : String; value : TFhirString);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeStringValue(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeStringProps(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseBoolean(element : IXmlDomElement; path : string) : TFhirBoolean;
var
  child : IXMLDOMElement;
begin
  result := TFhirBoolean.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := StringToBoolean(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBoolean(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBoolean(value, jsn));
end;

function TFHIRJsonParser.ParseBoolean(value : string; jsn : TJsonObject) : TFHIRBoolean;
begin
  result := TFhirBoolean.Create;
  try
    result.value := StringToBoolean(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeBoolean(xml : TXmlBuilder; name : String; value : TFhirBoolean);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', LCBooleanToString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeBooleanValue(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
begin
  if (value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeBooleanProps(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseInstant(element : IXmlDomElement; path : string) : TFhirInstant;
var
  child : IXMLDOMElement;
begin
  result := TFhirInstant.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTDateAndTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInstant(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInstant(value, jsn));
end;

function TFHIRJsonParser.ParseInstant(value : string; jsn : TJsonObject) : TFHIRInstant;
begin
  result := TFhirInstant.Create;
  try
     result.value := toTDateAndTime(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeInstant(xml : TXmlBuilder; name : String; value : TFhirInstant);
begin
  if (value = nil) or (value.value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', asString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeInstantValue(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
begin
  if (value = nil) or (value.value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeInstantProps(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseCode(element : IXmlDomElement; path : string) : TFhirCode;
var
  child : IXMLDOMElement;
begin
  result := TFhirCode.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCode(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCode(value, jsn));
end;

function TFHIRJsonParser.ParseCode(value : string; jsn : TJsonObject) : TFHIRCode;
begin
  result := TFhirCode.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeCode(xml : TXmlBuilder; name : String; value : TFhirCode);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeCodeValue(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeCodeProps(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseId(element : IXmlDomElement; path : string) : TFhirId;
var
  child : IXMLDOMElement;
begin
  result := TFhirId.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseId(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseId(value, jsn));
end;

function TFHIRJsonParser.ParseId(value : string; jsn : TJsonObject) : TFHIRId;
begin
  result := TFhirId.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeId(xml : TXmlBuilder; name : String; value : TFhirId);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeIdValue(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeIdProps(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseOid(element : IXmlDomElement; path : string) : TFhirOid;
var
  child : IXMLDOMElement;
begin
  result := TFhirOid.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOid(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOid(value, jsn));
end;

function TFHIRJsonParser.ParseOid(value : string; jsn : TJsonObject) : TFHIROid;
begin
  result := TFhirOid.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeOid(xml : TXmlBuilder; name : String; value : TFhirOid);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeOidValue(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeOidProps(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseUuid(element : IXmlDomElement; path : string) : TFhirUuid;
var
  child : IXMLDOMElement;
begin
  result := TFhirUuid.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseUuid(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUuid(value, jsn));
end;

function TFHIRJsonParser.ParseUuid(value : string; jsn : TJsonObject) : TFHIRUuid;
begin
  result := TFhirUuid.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUuid(xml : TXmlBuilder; name : String; value : TFhirUuid);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeUuidValue(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeUuidProps(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRXmlParser.ParseResourceAttributes(resource : TFhirResource; path : string; element : IXmlDomElement);
begin
  ParseElementAttributes(resource, path, element);
  // lang
end;

Function TFHIRXmlParser.ParseResourceChild(resource : TFhirResource; path : string; child : IXmlDomElement) : boolean;
begin
  result := true;
  if (child.baseName = 'text') then
    resource.text := ParseNarrative(child, path+'/text')
  else if (child.baseName = 'language') then
    resource.language := ParseCode(child, path+'/language')
  else if (child.baseName = 'contained') then
    resource.ContainedList.add(ParseContained(child, path+'/contained'))
  else if not parseBackboneElementChild(resource, path, child) then
    result := false;
end;

procedure TFHIRJsonParser.ParseResourceProperties(jsn : TJsonObject; resource : TFhirResource);
begin
  ParseBackboneElementProperties(jsn, resource);
  if jsn.has('language') or jsn.has('_language') then
    resource.language := parseCode(jsn['language'], jsn.vObj['_language']);
  if jsn.has('text') then
    resource.text := parseNarrative(jsn.vObj['text']);
  if jsn.has('contained') then
    iterateArray(jsn.vArr['contained'], resource.containedList, parseContained);
end;

Procedure TFHIRXmlComposer.ComposeResourceAttributes(xml : TXmlBuilder; resource : TFhirResource);
begin
  ComposeElementAttributes(xml, resource);
end;

Procedure TFHIRXmlComposer.ComposeResourceChildren(xml : TXmlBuilder; resource : TFhirResource);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, resource);
  composeCode(xml, 'language', resource.language);
  if not SummaryOnly then
    composeNarrative(xml, 'text', resource.text);
  if not SummaryOnly then
    for i := 0 to resource.containedList.count - 1 do
      ComposeContained(xml, 'contained', resource.containedList[i]);
end;

Procedure TFHIRJsonComposer.ComposeResourceProperties(json : TJSONWriter; resource : TFhirResource);
var
  i : integer;
begin
  ComposeBackboneElementProperties(json, resource);
  composeCodeValue(json, 'language', resource.language, false);
  composeCodeProps(json, 'language', resource.language, false);
  if not SummaryOnly then
    ComposeNarrative(json, 'text', resource.text);
  if not SummaryOnly and (resource.containedList.count > 0) then
  begin
    json.valueArray('contained');
    for i := 0 to resource.containedList.Count - 1 do
      ComposeContained(json, resource.containedList[i]);
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseExtension(element : IXmlDomElement; path : string) : TFhirExtension;
var
  child : IXMLDOMElement;
begin
  result := TFhirExtension.create;
  try
    parseElementAttributes(result, path, element);
    result.url := GetAttribute(element, 'url');{x.4}
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'valueInteger') then
        result.value := ParseInteger(child, path+'.valueInteger') {c}
      else if (child.baseName = 'valueDateTime') then
        result.value := ParseDateTime(child, path+'.valueDateTime') {c}
      else if (child.baseName = 'valueCode') then
        result.value := ParseCode(child, path+'.valueCode') {c}
      else if (child.baseName = 'valueDate') then
        result.value := ParseDate(child, path+'.valueDate') {c}
      else if (child.baseName = 'valueDecimal') then
        result.value := ParseDecimal(child, path+'.valueDecimal') {c}
      else if (child.baseName = 'valueUri') then
        result.value := ParseUri(child, path+'.valueUri') {c}
      else if (child.baseName = 'valueId') then
        result.value := ParseId(child, path+'.valueId') {c}
      else if (child.baseName = 'valueBase64Binary') then
        result.value := ParseBase64Binary(child, path+'.valueBase64Binary') {c}
      else if (child.baseName = 'valueTime') then
        result.value := ParseTime(child, path+'.valueTime') {c}
      else if (child.baseName = 'valueOid') then
        result.value := ParseOid(child, path+'.valueOid') {c}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'.valueString') {c}
      else if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'.valueBoolean') {c}
      else if (child.baseName = 'valueUuid') then
        result.value := ParseUuid(child, path+'.valueUuid') {c}
      else if (child.baseName = 'valueInstant') then
        result.value := ParseInstant(child, path+'.valueInstant') {c}
      else if (child.baseName = 'valuePeriod') then
        result.value := ParsePeriod(child, path+'.valuePeriod') {ePeriod}
      else if (child.baseName = 'valueCoding') then
        result.value := ParseCoding(child, path+'.valueCoding') {eCoding}
      else if (child.baseName = 'valueRange') then
        result.value := ParseRange(child, path+'.valueRange') {eRange}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'.valueQuantity') {eQuantity}
      else if (child.baseName = 'valueAttachment') then
        result.value := ParseAttachment(child, path+'.valueAttachment') {eAttachment}
      else if (child.baseName = 'valueRatio') then
        result.value := ParseRatio(child, path+'.valueRatio') {eRatio}
      else if (child.baseName = 'valueSampledData') then
        result.value := ParseSampledData(child, path+'.valueSampledData') {eSampledData}
      else if (child.baseName = 'valueReference') then
        result.value := ParseReference(child, path+'.valueReference') {eReference}
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'.valueCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'valueIdentifier') then
        result.value := ParseIdentifier(child, path+'.valueIdentifier') {eIdentifier}
      else if (child.baseName = 'valueTiming') then
        result.value := ParseTiming(child, path+'/valueTiming') {f}
      else if (child.baseName = 'valueAddress') then
        result.value := ParseAddress(child, path+'/valueAddress') {f}
      else if (child.baseName = 'valueHumanName') then
        result.value := ParseHumanName(child, path+'/valueHumanName') {f}
      else if (child.baseName = 'valueContactPoint') then
        result.value := ParseContactPoint(child, path+'/valueContactPoint') {f}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeExtension(xml : TXmlBuilder; name : string; elem : TFhirExtension);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  Attribute(xml, 'url', elem.url  );
  xml.open(name);
  composeElementChildren(xml, elem);
  if (elem.value is TFhirInteger) {1} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (elem.value is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (elem.value is TFhirCode) {1} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (elem.value is TFhirDate) {1} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (elem.value is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (elem.value is TFhirUri) {1} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value))
  else if (elem.value is TFhirId) {1} then
    ComposeId(xml, 'valueId', TFhirId(elem.value))
  else if (elem.value is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(elem.value))
  else if (elem.value is TFhirTime) {1} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (elem.value is TFhirOid) {1} then
    ComposeOid(xml, 'valueOid', TFhirOid(elem.value))
  else if (elem.value is TFhirString) {1} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (elem.value is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirUuid) {1} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(elem.value))
  else if (elem.value is TFhirInstant) {1} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (elem.value is TFhirPeriod) {8} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirCoding) {8} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirRange) {8} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirRatio) {8} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirReference) {8} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (elem.value is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (elem.value is TFhirTiming) {9} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(elem.value))
  else if (elem.value is TFhirAddress) {9} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(elem.value))
  else if (elem.value is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(elem.value))
  else if (elem.value is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(elem.value));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseExtension(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExtension(jsn));
end;

function TFHIRJsonParser.ParseExtension(jsn : TJsonObject) : TFhirExtension;
begin
  result := TFhirExtension.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlObject := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
        result.value := ParseInteger(jsn['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
        result.value := ParseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueCode') or jsn.has('_valueCode') then
        result.value := ParseCode(jsn['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
        result.value := ParseDate(jsn['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
        result.value := ParseDecimal(jsn['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
        result.value := ParseUri(jsn['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('valueId') or jsn.has('_valueId') then
        result.value := ParseId(jsn['valueId'], jsn.vObj['_valueId']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
        result.value := ParseBase64Binary(jsn['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
        result.value := ParseTime(jsn['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueOid') or jsn.has('_valueOid') then
        result.value := ParseOid(jsn['valueOid'], jsn.vObj['_valueOid']);
    if jsn.has('valueString') or jsn.has('_valueString') then
        result.value := ParseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
        result.value := ParseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
        result.value := ParseUuid(jsn['valueUuid'], jsn.vObj['_valueUuid']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
        result.value := ParseInstant(jsn['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valuePeriod') {a7} then
        result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueCoding') {a7} then
        result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueRange') {a7} then
        result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueQuantity') {a7} then
        result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueAttachment') {a7} then
        result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueRatio') {a7} then
        result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueSampledData') {a7} then
        result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueReference') {a7} then
        result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueCodeableConcept') {a7} then
        result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueIdentifier') {a7} then
        result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if jsn.has('valueTiming') {a9} then
        result.value := ParseTiming(jsn.vObj['valueTiming']);
    if jsn.has('valueAddress') {a9} then
        result.value := ParseAddress(jsn.vObj['valueAddress']);
    if jsn.has('valueHumanName') {a9} then
        result.value := ParseHumanName(jsn.vObj['valueHumanName']);
    if jsn.has('valueContactPoint') {a9} then
        result.value := ParseContactPoint(jsn.vObj['valueContactPoint']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeExtension(json : TJSONWriter; name : string; elem : TFhirExtension);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlObject, false);
  ComposeUriProps(json, 'url', elem.urlObject, false);
  if (elem.value is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false)
  end
  else if (elem.value is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false)
  end
  else if (elem.value is TFhirCode) then
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false)
  end
  else if (elem.value is TFhirDate) then
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false)
  end
  else if (elem.value is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false)
  end
  else if (elem.value is TFhirUri) then
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false)
  end
  else if (elem.value is TFhirId) then
  begin
    ComposeIdValue(json, 'valueId', TFhirId(elem.value), false);
    ComposeIdProps(json, 'valueId', TFhirId(elem.value), false)
  end
  else if (elem.value is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false)
  end
  else if (elem.value is TFhirTime) then
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false)
  end
  else if (elem.value is TFhirOid) then
  begin
    ComposeOidValue(json, 'valueOid', TFhirOid(elem.value), false);
    ComposeOidProps(json, 'valueOid', TFhirOid(elem.value), false)
  end
  else if (elem.value is TFhirString) then
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false)
  end
  else if (elem.value is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false)
  end
  else if (elem.value is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'valueUuid', TFhirUuid(elem.value), false);
    ComposeUuidProps(json, 'valueUuid', TFhirUuid(elem.value), false)
  end
  else if (elem.value is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false)
  end
  else if (elem.value is TFhirPeriod) then
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirCoding) then
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirRange) then
    ComposeRange(json, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirQuantity) then
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirAttachment) then
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirRatio) then
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirSampledData) then
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value))
  else if (elem.value is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirIdentifier) then
    ComposeIdentifier(json, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (elem.value is TFhirTiming) then
    ComposeTiming(json, 'valueTiming', TFhirTiming(elem.value))
  else if (elem.value is TFhirAddress) then
    ComposeAddress(json, 'valueAddress', TFhirAddress(elem.value))
  else if (elem.value is TFhirHumanName) then
    ComposeHumanName(json, 'valueHumanName', TFhirHumanName(elem.value))
  else if (elem.value is TFhirContactPoint) then
    ComposeContactPoint(json, 'valueContactPoint', TFhirContactPoint(elem.value));
  json.finishObject;
end;

function TFHIRXmlParser.ParseNarrative(element : IXmlDomElement; path : string) : TFhirNarrative;
var
  child : IXMLDOMElement;
begin
  result := TFhirNarrative.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirNarrativeStatus, path+'/status', child){1a}
      else if (child.baseName = 'div') then
        result.div_ := ParseXHtmlNode(child, path+'/div') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNarrative(xml : TXmlBuilder; name : string; elem : TFhirNarrative);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirNarrativeStatus);
  ComposeXHtmlNode(xml, 'div', elem.div_);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNarrative(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNarrative(jsn));
end;

function TFHIRJsonParser.ParseNarrative(jsn : TJsonObject) : TFhirNarrative;
begin
  result := TFhirNarrative.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirNarrativeStatus);
    if jsn.has('div') then
        result.div_ := ParseXHtmlNode(jsn.path+'.div', jsn['div']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNarrative(json : TJSONWriter; name : string; elem : TFhirNarrative);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirNarrativeStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirNarrativeStatus, false);
  ComposeXHtmlNode(json, 'div', elem.div_); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParsePeriod(element : IXmlDomElement; path : string) : TFhirPeriod;
var
  child : IXMLDOMElement;
begin
  result := TFhirPeriod.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'start') then
        result.startObject := ParseDateTime(child, path+'/start') {b}
      else if (child.baseName = 'end') then
        result.end_Object := ParseDateTime(child, path+'/end') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePeriod(xml : TXmlBuilder; name : string; elem : TFhirPeriod);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeDateTime(xml, 'start', elem.startObject);{x.2}
  ComposeDateTime(xml, 'end', elem.end_Object);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePeriod(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePeriod(jsn));
end;

function TFHIRJsonParser.ParsePeriod(jsn : TJsonObject) : TFhirPeriod;
begin
  result := TFhirPeriod.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('start') or jsn.has('_start') then
        result.startObject := ParseDateTime(jsn['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Object := ParseDateTime(jsn['end'], jsn.vObj['_end']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePeriod(json : TJSONWriter; name : string; elem : TFhirPeriod);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeDateTimeValue(json, 'start', elem.startObject, false);
  ComposeDateTimeProps(json, 'start', elem.startObject, false);
  ComposeDateTimeValue(json, 'end', elem.end_Object, false);
  ComposeDateTimeProps(json, 'end', elem.end_Object, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseCoding(element : IXmlDomElement; path : string) : TFhirCoding;
var
  child : IXMLDOMElement;
begin
  result := TFhirCoding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.systemObject := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'version') then
        result.versionObject := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'code') then
        result.codeObject := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'display') then
        result.displayObject := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'primary') then
        result.primaryObject := ParseBoolean(child, path+'/primary') {b}
      else if (child.baseName = 'valueSet') then
        result.valueSet := ParseReference{TFhirValueSet}(child, path+'/valueSet') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCoding(xml : TXmlBuilder; name : string; elem : TFhirCoding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.systemObject);{x.2}
  ComposeString(xml, 'version', elem.versionObject);{x.2}
  ComposeCode(xml, 'code', elem.codeObject);{x.2}
  ComposeString(xml, 'display', elem.displayObject);{x.2}
  ComposeBoolean(xml, 'primary', elem.primaryObject);{x.2}
  ComposeReference{TFhirValueSet}(xml, 'valueSet', elem.valueSet);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCoding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoding(jsn));
end;

function TFHIRJsonParser.ParseCoding(jsn : TJsonObject) : TFhirCoding;
begin
  result := TFhirCoding.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemObject := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionObject := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeObject := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayObject := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('primary') or jsn.has('_primary') then
        result.primaryObject := ParseBoolean(jsn['primary'], jsn.vObj['_primary']);{q}
    if jsn.has('valueSet') then
        result.valueSet := ParseReference{TFhirValueSet}(jsn.vObj['valueSet']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCoding(json : TJSONWriter; name : string; elem : TFhirCoding);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeUriValue(json, 'system', elem.systemObject, false);
  ComposeUriProps(json, 'system', elem.systemObject, false);
  ComposeStringValue(json, 'version', elem.versionObject, false);
  ComposeStringProps(json, 'version', elem.versionObject, false);
  ComposeCodeValue(json, 'code', elem.codeObject, false);
  ComposeCodeProps(json, 'code', elem.codeObject, false);
  ComposeStringValue(json, 'display', elem.displayObject, false);
  ComposeStringProps(json, 'display', elem.displayObject, false);
  ComposeBooleanValue(json, 'primary', elem.primaryObject, false);
  ComposeBooleanProps(json, 'primary', elem.primaryObject, false);
  ComposeReference{TFhirValueSet}(json, 'valueSet', elem.valueSet); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseRange(element : IXmlDomElement; path : string) : TFhirRange;
var
  child : IXMLDOMElement;
begin
  result := TFhirRange.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'low') then
        result.low := ParseQuantity(child, path+'/low') {b}
      else if (child.baseName = 'high') then
        result.high := ParseQuantity(child, path+'/high') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRange(xml : TXmlBuilder; name : string; elem : TFhirRange);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeQuantity(xml, 'low', elem.low);{x.2}
  ComposeQuantity(xml, 'high', elem.high);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRange(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRange(jsn));
end;

function TFHIRJsonParser.ParseRange(jsn : TJsonObject) : TFhirRange;
begin
  result := TFhirRange.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('low') then
        result.low := ParseQuantity(jsn.vObj['low']);{q}
    if jsn.has('high') then
        result.high := ParseQuantity(jsn.vObj['high']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRange(json : TJSONWriter; name : string; elem : TFhirRange);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeQuantity(json, 'low', elem.low); {a}
  ComposeQuantity(json, 'high', elem.high); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseQuantity(element : IXmlDomElement; path : string) : TFhirQuantity;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuantity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'value') then
        result.valueObject := ParseDecimal(child, path+'/value') {b}
      else if (child.baseName = 'comparator') then
        result.comparatorObject := ParseEnum(CODES_TFhirQuantityComparator, path+'/comparator', child){1a}
      else if (child.baseName = 'units') then
        result.unitsObject := ParseString(child, path+'/units') {b}
      else if (child.baseName = 'system') then
        result.systemObject := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'code') then
        result.codeObject := ParseCode(child, path+'/code') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuantity(xml : TXmlBuilder; name : string; elem : TFhirQuantity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeDecimal(xml, 'value', elem.valueObject);{x.2}
  ComposeEnum(xml, 'comparator', elem.ComparatorObject, CODES_TFhirQuantityComparator);
  ComposeString(xml, 'units', elem.unitsObject);{x.2}
  ComposeUri(xml, 'system', elem.systemObject);{x.2}
  ComposeCode(xml, 'code', elem.codeObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuantity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuantity(jsn));
end;

function TFHIRJsonParser.ParseQuantity(jsn : TJsonObject) : TFhirQuantity;
begin
  result := TFhirQuantity.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('value') or jsn.has('_value') then
        result.valueObject := ParseDecimal(jsn['value'], jsn.vObj['_value']);{q}
    if jsn.has('comparator') or jsn.has('_comparator')  then
      result.comparatorObject := parseEnum(jsn['comparator'], jsn.vObj['_comparator'], CODES_TFhirQuantityComparator);
    if jsn.has('units') or jsn.has('_units') then
        result.unitsObject := ParseString(jsn['units'], jsn.vObj['_units']);{q}
    if jsn.has('system') or jsn.has('_system') then
        result.systemObject := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeObject := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuantity(json : TJSONWriter; name : string; elem : TFhirQuantity);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeDecimalValue(json, 'value', elem.valueObject, false);
  ComposeDecimalProps(json, 'value', elem.valueObject, false);
  ComposeEnumValue(json, 'comparator', elem.ComparatorObject, CODES_TFhirQuantityComparator, false);
  ComposeEnumProps(json, 'comparator', elem.ComparatorObject, CODES_TFhirQuantityComparator, false);
  ComposeStringValue(json, 'units', elem.unitsObject, false);
  ComposeStringProps(json, 'units', elem.unitsObject, false);
  ComposeUriValue(json, 'system', elem.systemObject, false);
  ComposeUriProps(json, 'system', elem.systemObject, false);
  ComposeCodeValue(json, 'code', elem.codeObject, false);
  ComposeCodeProps(json, 'code', elem.codeObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseAttachment(element : IXmlDomElement; path : string) : TFhirAttachment;
var
  child : IXMLDOMElement;
begin
  result := TFhirAttachment.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'contentType') then
        result.contentTypeObject := ParseCode(child, path+'/contentType') {b}
      else if (child.baseName = 'language') then
        result.languageObject := ParseCode(child, path+'/language') {b}
      else if (child.baseName = 'data') then
        result.dataObject := ParseBase64Binary(child, path+'/data') {b}
      else if (child.baseName = 'url') then
        result.urlObject := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'size') then
        result.sizeObject := ParseInteger(child, path+'/size') {b}
      else if (child.baseName = 'hash') then
        result.hashObject := ParseBase64Binary(child, path+'/hash') {b}
      else if (child.baseName = 'title') then
        result.titleObject := ParseString(child, path+'/title') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAttachment(xml : TXmlBuilder; name : string; elem : TFhirAttachment);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeCode(xml, 'contentType', elem.contentTypeObject);{x.2}
  ComposeCode(xml, 'language', elem.languageObject);{x.2}
  ComposeBase64Binary(xml, 'data', elem.dataObject);{x.2}
  ComposeUri(xml, 'url', elem.urlObject);{x.2}
  ComposeInteger(xml, 'size', elem.sizeObject);{x.2}
  ComposeBase64Binary(xml, 'hash', elem.hashObject);{x.2}
  ComposeString(xml, 'title', elem.titleObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAttachment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAttachment(jsn));
end;

function TFHIRJsonParser.ParseAttachment(jsn : TJsonObject) : TFhirAttachment;
begin
  result := TFhirAttachment.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('contentType') or jsn.has('_contentType') then
        result.contentTypeObject := ParseCode(jsn['contentType'], jsn.vObj['_contentType']);{q}
    if jsn.has('language') or jsn.has('_language') then
        result.languageObject := ParseCode(jsn['language'], jsn.vObj['_language']);{q}
    if jsn.has('data') or jsn.has('_data') then
        result.dataObject := ParseBase64Binary(jsn['data'], jsn.vObj['_data']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlObject := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('size') or jsn.has('_size') then
        result.sizeObject := ParseInteger(jsn['size'], jsn.vObj['_size']);{q}
    if jsn.has('hash') or jsn.has('_hash') then
        result.hashObject := ParseBase64Binary(jsn['hash'], jsn.vObj['_hash']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleObject := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAttachment(json : TJSONWriter; name : string; elem : TFhirAttachment);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeCodeValue(json, 'contentType', elem.contentTypeObject, false);
  ComposeCodeProps(json, 'contentType', elem.contentTypeObject, false);
  ComposeCodeValue(json, 'language', elem.languageObject, false);
  ComposeCodeProps(json, 'language', elem.languageObject, false);
  ComposeBase64BinaryValue(json, 'data', elem.dataObject, false);
  ComposeBase64BinaryProps(json, 'data', elem.dataObject, false);
  ComposeUriValue(json, 'url', elem.urlObject, false);
  ComposeUriProps(json, 'url', elem.urlObject, false);
  ComposeIntegerValue(json, 'size', elem.sizeObject, false);
  ComposeIntegerProps(json, 'size', elem.sizeObject, false);
  ComposeBase64BinaryValue(json, 'hash', elem.hashObject, false);
  ComposeBase64BinaryProps(json, 'hash', elem.hashObject, false);
  ComposeStringValue(json, 'title', elem.titleObject, false);
  ComposeStringProps(json, 'title', elem.titleObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseRatio(element : IXmlDomElement; path : string) : TFhirRatio;
var
  child : IXMLDOMElement;
begin
  result := TFhirRatio.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'numerator') then
        result.numerator := ParseQuantity(child, path+'/numerator') {b}
      else if (child.baseName = 'denominator') then
        result.denominator := ParseQuantity(child, path+'/denominator') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRatio(xml : TXmlBuilder; name : string; elem : TFhirRatio);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeQuantity(xml, 'numerator', elem.numerator);{x.2}
  ComposeQuantity(xml, 'denominator', elem.denominator);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRatio(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRatio(jsn));
end;

function TFHIRJsonParser.ParseRatio(jsn : TJsonObject) : TFhirRatio;
begin
  result := TFhirRatio.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('numerator') then
        result.numerator := ParseQuantity(jsn.vObj['numerator']);{q}
    if jsn.has('denominator') then
        result.denominator := ParseQuantity(jsn.vObj['denominator']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRatio(json : TJSONWriter; name : string; elem : TFhirRatio);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeQuantity(json, 'numerator', elem.numerator); {a}
  ComposeQuantity(json, 'denominator', elem.denominator); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseSampledData(element : IXmlDomElement; path : string) : TFhirSampledData;
var
  child : IXMLDOMElement;
begin
  result := TFhirSampledData.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'origin') then
        result.origin := ParseQuantity(child, path+'/origin') {b}
      else if (child.baseName = 'period') then
        result.periodObject := ParseDecimal(child, path+'/period') {b}
      else if (child.baseName = 'factor') then
        result.factorObject := ParseDecimal(child, path+'/factor') {b}
      else if (child.baseName = 'lowerLimit') then
        result.lowerLimitObject := ParseDecimal(child, path+'/lowerLimit') {b}
      else if (child.baseName = 'upperLimit') then
        result.upperLimitObject := ParseDecimal(child, path+'/upperLimit') {b}
      else if (child.baseName = 'dimensions') then
        result.dimensionsObject := ParseInteger(child, path+'/dimensions') {b}
      else if (child.baseName = 'data') then
        result.dataObject := ParseString(child, path+'/data') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSampledData(xml : TXmlBuilder; name : string; elem : TFhirSampledData);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeQuantity(xml, 'origin', elem.origin);{x.2}
  ComposeDecimal(xml, 'period', elem.periodObject);{x.2}
  ComposeDecimal(xml, 'factor', elem.factorObject);{x.2}
  ComposeDecimal(xml, 'lowerLimit', elem.lowerLimitObject);{x.2}
  ComposeDecimal(xml, 'upperLimit', elem.upperLimitObject);{x.2}
  ComposeInteger(xml, 'dimensions', elem.dimensionsObject);{x.2}
  ComposeString(xml, 'data', elem.dataObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSampledData(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSampledData(jsn));
end;

function TFHIRJsonParser.ParseSampledData(jsn : TJsonObject) : TFhirSampledData;
begin
  result := TFhirSampledData.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('origin') then
        result.origin := ParseQuantity(jsn.vObj['origin']);{q}
    if jsn.has('period') or jsn.has('_period') then
        result.periodObject := ParseDecimal(jsn['period'], jsn.vObj['_period']);{q}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorObject := ParseDecimal(jsn['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('lowerLimit') or jsn.has('_lowerLimit') then
        result.lowerLimitObject := ParseDecimal(jsn['lowerLimit'], jsn.vObj['_lowerLimit']);{q}
    if jsn.has('upperLimit') or jsn.has('_upperLimit') then
        result.upperLimitObject := ParseDecimal(jsn['upperLimit'], jsn.vObj['_upperLimit']);{q}
    if jsn.has('dimensions') or jsn.has('_dimensions') then
        result.dimensionsObject := ParseInteger(jsn['dimensions'], jsn.vObj['_dimensions']);{q}
    if jsn.has('data') or jsn.has('_data') then
        result.dataObject := ParseString(jsn['data'], jsn.vObj['_data']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSampledData(json : TJSONWriter; name : string; elem : TFhirSampledData);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeQuantity(json, 'origin', elem.origin); {a}
  ComposeDecimalValue(json, 'period', elem.periodObject, false);
  ComposeDecimalProps(json, 'period', elem.periodObject, false);
  ComposeDecimalValue(json, 'factor', elem.factorObject, false);
  ComposeDecimalProps(json, 'factor', elem.factorObject, false);
  ComposeDecimalValue(json, 'lowerLimit', elem.lowerLimitObject, false);
  ComposeDecimalProps(json, 'lowerLimit', elem.lowerLimitObject, false);
  ComposeDecimalValue(json, 'upperLimit', elem.upperLimitObject, false);
  ComposeDecimalProps(json, 'upperLimit', elem.upperLimitObject, false);
  ComposeIntegerValue(json, 'dimensions', elem.dimensionsObject, false);
  ComposeIntegerProps(json, 'dimensions', elem.dimensionsObject, false);
  ComposeStringValue(json, 'data', elem.dataObject, false);
  ComposeStringProps(json, 'data', elem.dataObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseReference(element : IXmlDomElement; path : string) : TFhirReference;
var
  child : IXMLDOMElement;
begin
  result := TFhirReference.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'reference') then
        result.referenceObject := ParseString(child, path+'/reference') {b}
      else if (child.baseName = 'display') then
        result.displayObject := ParseString(child, path+'/display') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeReference(xml : TXmlBuilder; name : string; elem : TFhirReference);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeString(xml, 'reference', elem.referenceObject);{x.2}
  ComposeString(xml, 'display', elem.displayObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseReference(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseReference(jsn));
end;

function TFHIRJsonParser.ParseReference(jsn : TJsonObject) : TFhirReference;
begin
  result := TFhirReference.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceObject := ParseString(jsn['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayObject := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeReference(json : TJSONWriter; name : string; elem : TFhirReference);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeStringValue(json, 'reference', elem.referenceObject, false);
  ComposeStringProps(json, 'reference', elem.referenceObject, false);
  ComposeStringValue(json, 'display', elem.displayObject, false);
  ComposeStringProps(json, 'display', elem.displayObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseCodeableConcept(element : IXmlDomElement; path : string) : TFhirCodeableConcept;
var
  child : IXMLDOMElement;
begin
  result := TFhirCodeableConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'coding') then
        result.codingList.Add(ParseCoding(child, path+'/coding')){y.2}
      else if (child.baseName = 'text') then
        result.textObject := ParseString(child, path+'/text') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCodeableConcept(xml : TXmlBuilder; name : string; elem : TFhirCodeableConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  for i := 0 to elem.codingList.Count - 1 do
    ComposeCoding(xml, 'coding', elem.codingList[i]);
  ComposeString(xml, 'text', elem.textObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCodeableConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCodeableConcept(jsn));
end;

function TFHIRJsonParser.ParseCodeableConcept(jsn : TJsonObject) : TFhirCodeableConcept;
begin
  result := TFhirCodeableConcept.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('coding') then
      iterateArray(jsn.vArr['coding'], result.codingList, parseCoding);
    if jsn.has('text') or jsn.has('_text') then
        result.textObject := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCodeableConcept(json : TJSONWriter; name : string; elem : TFhirCodeableConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  if elem.codingList.Count > 0 then
  begin
    json.valueArray('coding');
    for i := 0 to elem.codingList.Count - 1 do
      ComposeCoding(json, '',elem.codingList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'text', elem.textObject, false);
  ComposeStringProps(json, 'text', elem.textObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseIdentifier(element : IXmlDomElement; path : string) : TFhirIdentifier;
var
  child : IXMLDOMElement;
begin
  result := TFhirIdentifier.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'use') then
        result.useObject := ParseEnum(CODES_TFhirIdentifierUse, path+'/use', child){1a}
      else if (child.baseName = 'label') then
        result.label_Object := ParseString(child, path+'/label') {b}
      else if (child.baseName = 'system') then
        result.systemObject := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'value') then
        result.valueObject := ParseString(child, path+'/value') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'assigner') then
        result.assigner := ParseReference{TFhirOrganization}(child, path+'/assigner') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeIdentifier(xml : TXmlBuilder; name : string; elem : TFhirIdentifier);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'use', elem.UseObject, CODES_TFhirIdentifierUse);
  ComposeString(xml, 'label', elem.label_Object);{x.2}
  ComposeUri(xml, 'system', elem.systemObject);{x.2}
  ComposeString(xml, 'value', elem.valueObject);{x.2}
  ComposePeriod(xml, 'period', elem.period);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'assigner', elem.assigner);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseIdentifier(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseIdentifier(jsn));
end;

function TFHIRJsonParser.ParseIdentifier(jsn : TJsonObject) : TFhirIdentifier;
begin
  result := TFhirIdentifier.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.useObject := parseEnum(jsn['use'], jsn.vObj['_use'], CODES_TFhirIdentifierUse);
    if jsn.has('label') or jsn.has('_label') then
        result.label_Object := ParseString(jsn['label'], jsn.vObj['_label']);{q}
    if jsn.has('system') or jsn.has('_system') then
        result.systemObject := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueObject := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('assigner') then
        result.assigner := ParseReference{TFhirOrganization}(jsn.vObj['assigner']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeIdentifier(json : TJSONWriter; name : string; elem : TFhirIdentifier);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'use', elem.UseObject, CODES_TFhirIdentifierUse, false);
  ComposeEnumProps(json, 'use', elem.UseObject, CODES_TFhirIdentifierUse, false);
  ComposeStringValue(json, 'label', elem.label_Object, false);
  ComposeStringProps(json, 'label', elem.label_Object, false);
  ComposeUriValue(json, 'system', elem.systemObject, false);
  ComposeUriProps(json, 'system', elem.systemObject, false);
  ComposeStringValue(json, 'value', elem.valueObject, false);
  ComposeStringProps(json, 'value', elem.valueObject, false);
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeReference{TFhirOrganization}(json, 'assigner', elem.assigner); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseTimingRepeat(element : IXmlDomElement; path : string) : TFhirTimingRepeat;
var
  child : IXMLDOMElement;
begin
  result := TFhirTimingRepeat.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'frequency') then
        result.frequencyObject := ParseInteger(child, path+'/frequency') {b}
      else if (child.baseName = 'when') then
        result.whenObject := ParseEnum(CODES_TFhirEventTiming, path+'/when', child){1a}
      else if (child.baseName = 'duration') then
        result.durationObject := ParseDecimal(child, path+'/duration') {b}
      else if (child.baseName = 'units') then
        result.unitsObject := ParseEnum(CODES_TFhirUnitsOfTime, path+'/units', child){1a}
      else if (child.baseName = 'count') then
        result.countObject := ParseInteger(child, path+'/count') {b}
      else if (child.baseName = 'end') then
        result.end_Object := ParseDateTime(child, path+'/end') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTimingRepeat(xml : TXmlBuilder; name : string; elem : TFhirTimingRepeat);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeInteger(xml, 'frequency', elem.frequencyObject);{x.2}
  ComposeEnum(xml, 'when', elem.WhenObject, CODES_TFhirEventTiming);
  ComposeDecimal(xml, 'duration', elem.durationObject);{x.2}
  ComposeEnum(xml, 'units', elem.UnitsObject, CODES_TFhirUnitsOfTime);
  ComposeInteger(xml, 'count', elem.countObject);{x.2}
  ComposeDateTime(xml, 'end', elem.end_Object);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTimingRepeat(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTimingRepeat(jsn));
end;

function TFHIRJsonParser.ParseTimingRepeat(jsn : TJsonObject) : TFhirTimingRepeat;
begin
  result := TFhirTimingRepeat.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('frequency') or jsn.has('_frequency') then
        result.frequencyObject := ParseInteger(jsn['frequency'], jsn.vObj['_frequency']);{q}
    if jsn.has('when') or jsn.has('_when')  then
      result.whenObject := parseEnum(jsn['when'], jsn.vObj['_when'], CODES_TFhirEventTiming);
    if jsn.has('duration') or jsn.has('_duration') then
        result.durationObject := ParseDecimal(jsn['duration'], jsn.vObj['_duration']);{q}
    if jsn.has('units') or jsn.has('_units')  then
      result.unitsObject := parseEnum(jsn['units'], jsn.vObj['_units'], CODES_TFhirUnitsOfTime);
    if jsn.has('count') or jsn.has('_count') then
        result.countObject := ParseInteger(jsn['count'], jsn.vObj['_count']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Object := ParseDateTime(jsn['end'], jsn.vObj['_end']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTimingRepeat(json : TJSONWriter; name : string; elem : TFhirTimingRepeat);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeIntegerValue(json, 'frequency', elem.frequencyObject, false);
  ComposeIntegerProps(json, 'frequency', elem.frequencyObject, false);
  ComposeEnumValue(json, 'when', elem.WhenObject, CODES_TFhirEventTiming, false);
  ComposeEnumProps(json, 'when', elem.WhenObject, CODES_TFhirEventTiming, false);
  ComposeDecimalValue(json, 'duration', elem.durationObject, false);
  ComposeDecimalProps(json, 'duration', elem.durationObject, false);
  ComposeEnumValue(json, 'units', elem.UnitsObject, CODES_TFhirUnitsOfTime, false);
  ComposeEnumProps(json, 'units', elem.UnitsObject, CODES_TFhirUnitsOfTime, false);
  ComposeIntegerValue(json, 'count', elem.countObject, false);
  ComposeIntegerProps(json, 'count', elem.countObject, false);
  ComposeDateTimeValue(json, 'end', elem.end_Object, false);
  ComposeDateTimeProps(json, 'end', elem.end_Object, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseTiming(element : IXmlDomElement; path : string) : TFhirTiming;
var
  child : IXMLDOMElement;
begin
  result := TFhirTiming.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'event') then
        result.eventList.Add(ParsePeriod(child, path+'/event')){y.2}
      else if (child.baseName = 'repeat') then
        result.repeat_ := ParseTimingRepeat(child, path+'/repeat') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTiming(xml : TXmlBuilder; name : string; elem : TFhirTiming);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  for i := 0 to elem.eventList.Count - 1 do
    ComposePeriod(xml, 'event', elem.eventList[i]);
  ComposeTimingRepeat(xml, 'repeat', elem.repeat_);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTiming(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTiming(jsn));
end;

function TFHIRJsonParser.ParseTiming(jsn : TJsonObject) : TFhirTiming;
begin
  result := TFhirTiming.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parsePeriod);
    if jsn.has('repeat') then
        result.repeat_ := ParseTimingRepeat(jsn.vObj['repeat']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTiming(json : TJSONWriter; name : string; elem : TFhirTiming);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposePeriod(json, '',elem.eventList[i]); {z - Period}
    json.FinishArray;
  end;
  ComposeTimingRepeat(json, 'repeat', elem.repeat_); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseAddress(element : IXmlDomElement; path : string) : TFhirAddress;
var
  child : IXMLDOMElement;
begin
  result := TFhirAddress.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'use') then
        result.useObject := ParseEnum(CODES_TFhirAddressUse, path+'/use', child){1a}
      else if (child.baseName = 'text') then
        result.textObject := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'line') then
        result.lineList.Add(ParseString(child, path+'/line')){y.2}
      else if (child.baseName = 'city') then
        result.cityObject := ParseString(child, path+'/city') {b}
      else if (child.baseName = 'state') then
        result.stateObject := ParseString(child, path+'/state') {b}
      else if (child.baseName = 'zip') then
        result.zipObject := ParseString(child, path+'/zip') {b}
      else if (child.baseName = 'country') then
        result.countryObject := ParseString(child, path+'/country') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAddress(xml : TXmlBuilder; name : string; elem : TFhirAddress);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'use', elem.UseObject, CODES_TFhirAddressUse);
  ComposeString(xml, 'text', elem.textObject);{x.2}
  for i := 0 to elem.lineList.Count - 1 do
    ComposeString(xml, 'line', elem.lineList[i]);
  ComposeString(xml, 'city', elem.cityObject);{x.2}
  ComposeString(xml, 'state', elem.stateObject);{x.2}
  ComposeString(xml, 'zip', elem.zipObject);{x.2}
  ComposeString(xml, 'country', elem.countryObject);{x.2}
  ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAddress(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAddress(jsn));
end;

function TFHIRJsonParser.ParseAddress(jsn : TJsonObject) : TFhirAddress;
begin
  result := TFhirAddress.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.useObject := parseEnum(jsn['use'], jsn.vObj['_use'], CODES_TFhirAddressUse);
    if jsn.has('text') or jsn.has('_text') then
        result.textObject := ParseString(jsn['text'], jsn.vObj['_text']);{q}
      if jsn.has('line') or jsn.has('_line') then
      iteratePrimitiveArray(jsn.vArr['line'], jsn.vArr['_line'], result.lineList, parseString);
    if jsn.has('city') or jsn.has('_city') then
        result.cityObject := ParseString(jsn['city'], jsn.vObj['_city']);{q}
    if jsn.has('state') or jsn.has('_state') then
        result.stateObject := ParseString(jsn['state'], jsn.vObj['_state']);{q}
    if jsn.has('zip') or jsn.has('_zip') then
        result.zipObject := ParseString(jsn['zip'], jsn.vObj['_zip']);{q}
    if jsn.has('country') or jsn.has('_country') then
        result.countryObject := ParseString(jsn['country'], jsn.vObj['_country']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAddress(json : TJSONWriter; name : string; elem : TFhirAddress);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'use', elem.UseObject, CODES_TFhirAddressUse, false);
  ComposeEnumProps(json, 'use', elem.UseObject, CODES_TFhirAddressUse, false);
  ComposeStringValue(json, 'text', elem.textObject, false);
  ComposeStringProps(json, 'text', elem.textObject, false);
  if elem.lineList.Count > 0 then
  begin
    json.valueArray('line');
    ext := false;
    for i := 0 to elem.lineList.Count - 1 do
    begin
      ext := ext or ((elem.lineList[i].xmlid <> '') or (elem.lineList[i].hasExtensions));
      ComposeStringValue(json, '',elem.lineList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_line');
      for i := 0 to elem.lineList.Count - 1 do
        ComposeStringProps(json, '',elem.lineList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeStringValue(json, 'city', elem.cityObject, false);
  ComposeStringProps(json, 'city', elem.cityObject, false);
  ComposeStringValue(json, 'state', elem.stateObject, false);
  ComposeStringProps(json, 'state', elem.stateObject, false);
  ComposeStringValue(json, 'zip', elem.zipObject, false);
  ComposeStringProps(json, 'zip', elem.zipObject, false);
  ComposeStringValue(json, 'country', elem.countryObject, false);
  ComposeStringProps(json, 'country', elem.countryObject, false);
  ComposePeriod(json, 'period', elem.period); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseHumanName(element : IXmlDomElement; path : string) : TFhirHumanName;
var
  child : IXMLDOMElement;
begin
  result := TFhirHumanName.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'use') then
        result.useObject := ParseEnum(CODES_TFhirNameUse, path+'/use', child){1a}
      else if (child.baseName = 'text') then
        result.textObject := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'family') then
        result.familyList.Add(ParseString(child, path+'/family')){y.2}
      else if (child.baseName = 'given') then
        result.givenList.Add(ParseString(child, path+'/given')){y.2}
      else if (child.baseName = 'prefix') then
        result.prefixList.Add(ParseString(child, path+'/prefix')){y.2}
      else if (child.baseName = 'suffix') then
        result.suffixList.Add(ParseString(child, path+'/suffix')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeHumanName(xml : TXmlBuilder; name : string; elem : TFhirHumanName);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'use', elem.UseObject, CODES_TFhirNameUse);
  ComposeString(xml, 'text', elem.textObject);{x.2}
  for i := 0 to elem.familyList.Count - 1 do
    ComposeString(xml, 'family', elem.familyList[i]);
  for i := 0 to elem.givenList.Count - 1 do
    ComposeString(xml, 'given', elem.givenList[i]);
  for i := 0 to elem.prefixList.Count - 1 do
    ComposeString(xml, 'prefix', elem.prefixList[i]);
  for i := 0 to elem.suffixList.Count - 1 do
    ComposeString(xml, 'suffix', elem.suffixList[i]);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseHumanName(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHumanName(jsn));
end;

function TFHIRJsonParser.ParseHumanName(jsn : TJsonObject) : TFhirHumanName;
begin
  result := TFhirHumanName.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.useObject := parseEnum(jsn['use'], jsn.vObj['_use'], CODES_TFhirNameUse);
    if jsn.has('text') or jsn.has('_text') then
        result.textObject := ParseString(jsn['text'], jsn.vObj['_text']);{q}
      if jsn.has('family') or jsn.has('_family') then
      iteratePrimitiveArray(jsn.vArr['family'], jsn.vArr['_family'], result.familyList, parseString);
      if jsn.has('given') or jsn.has('_given') then
      iteratePrimitiveArray(jsn.vArr['given'], jsn.vArr['_given'], result.givenList, parseString);
      if jsn.has('prefix') or jsn.has('_prefix') then
      iteratePrimitiveArray(jsn.vArr['prefix'], jsn.vArr['_prefix'], result.prefixList, parseString);
      if jsn.has('suffix') or jsn.has('_suffix') then
      iteratePrimitiveArray(jsn.vArr['suffix'], jsn.vArr['_suffix'], result.suffixList, parseString);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeHumanName(json : TJSONWriter; name : string; elem : TFhirHumanName);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'use', elem.UseObject, CODES_TFhirNameUse, false);
  ComposeEnumProps(json, 'use', elem.UseObject, CODES_TFhirNameUse, false);
  ComposeStringValue(json, 'text', elem.textObject, false);
  ComposeStringProps(json, 'text', elem.textObject, false);
  if elem.familyList.Count > 0 then
  begin
    json.valueArray('family');
    ext := false;
    for i := 0 to elem.familyList.Count - 1 do
    begin
      ext := ext or ((elem.familyList[i].xmlid <> '') or (elem.familyList[i].hasExtensions));
      ComposeStringValue(json, '',elem.familyList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_family');
      for i := 0 to elem.familyList.Count - 1 do
        ComposeStringProps(json, '',elem.familyList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.givenList.Count > 0 then
  begin
    json.valueArray('given');
    ext := false;
    for i := 0 to elem.givenList.Count - 1 do
    begin
      ext := ext or ((elem.givenList[i].xmlid <> '') or (elem.givenList[i].hasExtensions));
      ComposeStringValue(json, '',elem.givenList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_given');
      for i := 0 to elem.givenList.Count - 1 do
        ComposeStringProps(json, '',elem.givenList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.prefixList.Count > 0 then
  begin
    json.valueArray('prefix');
    ext := false;
    for i := 0 to elem.prefixList.Count - 1 do
    begin
      ext := ext or ((elem.prefixList[i].xmlid <> '') or (elem.prefixList[i].hasExtensions));
      ComposeStringValue(json, '',elem.prefixList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_prefix');
      for i := 0 to elem.prefixList.Count - 1 do
        ComposeStringProps(json, '',elem.prefixList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.suffixList.Count > 0 then
  begin
    json.valueArray('suffix');
    ext := false;
    for i := 0 to elem.suffixList.Count - 1 do
    begin
      ext := ext or ((elem.suffixList[i].xmlid <> '') or (elem.suffixList[i].hasExtensions));
      ComposeStringValue(json, '',elem.suffixList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_suffix');
      for i := 0 to elem.suffixList.Count - 1 do
        ComposeStringProps(json, '',elem.suffixList[i], true);
      json.FinishArray;
    end;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseContactPoint(element : IXmlDomElement; path : string) : TFhirContactPoint;
var
  child : IXMLDOMElement;
begin
  result := TFhirContactPoint.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.systemObject := ParseEnum(CODES_TFhirContactPointSystem, path+'/system', child){1a}
      else if (child.baseName = 'value') then
        result.valueObject := ParseString(child, path+'/value') {b}
      else if (child.baseName = 'use') then
        result.useObject := ParseEnum(CODES_TFhirContactPointUse, path+'/use', child){1a}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContactPoint(xml : TXmlBuilder; name : string; elem : TFhirContactPoint);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'system', elem.SystemObject, CODES_TFhirContactPointSystem);
  ComposeString(xml, 'value', elem.valueObject);{x.2}
  ComposeEnum(xml, 'use', elem.UseObject, CODES_TFhirContactPointUse);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContactPoint(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContactPoint(jsn));
end;

function TFHIRJsonParser.ParseContactPoint(jsn : TJsonObject) : TFhirContactPoint;
begin
  result := TFhirContactPoint.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system')  then
      result.systemObject := parseEnum(jsn['system'], jsn.vObj['_system'], CODES_TFhirContactPointSystem);
    if jsn.has('value') or jsn.has('_value') then
        result.valueObject := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    if jsn.has('use') or jsn.has('_use')  then
      result.useObject := parseEnum(jsn['use'], jsn.vObj['_use'], CODES_TFhirContactPointUse);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContactPoint(json : TJSONWriter; name : string; elem : TFhirContactPoint);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'system', elem.SystemObject, CODES_TFhirContactPointSystem, false);
  ComposeEnumProps(json, 'system', elem.SystemObject, CODES_TFhirContactPointSystem, false);
  ComposeStringValue(json, 'value', elem.valueObject, false);
  ComposeStringProps(json, 'value', elem.valueObject, false);
  ComposeEnumValue(json, 'use', elem.UseObject, CODES_TFhirContactPointUse, false);
  ComposeEnumProps(json, 'use', elem.UseObject, CODES_TFhirContactPointUse, false);
  ComposePeriod(json, 'period', elem.period); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseAge(element : IXmlDomElement; path : string) : TFhirAge;
begin
  result := ParseQuantity(element, path);
end;

procedure TFHIRXmlComposer.ComposeAge(xml : TXmlBuilder; name : string; elem : TFhirAge);
begin
  ComposeQuantity(xml, name, elem);
end;

function TFHIRJsonParser.ParseAge(jsn : TJsonObject) : TFhirAge;
begin
  result := ParseQuantity(jsn);
end;

procedure TFHIRJsonComposer.ComposeAge(json : TJSONWriter; name : string; elem : TFhirAge);
begin
  ComposeQuantity(json, name, elem);
end;

function TFHIRXmlParser.ParseCount(element : IXmlDomElement; path : string) : TFhirCount;
begin
  result := ParseQuantity(element, path);
end;

procedure TFHIRXmlComposer.ComposeCount(xml : TXmlBuilder; name : string; elem : TFhirCount);
begin
  ComposeQuantity(xml, name, elem);
end;

function TFHIRJsonParser.ParseCount(jsn : TJsonObject) : TFhirCount;
begin
  result := ParseQuantity(jsn);
end;

procedure TFHIRJsonComposer.ComposeCount(json : TJSONWriter; name : string; elem : TFhirCount);
begin
  ComposeQuantity(json, name, elem);
end;

function TFHIRXmlParser.ParseMoney(element : IXmlDomElement; path : string) : TFhirMoney;
begin
  result := ParseQuantity(element, path);
end;

procedure TFHIRXmlComposer.ComposeMoney(xml : TXmlBuilder; name : string; elem : TFhirMoney);
begin
  ComposeQuantity(xml, name, elem);
end;

function TFHIRJsonParser.ParseMoney(jsn : TJsonObject) : TFhirMoney;
begin
  result := ParseQuantity(jsn);
end;

procedure TFHIRJsonComposer.ComposeMoney(json : TJSONWriter; name : string; elem : TFhirMoney);
begin
  ComposeQuantity(json, name, elem);
end;

function TFHIRXmlParser.ParseDistance(element : IXmlDomElement; path : string) : TFhirDistance;
begin
  result := ParseQuantity(element, path);
end;

procedure TFHIRXmlComposer.ComposeDistance(xml : TXmlBuilder; name : string; elem : TFhirDistance);
begin
  ComposeQuantity(xml, name, elem);
end;

function TFHIRJsonParser.ParseDistance(jsn : TJsonObject) : TFhirDistance;
begin
  result := ParseQuantity(jsn);
end;

procedure TFHIRJsonComposer.ComposeDistance(json : TJSONWriter; name : string; elem : TFhirDistance);
begin
  ComposeQuantity(json, name, elem);
end;

function TFHIRXmlParser.ParseDuration(element : IXmlDomElement; path : string) : TFhirDuration;
begin
  result := ParseQuantity(element, path);
end;

procedure TFHIRXmlComposer.ComposeDuration(xml : TXmlBuilder; name : string; elem : TFhirDuration);
begin
  ComposeQuantity(xml, name, elem);
end;

function TFHIRJsonParser.ParseDuration(jsn : TJsonObject) : TFhirDuration;
begin
  result := ParseQuantity(jsn);
end;

procedure TFHIRJsonComposer.ComposeDuration(json : TJSONWriter; name : string; elem : TFhirDuration);
begin
  ComposeQuantity(json, name, elem);
end;

function TFHIRXmlParser.ParseAdverseReactionSymptom(element : IXmlDomElement; path : string) : TFhirAdverseReactionSymptom;
var
  child : IXMLDOMElement;
begin
  result := TFhirAdverseReactionSymptom.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'severity') then
        result.severityObject := ParseEnum(CODES_TFhirReactionSeverity, path+'/severity', child){1a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAdverseReactionSymptom(xml : TXmlBuilder; name : string; elem : TFhirAdverseReactionSymptom);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeEnum(xml, 'severity', elem.SeverityObject, CODES_TFhirReactionSeverity);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAdverseReactionSymptom(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAdverseReactionSymptom(jsn));
end;

function TFHIRJsonParser.ParseAdverseReactionSymptom(jsn : TJsonObject) : TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityObject := parseEnum(jsn['severity'], jsn.vObj['_severity'], CODES_TFhirReactionSeverity);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAdverseReactionSymptom(json : TJSONWriter; name : string; elem : TFhirAdverseReactionSymptom);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeEnumValue(json, 'severity', elem.SeverityObject, CODES_TFhirReactionSeverity, false);
  ComposeEnumProps(json, 'severity', elem.SeverityObject, CODES_TFhirReactionSeverity, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseAdverseReactionExposure(element : IXmlDomElement; path : string) : TFhirAdverseReactionExposure;
var
  child : IXMLDOMElement;
begin
  result := TFhirAdverseReactionExposure.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'type') then
        result.type_Object := ParseEnum(CODES_TFhirExposureType, path+'/type', child){1a}
      else if (child.baseName = 'causalityExpectation') then
        result.causalityExpectationObject := ParseEnum(CODES_TFhirCausalityExpectation, path+'/causalityExpectation', child){1a}
      else if (child.baseName = 'substance') then
        result.substance := ParseReference{TFhirSubstance}(child, path+'/substance') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAdverseReactionExposure(xml : TXmlBuilder; name : string; elem : TFhirAdverseReactionExposure);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  ComposeEnum(xml, 'type', elem.Type_Object, CODES_TFhirExposureType);
  ComposeEnum(xml, 'causalityExpectation', elem.CausalityExpectationObject, CODES_TFhirCausalityExpectation);
  ComposeReference{TFhirSubstance}(xml, 'substance', elem.substance);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAdverseReactionExposure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAdverseReactionExposure(jsn));
end;

function TFHIRJsonParser.ParseAdverseReactionExposure(jsn : TJsonObject) : TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Object := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirExposureType);
    if jsn.has('causalityExpectation') or jsn.has('_causalityExpectation')  then
      result.causalityExpectationObject := parseEnum(jsn['causalityExpectation'], jsn.vObj['_causalityExpectation'], CODES_TFhirCausalityExpectation);
    if jsn.has('substance') then
        result.substance := ParseReference{TFhirSubstance}(jsn.vObj['substance']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAdverseReactionExposure(json : TJSONWriter; name : string; elem : TFhirAdverseReactionExposure);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  ComposeEnumValue(json, 'type', elem.Type_Object, CODES_TFhirExposureType, false);
  ComposeEnumProps(json, 'type', elem.Type_Object, CODES_TFhirExposureType, false);
  ComposeEnumValue(json, 'causalityExpectation', elem.CausalityExpectationObject, CODES_TFhirCausalityExpectation, false);
  ComposeEnumProps(json, 'causalityExpectation', elem.CausalityExpectationObject, CODES_TFhirCausalityExpectation, false);
  ComposeReference{TFhirSubstance}(json, 'substance', elem.substance); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseAdverseReaction(element : IXmlDomElement; path : string) : TFhirAdverseReaction;
var
  child : IXMLDOMElement;
begin
  result := TFhirAdverseReaction.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'didNotOccurFlag') then
        result.didNotOccurFlagObject := ParseBoolean(child, path+'/didNotOccurFlag') {b}
      else if (child.baseName = 'recorder') then
        result.recorder := ParseReference{Resource}(child, path+'/recorder') {b}
      else if (child.baseName = 'symptom') then
        result.symptomList.Add(ParseAdverseReactionSymptom(child, path+'/symptom')){y.2}
      else if (child.baseName = 'exposure') then
        result.exposureList.Add(ParseAdverseReactionExposure(child, path+'/exposure')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAdverseReaction(xml : TXmlBuilder; name : string; elem : TFhirAdverseReaction);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  ComposeBoolean(xml, 'didNotOccurFlag', elem.didNotOccurFlagObject);{x.2}
  ComposeReference{Resource}(xml, 'recorder', elem.recorder);{x.2}
  for i := 0 to elem.symptomList.Count - 1 do
    ComposeAdverseReactionSymptom(xml, 'symptom', elem.symptomList[i]);
  for i := 0 to elem.exposureList.Count - 1 do
    ComposeAdverseReactionExposure(xml, 'exposure', elem.exposureList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAdverseReaction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAdverseReaction(jsn));
end;

function TFHIRJsonParser.ParseAdverseReaction(jsn : TJsonObject) : TFhirAdverseReaction;
begin
  result := TFhirAdverseReaction.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('didNotOccurFlag') or jsn.has('_didNotOccurFlag') then
        result.didNotOccurFlagObject := ParseBoolean(jsn['didNotOccurFlag'], jsn.vObj['_didNotOccurFlag']);{q}
    if jsn.has('recorder') then
        result.recorder := ParseReference{Resource}(jsn.vObj['recorder']);{q}
    if jsn.has('symptom') then
      iterateArray(jsn.vArr['symptom'], result.symptomList, parseAdverseReactionSymptom);
    if jsn.has('exposure') then
      iterateArray(jsn.vArr['exposure'], result.exposureList, parseAdverseReactionExposure);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAdverseReaction(json : TJSONWriter; name : string; elem : TFhirAdverseReaction);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeBooleanValue(json, 'didNotOccurFlag', elem.didNotOccurFlagObject, false);
  ComposeBooleanProps(json, 'didNotOccurFlag', elem.didNotOccurFlagObject, false);
  ComposeReference{Resource}(json, 'recorder', elem.recorder); {a}
  if elem.symptomList.Count > 0 then
  begin
    json.valueArray('symptom');
    for i := 0 to elem.symptomList.Count - 1 do
      ComposeAdverseReactionSymptom(json, '',elem.symptomList[i]); {z - }
    json.FinishArray;
  end;
  if elem.exposureList.Count > 0 then
  begin
    json.valueArray('exposure');
    for i := 0 to elem.exposureList.Count - 1 do
      ComposeAdverseReactionExposure(json, '',elem.exposureList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseAlert(element : IXmlDomElement; path : string) : TFhirAlert;
var
  child : IXMLDOMElement;
begin
  result := TFhirAlert.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirAlertStatus, path+'/status', child){1a}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'note') then
        result.noteObject := ParseString(child, path+'/note') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAlert(xml : TXmlBuilder; name : string; elem : TFhirAlert);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirAlertStatus);
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{Resource}(xml, 'author', elem.author);{x.2}
  ComposeString(xml, 'note', elem.noteObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAlert(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAlert(jsn));
end;

function TFHIRJsonParser.ParseAlert(jsn : TJsonObject) : TFhirAlert;
begin
  result := TFhirAlert.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirAlertStatus);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('note') or jsn.has('_note') then
        result.noteObject := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAlert(json : TJSONWriter; name : string; elem : TFhirAlert);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirAlertStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirAlertStatus, false);
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeReference{Resource}(json, 'author', elem.author); {a}
  ComposeStringValue(json, 'note', elem.noteObject, false);
  ComposeStringProps(json, 'note', elem.noteObject, false);
end;

function TFHIRXmlParser.ParseAllergyIntolerance(element : IXmlDomElement; path : string) : TFhirAllergyIntolerance;
var
  child : IXMLDOMElement;
begin
  result := TFhirAllergyIntolerance.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'criticality') then
        result.criticalityObject := ParseEnum(CODES_TFhirCriticality, path+'/criticality', child){1a}
      else if (child.baseName = 'sensitivityType') then
        result.sensitivityTypeObject := ParseEnum(CODES_TFhirSensitivitytype, path+'/sensitivityType', child){1a}
      else if (child.baseName = 'recordedDate') then
        result.recordedDateObject := ParseDateTime(child, path+'/recordedDate') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirSensitivitystatus, path+'/status', child){1a}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'recorder') then
        result.recorder := ParseReference{Resource}(child, path+'/recorder') {b}
      else if (child.baseName = 'substance') then
        result.substance := ParseReference{TFhirSubstance}(child, path+'/substance') {b}
      else if (child.baseName = 'reaction') then
        result.reactionList.Add(ParseReference{TFhirAdverseReaction}(child, path+'/reaction')){y.2}
      else if (child.baseName = 'sensitivityTest') then
        result.sensitivityTestList.Add(ParseReference{TFhirObservation}(child, path+'/sensitivityTest')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntolerance(xml : TXmlBuilder; name : string; elem : TFhirAllergyIntolerance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'criticality', elem.CriticalityObject, CODES_TFhirCriticality);
  ComposeEnum(xml, 'sensitivityType', elem.SensitivityTypeObject, CODES_TFhirSensitivitytype);
  ComposeDateTime(xml, 'recordedDate', elem.recordedDateObject);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirSensitivitystatus);
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{Resource}(xml, 'recorder', elem.recorder);{x.2}
  ComposeReference{TFhirSubstance}(xml, 'substance', elem.substance);{x.2}
  for i := 0 to elem.reactionList.Count - 1 do
    ComposeReference{TFhirAdverseReaction}(xml, 'reaction', elem.reactionList[i]);
  for i := 0 to elem.sensitivityTestList.Count - 1 do
    ComposeReference{TFhirObservation}(xml, 'sensitivityTest', elem.sensitivityTestList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAllergyIntolerance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAllergyIntolerance(jsn));
end;

function TFHIRJsonParser.ParseAllergyIntolerance(jsn : TJsonObject) : TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('criticality') or jsn.has('_criticality')  then
      result.criticalityObject := parseEnum(jsn['criticality'], jsn.vObj['_criticality'], CODES_TFhirCriticality);
    if jsn.has('sensitivityType') or jsn.has('_sensitivityType')  then
      result.sensitivityTypeObject := parseEnum(jsn['sensitivityType'], jsn.vObj['_sensitivityType'], CODES_TFhirSensitivitytype);
    if jsn.has('recordedDate') or jsn.has('_recordedDate') then
        result.recordedDateObject := ParseDateTime(jsn['recordedDate'], jsn.vObj['_recordedDate']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirSensitivitystatus);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('recorder') then
        result.recorder := ParseReference{Resource}(jsn.vObj['recorder']);{q}
    if jsn.has('substance') then
        result.substance := ParseReference{TFhirSubstance}(jsn.vObj['substance']);{q}
    if jsn.has('reaction') then
      iterateArray(jsn.vArr['reaction'], result.reactionList, parseReference{TFhirAdverseReaction});
    if jsn.has('sensitivityTest') then
      iterateArray(jsn.vArr['sensitivityTest'], result.sensitivityTestList, parseReference{TFhirObservation});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAllergyIntolerance(json : TJSONWriter; name : string; elem : TFhirAllergyIntolerance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'criticality', elem.CriticalityObject, CODES_TFhirCriticality, false);
  ComposeEnumProps(json, 'criticality', elem.CriticalityObject, CODES_TFhirCriticality, false);
  ComposeEnumValue(json, 'sensitivityType', elem.SensitivityTypeObject, CODES_TFhirSensitivitytype, false);
  ComposeEnumProps(json, 'sensitivityType', elem.SensitivityTypeObject, CODES_TFhirSensitivitytype, false);
  ComposeDateTimeValue(json, 'recordedDate', elem.recordedDateObject, false);
  ComposeDateTimeProps(json, 'recordedDate', elem.recordedDateObject, false);
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirSensitivitystatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirSensitivitystatus, false);
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeReference{Resource}(json, 'recorder', elem.recorder); {a}
  ComposeReference{TFhirSubstance}(json, 'substance', elem.substance); {a}
  if elem.reactionList.Count > 0 then
  begin
    json.valueArray('reaction');
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeReference{TFhirAdverseReaction}(json, '',elem.reactionList[i]); {z - Reference(AdverseReaction)}
    json.FinishArray;
  end;
  if elem.sensitivityTestList.Count > 0 then
  begin
    json.valueArray('sensitivityTest');
    for i := 0 to elem.sensitivityTestList.Count - 1 do
      ComposeReference{TFhirObservation}(json, '',elem.sensitivityTestList[i]); {z - Reference(Observation)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseAppointmentParticipant(element : IXmlDomElement; path : string) : TFhirAppointmentParticipant;
var
  child : IXMLDOMElement;
begin
  result := TFhirAppointmentParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.baseName = 'actor') then
        result.actor := ParseReference{TFhirReference}(child, path+'/actor') {b}
      else if (child.baseName = 'required') then
        result.requiredObject := ParseEnum(CODES_TFhirParticipantrequired, path+'/required', child){1a}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirParticipationstatus, path+'/status', child){1a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAppointmentParticipant(xml : TXmlBuilder; name : string; elem : TFhirAppointmentParticipant);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  ComposeReference{TFhirReference}(xml, 'actor', elem.actor);{x.2}
  ComposeEnum(xml, 'required', elem.RequiredObject, CODES_TFhirParticipantrequired);
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirParticipationstatus);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAppointmentParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAppointmentParticipant(jsn));
end;

function TFHIRJsonParser.ParseAppointmentParticipant(jsn : TJsonObject) : TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('actor') then
        result.actor := ParseReference{TFhirReference}(jsn.vObj['actor']);{q}
    if jsn.has('required') or jsn.has('_required')  then
      result.requiredObject := parseEnum(jsn['required'], jsn.vObj['_required'], CODES_TFhirParticipantrequired);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirParticipationstatus);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAppointmentParticipant(json : TJSONWriter; name : string; elem : TFhirAppointmentParticipant);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '',elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeReference{TFhirReference}(json, 'actor', elem.actor); {a}
  ComposeEnumValue(json, 'required', elem.RequiredObject, CODES_TFhirParticipantrequired, false);
  ComposeEnumProps(json, 'required', elem.RequiredObject, CODES_TFhirParticipantrequired, false);
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirParticipationstatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirParticipationstatus, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseAppointment(element : IXmlDomElement; path : string) : TFhirAppointment;
var
  child : IXMLDOMElement;
begin
  result := TFhirAppointment.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'priority') then
        result.priorityObject := ParseInteger(child, path+'/priority') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseCode(child, path+'/status') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'start') then
        result.startObject := ParseInstant(child, path+'/start') {b}
      else if (child.baseName = 'end') then
        result.end_Object := ParseInstant(child, path+'/end') {b}
      else if (child.baseName = 'slot') then
        result.slotList.Add(ParseReference{TFhirSlot}(child, path+'/slot')){y.2}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'comment') then
        result.commentObject := ParseString(child, path+'/comment') {b}
      else if (child.baseName = 'order') then
        result.order := ParseReference{TFhirOrder}(child, path+'/order') {b}
      else if (child.baseName = 'participant') then
        result.participantList.Add(ParseAppointmentParticipant(child, path+'/participant')){y.2}
      else if (child.baseName = 'lastModifiedBy') then
        result.lastModifiedBy := ParseReference{Resource}(child, path+'/lastModifiedBy') {b}
      else if (child.baseName = 'lastModified') then
        result.lastModifiedObject := ParseDateTime(child, path+'/lastModified') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAppointment(xml : TXmlBuilder; name : string; elem : TFhirAppointment);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeInteger(xml, 'priority', elem.priorityObject);{x.2}
  ComposeCode(xml, 'status', elem.statusObject);{x.2}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2}
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  ComposeInstant(xml, 'start', elem.startObject);{x.2}
  ComposeInstant(xml, 'end', elem.end_Object);{x.2}
  for i := 0 to elem.slotList.Count - 1 do
    ComposeReference{TFhirSlot}(xml, 'slot', elem.slotList[i]);
  ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  ComposeString(xml, 'comment', elem.commentObject);{x.2}
  ComposeReference{TFhirOrder}(xml, 'order', elem.order);{x.2}
  for i := 0 to elem.participantList.Count - 1 do
    ComposeAppointmentParticipant(xml, 'participant', elem.participantList[i]);
  ComposeReference{Resource}(xml, 'lastModifiedBy', elem.lastModifiedBy);{x.2}
  ComposeDateTime(xml, 'lastModified', elem.lastModifiedObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAppointment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAppointment(jsn));
end;

function TFHIRJsonParser.ParseAppointment(jsn : TJsonObject) : TFhirAppointment;
begin
  result := TFhirAppointment.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('priority') or jsn.has('_priority') then
        result.priorityObject := ParseInteger(jsn['priority'], jsn.vObj['_priority']);{q}
    if jsn.has('status') or jsn.has('_status') then
        result.statusObject := ParseCode(jsn['status'], jsn.vObj['_status']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('start') or jsn.has('_start') then
        result.startObject := ParseInstant(jsn['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Object := ParseInstant(jsn['end'], jsn.vObj['_end']);{q}
    if jsn.has('slot') then
      iterateArray(jsn.vArr['slot'], result.slotList, parseReference{TFhirSlot});
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentObject := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('order') then
        result.order := ParseReference{TFhirOrder}(jsn.vObj['order']);{q}
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseAppointmentParticipant);
    if jsn.has('lastModifiedBy') then
        result.lastModifiedBy := ParseReference{Resource}(jsn.vObj['lastModifiedBy']);{q}
    if jsn.has('lastModified') or jsn.has('_lastModified') then
        result.lastModifiedObject := ParseDateTime(jsn['lastModified'], jsn.vObj['_lastModified']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAppointment(json : TJSONWriter; name : string; elem : TFhirAppointment);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeIntegerValue(json, 'priority', elem.priorityObject, false);
  ComposeIntegerProps(json, 'priority', elem.priorityObject, false);
  ComposeCodeValue(json, 'status', elem.statusObject, false);
  ComposeCodeProps(json, 'status', elem.statusObject, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  ComposeInstantValue(json, 'start', elem.startObject, false);
  ComposeInstantProps(json, 'start', elem.startObject, false);
  ComposeInstantValue(json, 'end', elem.end_Object, false);
  ComposeInstantProps(json, 'end', elem.end_Object, false);
  if elem.slotList.Count > 0 then
  begin
    json.valueArray('slot');
    for i := 0 to elem.slotList.Count - 1 do
      ComposeReference{TFhirSlot}(json, '',elem.slotList[i]); {z - Reference(Slot)}
    json.FinishArray;
  end;
  ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  ComposeStringValue(json, 'comment', elem.commentObject, false);
  ComposeStringProps(json, 'comment', elem.commentObject, false);
  ComposeReference{TFhirOrder}(json, 'order', elem.order); {a}
  if elem.participantList.Count > 0 then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeAppointmentParticipant(json, '',elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  ComposeReference{Resource}(json, 'lastModifiedBy', elem.lastModifiedBy); {a}
  ComposeDateTimeValue(json, 'lastModified', elem.lastModifiedObject, false);
  ComposeDateTimeProps(json, 'lastModified', elem.lastModifiedObject, false);
end;

function TFHIRXmlParser.ParseAppointmentResponse(element : IXmlDomElement; path : string) : TFhirAppointmentResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirAppointmentResponse.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'appointment') then
        result.appointment := ParseReference{TFhirAppointment}(child, path+'/appointment') {b}
      else if (child.baseName = 'participantType') then
        result.participantTypeList.Add(ParseCodeableConcept(child, path+'/participantType')){y.2}
      else if (child.baseName = 'individual') then
        result.individualList.Add(ParseReference{TFhirReference}(child, path+'/individual')){y.2}
      else if (child.baseName = 'participantStatus') then
        result.participantStatusObject := ParseEnum(CODES_TFhirParticipantstatus, path+'/participantStatus', child){1a}
      else if (child.baseName = 'comment') then
        result.commentObject := ParseString(child, path+'/comment') {b}
      else if (child.baseName = 'start') then
        result.startObject := ParseInstant(child, path+'/start') {b}
      else if (child.baseName = 'end') then
        result.end_Object := ParseInstant(child, path+'/end') {b}
      else if (child.baseName = 'lastModifiedBy') then
        result.lastModifiedBy := ParseReference{Resource}(child, path+'/lastModifiedBy') {b}
      else if (child.baseName = 'lastModified') then
        result.lastModifiedObject := ParseDateTime(child, path+'/lastModified') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAppointmentResponse(xml : TXmlBuilder; name : string; elem : TFhirAppointmentResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirAppointment}(xml, 'appointment', elem.appointment);{x.2}
  for i := 0 to elem.participantTypeList.Count - 1 do
    ComposeCodeableConcept(xml, 'participantType', elem.participantTypeList[i]);
  for i := 0 to elem.individualList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'individual', elem.individualList[i]);
  ComposeEnum(xml, 'participantStatus', elem.ParticipantStatusObject, CODES_TFhirParticipantstatus);
  ComposeString(xml, 'comment', elem.commentObject);{x.2}
  ComposeInstant(xml, 'start', elem.startObject);{x.2}
  ComposeInstant(xml, 'end', elem.end_Object);{x.2}
  ComposeReference{Resource}(xml, 'lastModifiedBy', elem.lastModifiedBy);{x.2}
  ComposeDateTime(xml, 'lastModified', elem.lastModifiedObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAppointmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAppointmentResponse(jsn));
end;

function TFHIRJsonParser.ParseAppointmentResponse(jsn : TJsonObject) : TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('appointment') then
        result.appointment := ParseReference{TFhirAppointment}(jsn.vObj['appointment']);{q}
    if jsn.has('participantType') then
      iterateArray(jsn.vArr['participantType'], result.participantTypeList, parseCodeableConcept);
    if jsn.has('individual') then
      iterateArray(jsn.vArr['individual'], result.individualList, parseReference{TFhirReference});
    if jsn.has('participantStatus') or jsn.has('_participantStatus')  then
      result.participantStatusObject := parseEnum(jsn['participantStatus'], jsn.vObj['_participantStatus'], CODES_TFhirParticipantstatus);
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentObject := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('start') or jsn.has('_start') then
        result.startObject := ParseInstant(jsn['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Object := ParseInstant(jsn['end'], jsn.vObj['_end']);{q}
    if jsn.has('lastModifiedBy') then
        result.lastModifiedBy := ParseReference{Resource}(jsn.vObj['lastModifiedBy']);{q}
    if jsn.has('lastModified') or jsn.has('_lastModified') then
        result.lastModifiedObject := ParseDateTime(jsn['lastModified'], jsn.vObj['_lastModified']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAppointmentResponse(json : TJSONWriter; name : string; elem : TFhirAppointmentResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirAppointment}(json, 'appointment', elem.appointment); {a}
  if elem.participantTypeList.Count > 0 then
  begin
    json.valueArray('participantType');
    for i := 0 to elem.participantTypeList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.participantTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.individualList.Count > 0 then
  begin
    json.valueArray('individual');
    for i := 0 to elem.individualList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.individualList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'participantStatus', elem.ParticipantStatusObject, CODES_TFhirParticipantstatus, false);
  ComposeEnumProps(json, 'participantStatus', elem.ParticipantStatusObject, CODES_TFhirParticipantstatus, false);
  ComposeStringValue(json, 'comment', elem.commentObject, false);
  ComposeStringProps(json, 'comment', elem.commentObject, false);
  ComposeInstantValue(json, 'start', elem.startObject, false);
  ComposeInstantProps(json, 'start', elem.startObject, false);
  ComposeInstantValue(json, 'end', elem.end_Object, false);
  ComposeInstantProps(json, 'end', elem.end_Object, false);
  ComposeReference{Resource}(json, 'lastModifiedBy', elem.lastModifiedBy); {a}
  ComposeDateTimeValue(json, 'lastModified', elem.lastModifiedObject, false);
  ComposeDateTimeProps(json, 'lastModified', elem.lastModifiedObject, false);
end;

function TFHIRXmlParser.ParseAvailability(element : IXmlDomElement; path : string) : TFhirAvailability;
var
  child : IXMLDOMElement;
begin
  result := TFhirAvailability.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.baseName = 'actor') then
        result.actor := ParseReference{TFhirReference}(child, path+'/actor') {b}
      else if (child.baseName = 'planningHorizon') then
        result.planningHorizon := ParsePeriod(child, path+'/planningHorizon') {b}
      else if (child.baseName = 'comment') then
        result.commentObject := ParseString(child, path+'/comment') {b}
      else if (child.baseName = 'lastModified') then
        result.lastModifiedObject := ParseDateTime(child, path+'/lastModified') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAvailability(xml : TXmlBuilder; name : string; elem : TFhirAvailability);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  ComposeReference{TFhirReference}(xml, 'actor', elem.actor);{x.2}
  ComposePeriod(xml, 'planningHorizon', elem.planningHorizon);{x.2}
  ComposeString(xml, 'comment', elem.commentObject);{x.2}
  ComposeDateTime(xml, 'lastModified', elem.lastModifiedObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAvailability(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAvailability(jsn));
end;

function TFHIRJsonParser.ParseAvailability(jsn : TJsonObject) : TFhirAvailability;
begin
  result := TFhirAvailability.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('actor') then
        result.actor := ParseReference{TFhirReference}(jsn.vObj['actor']);{q}
    if jsn.has('planningHorizon') then
        result.planningHorizon := ParsePeriod(jsn.vObj['planningHorizon']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentObject := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('lastModified') or jsn.has('_lastModified') then
        result.lastModifiedObject := ParseDateTime(jsn['lastModified'], jsn.vObj['_lastModified']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAvailability(json : TJSONWriter; name : string; elem : TFhirAvailability);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '',elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeReference{TFhirReference}(json, 'actor', elem.actor); {a}
  ComposePeriod(json, 'planningHorizon', elem.planningHorizon); {a}
  ComposeStringValue(json, 'comment', elem.commentObject, false);
  ComposeStringProps(json, 'comment', elem.commentObject, false);
  ComposeDateTimeValue(json, 'lastModified', elem.lastModifiedObject, false);
  ComposeDateTimeProps(json, 'lastModified', elem.lastModifiedObject, false);
end;

function TFHIRXmlParser.ParseCarePlanParticipant(element : IXmlDomElement; path : string) : TFhirCarePlanParticipant;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlanParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'role') then
        result.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.baseName = 'member') then
        result.member := ParseReference{Resource}(child, path+'/member') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlanParticipant(xml : TXmlBuilder; name : string; elem : TFhirCarePlanParticipant);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'role', elem.role);{x.2}
  ComposeReference{Resource}(xml, 'member', elem.member);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlanParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanParticipant(jsn));
end;

function TFHIRJsonParser.ParseCarePlanParticipant(jsn : TJsonObject) : TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q}
    if jsn.has('member') then
        result.member := ParseReference{Resource}(jsn.vObj['member']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlanParticipant(json : TJSONWriter; name : string; elem : TFhirCarePlanParticipant);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'role', elem.role); {a}
  ComposeReference{Resource}(json, 'member', elem.member); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseCarePlanGoal(element : IXmlDomElement; path : string) : TFhirCarePlanGoal;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlanGoal.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirCarePlanGoalStatus, path+'/status', child){1a}
      else if (child.baseName = 'notes') then
        result.notesObject := ParseString(child, path+'/notes') {b}
      else if (child.baseName = 'concern') then
        result.concernList.Add(ParseReference{TFhirCondition}(child, path+'/concern')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlanGoal(xml : TXmlBuilder; name : string; elem : TFhirCarePlanGoal);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirCarePlanGoalStatus);
  ComposeString(xml, 'notes', elem.notesObject);{x.2}
  for i := 0 to elem.concernList.Count - 1 do
    ComposeReference{TFhirCondition}(xml, 'concern', elem.concernList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlanGoal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanGoal(jsn));
end;

function TFHIRJsonParser.ParseCarePlanGoal(jsn : TJsonObject) : TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirCarePlanGoalStatus);
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesObject := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    if jsn.has('concern') then
      iterateArray(jsn.vArr['concern'], result.concernList, parseReference{TFhirCondition});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlanGoal(json : TJSONWriter; name : string; elem : TFhirCarePlanGoal);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirCarePlanGoalStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirCarePlanGoalStatus, false);
  ComposeStringValue(json, 'notes', elem.notesObject, false);
  ComposeStringProps(json, 'notes', elem.notesObject, false);
  if elem.concernList.Count > 0 then
  begin
    json.valueArray('concern');
    for i := 0 to elem.concernList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '',elem.concernList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseCarePlanActivity(element : IXmlDomElement; path : string) : TFhirCarePlanActivity;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlanActivity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'goal') then
        result.goalList.Add(ParseString(child, path+'/goal')){y.2}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirCarePlanActivityStatus, path+'/status', child){1a}
      else if (child.baseName = 'prohibited') then
        result.prohibitedObject := ParseBoolean(child, path+'/prohibited') {b}
      else if (child.baseName = 'actionResulting') then
        result.actionResultingList.Add(ParseReference{TFhirReference}(child, path+'/actionResulting')){y.2}
      else if (child.baseName = 'notes') then
        result.notesObject := ParseString(child, path+'/notes') {b}
      else if (child.baseName = 'detail') then
        result.detail := ParseReference{Resource}(child, path+'/detail') {b}
      else if (child.baseName = 'simple') then
        result.simple := ParseCarePlanActivitySimple(child, path+'/simple') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivity(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivity);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.goalList.Count - 1 do
    ComposeString(xml, 'goal', elem.goalList[i]);
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirCarePlanActivityStatus);
  ComposeBoolean(xml, 'prohibited', elem.prohibitedObject);{x.2}
  for i := 0 to elem.actionResultingList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'actionResulting', elem.actionResultingList[i]);
  ComposeString(xml, 'notes', elem.notesObject);{x.2}
  ComposeReference{Resource}(xml, 'detail', elem.detail);{x.2}
  ComposeCarePlanActivitySimple(xml, 'simple', elem.simple);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlanActivity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanActivity(jsn));
end;

function TFHIRJsonParser.ParseCarePlanActivity(jsn : TJsonObject) : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('goal') or jsn.has('_goal') then
      iteratePrimitiveArray(jsn.vArr['goal'], jsn.vArr['_goal'], result.goalList, parseString);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirCarePlanActivityStatus);
    if jsn.has('prohibited') or jsn.has('_prohibited') then
        result.prohibitedObject := ParseBoolean(jsn['prohibited'], jsn.vObj['_prohibited']);{q}
    if jsn.has('actionResulting') then
      iterateArray(jsn.vArr['actionResulting'], result.actionResultingList, parseReference{TFhirReference});
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesObject := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    if jsn.has('detail') then
        result.detail := ParseReference{Resource}(jsn.vObj['detail']);{q}
    if jsn.has('simple') then
        result.simple := ParseCarePlanActivitySimple(jsn.vObj['simple']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlanActivity(json : TJSONWriter; name : string; elem : TFhirCarePlanActivity);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.goalList.Count > 0 then
  begin
    json.valueArray('goal');
    ext := false;
    for i := 0 to elem.goalList.Count - 1 do
    begin
      ext := ext or ((elem.goalList[i].xmlid <> '') or (elem.goalList[i].hasExtensions));
      ComposeStringValue(json, '',elem.goalList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_goal');
      for i := 0 to elem.goalList.Count - 1 do
        ComposeStringProps(json, '',elem.goalList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirCarePlanActivityStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirCarePlanActivityStatus, false);
  ComposeBooleanValue(json, 'prohibited', elem.prohibitedObject, false);
  ComposeBooleanProps(json, 'prohibited', elem.prohibitedObject, false);
  if elem.actionResultingList.Count > 0 then
  begin
    json.valueArray('actionResulting');
    for i := 0 to elem.actionResultingList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.actionResultingList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'notes', elem.notesObject, false);
  ComposeStringProps(json, 'notes', elem.notesObject, false);
  ComposeReference{Resource}(json, 'detail', elem.detail); {a}
  ComposeCarePlanActivitySimple(json, 'simple', elem.simple); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseCarePlanActivitySimple(element : IXmlDomElement; path : string) : TFhirCarePlanActivitySimple;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlanActivitySimple.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'category') then
        result.categoryObject := ParseEnum(CODES_TFhirCarePlanActivityCategory, path+'/category', child){1a}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'scheduledTiming') then
        result.scheduled := ParseTiming(child, path+'/scheduledTiming'){x.3}
      else if (child.baseName = 'scheduledPeriod') then
        result.scheduled := ParsePeriod(child, path+'/scheduledPeriod'){x.3}
      else if (child.baseName = 'scheduledString') then
        result.scheduled := ParseString(child, path+'/scheduledString'){x.3}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'performer') then
        result.performerList.Add(ParseReference{Resource}(child, path+'/performer')){y.2}
      else if (child.baseName = 'product') then
        result.product := ParseReference{Resource}(child, path+'/product') {b}
      else if (child.baseName = 'dailyAmount') then
        result.dailyAmount := ParseQuantity(child, path+'/dailyAmount') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'details') then
        result.detailsObject := ParseString(child, path+'/details') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivitySimple(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivitySimple);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'category', elem.CategoryObject, CODES_TFhirCarePlanActivityCategory);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (elem.scheduled is TFhirTiming) {6} then
    ComposeTiming(xml, 'scheduledTiming', TFhirTiming(elem.scheduled))
  else if (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(xml, 'scheduledPeriod', TFhirPeriod(elem.scheduled))
  else if (elem.scheduled is TFhirString) {6} then
    ComposeString(xml, 'scheduledString', TFhirString(elem.scheduled));
  ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  for i := 0 to elem.performerList.Count - 1 do
    ComposeReference{Resource}(xml, 'performer', elem.performerList[i]);
  ComposeReference{Resource}(xml, 'product', elem.product);{x.2}
  ComposeQuantity(xml, 'dailyAmount', elem.dailyAmount);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeString(xml, 'details', elem.detailsObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlanActivitySimple(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanActivitySimple(jsn));
end;

function TFHIRJsonParser.ParseCarePlanActivitySimple(jsn : TJsonObject) : TFhirCarePlanActivitySimple;
begin
  result := TFhirCarePlanActivitySimple.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('category') or jsn.has('_category')  then
      result.categoryObject := parseEnum(jsn['category'], jsn.vObj['_category'], CODES_TFhirCarePlanActivityCategory);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('scheduledTiming') {a4} then
      result.scheduled := ParseTiming(jsn.vObj['scheduledTiming']);
    if jsn.has('scheduledPeriod') {a4} then
      result.scheduled := ParsePeriod(jsn.vObj['scheduledPeriod']);
    if jsn.has('scheduledString') or jsn.has('_scheduledString') then
      result.scheduled := parseString(jsn['scheduledString'], jsn.vObj['_scheduledString']);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseReference{Resource});
    if jsn.has('product') then
        result.product := ParseReference{Resource}(jsn.vObj['product']);{q}
    if jsn.has('dailyAmount') then
        result.dailyAmount := ParseQuantity(jsn.vObj['dailyAmount']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('details') or jsn.has('_details') then
        result.detailsObject := ParseString(jsn['details'], jsn.vObj['_details']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlanActivitySimple(json : TJSONWriter; name : string; elem : TFhirCarePlanActivitySimple);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'category', elem.CategoryObject, CODES_TFhirCarePlanActivityCategory, false);
  ComposeEnumProps(json, 'category', elem.CategoryObject, CODES_TFhirCarePlanActivityCategory, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (elem.scheduled is TFhirTiming) then 
    ComposeTiming(json, 'scheduledTiming', TFhirTiming(elem.scheduled)) 
  else if (elem.scheduled is TFhirPeriod) then 
    ComposePeriod(json, 'scheduledPeriod', TFhirPeriod(elem.scheduled)) 
  else if (elem.scheduled is TFhirString) then 
  begin
    ComposeStringValue(json, 'scheduledString', TFhirString(elem.scheduled), false);
    ComposeStringProps(json, 'scheduledString', TFhirString(elem.scheduled), false);
  end;
  ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if elem.performerList.Count > 0 then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.performerList[i]); {z - Reference(Practitioner|Organization|RelatedPerson|Patient)}
    json.FinishArray;
  end;
  ComposeReference{Resource}(json, 'product', elem.product); {a}
  ComposeQuantity(json, 'dailyAmount', elem.dailyAmount); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeStringValue(json, 'details', elem.detailsObject, false);
  ComposeStringProps(json, 'details', elem.detailsObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseCarePlan(element : IXmlDomElement; path : string) : TFhirCarePlan;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlan.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirCarePlanStatus, path+'/status', child){1a}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'modified') then
        result.modifiedObject := ParseDateTime(child, path+'/modified') {b}
      else if (child.baseName = 'concern') then
        result.concernList.Add(ParseReference{TFhirCondition}(child, path+'/concern')){y.2}
      else if (child.baseName = 'participant') then
        result.participantList.Add(ParseCarePlanParticipant(child, path+'/participant')){y.2}
      else if (child.baseName = 'goal') then
        result.goalList.Add(ParseCarePlanGoal(child, path+'/goal')){y.2}
      else if (child.baseName = 'activity') then
        result.activityList.Add(ParseCarePlanActivity(child, path+'/activity')){y.2}
      else if (child.baseName = 'notes') then
        result.notesObject := ParseString(child, path+'/notes') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlan(xml : TXmlBuilder; name : string; elem : TFhirCarePlan);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirCarePlanStatus);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  ComposeDateTime(xml, 'modified', elem.modifiedObject);{x.2}
  for i := 0 to elem.concernList.Count - 1 do
    ComposeReference{TFhirCondition}(xml, 'concern', elem.concernList[i]);
  for i := 0 to elem.participantList.Count - 1 do
    ComposeCarePlanParticipant(xml, 'participant', elem.participantList[i]);
  for i := 0 to elem.goalList.Count - 1 do
    ComposeCarePlanGoal(xml, 'goal', elem.goalList[i]);
  for i := 0 to elem.activityList.Count - 1 do
    ComposeCarePlanActivity(xml, 'activity', elem.activityList[i]);
  ComposeString(xml, 'notes', elem.notesObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlan(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlan(jsn));
end;

function TFHIRJsonParser.ParseCarePlan(jsn : TJsonObject) : TFhirCarePlan;
begin
  result := TFhirCarePlan.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirCarePlanStatus);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('modified') or jsn.has('_modified') then
        result.modifiedObject := ParseDateTime(jsn['modified'], jsn.vObj['_modified']);{q}
    if jsn.has('concern') then
      iterateArray(jsn.vArr['concern'], result.concernList, parseReference{TFhirCondition});
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseCarePlanParticipant);
    if jsn.has('goal') then
      iterateArray(jsn.vArr['goal'], result.goalList, parseCarePlanGoal);
    if jsn.has('activity') then
      iterateArray(jsn.vArr['activity'], result.activityList, parseCarePlanActivity);
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesObject := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlan(json : TJSONWriter; name : string; elem : TFhirCarePlan);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirCarePlanStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirCarePlanStatus, false);
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeDateTimeValue(json, 'modified', elem.modifiedObject, false);
  ComposeDateTimeProps(json, 'modified', elem.modifiedObject, false);
  if elem.concernList.Count > 0 then
  begin
    json.valueArray('concern');
    for i := 0 to elem.concernList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '',elem.concernList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if elem.participantList.Count > 0 then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeCarePlanParticipant(json, '',elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  if elem.goalList.Count > 0 then
  begin
    json.valueArray('goal');
    for i := 0 to elem.goalList.Count - 1 do
      ComposeCarePlanGoal(json, '',elem.goalList[i]); {z - }
    json.FinishArray;
  end;
  if elem.activityList.Count > 0 then
  begin
    json.valueArray('activity');
    for i := 0 to elem.activityList.Count - 1 do
      ComposeCarePlanActivity(json, '',elem.activityList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'notes', elem.notesObject, false);
  ComposeStringProps(json, 'notes', elem.notesObject, false);
end;

function TFHIRXmlParser.ParseCompositionAttester(element : IXmlDomElement; path : string) : TFhirCompositionAttester;
var
  child : IXMLDOMElement;
begin
  result := TFhirCompositionAttester.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'mode') then
        result.modeObject.Add(ParseEnum(CODES_TFhirCompositionAttestationMode, path+'/mode', child)){y.1}
      else if (child.baseName = 'time') then
        result.timeObject := ParseDateTime(child, path+'/time') {b}
      else if (child.baseName = 'party') then
        result.party := ParseReference{Resource}(child, path+'/party') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCompositionAttester(xml : TXmlBuilder; name : string; elem : TFhirCompositionAttester);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.modeObject.Count - 1 do
    ComposeEnum(xml, 'mode', elem.modeObject[i], CODES_TFhirCompositionAttestationMode);
  ComposeDateTime(xml, 'time', elem.timeObject);{x.2}
  ComposeReference{Resource}(xml, 'party', elem.party);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCompositionAttester(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionAttester(jsn));
end;

function TFHIRJsonParser.ParseCompositionAttester(jsn : TJsonObject) : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode') then
      iterateEnumArray(jsn.vArr['mode'], jsn.vArr['_mode'], result.modeObject, parseEnum, CODES_TFhirCompositionAttestationMode);
    if jsn.has('time') or jsn.has('_time') then
        result.timeObject := ParseDateTime(jsn['time'], jsn.vObj['_time']);{q}
    if jsn.has('party') then
        result.party := ParseReference{Resource}(jsn.vObj['party']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCompositionAttester(json : TJSONWriter; name : string; elem : TFhirCompositionAttester);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.modeObject.Count > 0 then
  begin
    json.valueArray('mode');
    ext := false;
    for i := 0 to elem.modeObject.Count - 1 do
    begin
      ext := ext or ((elem.modeObject[i].xmlid <> '') or (elem.modeObject[i].hasExtensions));
      ComposeEnumValue(json, '', elem.modeObject[i], CODES_TFhirCompositionAttestationMode, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_mode');
      for i := 0 to elem.modeObject.Count - 1 do
        ComposeEnumProps(json, '', elem.modeObject[i], CODES_TFhirCompositionAttestationMode, true);
      json.FinishArray;
    end;
  end;
  ComposeDateTimeValue(json, 'time', elem.timeObject, false);
  ComposeDateTimeProps(json, 'time', elem.timeObject, false);
  ComposeReference{Resource}(json, 'party', elem.party); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseCompositionEvent(element : IXmlDomElement; path : string) : TFhirCompositionEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirCompositionEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeList.Add(ParseCodeableConcept(child, path+'/code')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseReference{TFhirReference}(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCompositionEvent(xml : TXmlBuilder; name : string; elem : TFhirCompositionEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.codeList.Count - 1 do
    ComposeCodeableConcept(xml, 'code', elem.codeList[i]);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  for i := 0 to elem.detailList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCompositionEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionEvent(jsn));
end;

function TFHIRJsonParser.ParseCompositionEvent(jsn : TJsonObject) : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCompositionEvent(json : TJSONWriter; name : string; elem : TFhirCompositionEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.codeList.Count > 0 then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.codeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
  if elem.detailList.Count > 0 then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.detailList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseCompositionSection(element : IXmlDomElement; path : string) : TFhirCompositionSection;
var
  child : IXMLDOMElement;
begin
  result := TFhirCompositionSection.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'title') then
        result.titleObject := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'text') then
        result.text := ParseNarrative(child, path+'/text') {b}
      else if (child.baseName = 'emptyReason') then
        result.emptyReason := ParseCodeableConcept(child, path+'/emptyReason') {b}
      else if (child.baseName = 'order') then
        result.order := ParseCodeableConcept(child, path+'/order') {b}
      else if (child.baseName = 'section') then
        result.sectionList.Add(ParseCompositionSection(child, path+'/section')){y.2}
      else if (child.baseName = 'entry') then
        result.entryList.Add(ParseReference{TFhirReference}(child, path+'/entry')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCompositionSection(xml : TXmlBuilder; name : string; elem : TFhirCompositionSection);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'title', elem.titleObject);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeNarrative(xml, 'text', elem.text);{x.2}
  ComposeCodeableConcept(xml, 'emptyReason', elem.emptyReason);{x.2}
  ComposeCodeableConcept(xml, 'order', elem.order);{x.2}
  for i := 0 to elem.sectionList.Count - 1 do
    ComposeCompositionSection(xml, 'section', elem.sectionList[i]);
  for i := 0 to elem.entryList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'entry', elem.entryList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCompositionSection(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionSection(jsn));
end;

function TFHIRJsonParser.ParseCompositionSection(jsn : TJsonObject) : TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('title') or jsn.has('_title') then
        result.titleObject := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('text') then
        result.text := ParseNarrative(jsn.vObj['text']);{q}
    if jsn.has('emptyReason') then
        result.emptyReason := ParseCodeableConcept(jsn.vObj['emptyReason']);{q}
    if jsn.has('order') then
        result.order := ParseCodeableConcept(jsn.vObj['order']);{q}
    if jsn.has('section') then
      iterateArray(jsn.vArr['section'], result.sectionList, parseCompositionSection);
    if jsn.has('entry') then
      iterateArray(jsn.vArr['entry'], result.entryList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCompositionSection(json : TJSONWriter; name : string; elem : TFhirCompositionSection);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'title', elem.titleObject, false);
  ComposeStringProps(json, 'title', elem.titleObject, false);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeNarrative(json, 'text', elem.text); {a}
  ComposeCodeableConcept(json, 'emptyReason', elem.emptyReason); {a}
  ComposeCodeableConcept(json, 'order', elem.order); {a}
  if elem.sectionList.Count > 0 then
  begin
    json.valueArray('section');
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(json, '',elem.sectionList[i]); {z - @Composition.section}
    json.FinishArray;
  end;
  if elem.entryList.Count > 0 then
  begin
    json.valueArray('entry');
    for i := 0 to elem.entryList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.entryList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseComposition(element : IXmlDomElement; path : string) : TFhirComposition;
var
  child : IXMLDOMElement;
begin
  result := TFhirComposition.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'class') then
        result.class_ := ParseCodeableConcept(child, path+'/class') {b}
      else if (child.baseName = 'title') then
        result.titleObject := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirCompositionStatus, path+'/status', child){1a}
      else if (child.baseName = 'confidentiality') then
        result.confidentiality := ParseCoding(child, path+'/confidentiality') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'author') then
        result.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.baseName = 'attester') then
        result.attesterList.Add(ParseCompositionAttester(child, path+'/attester')){y.2}
      else if (child.baseName = 'custodian') then
        result.custodian := ParseReference{TFhirOrganization}(child, path+'/custodian') {b}
      else if (child.baseName = 'event') then
        result.eventList.Add(ParseCompositionEvent(child, path+'/event')){y.2}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'section') then
        result.sectionList.Add(ParseCompositionSection(child, path+'/section')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeComposition(xml : TXmlBuilder; name : string; elem : TFhirComposition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeCodeableConcept(xml, 'class', elem.class_);{x.2}
  ComposeString(xml, 'title', elem.titleObject);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirCompositionStatus);
  ComposeCoding(xml, 'confidentiality', elem.confidentiality);{x.2}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  for i := 0 to elem.authorList.Count - 1 do
    ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  for i := 0 to elem.attesterList.Count - 1 do
    ComposeCompositionAttester(xml, 'attester', elem.attesterList[i]);
  ComposeReference{TFhirOrganization}(xml, 'custodian', elem.custodian);{x.2}
  for i := 0 to elem.eventList.Count - 1 do
    ComposeCompositionEvent(xml, 'event', elem.eventList[i]);
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(xml, 'section', elem.sectionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseComposition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseComposition(jsn));
end;

function TFHIRJsonParser.ParseComposition(jsn : TJsonObject) : TFhirComposition;
begin
  result := TFhirComposition.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('class') then
        result.class_ := ParseCodeableConcept(jsn.vObj['class']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleObject := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirCompositionStatus);
    if jsn.has('confidentiality') then
        result.confidentiality := ParseCoding(jsn.vObj['confidentiality']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{Resource});
    if jsn.has('attester') then
      iterateArray(jsn.vArr['attester'], result.attesterList, parseCompositionAttester);
    if jsn.has('custodian') then
        result.custodian := ParseReference{TFhirOrganization}(jsn.vObj['custodian']);{q}
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseCompositionEvent);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('section') then
      iterateArray(jsn.vArr['section'], result.sectionList, parseCompositionSection);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeComposition(json : TJSONWriter; name : string; elem : TFhirComposition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeCodeableConcept(json, 'class', elem.class_); {a}
  ComposeStringValue(json, 'title', elem.titleObject, false);
  ComposeStringProps(json, 'title', elem.titleObject, false);
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirCompositionStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirCompositionStatus, false);
  ComposeCoding(json, 'confidentiality', elem.confidentiality); {a}
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if elem.authorList.Count > 0 then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.authorList[i]); {z - Reference(Practitioner|Device|Patient|RelatedPerson)}
    json.FinishArray;
  end;
  if elem.attesterList.Count > 0 then
  begin
    json.valueArray('attester');
    for i := 0 to elem.attesterList.Count - 1 do
      ComposeCompositionAttester(json, '',elem.attesterList[i]); {z - }
    json.FinishArray;
  end;
  ComposeReference{TFhirOrganization}(json, 'custodian', elem.custodian); {a}
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCompositionEvent(json, '',elem.eventList[i]); {z - }
    json.FinishArray;
  end;
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if not SummaryOnly and (elem.sectionList.Count > 0) then
  begin
    json.valueArray('section');
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(json, '',elem.sectionList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseConceptMapElement(element : IXmlDomElement; path : string) : TFhirConceptMapElement;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMapElement.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'codeSystem') then
        result.codeSystemObject := ParseUri(child, path+'/codeSystem') {b}
      else if (child.baseName = 'code') then
        result.codeObject := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'dependsOn') then
        result.dependsOnList.Add(ParseConceptMapElementDependsOn(child, path+'/dependsOn')){y.2}
      else if (child.baseName = 'map') then
        result.mapList.Add(ParseConceptMapElementMap(child, path+'/map')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMapElement(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'codeSystem', elem.codeSystemObject);{x.2}
  ComposeCode(xml, 'code', elem.codeObject);{x.2}
  for i := 0 to elem.dependsOnList.Count - 1 do
    ComposeConceptMapElementDependsOn(xml, 'dependsOn', elem.dependsOnList[i]);
  for i := 0 to elem.mapList.Count - 1 do
    ComposeConceptMapElementMap(xml, 'map', elem.mapList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMapElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapElement(jsn));
end;

function TFHIRJsonParser.ParseConceptMapElement(jsn : TJsonObject) : TFhirConceptMapElement;
begin
  result := TFhirConceptMapElement.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('codeSystem') or jsn.has('_codeSystem') then
        result.codeSystemObject := ParseUri(jsn['codeSystem'], jsn.vObj['_codeSystem']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeObject := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('dependsOn') then
      iterateArray(jsn.vArr['dependsOn'], result.dependsOnList, parseConceptMapElementDependsOn);
    if jsn.has('map') then
      iterateArray(jsn.vArr['map'], result.mapList, parseConceptMapElementMap);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMapElement(json : TJSONWriter; name : string; elem : TFhirConceptMapElement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'codeSystem', elem.codeSystemObject, false);
  ComposeUriProps(json, 'codeSystem', elem.codeSystemObject, false);
  ComposeCodeValue(json, 'code', elem.codeObject, false);
  ComposeCodeProps(json, 'code', elem.codeObject, false);
  if elem.dependsOnList.Count > 0 then
  begin
    json.valueArray('dependsOn');
    for i := 0 to elem.dependsOnList.Count - 1 do
      ComposeConceptMapElementDependsOn(json, '',elem.dependsOnList[i]); {z - }
    json.FinishArray;
  end;
  if elem.mapList.Count > 0 then
  begin
    json.valueArray('map');
    for i := 0 to elem.mapList.Count - 1 do
      ComposeConceptMapElementMap(json, '',elem.mapList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConceptMapElementDependsOn(element : IXmlDomElement; path : string) : TFhirConceptMapElementDependsOn;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMapElementDependsOn.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'element') then
        result.elementObject := ParseUri(child, path+'/element') {b}
      else if (child.baseName = 'codeSystem') then
        result.codeSystemObject := ParseUri(child, path+'/codeSystem') {b}
      else if (child.baseName = 'code') then
        result.codeObject := ParseString(child, path+'/code') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMapElementDependsOn(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElementDependsOn);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'element', elem.elementObject);{x.2}
  ComposeUri(xml, 'codeSystem', elem.codeSystemObject);{x.2}
  ComposeString(xml, 'code', elem.codeObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMapElementDependsOn(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapElementDependsOn(jsn));
end;

function TFHIRJsonParser.ParseConceptMapElementDependsOn(jsn : TJsonObject) : TFhirConceptMapElementDependsOn;
begin
  result := TFhirConceptMapElementDependsOn.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('element') or jsn.has('_element') then
        result.elementObject := ParseUri(jsn['element'], jsn.vObj['_element']);{q}
    if jsn.has('codeSystem') or jsn.has('_codeSystem') then
        result.codeSystemObject := ParseUri(jsn['codeSystem'], jsn.vObj['_codeSystem']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeObject := ParseString(jsn['code'], jsn.vObj['_code']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMapElementDependsOn(json : TJSONWriter; name : string; elem : TFhirConceptMapElementDependsOn);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'element', elem.elementObject, false);
  ComposeUriProps(json, 'element', elem.elementObject, false);
  ComposeUriValue(json, 'codeSystem', elem.codeSystemObject, false);
  ComposeUriProps(json, 'codeSystem', elem.codeSystemObject, false);
  ComposeStringValue(json, 'code', elem.codeObject, false);
  ComposeStringProps(json, 'code', elem.codeObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseConceptMapElementMap(element : IXmlDomElement; path : string) : TFhirConceptMapElementMap;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMapElementMap.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'codeSystem') then
        result.codeSystemObject := ParseUri(child, path+'/codeSystem') {b}
      else if (child.baseName = 'code') then
        result.codeObject := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'equivalence') then
        result.equivalenceObject := ParseEnum(CODES_TFhirConceptEquivalence, path+'/equivalence', child){1a}
      else if (child.baseName = 'comments') then
        result.commentsObject := ParseString(child, path+'/comments') {b}
      else if (child.baseName = 'product') then
        result.productList.Add(ParseConceptMapElementDependsOn(child, path+'/product')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMapElementMap(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElementMap);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'codeSystem', elem.codeSystemObject);{x.2}
  ComposeCode(xml, 'code', elem.codeObject);{x.2}
  ComposeEnum(xml, 'equivalence', elem.EquivalenceObject, CODES_TFhirConceptEquivalence);
  ComposeString(xml, 'comments', elem.commentsObject);{x.2}
  for i := 0 to elem.productList.Count - 1 do
    ComposeConceptMapElementDependsOn(xml, 'product', elem.productList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMapElementMap(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapElementMap(jsn));
end;

function TFHIRJsonParser.ParseConceptMapElementMap(jsn : TJsonObject) : TFhirConceptMapElementMap;
begin
  result := TFhirConceptMapElementMap.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('codeSystem') or jsn.has('_codeSystem') then
        result.codeSystemObject := ParseUri(jsn['codeSystem'], jsn.vObj['_codeSystem']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeObject := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('equivalence') or jsn.has('_equivalence')  then
      result.equivalenceObject := parseEnum(jsn['equivalence'], jsn.vObj['_equivalence'], CODES_TFhirConceptEquivalence);
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsObject := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    if jsn.has('product') then
      iterateArray(jsn.vArr['product'], result.productList, parseConceptMapElementDependsOn);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMapElementMap(json : TJSONWriter; name : string; elem : TFhirConceptMapElementMap);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'codeSystem', elem.codeSystemObject, false);
  ComposeUriProps(json, 'codeSystem', elem.codeSystemObject, false);
  ComposeCodeValue(json, 'code', elem.codeObject, false);
  ComposeCodeProps(json, 'code', elem.codeObject, false);
  ComposeEnumValue(json, 'equivalence', elem.EquivalenceObject, CODES_TFhirConceptEquivalence, false);
  ComposeEnumProps(json, 'equivalence', elem.EquivalenceObject, CODES_TFhirConceptEquivalence, false);
  ComposeStringValue(json, 'comments', elem.commentsObject, false);
  ComposeStringProps(json, 'comments', elem.commentsObject, false);
  if elem.productList.Count > 0 then
  begin
    json.valueArray('product');
    for i := 0 to elem.productList.Count - 1 do
      ComposeConceptMapElementDependsOn(json, '',elem.productList[i]); {z - @ConceptMap.element.dependsOn}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConceptMap(element : IXmlDomElement; path : string) : TFhirConceptMap;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMap.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierObject := ParseString(child, path+'/identifier') {b}
      else if (child.baseName = 'version') then
        result.versionObject := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'publisher') then
        result.publisherObject := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'copyright') then
        result.copyrightObject := ParseString(child, path+'/copyright') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirValuesetStatus, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalObject := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'sourceUri') then
        result.source := ParseUri(child, path+'/sourceUri'){x.3}
      else if (child.baseName = 'sourceReference') then
        result.source := ParseReference(child, path+'/sourceReference') {a}
      else if (child.baseName = 'targetUri') then
        result.target := ParseUri(child, path+'/targetUri'){x.3}
      else if (child.baseName = 'targetReference') then
        result.target := ParseReference(child, path+'/targetReference') {a}
      else if (child.baseName = 'element') then
        result.elementList.Add(ParseConceptMapElement(child, path+'/element')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMap(xml : TXmlBuilder; name : string; elem : TFhirConceptMap);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeString(xml, 'identifier', elem.identifierObject);{x.2}
  ComposeString(xml, 'version', elem.versionObject);{x.2}
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeString(xml, 'publisher', elem.publisherObject);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  if not SummaryOnly then
    ComposeString(xml, 'copyright', elem.copyrightObject);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirValuesetStatus);
  ComposeBoolean(xml, 'experimental', elem.experimentalObject);{x.2}
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  if (elem.source is TFhirUri) {6} then
    ComposeUri(xml, 'sourceUri', TFhirUri(elem.source))
  else if (elem.source is TFhirReference) {2} then
    ComposeReference(xml, 'sourceReference', TFhirReference(elem.source));
  if (elem.target is TFhirUri) {6} then
    ComposeUri(xml, 'targetUri', TFhirUri(elem.target))
  else if (elem.target is TFhirReference) {2} then
    ComposeReference(xml, 'targetReference', TFhirReference(elem.target));
  if not SummaryOnly then
    for i := 0 to elem.elementList.Count - 1 do
      ComposeConceptMapElement(xml, 'element', elem.elementList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMap(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMap(jsn));
end;

function TFHIRJsonParser.ParseConceptMap(jsn : TJsonObject) : TFhirConceptMap;
begin
  result := TFhirConceptMap.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierObject := ParseString(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionObject := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherObject := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightObject := ParseString(jsn['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirValuesetStatus);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalObject := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('sourceUri') or jsn.has('_sourceUri') then
      result.source := parseUri(jsn['sourceUri'], jsn.vObj['_sourceUri']);
    if jsn.has('sourceReference') {a3} then
      result.source := ParseReference(jsn.vObj['sourceReference']);
    if jsn.has('targetUri') or jsn.has('_targetUri') then
      result.target := parseUri(jsn['targetUri'], jsn.vObj['_targetUri']);
    if jsn.has('targetReference') {a3} then
      result.target := ParseReference(jsn.vObj['targetReference']);
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseConceptMapElement);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMap(json : TJSONWriter; name : string; elem : TFhirConceptMap);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeStringValue(json, 'identifier', elem.identifierObject, false);
  ComposeStringProps(json, 'identifier', elem.identifierObject, false);
  ComposeStringValue(json, 'version', elem.versionObject, false);
  ComposeStringProps(json, 'version', elem.versionObject, false);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeStringValue(json, 'publisher', elem.publisherObject, false);
  ComposeStringProps(json, 'publisher', elem.publisherObject, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  if not SummaryOnly then
    ComposeStringValue(json, 'copyright', elem.copyrightObject, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'copyright', elem.copyrightObject, false);
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirValuesetStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirValuesetStatus, false);
  ComposeBooleanValue(json, 'experimental', elem.experimentalObject, false);
  ComposeBooleanProps(json, 'experimental', elem.experimentalObject, false);
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  if (elem.source is TFhirUri) then 
  begin
    ComposeUriValue(json, 'sourceUri', TFhirUri(elem.source), false);
    ComposeUriProps(json, 'sourceUri', TFhirUri(elem.source), false);
  end
  else if (elem.source is TFhirReference) then
    ComposeReference(json, 'sourceReference', TFhirReference(elem.source));
  if (elem.target is TFhirUri) then 
  begin
    ComposeUriValue(json, 'targetUri', TFhirUri(elem.target), false);
    ComposeUriProps(json, 'targetUri', TFhirUri(elem.target), false);
  end
  else if (elem.target is TFhirReference) then
    ComposeReference(json, 'targetReference', TFhirReference(elem.target));
  if not SummaryOnly and (elem.elementList.Count > 0) then
  begin
    json.valueArray('element');
    for i := 0 to elem.elementList.Count - 1 do
      ComposeConceptMapElement(json, '',elem.elementList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseConditionStage(element : IXmlDomElement; path : string) : TFhirConditionStage;
var
  child : IXMLDOMElement;
begin
  result := TFhirConditionStage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'summary') then
        result.summary := ParseCodeableConcept(child, path+'/summary') {b}
      else if (child.baseName = 'assessment') then
        result.assessmentList.Add(ParseReference{TFhirReference}(child, path+'/assessment')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConditionStage(xml : TXmlBuilder; name : string; elem : TFhirConditionStage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'summary', elem.summary);{x.2}
  for i := 0 to elem.assessmentList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'assessment', elem.assessmentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConditionStage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionStage(jsn));
end;

function TFHIRJsonParser.ParseConditionStage(jsn : TJsonObject) : TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('summary') then
        result.summary := ParseCodeableConcept(jsn.vObj['summary']);{q}
    if jsn.has('assessment') then
      iterateArray(jsn.vArr['assessment'], result.assessmentList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConditionStage(json : TJSONWriter; name : string; elem : TFhirConditionStage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'summary', elem.summary); {a}
  if elem.assessmentList.Count > 0 then
  begin
    json.valueArray('assessment');
    for i := 0 to elem.assessmentList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.assessmentList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConditionEvidence(element : IXmlDomElement; path : string) : TFhirConditionEvidence;
var
  child : IXMLDOMElement;
begin
  result := TFhirConditionEvidence.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseReference{TFhirReference}(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConditionEvidence(xml : TXmlBuilder; name : string; elem : TFhirConditionEvidence);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  for i := 0 to elem.detailList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConditionEvidence(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionEvidence(jsn));
end;

function TFHIRJsonParser.ParseConditionEvidence(jsn : TJsonObject) : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConditionEvidence(json : TJSONWriter; name : string; elem : TFhirConditionEvidence);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if elem.detailList.Count > 0 then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.detailList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConditionLocation(element : IXmlDomElement; path : string) : TFhirConditionLocation;
var
  child : IXMLDOMElement;
begin
  result := TFhirConditionLocation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'detail') then
        result.detailObject := ParseString(child, path+'/detail') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConditionLocation(xml : TXmlBuilder; name : string; elem : TFhirConditionLocation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeString(xml, 'detail', elem.detailObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConditionLocation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionLocation(jsn));
end;

function TFHIRJsonParser.ParseConditionLocation(jsn : TJsonObject) : TFhirConditionLocation;
begin
  result := TFhirConditionLocation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('detail') or jsn.has('_detail') then
        result.detailObject := ParseString(jsn['detail'], jsn.vObj['_detail']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConditionLocation(json : TJSONWriter; name : string; elem : TFhirConditionLocation);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeStringValue(json, 'detail', elem.detailObject, false);
  ComposeStringProps(json, 'detail', elem.detailObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseConditionRelatedItem(element : IXmlDomElement; path : string) : TFhirConditionRelatedItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirConditionRelatedItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Object := ParseEnum(CODES_TFhirConditionRelationshipType, path+'/type', child){1a}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{Resource}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConditionRelatedItem(xml : TXmlBuilder; name : string; elem : TFhirConditionRelatedItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Object, CODES_TFhirConditionRelationshipType);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeReference{Resource}(xml, 'target', elem.target);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConditionRelatedItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionRelatedItem(jsn));
end;

function TFHIRJsonParser.ParseConditionRelatedItem(jsn : TJsonObject) : TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Object := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirConditionRelationshipType);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('target') then
        result.target := ParseReference{Resource}(jsn.vObj['target']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConditionRelatedItem(json : TJSONWriter; name : string; elem : TFhirConditionRelatedItem);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Object, CODES_TFhirConditionRelationshipType, false);
  ComposeEnumProps(json, 'type', elem.Type_Object, CODES_TFhirConditionRelationshipType, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeReference{Resource}(json, 'target', elem.target); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseCondition(element : IXmlDomElement; path : string) : TFhirCondition;
var
  child : IXMLDOMElement;
begin
  result := TFhirCondition.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'asserter') then
        result.asserter := ParseReference{Resource}(child, path+'/asserter') {b}
      else if (child.baseName = 'dateAsserted') then
        result.dateAssertedObject := ParseDate(child, path+'/dateAsserted') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirConditionStatus, path+'/status', child){1a}
      else if (child.baseName = 'certainty') then
        result.certainty := ParseCodeableConcept(child, path+'/certainty') {b}
      else if (child.baseName = 'severity') then
        result.severity := ParseCodeableConcept(child, path+'/severity') {b}
      else if (child.baseName = 'onsetDate') then
        result.onset := ParseDate(child, path+'/onsetDate'){x.3}
      else if (child.baseName = 'onsetAge') then
        result.onset := ParseAge(child, path+'/onsetAge'){x.3}
      else if (child.baseName = 'abatementDate') then
        result.abatement := ParseDate(child, path+'/abatementDate'){x.3}
      else if (child.baseName = 'abatementAge') then
        result.abatement := ParseAge(child, path+'/abatementAge'){x.3}
      else if (child.baseName = 'abatementBoolean') then
        result.abatement := ParseBoolean(child, path+'/abatementBoolean'){x.3}
      else if (child.baseName = 'stage') then
        result.stage := ParseConditionStage(child, path+'/stage') {b}
      else if (child.baseName = 'evidence') then
        result.evidenceList.Add(ParseConditionEvidence(child, path+'/evidence')){y.2}
      else if (child.baseName = 'location') then
        result.locationList.Add(ParseConditionLocation(child, path+'/location')){y.2}
      else if (child.baseName = 'relatedItem') then
        result.relatedItemList.Add(ParseConditionRelatedItem(child, path+'/relatedItem')){y.2}
      else if (child.baseName = 'notes') then
        result.notesObject := ParseString(child, path+'/notes') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCondition(xml : TXmlBuilder; name : string; elem : TFhirCondition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  ComposeReference{Resource}(xml, 'asserter', elem.asserter);{x.2}
  ComposeDate(xml, 'dateAsserted', elem.dateAssertedObject);{x.2}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirConditionStatus);
  ComposeCodeableConcept(xml, 'certainty', elem.certainty);{x.2}
  ComposeCodeableConcept(xml, 'severity', elem.severity);{x.2}
  if (elem.onset is TFhirDate) {6} then
    ComposeDate(xml, 'onsetDate', TFhirDate(elem.onset))
  else if (elem.onset is TFhirQuantity) {6} then
    ComposeAge(xml, 'onsetAge', TFhirQuantity(elem.onset));
  if (elem.abatement is TFhirDate) {6} then
    ComposeDate(xml, 'abatementDate', TFhirDate(elem.abatement))
  else if (elem.abatement is TFhirQuantity) {6} then
    ComposeAge(xml, 'abatementAge', TFhirQuantity(elem.abatement))
  else if (elem.abatement is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'abatementBoolean', TFhirBoolean(elem.abatement));
  ComposeConditionStage(xml, 'stage', elem.stage);{x.2}
  for i := 0 to elem.evidenceList.Count - 1 do
    ComposeConditionEvidence(xml, 'evidence', elem.evidenceList[i]);
  for i := 0 to elem.locationList.Count - 1 do
    ComposeConditionLocation(xml, 'location', elem.locationList[i]);
  for i := 0 to elem.relatedItemList.Count - 1 do
    ComposeConditionRelatedItem(xml, 'relatedItem', elem.relatedItemList[i]);
  ComposeString(xml, 'notes', elem.notesObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCondition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCondition(jsn));
end;

function TFHIRJsonParser.ParseCondition(jsn : TJsonObject) : TFhirCondition;
begin
  result := TFhirCondition.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('asserter') then
        result.asserter := ParseReference{Resource}(jsn.vObj['asserter']);{q}
    if jsn.has('dateAsserted') or jsn.has('_dateAsserted') then
        result.dateAssertedObject := ParseDate(jsn['dateAsserted'], jsn.vObj['_dateAsserted']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirConditionStatus);
    if jsn.has('certainty') then
        result.certainty := ParseCodeableConcept(jsn.vObj['certainty']);{q}
    if jsn.has('severity') then
        result.severity := ParseCodeableConcept(jsn.vObj['severity']);{q}
    if jsn.has('onsetDate') or jsn.has('_onsetDate') then
      result.onset := parseDate(jsn['onsetDate'], jsn.vObj['_onsetDate']);
    if jsn.has('onsetAge') {a4} then
      result.onset := ParseAge(jsn.vObj['onsetAge']);
    if jsn.has('abatementDate') or jsn.has('_abatementDate') then
      result.abatement := parseDate(jsn['abatementDate'], jsn.vObj['_abatementDate']);
    if jsn.has('abatementAge') {a4} then
      result.abatement := ParseAge(jsn.vObj['abatementAge']);
    if jsn.has('abatementBoolean') or jsn.has('_abatementBoolean') then
      result.abatement := parseBoolean(jsn['abatementBoolean'], jsn.vObj['_abatementBoolean']);
    if jsn.has('stage') then
        result.stage := ParseConditionStage(jsn.vObj['stage']);{q}
    if jsn.has('evidence') then
      iterateArray(jsn.vArr['evidence'], result.evidenceList, parseConditionEvidence);
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseConditionLocation);
    if jsn.has('relatedItem') then
      iterateArray(jsn.vArr['relatedItem'], result.relatedItemList, parseConditionRelatedItem);
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesObject := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCondition(json : TJSONWriter; name : string; elem : TFhirCondition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeReference{Resource}(json, 'asserter', elem.asserter); {a}
  ComposeDateValue(json, 'dateAsserted', elem.dateAssertedObject, false);
  ComposeDateProps(json, 'dateAsserted', elem.dateAssertedObject, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirConditionStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirConditionStatus, false);
  ComposeCodeableConcept(json, 'certainty', elem.certainty); {a}
  ComposeCodeableConcept(json, 'severity', elem.severity); {a}
  if (elem.onset is TFhirDate) then 
  begin
    ComposeDateValue(json, 'onsetDate', TFhirDate(elem.onset), false);
    ComposeDateProps(json, 'onsetDate', TFhirDate(elem.onset), false);
  end
  else if (elem.onset is TFhirQuantity) then 
    ComposeAge(json, 'onsetAge', TFhirQuantity(elem.onset)) ;
  if (elem.abatement is TFhirDate) then 
  begin
    ComposeDateValue(json, 'abatementDate', TFhirDate(elem.abatement), false);
    ComposeDateProps(json, 'abatementDate', TFhirDate(elem.abatement), false);
  end
  else if (elem.abatement is TFhirQuantity) then 
    ComposeAge(json, 'abatementAge', TFhirQuantity(elem.abatement)) 
  else if (elem.abatement is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'abatementBoolean', TFhirBoolean(elem.abatement), false);
    ComposeBooleanProps(json, 'abatementBoolean', TFhirBoolean(elem.abatement), false);
  end;
  ComposeConditionStage(json, 'stage', elem.stage); {a}
  if elem.evidenceList.Count > 0 then
  begin
    json.valueArray('evidence');
    for i := 0 to elem.evidenceList.Count - 1 do
      ComposeConditionEvidence(json, '',elem.evidenceList[i]); {z - }
    json.FinishArray;
  end;
  if elem.locationList.Count > 0 then
  begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeConditionLocation(json, '',elem.locationList[i]); {z - }
    json.FinishArray;
  end;
  if elem.relatedItemList.Count > 0 then
  begin
    json.valueArray('relatedItem');
    for i := 0 to elem.relatedItemList.Count - 1 do
      ComposeConditionRelatedItem(json, '',elem.relatedItemList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'notes', elem.notesObject, false);
  ComposeStringProps(json, 'notes', elem.notesObject, false);
end;

function TFHIRXmlParser.ParseConformanceSoftware(element : IXmlDomElement; path : string) : TFhirConformanceSoftware;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceSoftware.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'version') then
        result.versionObject := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'releaseDate') then
        result.releaseDateObject := ParseDateTime(child, path+'/releaseDate') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceSoftware(xml : TXmlBuilder; name : string; elem : TFhirConformanceSoftware);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeString(xml, 'version', elem.versionObject);{x.2}
  ComposeDateTime(xml, 'releaseDate', elem.releaseDateObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceSoftware(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceSoftware(jsn));
end;

function TFHIRJsonParser.ParseConformanceSoftware(jsn : TJsonObject) : TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionObject := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('releaseDate') or jsn.has('_releaseDate') then
        result.releaseDateObject := ParseDateTime(jsn['releaseDate'], jsn.vObj['_releaseDate']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceSoftware(json : TJSONWriter; name : string; elem : TFhirConformanceSoftware);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeStringValue(json, 'version', elem.versionObject, false);
  ComposeStringProps(json, 'version', elem.versionObject, false);
  ComposeDateTimeValue(json, 'releaseDate', elem.releaseDateObject, false);
  ComposeDateTimeProps(json, 'releaseDate', elem.releaseDateObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceImplementation(element : IXmlDomElement; path : string) : TFhirConformanceImplementation;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceImplementation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'url') then
        result.urlObject := ParseUri(child, path+'/url') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceImplementation(xml : TXmlBuilder; name : string; elem : TFhirConformanceImplementation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  ComposeUri(xml, 'url', elem.urlObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceImplementation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceImplementation(jsn));
end;

function TFHIRJsonParser.ParseConformanceImplementation(jsn : TJsonObject) : TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlObject := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceImplementation(json : TJSONWriter; name : string; elem : TFhirConformanceImplementation);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  ComposeUriValue(json, 'url', elem.urlObject, false);
  ComposeUriProps(json, 'url', elem.urlObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRest(element : IXmlDomElement; path : string) : TFhirConformanceRest;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRest.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'mode') then
        result.modeObject := ParseEnum(CODES_TFhirRestfulConformanceMode, path+'/mode', child){1a}
      else if (child.baseName = 'documentation') then
        result.documentationObject := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'security') then
        result.security := ParseConformanceRestSecurity(child, path+'/security') {b}
      else if (child.baseName = 'resource') then
        result.resourceList.Add(ParseConformanceRestResource(child, path+'/resource')){y.2}
      else if (child.baseName = 'interaction') then
        result.interactionList.Add(ParseConformanceRestInteraction(child, path+'/interaction')){y.2}
      else if (child.baseName = 'operation') then
        result.operationList.Add(ParseConformanceRestOperation(child, path+'/operation')){y.2}
      else if (child.baseName = 'documentMailbox') then
        result.documentMailboxList.Add(ParseUri(child, path+'/documentMailbox')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRest(xml : TXmlBuilder; name : string; elem : TFhirConformanceRest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'mode', elem.ModeObject, CODES_TFhirRestfulConformanceMode);
  ComposeString(xml, 'documentation', elem.documentationObject);{x.2}
  ComposeConformanceRestSecurity(xml, 'security', elem.security);{x.2}
  for i := 0 to elem.resourceList.Count - 1 do
    ComposeConformanceRestResource(xml, 'resource', elem.resourceList[i]);
  for i := 0 to elem.interactionList.Count - 1 do
    ComposeConformanceRestInteraction(xml, 'interaction', elem.interactionList[i]);
  for i := 0 to elem.operationList.Count - 1 do
    ComposeConformanceRestOperation(xml, 'operation', elem.operationList[i]);
  for i := 0 to elem.documentMailboxList.Count - 1 do
    ComposeUri(xml, 'documentMailbox', elem.documentMailboxList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRest(jsn));
end;

function TFHIRJsonParser.ParseConformanceRest(jsn : TJsonObject) : TFhirConformanceRest;
begin
  result := TFhirConformanceRest.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeObject := parseEnum(jsn['mode'], jsn.vObj['_mode'], CODES_TFhirRestfulConformanceMode);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationObject := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('security') then
        result.security := ParseConformanceRestSecurity(jsn.vObj['security']);{q}
    if jsn.has('resource') then
      iterateArray(jsn.vArr['resource'], result.resourceList, parseConformanceRestResource);
    if jsn.has('interaction') then
      iterateArray(jsn.vArr['interaction'], result.interactionList, parseConformanceRestInteraction);
    if jsn.has('operation') then
      iterateArray(jsn.vArr['operation'], result.operationList, parseConformanceRestOperation);
      if jsn.has('documentMailbox') or jsn.has('_documentMailbox') then
      iteratePrimitiveArray(jsn.vArr['documentMailbox'], jsn.vArr['_documentMailbox'], result.documentMailboxList, parseUri);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRest(json : TJSONWriter; name : string; elem : TFhirConformanceRest);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'mode', elem.ModeObject, CODES_TFhirRestfulConformanceMode, false);
  ComposeEnumProps(json, 'mode', elem.ModeObject, CODES_TFhirRestfulConformanceMode, false);
  ComposeStringValue(json, 'documentation', elem.documentationObject, false);
  ComposeStringProps(json, 'documentation', elem.documentationObject, false);
  ComposeConformanceRestSecurity(json, 'security', elem.security); {a}
  if elem.resourceList.Count > 0 then
  begin
    json.valueArray('resource');
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeConformanceRestResource(json, '',elem.resourceList[i]); {z - }
    json.FinishArray;
  end;
  if elem.interactionList.Count > 0 then
  begin
    json.valueArray('interaction');
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeConformanceRestInteraction(json, '',elem.interactionList[i]); {z - }
    json.FinishArray;
  end;
  if elem.operationList.Count > 0 then
  begin
    json.valueArray('operation');
    for i := 0 to elem.operationList.Count - 1 do
      ComposeConformanceRestOperation(json, '',elem.operationList[i]); {z - }
    json.FinishArray;
  end;
  if elem.documentMailboxList.Count > 0 then
  begin
    json.valueArray('documentMailbox');
    ext := false;
    for i := 0 to elem.documentMailboxList.Count - 1 do
    begin
      ext := ext or ((elem.documentMailboxList[i].xmlid <> '') or (elem.documentMailboxList[i].hasExtensions));
      ComposeUriValue(json, '',elem.documentMailboxList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_documentMailbox');
      for i := 0 to elem.documentMailboxList.Count - 1 do
        ComposeUriProps(json, '',elem.documentMailboxList[i], true);
      json.FinishArray;
    end;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestSecurity(element : IXmlDomElement; path : string) : TFhirConformanceRestSecurity;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'cors') then
        result.corsObject := ParseBoolean(child, path+'/cors') {b}
      else if (child.baseName = 'service') then
        result.serviceList.Add(ParseCodeableConcept(child, path+'/service')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'certificate') then
        result.certificateList.Add(ParseConformanceRestSecurityCertificate(child, path+'/certificate')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestSecurity(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurity);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeBoolean(xml, 'cors', elem.corsObject);{x.2}
  for i := 0 to elem.serviceList.Count - 1 do
    ComposeCodeableConcept(xml, 'service', elem.serviceList[i]);
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  for i := 0 to elem.certificateList.Count - 1 do
    ComposeConformanceRestSecurityCertificate(xml, 'certificate', elem.certificateList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestSecurity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestSecurity(jsn));
end;

function TFHIRJsonParser.ParseConformanceRestSecurity(jsn : TJsonObject) : TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('cors') or jsn.has('_cors') then
        result.corsObject := ParseBoolean(jsn['cors'], jsn.vObj['_cors']);{q}
    if jsn.has('service') then
      iterateArray(jsn.vArr['service'], result.serviceList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('certificate') then
      iterateArray(jsn.vArr['certificate'], result.certificateList, parseConformanceRestSecurityCertificate);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestSecurity(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurity);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeBooleanValue(json, 'cors', elem.corsObject, false);
  ComposeBooleanProps(json, 'cors', elem.corsObject, false);
  if elem.serviceList.Count > 0 then
  begin
    json.valueArray('service');
    for i := 0 to elem.serviceList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.serviceList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  if elem.certificateList.Count > 0 then
  begin
    json.valueArray('certificate');
    for i := 0 to elem.certificateList.Count - 1 do
      ComposeConformanceRestSecurityCertificate(json, '',elem.certificateList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestSecurityCertificate(element : IXmlDomElement; path : string) : TFhirConformanceRestSecurityCertificate;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Object := ParseCode(child, path+'/type') {b}
      else if (child.baseName = 'blob') then
        result.blobObject := ParseBase64Binary(child, path+'/blob') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestSecurityCertificate(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurityCertificate);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'type', elem.type_Object);{x.2}
  ComposeBase64Binary(xml, 'blob', elem.blobObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestSecurityCertificate(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestSecurityCertificate(jsn));
end;

function TFHIRJsonParser.ParseConformanceRestSecurityCertificate(jsn : TJsonObject) : TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type') then
        result.type_Object := ParseCode(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('blob') or jsn.has('_blob') then
        result.blobObject := ParseBase64Binary(jsn['blob'], jsn.vObj['_blob']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestSecurityCertificate(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurityCertificate);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'type', elem.type_Object, false);
  ComposeCodeProps(json, 'type', elem.type_Object, false);
  ComposeBase64BinaryValue(json, 'blob', elem.blobObject, false);
  ComposeBase64BinaryProps(json, 'blob', elem.blobObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestResource(element : IXmlDomElement; path : string) : TFhirConformanceRestResource;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestResource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Object := ParseCode(child, path+'/type') {b}
      else if (child.baseName = 'profile') then
        result.profile := ParseReference{TFhirProfile}(child, path+'/profile') {b}
      else if (child.baseName = 'interaction') then
        result.interactionList.Add(ParseConformanceRestResourceInteraction(child, path+'/interaction')){y.2}
      else if (child.baseName = 'readHistory') then
        result.readHistoryObject := ParseBoolean(child, path+'/readHistory') {b}
      else if (child.baseName = 'updateCreate') then
        result.updateCreateObject := ParseBoolean(child, path+'/updateCreate') {b}
      else if (child.baseName = 'searchInclude') then
        result.searchIncludeList.Add(ParseString(child, path+'/searchInclude')){y.2}
      else if (child.baseName = 'searchParam') then
        result.searchParamList.Add(ParseConformanceRestResourceSearchParam(child, path+'/searchParam')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResource(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResource);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'type', elem.type_Object);{x.2}
  ComposeReference{TFhirProfile}(xml, 'profile', elem.profile);{x.2}
  for i := 0 to elem.interactionList.Count - 1 do
    ComposeConformanceRestResourceInteraction(xml, 'interaction', elem.interactionList[i]);
  ComposeBoolean(xml, 'readHistory', elem.readHistoryObject);{x.2}
  ComposeBoolean(xml, 'updateCreate', elem.updateCreateObject);{x.2}
  for i := 0 to elem.searchIncludeList.Count - 1 do
    ComposeString(xml, 'searchInclude', elem.searchIncludeList[i]);
  for i := 0 to elem.searchParamList.Count - 1 do
    ComposeConformanceRestResourceSearchParam(xml, 'searchParam', elem.searchParamList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestResource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestResource(jsn));
end;

function TFHIRJsonParser.ParseConformanceRestResource(jsn : TJsonObject) : TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type') then
        result.type_Object := ParseCode(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('profile') then
        result.profile := ParseReference{TFhirProfile}(jsn.vObj['profile']);{q}
    if jsn.has('interaction') then
      iterateArray(jsn.vArr['interaction'], result.interactionList, parseConformanceRestResourceInteraction);
    if jsn.has('readHistory') or jsn.has('_readHistory') then
        result.readHistoryObject := ParseBoolean(jsn['readHistory'], jsn.vObj['_readHistory']);{q}
    if jsn.has('updateCreate') or jsn.has('_updateCreate') then
        result.updateCreateObject := ParseBoolean(jsn['updateCreate'], jsn.vObj['_updateCreate']);{q}
      if jsn.has('searchInclude') or jsn.has('_searchInclude') then
      iteratePrimitiveArray(jsn.vArr['searchInclude'], jsn.vArr['_searchInclude'], result.searchIncludeList, parseString);
    if jsn.has('searchParam') then
      iterateArray(jsn.vArr['searchParam'], result.searchParamList, parseConformanceRestResourceSearchParam);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestResource(json : TJSONWriter; name : string; elem : TFhirConformanceRestResource);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'type', elem.type_Object, false);
  ComposeCodeProps(json, 'type', elem.type_Object, false);
  ComposeReference{TFhirProfile}(json, 'profile', elem.profile); {a}
  if elem.interactionList.Count > 0 then
  begin
    json.valueArray('interaction');
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeConformanceRestResourceInteraction(json, '',elem.interactionList[i]); {z - }
    json.FinishArray;
  end;
  ComposeBooleanValue(json, 'readHistory', elem.readHistoryObject, false);
  ComposeBooleanProps(json, 'readHistory', elem.readHistoryObject, false);
  ComposeBooleanValue(json, 'updateCreate', elem.updateCreateObject, false);
  ComposeBooleanProps(json, 'updateCreate', elem.updateCreateObject, false);
  if elem.searchIncludeList.Count > 0 then
  begin
    json.valueArray('searchInclude');
    ext := false;
    for i := 0 to elem.searchIncludeList.Count - 1 do
    begin
      ext := ext or ((elem.searchIncludeList[i].xmlid <> '') or (elem.searchIncludeList[i].hasExtensions));
      ComposeStringValue(json, '',elem.searchIncludeList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_searchInclude');
      for i := 0 to elem.searchIncludeList.Count - 1 do
        ComposeStringProps(json, '',elem.searchIncludeList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.searchParamList.Count > 0 then
  begin
    json.valueArray('searchParam');
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeConformanceRestResourceSearchParam(json, '',elem.searchParamList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestResourceInteraction(element : IXmlDomElement; path : string) : TFhirConformanceRestResourceInteraction;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestResourceInteraction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeObject := ParseEnum(CODES_TFhirTypeRestfulInteraction, path+'/code', child){1a}
      else if (child.baseName = 'documentation') then
        result.documentationObject := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResourceInteraction(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceInteraction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.CodeObject, CODES_TFhirTypeRestfulInteraction);
  ComposeString(xml, 'documentation', elem.documentationObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestResourceInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestResourceInteraction(jsn));
end;

function TFHIRJsonParser.ParseConformanceRestResourceInteraction(jsn : TJsonObject) : TFhirConformanceRestResourceInteraction;
begin
  result := TFhirConformanceRestResourceInteraction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeObject := parseEnum(jsn['code'], jsn.vObj['_code'], CODES_TFhirTypeRestfulInteraction);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationObject := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestResourceInteraction(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceInteraction);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.CodeObject, CODES_TFhirTypeRestfulInteraction, false);
  ComposeEnumProps(json, 'code', elem.CodeObject, CODES_TFhirTypeRestfulInteraction, false);
  ComposeStringValue(json, 'documentation', elem.documentationObject, false);
  ComposeStringProps(json, 'documentation', elem.documentationObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestResourceSearchParam(element : IXmlDomElement; path : string) : TFhirConformanceRestResourceSearchParam;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'definition') then
        result.definitionObject := ParseUri(child, path+'/definition') {b}
      else if (child.baseName = 'type') then
        result.type_Object := ParseEnum(CODES_TFhirSearchParamType, path+'/type', child){1a}
      else if (child.baseName = 'documentation') then
        result.documentationObject := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'target') then
        result.targetList.Add(ParseCode(child, path+'/target')){y.2}
      else if (child.baseName = 'chain') then
        result.chainList.Add(ParseString(child, path+'/chain')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResourceSearchParam(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceSearchParam);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeUri(xml, 'definition', elem.definitionObject);{x.2}
  ComposeEnum(xml, 'type', elem.Type_Object, CODES_TFhirSearchParamType);
  ComposeString(xml, 'documentation', elem.documentationObject);{x.2}
  for i := 0 to elem.targetList.Count - 1 do
    ComposeCode(xml, 'target', elem.targetList[i]);
  for i := 0 to elem.chainList.Count - 1 do
    ComposeString(xml, 'chain', elem.chainList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestResourceSearchParam(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestResourceSearchParam(jsn));
end;

function TFHIRJsonParser.ParseConformanceRestResourceSearchParam(jsn : TJsonObject) : TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionObject := ParseUri(jsn['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Object := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirSearchParamType);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationObject := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
      if jsn.has('target') or jsn.has('_target') then
      iteratePrimitiveArray(jsn.vArr['target'], jsn.vArr['_target'], result.targetList, parseCode);
      if jsn.has('chain') or jsn.has('_chain') then
      iteratePrimitiveArray(jsn.vArr['chain'], jsn.vArr['_chain'], result.chainList, parseString);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestResourceSearchParam(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceSearchParam);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeUriValue(json, 'definition', elem.definitionObject, false);
  ComposeUriProps(json, 'definition', elem.definitionObject, false);
  ComposeEnumValue(json, 'type', elem.Type_Object, CODES_TFhirSearchParamType, false);
  ComposeEnumProps(json, 'type', elem.Type_Object, CODES_TFhirSearchParamType, false);
  ComposeStringValue(json, 'documentation', elem.documentationObject, false);
  ComposeStringProps(json, 'documentation', elem.documentationObject, false);
  if elem.targetList.Count > 0 then
  begin
    json.valueArray('target');
    ext := false;
    for i := 0 to elem.targetList.Count - 1 do
    begin
      ext := ext or ((elem.targetList[i].xmlid <> '') or (elem.targetList[i].hasExtensions));
      ComposeCodeValue(json, '',elem.targetList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_target');
      for i := 0 to elem.targetList.Count - 1 do
        ComposeCodeProps(json, '',elem.targetList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.chainList.Count > 0 then
  begin
    json.valueArray('chain');
    ext := false;
    for i := 0 to elem.chainList.Count - 1 do
    begin
      ext := ext or ((elem.chainList[i].xmlid <> '') or (elem.chainList[i].hasExtensions));
      ComposeStringValue(json, '',elem.chainList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_chain');
      for i := 0 to elem.chainList.Count - 1 do
        ComposeStringProps(json, '',elem.chainList[i], true);
      json.FinishArray;
    end;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestInteraction(element : IXmlDomElement; path : string) : TFhirConformanceRestInteraction;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestInteraction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeObject := ParseEnum(CODES_TFhirSystemRestfulInteraction, path+'/code', child){1a}
      else if (child.baseName = 'documentation') then
        result.documentationObject := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestInteraction(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestInteraction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.CodeObject, CODES_TFhirSystemRestfulInteraction);
  ComposeString(xml, 'documentation', elem.documentationObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestInteraction(jsn));
end;

function TFHIRJsonParser.ParseConformanceRestInteraction(jsn : TJsonObject) : TFhirConformanceRestInteraction;
begin
  result := TFhirConformanceRestInteraction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeObject := parseEnum(jsn['code'], jsn.vObj['_code'], CODES_TFhirSystemRestfulInteraction);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationObject := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestInteraction(json : TJSONWriter; name : string; elem : TFhirConformanceRestInteraction);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.CodeObject, CODES_TFhirSystemRestfulInteraction, false);
  ComposeEnumProps(json, 'code', elem.CodeObject, CODES_TFhirSystemRestfulInteraction, false);
  ComposeStringValue(json, 'documentation', elem.documentationObject, false);
  ComposeStringProps(json, 'documentation', elem.documentationObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestOperation(element : IXmlDomElement; path : string) : TFhirConformanceRestOperation;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestOperation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'definition') then
        result.definition := ParseReference{TFhirOperationDefinition}(child, path+'/definition') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestOperation(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestOperation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeReference{TFhirOperationDefinition}(xml, 'definition', elem.definition);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestOperation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestOperation(jsn));
end;

function TFHIRJsonParser.ParseConformanceRestOperation(jsn : TJsonObject) : TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('definition') then
        result.definition := ParseReference{TFhirOperationDefinition}(jsn.vObj['definition']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestOperation(json : TJSONWriter; name : string; elem : TFhirConformanceRestOperation);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeReference{TFhirOperationDefinition}(json, 'definition', elem.definition); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceMessaging(element : IXmlDomElement; path : string) : TFhirConformanceMessaging;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceMessaging.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'endpoint') then
        result.endpointObject := ParseUri(child, path+'/endpoint') {b}
      else if (child.baseName = 'reliableCache') then
        result.reliableCacheObject := ParseInteger(child, path+'/reliableCache') {b}
      else if (child.baseName = 'documentation') then
        result.documentationObject := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'event') then
        result.eventList.Add(ParseConformanceMessagingEvent(child, path+'/event')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceMessaging(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessaging);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'endpoint', elem.endpointObject);{x.2}
  ComposeInteger(xml, 'reliableCache', elem.reliableCacheObject);{x.2}
  ComposeString(xml, 'documentation', elem.documentationObject);{x.2}
  for i := 0 to elem.eventList.Count - 1 do
    ComposeConformanceMessagingEvent(xml, 'event', elem.eventList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceMessaging(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceMessaging(jsn));
end;

function TFHIRJsonParser.ParseConformanceMessaging(jsn : TJsonObject) : TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpointObject := ParseUri(jsn['endpoint'], jsn.vObj['_endpoint']);{q}
    if jsn.has('reliableCache') or jsn.has('_reliableCache') then
        result.reliableCacheObject := ParseInteger(jsn['reliableCache'], jsn.vObj['_reliableCache']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationObject := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseConformanceMessagingEvent);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceMessaging(json : TJSONWriter; name : string; elem : TFhirConformanceMessaging);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'endpoint', elem.endpointObject, false);
  ComposeUriProps(json, 'endpoint', elem.endpointObject, false);
  ComposeIntegerValue(json, 'reliableCache', elem.reliableCacheObject, false);
  ComposeIntegerProps(json, 'reliableCache', elem.reliableCacheObject, false);
  ComposeStringValue(json, 'documentation', elem.documentationObject, false);
  ComposeStringProps(json, 'documentation', elem.documentationObject, false);
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeConformanceMessagingEvent(json, '',elem.eventList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceMessagingEvent(element : IXmlDomElement; path : string) : TFhirConformanceMessagingEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCoding(child, path+'/code') {b}
      else if (child.baseName = 'category') then
        result.categoryObject := ParseEnum(CODES_TFhirMessageSignificanceCategory, path+'/category', child){1a}
      else if (child.baseName = 'mode') then
        result.modeObject := ParseEnum(CODES_TFhirMessageConformanceEventMode, path+'/mode', child){1a}
      else if (child.baseName = 'protocol') then
        result.protocolList.Add(ParseCoding(child, path+'/protocol')){y.2}
      else if (child.baseName = 'focus') then
        result.focusObject := ParseCode(child, path+'/focus') {b}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirProfile}(child, path+'/request') {b}
      else if (child.baseName = 'response') then
        result.response := ParseReference{TFhirProfile}(child, path+'/response') {b}
      else if (child.baseName = 'documentation') then
        result.documentationObject := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceMessagingEvent(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessagingEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'code', elem.code);{x.2}
  ComposeEnum(xml, 'category', elem.CategoryObject, CODES_TFhirMessageSignificanceCategory);
  ComposeEnum(xml, 'mode', elem.ModeObject, CODES_TFhirMessageConformanceEventMode);
  for i := 0 to elem.protocolList.Count - 1 do
    ComposeCoding(xml, 'protocol', elem.protocolList[i]);
  ComposeCode(xml, 'focus', elem.focusObject);{x.2}
  ComposeReference{TFhirProfile}(xml, 'request', elem.request);{x.2}
  ComposeReference{TFhirProfile}(xml, 'response', elem.response);{x.2}
  ComposeString(xml, 'documentation', elem.documentationObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceMessagingEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceMessagingEvent(jsn));
end;

function TFHIRJsonParser.ParseConformanceMessagingEvent(jsn : TJsonObject) : TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q}
    if jsn.has('category') or jsn.has('_category')  then
      result.categoryObject := parseEnum(jsn['category'], jsn.vObj['_category'], CODES_TFhirMessageSignificanceCategory);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeObject := parseEnum(jsn['mode'], jsn.vObj['_mode'], CODES_TFhirMessageConformanceEventMode);
    if jsn.has('protocol') then
      iterateArray(jsn.vArr['protocol'], result.protocolList, parseCoding);
    if jsn.has('focus') or jsn.has('_focus') then
        result.focusObject := ParseCode(jsn['focus'], jsn.vObj['_focus']);{q}
    if jsn.has('request') then
        result.request := ParseReference{TFhirProfile}(jsn.vObj['request']);{q}
    if jsn.has('response') then
        result.response := ParseReference{TFhirProfile}(jsn.vObj['response']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationObject := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceMessagingEvent(json : TJSONWriter; name : string; elem : TFhirConformanceMessagingEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'code', elem.code); {a}
  ComposeEnumValue(json, 'category', elem.CategoryObject, CODES_TFhirMessageSignificanceCategory, false);
  ComposeEnumProps(json, 'category', elem.CategoryObject, CODES_TFhirMessageSignificanceCategory, false);
  ComposeEnumValue(json, 'mode', elem.ModeObject, CODES_TFhirMessageConformanceEventMode, false);
  ComposeEnumProps(json, 'mode', elem.ModeObject, CODES_TFhirMessageConformanceEventMode, false);
  if elem.protocolList.Count > 0 then
  begin
    json.valueArray('protocol');
    for i := 0 to elem.protocolList.Count - 1 do
      ComposeCoding(json, '',elem.protocolList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeCodeValue(json, 'focus', elem.focusObject, false);
  ComposeCodeProps(json, 'focus', elem.focusObject, false);
  ComposeReference{TFhirProfile}(json, 'request', elem.request); {a}
  ComposeReference{TFhirProfile}(json, 'response', elem.response); {a}
  ComposeStringValue(json, 'documentation', elem.documentationObject, false);
  ComposeStringProps(json, 'documentation', elem.documentationObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceDocument(element : IXmlDomElement; path : string) : TFhirConformanceDocument;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceDocument.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'mode') then
        result.modeObject := ParseEnum(CODES_TFhirDocumentMode, path+'/mode', child){1a}
      else if (child.baseName = 'documentation') then
        result.documentationObject := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'profile') then
        result.profile := ParseReference{TFhirProfile}(child, path+'/profile') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceDocument(xml : TXmlBuilder; name : string; elem : TFhirConformanceDocument);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'mode', elem.ModeObject, CODES_TFhirDocumentMode);
  ComposeString(xml, 'documentation', elem.documentationObject);{x.2}
  ComposeReference{TFhirProfile}(xml, 'profile', elem.profile);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceDocument(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceDocument(jsn));
end;

function TFHIRJsonParser.ParseConformanceDocument(jsn : TJsonObject) : TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeObject := parseEnum(jsn['mode'], jsn.vObj['_mode'], CODES_TFhirDocumentMode);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationObject := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('profile') then
        result.profile := ParseReference{TFhirProfile}(jsn.vObj['profile']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceDocument(json : TJSONWriter; name : string; elem : TFhirConformanceDocument);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'mode', elem.ModeObject, CODES_TFhirDocumentMode, false);
  ComposeEnumProps(json, 'mode', elem.ModeObject, CODES_TFhirDocumentMode, false);
  ComposeStringValue(json, 'documentation', elem.documentationObject, false);
  ComposeStringProps(json, 'documentation', elem.documentationObject, false);
  ComposeReference{TFhirProfile}(json, 'profile', elem.profile); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformance(element : IXmlDomElement; path : string) : TFhirConformance;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformance.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierObject := ParseString(child, path+'/identifier') {b}
      else if (child.baseName = 'version') then
        result.versionObject := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'publisher') then
        result.publisherObject := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirConformanceStatementStatus, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalObject := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'software') then
        result.software := ParseConformanceSoftware(child, path+'/software') {b}
      else if (child.baseName = 'implementation') then
        result.implementation_ := ParseConformanceImplementation(child, path+'/implementation') {b}
      else if (child.baseName = 'fhirVersion') then
        result.fhirVersionObject := ParseId(child, path+'/fhirVersion') {b}
      else if (child.baseName = 'acceptUnknown') then
        result.acceptUnknownObject := ParseBoolean(child, path+'/acceptUnknown') {b}
      else if (child.baseName = 'format') then
        result.formatList.Add(ParseCode(child, path+'/format')){y.2}
      else if (child.baseName = 'profile') then
        result.profileList.Add(ParseReference{TFhirProfile}(child, path+'/profile')){y.2}
      else if (child.baseName = 'rest') then
        result.restList.Add(ParseConformanceRest(child, path+'/rest')){y.2}
      else if (child.baseName = 'messaging') then
        result.messagingList.Add(ParseConformanceMessaging(child, path+'/messaging')){y.2}
      else if (child.baseName = 'document') then
        result.documentList.Add(ParseConformanceDocument(child, path+'/document')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformance(xml : TXmlBuilder; name : string; elem : TFhirConformance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeString(xml, 'identifier', elem.identifierObject);{x.2}
  ComposeString(xml, 'version', elem.versionObject);{x.2}
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeString(xml, 'publisher', elem.publisherObject);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirConformanceStatementStatus);
  ComposeBoolean(xml, 'experimental', elem.experimentalObject);{x.2}
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  ComposeConformanceSoftware(xml, 'software', elem.software);{x.2}
  ComposeConformanceImplementation(xml, 'implementation', elem.implementation_);{x.2}
  ComposeId(xml, 'fhirVersion', elem.fhirVersionObject);{x.2}
  ComposeBoolean(xml, 'acceptUnknown', elem.acceptUnknownObject);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.formatList.Count - 1 do
      ComposeCode(xml, 'format', elem.formatList[i]);
  if not SummaryOnly then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirProfile}(xml, 'profile', elem.profileList[i]);
  if not SummaryOnly then
    for i := 0 to elem.restList.Count - 1 do
      ComposeConformanceRest(xml, 'rest', elem.restList[i]);
  if not SummaryOnly then
    for i := 0 to elem.messagingList.Count - 1 do
      ComposeConformanceMessaging(xml, 'messaging', elem.messagingList[i]);
  if not SummaryOnly then
    for i := 0 to elem.documentList.Count - 1 do
      ComposeConformanceDocument(xml, 'document', elem.documentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformance(jsn));
end;

function TFHIRJsonParser.ParseConformance(jsn : TJsonObject) : TFhirConformance;
begin
  result := TFhirConformance.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierObject := ParseString(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionObject := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherObject := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceStatementStatus);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalObject := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('software') then
        result.software := ParseConformanceSoftware(jsn.vObj['software']);{q}
    if jsn.has('implementation') then
        result.implementation_ := ParseConformanceImplementation(jsn.vObj['implementation']);{q}
    if jsn.has('fhirVersion') or jsn.has('_fhirVersion') then
        result.fhirVersionObject := ParseId(jsn['fhirVersion'], jsn.vObj['_fhirVersion']);{q}
    if jsn.has('acceptUnknown') or jsn.has('_acceptUnknown') then
        result.acceptUnknownObject := ParseBoolean(jsn['acceptUnknown'], jsn.vObj['_acceptUnknown']);{q}
      if jsn.has('format') or jsn.has('_format') then
      iteratePrimitiveArray(jsn.vArr['format'], jsn.vArr['_format'], result.formatList, parseCode);
    if jsn.has('profile') then
      iterateArray(jsn.vArr['profile'], result.profileList, parseReference{TFhirProfile});
    if jsn.has('rest') then
      iterateArray(jsn.vArr['rest'], result.restList, parseConformanceRest);
    if jsn.has('messaging') then
      iterateArray(jsn.vArr['messaging'], result.messagingList, parseConformanceMessaging);
    if jsn.has('document') then
      iterateArray(jsn.vArr['document'], result.documentList, parseConformanceDocument);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformance(json : TJSONWriter; name : string; elem : TFhirConformance);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeStringValue(json, 'identifier', elem.identifierObject, false);
  ComposeStringProps(json, 'identifier', elem.identifierObject, false);
  ComposeStringValue(json, 'version', elem.versionObject, false);
  ComposeStringProps(json, 'version', elem.versionObject, false);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeStringValue(json, 'publisher', elem.publisherObject, false);
  ComposeStringProps(json, 'publisher', elem.publisherObject, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirConformanceStatementStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirConformanceStatementStatus, false);
  ComposeBooleanValue(json, 'experimental', elem.experimentalObject, false);
  ComposeBooleanProps(json, 'experimental', elem.experimentalObject, false);
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  ComposeConformanceSoftware(json, 'software', elem.software); {a}
  ComposeConformanceImplementation(json, 'implementation', elem.implementation_); {a}
  ComposeIdValue(json, 'fhirVersion', elem.fhirVersionObject, false);
  ComposeIdProps(json, 'fhirVersion', elem.fhirVersionObject, false);
  ComposeBooleanValue(json, 'acceptUnknown', elem.acceptUnknownObject, false);
  ComposeBooleanProps(json, 'acceptUnknown', elem.acceptUnknownObject, false);
  if not SummaryOnly and (elem.formatList.Count > 0) then
  begin
    json.valueArray('format');
    ext := false;
    for i := 0 to elem.formatList.Count - 1 do
    begin
      ext := ext or ((elem.formatList[i].xmlid <> '') or (elem.formatList[i].hasExtensions));
      ComposeCodeValue(json, '',elem.formatList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_format');
      for i := 0 to elem.formatList.Count - 1 do
        ComposeCodeProps(json, '',elem.formatList[i], true);
      json.FinishArray;
    end;
  end;
  if not SummaryOnly and (elem.profileList.Count > 0) then
  begin
    json.valueArray('profile');
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirProfile}(json, '',elem.profileList[i]); {z - Reference(Profile)}
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.restList.Count > 0) then
  begin
    json.valueArray('rest');
    for i := 0 to elem.restList.Count - 1 do
      ComposeConformanceRest(json, '',elem.restList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.messagingList.Count > 0) then
  begin
    json.valueArray('messaging');
    for i := 0 to elem.messagingList.Count - 1 do
      ComposeConformanceMessaging(json, '',elem.messagingList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.documentList.Count > 0) then
  begin
    json.valueArray('document');
    for i := 0 to elem.documentList.Count - 1 do
      ComposeConformanceDocument(json, '',elem.documentList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseContraindicationMitigation(element : IXmlDomElement; path : string) : TFhirContraindicationMitigation;
var
  child : IXMLDOMElement;
begin
  result := TFhirContraindicationMitigation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'action') then
        result.action := ParseCodeableConcept(child, path+'/action') {b}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{TFhirPractitioner}(child, path+'/author') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContraindicationMitigation(xml : TXmlBuilder; name : string; elem : TFhirContraindicationMitigation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'action', elem.action);{x.2}
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'author', elem.author);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContraindicationMitigation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContraindicationMitigation(jsn));
end;

function TFHIRJsonParser.ParseContraindicationMitigation(jsn : TJsonObject) : TFhirContraindicationMitigation;
begin
  result := TFhirContraindicationMitigation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('action') then
        result.action := ParseCodeableConcept(jsn.vObj['action']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('author') then
        result.author := ParseReference{TFhirPractitioner}(jsn.vObj['author']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContraindicationMitigation(json : TJSONWriter; name : string; elem : TFhirContraindicationMitigation);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'action', elem.action); {a}
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  ComposeReference{TFhirPractitioner}(json, 'author', elem.author); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseContraindication(element : IXmlDomElement; path : string) : TFhirContraindication;
var
  child : IXMLDOMElement;
begin
  result := TFhirContraindication.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'severity') then
        result.severityObject := ParseCode(child, path+'/severity') {b}
      else if (child.baseName = 'implicated') then
        result.implicatedList.Add(ParseReference{TFhirReference}(child, path+'/implicated')){y.2}
      else if (child.baseName = 'detail') then
        result.detailObject := ParseString(child, path+'/detail') {b}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'reference') then
        result.referenceObject := ParseUri(child, path+'/reference') {b}
      else if (child.baseName = 'mitigation') then
        result.mitigationList.Add(ParseContraindicationMitigation(child, path+'/mitigation')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContraindication(xml : TXmlBuilder; name : string; elem : TFhirContraindication);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  ComposeCode(xml, 'severity', elem.severityObject);{x.2}
  for i := 0 to elem.implicatedList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'implicated', elem.implicatedList[i]);
  if not SummaryOnly then
    ComposeString(xml, 'detail', elem.detailObject);{x.2}
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  ComposeReference{Resource}(xml, 'author', elem.author);{x.2}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if not SummaryOnly then
    ComposeUri(xml, 'reference', elem.referenceObject);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.mitigationList.Count - 1 do
      ComposeContraindicationMitigation(xml, 'mitigation', elem.mitigationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContraindication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContraindication(jsn));
end;

function TFHIRJsonParser.ParseContraindication(jsn : TJsonObject) : TFhirContraindication;
begin
  result := TFhirContraindication.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('severity') or jsn.has('_severity') then
        result.severityObject := ParseCode(jsn['severity'], jsn.vObj['_severity']);{q}
    if jsn.has('implicated') then
      iterateArray(jsn.vArr['implicated'], result.implicatedList, parseReference{TFhirReference});
    if jsn.has('detail') or jsn.has('_detail') then
        result.detailObject := ParseString(jsn['detail'], jsn.vObj['_detail']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceObject := ParseUri(jsn['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('mitigation') then
      iterateArray(jsn.vArr['mitigation'], result.mitigationList, parseContraindicationMitigation);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContraindication(json : TJSONWriter; name : string; elem : TFhirContraindication);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeCodeValue(json, 'severity', elem.severityObject, false);
  ComposeCodeProps(json, 'severity', elem.severityObject, false);
  if elem.implicatedList.Count > 0 then
  begin
    json.valueArray('implicated');
    for i := 0 to elem.implicatedList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.implicatedList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if not SummaryOnly then
    ComposeStringValue(json, 'detail', elem.detailObject, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'detail', elem.detailObject, false);
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  ComposeReference{Resource}(json, 'author', elem.author); {a}
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if not SummaryOnly then
    ComposeUriValue(json, 'reference', elem.referenceObject, false);
  if not SummaryOnly then
    ComposeUriProps(json, 'reference', elem.referenceObject, false);
  if not SummaryOnly and (elem.mitigationList.Count > 0) then
  begin
    json.valueArray('mitigation');
    for i := 0 to elem.mitigationList.Count - 1 do
      ComposeContraindicationMitigation(json, '',elem.mitigationList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseDataElementBinding(element : IXmlDomElement; path : string) : TFhirDataElementBinding;
var
  child : IXMLDOMElement;
begin
  result := TFhirDataElementBinding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'isExtensible') then
        result.isExtensibleObject := ParseBoolean(child, path+'/isExtensible') {b}
      else if (child.baseName = 'conformance') then
        result.conformanceObject := ParseEnum(CODES_TFhirBindingConformance, path+'/conformance', child){1a}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'valueSet') then
        result.valueSet := ParseReference{TFhirValueSet}(child, path+'/valueSet') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDataElementBinding(xml : TXmlBuilder; name : string; elem : TFhirDataElementBinding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeBoolean(xml, 'isExtensible', elem.isExtensibleObject);{x.2}
  ComposeEnum(xml, 'conformance', elem.ConformanceObject, CODES_TFhirBindingConformance);
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  ComposeReference{TFhirValueSet}(xml, 'valueSet', elem.valueSet);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDataElementBinding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDataElementBinding(jsn));
end;

function TFHIRJsonParser.ParseDataElementBinding(jsn : TJsonObject) : TFhirDataElementBinding;
begin
  result := TFhirDataElementBinding.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('isExtensible') or jsn.has('_isExtensible') then
        result.isExtensibleObject := ParseBoolean(jsn['isExtensible'], jsn.vObj['_isExtensible']);{q}
    if jsn.has('conformance') or jsn.has('_conformance')  then
      result.conformanceObject := parseEnum(jsn['conformance'], jsn.vObj['_conformance'], CODES_TFhirBindingConformance);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('valueSet') then
        result.valueSet := ParseReference{TFhirValueSet}(jsn.vObj['valueSet']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDataElementBinding(json : TJSONWriter; name : string; elem : TFhirDataElementBinding);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeBooleanValue(json, 'isExtensible', elem.isExtensibleObject, false);
  ComposeBooleanProps(json, 'isExtensible', elem.isExtensibleObject, false);
  ComposeEnumValue(json, 'conformance', elem.ConformanceObject, CODES_TFhirBindingConformance, false);
  ComposeEnumProps(json, 'conformance', elem.ConformanceObject, CODES_TFhirBindingConformance, false);
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  ComposeReference{TFhirValueSet}(json, 'valueSet', elem.valueSet); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseDataElementMapping(element : IXmlDomElement; path : string) : TFhirDataElementMapping;
var
  child : IXMLDOMElement;
begin
  result := TFhirDataElementMapping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'uri') then
        result.uriObject := ParseUri(child, path+'/uri') {b}
      else if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'comments') then
        result.commentsObject := ParseString(child, path+'/comments') {b}
      else if (child.baseName = 'map') then
        result.mapObject := ParseString(child, path+'/map') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDataElementMapping(xml : TXmlBuilder; name : string; elem : TFhirDataElementMapping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'uri', elem.uriObject);{x.2}
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeString(xml, 'comments', elem.commentsObject);{x.2}
  ComposeString(xml, 'map', elem.mapObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDataElementMapping(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDataElementMapping(jsn));
end;

function TFHIRJsonParser.ParseDataElementMapping(jsn : TJsonObject) : TFhirDataElementMapping;
begin
  result := TFhirDataElementMapping.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('uri') or jsn.has('_uri') then
        result.uriObject := ParseUri(jsn['uri'], jsn.vObj['_uri']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsObject := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    if jsn.has('map') or jsn.has('_map') then
        result.mapObject := ParseString(jsn['map'], jsn.vObj['_map']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDataElementMapping(json : TJSONWriter; name : string; elem : TFhirDataElementMapping);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'uri', elem.uriObject, false);
  ComposeUriProps(json, 'uri', elem.uriObject, false);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeStringValue(json, 'comments', elem.commentsObject, false);
  ComposeStringProps(json, 'comments', elem.commentsObject, false);
  ComposeStringValue(json, 'map', elem.mapObject, false);
  ComposeStringProps(json, 'map', elem.mapObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseDataElement(element : IXmlDomElement; path : string) : TFhirDataElement;
var
  child : IXMLDOMElement;
begin
  result := TFhirDataElement.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'version') then
        result.versionObject := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'publisher') then
        result.publisherObject := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirResourceObservationDefStatus, path+'/status', child){1a}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'category') then
        result.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.baseName = 'code') then
        result.codeList.Add(ParseCoding(child, path+'/code')){y.2}
      else if (child.baseName = 'question') then
        result.questionObject := ParseString(child, path+'/question') {b}
      else if (child.baseName = 'definition') then
        result.definitionObject := ParseString(child, path+'/definition') {b}
      else if (child.baseName = 'comments') then
        result.commentsObject := ParseString(child, path+'/comments') {b}
      else if (child.baseName = 'requirements') then
        result.requirementsObject := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'synonym') then
        result.synonymList.Add(ParseString(child, path+'/synonym')){y.2}
      else if (child.baseName = 'type') then
        result.type_Object := ParseCode(child, path+'/type') {b}
      else if (child.baseName = 'exampleInteger') then
        result.example := ParseInteger(child, path+'.exampleInteger') {c}
      else if (child.baseName = 'exampleDateTime') then
        result.example := ParseDateTime(child, path+'.exampleDateTime') {c}
      else if (child.baseName = 'exampleCode') then
        result.example := ParseCode(child, path+'.exampleCode') {c}
      else if (child.baseName = 'exampleDate') then
        result.example := ParseDate(child, path+'.exampleDate') {c}
      else if (child.baseName = 'exampleDecimal') then
        result.example := ParseDecimal(child, path+'.exampleDecimal') {c}
      else if (child.baseName = 'exampleUri') then
        result.example := ParseUri(child, path+'.exampleUri') {c}
      else if (child.baseName = 'exampleId') then
        result.example := ParseId(child, path+'.exampleId') {c}
      else if (child.baseName = 'exampleBase64Binary') then
        result.example := ParseBase64Binary(child, path+'.exampleBase64Binary') {c}
      else if (child.baseName = 'exampleTime') then
        result.example := ParseTime(child, path+'.exampleTime') {c}
      else if (child.baseName = 'exampleOid') then
        result.example := ParseOid(child, path+'.exampleOid') {c}
      else if (child.baseName = 'exampleString') then
        result.example := ParseString(child, path+'.exampleString') {c}
      else if (child.baseName = 'exampleBoolean') then
        result.example := ParseBoolean(child, path+'.exampleBoolean') {c}
      else if (child.baseName = 'exampleUuid') then
        result.example := ParseUuid(child, path+'.exampleUuid') {c}
      else if (child.baseName = 'exampleInstant') then
        result.example := ParseInstant(child, path+'.exampleInstant') {c}
      else if (child.baseName = 'examplePeriod') then
        result.example := ParsePeriod(child, path+'.examplePeriod') {ePeriod}
      else if (child.baseName = 'exampleCoding') then
        result.example := ParseCoding(child, path+'.exampleCoding') {eCoding}
      else if (child.baseName = 'exampleRange') then
        result.example := ParseRange(child, path+'.exampleRange') {eRange}
      else if (child.baseName = 'exampleQuantity') then
        result.example := ParseQuantity(child, path+'.exampleQuantity') {eQuantity}
      else if (child.baseName = 'exampleAttachment') then
        result.example := ParseAttachment(child, path+'.exampleAttachment') {eAttachment}
      else if (child.baseName = 'exampleRatio') then
        result.example := ParseRatio(child, path+'.exampleRatio') {eRatio}
      else if (child.baseName = 'exampleSampledData') then
        result.example := ParseSampledData(child, path+'.exampleSampledData') {eSampledData}
      else if (child.baseName = 'exampleReference') then
        result.example := ParseReference(child, path+'.exampleReference') {eReference}
      else if (child.baseName = 'exampleCodeableConcept') then
        result.example := ParseCodeableConcept(child, path+'.exampleCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'exampleIdentifier') then
        result.example := ParseIdentifier(child, path+'.exampleIdentifier') {eIdentifier}
      else if (child.baseName = 'exampleTiming') then
        result.example := ParseTiming(child, path+'/exampleTiming') {f}
      else if (child.baseName = 'exampleAddress') then
        result.example := ParseAddress(child, path+'/exampleAddress') {f}
      else if (child.baseName = 'exampleHumanName') then
        result.example := ParseHumanName(child, path+'/exampleHumanName') {f}
      else if (child.baseName = 'exampleContactPoint') then
        result.example := ParseContactPoint(child, path+'/exampleContactPoint') {f}
      else if (child.baseName = 'maxLength') then
        result.maxLengthObject := ParseInteger(child, path+'/maxLength') {b}
      else if (child.baseName = 'units') then
        result.units := ParseCodeableConcept(child, path+'/units') {b}
      else if (child.baseName = 'binding') then
        result.binding := ParseDataElementBinding(child, path+'/binding') {b}
      else if (child.baseName = 'mapping') then
        result.mappingList.Add(ParseDataElementMapping(child, path+'/mapping')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDataElement(xml : TXmlBuilder; name : string; elem : TFhirDataElement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeString(xml, 'version', elem.versionObject);{x.2}
  ComposeString(xml, 'publisher', elem.publisherObject);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirResourceObservationDefStatus);
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  for i := 0 to elem.categoryList.Count - 1 do
    ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  for i := 0 to elem.codeList.Count - 1 do
    ComposeCoding(xml, 'code', elem.codeList[i]);
  ComposeString(xml, 'question', elem.questionObject);{x.2}
  if not SummaryOnly then
    ComposeString(xml, 'definition', elem.definitionObject);{x.2}
  if not SummaryOnly then
    ComposeString(xml, 'comments', elem.commentsObject);{x.2}
  if not SummaryOnly then
    ComposeString(xml, 'requirements', elem.requirementsObject);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.synonymList.Count - 1 do
      ComposeString(xml, 'synonym', elem.synonymList[i]);
  if not SummaryOnly then
    ComposeCode(xml, 'type', elem.type_Object);{x.2}
  if Not SummaryOnly and (elem.example is TFhirInteger) {1} then
    ComposeInteger(xml, 'exampleInteger', TFhirInteger(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'exampleDateTime', TFhirDateTime(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirCode) {1} then
    ComposeCode(xml, 'exampleCode', TFhirCode(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirDate) {1} then
    ComposeDate(xml, 'exampleDate', TFhirDate(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'exampleDecimal', TFhirDecimal(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirUri) {1} then
    ComposeUri(xml, 'exampleUri', TFhirUri(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirId) {1} then
    ComposeId(xml, 'exampleId', TFhirId(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'exampleBase64Binary', TFhirBase64Binary(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirTime) {1} then
    ComposeTime(xml, 'exampleTime', TFhirTime(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirOid) {1} then
    ComposeOid(xml, 'exampleOid', TFhirOid(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirString) {1} then
    ComposeString(xml, 'exampleString', TFhirString(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'exampleBoolean', TFhirBoolean(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirUuid) {1} then
    ComposeUuid(xml, 'exampleUuid', TFhirUuid(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirInstant) {1} then
    ComposeInstant(xml, 'exampleInstant', TFhirInstant(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirPeriod) {8} then
    ComposePeriod(xml, 'examplePeriod', TFhirPeriod(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirCoding) {8} then
    ComposeCoding(xml, 'exampleCoding', TFhirCoding(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirRange) {8} then
    ComposeRange(xml, 'exampleRange', TFhirRange(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'exampleQuantity', TFhirQuantity(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'exampleAttachment', TFhirAttachment(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirRatio) {8} then
    ComposeRatio(xml, 'exampleRatio', TFhirRatio(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'exampleSampledData', TFhirSampledData(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirReference) {8} then
    ComposeReference(xml, 'exampleReference', TFhirReference(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'exampleCodeableConcept', TFhirCodeableConcept(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'exampleIdentifier', TFhirIdentifier(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirTiming) {9} then
    ComposeTiming(xml, 'exampleTiming', TFhirTiming(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirAddress) {9} then
    ComposeAddress(xml, 'exampleAddress', TFhirAddress(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'exampleHumanName', TFhirHumanName(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'exampleContactPoint', TFhirContactPoint(elem.example));
  if not SummaryOnly then
    ComposeInteger(xml, 'maxLength', elem.maxLengthObject);{x.2}
  if not SummaryOnly then
    ComposeCodeableConcept(xml, 'units', elem.units);{x.2}
  if not SummaryOnly then
    ComposeDataElementBinding(xml, 'binding', elem.binding);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeDataElementMapping(xml, 'mapping', elem.mappingList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDataElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDataElement(jsn));
end;

function TFHIRJsonParser.ParseDataElement(jsn : TJsonObject) : TFhirDataElement;
begin
  result := TFhirDataElement.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionObject := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherObject := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirResourceObservationDefStatus);
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCoding);
    if jsn.has('question') or jsn.has('_question') then
        result.questionObject := ParseString(jsn['question'], jsn.vObj['_question']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionObject := ParseString(jsn['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsObject := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsObject := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
      if jsn.has('synonym') or jsn.has('_synonym') then
      iteratePrimitiveArray(jsn.vArr['synonym'], jsn.vArr['_synonym'], result.synonymList, parseString);
    if jsn.has('type') or jsn.has('_type') then
        result.type_Object := ParseCode(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('exampleInteger') or jsn.has('_exampleInteger') then
        result.example := ParseInteger(jsn['exampleInteger'], jsn.vObj['_exampleInteger']);
    if jsn.has('exampleDateTime') or jsn.has('_exampleDateTime') then
        result.example := ParseDateTime(jsn['exampleDateTime'], jsn.vObj['_exampleDateTime']);
    if jsn.has('exampleCode') or jsn.has('_exampleCode') then
        result.example := ParseCode(jsn['exampleCode'], jsn.vObj['_exampleCode']);
    if jsn.has('exampleDate') or jsn.has('_exampleDate') then
        result.example := ParseDate(jsn['exampleDate'], jsn.vObj['_exampleDate']);
    if jsn.has('exampleDecimal') or jsn.has('_exampleDecimal') then
        result.example := ParseDecimal(jsn['exampleDecimal'], jsn.vObj['_exampleDecimal']);
    if jsn.has('exampleUri') or jsn.has('_exampleUri') then
        result.example := ParseUri(jsn['exampleUri'], jsn.vObj['_exampleUri']);
    if jsn.has('exampleId') or jsn.has('_exampleId') then
        result.example := ParseId(jsn['exampleId'], jsn.vObj['_exampleId']);
    if jsn.has('exampleBase64Binary') or jsn.has('_exampleBase64Binary') then
        result.example := ParseBase64Binary(jsn['exampleBase64Binary'], jsn.vObj['_exampleBase64Binary']);
    if jsn.has('exampleTime') or jsn.has('_exampleTime') then
        result.example := ParseTime(jsn['exampleTime'], jsn.vObj['_exampleTime']);
    if jsn.has('exampleOid') or jsn.has('_exampleOid') then
        result.example := ParseOid(jsn['exampleOid'], jsn.vObj['_exampleOid']);
    if jsn.has('exampleString') or jsn.has('_exampleString') then
        result.example := ParseString(jsn['exampleString'], jsn.vObj['_exampleString']);
    if jsn.has('exampleBoolean') or jsn.has('_exampleBoolean') then
        result.example := ParseBoolean(jsn['exampleBoolean'], jsn.vObj['_exampleBoolean']);
    if jsn.has('exampleUuid') or jsn.has('_exampleUuid') then
        result.example := ParseUuid(jsn['exampleUuid'], jsn.vObj['_exampleUuid']);
    if jsn.has('exampleInstant') or jsn.has('_exampleInstant') then
        result.example := ParseInstant(jsn['exampleInstant'], jsn.vObj['_exampleInstant']);
    if jsn.has('examplePeriod') {a7} then
        result.example := ParsePeriod(jsn.vObj['examplePeriod']);
    if jsn.has('exampleCoding') {a7} then
        result.example := ParseCoding(jsn.vObj['exampleCoding']);
    if jsn.has('exampleRange') {a7} then
        result.example := ParseRange(jsn.vObj['exampleRange']);
    if jsn.has('exampleQuantity') {a7} then
        result.example := ParseQuantity(jsn.vObj['exampleQuantity']);
    if jsn.has('exampleAttachment') {a7} then
        result.example := ParseAttachment(jsn.vObj['exampleAttachment']);
    if jsn.has('exampleRatio') {a7} then
        result.example := ParseRatio(jsn.vObj['exampleRatio']);
    if jsn.has('exampleSampledData') {a7} then
        result.example := ParseSampledData(jsn.vObj['exampleSampledData']);
    if jsn.has('exampleReference') {a7} then
        result.example := ParseReference(jsn.vObj['exampleReference']);
    if jsn.has('exampleCodeableConcept') {a7} then
        result.example := ParseCodeableConcept(jsn.vObj['exampleCodeableConcept']);
    if jsn.has('exampleIdentifier') {a7} then
        result.example := ParseIdentifier(jsn.vObj['exampleIdentifier']);
    if jsn.has('exampleTiming') {a9} then
        result.example := ParseTiming(jsn.vObj['exampleTiming']);
    if jsn.has('exampleAddress') {a9} then
        result.example := ParseAddress(jsn.vObj['exampleAddress']);
    if jsn.has('exampleHumanName') {a9} then
        result.example := ParseHumanName(jsn.vObj['exampleHumanName']);
    if jsn.has('exampleContactPoint') {a9} then
        result.example := ParseContactPoint(jsn.vObj['exampleContactPoint']);
    if jsn.has('maxLength') or jsn.has('_maxLength') then
        result.maxLengthObject := ParseInteger(jsn['maxLength'], jsn.vObj['_maxLength']);{q}
    if jsn.has('units') then
        result.units := ParseCodeableConcept(jsn.vObj['units']);{q}
    if jsn.has('binding') then
        result.binding := ParseDataElementBinding(jsn.vObj['binding']);{q}
    if jsn.has('mapping') then
      iterateArray(jsn.vArr['mapping'], result.mappingList, parseDataElementMapping);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDataElement(json : TJSONWriter; name : string; elem : TFhirDataElement);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeStringValue(json, 'version', elem.versionObject, false);
  ComposeStringProps(json, 'version', elem.versionObject, false);
  ComposeStringValue(json, 'publisher', elem.publisherObject, false);
  ComposeStringProps(json, 'publisher', elem.publisherObject, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirResourceObservationDefStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirResourceObservationDefStatus, false);
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  if elem.categoryList.Count > 0 then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.codeList.Count > 0 then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(json, '',elem.codeList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'question', elem.questionObject, false);
  ComposeStringProps(json, 'question', elem.questionObject, false);
  if not SummaryOnly then
    ComposeStringValue(json, 'definition', elem.definitionObject, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'definition', elem.definitionObject, false);
  if not SummaryOnly then
    ComposeStringValue(json, 'comments', elem.commentsObject, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'comments', elem.commentsObject, false);
  if not SummaryOnly then
    ComposeStringValue(json, 'requirements', elem.requirementsObject, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'requirements', elem.requirementsObject, false);
  if not SummaryOnly and (elem.synonymList.Count > 0) then
  begin
    json.valueArray('synonym');
    ext := false;
    for i := 0 to elem.synonymList.Count - 1 do
    begin
      ext := ext or ((elem.synonymList[i].xmlid <> '') or (elem.synonymList[i].hasExtensions));
      ComposeStringValue(json, '',elem.synonymList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_synonym');
      for i := 0 to elem.synonymList.Count - 1 do
        ComposeStringProps(json, '',elem.synonymList[i], true);
      json.FinishArray;
    end;
  end;
  if not SummaryOnly then
    ComposeCodeValue(json, 'type', elem.type_Object, false);
  if not SummaryOnly then
    ComposeCodeProps(json, 'type', elem.type_Object, false);
  if Not SummaryOnly and (elem.example is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'exampleInteger', TFhirInteger(elem.example), false);
    ComposeIntegerProps(json, 'exampleInteger', TFhirInteger(elem.example), false)
  end
  else if Not SummaryOnly and (elem.example is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'exampleDateTime', TFhirDateTime(elem.example), false);
    ComposeDateTimeProps(json, 'exampleDateTime', TFhirDateTime(elem.example), false)
  end
  else if Not SummaryOnly and (elem.example is TFhirCode) then
  begin
    ComposeCodeValue(json, 'exampleCode', TFhirCode(elem.example), false);
    ComposeCodeProps(json, 'exampleCode', TFhirCode(elem.example), false)
  end
  else if Not SummaryOnly and (elem.example is TFhirDate) then
  begin
    ComposeDateValue(json, 'exampleDate', TFhirDate(elem.example), false);
    ComposeDateProps(json, 'exampleDate', TFhirDate(elem.example), false)
  end
  else if Not SummaryOnly and (elem.example is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'exampleDecimal', TFhirDecimal(elem.example), false);
    ComposeDecimalProps(json, 'exampleDecimal', TFhirDecimal(elem.example), false)
  end
  else if Not SummaryOnly and (elem.example is TFhirUri) then
  begin
    ComposeUriValue(json, 'exampleUri', TFhirUri(elem.example), false);
    ComposeUriProps(json, 'exampleUri', TFhirUri(elem.example), false)
  end
  else if Not SummaryOnly and (elem.example is TFhirId) then
  begin
    ComposeIdValue(json, 'exampleId', TFhirId(elem.example), false);
    ComposeIdProps(json, 'exampleId', TFhirId(elem.example), false)
  end
  else if Not SummaryOnly and (elem.example is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'exampleBase64Binary', TFhirBase64Binary(elem.example), false);
    ComposeBase64BinaryProps(json, 'exampleBase64Binary', TFhirBase64Binary(elem.example), false)
  end
  else if Not SummaryOnly and (elem.example is TFhirTime) then
  begin
    ComposeTimeValue(json, 'exampleTime', TFhirTime(elem.example), false);
    ComposeTimeProps(json, 'exampleTime', TFhirTime(elem.example), false)
  end
  else if Not SummaryOnly and (elem.example is TFhirOid) then
  begin
    ComposeOidValue(json, 'exampleOid', TFhirOid(elem.example), false);
    ComposeOidProps(json, 'exampleOid', TFhirOid(elem.example), false)
  end
  else if Not SummaryOnly and (elem.example is TFhirString) then
  begin
    ComposeStringValue(json, 'exampleString', TFhirString(elem.example), false);
    ComposeStringProps(json, 'exampleString', TFhirString(elem.example), false)
  end
  else if Not SummaryOnly and (elem.example is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'exampleBoolean', TFhirBoolean(elem.example), false);
    ComposeBooleanProps(json, 'exampleBoolean', TFhirBoolean(elem.example), false)
  end
  else if Not SummaryOnly and (elem.example is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'exampleUuid', TFhirUuid(elem.example), false);
    ComposeUuidProps(json, 'exampleUuid', TFhirUuid(elem.example), false)
  end
  else if Not SummaryOnly and (elem.example is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'exampleInstant', TFhirInstant(elem.example), false);
    ComposeInstantProps(json, 'exampleInstant', TFhirInstant(elem.example), false)
  end
  else if Not SummaryOnly and (elem.example is TFhirPeriod) then
    ComposePeriod(json, 'examplePeriod', TFhirPeriod(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirCoding) then
    ComposeCoding(json, 'exampleCoding', TFhirCoding(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirRange) then
    ComposeRange(json, 'exampleRange', TFhirRange(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirQuantity) then
    ComposeQuantity(json, 'exampleQuantity', TFhirQuantity(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirAttachment) then
    ComposeAttachment(json, 'exampleAttachment', TFhirAttachment(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirRatio) then
    ComposeRatio(json, 'exampleRatio', TFhirRatio(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirSampledData) then
    ComposeSampledData(json, 'exampleSampledData', TFhirSampledData(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirReference) then
    ComposeReference(json, 'exampleReference', TFhirReference(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'exampleCodeableConcept', TFhirCodeableConcept(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirIdentifier) then
    ComposeIdentifier(json, 'exampleIdentifier', TFhirIdentifier(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirTiming) then
    ComposeTiming(json, 'exampleTiming', TFhirTiming(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirAddress) then
    ComposeAddress(json, 'exampleAddress', TFhirAddress(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirHumanName) then
    ComposeHumanName(json, 'exampleHumanName', TFhirHumanName(elem.example))
  else if Not SummaryOnly and (elem.example is TFhirContactPoint) then
    ComposeContactPoint(json, 'exampleContactPoint', TFhirContactPoint(elem.example));
  if not SummaryOnly then
    ComposeIntegerValue(json, 'maxLength', elem.maxLengthObject, false);
  if not SummaryOnly then
    ComposeIntegerProps(json, 'maxLength', elem.maxLengthObject, false);
  if not SummaryOnly then
    ComposeCodeableConcept(json, 'units', elem.units); {a}
  if not SummaryOnly then
    ComposeDataElementBinding(json, 'binding', elem.binding); {a}
  if not SummaryOnly and (elem.mappingList.Count > 0) then
  begin
    json.valueArray('mapping');
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeDataElementMapping(json, '',elem.mappingList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseDevice(element : IXmlDomElement; path : string) : TFhirDevice;
var
  child : IXMLDOMElement;
begin
  result := TFhirDevice.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'manufacturer') then
        result.manufacturerObject := ParseString(child, path+'/manufacturer') {b}
      else if (child.baseName = 'model') then
        result.modelObject := ParseString(child, path+'/model') {b}
      else if (child.baseName = 'version') then
        result.versionObject := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'expiry') then
        result.expiryObject := ParseDate(child, path+'/expiry') {b}
      else if (child.baseName = 'udi') then
        result.udiObject := ParseString(child, path+'/udi') {b}
      else if (child.baseName = 'lotNumber') then
        result.lotNumberObject := ParseString(child, path+'/lotNumber') {b}
      else if (child.baseName = 'owner') then
        result.owner := ParseReference{TFhirOrganization}(child, path+'/owner') {b}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseContactPoint(child, path+'/contact')){y.2}
      else if (child.baseName = 'url') then
        result.urlObject := ParseUri(child, path+'/url') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDevice(xml : TXmlBuilder; name : string; elem : TFhirDevice);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeString(xml, 'manufacturer', elem.manufacturerObject);{x.2}
  ComposeString(xml, 'model', elem.modelObject);{x.2}
  ComposeString(xml, 'version', elem.versionObject);{x.2}
  ComposeDate(xml, 'expiry', elem.expiryObject);{x.2}
  ComposeString(xml, 'udi', elem.udiObject);{x.2}
  ComposeString(xml, 'lotNumber', elem.lotNumberObject);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'owner', elem.owner);{x.2}
  ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  for i := 0 to elem.contactList.Count - 1 do
    ComposeContactPoint(xml, 'contact', elem.contactList[i]);
  ComposeUri(xml, 'url', elem.urlObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDevice(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDevice(jsn));
end;

function TFHIRJsonParser.ParseDevice(jsn : TJsonObject) : TFhirDevice;
begin
  result := TFhirDevice.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('manufacturer') or jsn.has('_manufacturer') then
        result.manufacturerObject := ParseString(jsn['manufacturer'], jsn.vObj['_manufacturer']);{q}
    if jsn.has('model') or jsn.has('_model') then
        result.modelObject := ParseString(jsn['model'], jsn.vObj['_model']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionObject := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('expiry') or jsn.has('_expiry') then
        result.expiryObject := ParseDate(jsn['expiry'], jsn.vObj['_expiry']);{q}
    if jsn.has('udi') or jsn.has('_udi') then
        result.udiObject := ParseString(jsn['udi'], jsn.vObj['_udi']);{q}
    if jsn.has('lotNumber') or jsn.has('_lotNumber') then
        result.lotNumberObject := ParseString(jsn['lotNumber'], jsn.vObj['_lotNumber']);{q}
    if jsn.has('owner') then
        result.owner := ParseReference{TFhirOrganization}(jsn.vObj['owner']);{q}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactPoint);
    if jsn.has('url') or jsn.has('_url') then
        result.urlObject := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDevice(json : TJSONWriter; name : string; elem : TFhirDevice);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeStringValue(json, 'manufacturer', elem.manufacturerObject, false);
  ComposeStringProps(json, 'manufacturer', elem.manufacturerObject, false);
  ComposeStringValue(json, 'model', elem.modelObject, false);
  ComposeStringProps(json, 'model', elem.modelObject, false);
  ComposeStringValue(json, 'version', elem.versionObject, false);
  ComposeStringProps(json, 'version', elem.versionObject, false);
  ComposeDateValue(json, 'expiry', elem.expiryObject, false);
  ComposeDateProps(json, 'expiry', elem.expiryObject, false);
  ComposeStringValue(json, 'udi', elem.udiObject, false);
  ComposeStringProps(json, 'udi', elem.udiObject, false);
  ComposeStringValue(json, 'lotNumber', elem.lotNumberObject, false);
  ComposeStringProps(json, 'lotNumber', elem.lotNumberObject, false);
  ComposeReference{TFhirOrganization}(json, 'owner', elem.owner); {a}
  ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if elem.contactList.Count > 0 then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(json, '',elem.contactList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeUriValue(json, 'url', elem.urlObject, false);
  ComposeUriProps(json, 'url', elem.urlObject, false);
end;

function TFHIRXmlParser.ParseDeviceObservationReportVirtualDevice(element : IXmlDomElement; path : string) : TFhirDeviceObservationReportVirtualDevice;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceObservationReportVirtualDevice.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'channel') then
        result.channelList.Add(ParseDeviceObservationReportVirtualDeviceChannel(child, path+'/channel')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceObservationReportVirtualDevice(xml : TXmlBuilder; name : string; elem : TFhirDeviceObservationReportVirtualDevice);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  for i := 0 to elem.channelList.Count - 1 do
    ComposeDeviceObservationReportVirtualDeviceChannel(xml, 'channel', elem.channelList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceObservationReportVirtualDevice(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceObservationReportVirtualDevice(jsn));
end;

function TFHIRJsonParser.ParseDeviceObservationReportVirtualDevice(jsn : TJsonObject) : TFhirDeviceObservationReportVirtualDevice;
begin
  result := TFhirDeviceObservationReportVirtualDevice.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('channel') then
      iterateArray(jsn.vArr['channel'], result.channelList, parseDeviceObservationReportVirtualDeviceChannel);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceObservationReportVirtualDevice(json : TJSONWriter; name : string; elem : TFhirDeviceObservationReportVirtualDevice);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if elem.channelList.Count > 0 then
  begin
    json.valueArray('channel');
    for i := 0 to elem.channelList.Count - 1 do
      ComposeDeviceObservationReportVirtualDeviceChannel(json, '',elem.channelList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseDeviceObservationReportVirtualDeviceChannel(element : IXmlDomElement; path : string) : TFhirDeviceObservationReportVirtualDeviceChannel;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannel.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'metric') then
        result.metricList.Add(ParseDeviceObservationReportVirtualDeviceChannelMetric(child, path+'/metric')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceObservationReportVirtualDeviceChannel(xml : TXmlBuilder; name : string; elem : TFhirDeviceObservationReportVirtualDeviceChannel);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  for i := 0 to elem.metricList.Count - 1 do
    ComposeDeviceObservationReportVirtualDeviceChannelMetric(xml, 'metric', elem.metricList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceObservationReportVirtualDeviceChannel(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceObservationReportVirtualDeviceChannel(jsn));
end;

function TFHIRJsonParser.ParseDeviceObservationReportVirtualDeviceChannel(jsn : TJsonObject) : TFhirDeviceObservationReportVirtualDeviceChannel;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannel.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('metric') then
      iterateArray(jsn.vArr['metric'], result.metricList, parseDeviceObservationReportVirtualDeviceChannelMetric);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceObservationReportVirtualDeviceChannel(json : TJSONWriter; name : string; elem : TFhirDeviceObservationReportVirtualDeviceChannel);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if elem.metricList.Count > 0 then
  begin
    json.valueArray('metric');
    for i := 0 to elem.metricList.Count - 1 do
      ComposeDeviceObservationReportVirtualDeviceChannelMetric(json, '',elem.metricList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseDeviceObservationReportVirtualDeviceChannelMetric(element : IXmlDomElement; path : string) : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetric.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'observation') then
        result.observation := ParseReference{TFhirObservation}(child, path+'/observation') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceObservationReportVirtualDeviceChannelMetric(xml : TXmlBuilder; name : string; elem : TFhirDeviceObservationReportVirtualDeviceChannelMetric);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirObservation}(xml, 'observation', elem.observation);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceObservationReportVirtualDeviceChannelMetric(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceObservationReportVirtualDeviceChannelMetric(jsn));
end;

function TFHIRJsonParser.ParseDeviceObservationReportVirtualDeviceChannelMetric(jsn : TJsonObject) : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetric.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('observation') then
        result.observation := ParseReference{TFhirObservation}(jsn.vObj['observation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceObservationReportVirtualDeviceChannelMetric(json : TJSONWriter; name : string; elem : TFhirDeviceObservationReportVirtualDeviceChannelMetric);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirObservation}(json, 'observation', elem.observation); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseDeviceObservationReport(element : IXmlDomElement; path : string) : TFhirDeviceObservationReport;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceObservationReport.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'instant') then
        result.instantObject := ParseInstant(child, path+'/instant') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'source') then
        result.source := ParseReference{TFhirDevice}(child, path+'/source') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'virtualDevice') then
        result.virtualDeviceList.Add(ParseDeviceObservationReportVirtualDevice(child, path+'/virtualDevice')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceObservationReport(xml : TXmlBuilder; name : string; elem : TFhirDeviceObservationReport);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeInstant(xml, 'instant', elem.instantObject);{x.2}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeReference{TFhirDevice}(xml, 'source', elem.source);{x.2}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  for i := 0 to elem.virtualDeviceList.Count - 1 do
    ComposeDeviceObservationReportVirtualDevice(xml, 'virtualDevice', elem.virtualDeviceList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceObservationReport(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceObservationReport(jsn));
end;

function TFHIRJsonParser.ParseDeviceObservationReport(jsn : TJsonObject) : TFhirDeviceObservationReport;
begin
  result := TFhirDeviceObservationReport.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('instant') or jsn.has('_instant') then
        result.instantObject := ParseInstant(jsn['instant'], jsn.vObj['_instant']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('source') then
        result.source := ParseReference{TFhirDevice}(jsn.vObj['source']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('virtualDevice') then
      iterateArray(jsn.vArr['virtualDevice'], result.virtualDeviceList, parseDeviceObservationReportVirtualDevice);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceObservationReport(json : TJSONWriter; name : string; elem : TFhirDeviceObservationReport);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeInstantValue(json, 'instant', elem.instantObject, false);
  ComposeInstantProps(json, 'instant', elem.instantObject, false);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeReference{TFhirDevice}(json, 'source', elem.source); {a}
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if elem.virtualDeviceList.Count > 0 then
  begin
    json.valueArray('virtualDevice');
    for i := 0 to elem.virtualDeviceList.Count - 1 do
      ComposeDeviceObservationReportVirtualDevice(json, '',elem.virtualDeviceList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseDiagnosticOrderEvent(element : IXmlDomElement; path : string) : TFhirDiagnosticOrderEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirDiagnosticOrderStatus, path+'/status', child){1a}
      else if (child.baseName = 'description') then
        result.description := ParseCodeableConcept(child, path+'/description') {b}
      else if (child.baseName = 'dateTime') then
        result.dateTimeObject := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.baseName = 'actor') then
        result.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrderEvent(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderEvent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirDiagnosticOrderStatus);
  ComposeCodeableConcept(xml, 'description', elem.description);{x.2}
  ComposeDateTime(xml, 'dateTime', elem.dateTimeObject);{x.2}
  ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticOrderEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticOrderEvent(jsn));
end;

function TFHIRJsonParser.ParseDiagnosticOrderEvent(jsn : TJsonObject) : TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticOrderStatus);
    if jsn.has('description') then
        result.description := ParseCodeableConcept(jsn.vObj['description']);{q}
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeObject := ParseDateTime(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('actor') then
        result.actor := ParseReference{Resource}(jsn.vObj['actor']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticOrderEvent(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderEvent);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirDiagnosticOrderStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirDiagnosticOrderStatus, false);
  ComposeCodeableConcept(json, 'description', elem.description); {a}
  ComposeDateTimeValue(json, 'dateTime', elem.dateTimeObject, false);
  ComposeDateTimeProps(json, 'dateTime', elem.dateTimeObject, false);
  ComposeReference{Resource}(json, 'actor', elem.actor); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseDiagnosticOrderItem(element : IXmlDomElement; path : string) : TFhirDiagnosticOrderItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'specimen') then
        result.specimenList.Add(ParseReference{TFhirSpecimen}(child, path+'/specimen')){y.2}
      else if (child.baseName = 'bodySite') then
        result.bodySite := ParseCodeableConcept(child, path+'/bodySite') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirDiagnosticOrderStatus, path+'/status', child){1a}
      else if (child.baseName = 'event') then
        result.eventList.Add(ParseDiagnosticOrderEvent(child, path+'/event')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrderItem(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderItem);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  for i := 0 to elem.specimenList.Count - 1 do
    ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimenList[i]);
  ComposeCodeableConcept(xml, 'bodySite', elem.bodySite);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirDiagnosticOrderStatus);
  for i := 0 to elem.eventList.Count - 1 do
    ComposeDiagnosticOrderEvent(xml, 'event', elem.eventList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticOrderItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticOrderItem(jsn));
end;

function TFHIRJsonParser.ParseDiagnosticOrderItem(jsn : TJsonObject) : TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseReference{TFhirSpecimen});
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticOrderStatus);
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseDiagnosticOrderEvent);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticOrderItem(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderItem);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if elem.specimenList.Count > 0 then
  begin
    json.valueArray('specimen');
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '',elem.specimenList[i]); {z - Reference(Specimen)}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirDiagnosticOrderStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirDiagnosticOrderStatus, false);
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(json, '',elem.eventList[i]); {z - @DiagnosticOrder.event}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseDiagnosticOrder(element : IXmlDomElement; path : string) : TFhirDiagnosticOrder;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticOrder.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'orderer') then
        result.orderer := ParseReference{TFhirPractitioner}(child, path+'/orderer') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'clinicalNotes') then
        result.clinicalNotesObject := ParseString(child, path+'/clinicalNotes') {b}
      else if (child.baseName = 'supportingInformation') then
        result.supportingInformationList.Add(ParseReference{Resource}(child, path+'/supportingInformation')){y.2}
      else if (child.baseName = 'specimen') then
        result.specimenList.Add(ParseReference{TFhirSpecimen}(child, path+'/specimen')){y.2}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirDiagnosticOrderStatus, path+'/status', child){1a}
      else if (child.baseName = 'priority') then
        result.priorityObject := ParseEnum(CODES_TFhirDiagnosticOrderPriority, path+'/priority', child){1a}
      else if (child.baseName = 'event') then
        result.eventList.Add(ParseDiagnosticOrderEvent(child, path+'/event')){y.2}
      else if (child.baseName = 'item') then
        result.itemList.Add(ParseDiagnosticOrderItem(child, path+'/item')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrder(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrder);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'orderer', elem.orderer);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  ComposeString(xml, 'clinicalNotes', elem.clinicalNotesObject);{x.2}
  for i := 0 to elem.supportingInformationList.Count - 1 do
    ComposeReference{Resource}(xml, 'supportingInformation', elem.supportingInformationList[i]);
  for i := 0 to elem.specimenList.Count - 1 do
    ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimenList[i]);
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirDiagnosticOrderStatus);
  ComposeEnum(xml, 'priority', elem.PriorityObject, CODES_TFhirDiagnosticOrderPriority);
  for i := 0 to elem.eventList.Count - 1 do
    ComposeDiagnosticOrderEvent(xml, 'event', elem.eventList[i]);
  for i := 0 to elem.itemList.Count - 1 do
    ComposeDiagnosticOrderItem(xml, 'item', elem.itemList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticOrder(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticOrder(jsn));
end;

function TFHIRJsonParser.ParseDiagnosticOrder(jsn : TJsonObject) : TFhirDiagnosticOrder;
begin
  result := TFhirDiagnosticOrder.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('orderer') then
        result.orderer := ParseReference{TFhirPractitioner}(jsn.vObj['orderer']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('clinicalNotes') or jsn.has('_clinicalNotes') then
        result.clinicalNotesObject := ParseString(jsn['clinicalNotes'], jsn.vObj['_clinicalNotes']);{q}
    if jsn.has('supportingInformation') then
      iterateArray(jsn.vArr['supportingInformation'], result.supportingInformationList, parseReference{Resource});
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseReference{TFhirSpecimen});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticOrderStatus);
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityObject := parseEnum(jsn['priority'], jsn.vObj['_priority'], CODES_TFhirDiagnosticOrderPriority);
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseDiagnosticOrderEvent);
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseDiagnosticOrderItem);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticOrder(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrder);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeReference{TFhirPractitioner}(json, 'orderer', elem.orderer); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeStringValue(json, 'clinicalNotes', elem.clinicalNotesObject, false);
  ComposeStringProps(json, 'clinicalNotes', elem.clinicalNotesObject, false);
  if elem.supportingInformationList.Count > 0 then
  begin
    json.valueArray('supportingInformation');
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.supportingInformationList[i]); {z - Reference(Observation|Condition)}
    json.FinishArray;
  end;
  if elem.specimenList.Count > 0 then
  begin
    json.valueArray('specimen');
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '',elem.specimenList[i]); {z - Reference(Specimen)}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirDiagnosticOrderStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirDiagnosticOrderStatus, false);
  ComposeEnumValue(json, 'priority', elem.PriorityObject, CODES_TFhirDiagnosticOrderPriority, false);
  ComposeEnumProps(json, 'priority', elem.PriorityObject, CODES_TFhirDiagnosticOrderPriority, false);
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(json, '',elem.eventList[i]); {z - }
    json.FinishArray;
  end;
  if elem.itemList.Count > 0 then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeDiagnosticOrderItem(json, '',elem.itemList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseDiagnosticReportImage(element : IXmlDomElement; path : string) : TFhirDiagnosticReportImage;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'comment') then
        result.commentObject := ParseString(child, path+'/comment') {b}
      else if (child.baseName = 'link') then
        result.link_ := ParseReference{TFhirMedia}(child, path+'/link') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReportImage(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReportImage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'comment', elem.commentObject);{x.2}
  ComposeReference{TFhirMedia}(xml, 'link', elem.link_);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticReportImage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticReportImage(jsn));
end;

function TFHIRJsonParser.ParseDiagnosticReportImage(jsn : TJsonObject) : TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentObject := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('link') then
        result.link_ := ParseReference{TFhirMedia}(jsn.vObj['link']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticReportImage(json : TJSONWriter; name : string; elem : TFhirDiagnosticReportImage);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'comment', elem.commentObject, false);
  ComposeStringProps(json, 'comment', elem.commentObject, false);
  ComposeReference{TFhirMedia}(json, 'link', elem.link_); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseDiagnosticReport(element : IXmlDomElement; path : string) : TFhirDiagnosticReport;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticReport.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseCodeableConcept(child, path+'/name') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirDiagnosticReportStatus, path+'/status', child){1a}
      else if (child.baseName = 'issued') then
        result.issuedObject := ParseDateTime(child, path+'/issued') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'performer') then
        result.performer := ParseReference{Resource}(child, path+'/performer') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'requestDetail') then
        result.requestDetailList.Add(ParseReference{TFhirDiagnosticOrder}(child, path+'/requestDetail')){y.2}
      else if (child.baseName = 'serviceCategory') then
        result.serviceCategory := ParseCodeableConcept(child, path+'/serviceCategory') {b}
      else if (child.baseName = 'diagnosticDateTime') then
        result.diagnostic := ParseDateTime(child, path+'/diagnosticDateTime'){x.3}
      else if (child.baseName = 'diagnosticPeriod') then
        result.diagnostic := ParsePeriod(child, path+'/diagnosticPeriod'){x.3}
      else if (child.baseName = 'specimen') then
        result.specimenList.Add(ParseReference{TFhirSpecimen}(child, path+'/specimen')){y.2}
      else if (child.baseName = 'result') then
        result.resultList.Add(ParseReference{TFhirObservation}(child, path+'/result')){y.2}
      else if (child.baseName = 'imagingStudy') then
        result.imagingStudyList.Add(ParseReference{TFhirImagingStudy}(child, path+'/imagingStudy')){y.2}
      else if (child.baseName = 'image') then
        result.imageList.Add(ParseDiagnosticReportImage(child, path+'/image')){y.2}
      else if (child.baseName = 'conclusion') then
        result.conclusionObject := ParseString(child, path+'/conclusion') {b}
      else if (child.baseName = 'codedDiagnosis') then
        result.codedDiagnosisList.Add(ParseCodeableConcept(child, path+'/codedDiagnosis')){y.2}
      else if (child.baseName = 'presentedForm') then
        result.presentedFormList.Add(ParseAttachment(child, path+'/presentedForm')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReport(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReport);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  if not SummaryOnly then
    ComposeCodeableConcept(xml, 'name', elem.name);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirDiagnosticReportStatus);
  ComposeDateTime(xml, 'issued', elem.issuedObject);{x.2}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{Resource}(xml, 'performer', elem.performer);{x.2}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.requestDetailList.Count - 1 do
      ComposeReference{TFhirDiagnosticOrder}(xml, 'requestDetail', elem.requestDetailList[i]);
  ComposeCodeableConcept(xml, 'serviceCategory', elem.serviceCategory);{x.2}
  if (elem.diagnostic is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'diagnosticDateTime', TFhirDateTime(elem.diagnostic))
  else if (elem.diagnostic is TFhirPeriod) {6} then
    ComposePeriod(xml, 'diagnosticPeriod', TFhirPeriod(elem.diagnostic));
  if not SummaryOnly then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimenList[i]);
  if not SummaryOnly then
    for i := 0 to elem.resultList.Count - 1 do
      ComposeReference{TFhirObservation}(xml, 'result', elem.resultList[i]);
  if not SummaryOnly then
    for i := 0 to elem.imagingStudyList.Count - 1 do
      ComposeReference{TFhirImagingStudy}(xml, 'imagingStudy', elem.imagingStudyList[i]);
  for i := 0 to elem.imageList.Count - 1 do
    ComposeDiagnosticReportImage(xml, 'image', elem.imageList[i]);
  if not SummaryOnly then
    ComposeString(xml, 'conclusion', elem.conclusionObject);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.codedDiagnosisList.Count - 1 do
      ComposeCodeableConcept(xml, 'codedDiagnosis', elem.codedDiagnosisList[i]);
  if not SummaryOnly then
    for i := 0 to elem.presentedFormList.Count - 1 do
      ComposeAttachment(xml, 'presentedForm', elem.presentedFormList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticReport(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticReport(jsn));
end;

function TFHIRJsonParser.ParseDiagnosticReport(jsn : TJsonObject) : TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('name') then
        result.name := ParseCodeableConcept(jsn.vObj['name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticReportStatus);
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedObject := ParseDateTime(jsn['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('performer') then
        result.performer := ParseReference{Resource}(jsn.vObj['performer']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('requestDetail') then
      iterateArray(jsn.vArr['requestDetail'], result.requestDetailList, parseReference{TFhirDiagnosticOrder});
    if jsn.has('serviceCategory') then
        result.serviceCategory := ParseCodeableConcept(jsn.vObj['serviceCategory']);{q}
    if jsn.has('diagnosticDateTime') or jsn.has('_diagnosticDateTime') then
      result.diagnostic := parseDateTime(jsn['diagnosticDateTime'], jsn.vObj['_diagnosticDateTime']);
    if jsn.has('diagnosticPeriod') {a4} then
      result.diagnostic := ParsePeriod(jsn.vObj['diagnosticPeriod']);
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseReference{TFhirSpecimen});
    if jsn.has('result') then
      iterateArray(jsn.vArr['result'], result.resultList, parseReference{TFhirObservation});
    if jsn.has('imagingStudy') then
      iterateArray(jsn.vArr['imagingStudy'], result.imagingStudyList, parseReference{TFhirImagingStudy});
    if jsn.has('image') then
      iterateArray(jsn.vArr['image'], result.imageList, parseDiagnosticReportImage);
    if jsn.has('conclusion') or jsn.has('_conclusion') then
        result.conclusionObject := ParseString(jsn['conclusion'], jsn.vObj['_conclusion']);{q}
    if jsn.has('codedDiagnosis') then
      iterateArray(jsn.vArr['codedDiagnosis'], result.codedDiagnosisList, parseCodeableConcept);
    if jsn.has('presentedForm') then
      iterateArray(jsn.vArr['presentedForm'], result.presentedFormList, parseAttachment);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticReport(json : TJSONWriter; name : string; elem : TFhirDiagnosticReport);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if not SummaryOnly then
    ComposeCodeableConcept(json, 'name', elem.name); {a}
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirDiagnosticReportStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirDiagnosticReportStatus, false);
  ComposeDateTimeValue(json, 'issued', elem.issuedObject, false);
  ComposeDateTimeProps(json, 'issued', elem.issuedObject, false);
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeReference{Resource}(json, 'performer', elem.performer); {a}
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if not SummaryOnly and (elem.requestDetailList.Count > 0) then
  begin
    json.valueArray('requestDetail');
    for i := 0 to elem.requestDetailList.Count - 1 do
      ComposeReference{TFhirDiagnosticOrder}(json, '',elem.requestDetailList[i]); {z - Reference(DiagnosticOrder)}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'serviceCategory', elem.serviceCategory); {a}
  if (elem.diagnostic is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'diagnosticDateTime', TFhirDateTime(elem.diagnostic), false);
    ComposeDateTimeProps(json, 'diagnosticDateTime', TFhirDateTime(elem.diagnostic), false);
  end
  else if (elem.diagnostic is TFhirPeriod) then 
    ComposePeriod(json, 'diagnosticPeriod', TFhirPeriod(elem.diagnostic)) ;
  if not SummaryOnly and (elem.specimenList.Count > 0) then
  begin
    json.valueArray('specimen');
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '',elem.specimenList[i]); {z - Reference(Specimen)}
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.resultList.Count > 0) then
  begin
    json.valueArray('result');
    for i := 0 to elem.resultList.Count - 1 do
      ComposeReference{TFhirObservation}(json, '',elem.resultList[i]); {z - Reference(Observation)}
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.imagingStudyList.Count > 0) then
  begin
    json.valueArray('imagingStudy');
    for i := 0 to elem.imagingStudyList.Count - 1 do
      ComposeReference{TFhirImagingStudy}(json, '',elem.imagingStudyList[i]); {z - Reference(ImagingStudy)}
    json.FinishArray;
  end;
  if elem.imageList.Count > 0 then
  begin
    json.valueArray('image');
    for i := 0 to elem.imageList.Count - 1 do
      ComposeDiagnosticReportImage(json, '',elem.imageList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly then
    ComposeStringValue(json, 'conclusion', elem.conclusionObject, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'conclusion', elem.conclusionObject, false);
  if not SummaryOnly and (elem.codedDiagnosisList.Count > 0) then
  begin
    json.valueArray('codedDiagnosis');
    for i := 0 to elem.codedDiagnosisList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.codedDiagnosisList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.presentedFormList.Count > 0) then
  begin
    json.valueArray('presentedForm');
    for i := 0 to elem.presentedFormList.Count - 1 do
      ComposeAttachment(json, '',elem.presentedFormList[i]); {z - Attachment}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseDocumentManifest(element : IXmlDomElement; path : string) : TFhirDocumentManifest;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentManifest.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(child, path+'/masterIdentifier') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subjectList.Add(ParseReference{Resource}(child, path+'/subject')){y.2}
      else if (child.baseName = 'recipient') then
        result.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'author') then
        result.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.baseName = 'created') then
        result.createdObject := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'source') then
        result.sourceObject := ParseUri(child, path+'/source') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirDocumentReferenceStatus, path+'/status', child){1a}
      else if (child.baseName = 'supercedes') then
        result.supercedes := ParseReference{TFhirDocumentManifest}(child, path+'/supercedes') {b}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'confidentiality') then
        result.confidentiality := ParseCodeableConcept(child, path+'/confidentiality') {b}
      else if (child.baseName = 'content') then
        result.contentList.Add(ParseReference{Resource}(child, path+'/content')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifest(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'masterIdentifier', elem.masterIdentifier);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  for i := 0 to elem.subjectList.Count - 1 do
    ComposeReference{Resource}(xml, 'subject', elem.subjectList[i]);
  for i := 0 to elem.recipientList.Count - 1 do
    ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  for i := 0 to elem.authorList.Count - 1 do
    ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  ComposeDateTime(xml, 'created', elem.createdObject);{x.2}
  ComposeUri(xml, 'source', elem.sourceObject);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirDocumentReferenceStatus);
  ComposeReference{TFhirDocumentManifest}(xml, 'supercedes', elem.supercedes);{x.2}
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  ComposeCodeableConcept(xml, 'confidentiality', elem.confidentiality);{x.2}
  for i := 0 to elem.contentList.Count - 1 do
    ComposeReference{Resource}(xml, 'content', elem.contentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentManifest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentManifest(jsn));
end;

function TFHIRJsonParser.ParseDocumentManifest(jsn : TJsonObject) : TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(jsn.vObj['masterIdentifier']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
      iterateArray(jsn.vArr['subject'], result.subjectList, parseReference{Resource});
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{Resource});
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{Resource});
    if jsn.has('created') or jsn.has('_created') then
        result.createdObject := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('source') or jsn.has('_source') then
        result.sourceObject := ParseUri(jsn['source'], jsn.vObj['_source']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDocumentReferenceStatus);
    if jsn.has('supercedes') then
        result.supercedes := ParseReference{TFhirDocumentManifest}(jsn.vObj['supercedes']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('confidentiality') then
        result.confidentiality := ParseCodeableConcept(jsn.vObj['confidentiality']);{q}
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentManifest(json : TJSONWriter; name : string; elem : TFhirDocumentManifest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeIdentifier(json, 'masterIdentifier', elem.masterIdentifier); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if elem.subjectList.Count > 0 then
  begin
    json.valueArray('subject');
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.subjectList[i]); {z - Reference(Patient|Practitioner|Group|Device)}
    json.FinishArray;
  end;
  if elem.recipientList.Count > 0 then
  begin
    json.valueArray('recipient');
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.recipientList[i]); {z - Reference(Patient|Practitioner|Organization)}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.authorList.Count > 0 then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.authorList[i]); {z - Reference(Practitioner|Device|Patient|RelatedPerson)}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'created', elem.createdObject, false);
  ComposeDateTimeProps(json, 'created', elem.createdObject, false);
  ComposeUriValue(json, 'source', elem.sourceObject, false);
  ComposeUriProps(json, 'source', elem.sourceObject, false);
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirDocumentReferenceStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirDocumentReferenceStatus, false);
  ComposeReference{TFhirDocumentManifest}(json, 'supercedes', elem.supercedes); {a}
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  ComposeCodeableConcept(json, 'confidentiality', elem.confidentiality); {a}
  if elem.contentList.Count > 0 then
  begin
    json.valueArray('content');
    for i := 0 to elem.contentList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.contentList[i]); {z - Reference(DocumentReference|Binary|Media)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceRelatesTo(element : IXmlDomElement; path : string) : TFhirDocumentReferenceRelatesTo;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeObject := ParseEnum(CODES_TFhirDocumentRelationshipType, path+'/code', child){1a}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirDocumentReference}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceRelatesTo(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceRelatesTo);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.CodeObject, CODES_TFhirDocumentRelationshipType);
  ComposeReference{TFhirDocumentReference}(xml, 'target', elem.target);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceRelatesTo(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceRelatesTo(jsn));
end;

function TFHIRJsonParser.ParseDocumentReferenceRelatesTo(jsn : TJsonObject) : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeObject := parseEnum(jsn['code'], jsn.vObj['_code'], CODES_TFhirDocumentRelationshipType);
    if jsn.has('target') then
        result.target := ParseReference{TFhirDocumentReference}(jsn.vObj['target']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceRelatesTo(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceRelatesTo);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.CodeObject, CODES_TFhirDocumentRelationshipType, false);
  ComposeEnumProps(json, 'code', elem.CodeObject, CODES_TFhirDocumentRelationshipType, false);
  ComposeReference{TFhirDocumentReference}(json, 'target', elem.target); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseDocumentReferenceService(element : IXmlDomElement; path : string) : TFhirDocumentReferenceService;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReferenceService.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'address') then
        result.addressObject := ParseString(child, path+'/address') {b}
      else if (child.baseName = 'parameter') then
        result.parameterList.Add(ParseDocumentReferenceServiceParameter(child, path+'/parameter')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceService(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceService);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeString(xml, 'address', elem.addressObject);{x.2}
  for i := 0 to elem.parameterList.Count - 1 do
    ComposeDocumentReferenceServiceParameter(xml, 'parameter', elem.parameterList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceService(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceService(jsn));
end;

function TFHIRJsonParser.ParseDocumentReferenceService(jsn : TJsonObject) : TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('address') or jsn.has('_address') then
        result.addressObject := ParseString(jsn['address'], jsn.vObj['_address']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseDocumentReferenceServiceParameter);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceService(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceService);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeStringValue(json, 'address', elem.addressObject, false);
  ComposeStringProps(json, 'address', elem.addressObject, false);
  if elem.parameterList.Count > 0 then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeDocumentReferenceServiceParameter(json, '',elem.parameterList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseDocumentReferenceServiceParameter(element : IXmlDomElement; path : string) : TFhirDocumentReferenceServiceParameter;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReferenceServiceParameter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'value') then
        result.valueObject := ParseString(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceServiceParameter(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceServiceParameter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeString(xml, 'value', elem.valueObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceServiceParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceServiceParameter(jsn));
end;

function TFHIRJsonParser.ParseDocumentReferenceServiceParameter(jsn : TJsonObject) : TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueObject := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceServiceParameter(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceServiceParameter);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeStringValue(json, 'value', elem.valueObject, false);
  ComposeStringProps(json, 'value', elem.valueObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseDocumentReferenceContext(element : IXmlDomElement; path : string) : TFhirDocumentReferenceContext;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'event') then
        result.eventList.Add(ParseCodeableConcept(child, path+'/event')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'facilityType') then
        result.facilityType := ParseCodeableConcept(child, path+'/facilityType') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContext(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContext);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.eventList.Count - 1 do
    ComposeCodeableConcept(xml, 'event', elem.eventList[i]);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  ComposeCodeableConcept(xml, 'facilityType', elem.facilityType);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceContext(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceContext(jsn));
end;

function TFHIRJsonParser.ParseDocumentReferenceContext(jsn : TJsonObject) : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('facilityType') then
        result.facilityType := ParseCodeableConcept(jsn.vObj['facilityType']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceContext(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContext);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.eventList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeCodeableConcept(json, 'facilityType', elem.facilityType); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseDocumentReference(element : IXmlDomElement; path : string) : TFhirDocumentReference;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReference.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(child, path+'/masterIdentifier') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'class') then
        result.class_ := ParseCodeableConcept(child, path+'/class') {b}
      else if (child.baseName = 'author') then
        result.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.baseName = 'custodian') then
        result.custodian := ParseReference{TFhirOrganization}(child, path+'/custodian') {b}
      else if (child.baseName = 'policyManager') then
        result.policyManagerObject := ParseUri(child, path+'/policyManager') {b}
      else if (child.baseName = 'authenticator') then
        result.authenticator := ParseReference{Resource}(child, path+'/authenticator') {b}
      else if (child.baseName = 'created') then
        result.createdObject := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'indexed') then
        result.indexedObject := ParseInstant(child, path+'/indexed') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirDocumentReferenceStatus, path+'/status', child){1a}
      else if (child.baseName = 'docStatus') then
        result.docStatus := ParseCodeableConcept(child, path+'/docStatus') {b}
      else if (child.baseName = 'relatesTo') then
        result.relatesToList.Add(ParseDocumentReferenceRelatesTo(child, path+'/relatesTo')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'confidentiality') then
        result.confidentialityList.Add(ParseCodeableConcept(child, path+'/confidentiality')){y.2}
      else if (child.baseName = 'primaryLanguage') then
        result.primaryLanguageObject := ParseCode(child, path+'/primaryLanguage') {b}
      else if (child.baseName = 'mimeType') then
        result.mimeTypeObject := ParseCode(child, path+'/mimeType') {b}
      else if (child.baseName = 'format') then
        result.formatList.Add(ParseUri(child, path+'/format')){y.2}
      else if (child.baseName = 'size') then
        result.sizeObject := ParseInteger(child, path+'/size') {b}
      else if (child.baseName = 'hash') then
        result.hashObject := ParseString(child, path+'/hash') {b}
      else if (child.baseName = 'location') then
        result.locationObject := ParseUri(child, path+'/location') {b}
      else if (child.baseName = 'service') then
        result.service := ParseDocumentReferenceService(child, path+'/service') {b}
      else if (child.baseName = 'context') then
        result.context := ParseDocumentReferenceContext(child, path+'/context') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReference(xml : TXmlBuilder; name : string; elem : TFhirDocumentReference);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'masterIdentifier', elem.masterIdentifier);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeCodeableConcept(xml, 'class', elem.class_);{x.2}
  for i := 0 to elem.authorList.Count - 1 do
    ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  ComposeReference{TFhirOrganization}(xml, 'custodian', elem.custodian);{x.2}
  ComposeUri(xml, 'policyManager', elem.policyManagerObject);{x.2}
  ComposeReference{Resource}(xml, 'authenticator', elem.authenticator);{x.2}
  ComposeDateTime(xml, 'created', elem.createdObject);{x.2}
  ComposeInstant(xml, 'indexed', elem.indexedObject);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirDocumentReferenceStatus);
  ComposeCodeableConcept(xml, 'docStatus', elem.docStatus);{x.2}
  for i := 0 to elem.relatesToList.Count - 1 do
    ComposeDocumentReferenceRelatesTo(xml, 'relatesTo', elem.relatesToList[i]);
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  for i := 0 to elem.confidentialityList.Count - 1 do
    ComposeCodeableConcept(xml, 'confidentiality', elem.confidentialityList[i]);
  ComposeCode(xml, 'primaryLanguage', elem.primaryLanguageObject);{x.2}
  ComposeCode(xml, 'mimeType', elem.mimeTypeObject);{x.2}
  for i := 0 to elem.formatList.Count - 1 do
    ComposeUri(xml, 'format', elem.formatList[i]);
  ComposeInteger(xml, 'size', elem.sizeObject);{x.2}
  ComposeString(xml, 'hash', elem.hashObject);{x.2}
  ComposeUri(xml, 'location', elem.locationObject);{x.2}
  ComposeDocumentReferenceService(xml, 'service', elem.service);{x.2}
  ComposeDocumentReferenceContext(xml, 'context', elem.context);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReference(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReference(jsn));
end;

function TFHIRJsonParser.ParseDocumentReference(jsn : TJsonObject) : TFhirDocumentReference;
begin
  result := TFhirDocumentReference.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(jsn.vObj['masterIdentifier']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('class') then
        result.class_ := ParseCodeableConcept(jsn.vObj['class']);{q}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{Resource});
    if jsn.has('custodian') then
        result.custodian := ParseReference{TFhirOrganization}(jsn.vObj['custodian']);{q}
    if jsn.has('policyManager') or jsn.has('_policyManager') then
        result.policyManagerObject := ParseUri(jsn['policyManager'], jsn.vObj['_policyManager']);{q}
    if jsn.has('authenticator') then
        result.authenticator := ParseReference{Resource}(jsn.vObj['authenticator']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdObject := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('indexed') or jsn.has('_indexed') then
        result.indexedObject := ParseInstant(jsn['indexed'], jsn.vObj['_indexed']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDocumentReferenceStatus);
    if jsn.has('docStatus') then
        result.docStatus := ParseCodeableConcept(jsn.vObj['docStatus']);{q}
    if jsn.has('relatesTo') then
      iterateArray(jsn.vArr['relatesTo'], result.relatesToList, parseDocumentReferenceRelatesTo);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('confidentiality') then
      iterateArray(jsn.vArr['confidentiality'], result.confidentialityList, parseCodeableConcept);
    if jsn.has('primaryLanguage') or jsn.has('_primaryLanguage') then
        result.primaryLanguageObject := ParseCode(jsn['primaryLanguage'], jsn.vObj['_primaryLanguage']);{q}
    if jsn.has('mimeType') or jsn.has('_mimeType') then
        result.mimeTypeObject := ParseCode(jsn['mimeType'], jsn.vObj['_mimeType']);{q}
      if jsn.has('format') or jsn.has('_format') then
      iteratePrimitiveArray(jsn.vArr['format'], jsn.vArr['_format'], result.formatList, parseUri);
    if jsn.has('size') or jsn.has('_size') then
        result.sizeObject := ParseInteger(jsn['size'], jsn.vObj['_size']);{q}
    if jsn.has('hash') or jsn.has('_hash') then
        result.hashObject := ParseString(jsn['hash'], jsn.vObj['_hash']);{q}
    if jsn.has('location') or jsn.has('_location') then
        result.locationObject := ParseUri(jsn['location'], jsn.vObj['_location']);{q}
    if jsn.has('service') then
        result.service := ParseDocumentReferenceService(jsn.vObj['service']);{q}
    if jsn.has('context') then
        result.context := ParseDocumentReferenceContext(jsn.vObj['context']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReference(json : TJSONWriter; name : string; elem : TFhirDocumentReference);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeIdentifier(json, 'masterIdentifier', elem.masterIdentifier); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeCodeableConcept(json, 'class', elem.class_); {a}
  if elem.authorList.Count > 0 then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.authorList[i]); {z - Reference(Practitioner|Device|Patient|RelatedPerson)}
    json.FinishArray;
  end;
  ComposeReference{TFhirOrganization}(json, 'custodian', elem.custodian); {a}
  ComposeUriValue(json, 'policyManager', elem.policyManagerObject, false);
  ComposeUriProps(json, 'policyManager', elem.policyManagerObject, false);
  ComposeReference{Resource}(json, 'authenticator', elem.authenticator); {a}
  ComposeDateTimeValue(json, 'created', elem.createdObject, false);
  ComposeDateTimeProps(json, 'created', elem.createdObject, false);
  ComposeInstantValue(json, 'indexed', elem.indexedObject, false);
  ComposeInstantProps(json, 'indexed', elem.indexedObject, false);
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirDocumentReferenceStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirDocumentReferenceStatus, false);
  ComposeCodeableConcept(json, 'docStatus', elem.docStatus); {a}
  if elem.relatesToList.Count > 0 then
  begin
    json.valueArray('relatesTo');
    for i := 0 to elem.relatesToList.Count - 1 do
      ComposeDocumentReferenceRelatesTo(json, '',elem.relatesToList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  if elem.confidentialityList.Count > 0 then
  begin
    json.valueArray('confidentiality');
    for i := 0 to elem.confidentialityList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.confidentialityList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeCodeValue(json, 'primaryLanguage', elem.primaryLanguageObject, false);
  ComposeCodeProps(json, 'primaryLanguage', elem.primaryLanguageObject, false);
  ComposeCodeValue(json, 'mimeType', elem.mimeTypeObject, false);
  ComposeCodeProps(json, 'mimeType', elem.mimeTypeObject, false);
  if elem.formatList.Count > 0 then
  begin
    json.valueArray('format');
    ext := false;
    for i := 0 to elem.formatList.Count - 1 do
    begin
      ext := ext or ((elem.formatList[i].xmlid <> '') or (elem.formatList[i].hasExtensions));
      ComposeUriValue(json, '',elem.formatList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_format');
      for i := 0 to elem.formatList.Count - 1 do
        ComposeUriProps(json, '',elem.formatList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeIntegerValue(json, 'size', elem.sizeObject, false);
  ComposeIntegerProps(json, 'size', elem.sizeObject, false);
  ComposeStringValue(json, 'hash', elem.hashObject, false);
  ComposeStringProps(json, 'hash', elem.hashObject, false);
  ComposeUriValue(json, 'location', elem.locationObject, false);
  ComposeUriProps(json, 'location', elem.locationObject, false);
  ComposeDocumentReferenceService(json, 'service', elem.service); {a}
  ComposeDocumentReferenceContext(json, 'context', elem.context); {a}
end;

function TFHIRXmlParser.ParseEncounterParticipant(element : IXmlDomElement; path : string) : TFhirEncounterParticipant;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounterParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.baseName = 'individual') then
        result.individual := ParseReference{Resource}(child, path+'/individual') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounterParticipant(xml : TXmlBuilder; name : string; elem : TFhirEncounterParticipant);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  ComposeReference{Resource}(xml, 'individual', elem.individual);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounterParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterParticipant(jsn));
end;

function TFHIRJsonParser.ParseEncounterParticipant(jsn : TJsonObject) : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('individual') then
        result.individual := ParseReference{Resource}(jsn.vObj['individual']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounterParticipant(json : TJSONWriter; name : string; elem : TFhirEncounterParticipant);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '',elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeReference{Resource}(json, 'individual', elem.individual); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseEncounterHospitalization(element : IXmlDomElement; path : string) : TFhirEncounterHospitalization;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounterHospitalization.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'preAdmissionIdentifier') then
        result.preAdmissionIdentifier := ParseIdentifier(child, path+'/preAdmissionIdentifier') {b}
      else if (child.baseName = 'origin') then
        result.origin := ParseReference{TFhirLocation}(child, path+'/origin') {b}
      else if (child.baseName = 'admitSource') then
        result.admitSource := ParseCodeableConcept(child, path+'/admitSource') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'accomodation') then
        result.accomodationList.Add(ParseEncounterHospitalizationAccomodation(child, path+'/accomodation')){y.2}
      else if (child.baseName = 'diet') then
        result.diet := ParseCodeableConcept(child, path+'/diet') {b}
      else if (child.baseName = 'specialCourtesy') then
        result.specialCourtesyList.Add(ParseCodeableConcept(child, path+'/specialCourtesy')){y.2}
      else if (child.baseName = 'specialArrangement') then
        result.specialArrangementList.Add(ParseCodeableConcept(child, path+'/specialArrangement')){y.2}
      else if (child.baseName = 'destination') then
        result.destination := ParseReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.baseName = 'dischargeDisposition') then
        result.dischargeDisposition := ParseCodeableConcept(child, path+'/dischargeDisposition') {b}
      else if (child.baseName = 'dischargeDiagnosis') then
        result.dischargeDiagnosis := ParseReference{TFhirReference}(child, path+'/dischargeDiagnosis') {b}
      else if (child.baseName = 'reAdmission') then
        result.reAdmissionObject := ParseBoolean(child, path+'/reAdmission') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounterHospitalization(xml : TXmlBuilder; name : string; elem : TFhirEncounterHospitalization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'preAdmissionIdentifier', elem.preAdmissionIdentifier);{x.2}
  ComposeReference{TFhirLocation}(xml, 'origin', elem.origin);{x.2}
  ComposeCodeableConcept(xml, 'admitSource', elem.admitSource);{x.2}
  ComposePeriod(xml, 'period', elem.period);{x.2}
  for i := 0 to elem.accomodationList.Count - 1 do
    ComposeEncounterHospitalizationAccomodation(xml, 'accomodation', elem.accomodationList[i]);
  ComposeCodeableConcept(xml, 'diet', elem.diet);{x.2}
  for i := 0 to elem.specialCourtesyList.Count - 1 do
    ComposeCodeableConcept(xml, 'specialCourtesy', elem.specialCourtesyList[i]);
  for i := 0 to elem.specialArrangementList.Count - 1 do
    ComposeCodeableConcept(xml, 'specialArrangement', elem.specialArrangementList[i]);
  ComposeReference{TFhirLocation}(xml, 'destination', elem.destination);{x.2}
  ComposeCodeableConcept(xml, 'dischargeDisposition', elem.dischargeDisposition);{x.2}
  ComposeReference{TFhirReference}(xml, 'dischargeDiagnosis', elem.dischargeDiagnosis);{x.2}
  ComposeBoolean(xml, 'reAdmission', elem.reAdmissionObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounterHospitalization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterHospitalization(jsn));
end;

function TFHIRJsonParser.ParseEncounterHospitalization(jsn : TJsonObject) : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('preAdmissionIdentifier') then
        result.preAdmissionIdentifier := ParseIdentifier(jsn.vObj['preAdmissionIdentifier']);{q}
    if jsn.has('origin') then
        result.origin := ParseReference{TFhirLocation}(jsn.vObj['origin']);{q}
    if jsn.has('admitSource') then
        result.admitSource := ParseCodeableConcept(jsn.vObj['admitSource']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('accomodation') then
      iterateArray(jsn.vArr['accomodation'], result.accomodationList, parseEncounterHospitalizationAccomodation);
    if jsn.has('diet') then
        result.diet := ParseCodeableConcept(jsn.vObj['diet']);{q}
    if jsn.has('specialCourtesy') then
      iterateArray(jsn.vArr['specialCourtesy'], result.specialCourtesyList, parseCodeableConcept);
    if jsn.has('specialArrangement') then
      iterateArray(jsn.vArr['specialArrangement'], result.specialArrangementList, parseCodeableConcept);
    if jsn.has('destination') then
        result.destination := ParseReference{TFhirLocation}(jsn.vObj['destination']);{q}
    if jsn.has('dischargeDisposition') then
        result.dischargeDisposition := ParseCodeableConcept(jsn.vObj['dischargeDisposition']);{q}
    if jsn.has('dischargeDiagnosis') then
        result.dischargeDiagnosis := ParseReference{TFhirReference}(jsn.vObj['dischargeDiagnosis']);{q}
    if jsn.has('reAdmission') or jsn.has('_reAdmission') then
        result.reAdmissionObject := ParseBoolean(jsn['reAdmission'], jsn.vObj['_reAdmission']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounterHospitalization(json : TJSONWriter; name : string; elem : TFhirEncounterHospitalization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'preAdmissionIdentifier', elem.preAdmissionIdentifier); {a}
  ComposeReference{TFhirLocation}(json, 'origin', elem.origin); {a}
  ComposeCodeableConcept(json, 'admitSource', elem.admitSource); {a}
  ComposePeriod(json, 'period', elem.period); {a}
  if elem.accomodationList.Count > 0 then
  begin
    json.valueArray('accomodation');
    for i := 0 to elem.accomodationList.Count - 1 do
      ComposeEncounterHospitalizationAccomodation(json, '',elem.accomodationList[i]); {z - }
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'diet', elem.diet); {a}
  if elem.specialCourtesyList.Count > 0 then
  begin
    json.valueArray('specialCourtesy');
    for i := 0 to elem.specialCourtesyList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.specialCourtesyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.specialArrangementList.Count > 0 then
  begin
    json.valueArray('specialArrangement');
    for i := 0 to elem.specialArrangementList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.specialArrangementList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  ComposeCodeableConcept(json, 'dischargeDisposition', elem.dischargeDisposition); {a}
  ComposeReference{TFhirReference}(json, 'dischargeDiagnosis', elem.dischargeDiagnosis); {a}
  ComposeBooleanValue(json, 'reAdmission', elem.reAdmissionObject, false);
  ComposeBooleanProps(json, 'reAdmission', elem.reAdmissionObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseEncounterHospitalizationAccomodation(element : IXmlDomElement; path : string) : TFhirEncounterHospitalizationAccomodation;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounterHospitalizationAccomodation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'bed') then
        result.bed := ParseReference{TFhirLocation}(child, path+'/bed') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounterHospitalizationAccomodation(xml : TXmlBuilder; name : string; elem : TFhirEncounterHospitalizationAccomodation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirLocation}(xml, 'bed', elem.bed);{x.2}
  ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounterHospitalizationAccomodation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterHospitalizationAccomodation(jsn));
end;

function TFHIRJsonParser.ParseEncounterHospitalizationAccomodation(jsn : TJsonObject) : TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('bed') then
        result.bed := ParseReference{TFhirLocation}(jsn.vObj['bed']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounterHospitalizationAccomodation(json : TJSONWriter; name : string; elem : TFhirEncounterHospitalizationAccomodation);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirLocation}(json, 'bed', elem.bed); {a}
  ComposePeriod(json, 'period', elem.period); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseEncounterLocation(element : IXmlDomElement; path : string) : TFhirEncounterLocation;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounterLocation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounterLocation(xml : TXmlBuilder; name : string; elem : TFhirEncounterLocation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounterLocation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterLocation(jsn));
end;

function TFHIRJsonParser.ParseEncounterLocation(jsn : TJsonObject) : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounterLocation(json : TJSONWriter; name : string; elem : TFhirEncounterLocation);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  ComposePeriod(json, 'period', elem.period); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseEncounter(element : IXmlDomElement; path : string) : TFhirEncounter;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounter.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirEncounterState, path+'/status', child){1a}
      else if (child.baseName = 'class') then
        result.class_Object := ParseEnum(CODES_TFhirEncounterClass, path+'/class', child){1a}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'participant') then
        result.participantList.Add(ParseEncounterParticipant(child, path+'/participant')){y.2}
      else if (child.baseName = 'fulfills') then
        result.fulfills := ParseReference{TFhirAppointment}(child, path+'/fulfills') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'length') then
        result.length := ParseQuantity(child, path+'/length') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.baseName = 'indication') then
        result.indication := ParseReference{TFhirReference}(child, path+'/indication') {b}
      else if (child.baseName = 'priority') then
        result.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if (child.baseName = 'hospitalization') then
        result.hospitalization := ParseEncounterHospitalization(child, path+'/hospitalization') {b}
      else if (child.baseName = 'location') then
        result.locationList.Add(ParseEncounterLocation(child, path+'/location')){y.2}
      else if (child.baseName = 'serviceProvider') then
        result.serviceProvider := ParseReference{TFhirOrganization}(child, path+'/serviceProvider') {b}
      else if (child.baseName = 'partOf') then
        result.partOf := ParseReference{TFhirEncounter}(child, path+'/partOf') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounter(xml : TXmlBuilder; name : string; elem : TFhirEncounter);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirEncounterState);
  ComposeEnum(xml, 'class', elem.Class_Object, CODES_TFhirEncounterClass);
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  for i := 0 to elem.participantList.Count - 1 do
    ComposeEncounterParticipant(xml, 'participant', elem.participantList[i]);
  ComposeReference{TFhirAppointment}(xml, 'fulfills', elem.fulfills);{x.2}
  if not SummaryOnly then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  if not SummaryOnly then
    ComposeQuantity(xml, 'length', elem.length);{x.2}
  ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2}
  if not SummaryOnly then
    ComposeReference{TFhirReference}(xml, 'indication', elem.indication);{x.2}
  if not SummaryOnly then
    ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2}
  if not SummaryOnly then
    ComposeEncounterHospitalization(xml, 'hospitalization', elem.hospitalization);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeEncounterLocation(xml, 'location', elem.locationList[i]);
  if not SummaryOnly then
    ComposeReference{TFhirOrganization}(xml, 'serviceProvider', elem.serviceProvider);{x.2}
  if not SummaryOnly then
    ComposeReference{TFhirEncounter}(xml, 'partOf', elem.partOf);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounter(jsn));
end;

function TFHIRJsonParser.ParseEncounter(jsn : TJsonObject) : TFhirEncounter;
begin
  result := TFhirEncounter.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirEncounterState);
    if jsn.has('class') or jsn.has('_class')  then
      result.class_Object := parseEnum(jsn['class'], jsn.vObj['_class'], CODES_TFhirEncounterClass);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseEncounterParticipant);
    if jsn.has('fulfills') then
        result.fulfills := ParseReference{TFhirAppointment}(jsn.vObj['fulfills']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('length') then
        result.length := ParseQuantity(jsn.vObj['length']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    if jsn.has('indication') then
        result.indication := ParseReference{TFhirReference}(jsn.vObj['indication']);{q}
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q}
    if jsn.has('hospitalization') then
        result.hospitalization := ParseEncounterHospitalization(jsn.vObj['hospitalization']);{q}
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseEncounterLocation);
    if jsn.has('serviceProvider') then
        result.serviceProvider := ParseReference{TFhirOrganization}(jsn.vObj['serviceProvider']);{q}
    if jsn.has('partOf') then
        result.partOf := ParseReference{TFhirEncounter}(jsn.vObj['partOf']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounter(json : TJSONWriter; name : string; elem : TFhirEncounter);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirEncounterState, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirEncounterState, false);
  ComposeEnumValue(json, 'class', elem.Class_Object, CODES_TFhirEncounterClass, false);
  ComposeEnumProps(json, 'class', elem.Class_Object, CODES_TFhirEncounterClass, false);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '',elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if elem.participantList.Count > 0 then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeEncounterParticipant(json, '',elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  ComposeReference{TFhirAppointment}(json, 'fulfills', elem.fulfills); {a}
  if not SummaryOnly then
    ComposePeriod(json, 'period', elem.period); {a}
  if not SummaryOnly then
    ComposeQuantity(json, 'length', elem.length); {a}
  ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if not SummaryOnly then
    ComposeReference{TFhirReference}(json, 'indication', elem.indication); {a}
  if not SummaryOnly then
    ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  if not SummaryOnly then
    ComposeEncounterHospitalization(json, 'hospitalization', elem.hospitalization); {a}
  if not SummaryOnly and (elem.locationList.Count > 0) then
  begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeEncounterLocation(json, '',elem.locationList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly then
    ComposeReference{TFhirOrganization}(json, 'serviceProvider', elem.serviceProvider); {a}
  if not SummaryOnly then
    ComposeReference{TFhirEncounter}(json, 'partOf', elem.partOf); {a}
end;

function TFHIRXmlParser.ParseFamilyHistoryRelation(element : IXmlDomElement; path : string) : TFhirFamilyHistoryRelation;
var
  child : IXMLDOMElement;
begin
  result := TFhirFamilyHistoryRelation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'relationship') then
        result.relationship := ParseCodeableConcept(child, path+'/relationship') {b}
      else if (child.baseName = 'bornPeriod') then
        result.born := ParsePeriod(child, path+'/bornPeriod'){x.3}
      else if (child.baseName = 'bornDate') then
        result.born := ParseDate(child, path+'/bornDate'){x.3}
      else if (child.baseName = 'bornString') then
        result.born := ParseString(child, path+'/bornString'){x.3}
      else if (child.baseName = 'ageAge') then
        result.age := ParseAge(child, path+'/ageAge'){x.3}
      else if (child.baseName = 'ageRange') then
        result.age := ParseRange(child, path+'/ageRange'){x.3}
      else if (child.baseName = 'ageString') then
        result.age := ParseString(child, path+'/ageString'){x.3}
      else if (child.baseName = 'deceasedBoolean') then
        result.deceased := ParseBoolean(child, path+'/deceasedBoolean'){x.3}
      else if (child.baseName = 'deceasedAge') then
        result.deceased := ParseAge(child, path+'/deceasedAge'){x.3}
      else if (child.baseName = 'deceasedRange') then
        result.deceased := ParseRange(child, path+'/deceasedRange'){x.3}
      else if (child.baseName = 'deceasedDate') then
        result.deceased := ParseDate(child, path+'/deceasedDate'){x.3}
      else if (child.baseName = 'deceasedString') then
        result.deceased := ParseString(child, path+'/deceasedString'){x.3}
      else if (child.baseName = 'note') then
        result.noteObject := ParseString(child, path+'/note') {b}
      else if (child.baseName = 'condition') then
        result.conditionList.Add(ParseFamilyHistoryRelationCondition(child, path+'/condition')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeFamilyHistoryRelation(xml : TXmlBuilder; name : string; elem : TFhirFamilyHistoryRelation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeCodeableConcept(xml, 'relationship', elem.relationship);{x.2}
  if (elem.born is TFhirPeriod) {6} then
    ComposePeriod(xml, 'bornPeriod', TFhirPeriod(elem.born))
  else if (elem.born is TFhirDate) {6} then
    ComposeDate(xml, 'bornDate', TFhirDate(elem.born))
  else if (elem.born is TFhirString) {6} then
    ComposeString(xml, 'bornString', TFhirString(elem.born));
  if (elem.age is TFhirQuantity) {6} then
    ComposeAge(xml, 'ageAge', TFhirQuantity(elem.age))
  else if (elem.age is TFhirRange) {6} then
    ComposeRange(xml, 'ageRange', TFhirRange(elem.age))
  else if (elem.age is TFhirString) {6} then
    ComposeString(xml, 'ageString', TFhirString(elem.age));
  if (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'deceasedBoolean', TFhirBoolean(elem.deceased))
  else if (elem.deceased is TFhirQuantity) {6} then
    ComposeAge(xml, 'deceasedAge', TFhirQuantity(elem.deceased))
  else if (elem.deceased is TFhirRange) {6} then
    ComposeRange(xml, 'deceasedRange', TFhirRange(elem.deceased))
  else if (elem.deceased is TFhirDate) {6} then
    ComposeDate(xml, 'deceasedDate', TFhirDate(elem.deceased))
  else if (elem.deceased is TFhirString) {6} then
    ComposeString(xml, 'deceasedString', TFhirString(elem.deceased));
  ComposeString(xml, 'note', elem.noteObject);{x.2}
  for i := 0 to elem.conditionList.Count - 1 do
    ComposeFamilyHistoryRelationCondition(xml, 'condition', elem.conditionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseFamilyHistoryRelation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFamilyHistoryRelation(jsn));
end;

function TFHIRJsonParser.ParseFamilyHistoryRelation(jsn : TJsonObject) : TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCodeableConcept(jsn.vObj['relationship']);{q}
    if jsn.has('bornPeriod') {a4} then
      result.born := ParsePeriod(jsn.vObj['bornPeriod']);
    if jsn.has('bornDate') or jsn.has('_bornDate') then
      result.born := parseDate(jsn['bornDate'], jsn.vObj['_bornDate']);
    if jsn.has('bornString') or jsn.has('_bornString') then
      result.born := parseString(jsn['bornString'], jsn.vObj['_bornString']);
    if jsn.has('ageAge') {a4} then
      result.age := ParseAge(jsn.vObj['ageAge']);
    if jsn.has('ageRange') {a4} then
      result.age := ParseRange(jsn.vObj['ageRange']);
    if jsn.has('ageString') or jsn.has('_ageString') then
      result.age := parseString(jsn['ageString'], jsn.vObj['_ageString']);
    if jsn.has('deceasedBoolean') or jsn.has('_deceasedBoolean') then
      result.deceased := parseBoolean(jsn['deceasedBoolean'], jsn.vObj['_deceasedBoolean']);
    if jsn.has('deceasedAge') {a4} then
      result.deceased := ParseAge(jsn.vObj['deceasedAge']);
    if jsn.has('deceasedRange') {a4} then
      result.deceased := ParseRange(jsn.vObj['deceasedRange']);
    if jsn.has('deceasedDate') or jsn.has('_deceasedDate') then
      result.deceased := parseDate(jsn['deceasedDate'], jsn.vObj['_deceasedDate']);
    if jsn.has('deceasedString') or jsn.has('_deceasedString') then
      result.deceased := parseString(jsn['deceasedString'], jsn.vObj['_deceasedString']);
    if jsn.has('note') or jsn.has('_note') then
        result.noteObject := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    if jsn.has('condition') then
      iterateArray(jsn.vArr['condition'], result.conditionList, parseFamilyHistoryRelationCondition);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeFamilyHistoryRelation(json : TJSONWriter; name : string; elem : TFhirFamilyHistoryRelation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeCodeableConcept(json, 'relationship', elem.relationship); {a}
  if (elem.born is TFhirPeriod) then 
    ComposePeriod(json, 'bornPeriod', TFhirPeriod(elem.born)) 
  else if (elem.born is TFhirDate) then 
  begin
    ComposeDateValue(json, 'bornDate', TFhirDate(elem.born), false);
    ComposeDateProps(json, 'bornDate', TFhirDate(elem.born), false);
  end
  else if (elem.born is TFhirString) then 
  begin
    ComposeStringValue(json, 'bornString', TFhirString(elem.born), false);
    ComposeStringProps(json, 'bornString', TFhirString(elem.born), false);
  end;
  if (elem.age is TFhirQuantity) then 
    ComposeAge(json, 'ageAge', TFhirQuantity(elem.age)) 
  else if (elem.age is TFhirRange) then 
    ComposeRange(json, 'ageRange', TFhirRange(elem.age)) 
  else if (elem.age is TFhirString) then 
  begin
    ComposeStringValue(json, 'ageString', TFhirString(elem.age), false);
    ComposeStringProps(json, 'ageString', TFhirString(elem.age), false);
  end;
  if (elem.deceased is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
    ComposeBooleanProps(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
  end
  else if (elem.deceased is TFhirQuantity) then 
    ComposeAge(json, 'deceasedAge', TFhirQuantity(elem.deceased)) 
  else if (elem.deceased is TFhirRange) then 
    ComposeRange(json, 'deceasedRange', TFhirRange(elem.deceased)) 
  else if (elem.deceased is TFhirDate) then 
  begin
    ComposeDateValue(json, 'deceasedDate', TFhirDate(elem.deceased), false);
    ComposeDateProps(json, 'deceasedDate', TFhirDate(elem.deceased), false);
  end
  else if (elem.deceased is TFhirString) then 
  begin
    ComposeStringValue(json, 'deceasedString', TFhirString(elem.deceased), false);
    ComposeStringProps(json, 'deceasedString', TFhirString(elem.deceased), false);
  end;
  ComposeStringValue(json, 'note', elem.noteObject, false);
  ComposeStringProps(json, 'note', elem.noteObject, false);
  if elem.conditionList.Count > 0 then
  begin
    json.valueArray('condition');
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeFamilyHistoryRelationCondition(json, '',elem.conditionList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseFamilyHistoryRelationCondition(element : IXmlDomElement; path : string) : TFhirFamilyHistoryRelationCondition;
var
  child : IXMLDOMElement;
begin
  result := TFhirFamilyHistoryRelationCondition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'outcome') then
        result.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.baseName = 'onsetAge') then
        result.onset := ParseAge(child, path+'/onsetAge'){x.3}
      else if (child.baseName = 'onsetRange') then
        result.onset := ParseRange(child, path+'/onsetRange'){x.3}
      else if (child.baseName = 'onsetString') then
        result.onset := ParseString(child, path+'/onsetString'){x.3}
      else if (child.baseName = 'note') then
        result.noteObject := ParseString(child, path+'/note') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeFamilyHistoryRelationCondition(xml : TXmlBuilder; name : string; elem : TFhirFamilyHistoryRelationCondition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2}
  if (elem.onset is TFhirQuantity) {6} then
    ComposeAge(xml, 'onsetAge', TFhirQuantity(elem.onset))
  else if (elem.onset is TFhirRange) {6} then
    ComposeRange(xml, 'onsetRange', TFhirRange(elem.onset))
  else if (elem.onset is TFhirString) {6} then
    ComposeString(xml, 'onsetString', TFhirString(elem.onset));
  ComposeString(xml, 'note', elem.noteObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseFamilyHistoryRelationCondition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFamilyHistoryRelationCondition(jsn));
end;

function TFHIRJsonParser.ParseFamilyHistoryRelationCondition(jsn : TJsonObject) : TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('outcome') then
        result.outcome := ParseCodeableConcept(jsn.vObj['outcome']);{q}
    if jsn.has('onsetAge') {a4} then
      result.onset := ParseAge(jsn.vObj['onsetAge']);
    if jsn.has('onsetRange') {a4} then
      result.onset := ParseRange(jsn.vObj['onsetRange']);
    if jsn.has('onsetString') or jsn.has('_onsetString') then
      result.onset := parseString(jsn['onsetString'], jsn.vObj['_onsetString']);
    if jsn.has('note') or jsn.has('_note') then
        result.noteObject := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeFamilyHistoryRelationCondition(json : TJSONWriter; name : string; elem : TFhirFamilyHistoryRelationCondition);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeCodeableConcept(json, 'outcome', elem.outcome); {a}
  if (elem.onset is TFhirQuantity) then 
    ComposeAge(json, 'onsetAge', TFhirQuantity(elem.onset)) 
  else if (elem.onset is TFhirRange) then 
    ComposeRange(json, 'onsetRange', TFhirRange(elem.onset)) 
  else if (elem.onset is TFhirString) then 
  begin
    ComposeStringValue(json, 'onsetString', TFhirString(elem.onset), false);
    ComposeStringProps(json, 'onsetString', TFhirString(elem.onset), false);
  end;
  ComposeStringValue(json, 'note', elem.noteObject, false);
  ComposeStringProps(json, 'note', elem.noteObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseFamilyHistory(element : IXmlDomElement; path : string) : TFhirFamilyHistory;
var
  child : IXMLDOMElement;
begin
  result := TFhirFamilyHistory.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'note') then
        result.noteObject := ParseString(child, path+'/note') {b}
      else if (child.baseName = 'relation') then
        result.relationList.Add(ParseFamilyHistoryRelation(child, path+'/relation')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeFamilyHistory(xml : TXmlBuilder; name : string; elem : TFhirFamilyHistory);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  if not SummaryOnly then
    ComposeString(xml, 'note', elem.noteObject);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.relationList.Count - 1 do
      ComposeFamilyHistoryRelation(xml, 'relation', elem.relationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseFamilyHistory(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFamilyHistory(jsn));
end;

function TFHIRJsonParser.ParseFamilyHistory(jsn : TJsonObject) : TFhirFamilyHistory;
begin
  result := TFhirFamilyHistory.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('note') or jsn.has('_note') then
        result.noteObject := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    if jsn.has('relation') then
      iterateArray(jsn.vArr['relation'], result.relationList, parseFamilyHistoryRelation);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeFamilyHistory(json : TJSONWriter; name : string; elem : TFhirFamilyHistory);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  if not SummaryOnly then
    ComposeStringValue(json, 'note', elem.noteObject, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'note', elem.noteObject, false);
  if not SummaryOnly and (elem.relationList.Count > 0) then
  begin
    json.valueArray('relation');
    for i := 0 to elem.relationList.Count - 1 do
      ComposeFamilyHistoryRelation(json, '',elem.relationList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseGroupCharacteristic(element : IXmlDomElement; path : string) : TFhirGroupCharacteristic;
var
  child : IXMLDOMElement;
begin
  result := TFhirGroupCharacteristic.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.baseName = 'valueRange') then
        result.value := ParseRange(child, path+'/valueRange'){x.3}
      else if (child.baseName = 'exclude') then
        result.excludeObject := ParseBoolean(child, path+'/exclude') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeGroupCharacteristic(xml : TXmlBuilder; name : string; elem : TFhirGroupCharacteristic);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value));
  ComposeBoolean(xml, 'exclude', elem.excludeObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseGroupCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGroupCharacteristic(jsn));
end;

function TFHIRJsonParser.ParseGroupCharacteristic(jsn : TJsonObject) : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('exclude') or jsn.has('_exclude') then
        result.excludeObject := ParseBoolean(jsn['exclude'], jsn.vObj['_exclude']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeGroupCharacteristic(json : TJSONWriter; name : string; elem : TFhirGroupCharacteristic);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) ;
  ComposeBooleanValue(json, 'exclude', elem.excludeObject, false);
  ComposeBooleanProps(json, 'exclude', elem.excludeObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseGroup(element : IXmlDomElement; path : string) : TFhirGroup;
var
  child : IXMLDOMElement;
begin
  result := TFhirGroup.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'type') then
        result.type_Object := ParseEnum(CODES_TFhirGroupType, path+'/type', child){1a}
      else if (child.baseName = 'actual') then
        result.actualObject := ParseBoolean(child, path+'/actual') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'quantity') then
        result.quantityObject := ParseInteger(child, path+'/quantity') {b}
      else if (child.baseName = 'characteristic') then
        result.characteristicList.Add(ParseGroupCharacteristic(child, path+'/characteristic')){y.2}
      else if (child.baseName = 'member') then
        result.memberList.Add(ParseReference{Resource}(child, path+'/member')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeGroup(xml : TXmlBuilder; name : string; elem : TFhirGroup);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeEnum(xml, 'type', elem.Type_Object, CODES_TFhirGroupType);
  ComposeBoolean(xml, 'actual', elem.actualObject);{x.2}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeInteger(xml, 'quantity', elem.quantityObject);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeGroupCharacteristic(xml, 'characteristic', elem.characteristicList[i]);
  if not SummaryOnly then
    for i := 0 to elem.memberList.Count - 1 do
      ComposeReference{Resource}(xml, 'member', elem.memberList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGroup(jsn));
end;

function TFHIRJsonParser.ParseGroup(jsn : TJsonObject) : TFhirGroup;
begin
  result := TFhirGroup.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Object := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirGroupType);
    if jsn.has('actual') or jsn.has('_actual') then
        result.actualObject := ParseBoolean(jsn['actual'], jsn.vObj['_actual']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('quantity') or jsn.has('_quantity') then
        result.quantityObject := ParseInteger(jsn['quantity'], jsn.vObj['_quantity']);{q}
    if jsn.has('characteristic') then
      iterateArray(jsn.vArr['characteristic'], result.characteristicList, parseGroupCharacteristic);
    if jsn.has('member') then
      iterateArray(jsn.vArr['member'], result.memberList, parseReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeGroup(json : TJSONWriter; name : string; elem : TFhirGroup);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'type', elem.Type_Object, CODES_TFhirGroupType, false);
  ComposeEnumProps(json, 'type', elem.Type_Object, CODES_TFhirGroupType, false);
  ComposeBooleanValue(json, 'actual', elem.actualObject, false);
  ComposeBooleanProps(json, 'actual', elem.actualObject, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeIntegerValue(json, 'quantity', elem.quantityObject, false);
  ComposeIntegerProps(json, 'quantity', elem.quantityObject, false);
  if not SummaryOnly and (elem.characteristicList.Count > 0) then
  begin
    json.valueArray('characteristic');
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeGroupCharacteristic(json, '',elem.characteristicList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.memberList.Count > 0) then
  begin
    json.valueArray('member');
    for i := 0 to elem.memberList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.memberList[i]); {z - Reference(Patient|Practitioner|Device|Medication|Substance)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseImagingStudySeries(element : IXmlDomElement; path : string) : TFhirImagingStudySeries;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingStudySeries.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'number') then
        result.numberObject := ParseInteger(child, path+'/number') {b}
      else if (child.baseName = 'modality') then
        result.modalityObject := ParseEnum(CODES_TFhirModality, path+'/modality', child){1a}
      else if (child.baseName = 'uid') then
        result.uidObject := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'numberOfInstances') then
        result.numberOfInstancesObject := ParseInteger(child, path+'/numberOfInstances') {b}
      else if (child.baseName = 'availability') then
        result.availabilityObject := ParseEnum(CODES_TFhirInstanceAvailability, path+'/availability', child){1a}
      else if (child.baseName = 'url') then
        result.urlObject := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'bodySite') then
        result.bodySite := ParseCoding(child, path+'/bodySite') {b}
      else if (child.baseName = 'dateTime') then
        result.dateTimeObject := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.baseName = 'instance') then
        result.instanceList.Add(ParseImagingStudySeriesInstance(child, path+'/instance')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeries(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeries);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeInteger(xml, 'number', elem.numberObject);{x.2}
  ComposeEnum(xml, 'modality', elem.ModalityObject, CODES_TFhirModality);
  ComposeOid(xml, 'uid', elem.uidObject);{x.2}
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  ComposeInteger(xml, 'numberOfInstances', elem.numberOfInstancesObject);{x.2}
  ComposeEnum(xml, 'availability', elem.AvailabilityObject, CODES_TFhirInstanceAvailability);
  ComposeUri(xml, 'url', elem.urlObject);{x.2}
  ComposeCoding(xml, 'bodySite', elem.bodySite);{x.2}
  ComposeDateTime(xml, 'dateTime', elem.dateTimeObject);{x.2}
  for i := 0 to elem.instanceList.Count - 1 do
    ComposeImagingStudySeriesInstance(xml, 'instance', elem.instanceList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudySeries(jsn));
end;

function TFHIRJsonParser.ParseImagingStudySeries(jsn : TJsonObject) : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('number') or jsn.has('_number') then
        result.numberObject := ParseInteger(jsn['number'], jsn.vObj['_number']);{q}
    if jsn.has('modality') or jsn.has('_modality')  then
      result.modalityObject := parseEnum(jsn['modality'], jsn.vObj['_modality'], CODES_TFhirModality);
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidObject := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('numberOfInstances') or jsn.has('_numberOfInstances') then
        result.numberOfInstancesObject := ParseInteger(jsn['numberOfInstances'], jsn.vObj['_numberOfInstances']);{q}
    if jsn.has('availability') or jsn.has('_availability')  then
      result.availabilityObject := parseEnum(jsn['availability'], jsn.vObj['_availability'], CODES_TFhirInstanceAvailability);
    if jsn.has('url') or jsn.has('_url') then
        result.urlObject := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('bodySite') then
        result.bodySite := ParseCoding(jsn.vObj['bodySite']);{q}
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeObject := ParseDateTime(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('instance') then
      iterateArray(jsn.vArr['instance'], result.instanceList, parseImagingStudySeriesInstance);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingStudySeries);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIntegerValue(json, 'number', elem.numberObject, false);
  ComposeIntegerProps(json, 'number', elem.numberObject, false);
  ComposeEnumValue(json, 'modality', elem.ModalityObject, CODES_TFhirModality, false);
  ComposeEnumProps(json, 'modality', elem.ModalityObject, CODES_TFhirModality, false);
  ComposeOidValue(json, 'uid', elem.uidObject, false);
  ComposeOidProps(json, 'uid', elem.uidObject, false);
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  ComposeIntegerValue(json, 'numberOfInstances', elem.numberOfInstancesObject, false);
  ComposeIntegerProps(json, 'numberOfInstances', elem.numberOfInstancesObject, false);
  ComposeEnumValue(json, 'availability', elem.AvailabilityObject, CODES_TFhirInstanceAvailability, false);
  ComposeEnumProps(json, 'availability', elem.AvailabilityObject, CODES_TFhirInstanceAvailability, false);
  ComposeUriValue(json, 'url', elem.urlObject, false);
  ComposeUriProps(json, 'url', elem.urlObject, false);
  ComposeCoding(json, 'bodySite', elem.bodySite); {a}
  ComposeDateTimeValue(json, 'dateTime', elem.dateTimeObject, false);
  ComposeDateTimeProps(json, 'dateTime', elem.dateTimeObject, false);
  if elem.instanceList.Count > 0 then
  begin
    json.valueArray('instance');
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingStudySeriesInstance(json, '',elem.instanceList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseImagingStudySeriesInstance(element : IXmlDomElement; path : string) : TFhirImagingStudySeriesInstance;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'number') then
        result.numberObject := ParseInteger(child, path+'/number') {b}
      else if (child.baseName = 'uid') then
        result.uidObject := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'sopclass') then
        result.sopclassObject := ParseOid(child, path+'/sopclass') {b}
      else if (child.baseName = 'type') then
        result.type_Object := ParseString(child, path+'/type') {b}
      else if (child.baseName = 'title') then
        result.titleObject := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'url') then
        result.urlObject := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'attachment') then
        result.attachment := ParseReference{TFhirReference}(child, path+'/attachment') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeriesInstance(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeriesInstance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeInteger(xml, 'number', elem.numberObject);{x.2}
  ComposeOid(xml, 'uid', elem.uidObject);{x.2}
  ComposeOid(xml, 'sopclass', elem.sopclassObject);{x.2}
  ComposeString(xml, 'type', elem.type_Object);{x.2}
  ComposeString(xml, 'title', elem.titleObject);{x.2}
  ComposeUri(xml, 'url', elem.urlObject);{x.2}
  ComposeReference{TFhirReference}(xml, 'attachment', elem.attachment);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudySeriesInstance(jsn));
end;

function TFHIRJsonParser.ParseImagingStudySeriesInstance(jsn : TJsonObject) : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('number') or jsn.has('_number') then
        result.numberObject := ParseInteger(jsn['number'], jsn.vObj['_number']);{q}
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidObject := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('sopclass') or jsn.has('_sopclass') then
        result.sopclassObject := ParseOid(jsn['sopclass'], jsn.vObj['_sopclass']);{q}
    if jsn.has('type') or jsn.has('_type') then
        result.type_Object := ParseString(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleObject := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlObject := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('attachment') then
        result.attachment := ParseReference{TFhirReference}(jsn.vObj['attachment']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingStudySeriesInstance);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIntegerValue(json, 'number', elem.numberObject, false);
  ComposeIntegerProps(json, 'number', elem.numberObject, false);
  ComposeOidValue(json, 'uid', elem.uidObject, false);
  ComposeOidProps(json, 'uid', elem.uidObject, false);
  ComposeOidValue(json, 'sopclass', elem.sopclassObject, false);
  ComposeOidProps(json, 'sopclass', elem.sopclassObject, false);
  ComposeStringValue(json, 'type', elem.type_Object, false);
  ComposeStringProps(json, 'type', elem.type_Object, false);
  ComposeStringValue(json, 'title', elem.titleObject, false);
  ComposeStringProps(json, 'title', elem.titleObject, false);
  ComposeUriValue(json, 'url', elem.urlObject, false);
  ComposeUriProps(json, 'url', elem.urlObject, false);
  ComposeReference{TFhirReference}(json, 'attachment', elem.attachment); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseImagingStudy(element : IXmlDomElement; path : string) : TFhirImagingStudy;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingStudy.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'dateTime') then
        result.dateTimeObject := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'uid') then
        result.uidObject := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'accessionNo') then
        result.accessionNo := ParseIdentifier(child, path+'/accessionNo') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'order') then
        result.orderList.Add(ParseReference{TFhirDiagnosticOrder}(child, path+'/order')){y.2}
      else if (child.baseName = 'modality') then
        result.modality.Add(ParseEnum(CODES_TFhirImagingModality, path+'/modality', child)){y.1}
      else if (child.baseName = 'referrer') then
        result.referrer := ParseReference{TFhirPractitioner}(child, path+'/referrer') {b}
      else if (child.baseName = 'availability') then
        result.availabilityObject := ParseEnum(CODES_TFhirInstanceAvailability, path+'/availability', child){1a}
      else if (child.baseName = 'url') then
        result.urlObject := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'numberOfSeries') then
        result.numberOfSeriesObject := ParseInteger(child, path+'/numberOfSeries') {b}
      else if (child.baseName = 'numberOfInstances') then
        result.numberOfInstancesObject := ParseInteger(child, path+'/numberOfInstances') {b}
      else if (child.baseName = 'clinicalInformation') then
        result.clinicalInformationObject := ParseString(child, path+'/clinicalInformation') {b}
      else if (child.baseName = 'procedure') then
        result.procedure_List.Add(ParseCoding(child, path+'/procedure')){y.2}
      else if (child.baseName = 'interpreter') then
        result.interpreter := ParseReference{TFhirPractitioner}(child, path+'/interpreter') {b}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'series') then
        result.seriesList.Add(ParseImagingStudySeries(child, path+'/series')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingStudy(xml : TXmlBuilder; name : string; elem : TFhirImagingStudy);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeDateTime(xml, 'dateTime', elem.dateTimeObject);{x.2}
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  ComposeOid(xml, 'uid', elem.uidObject);{x.2}
  ComposeIdentifier(xml, 'accessionNo', elem.accessionNo);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  for i := 0 to elem.orderList.Count - 1 do
    ComposeReference{TFhirDiagnosticOrder}(xml, 'order', elem.orderList[i]);
  for i := 0 to elem.modality.Count - 1 do
    ComposeEnum(xml, 'modality', elem.modality[i], CODES_TFhirImagingModality);
  ComposeReference{TFhirPractitioner}(xml, 'referrer', elem.referrer);{x.2}
  ComposeEnum(xml, 'availability', elem.AvailabilityObject, CODES_TFhirInstanceAvailability);
  ComposeUri(xml, 'url', elem.urlObject);{x.2}
  ComposeInteger(xml, 'numberOfSeries', elem.numberOfSeriesObject);{x.2}
  ComposeInteger(xml, 'numberOfInstances', elem.numberOfInstancesObject);{x.2}
  ComposeString(xml, 'clinicalInformation', elem.clinicalInformationObject);{x.2}
  for i := 0 to elem.procedure_List.Count - 1 do
    ComposeCoding(xml, 'procedure', elem.procedure_List[i]);
  ComposeReference{TFhirPractitioner}(xml, 'interpreter', elem.interpreter);{x.2}
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  for i := 0 to elem.seriesList.Count - 1 do
    ComposeImagingStudySeries(xml, 'series', elem.seriesList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingStudy(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudy(jsn));
end;

function TFHIRJsonParser.ParseImagingStudy(jsn : TJsonObject) : TFhirImagingStudy;
begin
  result := TFhirImagingStudy.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeObject := ParseDateTime(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidObject := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('accessionNo') then
        result.accessionNo := ParseIdentifier(jsn.vObj['accessionNo']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('order') then
      iterateArray(jsn.vArr['order'], result.orderList, parseReference{TFhirDiagnosticOrder});
    if jsn.has('modality') or jsn.has('_modality') then
      iterateEnumArray(jsn.vArr['modality'], jsn.vArr['_modality'], result.modality, parseEnum, CODES_TFhirImagingModality);
    if jsn.has('referrer') then
        result.referrer := ParseReference{TFhirPractitioner}(jsn.vObj['referrer']);{q}
    if jsn.has('availability') or jsn.has('_availability')  then
      result.availabilityObject := parseEnum(jsn['availability'], jsn.vObj['_availability'], CODES_TFhirInstanceAvailability);
    if jsn.has('url') or jsn.has('_url') then
        result.urlObject := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('numberOfSeries') or jsn.has('_numberOfSeries') then
        result.numberOfSeriesObject := ParseInteger(jsn['numberOfSeries'], jsn.vObj['_numberOfSeries']);{q}
    if jsn.has('numberOfInstances') or jsn.has('_numberOfInstances') then
        result.numberOfInstancesObject := ParseInteger(jsn['numberOfInstances'], jsn.vObj['_numberOfInstances']);{q}
    if jsn.has('clinicalInformation') or jsn.has('_clinicalInformation') then
        result.clinicalInformationObject := ParseString(jsn['clinicalInformation'], jsn.vObj['_clinicalInformation']);{q}
    if jsn.has('procedure') then
      iterateArray(jsn.vArr['procedure'], result.procedure_List, parseCoding);
    if jsn.has('interpreter') then
        result.interpreter := ParseReference{TFhirPractitioner}(jsn.vObj['interpreter']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('series') then
      iterateArray(jsn.vArr['series'], result.seriesList, parseImagingStudySeries);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingStudy(json : TJSONWriter; name : string; elem : TFhirImagingStudy);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeDateTimeValue(json, 'dateTime', elem.dateTimeObject, false);
  ComposeDateTimeProps(json, 'dateTime', elem.dateTimeObject, false);
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeOidValue(json, 'uid', elem.uidObject, false);
  ComposeOidProps(json, 'uid', elem.uidObject, false);
  ComposeIdentifier(json, 'accessionNo', elem.accessionNo); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if elem.orderList.Count > 0 then
  begin
    json.valueArray('order');
    for i := 0 to elem.orderList.Count - 1 do
      ComposeReference{TFhirDiagnosticOrder}(json, '',elem.orderList[i]); {z - Reference(DiagnosticOrder)}
    json.FinishArray;
  end;
  if elem.modality.Count > 0 then
  begin
    json.valueArray('modality');
    ext := false;
    for i := 0 to elem.modality.Count - 1 do
    begin
      ext := ext or ((elem.modality[i].xmlid <> '') or (elem.modality[i].hasExtensions));
      ComposeEnumValue(json, '', elem.modality[i], CODES_TFhirImagingModality, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_modality');
      for i := 0 to elem.modality.Count - 1 do
        ComposeEnumProps(json, '', elem.modality[i], CODES_TFhirImagingModality, true);
      json.FinishArray;
    end;
  end;
  ComposeReference{TFhirPractitioner}(json, 'referrer', elem.referrer); {a}
  ComposeEnumValue(json, 'availability', elem.AvailabilityObject, CODES_TFhirInstanceAvailability, false);
  ComposeEnumProps(json, 'availability', elem.AvailabilityObject, CODES_TFhirInstanceAvailability, false);
  ComposeUriValue(json, 'url', elem.urlObject, false);
  ComposeUriProps(json, 'url', elem.urlObject, false);
  ComposeIntegerValue(json, 'numberOfSeries', elem.numberOfSeriesObject, false);
  ComposeIntegerProps(json, 'numberOfSeries', elem.numberOfSeriesObject, false);
  ComposeIntegerValue(json, 'numberOfInstances', elem.numberOfInstancesObject, false);
  ComposeIntegerProps(json, 'numberOfInstances', elem.numberOfInstancesObject, false);
  ComposeStringValue(json, 'clinicalInformation', elem.clinicalInformationObject, false);
  ComposeStringProps(json, 'clinicalInformation', elem.clinicalInformationObject, false);
  if elem.procedure_List.Count > 0 then
  begin
    json.valueArray('procedure');
    for i := 0 to elem.procedure_List.Count - 1 do
      ComposeCoding(json, '',elem.procedure_List[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeReference{TFhirPractitioner}(json, 'interpreter', elem.interpreter); {a}
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  if elem.seriesList.Count > 0 then
  begin
    json.valueArray('series');
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingStudySeries(json, '',elem.seriesList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseImmunizationExplanation(element : IXmlDomElement; path : string) : TFhirImmunizationExplanation;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationExplanation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'reason') then
        result.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.baseName = 'refusalReason') then
        result.refusalReasonList.Add(ParseCodeableConcept(child, path+'/refusalReason')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationExplanation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationExplanation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.reasonList.Count - 1 do
    ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  for i := 0 to elem.refusalReasonList.Count - 1 do
    ComposeCodeableConcept(xml, 'refusalReason', elem.refusalReasonList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationExplanation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationExplanation(jsn));
end;

function TFHIRJsonParser.ParseImmunizationExplanation(jsn : TJsonObject) : TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('refusalReason') then
      iterateArray(jsn.vArr['refusalReason'], result.refusalReasonList, parseCodeableConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationExplanation(json : TJSONWriter; name : string; elem : TFhirImmunizationExplanation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.reasonList.Count > 0 then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.refusalReasonList.Count > 0 then
  begin
    json.valueArray('refusalReason');
    for i := 0 to elem.refusalReasonList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.refusalReasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseImmunizationReaction(element : IXmlDomElement; path : string) : TFhirImmunizationReaction;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationReaction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'detail') then
        result.detail := ParseReference{Resource}(child, path+'/detail') {b}
      else if (child.baseName = 'reported') then
        result.reportedObject := ParseBoolean(child, path+'/reported') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationReaction(xml : TXmlBuilder; name : string; elem : TFhirImmunizationReaction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  ComposeReference{Resource}(xml, 'detail', elem.detail);{x.2}
  ComposeBoolean(xml, 'reported', elem.reportedObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationReaction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationReaction(jsn));
end;

function TFHIRJsonParser.ParseImmunizationReaction(jsn : TJsonObject) : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('detail') then
        result.detail := ParseReference{Resource}(jsn.vObj['detail']);{q}
    if jsn.has('reported') or jsn.has('_reported') then
        result.reportedObject := ParseBoolean(jsn['reported'], jsn.vObj['_reported']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationReaction(json : TJSONWriter; name : string; elem : TFhirImmunizationReaction);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  ComposeReference{Resource}(json, 'detail', elem.detail); {a}
  ComposeBooleanValue(json, 'reported', elem.reportedObject, false);
  ComposeBooleanProps(json, 'reported', elem.reportedObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseImmunizationVaccinationProtocol(element : IXmlDomElement; path : string) : TFhirImmunizationVaccinationProtocol;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'doseSequence') then
        result.doseSequenceObject := ParseInteger(child, path+'/doseSequence') {b}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'authority') then
        result.authority := ParseReference{TFhirOrganization}(child, path+'/authority') {b}
      else if (child.baseName = 'series') then
        result.seriesObject := ParseString(child, path+'/series') {b}
      else if (child.baseName = 'seriesDoses') then
        result.seriesDosesObject := ParseInteger(child, path+'/seriesDoses') {b}
      else if (child.baseName = 'doseTarget') then
        result.doseTarget := ParseCodeableConcept(child, path+'/doseTarget') {b}
      else if (child.baseName = 'doseStatus') then
        result.doseStatus := ParseCodeableConcept(child, path+'/doseStatus') {b}
      else if (child.baseName = 'doseStatusReason') then
        result.doseStatusReason := ParseCodeableConcept(child, path+'/doseStatusReason') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationVaccinationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationVaccinationProtocol);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeInteger(xml, 'doseSequence', elem.doseSequenceObject);{x.2}
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'authority', elem.authority);{x.2}
  ComposeString(xml, 'series', elem.seriesObject);{x.2}
  ComposeInteger(xml, 'seriesDoses', elem.seriesDosesObject);{x.2}
  ComposeCodeableConcept(xml, 'doseTarget', elem.doseTarget);{x.2}
  ComposeCodeableConcept(xml, 'doseStatus', elem.doseStatus);{x.2}
  ComposeCodeableConcept(xml, 'doseStatusReason', elem.doseStatusReason);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationVaccinationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationVaccinationProtocol(jsn));
end;

function TFHIRJsonParser.ParseImmunizationVaccinationProtocol(jsn : TJsonObject) : TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('doseSequence') or jsn.has('_doseSequence') then
        result.doseSequenceObject := ParseInteger(jsn['doseSequence'], jsn.vObj['_doseSequence']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('authority') then
        result.authority := ParseReference{TFhirOrganization}(jsn.vObj['authority']);{q}
    if jsn.has('series') or jsn.has('_series') then
        result.seriesObject := ParseString(jsn['series'], jsn.vObj['_series']);{q}
    if jsn.has('seriesDoses') or jsn.has('_seriesDoses') then
        result.seriesDosesObject := ParseInteger(jsn['seriesDoses'], jsn.vObj['_seriesDoses']);{q}
    if jsn.has('doseTarget') then
        result.doseTarget := ParseCodeableConcept(jsn.vObj['doseTarget']);{q}
    if jsn.has('doseStatus') then
        result.doseStatus := ParseCodeableConcept(jsn.vObj['doseStatus']);{q}
    if jsn.has('doseStatusReason') then
        result.doseStatusReason := ParseCodeableConcept(jsn.vObj['doseStatusReason']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationVaccinationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationVaccinationProtocol);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIntegerValue(json, 'doseSequence', elem.doseSequenceObject, false);
  ComposeIntegerProps(json, 'doseSequence', elem.doseSequenceObject, false);
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  ComposeReference{TFhirOrganization}(json, 'authority', elem.authority); {a}
  ComposeStringValue(json, 'series', elem.seriesObject, false);
  ComposeStringProps(json, 'series', elem.seriesObject, false);
  ComposeIntegerValue(json, 'seriesDoses', elem.seriesDosesObject, false);
  ComposeIntegerProps(json, 'seriesDoses', elem.seriesDosesObject, false);
  ComposeCodeableConcept(json, 'doseTarget', elem.doseTarget); {a}
  ComposeCodeableConcept(json, 'doseStatus', elem.doseStatus); {a}
  ComposeCodeableConcept(json, 'doseStatusReason', elem.doseStatusReason); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseImmunization(element : IXmlDomElement; path : string) : TFhirImmunization;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunization.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'vaccineType') then
        result.vaccineType := ParseCodeableConcept(child, path+'/vaccineType') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'refusedIndicator') then
        result.refusedIndicatorObject := ParseBoolean(child, path+'/refusedIndicator') {b}
      else if (child.baseName = 'reported') then
        result.reportedObject := ParseBoolean(child, path+'/reported') {b}
      else if (child.baseName = 'performer') then
        result.performer := ParseReference{TFhirPractitioner}(child, path+'/performer') {b}
      else if (child.baseName = 'requester') then
        result.requester := ParseReference{TFhirPractitioner}(child, path+'/requester') {b}
      else if (child.baseName = 'manufacturer') then
        result.manufacturer := ParseReference{TFhirOrganization}(child, path+'/manufacturer') {b}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'lotNumber') then
        result.lotNumberObject := ParseString(child, path+'/lotNumber') {b}
      else if (child.baseName = 'expirationDate') then
        result.expirationDateObject := ParseDate(child, path+'/expirationDate') {b}
      else if (child.baseName = 'site') then
        result.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'doseQuantity') then
        result.doseQuantity := ParseQuantity(child, path+'/doseQuantity') {b}
      else if (child.baseName = 'explanation') then
        result.explanation := ParseImmunizationExplanation(child, path+'/explanation') {b}
      else if (child.baseName = 'reaction') then
        result.reactionList.Add(ParseImmunizationReaction(child, path+'/reaction')){y.2}
      else if (child.baseName = 'vaccinationProtocol') then
        result.vaccinationProtocolList.Add(ParseImmunizationVaccinationProtocol(child, path+'/vaccinationProtocol')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunization(xml : TXmlBuilder; name : string; elem : TFhirImmunization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  ComposeCodeableConcept(xml, 'vaccineType', elem.vaccineType);{x.2}
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  ComposeBoolean(xml, 'refusedIndicator', elem.refusedIndicatorObject);{x.2}
  ComposeBoolean(xml, 'reported', elem.reportedObject);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'performer', elem.performer);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'requester', elem.requester);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'manufacturer', elem.manufacturer);{x.2}
  ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  ComposeString(xml, 'lotNumber', elem.lotNumberObject);{x.2}
  ComposeDate(xml, 'expirationDate', elem.expirationDateObject);{x.2}
  ComposeCodeableConcept(xml, 'site', elem.site);{x.2}
  ComposeCodeableConcept(xml, 'route', elem.route);{x.2}
  ComposeQuantity(xml, 'doseQuantity', elem.doseQuantity);{x.2}
  ComposeImmunizationExplanation(xml, 'explanation', elem.explanation);{x.2}
  for i := 0 to elem.reactionList.Count - 1 do
    ComposeImmunizationReaction(xml, 'reaction', elem.reactionList[i]);
  for i := 0 to elem.vaccinationProtocolList.Count - 1 do
    ComposeImmunizationVaccinationProtocol(xml, 'vaccinationProtocol', elem.vaccinationProtocolList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunization(jsn));
end;

function TFHIRJsonParser.ParseImmunization(jsn : TJsonObject) : TFhirImmunization;
begin
  result := TFhirImmunization.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('vaccineType') then
        result.vaccineType := ParseCodeableConcept(jsn.vObj['vaccineType']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('refusedIndicator') or jsn.has('_refusedIndicator') then
        result.refusedIndicatorObject := ParseBoolean(jsn['refusedIndicator'], jsn.vObj['_refusedIndicator']);{q}
    if jsn.has('reported') or jsn.has('_reported') then
        result.reportedObject := ParseBoolean(jsn['reported'], jsn.vObj['_reported']);{q}
    if jsn.has('performer') then
        result.performer := ParseReference{TFhirPractitioner}(jsn.vObj['performer']);{q}
    if jsn.has('requester') then
        result.requester := ParseReference{TFhirPractitioner}(jsn.vObj['requester']);{q}
    if jsn.has('manufacturer') then
        result.manufacturer := ParseReference{TFhirOrganization}(jsn.vObj['manufacturer']);{q}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('lotNumber') or jsn.has('_lotNumber') then
        result.lotNumberObject := ParseString(jsn['lotNumber'], jsn.vObj['_lotNumber']);{q}
    if jsn.has('expirationDate') or jsn.has('_expirationDate') then
        result.expirationDateObject := ParseDate(jsn['expirationDate'], jsn.vObj['_expirationDate']);{q}
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('doseQuantity') then
        result.doseQuantity := ParseQuantity(jsn.vObj['doseQuantity']);{q}
    if jsn.has('explanation') then
        result.explanation := ParseImmunizationExplanation(jsn.vObj['explanation']);{q}
    if jsn.has('reaction') then
      iterateArray(jsn.vArr['reaction'], result.reactionList, parseImmunizationReaction);
    if jsn.has('vaccinationProtocol') then
      iterateArray(jsn.vArr['vaccinationProtocol'], result.vaccinationProtocolList, parseImmunizationVaccinationProtocol);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunization(json : TJSONWriter; name : string; elem : TFhirImmunization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  ComposeCodeableConcept(json, 'vaccineType', elem.vaccineType); {a}
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeBooleanValue(json, 'refusedIndicator', elem.refusedIndicatorObject, false);
  ComposeBooleanProps(json, 'refusedIndicator', elem.refusedIndicatorObject, false);
  ComposeBooleanValue(json, 'reported', elem.reportedObject, false);
  ComposeBooleanProps(json, 'reported', elem.reportedObject, false);
  ComposeReference{TFhirPractitioner}(json, 'performer', elem.performer); {a}
  ComposeReference{TFhirPractitioner}(json, 'requester', elem.requester); {a}
  ComposeReference{TFhirOrganization}(json, 'manufacturer', elem.manufacturer); {a}
  ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  ComposeStringValue(json, 'lotNumber', elem.lotNumberObject, false);
  ComposeStringProps(json, 'lotNumber', elem.lotNumberObject, false);
  ComposeDateValue(json, 'expirationDate', elem.expirationDateObject, false);
  ComposeDateProps(json, 'expirationDate', elem.expirationDateObject, false);
  ComposeCodeableConcept(json, 'site', elem.site); {a}
  ComposeCodeableConcept(json, 'route', elem.route); {a}
  ComposeQuantity(json, 'doseQuantity', elem.doseQuantity); {a}
  ComposeImmunizationExplanation(json, 'explanation', elem.explanation); {a}
  if elem.reactionList.Count > 0 then
  begin
    json.valueArray('reaction');
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeImmunizationReaction(json, '',elem.reactionList[i]); {z - }
    json.FinishArray;
  end;
  if elem.vaccinationProtocolList.Count > 0 then
  begin
    json.valueArray('vaccinationProtocol');
    for i := 0 to elem.vaccinationProtocolList.Count - 1 do
      ComposeImmunizationVaccinationProtocol(json, '',elem.vaccinationProtocolList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendation(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendation;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'vaccineType') then
        result.vaccineType := ParseCodeableConcept(child, path+'/vaccineType') {b}
      else if (child.baseName = 'doseNumber') then
        result.doseNumberObject := ParseInteger(child, path+'/doseNumber') {b}
      else if (child.baseName = 'forecastStatus') then
        result.forecastStatus := ParseCodeableConcept(child, path+'/forecastStatus') {b}
      else if (child.baseName = 'dateCriterion') then
        result.dateCriterionList.Add(ParseImmunizationRecommendationRecommendationDateCriterion(child, path+'/dateCriterion')){y.2}
      else if (child.baseName = 'protocol') then
        result.protocol := ParseImmunizationRecommendationRecommendationProtocol(child, path+'/protocol') {b}
      else if (child.baseName = 'supportingImmunization') then
        result.supportingImmunizationList.Add(ParseReference{TFhirImmunization}(child, path+'/supportingImmunization')){y.2}
      else if (child.baseName = 'supportingPatientInformation') then
        result.supportingPatientInformationList.Add(ParseReference{Resource}(child, path+'/supportingPatientInformation')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  ComposeCodeableConcept(xml, 'vaccineType', elem.vaccineType);{x.2}
  ComposeInteger(xml, 'doseNumber', elem.doseNumberObject);{x.2}
  ComposeCodeableConcept(xml, 'forecastStatus', elem.forecastStatus);{x.2}
  for i := 0 to elem.dateCriterionList.Count - 1 do
    ComposeImmunizationRecommendationRecommendationDateCriterion(xml, 'dateCriterion', elem.dateCriterionList[i]);
  ComposeImmunizationRecommendationRecommendationProtocol(xml, 'protocol', elem.protocol);{x.2}
  for i := 0 to elem.supportingImmunizationList.Count - 1 do
    ComposeReference{TFhirImmunization}(xml, 'supportingImmunization', elem.supportingImmunizationList[i]);
  for i := 0 to elem.supportingPatientInformationList.Count - 1 do
    ComposeReference{Resource}(xml, 'supportingPatientInformation', elem.supportingPatientInformationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendationRecommendation(jsn));
end;

function TFHIRJsonParser.ParseImmunizationRecommendationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('vaccineType') then
        result.vaccineType := ParseCodeableConcept(jsn.vObj['vaccineType']);{q}
    if jsn.has('doseNumber') or jsn.has('_doseNumber') then
        result.doseNumberObject := ParseInteger(jsn['doseNumber'], jsn.vObj['_doseNumber']);{q}
    if jsn.has('forecastStatus') then
        result.forecastStatus := ParseCodeableConcept(jsn.vObj['forecastStatus']);{q}
    if jsn.has('dateCriterion') then
      iterateArray(jsn.vArr['dateCriterion'], result.dateCriterionList, parseImmunizationRecommendationRecommendationDateCriterion);
    if jsn.has('protocol') then
        result.protocol := ParseImmunizationRecommendationRecommendationProtocol(jsn.vObj['protocol']);{q}
    if jsn.has('supportingImmunization') then
      iterateArray(jsn.vArr['supportingImmunization'], result.supportingImmunizationList, parseReference{TFhirImmunization});
    if jsn.has('supportingPatientInformation') then
      iterateArray(jsn.vArr['supportingPatientInformation'], result.supportingPatientInformationList, parseReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  ComposeCodeableConcept(json, 'vaccineType', elem.vaccineType); {a}
  ComposeIntegerValue(json, 'doseNumber', elem.doseNumberObject, false);
  ComposeIntegerProps(json, 'doseNumber', elem.doseNumberObject, false);
  ComposeCodeableConcept(json, 'forecastStatus', elem.forecastStatus); {a}
  if elem.dateCriterionList.Count > 0 then
  begin
    json.valueArray('dateCriterion');
    for i := 0 to elem.dateCriterionList.Count - 1 do
      ComposeImmunizationRecommendationRecommendationDateCriterion(json, '',elem.dateCriterionList[i]); {z - }
    json.FinishArray;
  end;
  ComposeImmunizationRecommendationRecommendationProtocol(json, 'protocol', elem.protocol); {a}
  if elem.supportingImmunizationList.Count > 0 then
  begin
    json.valueArray('supportingImmunization');
    for i := 0 to elem.supportingImmunizationList.Count - 1 do
      ComposeReference{TFhirImmunization}(json, '',elem.supportingImmunizationList[i]); {z - Reference(Immunization)}
    json.FinishArray;
  end;
  if elem.supportingPatientInformationList.Count > 0 then
  begin
    json.valueArray('supportingPatientInformation');
    for i := 0 to elem.supportingPatientInformationList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.supportingPatientInformationList[i]); {z - Reference(Observation|AdverseReaction|AllergyIntolerance)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationDateCriterion(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendationDateCriterion;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'value') then
        result.valueObject := ParseDateTime(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeDateTime(xml, 'value', elem.valueObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendationRecommendationDateCriterion(jsn));
end;

function TFHIRJsonParser.ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueObject := ParseDateTime(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeDateTimeValue(json, 'value', elem.valueObject, false);
  ComposeDateTimeProps(json, 'value', elem.valueObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationProtocol(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendationProtocol;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'doseSequence') then
        result.doseSequenceObject := ParseInteger(child, path+'/doseSequence') {b}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'authority') then
        result.authority := ParseReference{TFhirOrganization}(child, path+'/authority') {b}
      else if (child.baseName = 'series') then
        result.seriesObject := ParseString(child, path+'/series') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeInteger(xml, 'doseSequence', elem.doseSequenceObject);{x.2}
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'authority', elem.authority);{x.2}
  ComposeString(xml, 'series', elem.seriesObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendationRecommendationProtocol(jsn));
end;

function TFHIRJsonParser.ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('doseSequence') or jsn.has('_doseSequence') then
        result.doseSequenceObject := ParseInteger(jsn['doseSequence'], jsn.vObj['_doseSequence']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('authority') then
        result.authority := ParseReference{TFhirOrganization}(jsn.vObj['authority']);{q}
    if jsn.has('series') or jsn.has('_series') then
        result.seriesObject := ParseString(jsn['series'], jsn.vObj['_series']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendationRecommendationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIntegerValue(json, 'doseSequence', elem.doseSequenceObject, false);
  ComposeIntegerProps(json, 'doseSequence', elem.doseSequenceObject, false);
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  ComposeReference{TFhirOrganization}(json, 'authority', elem.authority); {a}
  ComposeStringValue(json, 'series', elem.seriesObject, false);
  ComposeStringProps(json, 'series', elem.seriesObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseImmunizationRecommendation(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendation;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'recommendation') then
        result.recommendationList.Add(ParseImmunizationRecommendationRecommendation(child, path+'/recommendation')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  for i := 0 to elem.recommendationList.Count - 1 do
    ComposeImmunizationRecommendationRecommendation(xml, 'recommendation', elem.recommendationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendation(jsn));
end;

function TFHIRJsonParser.ParseImmunizationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('recommendation') then
      iterateArray(jsn.vArr['recommendation'], result.recommendationList, parseImmunizationRecommendationRecommendation);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if elem.recommendationList.Count > 0 then
  begin
    json.valueArray('recommendation');
    for i := 0 to elem.recommendationList.Count - 1 do
      ComposeImmunizationRecommendationRecommendation(json, '',elem.recommendationList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseListEntry(element : IXmlDomElement; path : string) : TFhirListEntry;
var
  child : IXMLDOMElement;
begin
  result := TFhirListEntry.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'flag') then
        result.flagList.Add(ParseCodeableConcept(child, path+'/flag')){y.2}
      else if (child.baseName = 'deleted') then
        result.deletedObject := ParseBoolean(child, path+'/deleted') {b}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'item') then
        result.item := ParseReference{TFhirReference}(child, path+'/item') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeListEntry(xml : TXmlBuilder; name : string; elem : TFhirListEntry);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.flagList.Count - 1 do
    ComposeCodeableConcept(xml, 'flag', elem.flagList[i]);
  ComposeBoolean(xml, 'deleted', elem.deletedObject);{x.2}
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  ComposeReference{TFhirReference}(xml, 'item', elem.item);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseListEntry(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseListEntry(jsn));
end;

function TFHIRJsonParser.ParseListEntry(jsn : TJsonObject) : TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('flag') then
      iterateArray(jsn.vArr['flag'], result.flagList, parseCodeableConcept);
    if jsn.has('deleted') or jsn.has('_deleted') then
        result.deletedObject := ParseBoolean(jsn['deleted'], jsn.vObj['_deleted']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('item') then
        result.item := ParseReference{TFhirReference}(jsn.vObj['item']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeListEntry(json : TJSONWriter; name : string; elem : TFhirListEntry);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.flagList.Count > 0 then
  begin
    json.valueArray('flag');
    for i := 0 to elem.flagList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.flagList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeBooleanValue(json, 'deleted', elem.deletedObject, false);
  ComposeBooleanProps(json, 'deleted', elem.deletedObject, false);
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  ComposeReference{TFhirReference}(json, 'item', elem.item); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseList(element : IXmlDomElement; path : string) : TFhirList;
var
  child : IXMLDOMElement;
begin
  result := TFhirList.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'source') then
        result.source := ParseReference{Resource}(child, path+'/source') {b}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'ordered') then
        result.orderedObject := ParseBoolean(child, path+'/ordered') {b}
      else if (child.baseName = 'mode') then
        result.modeObject := ParseEnum(CODES_TFhirListMode, path+'/mode', child){1a}
      else if (child.baseName = 'entry') then
        result.entryList.Add(ParseListEntry(child, path+'/entry')){y.2}
      else if (child.baseName = 'emptyReason') then
        result.emptyReason := ParseCodeableConcept(child, path+'/emptyReason') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeList(xml : TXmlBuilder; name : string; elem : TFhirList);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{Resource}(xml, 'source', elem.source);{x.2}
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  ComposeBoolean(xml, 'ordered', elem.orderedObject);{x.2}
  ComposeEnum(xml, 'mode', elem.ModeObject, CODES_TFhirListMode);
  for i := 0 to elem.entryList.Count - 1 do
    ComposeListEntry(xml, 'entry', elem.entryList[i]);
  ComposeCodeableConcept(xml, 'emptyReason', elem.emptyReason);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseList(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseList(jsn));
end;

function TFHIRJsonParser.ParseList(jsn : TJsonObject) : TFhirList;
begin
  result := TFhirList.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('source') then
        result.source := ParseReference{Resource}(jsn.vObj['source']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('ordered') or jsn.has('_ordered') then
        result.orderedObject := ParseBoolean(jsn['ordered'], jsn.vObj['_ordered']);{q}
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeObject := parseEnum(jsn['mode'], jsn.vObj['_mode'], CODES_TFhirListMode);
    if jsn.has('entry') then
      iterateArray(jsn.vArr['entry'], result.entryList, parseListEntry);
    if jsn.has('emptyReason') then
        result.emptyReason := ParseCodeableConcept(jsn.vObj['emptyReason']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeList(json : TJSONWriter; name : string; elem : TFhirList);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeReference{Resource}(json, 'source', elem.source); {a}
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  ComposeBooleanValue(json, 'ordered', elem.orderedObject, false);
  ComposeBooleanProps(json, 'ordered', elem.orderedObject, false);
  ComposeEnumValue(json, 'mode', elem.ModeObject, CODES_TFhirListMode, false);
  ComposeEnumProps(json, 'mode', elem.ModeObject, CODES_TFhirListMode, false);
  if elem.entryList.Count > 0 then
  begin
    json.valueArray('entry');
    for i := 0 to elem.entryList.Count - 1 do
      ComposeListEntry(json, '',elem.entryList[i]); {z - }
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'emptyReason', elem.emptyReason); {a}
end;

function TFHIRXmlParser.ParseLocationPosition(element : IXmlDomElement; path : string) : TFhirLocationPosition;
var
  child : IXMLDOMElement;
begin
  result := TFhirLocationPosition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'longitude') then
        result.longitudeObject := ParseDecimal(child, path+'/longitude') {b}
      else if (child.baseName = 'latitude') then
        result.latitudeObject := ParseDecimal(child, path+'/latitude') {b}
      else if (child.baseName = 'altitude') then
        result.altitudeObject := ParseDecimal(child, path+'/altitude') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeLocationPosition(xml : TXmlBuilder; name : string; elem : TFhirLocationPosition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeDecimal(xml, 'longitude', elem.longitudeObject);{x.2}
  ComposeDecimal(xml, 'latitude', elem.latitudeObject);{x.2}
  ComposeDecimal(xml, 'altitude', elem.altitudeObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseLocationPosition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseLocationPosition(jsn));
end;

function TFHIRJsonParser.ParseLocationPosition(jsn : TJsonObject) : TFhirLocationPosition;
begin
  result := TFhirLocationPosition.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('longitude') or jsn.has('_longitude') then
        result.longitudeObject := ParseDecimal(jsn['longitude'], jsn.vObj['_longitude']);{q}
    if jsn.has('latitude') or jsn.has('_latitude') then
        result.latitudeObject := ParseDecimal(jsn['latitude'], jsn.vObj['_latitude']);{q}
    if jsn.has('altitude') or jsn.has('_altitude') then
        result.altitudeObject := ParseDecimal(jsn['altitude'], jsn.vObj['_altitude']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeLocationPosition(json : TJSONWriter; name : string; elem : TFhirLocationPosition);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeDecimalValue(json, 'longitude', elem.longitudeObject, false);
  ComposeDecimalProps(json, 'longitude', elem.longitudeObject, false);
  ComposeDecimalValue(json, 'latitude', elem.latitudeObject, false);
  ComposeDecimalProps(json, 'latitude', elem.latitudeObject, false);
  ComposeDecimalValue(json, 'altitude', elem.altitudeObject, false);
  ComposeDecimalProps(json, 'altitude', elem.altitudeObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseLocation(element : IXmlDomElement; path : string) : TFhirLocation;
var
  child : IXMLDOMElement;
begin
  result := TFhirLocation.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'address') then
        result.address := ParseAddress(child, path+'/address') {b}
      else if (child.baseName = 'physicalType') then
        result.physicalType := ParseCodeableConcept(child, path+'/physicalType') {b}
      else if (child.baseName = 'position') then
        result.position := ParseLocationPosition(child, path+'/position') {b}
      else if (child.baseName = 'managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirLocationStatus, path+'/status', child){1a}
      else if (child.baseName = 'partOf') then
        result.partOf := ParseReference{TFhirLocation}(child, path+'/partOf') {b}
      else if (child.baseName = 'mode') then
        result.modeObject := ParseEnum(CODES_TFhirLocationMode, path+'/mode', child){1a}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeLocation(xml : TXmlBuilder; name : string; elem : TFhirLocation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeAddress(xml, 'address', elem.address);{x.2}
  ComposeCodeableConcept(xml, 'physicalType', elem.physicalType);{x.2}
  ComposeLocationPosition(xml, 'position', elem.position);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirLocationStatus);
  ComposeReference{TFhirLocation}(xml, 'partOf', elem.partOf);{x.2}
  ComposeEnum(xml, 'mode', elem.ModeObject, CODES_TFhirLocationMode);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseLocation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseLocation(jsn));
end;

function TFHIRJsonParser.ParseLocation(jsn : TJsonObject) : TFhirLocation;
begin
  result := TFhirLocation.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q}
    if jsn.has('physicalType') then
        result.physicalType := ParseCodeableConcept(jsn.vObj['physicalType']);{q}
    if jsn.has('position') then
        result.position := ParseLocationPosition(jsn.vObj['position']);{q}
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirLocationStatus);
    if jsn.has('partOf') then
        result.partOf := ParseReference{TFhirLocation}(jsn.vObj['partOf']);{q}
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeObject := parseEnum(jsn['mode'], jsn.vObj['_mode'], CODES_TFhirLocationMode);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeLocation(json : TJSONWriter; name : string; elem : TFhirLocation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeAddress(json, 'address', elem.address); {a}
  ComposeCodeableConcept(json, 'physicalType', elem.physicalType); {a}
  ComposeLocationPosition(json, 'position', elem.position); {a}
  ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirLocationStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirLocationStatus, false);
  ComposeReference{TFhirLocation}(json, 'partOf', elem.partOf); {a}
  ComposeEnumValue(json, 'mode', elem.ModeObject, CODES_TFhirLocationMode, false);
  ComposeEnumProps(json, 'mode', elem.ModeObject, CODES_TFhirLocationMode, false);
end;

function TFHIRXmlParser.ParseMedia(element : IXmlDomElement; path : string) : TFhirMedia;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedia.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Object := ParseEnum(CODES_TFhirMediaType, path+'/type', child){1a}
      else if (child.baseName = 'subtype') then
        result.subtype := ParseCodeableConcept(child, path+'/subtype') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'dateTime') then
        result.dateTimeObject := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'operator') then
        result.operator := ParseReference{TFhirPractitioner}(child, path+'/operator') {b}
      else if (child.baseName = 'view') then
        result.view := ParseCodeableConcept(child, path+'/view') {b}
      else if (child.baseName = 'deviceName') then
        result.deviceNameObject := ParseString(child, path+'/deviceName') {b}
      else if (child.baseName = 'height') then
        result.heightObject := ParseInteger(child, path+'/height') {b}
      else if (child.baseName = 'width') then
        result.widthObject := ParseInteger(child, path+'/width') {b}
      else if (child.baseName = 'frames') then
        result.framesObject := ParseInteger(child, path+'/frames') {b}
      else if (child.baseName = 'length') then
        result.lengthObject := ParseInteger(child, path+'/length') {b}
      else if (child.baseName = 'content') then
        result.content := ParseAttachment(child, path+'/content') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedia(xml : TXmlBuilder; name : string; elem : TFhirMedia);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Object, CODES_TFhirMediaType);
  ComposeCodeableConcept(xml, 'subtype', elem.subtype);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeDateTime(xml, 'dateTime', elem.dateTimeObject);{x.2}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'operator', elem.operator);{x.2}
  ComposeCodeableConcept(xml, 'view', elem.view);{x.2}
  ComposeString(xml, 'deviceName', elem.deviceNameObject);{x.2}
  ComposeInteger(xml, 'height', elem.heightObject);{x.2}
  ComposeInteger(xml, 'width', elem.widthObject);{x.2}
  ComposeInteger(xml, 'frames', elem.framesObject);{x.2}
  ComposeInteger(xml, 'length', elem.lengthObject);{x.2}
  if not SummaryOnly then
    ComposeAttachment(xml, 'content', elem.content);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedia(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedia(jsn));
end;

function TFHIRJsonParser.ParseMedia(jsn : TJsonObject) : TFhirMedia;
begin
  result := TFhirMedia.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Object := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirMediaType);
    if jsn.has('subtype') then
        result.subtype := ParseCodeableConcept(jsn.vObj['subtype']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeObject := ParseDateTime(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('operator') then
        result.operator := ParseReference{TFhirPractitioner}(jsn.vObj['operator']);{q}
    if jsn.has('view') then
        result.view := ParseCodeableConcept(jsn.vObj['view']);{q}
    if jsn.has('deviceName') or jsn.has('_deviceName') then
        result.deviceNameObject := ParseString(jsn['deviceName'], jsn.vObj['_deviceName']);{q}
    if jsn.has('height') or jsn.has('_height') then
        result.heightObject := ParseInteger(jsn['height'], jsn.vObj['_height']);{q}
    if jsn.has('width') or jsn.has('_width') then
        result.widthObject := ParseInteger(jsn['width'], jsn.vObj['_width']);{q}
    if jsn.has('frames') or jsn.has('_frames') then
        result.framesObject := ParseInteger(jsn['frames'], jsn.vObj['_frames']);{q}
    if jsn.has('length') or jsn.has('_length') then
        result.lengthObject := ParseInteger(jsn['length'], jsn.vObj['_length']);{q}
    if jsn.has('content') then
        result.content := ParseAttachment(jsn.vObj['content']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedia(json : TJSONWriter; name : string; elem : TFhirMedia);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Object, CODES_TFhirMediaType, false);
  ComposeEnumProps(json, 'type', elem.Type_Object, CODES_TFhirMediaType, false);
  ComposeCodeableConcept(json, 'subtype', elem.subtype); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'dateTime', elem.dateTimeObject, false);
  ComposeDateTimeProps(json, 'dateTime', elem.dateTimeObject, false);
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeReference{TFhirPractitioner}(json, 'operator', elem.operator); {a}
  ComposeCodeableConcept(json, 'view', elem.view); {a}
  ComposeStringValue(json, 'deviceName', elem.deviceNameObject, false);
  ComposeStringProps(json, 'deviceName', elem.deviceNameObject, false);
  ComposeIntegerValue(json, 'height', elem.heightObject, false);
  ComposeIntegerProps(json, 'height', elem.heightObject, false);
  ComposeIntegerValue(json, 'width', elem.widthObject, false);
  ComposeIntegerProps(json, 'width', elem.widthObject, false);
  ComposeIntegerValue(json, 'frames', elem.framesObject, false);
  ComposeIntegerProps(json, 'frames', elem.framesObject, false);
  ComposeIntegerValue(json, 'length', elem.lengthObject, false);
  ComposeIntegerProps(json, 'length', elem.lengthObject, false);
  if not SummaryOnly then
    ComposeAttachment(json, 'content', elem.content); {a}
end;

function TFHIRXmlParser.ParseMedicationProduct(element : IXmlDomElement; path : string) : TFhirMedicationProduct;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationProduct.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'form') then
        result.form := ParseCodeableConcept(child, path+'/form') {b}
      else if (child.baseName = 'ingredient') then
        result.ingredientList.Add(ParseMedicationProductIngredient(child, path+'/ingredient')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationProduct(xml : TXmlBuilder; name : string; elem : TFhirMedicationProduct);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'form', elem.form);{x.2}
  for i := 0 to elem.ingredientList.Count - 1 do
    ComposeMedicationProductIngredient(xml, 'ingredient', elem.ingredientList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationProduct(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationProduct(jsn));
end;

function TFHIRJsonParser.ParseMedicationProduct(jsn : TJsonObject) : TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('form') then
        result.form := ParseCodeableConcept(jsn.vObj['form']);{q}
    if jsn.has('ingredient') then
      iterateArray(jsn.vArr['ingredient'], result.ingredientList, parseMedicationProductIngredient);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationProduct(json : TJSONWriter; name : string; elem : TFhirMedicationProduct);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'form', elem.form); {a}
  if elem.ingredientList.Count > 0 then
  begin
    json.valueArray('ingredient');
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeMedicationProductIngredient(json, '',elem.ingredientList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationProductIngredient(element : IXmlDomElement; path : string) : TFhirMedicationProductIngredient;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'item') then
        result.item := ParseReference{Resource}(child, path+'/item') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseRatio(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationProductIngredient(xml : TXmlBuilder; name : string; elem : TFhirMedicationProductIngredient);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'item', elem.item);{x.2}
  ComposeRatio(xml, 'amount', elem.amount);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationProductIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationProductIngredient(jsn));
end;

function TFHIRJsonParser.ParseMedicationProductIngredient(jsn : TJsonObject) : TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('item') then
        result.item := ParseReference{Resource}(jsn.vObj['item']);{q}
    if jsn.has('amount') then
        result.amount := ParseRatio(jsn.vObj['amount']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationProductIngredient(json : TJSONWriter; name : string; elem : TFhirMedicationProductIngredient);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{Resource}(json, 'item', elem.item); {a}
  ComposeRatio(json, 'amount', elem.amount); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationPackage(element : IXmlDomElement; path : string) : TFhirMedicationPackage;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPackage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'container') then
        result.container := ParseCodeableConcept(child, path+'/container') {b}
      else if (child.baseName = 'content') then
        result.contentList.Add(ParseMedicationPackageContent(child, path+'/content')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackage(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'container', elem.container);{x.2}
  for i := 0 to elem.contentList.Count - 1 do
    ComposeMedicationPackageContent(xml, 'content', elem.contentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPackage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPackage(jsn));
end;

function TFHIRJsonParser.ParseMedicationPackage(jsn : TJsonObject) : TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('container') then
        result.container := ParseCodeableConcept(jsn.vObj['container']);{q}
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseMedicationPackageContent);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPackage(json : TJSONWriter; name : string; elem : TFhirMedicationPackage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'container', elem.container); {a}
  if elem.contentList.Count > 0 then
  begin
    json.valueArray('content');
    for i := 0 to elem.contentList.Count - 1 do
      ComposeMedicationPackageContent(json, '',elem.contentList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationPackageContent(element : IXmlDomElement; path : string) : TFhirMedicationPackageContent;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPackageContent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'item') then
        result.item := ParseReference{TFhirMedication}(child, path+'/item') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackageContent(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackageContent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirMedication}(xml, 'item', elem.item);{x.2}
  ComposeQuantity(xml, 'amount', elem.amount);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPackageContent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPackageContent(jsn));
end;

function TFHIRJsonParser.ParseMedicationPackageContent(jsn : TJsonObject) : TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('item') then
        result.item := ParseReference{TFhirMedication}(jsn.vObj['item']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPackageContent(json : TJSONWriter; name : string; elem : TFhirMedicationPackageContent);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirMedication}(json, 'item', elem.item); {a}
  ComposeQuantity(json, 'amount', elem.amount); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedication(element : IXmlDomElement; path : string) : TFhirMedication;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedication.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'isBrand') then
        result.isBrandObject := ParseBoolean(child, path+'/isBrand') {b}
      else if (child.baseName = 'manufacturer') then
        result.manufacturer := ParseReference{TFhirOrganization}(child, path+'/manufacturer') {b}
      else if (child.baseName = 'kind') then
        result.kindObject := ParseEnum(CODES_TFhirMedicationKind, path+'/kind', child){1a}
      else if (child.baseName = 'product') then
        result.product := ParseMedicationProduct(child, path+'/product') {b}
      else if (child.baseName = 'package') then
        result.package := ParseMedicationPackage(child, path+'/package') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedication(xml : TXmlBuilder; name : string; elem : TFhirMedication);
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeBoolean(xml, 'isBrand', elem.isBrandObject);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'manufacturer', elem.manufacturer);{x.2}
  ComposeEnum(xml, 'kind', elem.KindObject, CODES_TFhirMedicationKind);
  if not SummaryOnly then
    ComposeMedicationProduct(xml, 'product', elem.product);{x.2}
  if not SummaryOnly then
    ComposeMedicationPackage(xml, 'package', elem.package);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedication(jsn));
end;

function TFHIRJsonParser.ParseMedication(jsn : TJsonObject) : TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('isBrand') or jsn.has('_isBrand') then
        result.isBrandObject := ParseBoolean(jsn['isBrand'], jsn.vObj['_isBrand']);{q}
    if jsn.has('manufacturer') then
        result.manufacturer := ParseReference{TFhirOrganization}(jsn.vObj['manufacturer']);{q}
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindObject := parseEnum(jsn['kind'], jsn.vObj['_kind'], CODES_TFhirMedicationKind);
    if jsn.has('product') then
        result.product := ParseMedicationProduct(jsn.vObj['product']);{q}
    if jsn.has('package') then
        result.package := ParseMedicationPackage(jsn.vObj['package']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedication(json : TJSONWriter; name : string; elem : TFhirMedication);
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeBooleanValue(json, 'isBrand', elem.isBrandObject, false);
  ComposeBooleanProps(json, 'isBrand', elem.isBrandObject, false);
  ComposeReference{TFhirOrganization}(json, 'manufacturer', elem.manufacturer); {a}
  ComposeEnumValue(json, 'kind', elem.KindObject, CODES_TFhirMedicationKind, false);
  ComposeEnumProps(json, 'kind', elem.KindObject, CODES_TFhirMedicationKind, false);
  if not SummaryOnly then
    ComposeMedicationProduct(json, 'product', elem.product); {a}
  if not SummaryOnly then
    ComposeMedicationPackage(json, 'package', elem.package); {a}
end;

function TFHIRXmlParser.ParseMedicationAdministrationDosage(element : IXmlDomElement; path : string) : TFhirMedicationAdministrationDosage;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'timingDateTime') then
        result.timing := ParseDateTime(child, path+'/timingDateTime'){x.3}
      else if (child.baseName = 'timingPeriod') then
        result.timing := ParsePeriod(child, path+'/timingPeriod'){x.3}
      else if (child.baseName = 'asNeededBoolean') then
        result.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.baseName = 'asNeededCodeableConcept') then
        result.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.baseName = 'site') then
        result.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'rate') then
        result.rate := ParseRatio(child, path+'/rate') {b}
      else if (child.baseName = 'maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministrationDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministrationDosage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(elem.timing))
  else if (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing));
  if (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded))
  else if (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded));
  ComposeCodeableConcept(xml, 'site', elem.site);{x.2}
  ComposeCodeableConcept(xml, 'route', elem.route);{x.2}
  ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeRatio(xml, 'rate', elem.rate);{x.2}
  ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationAdministrationDosage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationAdministrationDosage(jsn));
end;

function TFHIRJsonParser.ParseMedicationAdministrationDosage(jsn : TJsonObject) : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('timingDateTime') or jsn.has('_timingDateTime') then
      result.timing := parseDateTime(jsn['timingDateTime'], jsn.vObj['_timingDateTime']);
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('rate') then
        result.rate := ParseRatio(jsn.vObj['rate']);{q}
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationAdministrationDosage(json : TJSONWriter; name : string; elem : TFhirMedicationAdministrationDosage);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.timing is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
    ComposeDateTimeProps(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
  end
  else if (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) ;
  if (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end
  else if (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) ;
  ComposeCodeableConcept(json, 'site', elem.site); {a}
  ComposeCodeableConcept(json, 'route', elem.route); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeRatio(json, 'rate', elem.rate); {a}
  ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationAdministration(element : IXmlDomElement; path : string) : TFhirMedicationAdministration;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationAdministration.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirMedicationAdminStatus, path+'/status', child){1a}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'practitioner') then
        result.practitioner := ParseReference{TFhirPractitioner}(child, path+'/practitioner') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'prescription') then
        result.prescription := ParseReference{TFhirMedicationPrescription}(child, path+'/prescription') {b}
      else if (child.baseName = 'wasNotGiven') then
        result.wasNotGivenObject := ParseBoolean(child, path+'/wasNotGiven') {b}
      else if (child.baseName = 'reasonNotGiven') then
        result.reasonNotGivenList.Add(ParseCodeableConcept(child, path+'/reasonNotGiven')){y.2}
      else if (child.baseName = 'effectiveTimeDateTime') then
        result.effectiveTime := ParseDateTime(child, path+'/effectiveTimeDateTime'){x.3}
      else if (child.baseName = 'effectiveTimePeriod') then
        result.effectiveTime := ParsePeriod(child, path+'/effectiveTimePeriod'){x.3}
      else if (child.baseName = 'medication') then
        result.medication := ParseReference{TFhirMedication}(child, path+'/medication') {b}
      else if (child.baseName = 'device') then
        result.deviceList.Add(ParseReference{TFhirDevice}(child, path+'/device')){y.2}
      else if (child.baseName = 'dosage') then
        result.dosageList.Add(ParseMedicationAdministrationDosage(child, path+'/dosage')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministration(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministration);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirMedicationAdminStatus);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'practitioner', elem.practitioner);{x.2}
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  ComposeReference{TFhirMedicationPrescription}(xml, 'prescription', elem.prescription);{x.2}
  ComposeBoolean(xml, 'wasNotGiven', elem.wasNotGivenObject);{x.2}
  for i := 0 to elem.reasonNotGivenList.Count - 1 do
    ComposeCodeableConcept(xml, 'reasonNotGiven', elem.reasonNotGivenList[i]);
  if (elem.effectiveTime is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveTimeDateTime', TFhirDateTime(elem.effectiveTime))
  else if (elem.effectiveTime is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectiveTimePeriod', TFhirPeriod(elem.effectiveTime));
  ComposeReference{TFhirMedication}(xml, 'medication', elem.medication);{x.2}
  for i := 0 to elem.deviceList.Count - 1 do
    ComposeReference{TFhirDevice}(xml, 'device', elem.deviceList[i]);
  for i := 0 to elem.dosageList.Count - 1 do
    ComposeMedicationAdministrationDosage(xml, 'dosage', elem.dosageList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationAdministration(jsn));
end;

function TFHIRJsonParser.ParseMedicationAdministration(jsn : TJsonObject) : TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirMedicationAdminStatus);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('practitioner') then
        result.practitioner := ParseReference{TFhirPractitioner}(jsn.vObj['practitioner']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('prescription') then
        result.prescription := ParseReference{TFhirMedicationPrescription}(jsn.vObj['prescription']);{q}
    if jsn.has('wasNotGiven') or jsn.has('_wasNotGiven') then
        result.wasNotGivenObject := ParseBoolean(jsn['wasNotGiven'], jsn.vObj['_wasNotGiven']);{q}
    if jsn.has('reasonNotGiven') then
      iterateArray(jsn.vArr['reasonNotGiven'], result.reasonNotGivenList, parseCodeableConcept);
    if jsn.has('effectiveTimeDateTime') or jsn.has('_effectiveTimeDateTime') then
      result.effectiveTime := parseDateTime(jsn['effectiveTimeDateTime'], jsn.vObj['_effectiveTimeDateTime']);
    if jsn.has('effectiveTimePeriod') {a4} then
      result.effectiveTime := ParsePeriod(jsn.vObj['effectiveTimePeriod']);
    if jsn.has('medication') then
        result.medication := ParseReference{TFhirMedication}(jsn.vObj['medication']);{q}
    if jsn.has('device') then
      iterateArray(jsn.vArr['device'], result.deviceList, parseReference{TFhirDevice});
    if jsn.has('dosage') then
      iterateArray(jsn.vArr['dosage'], result.dosageList, parseMedicationAdministrationDosage);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationAdministration(json : TJSONWriter; name : string; elem : TFhirMedicationAdministration);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirMedicationAdminStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirMedicationAdminStatus, false);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeReference{TFhirPractitioner}(json, 'practitioner', elem.practitioner); {a}
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeReference{TFhirMedicationPrescription}(json, 'prescription', elem.prescription); {a}
  ComposeBooleanValue(json, 'wasNotGiven', elem.wasNotGivenObject, false);
  ComposeBooleanProps(json, 'wasNotGiven', elem.wasNotGivenObject, false);
  if elem.reasonNotGivenList.Count > 0 then
  begin
    json.valueArray('reasonNotGiven');
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.reasonNotGivenList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (elem.effectiveTime is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'effectiveTimeDateTime', TFhirDateTime(elem.effectiveTime), false);
    ComposeDateTimeProps(json, 'effectiveTimeDateTime', TFhirDateTime(elem.effectiveTime), false);
  end
  else if (elem.effectiveTime is TFhirPeriod) then 
    ComposePeriod(json, 'effectiveTimePeriod', TFhirPeriod(elem.effectiveTime)) ;
  ComposeReference{TFhirMedication}(json, 'medication', elem.medication); {a}
  if elem.deviceList.Count > 0 then
  begin
    json.valueArray('device');
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeReference{TFhirDevice}(json, '',elem.deviceList[i]); {z - Reference(Device)}
    json.FinishArray;
  end;
  if elem.dosageList.Count > 0 then
  begin
    json.valueArray('dosage');
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeMedicationAdministrationDosage(json, '',elem.dosageList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseMedicationDispenseDispense(element : IXmlDomElement; path : string) : TFhirMedicationDispenseDispense;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationDispenseDispense.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirMedicationDispenseStatus, path+'/status', child){1a}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'medication') then
        result.medication := ParseReference{TFhirMedication}(child, path+'/medication') {b}
      else if (child.baseName = 'whenPrepared') then
        result.whenPreparedObject := ParseDateTime(child, path+'/whenPrepared') {b}
      else if (child.baseName = 'whenHandedOver') then
        result.whenHandedOverObject := ParseDateTime(child, path+'/whenHandedOver') {b}
      else if (child.baseName = 'destination') then
        result.destination := ParseReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.baseName = 'receiver') then
        result.receiverList.Add(ParseReference{Resource}(child, path+'/receiver')){y.2}
      else if (child.baseName = 'dosage') then
        result.dosageList.Add(ParseMedicationDispenseDispenseDosage(child, path+'/dosage')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseDispense);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirMedicationDispenseStatus);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeReference{TFhirMedication}(xml, 'medication', elem.medication);{x.2}
  ComposeDateTime(xml, 'whenPrepared', elem.whenPreparedObject);{x.2}
  ComposeDateTime(xml, 'whenHandedOver', elem.whenHandedOverObject);{x.2}
  ComposeReference{TFhirLocation}(xml, 'destination', elem.destination);{x.2}
  for i := 0 to elem.receiverList.Count - 1 do
    ComposeReference{Resource}(xml, 'receiver', elem.receiverList[i]);
  for i := 0 to elem.dosageList.Count - 1 do
    ComposeMedicationDispenseDispenseDosage(xml, 'dosage', elem.dosageList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationDispenseDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispenseDispense(jsn));
end;

function TFHIRJsonParser.ParseMedicationDispenseDispense(jsn : TJsonObject) : TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirMedicationDispenseStatus);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('medication') then
        result.medication := ParseReference{TFhirMedication}(jsn.vObj['medication']);{q}
    if jsn.has('whenPrepared') or jsn.has('_whenPrepared') then
        result.whenPreparedObject := ParseDateTime(jsn['whenPrepared'], jsn.vObj['_whenPrepared']);{q}
    if jsn.has('whenHandedOver') or jsn.has('_whenHandedOver') then
        result.whenHandedOverObject := ParseDateTime(jsn['whenHandedOver'], jsn.vObj['_whenHandedOver']);{q}
    if jsn.has('destination') then
        result.destination := ParseReference{TFhirLocation}(jsn.vObj['destination']);{q}
    if jsn.has('receiver') then
      iterateArray(jsn.vArr['receiver'], result.receiverList, parseReference{Resource});
    if jsn.has('dosage') then
      iterateArray(jsn.vArr['dosage'], result.dosageList, parseMedicationDispenseDispenseDosage);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationDispenseDispense(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseDispense);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirMedicationDispenseStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirMedicationDispenseStatus, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeReference{TFhirMedication}(json, 'medication', elem.medication); {a}
  ComposeDateTimeValue(json, 'whenPrepared', elem.whenPreparedObject, false);
  ComposeDateTimeProps(json, 'whenPrepared', elem.whenPreparedObject, false);
  ComposeDateTimeValue(json, 'whenHandedOver', elem.whenHandedOverObject, false);
  ComposeDateTimeProps(json, 'whenHandedOver', elem.whenHandedOverObject, false);
  ComposeReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  if elem.receiverList.Count > 0 then
  begin
    json.valueArray('receiver');
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.receiverList[i]); {z - Reference(Patient|Practitioner)}
    json.FinishArray;
  end;
  if elem.dosageList.Count > 0 then
  begin
    json.valueArray('dosage');
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeMedicationDispenseDispenseDosage(json, '',elem.dosageList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationDispenseDispenseDosage(element : IXmlDomElement; path : string) : TFhirMedicationDispenseDispenseDosage;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationDispenseDispenseDosage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(child, path+'/additionalInstructions') {b}
      else if (child.baseName = 'scheduleDateTime') then
        result.schedule := ParseDateTime(child, path+'/scheduleDateTime'){x.3}
      else if (child.baseName = 'schedulePeriod') then
        result.schedule := ParsePeriod(child, path+'/schedulePeriod'){x.3}
      else if (child.baseName = 'scheduleTiming') then
        result.schedule := ParseTiming(child, path+'/scheduleTiming'){x.3}
      else if (child.baseName = 'asNeededBoolean') then
        result.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.baseName = 'asNeededCodeableConcept') then
        result.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.baseName = 'site') then
        result.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'rate') then
        result.rate := ParseRatio(child, path+'/rate') {b}
      else if (child.baseName = 'maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseDispenseDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseDispenseDosage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'additionalInstructions', elem.additionalInstructions);{x.2}
  if (elem.schedule is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'scheduleDateTime', TFhirDateTime(elem.schedule))
  else if (elem.schedule is TFhirPeriod) {6} then
    ComposePeriod(xml, 'schedulePeriod', TFhirPeriod(elem.schedule))
  else if (elem.schedule is TFhirTiming) {6} then
    ComposeTiming(xml, 'scheduleTiming', TFhirTiming(elem.schedule));
  if (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded))
  else if (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded));
  ComposeCodeableConcept(xml, 'site', elem.site);{x.2}
  ComposeCodeableConcept(xml, 'route', elem.route);{x.2}
  ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeRatio(xml, 'rate', elem.rate);{x.2}
  ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationDispenseDispenseDosage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispenseDispenseDosage(jsn));
end;

function TFHIRJsonParser.ParseMedicationDispenseDispenseDosage(jsn : TJsonObject) : TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(jsn.vObj['additionalInstructions']);{q}
    if jsn.has('scheduleDateTime') or jsn.has('_scheduleDateTime') then
      result.schedule := parseDateTime(jsn['scheduleDateTime'], jsn.vObj['_scheduleDateTime']);
    if jsn.has('schedulePeriod') {a4} then
      result.schedule := ParsePeriod(jsn.vObj['schedulePeriod']);
    if jsn.has('scheduleTiming') {a4} then
      result.schedule := ParseTiming(jsn.vObj['scheduleTiming']);
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('rate') then
        result.rate := ParseRatio(jsn.vObj['rate']);{q}
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationDispenseDispenseDosage(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseDispenseDosage);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'additionalInstructions', elem.additionalInstructions); {a}
  if (elem.schedule is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'scheduleDateTime', TFhirDateTime(elem.schedule), false);
    ComposeDateTimeProps(json, 'scheduleDateTime', TFhirDateTime(elem.schedule), false);
  end
  else if (elem.schedule is TFhirPeriod) then 
    ComposePeriod(json, 'schedulePeriod', TFhirPeriod(elem.schedule)) 
  else if (elem.schedule is TFhirTiming) then 
    ComposeTiming(json, 'scheduleTiming', TFhirTiming(elem.schedule)) ;
  if (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end
  else if (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) ;
  ComposeCodeableConcept(json, 'site', elem.site); {a}
  ComposeCodeableConcept(json, 'route', elem.route); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeRatio(json, 'rate', elem.rate); {a}
  ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationDispenseSubstitution(element : IXmlDomElement; path : string) : TFhirMedicationDispenseSubstitution;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'reason') then
        result.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.baseName = 'responsibleParty') then
        result.responsiblePartyList.Add(ParseReference{TFhirPractitioner}(child, path+'/responsibleParty')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseSubstitution);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  for i := 0 to elem.reasonList.Count - 1 do
    ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  for i := 0 to elem.responsiblePartyList.Count - 1 do
    ComposeReference{TFhirPractitioner}(xml, 'responsibleParty', elem.responsiblePartyList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationDispenseSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispenseSubstitution(jsn));
end;

function TFHIRJsonParser.ParseMedicationDispenseSubstitution(jsn : TJsonObject) : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('responsibleParty') then
      iterateArray(jsn.vArr['responsibleParty'], result.responsiblePartyList, parseReference{TFhirPractitioner});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationDispenseSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseSubstitution);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.reasonList.Count > 0 then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.responsiblePartyList.Count > 0 then
  begin
    json.valueArray('responsibleParty');
    for i := 0 to elem.responsiblePartyList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '',elem.responsiblePartyList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationDispense(element : IXmlDomElement; path : string) : TFhirMedicationDispense;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationDispense.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirMedicationDispenseStatus, path+'/status', child){1a}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'dispenser') then
        result.dispenser := ParseReference{TFhirPractitioner}(child, path+'/dispenser') {b}
      else if (child.baseName = 'authorizingPrescription') then
        result.authorizingPrescriptionList.Add(ParseReference{TFhirMedicationPrescription}(child, path+'/authorizingPrescription')){y.2}
      else if (child.baseName = 'dispense') then
        result.dispenseList.Add(ParseMedicationDispenseDispense(child, path+'/dispense')){y.2}
      else if (child.baseName = 'substitution') then
        result.substitution := ParseMedicationDispenseSubstitution(child, path+'/substitution') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispense);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirMedicationDispenseStatus);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'dispenser', elem.dispenser);{x.2}
  for i := 0 to elem.authorizingPrescriptionList.Count - 1 do
    ComposeReference{TFhirMedicationPrescription}(xml, 'authorizingPrescription', elem.authorizingPrescriptionList[i]);
  for i := 0 to elem.dispenseList.Count - 1 do
    ComposeMedicationDispenseDispense(xml, 'dispense', elem.dispenseList[i]);
  ComposeMedicationDispenseSubstitution(xml, 'substitution', elem.substitution);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispense(jsn));
end;

function TFHIRJsonParser.ParseMedicationDispense(jsn : TJsonObject) : TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirMedicationDispenseStatus);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('dispenser') then
        result.dispenser := ParseReference{TFhirPractitioner}(jsn.vObj['dispenser']);{q}
    if jsn.has('authorizingPrescription') then
      iterateArray(jsn.vArr['authorizingPrescription'], result.authorizingPrescriptionList, parseReference{TFhirMedicationPrescription});
    if jsn.has('dispense') then
      iterateArray(jsn.vArr['dispense'], result.dispenseList, parseMedicationDispenseDispense);
    if jsn.has('substitution') then
        result.substitution := ParseMedicationDispenseSubstitution(jsn.vObj['substitution']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationDispense(json : TJSONWriter; name : string; elem : TFhirMedicationDispense);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirMedicationDispenseStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirMedicationDispenseStatus, false);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeReference{TFhirPractitioner}(json, 'dispenser', elem.dispenser); {a}
  if elem.authorizingPrescriptionList.Count > 0 then
  begin
    json.valueArray('authorizingPrescription');
    for i := 0 to elem.authorizingPrescriptionList.Count - 1 do
      ComposeReference{TFhirMedicationPrescription}(json, '',elem.authorizingPrescriptionList[i]); {z - Reference(MedicationPrescription)}
    json.FinishArray;
  end;
  if elem.dispenseList.Count > 0 then
  begin
    json.valueArray('dispense');
    for i := 0 to elem.dispenseList.Count - 1 do
      ComposeMedicationDispenseDispense(json, '',elem.dispenseList[i]); {z - }
    json.FinishArray;
  end;
  ComposeMedicationDispenseSubstitution(json, 'substitution', elem.substitution); {a}
end;

function TFHIRXmlParser.ParseMedicationPrescriptionDosageInstruction(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionDosageInstruction;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPrescriptionDosageInstruction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'text') then
        result.textObject := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(child, path+'/additionalInstructions') {b}
      else if (child.baseName = 'scheduledDateTime') then
        result.scheduled := ParseDateTime(child, path+'/scheduledDateTime'){x.3}
      else if (child.baseName = 'scheduledPeriod') then
        result.scheduled := ParsePeriod(child, path+'/scheduledPeriod'){x.3}
      else if (child.baseName = 'scheduledTiming') then
        result.scheduled := ParseTiming(child, path+'/scheduledTiming'){x.3}
      else if (child.baseName = 'asNeededBoolean') then
        result.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.baseName = 'asNeededCodeableConcept') then
        result.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.baseName = 'site') then
        result.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'doseQuantity') then
        result.doseQuantity := ParseQuantity(child, path+'/doseQuantity') {b}
      else if (child.baseName = 'rate') then
        result.rate := ParseRatio(child, path+'/rate') {b}
      else if (child.baseName = 'maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPrescriptionDosageInstruction(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionDosageInstruction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'text', elem.textObject);{x.2}
  ComposeCodeableConcept(xml, 'additionalInstructions', elem.additionalInstructions);{x.2}
  if (elem.scheduled is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'scheduledDateTime', TFhirDateTime(elem.scheduled))
  else if (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(xml, 'scheduledPeriod', TFhirPeriod(elem.scheduled))
  else if (elem.scheduled is TFhirTiming) {6} then
    ComposeTiming(xml, 'scheduledTiming', TFhirTiming(elem.scheduled));
  if (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded))
  else if (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded));
  ComposeCodeableConcept(xml, 'site', elem.site);{x.2}
  ComposeCodeableConcept(xml, 'route', elem.route);{x.2}
  ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  ComposeQuantity(xml, 'doseQuantity', elem.doseQuantity);{x.2}
  ComposeRatio(xml, 'rate', elem.rate);{x.2}
  ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPrescriptionDosageInstruction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPrescriptionDosageInstruction(jsn));
end;

function TFHIRJsonParser.ParseMedicationPrescriptionDosageInstruction(jsn : TJsonObject) : TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('text') or jsn.has('_text') then
        result.textObject := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(jsn.vObj['additionalInstructions']);{q}
    if jsn.has('scheduledDateTime') or jsn.has('_scheduledDateTime') then
      result.scheduled := parseDateTime(jsn['scheduledDateTime'], jsn.vObj['_scheduledDateTime']);
    if jsn.has('scheduledPeriod') {a4} then
      result.scheduled := ParsePeriod(jsn.vObj['scheduledPeriod']);
    if jsn.has('scheduledTiming') {a4} then
      result.scheduled := ParseTiming(jsn.vObj['scheduledTiming']);
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('doseQuantity') then
        result.doseQuantity := ParseQuantity(jsn.vObj['doseQuantity']);{q}
    if jsn.has('rate') then
        result.rate := ParseRatio(jsn.vObj['rate']);{q}
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPrescriptionDosageInstruction(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionDosageInstruction);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'text', elem.textObject, false);
  ComposeStringProps(json, 'text', elem.textObject, false);
  ComposeCodeableConcept(json, 'additionalInstructions', elem.additionalInstructions); {a}
  if (elem.scheduled is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'scheduledDateTime', TFhirDateTime(elem.scheduled), false);
    ComposeDateTimeProps(json, 'scheduledDateTime', TFhirDateTime(elem.scheduled), false);
  end
  else if (elem.scheduled is TFhirPeriod) then 
    ComposePeriod(json, 'scheduledPeriod', TFhirPeriod(elem.scheduled)) 
  else if (elem.scheduled is TFhirTiming) then 
    ComposeTiming(json, 'scheduledTiming', TFhirTiming(elem.scheduled)) ;
  if (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end
  else if (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) ;
  ComposeCodeableConcept(json, 'site', elem.site); {a}
  ComposeCodeableConcept(json, 'route', elem.route); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  ComposeQuantity(json, 'doseQuantity', elem.doseQuantity); {a}
  ComposeRatio(json, 'rate', elem.rate); {a}
  ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationPrescriptionDispense(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionDispense;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPrescriptionDispense.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'medication') then
        result.medication := ParseReference{TFhirMedication}(child, path+'/medication') {b}
      else if (child.baseName = 'validityPeriod') then
        result.validityPeriod := ParsePeriod(child, path+'/validityPeriod') {b}
      else if (child.baseName = 'numberOfRepeatsAllowed') then
        result.numberOfRepeatsAllowedObject := ParseInteger(child, path+'/numberOfRepeatsAllowed') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'expectedSupplyDuration') then
        result.expectedSupplyDuration := ParseQuantity(child, path+'/expectedSupplyDuration') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPrescriptionDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionDispense);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirMedication}(xml, 'medication', elem.medication);{x.2}
  ComposePeriod(xml, 'validityPeriod', elem.validityPeriod);{x.2}
  ComposeInteger(xml, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedObject);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeQuantity(xml, 'expectedSupplyDuration', elem.expectedSupplyDuration);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPrescriptionDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPrescriptionDispense(jsn));
end;

function TFHIRJsonParser.ParseMedicationPrescriptionDispense(jsn : TJsonObject) : TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('medication') then
        result.medication := ParseReference{TFhirMedication}(jsn.vObj['medication']);{q}
    if jsn.has('validityPeriod') then
        result.validityPeriod := ParsePeriod(jsn.vObj['validityPeriod']);{q}
    if jsn.has('numberOfRepeatsAllowed') or jsn.has('_numberOfRepeatsAllowed') then
        result.numberOfRepeatsAllowedObject := ParseInteger(jsn['numberOfRepeatsAllowed'], jsn.vObj['_numberOfRepeatsAllowed']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('expectedSupplyDuration') then
        result.expectedSupplyDuration := ParseQuantity(jsn.vObj['expectedSupplyDuration']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPrescriptionDispense(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionDispense);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirMedication}(json, 'medication', elem.medication); {a}
  ComposePeriod(json, 'validityPeriod', elem.validityPeriod); {a}
  ComposeIntegerValue(json, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedObject, false);
  ComposeIntegerProps(json, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedObject, false);
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeQuantity(json, 'expectedSupplyDuration', elem.expectedSupplyDuration); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationPrescriptionSubstitution(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionSubstitution;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPrescriptionSubstitution.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPrescriptionSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionSubstitution);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPrescriptionSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPrescriptionSubstitution(jsn));
end;

function TFHIRJsonParser.ParseMedicationPrescriptionSubstitution(jsn : TJsonObject) : TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPrescriptionSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionSubstitution);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationPrescription(element : IXmlDomElement; path : string) : TFhirMedicationPrescription;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPrescription.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'dateWritten') then
        result.dateWrittenObject := ParseDateTime(child, path+'/dateWritten') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirMedicationPrescriptionStatus, path+'/status', child){1a}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'prescriber') then
        result.prescriber := ParseReference{TFhirPractitioner}(child, path+'/prescriber') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'reasonCodeableConcept') then
        result.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.baseName = 'reasonReference') then
        result.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.baseName = 'medication') then
        result.medication := ParseReference{TFhirMedication}(child, path+'/medication') {b}
      else if (child.baseName = 'dosageInstruction') then
        result.dosageInstructionList.Add(ParseMedicationPrescriptionDosageInstruction(child, path+'/dosageInstruction')){y.2}
      else if (child.baseName = 'dispense') then
        result.dispense := ParseMedicationPrescriptionDispense(child, path+'/dispense') {b}
      else if (child.baseName = 'substitution') then
        result.substitution := ParseMedicationPrescriptionSubstitution(child, path+'/substitution') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPrescription(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescription);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeDateTime(xml, 'dateWritten', elem.dateWrittenObject);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirMedicationPrescriptionStatus);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'prescriber', elem.prescriber);{x.2}
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  ComposeReference{TFhirMedication}(xml, 'medication', elem.medication);{x.2}
  for i := 0 to elem.dosageInstructionList.Count - 1 do
    ComposeMedicationPrescriptionDosageInstruction(xml, 'dosageInstruction', elem.dosageInstructionList[i]);
  ComposeMedicationPrescriptionDispense(xml, 'dispense', elem.dispense);{x.2}
  ComposeMedicationPrescriptionSubstitution(xml, 'substitution', elem.substitution);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPrescription(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPrescription(jsn));
end;

function TFHIRJsonParser.ParseMedicationPrescription(jsn : TJsonObject) : TFhirMedicationPrescription;
begin
  result := TFhirMedicationPrescription.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('dateWritten') or jsn.has('_dateWritten') then
        result.dateWrittenObject := ParseDateTime(jsn['dateWritten'], jsn.vObj['_dateWritten']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirMedicationPrescriptionStatus);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('prescriber') then
        result.prescriber := ParseReference{TFhirPractitioner}(jsn.vObj['prescriber']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('medication') then
        result.medication := ParseReference{TFhirMedication}(jsn.vObj['medication']);{q}
    if jsn.has('dosageInstruction') then
      iterateArray(jsn.vArr['dosageInstruction'], result.dosageInstructionList, parseMedicationPrescriptionDosageInstruction);
    if jsn.has('dispense') then
        result.dispense := ParseMedicationPrescriptionDispense(jsn.vObj['dispense']);{q}
    if jsn.has('substitution') then
        result.substitution := ParseMedicationPrescriptionSubstitution(jsn.vObj['substitution']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPrescription(json : TJSONWriter; name : string; elem : TFhirMedicationPrescription);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'dateWritten', elem.dateWrittenObject, false);
  ComposeDateTimeProps(json, 'dateWritten', elem.dateWrittenObject, false);
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirMedicationPrescriptionStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirMedicationPrescriptionStatus, false);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeReference{TFhirPractitioner}(json, 'prescriber', elem.prescriber); {a}
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  ComposeReference{TFhirMedication}(json, 'medication', elem.medication); {a}
  if elem.dosageInstructionList.Count > 0 then
  begin
    json.valueArray('dosageInstruction');
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeMedicationPrescriptionDosageInstruction(json, '',elem.dosageInstructionList[i]); {z - }
    json.FinishArray;
  end;
  ComposeMedicationPrescriptionDispense(json, 'dispense', elem.dispense); {a}
  ComposeMedicationPrescriptionSubstitution(json, 'substitution', elem.substitution); {a}
end;

function TFHIRXmlParser.ParseMedicationStatementDosage(element : IXmlDomElement; path : string) : TFhirMedicationStatementDosage;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'schedule') then
        result.schedule := ParseTiming(child, path+'/schedule') {b}
      else if (child.baseName = 'asNeededBoolean') then
        result.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.baseName = 'asNeededCodeableConcept') then
        result.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.baseName = 'site') then
        result.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'rate') then
        result.rate := ParseRatio(child, path+'/rate') {b}
      else if (child.baseName = 'maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationStatementDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatementDosage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeTiming(xml, 'schedule', elem.schedule);{x.2}
  if (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded))
  else if (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded));
  ComposeCodeableConcept(xml, 'site', elem.site);{x.2}
  ComposeCodeableConcept(xml, 'route', elem.route);{x.2}
  ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeRatio(xml, 'rate', elem.rate);{x.2}
  ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationStatementDosage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationStatementDosage(jsn));
end;

function TFHIRJsonParser.ParseMedicationStatementDosage(jsn : TJsonObject) : TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('schedule') then
        result.schedule := ParseTiming(jsn.vObj['schedule']);{q}
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('rate') then
        result.rate := ParseRatio(jsn.vObj['rate']);{q}
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationStatementDosage(json : TJSONWriter; name : string; elem : TFhirMedicationStatementDosage);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeTiming(json, 'schedule', elem.schedule); {a}
  if (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end
  else if (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) ;
  ComposeCodeableConcept(json, 'site', elem.site); {a}
  ComposeCodeableConcept(json, 'route', elem.route); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeRatio(json, 'rate', elem.rate); {a}
  ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationStatement(element : IXmlDomElement; path : string) : TFhirMedicationStatement;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationStatement.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'wasNotGiven') then
        result.wasNotGivenObject := ParseBoolean(child, path+'/wasNotGiven') {b}
      else if (child.baseName = 'reasonNotGiven') then
        result.reasonNotGivenList.Add(ParseCodeableConcept(child, path+'/reasonNotGiven')){y.2}
      else if (child.baseName = 'whenGiven') then
        result.whenGiven := ParsePeriod(child, path+'/whenGiven') {b}
      else if (child.baseName = 'medication') then
        result.medication := ParseReference{TFhirMedication}(child, path+'/medication') {b}
      else if (child.baseName = 'device') then
        result.deviceList.Add(ParseReference{TFhirDevice}(child, path+'/device')){y.2}
      else if (child.baseName = 'dosage') then
        result.dosageList.Add(ParseMedicationStatementDosage(child, path+'/dosage')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationStatement(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeBoolean(xml, 'wasNotGiven', elem.wasNotGivenObject);{x.2}
  for i := 0 to elem.reasonNotGivenList.Count - 1 do
    ComposeCodeableConcept(xml, 'reasonNotGiven', elem.reasonNotGivenList[i]);
  ComposePeriod(xml, 'whenGiven', elem.whenGiven);{x.2}
  ComposeReference{TFhirMedication}(xml, 'medication', elem.medication);{x.2}
  for i := 0 to elem.deviceList.Count - 1 do
    ComposeReference{TFhirDevice}(xml, 'device', elem.deviceList[i]);
  for i := 0 to elem.dosageList.Count - 1 do
    ComposeMedicationStatementDosage(xml, 'dosage', elem.dosageList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationStatement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationStatement(jsn));
end;

function TFHIRJsonParser.ParseMedicationStatement(jsn : TJsonObject) : TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('wasNotGiven') or jsn.has('_wasNotGiven') then
        result.wasNotGivenObject := ParseBoolean(jsn['wasNotGiven'], jsn.vObj['_wasNotGiven']);{q}
    if jsn.has('reasonNotGiven') then
      iterateArray(jsn.vArr['reasonNotGiven'], result.reasonNotGivenList, parseCodeableConcept);
    if jsn.has('whenGiven') then
        result.whenGiven := ParsePeriod(jsn.vObj['whenGiven']);{q}
    if jsn.has('medication') then
        result.medication := ParseReference{TFhirMedication}(jsn.vObj['medication']);{q}
    if jsn.has('device') then
      iterateArray(jsn.vArr['device'], result.deviceList, parseReference{TFhirDevice});
    if jsn.has('dosage') then
      iterateArray(jsn.vArr['dosage'], result.dosageList, parseMedicationStatementDosage);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationStatement(json : TJSONWriter; name : string; elem : TFhirMedicationStatement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeBooleanValue(json, 'wasNotGiven', elem.wasNotGivenObject, false);
  ComposeBooleanProps(json, 'wasNotGiven', elem.wasNotGivenObject, false);
  if elem.reasonNotGivenList.Count > 0 then
  begin
    json.valueArray('reasonNotGiven');
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.reasonNotGivenList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposePeriod(json, 'whenGiven', elem.whenGiven); {a}
  ComposeReference{TFhirMedication}(json, 'medication', elem.medication); {a}
  if elem.deviceList.Count > 0 then
  begin
    json.valueArray('device');
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeReference{TFhirDevice}(json, '',elem.deviceList[i]); {z - Reference(Device)}
    json.FinishArray;
  end;
  if elem.dosageList.Count > 0 then
  begin
    json.valueArray('dosage');
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeMedicationStatementDosage(json, '',elem.dosageList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseMessageHeaderResponse(element : IXmlDomElement; path : string) : TFhirMessageHeaderResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierObject := ParseId(child, path+'/identifier') {b}
      else if (child.baseName = 'code') then
        result.codeObject := ParseEnum(CODES_TFhirResponseCode, path+'/code', child){1a}
      else if (child.baseName = 'details') then
        result.details := ParseReference{TFhirOperationOutcome}(child, path+'/details') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderResponse(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderResponse);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'identifier', elem.identifierObject);{x.2}
  ComposeEnum(xml, 'code', elem.CodeObject, CODES_TFhirResponseCode);
  ComposeReference{TFhirOperationOutcome}(xml, 'details', elem.details);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMessageHeaderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderResponse(jsn));
end;

function TFHIRJsonParser.ParseMessageHeaderResponse(jsn : TJsonObject) : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierObject := ParseId(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('code') or jsn.has('_code')  then
      result.codeObject := parseEnum(jsn['code'], jsn.vObj['_code'], CODES_TFhirResponseCode);
    if jsn.has('details') then
        result.details := ParseReference{TFhirOperationOutcome}(jsn.vObj['details']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderResponse(json : TJSONWriter; name : string; elem : TFhirMessageHeaderResponse);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'identifier', elem.identifierObject, false);
  ComposeIdProps(json, 'identifier', elem.identifierObject, false);
  ComposeEnumValue(json, 'code', elem.CodeObject, CODES_TFhirResponseCode, false);
  ComposeEnumProps(json, 'code', elem.CodeObject, CODES_TFhirResponseCode, false);
  ComposeReference{TFhirOperationOutcome}(json, 'details', elem.details); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMessageHeaderSource(element : IXmlDomElement; path : string) : TFhirMessageHeaderSource;
var
  child : IXMLDOMElement;
begin
  result := TFhirMessageHeaderSource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'software') then
        result.softwareObject := ParseString(child, path+'/software') {b}
      else if (child.baseName = 'version') then
        result.versionObject := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'contact') then
        result.contact := ParseContactPoint(child, path+'/contact') {b}
      else if (child.baseName = 'endpoint') then
        result.endpointObject := ParseUri(child, path+'/endpoint') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderSource(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderSource);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeString(xml, 'software', elem.softwareObject);{x.2}
  ComposeString(xml, 'version', elem.versionObject);{x.2}
  ComposeContactPoint(xml, 'contact', elem.contact);{x.2}
  ComposeUri(xml, 'endpoint', elem.endpointObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMessageHeaderSource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderSource(jsn));
end;

function TFHIRJsonParser.ParseMessageHeaderSource(jsn : TJsonObject) : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('software') or jsn.has('_software') then
        result.softwareObject := ParseString(jsn['software'], jsn.vObj['_software']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionObject := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('contact') then
        result.contact := ParseContactPoint(jsn.vObj['contact']);{q}
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpointObject := ParseUri(jsn['endpoint'], jsn.vObj['_endpoint']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderSource(json : TJSONWriter; name : string; elem : TFhirMessageHeaderSource);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeStringValue(json, 'software', elem.softwareObject, false);
  ComposeStringProps(json, 'software', elem.softwareObject, false);
  ComposeStringValue(json, 'version', elem.versionObject, false);
  ComposeStringProps(json, 'version', elem.versionObject, false);
  ComposeContactPoint(json, 'contact', elem.contact); {a}
  ComposeUriValue(json, 'endpoint', elem.endpointObject, false);
  ComposeUriProps(json, 'endpoint', elem.endpointObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseMessageHeaderDestination(element : IXmlDomElement; path : string) : TFhirMessageHeaderDestination;
var
  child : IXMLDOMElement;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirDevice}(child, path+'/target') {b}
      else if (child.baseName = 'endpoint') then
        result.endpointObject := ParseUri(child, path+'/endpoint') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderDestination(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderDestination);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeReference{TFhirDevice}(xml, 'target', elem.target);{x.2}
  ComposeUri(xml, 'endpoint', elem.endpointObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMessageHeaderDestination(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderDestination(jsn));
end;

function TFHIRJsonParser.ParseMessageHeaderDestination(jsn : TJsonObject) : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirDevice}(jsn.vObj['target']);{q}
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpointObject := ParseUri(jsn['endpoint'], jsn.vObj['_endpoint']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderDestination(json : TJSONWriter; name : string; elem : TFhirMessageHeaderDestination);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeReference{TFhirDevice}(json, 'target', elem.target); {a}
  ComposeUriValue(json, 'endpoint', elem.endpointObject, false);
  ComposeUriProps(json, 'endpoint', elem.endpointObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseMessageHeader(element : IXmlDomElement; path : string) : TFhirMessageHeader;
var
  child : IXMLDOMElement;
begin
  result := TFhirMessageHeader.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierObject := ParseId(child, path+'/identifier') {b}
      else if (child.baseName = 'timestamp') then
        result.timestampObject := ParseInstant(child, path+'/timestamp') {b}
      else if (child.baseName = 'event') then
        result.event := ParseCoding(child, path+'/event') {b}
      else if (child.baseName = 'response') then
        result.response := ParseMessageHeaderResponse(child, path+'/response') {b}
      else if (child.baseName = 'source') then
        result.source := ParseMessageHeaderSource(child, path+'/source') {b}
      else if (child.baseName = 'destination') then
        result.destinationList.Add(ParseMessageHeaderDestination(child, path+'/destination')){y.2}
      else if (child.baseName = 'enterer') then
        result.enterer := ParseReference{TFhirPractitioner}(child, path+'/enterer') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{TFhirPractitioner}(child, path+'/author') {b}
      else if (child.baseName = 'receiver') then
        result.receiver := ParseReference{Resource}(child, path+'/receiver') {b}
      else if (child.baseName = 'responsible') then
        result.responsible := ParseReference{Resource}(child, path+'/responsible') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.baseName = 'data') then
        result.dataList.Add(ParseReference{TFhirReference}(child, path+'/data')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMessageHeader(xml : TXmlBuilder; name : string; elem : TFhirMessageHeader);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeId(xml, 'identifier', elem.identifierObject);{x.2}
  ComposeInstant(xml, 'timestamp', elem.timestampObject);{x.2}
  ComposeCoding(xml, 'event', elem.event);{x.2}
  ComposeMessageHeaderResponse(xml, 'response', elem.response);{x.2}
  ComposeMessageHeaderSource(xml, 'source', elem.source);{x.2}
  for i := 0 to elem.destinationList.Count - 1 do
    ComposeMessageHeaderDestination(xml, 'destination', elem.destinationList[i]);
  ComposeReference{TFhirPractitioner}(xml, 'enterer', elem.enterer);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'author', elem.author);{x.2}
  ComposeReference{Resource}(xml, 'receiver', elem.receiver);{x.2}
  ComposeReference{Resource}(xml, 'responsible', elem.responsible);{x.2}
  ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2}
  for i := 0 to elem.dataList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'data', elem.dataList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMessageHeader(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeader(jsn));
end;

function TFHIRJsonParser.ParseMessageHeader(jsn : TJsonObject) : TFhirMessageHeader;
begin
  result := TFhirMessageHeader.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierObject := ParseId(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('timestamp') or jsn.has('_timestamp') then
        result.timestampObject := ParseInstant(jsn['timestamp'], jsn.vObj['_timestamp']);{q}
    if jsn.has('event') then
        result.event := ParseCoding(jsn.vObj['event']);{q}
    if jsn.has('response') then
        result.response := ParseMessageHeaderResponse(jsn.vObj['response']);{q}
    if jsn.has('source') then
        result.source := ParseMessageHeaderSource(jsn.vObj['source']);{q}
    if jsn.has('destination') then
      iterateArray(jsn.vArr['destination'], result.destinationList, parseMessageHeaderDestination);
    if jsn.has('enterer') then
        result.enterer := ParseReference{TFhirPractitioner}(jsn.vObj['enterer']);{q}
    if jsn.has('author') then
        result.author := ParseReference{TFhirPractitioner}(jsn.vObj['author']);{q}
    if jsn.has('receiver') then
        result.receiver := ParseReference{Resource}(jsn.vObj['receiver']);{q}
    if jsn.has('responsible') then
        result.responsible := ParseReference{Resource}(jsn.vObj['responsible']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    if jsn.has('data') then
      iterateArray(jsn.vArr['data'], result.dataList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMessageHeader(json : TJSONWriter; name : string; elem : TFhirMessageHeader);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeIdValue(json, 'identifier', elem.identifierObject, false);
  ComposeIdProps(json, 'identifier', elem.identifierObject, false);
  ComposeInstantValue(json, 'timestamp', elem.timestampObject, false);
  ComposeInstantProps(json, 'timestamp', elem.timestampObject, false);
  ComposeCoding(json, 'event', elem.event); {a}
  ComposeMessageHeaderResponse(json, 'response', elem.response); {a}
  ComposeMessageHeaderSource(json, 'source', elem.source); {a}
  if elem.destinationList.Count > 0 then
  begin
    json.valueArray('destination');
    for i := 0 to elem.destinationList.Count - 1 do
      ComposeMessageHeaderDestination(json, '',elem.destinationList[i]); {z - }
    json.FinishArray;
  end;
  ComposeReference{TFhirPractitioner}(json, 'enterer', elem.enterer); {a}
  ComposeReference{TFhirPractitioner}(json, 'author', elem.author); {a}
  ComposeReference{Resource}(json, 'receiver', elem.receiver); {a}
  ComposeReference{Resource}(json, 'responsible', elem.responsible); {a}
  ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if elem.dataList.Count > 0 then
  begin
    json.valueArray('data');
    for i := 0 to elem.dataList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.dataList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseNamespaceUniqueId(element : IXmlDomElement; path : string) : TFhirNamespaceUniqueId;
var
  child : IXMLDOMElement;
begin
  result := TFhirNamespaceUniqueId.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Object := ParseEnum(CODES_TFhirNamespaceIdentifierType, path+'/type', child){1a}
      else if (child.baseName = 'value') then
        result.valueObject := ParseString(child, path+'/value') {b}
      else if (child.baseName = 'preferred') then
        result.preferredObject := ParseBoolean(child, path+'/preferred') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNamespaceUniqueId(xml : TXmlBuilder; name : string; elem : TFhirNamespaceUniqueId);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Object, CODES_TFhirNamespaceIdentifierType);
  ComposeString(xml, 'value', elem.valueObject);{x.2}
  ComposeBoolean(xml, 'preferred', elem.preferredObject);{x.2}
  ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNamespaceUniqueId(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNamespaceUniqueId(jsn));
end;

function TFHIRJsonParser.ParseNamespaceUniqueId(jsn : TJsonObject) : TFhirNamespaceUniqueId;
begin
  result := TFhirNamespaceUniqueId.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Object := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirNamespaceIdentifierType);
    if jsn.has('value') or jsn.has('_value') then
        result.valueObject := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    if jsn.has('preferred') or jsn.has('_preferred') then
        result.preferredObject := ParseBoolean(jsn['preferred'], jsn.vObj['_preferred']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNamespaceUniqueId(json : TJSONWriter; name : string; elem : TFhirNamespaceUniqueId);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Object, CODES_TFhirNamespaceIdentifierType, false);
  ComposeEnumProps(json, 'type', elem.Type_Object, CODES_TFhirNamespaceIdentifierType, false);
  ComposeStringValue(json, 'value', elem.valueObject, false);
  ComposeStringProps(json, 'value', elem.valueObject, false);
  ComposeBooleanValue(json, 'preferred', elem.preferredObject, false);
  ComposeBooleanProps(json, 'preferred', elem.preferredObject, false);
  ComposePeriod(json, 'period', elem.period); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseNamespaceContact(element : IXmlDomElement; path : string) : TFhirNamespaceContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirNamespaceContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseHumanName(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNamespaceContact(xml : TXmlBuilder; name : string; elem : TFhirNamespaceContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeHumanName(xml, 'name', elem.name);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNamespaceContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNamespaceContact(jsn));
end;

function TFHIRJsonParser.ParseNamespaceContact(jsn : TJsonObject) : TFhirNamespaceContact;
begin
  result := TFhirNamespaceContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNamespaceContact(json : TJSONWriter; name : string; elem : TFhirNamespaceContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeHumanName(json, 'name', elem.name); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseNamespace(element : IXmlDomElement; path : string) : TFhirNamespace;
var
  child : IXMLDOMElement;
begin
  result := TFhirNamespace.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Object := ParseEnum(CODES_TFhirNamespaceType, path+'/type', child){1a}
      else if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirNamespaceStatus, path+'/status', child){1a}
      else if (child.baseName = 'country') then
        result.countryObject := ParseCode(child, path+'/country') {b}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'responsible') then
        result.responsibleObject := ParseString(child, path+'/responsible') {b}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'usage') then
        result.usageObject := ParseString(child, path+'/usage') {b}
      else if (child.baseName = 'uniqueId') then
        result.uniqueIdList.Add(ParseNamespaceUniqueId(child, path+'/uniqueId')){y.2}
      else if (child.baseName = 'contact') then
        result.contact := ParseNamespaceContact(child, path+'/contact') {b}
      else if (child.baseName = 'replacedBy') then
        result.replacedBy := ParseReference{TFhirNamespace}(child, path+'/replacedBy') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNamespace(xml : TXmlBuilder; name : string; elem : TFhirNamespace);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Object, CODES_TFhirNamespaceType);
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirNamespaceStatus);
  ComposeCode(xml, 'country', elem.countryObject);{x.2}
  ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  ComposeString(xml, 'responsible', elem.responsibleObject);{x.2}
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  ComposeString(xml, 'usage', elem.usageObject);{x.2}
  for i := 0 to elem.uniqueIdList.Count - 1 do
    ComposeNamespaceUniqueId(xml, 'uniqueId', elem.uniqueIdList[i]);
  ComposeNamespaceContact(xml, 'contact', elem.contact);{x.2}
  ComposeReference{TFhirNamespace}(xml, 'replacedBy', elem.replacedBy);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNamespace(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNamespace(jsn));
end;

function TFHIRJsonParser.ParseNamespace(jsn : TJsonObject) : TFhirNamespace;
begin
  result := TFhirNamespace.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Object := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirNamespaceType);
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirNamespaceStatus);
    if jsn.has('country') or jsn.has('_country') then
        result.countryObject := ParseCode(jsn['country'], jsn.vObj['_country']);{q}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('responsible') or jsn.has('_responsible') then
        result.responsibleObject := ParseString(jsn['responsible'], jsn.vObj['_responsible']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('usage') or jsn.has('_usage') then
        result.usageObject := ParseString(jsn['usage'], jsn.vObj['_usage']);{q}
    if jsn.has('uniqueId') then
      iterateArray(jsn.vArr['uniqueId'], result.uniqueIdList, parseNamespaceUniqueId);
    if jsn.has('contact') then
        result.contact := ParseNamespaceContact(jsn.vObj['contact']);{q}
    if jsn.has('replacedBy') then
        result.replacedBy := ParseReference{TFhirNamespace}(jsn.vObj['replacedBy']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNamespace(json : TJSONWriter; name : string; elem : TFhirNamespace);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Object, CODES_TFhirNamespaceType, false);
  ComposeEnumProps(json, 'type', elem.Type_Object, CODES_TFhirNamespaceType, false);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirNamespaceStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirNamespaceStatus, false);
  ComposeCodeValue(json, 'country', elem.countryObject, false);
  ComposeCodeProps(json, 'country', elem.countryObject, false);
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeStringValue(json, 'responsible', elem.responsibleObject, false);
  ComposeStringProps(json, 'responsible', elem.responsibleObject, false);
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  ComposeStringValue(json, 'usage', elem.usageObject, false);
  ComposeStringProps(json, 'usage', elem.usageObject, false);
  if elem.uniqueIdList.Count > 0 then
  begin
    json.valueArray('uniqueId');
    for i := 0 to elem.uniqueIdList.Count - 1 do
      ComposeNamespaceUniqueId(json, '',elem.uniqueIdList[i]); {z - }
    json.FinishArray;
  end;
  ComposeNamespaceContact(json, 'contact', elem.contact); {a}
  ComposeReference{TFhirNamespace}(json, 'replacedBy', elem.replacedBy); {a}
end;

function TFHIRXmlParser.ParseNutritionOrderItem(element : IXmlDomElement; path : string) : TFhirNutritionOrderItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrderItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'scheduledTiming') then
        result.scheduled := ParseTiming(child, path+'/scheduledTiming'){x.3}
      else if (child.baseName = 'scheduledPeriod') then
        result.scheduled := ParsePeriod(child, path+'/scheduledPeriod'){x.3}
      else if (child.baseName = 'isInEffect') then
        result.isInEffectObject := ParseBoolean(child, path+'/isInEffect') {b}
      else if (child.baseName = 'oralDiet') then
        result.oralDiet := ParseNutritionOrderItemOralDiet(child, path+'/oralDiet') {b}
      else if (child.baseName = 'supplement') then
        result.supplement := ParseNutritionOrderItemSupplement(child, path+'/supplement') {b}
      else if (child.baseName = 'enteralFormula') then
        result.enteralFormula := ParseNutritionOrderItemEnteralFormula(child, path+'/enteralFormula') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderItem(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (elem.scheduled is TFhirTiming) {6} then
    ComposeTiming(xml, 'scheduledTiming', TFhirTiming(elem.scheduled))
  else if (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(xml, 'scheduledPeriod', TFhirPeriod(elem.scheduled));
  ComposeBoolean(xml, 'isInEffect', elem.isInEffectObject);{x.2}
  ComposeNutritionOrderItemOralDiet(xml, 'oralDiet', elem.oralDiet);{x.2}
  ComposeNutritionOrderItemSupplement(xml, 'supplement', elem.supplement);{x.2}
  ComposeNutritionOrderItemEnteralFormula(xml, 'enteralFormula', elem.enteralFormula);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrderItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderItem(jsn));
end;

function TFHIRJsonParser.ParseNutritionOrderItem(jsn : TJsonObject) : TFhirNutritionOrderItem;
begin
  result := TFhirNutritionOrderItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('scheduledTiming') {a4} then
      result.scheduled := ParseTiming(jsn.vObj['scheduledTiming']);
    if jsn.has('scheduledPeriod') {a4} then
      result.scheduled := ParsePeriod(jsn.vObj['scheduledPeriod']);
    if jsn.has('isInEffect') or jsn.has('_isInEffect') then
        result.isInEffectObject := ParseBoolean(jsn['isInEffect'], jsn.vObj['_isInEffect']);{q}
    if jsn.has('oralDiet') then
        result.oralDiet := ParseNutritionOrderItemOralDiet(jsn.vObj['oralDiet']);{q}
    if jsn.has('supplement') then
        result.supplement := ParseNutritionOrderItemSupplement(jsn.vObj['supplement']);{q}
    if jsn.has('enteralFormula') then
        result.enteralFormula := ParseNutritionOrderItemEnteralFormula(jsn.vObj['enteralFormula']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderItem(json : TJSONWriter; name : string; elem : TFhirNutritionOrderItem);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.scheduled is TFhirTiming) then 
    ComposeTiming(json, 'scheduledTiming', TFhirTiming(elem.scheduled)) 
  else if (elem.scheduled is TFhirPeriod) then 
    ComposePeriod(json, 'scheduledPeriod', TFhirPeriod(elem.scheduled)) ;
  ComposeBooleanValue(json, 'isInEffect', elem.isInEffectObject, false);
  ComposeBooleanProps(json, 'isInEffect', elem.isInEffectObject, false);
  ComposeNutritionOrderItemOralDiet(json, 'oralDiet', elem.oralDiet); {a}
  ComposeNutritionOrderItemSupplement(json, 'supplement', elem.supplement); {a}
  ComposeNutritionOrderItemEnteralFormula(json, 'enteralFormula', elem.enteralFormula); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseNutritionOrderItemOralDiet(element : IXmlDomElement; path : string) : TFhirNutritionOrderItemOralDiet;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrderItemOralDiet.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeList.Add(ParseCodeableConcept(child, path+'/code')){y.2}
      else if (child.baseName = 'nutrientModifier') then
        result.nutrientModifierList.Add(ParseCodeableConcept(child, path+'/nutrientModifier')){y.2}
      else if (child.baseName = 'nutrientAmountQuantity') then
        result.nutrientAmount := ParseQuantity(child, path+'/nutrientAmountQuantity'){x.3}
      else if (child.baseName = 'nutrientAmountRange') then
        result.nutrientAmount := ParseRange(child, path+'/nutrientAmountRange'){x.3}
      else if (child.baseName = 'textureModifier') then
        result.textureModifierList.Add(ParseCodeableConcept(child, path+'/textureModifier')){y.2}
      else if (child.baseName = 'foodType') then
        result.foodTypeList.Add(ParseCodeableConcept(child, path+'/foodType')){y.2}
      else if (child.baseName = 'fluidConsistencyType') then
        result.fluidConsistencyTypeList.Add(ParseCodeableConcept(child, path+'/fluidConsistencyType')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderItemOralDiet(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderItemOralDiet);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.codeList.Count - 1 do
    ComposeCodeableConcept(xml, 'code', elem.codeList[i]);
  for i := 0 to elem.nutrientModifierList.Count - 1 do
    ComposeCodeableConcept(xml, 'nutrientModifier', elem.nutrientModifierList[i]);
  if (elem.nutrientAmount is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'nutrientAmountQuantity', TFhirQuantity(elem.nutrientAmount))
  else if (elem.nutrientAmount is TFhirRange) {6} then
    ComposeRange(xml, 'nutrientAmountRange', TFhirRange(elem.nutrientAmount));
  for i := 0 to elem.textureModifierList.Count - 1 do
    ComposeCodeableConcept(xml, 'textureModifier', elem.textureModifierList[i]);
  for i := 0 to elem.foodTypeList.Count - 1 do
    ComposeCodeableConcept(xml, 'foodType', elem.foodTypeList[i]);
  for i := 0 to elem.fluidConsistencyTypeList.Count - 1 do
    ComposeCodeableConcept(xml, 'fluidConsistencyType', elem.fluidConsistencyTypeList[i]);
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrderItemOralDiet(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderItemOralDiet(jsn));
end;

function TFHIRJsonParser.ParseNutritionOrderItemOralDiet(jsn : TJsonObject) : TFhirNutritionOrderItemOralDiet;
begin
  result := TFhirNutritionOrderItemOralDiet.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCodeableConcept);
    if jsn.has('nutrientModifier') then
      iterateArray(jsn.vArr['nutrientModifier'], result.nutrientModifierList, parseCodeableConcept);
    if jsn.has('nutrientAmountQuantity') {a4} then
      result.nutrientAmount := ParseQuantity(jsn.vObj['nutrientAmountQuantity']);
    if jsn.has('nutrientAmountRange') {a4} then
      result.nutrientAmount := ParseRange(jsn.vObj['nutrientAmountRange']);
    if jsn.has('textureModifier') then
      iterateArray(jsn.vArr['textureModifier'], result.textureModifierList, parseCodeableConcept);
    if jsn.has('foodType') then
      iterateArray(jsn.vArr['foodType'], result.foodTypeList, parseCodeableConcept);
    if jsn.has('fluidConsistencyType') then
      iterateArray(jsn.vArr['fluidConsistencyType'], result.fluidConsistencyTypeList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderItemOralDiet(json : TJSONWriter; name : string; elem : TFhirNutritionOrderItemOralDiet);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.codeList.Count > 0 then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.codeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.nutrientModifierList.Count > 0 then
  begin
    json.valueArray('nutrientModifier');
    for i := 0 to elem.nutrientModifierList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.nutrientModifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (elem.nutrientAmount is TFhirQuantity) then 
    ComposeQuantity(json, 'nutrientAmountQuantity', TFhirQuantity(elem.nutrientAmount)) 
  else if (elem.nutrientAmount is TFhirRange) then 
    ComposeRange(json, 'nutrientAmountRange', TFhirRange(elem.nutrientAmount)) ;
  if elem.textureModifierList.Count > 0 then
  begin
    json.valueArray('textureModifier');
    for i := 0 to elem.textureModifierList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.textureModifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.foodTypeList.Count > 0 then
  begin
    json.valueArray('foodType');
    for i := 0 to elem.foodTypeList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.foodTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.fluidConsistencyTypeList.Count > 0 then
  begin
    json.valueArray('fluidConsistencyType');
    for i := 0 to elem.fluidConsistencyTypeList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.fluidConsistencyTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseNutritionOrderItemSupplement(element : IXmlDomElement; path : string) : TFhirNutritionOrderItemSupplement;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrderItemSupplement.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderItemSupplement(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderItemSupplement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrderItemSupplement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderItemSupplement(jsn));
end;

function TFHIRJsonParser.ParseNutritionOrderItemSupplement(jsn : TJsonObject) : TFhirNutritionOrderItemSupplement;
begin
  result := TFhirNutritionOrderItemSupplement.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderItemSupplement(json : TJSONWriter; name : string; elem : TFhirNutritionOrderItemSupplement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '',elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseNutritionOrderItemEnteralFormula(element : IXmlDomElement; path : string) : TFhirNutritionOrderItemEnteralFormula;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrderItemEnteralFormula.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'baseFormulaType') then
        result.baseFormulaType := ParseCodeableConcept(child, path+'/baseFormulaType') {b}
      else if (child.baseName = 'additiveType') then
        result.additiveTypeList.Add(ParseCodeableConcept(child, path+'/additiveType')){y.2}
      else if (child.baseName = 'caloricDensity') then
        result.caloricDensityList.Add(ParseQuantity(child, path+'/caloricDensity')){y.2}
      else if (child.baseName = 'routeofAdministration') then
        result.routeofAdministrationList.Add(ParseCodeableConcept(child, path+'/routeofAdministration')){y.2}
      else if (child.baseName = 'rate') then
        result.rateList.Add(ParseQuantity(child, path+'/rate')){y.2}
      else if (child.baseName = 'baseFormulaName') then
        result.baseFormulaNameObject := ParseString(child, path+'/baseFormulaName') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderItemEnteralFormula(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderItemEnteralFormula);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'baseFormulaType', elem.baseFormulaType);{x.2}
  for i := 0 to elem.additiveTypeList.Count - 1 do
    ComposeCodeableConcept(xml, 'additiveType', elem.additiveTypeList[i]);
  for i := 0 to elem.caloricDensityList.Count - 1 do
    ComposeQuantity(xml, 'caloricDensity', elem.caloricDensityList[i]);
  for i := 0 to elem.routeofAdministrationList.Count - 1 do
    ComposeCodeableConcept(xml, 'routeofAdministration', elem.routeofAdministrationList[i]);
  for i := 0 to elem.rateList.Count - 1 do
    ComposeQuantity(xml, 'rate', elem.rateList[i]);
  ComposeString(xml, 'baseFormulaName', elem.baseFormulaNameObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrderItemEnteralFormula(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderItemEnteralFormula(jsn));
end;

function TFHIRJsonParser.ParseNutritionOrderItemEnteralFormula(jsn : TJsonObject) : TFhirNutritionOrderItemEnteralFormula;
begin
  result := TFhirNutritionOrderItemEnteralFormula.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('baseFormulaType') then
        result.baseFormulaType := ParseCodeableConcept(jsn.vObj['baseFormulaType']);{q}
    if jsn.has('additiveType') then
      iterateArray(jsn.vArr['additiveType'], result.additiveTypeList, parseCodeableConcept);
    if jsn.has('caloricDensity') then
      iterateArray(jsn.vArr['caloricDensity'], result.caloricDensityList, parseQuantity);
    if jsn.has('routeofAdministration') then
      iterateArray(jsn.vArr['routeofAdministration'], result.routeofAdministrationList, parseCodeableConcept);
    if jsn.has('rate') then
      iterateArray(jsn.vArr['rate'], result.rateList, parseQuantity);
    if jsn.has('baseFormulaName') or jsn.has('_baseFormulaName') then
        result.baseFormulaNameObject := ParseString(jsn['baseFormulaName'], jsn.vObj['_baseFormulaName']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderItemEnteralFormula(json : TJSONWriter; name : string; elem : TFhirNutritionOrderItemEnteralFormula);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'baseFormulaType', elem.baseFormulaType); {a}
  if elem.additiveTypeList.Count > 0 then
  begin
    json.valueArray('additiveType');
    for i := 0 to elem.additiveTypeList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.additiveTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.caloricDensityList.Count > 0 then
  begin
    json.valueArray('caloricDensity');
    for i := 0 to elem.caloricDensityList.Count - 1 do
      ComposeQuantity(json, '',elem.caloricDensityList[i]); {z - Quantity}
    json.FinishArray;
  end;
  if elem.routeofAdministrationList.Count > 0 then
  begin
    json.valueArray('routeofAdministration');
    for i := 0 to elem.routeofAdministrationList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.routeofAdministrationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.rateList.Count > 0 then
  begin
    json.valueArray('rate');
    for i := 0 to elem.rateList.Count - 1 do
      ComposeQuantity(json, '',elem.rateList[i]); {z - Quantity}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'baseFormulaName', elem.baseFormulaNameObject, false);
  ComposeStringProps(json, 'baseFormulaName', elem.baseFormulaNameObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseNutritionOrder(element : IXmlDomElement; path : string) : TFhirNutritionOrder;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrder.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'orderer') then
        result.orderer := ParseReference{TFhirPractitioner}(child, path+'/orderer') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'dateTime') then
        result.dateTimeObject := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.baseName = 'allergyIntolerance') then
        result.allergyIntoleranceList.Add(ParseReference{TFhirAllergyIntolerance}(child, path+'/allergyIntolerance')){y.2}
      else if (child.baseName = 'foodPreferenceModifier') then
        result.foodPreferenceModifierList.Add(ParseCodeableConcept(child, path+'/foodPreferenceModifier')){y.2}
      else if (child.baseName = 'excludeFoodModifier') then
        result.excludeFoodModifierList.Add(ParseCodeableConcept(child, path+'/excludeFoodModifier')){y.2}
      else if (child.baseName = 'item') then
        result.itemList.Add(ParseNutritionOrderItem(child, path+'/item')){y.2}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirNutritionOrderStatus, path+'/status', child){1a}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrder(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrder);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'orderer', elem.orderer);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  ComposeDateTime(xml, 'dateTime', elem.dateTimeObject);{x.2}
  for i := 0 to elem.allergyIntoleranceList.Count - 1 do
    ComposeReference{TFhirAllergyIntolerance}(xml, 'allergyIntolerance', elem.allergyIntoleranceList[i]);
  for i := 0 to elem.foodPreferenceModifierList.Count - 1 do
    ComposeCodeableConcept(xml, 'foodPreferenceModifier', elem.foodPreferenceModifierList[i]);
  for i := 0 to elem.excludeFoodModifierList.Count - 1 do
    ComposeCodeableConcept(xml, 'excludeFoodModifier', elem.excludeFoodModifierList[i]);
  for i := 0 to elem.itemList.Count - 1 do
    ComposeNutritionOrderItem(xml, 'item', elem.itemList[i]);
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirNutritionOrderStatus);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrder(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrder(jsn));
end;

function TFHIRJsonParser.ParseNutritionOrder(jsn : TJsonObject) : TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('orderer') then
        result.orderer := ParseReference{TFhirPractitioner}(jsn.vObj['orderer']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeObject := ParseDateTime(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('allergyIntolerance') then
      iterateArray(jsn.vArr['allergyIntolerance'], result.allergyIntoleranceList, parseReference{TFhirAllergyIntolerance});
    if jsn.has('foodPreferenceModifier') then
      iterateArray(jsn.vArr['foodPreferenceModifier'], result.foodPreferenceModifierList, parseCodeableConcept);
    if jsn.has('excludeFoodModifier') then
      iterateArray(jsn.vArr['excludeFoodModifier'], result.excludeFoodModifierList, parseCodeableConcept);
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseNutritionOrderItem);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirNutritionOrderStatus);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrder(json : TJSONWriter; name : string; elem : TFhirNutritionOrder);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeReference{TFhirPractitioner}(json, 'orderer', elem.orderer); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeDateTimeValue(json, 'dateTime', elem.dateTimeObject, false);
  ComposeDateTimeProps(json, 'dateTime', elem.dateTimeObject, false);
  if elem.allergyIntoleranceList.Count > 0 then
  begin
    json.valueArray('allergyIntolerance');
    for i := 0 to elem.allergyIntoleranceList.Count - 1 do
      ComposeReference{TFhirAllergyIntolerance}(json, '',elem.allergyIntoleranceList[i]); {z - Reference(AllergyIntolerance)}
    json.FinishArray;
  end;
  if elem.foodPreferenceModifierList.Count > 0 then
  begin
    json.valueArray('foodPreferenceModifier');
    for i := 0 to elem.foodPreferenceModifierList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.foodPreferenceModifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.excludeFoodModifierList.Count > 0 then
  begin
    json.valueArray('excludeFoodModifier');
    for i := 0 to elem.excludeFoodModifierList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.excludeFoodModifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.itemList.Count > 0 then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeNutritionOrderItem(json, '',elem.itemList[i]); {z - }
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirNutritionOrderStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirNutritionOrderStatus, false);
end;

function TFHIRXmlParser.ParseObservationReferenceRange(element : IXmlDomElement; path : string) : TFhirObservationReferenceRange;
var
  child : IXMLDOMElement;
begin
  result := TFhirObservationReferenceRange.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'low') then
        result.low := ParseQuantity(child, path+'/low') {b}
      else if (child.baseName = 'high') then
        result.high := ParseQuantity(child, path+'/high') {b}
      else if (child.baseName = 'meaning') then
        result.meaning := ParseCodeableConcept(child, path+'/meaning') {b}
      else if (child.baseName = 'age') then
        result.age := ParseRange(child, path+'/age') {b}
      else if (child.baseName = 'text') then
        result.textObject := ParseString(child, path+'/text') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeObservationReferenceRange(xml : TXmlBuilder; name : string; elem : TFhirObservationReferenceRange);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeQuantity(xml, 'low', elem.low);{x.2}
  ComposeQuantity(xml, 'high', elem.high);{x.2}
  ComposeCodeableConcept(xml, 'meaning', elem.meaning);{x.2}
  ComposeRange(xml, 'age', elem.age);{x.2}
  ComposeString(xml, 'text', elem.textObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseObservationReferenceRange(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservationReferenceRange(jsn));
end;

function TFHIRJsonParser.ParseObservationReferenceRange(jsn : TJsonObject) : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('low') then
        result.low := ParseQuantity(jsn.vObj['low']);{q}
    if jsn.has('high') then
        result.high := ParseQuantity(jsn.vObj['high']);{q}
    if jsn.has('meaning') then
        result.meaning := ParseCodeableConcept(jsn.vObj['meaning']);{q}
    if jsn.has('age') then
        result.age := ParseRange(jsn.vObj['age']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textObject := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeObservationReferenceRange(json : TJSONWriter; name : string; elem : TFhirObservationReferenceRange);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeQuantity(json, 'low', elem.low); {a}
  ComposeQuantity(json, 'high', elem.high); {a}
  ComposeCodeableConcept(json, 'meaning', elem.meaning); {a}
  ComposeRange(json, 'age', elem.age); {a}
  ComposeStringValue(json, 'text', elem.textObject, false);
  ComposeStringProps(json, 'text', elem.textObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseObservationRelated(element : IXmlDomElement; path : string) : TFhirObservationRelated;
var
  child : IXMLDOMElement;
begin
  result := TFhirObservationRelated.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Object := ParseEnum(CODES_TFhirObservationRelationshiptypes, path+'/type', child){1a}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirObservation}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeObservationRelated(xml : TXmlBuilder; name : string; elem : TFhirObservationRelated);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Object, CODES_TFhirObservationRelationshiptypes);
  ComposeReference{TFhirObservation}(xml, 'target', elem.target);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseObservationRelated(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservationRelated(jsn));
end;

function TFHIRJsonParser.ParseObservationRelated(jsn : TJsonObject) : TFhirObservationRelated;
begin
  result := TFhirObservationRelated.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Object := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirObservationRelationshiptypes);
    if jsn.has('target') then
        result.target := ParseReference{TFhirObservation}(jsn.vObj['target']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeObservationRelated(json : TJSONWriter; name : string; elem : TFhirObservationRelated);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Object, CODES_TFhirObservationRelationshiptypes, false);
  ComposeEnumProps(json, 'type', elem.Type_Object, CODES_TFhirObservationRelationshiptypes, false);
  ComposeReference{TFhirObservation}(json, 'target', elem.target); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseObservation(element : IXmlDomElement; path : string) : TFhirObservation;
var
  child : IXMLDOMElement;
begin
  result := TFhirObservation.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseCodeableConcept(child, path+'/name') {b}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.baseName = 'valueAttachment') then
        result.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.baseName = 'valueRatio') then
        result.value := ParseRatio(child, path+'/valueRatio'){x.3}
      else if (child.baseName = 'valueDateTime') then
        result.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.baseName = 'valuePeriod') then
        result.value := ParsePeriod(child, path+'/valuePeriod'){x.3}
      else if (child.baseName = 'valueSampledData') then
        result.value := ParseSampledData(child, path+'/valueSampledData'){x.3}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.baseName = 'valueTime') then
        result.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.baseName = 'interpretation') then
        result.interpretation := ParseCodeableConcept(child, path+'/interpretation') {b}
      else if (child.baseName = 'comments') then
        result.commentsObject := ParseString(child, path+'/comments') {b}
      else if (child.baseName = 'appliesDateTime') then
        result.applies := ParseDateTime(child, path+'/appliesDateTime'){x.3}
      else if (child.baseName = 'appliesPeriod') then
        result.applies := ParsePeriod(child, path+'/appliesPeriod'){x.3}
      else if (child.baseName = 'issued') then
        result.issuedObject := ParseInstant(child, path+'/issued') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirObservationStatus, path+'/status', child){1a}
      else if (child.baseName = 'reliability') then
        result.reliabilityObject := ParseEnum(CODES_TFhirObservationReliability, path+'/reliability', child){1a}
      else if (child.baseName = 'bodySite') then
        result.bodySite := ParseCodeableConcept(child, path+'/bodySite') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'specimen') then
        result.specimen := ParseReference{TFhirSpecimen}(child, path+'/specimen') {b}
      else if (child.baseName = 'performer') then
        result.performerList.Add(ParseReference{Resource}(child, path+'/performer')){y.2}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'referenceRange') then
        result.referenceRangeList.Add(ParseObservationReferenceRange(child, path+'/referenceRange')){y.2}
      else if (child.baseName = 'related') then
        result.relatedList.Add(ParseObservationRelated(child, path+'/related')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeObservation(xml : TXmlBuilder; name : string; elem : TFhirObservation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeCodeableConcept(xml, 'name', elem.name);{x.2}
  if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (elem.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value));
  ComposeCodeableConcept(xml, 'interpretation', elem.interpretation);{x.2}
  ComposeString(xml, 'comments', elem.commentsObject);{x.2}
  if (elem.applies is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'appliesDateTime', TFhirDateTime(elem.applies))
  else if (elem.applies is TFhirPeriod) {6} then
    ComposePeriod(xml, 'appliesPeriod', TFhirPeriod(elem.applies));
  ComposeInstant(xml, 'issued', elem.issuedObject);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirObservationStatus);
  ComposeEnum(xml, 'reliability', elem.ReliabilityObject, CODES_TFhirObservationReliability);
  ComposeCodeableConcept(xml, 'bodySite', elem.bodySite);{x.2}
  ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimen);{x.2}
  for i := 0 to elem.performerList.Count - 1 do
    ComposeReference{Resource}(xml, 'performer', elem.performerList[i]);
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  for i := 0 to elem.referenceRangeList.Count - 1 do
    ComposeObservationReferenceRange(xml, 'referenceRange', elem.referenceRangeList[i]);
  for i := 0 to elem.relatedList.Count - 1 do
    ComposeObservationRelated(xml, 'related', elem.relatedList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseObservation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservation(jsn));
end;

function TFHIRJsonParser.ParseObservation(jsn : TJsonObject) : TFhirObservation;
begin
  result := TFhirObservation.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('name') then
        result.name := ParseCodeableConcept(jsn.vObj['name']);{q}
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueRatio') {a4} then
      result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valuePeriod') {a4} then
      result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueSampledData') {a4} then
      result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('interpretation') then
        result.interpretation := ParseCodeableConcept(jsn.vObj['interpretation']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsObject := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    if jsn.has('appliesDateTime') or jsn.has('_appliesDateTime') then
      result.applies := parseDateTime(jsn['appliesDateTime'], jsn.vObj['_appliesDateTime']);
    if jsn.has('appliesPeriod') {a4} then
      result.applies := ParsePeriod(jsn.vObj['appliesPeriod']);
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedObject := ParseInstant(jsn['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirObservationStatus);
    if jsn.has('reliability') or jsn.has('_reliability')  then
      result.reliabilityObject := parseEnum(jsn['reliability'], jsn.vObj['_reliability'], CODES_TFhirObservationReliability);
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('specimen') then
        result.specimen := ParseReference{TFhirSpecimen}(jsn.vObj['specimen']);{q}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseReference{Resource});
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('referenceRange') then
      iterateArray(jsn.vArr['referenceRange'], result.referenceRangeList, parseObservationReferenceRange);
    if jsn.has('related') then
      iterateArray(jsn.vArr['related'], result.relatedList, parseObservationRelated);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeObservation(json : TJSONWriter; name : string; elem : TFhirObservation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeCodeableConcept(json, 'name', elem.name); {a}
  if (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (elem.value is TFhirRatio) then 
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value)) 
  else if (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end
  else if (elem.value is TFhirPeriod) then 
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value)) 
  else if (elem.value is TFhirSampledData) then 
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value)) 
  else if (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end;
  ComposeCodeableConcept(json, 'interpretation', elem.interpretation); {a}
  ComposeStringValue(json, 'comments', elem.commentsObject, false);
  ComposeStringProps(json, 'comments', elem.commentsObject, false);
  if (elem.applies is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'appliesDateTime', TFhirDateTime(elem.applies), false);
    ComposeDateTimeProps(json, 'appliesDateTime', TFhirDateTime(elem.applies), false);
  end
  else if (elem.applies is TFhirPeriod) then 
    ComposePeriod(json, 'appliesPeriod', TFhirPeriod(elem.applies)) ;
  ComposeInstantValue(json, 'issued', elem.issuedObject, false);
  ComposeInstantProps(json, 'issued', elem.issuedObject, false);
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirObservationStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirObservationStatus, false);
  ComposeEnumValue(json, 'reliability', elem.ReliabilityObject, CODES_TFhirObservationReliability, false);
  ComposeEnumProps(json, 'reliability', elem.ReliabilityObject, CODES_TFhirObservationReliability, false);
  ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeReference{TFhirSpecimen}(json, 'specimen', elem.specimen); {a}
  if elem.performerList.Count > 0 then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.performerList[i]); {z - Reference(Practitioner|Device|Organization|Patient)}
    json.FinishArray;
  end;
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if elem.referenceRangeList.Count > 0 then
  begin
    json.valueArray('referenceRange');
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(json, '',elem.referenceRangeList[i]); {z - }
    json.FinishArray;
  end;
  if elem.relatedList.Count > 0 then
  begin
    json.valueArray('related');
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeObservationRelated(json, '',elem.relatedList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseOperationDefinitionParameter(element : IXmlDomElement; path : string) : TFhirOperationDefinitionParameter;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationDefinitionParameter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameObject := ParseCode(child, path+'/name') {b}
      else if (child.baseName = 'use') then
        result.useObject := ParseEnum(CODES_TFhirOperationParameterUse, path+'/use', child){1a}
      else if (child.baseName = 'min') then
        result.minObject := ParseInteger(child, path+'/min') {b}
      else if (child.baseName = 'max') then
        result.maxObject := ParseString(child, path+'/max') {b}
      else if (child.baseName = 'documentation') then
        result.documentationObject := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'profile') then
        result.profile := ParseReference{TFhirProfile}(child, path+'/profile') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameter(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionParameter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'name', elem.nameObject);{x.2}
  ComposeEnum(xml, 'use', elem.UseObject, CODES_TFhirOperationParameterUse);
  ComposeInteger(xml, 'min', elem.minObject);{x.2}
  ComposeString(xml, 'max', elem.maxObject);{x.2}
  ComposeString(xml, 'documentation', elem.documentationObject);{x.2}
  ComposeCoding(xml, 'type', elem.type_);{x.2}
  ComposeReference{TFhirProfile}(xml, 'profile', elem.profile);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationDefinitionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinitionParameter(jsn));
end;

function TFHIRJsonParser.ParseOperationDefinitionParameter(jsn : TJsonObject) : TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseCode(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('use') or jsn.has('_use')  then
      result.useObject := parseEnum(jsn['use'], jsn.vObj['_use'], CODES_TFhirOperationParameterUse);
    if jsn.has('min') or jsn.has('_min') then
        result.minObject := ParseInteger(jsn['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxObject := ParseString(jsn['max'], jsn.vObj['_max']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationObject := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('profile') then
        result.profile := ParseReference{TFhirProfile}(jsn.vObj['profile']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationDefinitionParameter(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameter);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'name', elem.nameObject, false);
  ComposeCodeProps(json, 'name', elem.nameObject, false);
  ComposeEnumValue(json, 'use', elem.UseObject, CODES_TFhirOperationParameterUse, false);
  ComposeEnumProps(json, 'use', elem.UseObject, CODES_TFhirOperationParameterUse, false);
  ComposeIntegerValue(json, 'min', elem.minObject, false);
  ComposeIntegerProps(json, 'min', elem.minObject, false);
  ComposeStringValue(json, 'max', elem.maxObject, false);
  ComposeStringProps(json, 'max', elem.maxObject, false);
  ComposeStringValue(json, 'documentation', elem.documentationObject, false);
  ComposeStringProps(json, 'documentation', elem.documentationObject, false);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeReference{TFhirProfile}(json, 'profile', elem.profile); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseOperationDefinition(element : IXmlDomElement; path : string) : TFhirOperationDefinition;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationDefinition.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierObject := ParseUri(child, path+'/identifier') {b}
      else if (child.baseName = 'version') then
        result.versionObject := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'title') then
        result.titleObject := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'publisher') then
        result.publisherObject := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'code') then
        result.codeList.Add(ParseCoding(child, path+'/code')){y.2}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirResourceProfileStatus, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalObject := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'kind') then
        result.kindObject := ParseEnum(CODES_TFhirOperationKind, path+'/kind', child){1a}
      else if (child.baseName = 'name') then
        result.nameObject := ParseCode(child, path+'/name') {b}
      else if (child.baseName = 'notes') then
        result.notesObject := ParseString(child, path+'/notes') {b}
      else if (child.baseName = 'base') then
        result.base := ParseReference{TFhirOperationDefinition}(child, path+'/base') {b}
      else if (child.baseName = 'system') then
        result.systemObject := ParseBoolean(child, path+'/system') {b}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseCode(child, path+'/type')){y.2}
      else if (child.baseName = 'instance') then
        result.instanceObject := ParseBoolean(child, path+'/instance') {b}
      else if (child.baseName = 'parameter') then
        result.parameterList.Add(ParseOperationDefinitionParameter(child, path+'/parameter')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinition(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeUri(xml, 'identifier', elem.identifierObject);{x.2}
  ComposeString(xml, 'version', elem.versionObject);{x.2}
  ComposeString(xml, 'title', elem.titleObject);{x.2}
  ComposeString(xml, 'publisher', elem.publisherObject);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  for i := 0 to elem.codeList.Count - 1 do
    ComposeCoding(xml, 'code', elem.codeList[i]);
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirResourceProfileStatus);
  ComposeBoolean(xml, 'experimental', elem.experimentalObject);{x.2}
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  ComposeEnum(xml, 'kind', elem.KindObject, CODES_TFhirOperationKind);
  ComposeCode(xml, 'name', elem.nameObject);{x.2}
  ComposeString(xml, 'notes', elem.notesObject);{x.2}
  ComposeReference{TFhirOperationDefinition}(xml, 'base', elem.base);{x.2}
  ComposeBoolean(xml, 'system', elem.systemObject);{x.2}
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCode(xml, 'type', elem.type_List[i]);
  ComposeBoolean(xml, 'instance', elem.instanceObject);{x.2}
  for i := 0 to elem.parameterList.Count - 1 do
    ComposeOperationDefinitionParameter(xml, 'parameter', elem.parameterList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinition(jsn));
end;

function TFHIRJsonParser.ParseOperationDefinition(jsn : TJsonObject) : TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierObject := ParseUri(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionObject := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleObject := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherObject := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCoding);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirResourceProfileStatus);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalObject := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindObject := parseEnum(jsn['kind'], jsn.vObj['_kind'], CODES_TFhirOperationKind);
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseCode(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesObject := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    if jsn.has('base') then
        result.base := ParseReference{TFhirOperationDefinition}(jsn.vObj['base']);{q}
    if jsn.has('system') or jsn.has('_system') then
        result.systemObject := ParseBoolean(jsn['system'], jsn.vObj['_system']);{q}
      if jsn.has('type') or jsn.has('_type') then
      iteratePrimitiveArray(jsn.vArr['type'], jsn.vArr['_type'], result.type_List, parseCode);
    if jsn.has('instance') or jsn.has('_instance') then
        result.instanceObject := ParseBoolean(jsn['instance'], jsn.vObj['_instance']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseOperationDefinitionParameter);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationDefinition(json : TJSONWriter; name : string; elem : TFhirOperationDefinition);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeUriValue(json, 'identifier', elem.identifierObject, false);
  ComposeUriProps(json, 'identifier', elem.identifierObject, false);
  ComposeStringValue(json, 'version', elem.versionObject, false);
  ComposeStringProps(json, 'version', elem.versionObject, false);
  ComposeStringValue(json, 'title', elem.titleObject, false);
  ComposeStringProps(json, 'title', elem.titleObject, false);
  ComposeStringValue(json, 'publisher', elem.publisherObject, false);
  ComposeStringProps(json, 'publisher', elem.publisherObject, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  if elem.codeList.Count > 0 then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(json, '',elem.codeList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirResourceProfileStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirResourceProfileStatus, false);
  ComposeBooleanValue(json, 'experimental', elem.experimentalObject, false);
  ComposeBooleanProps(json, 'experimental', elem.experimentalObject, false);
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  ComposeEnumValue(json, 'kind', elem.KindObject, CODES_TFhirOperationKind, false);
  ComposeEnumProps(json, 'kind', elem.KindObject, CODES_TFhirOperationKind, false);
  ComposeCodeValue(json, 'name', elem.nameObject, false);
  ComposeCodeProps(json, 'name', elem.nameObject, false);
  ComposeStringValue(json, 'notes', elem.notesObject, false);
  ComposeStringProps(json, 'notes', elem.notesObject, false);
  ComposeReference{TFhirOperationDefinition}(json, 'base', elem.base); {a}
  ComposeBooleanValue(json, 'system', elem.systemObject, false);
  ComposeBooleanProps(json, 'system', elem.systemObject, false);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    ext := false;
    for i := 0 to elem.type_List.Count - 1 do
    begin
      ext := ext or ((elem.type_List[i].xmlid <> '') or (elem.type_List[i].hasExtensions));
      ComposeCodeValue(json, '',elem.type_List[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_type');
      for i := 0 to elem.type_List.Count - 1 do
        ComposeCodeProps(json, '',elem.type_List[i], true);
      json.FinishArray;
    end;
  end;
  ComposeBooleanValue(json, 'instance', elem.instanceObject, false);
  ComposeBooleanProps(json, 'instance', elem.instanceObject, false);
  if elem.parameterList.Count > 0 then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeOperationDefinitionParameter(json, '',elem.parameterList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseOperationOutcomeIssue(element : IXmlDomElement; path : string) : TFhirOperationOutcomeIssue;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'severity') then
        result.severityObject := ParseEnum(CODES_TFhirIssueSeverity, path+'/severity', child){1a}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'details') then
        result.detailsObject := ParseString(child, path+'/details') {b}
      else if (child.baseName = 'location') then
        result.locationList.Add(ParseString(child, path+'/location')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcomeIssue(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcomeIssue);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'severity', elem.SeverityObject, CODES_TFhirIssueSeverity);
  ComposeCoding(xml, 'type', elem.type_);{x.2}
  ComposeString(xml, 'details', elem.detailsObject);{x.2}
  for i := 0 to elem.locationList.Count - 1 do
    ComposeString(xml, 'location', elem.locationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationOutcomeIssue(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationOutcomeIssue(jsn));
end;

function TFHIRJsonParser.ParseOperationOutcomeIssue(jsn : TJsonObject) : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityObject := parseEnum(jsn['severity'], jsn.vObj['_severity'], CODES_TFhirIssueSeverity);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('details') or jsn.has('_details') then
        result.detailsObject := ParseString(jsn['details'], jsn.vObj['_details']);{q}
      if jsn.has('location') or jsn.has('_location') then
      iteratePrimitiveArray(jsn.vArr['location'], jsn.vArr['_location'], result.locationList, parseString);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationOutcomeIssue(json : TJSONWriter; name : string; elem : TFhirOperationOutcomeIssue);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'severity', elem.SeverityObject, CODES_TFhirIssueSeverity, false);
  ComposeEnumProps(json, 'severity', elem.SeverityObject, CODES_TFhirIssueSeverity, false);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeStringValue(json, 'details', elem.detailsObject, false);
  ComposeStringProps(json, 'details', elem.detailsObject, false);
  if elem.locationList.Count > 0 then
  begin
    json.valueArray('location');
    ext := false;
    for i := 0 to elem.locationList.Count - 1 do
    begin
      ext := ext or ((elem.locationList[i].xmlid <> '') or (elem.locationList[i].hasExtensions));
      ComposeStringValue(json, '',elem.locationList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_location');
      for i := 0 to elem.locationList.Count - 1 do
        ComposeStringProps(json, '',elem.locationList[i], true);
      json.FinishArray;
    end;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseOperationOutcome(element : IXmlDomElement; path : string) : TFhirOperationOutcome;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationOutcome.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'issue') then
        result.issueList.Add(ParseOperationOutcomeIssue(child, path+'/issue')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcome(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcome);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.issueList.Count - 1 do
    ComposeOperationOutcomeIssue(xml, 'issue', elem.issueList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationOutcome(jsn));
end;

function TFHIRJsonParser.ParseOperationOutcome(jsn : TJsonObject) : TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('issue') then
      iterateArray(jsn.vArr['issue'], result.issueList, parseOperationOutcomeIssue);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationOutcome(json : TJSONWriter; name : string; elem : TFhirOperationOutcome);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.issueList.Count > 0 then
  begin
    json.valueArray('issue');
    for i := 0 to elem.issueList.Count - 1 do
      ComposeOperationOutcomeIssue(json, '',elem.issueList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseOrderWhen(element : IXmlDomElement; path : string) : TFhirOrderWhen;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrderWhen.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'schedule') then
        result.schedule := ParseTiming(child, path+'/schedule') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrderWhen(xml : TXmlBuilder; name : string; elem : TFhirOrderWhen);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeTiming(xml, 'schedule', elem.schedule);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrderWhen(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrderWhen(jsn));
end;

function TFHIRJsonParser.ParseOrderWhen(jsn : TJsonObject) : TFhirOrderWhen;
begin
  result := TFhirOrderWhen.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('schedule') then
        result.schedule := ParseTiming(jsn.vObj['schedule']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrderWhen(json : TJSONWriter; name : string; elem : TFhirOrderWhen);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeTiming(json, 'schedule', elem.schedule); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseOrder(element : IXmlDomElement; path : string) : TFhirOrder;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrder.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'source') then
        result.source := ParseReference{TFhirPractitioner}(child, path+'/source') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{Resource}(child, path+'/target') {b}
      else if (child.baseName = 'reasonCodeableConcept') then
        result.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.baseName = 'reasonReference') then
        result.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.baseName = 'authority') then
        result.authority := ParseReference{TFhirReference}(child, path+'/authority') {b}
      else if (child.baseName = 'when') then
        result.when := ParseOrderWhen(child, path+'/when') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseReference{TFhirReference}(child, path+'/detail')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrder(xml : TXmlBuilder; name : string; elem : TFhirOrder);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'source', elem.source);{x.2}
  ComposeReference{Resource}(xml, 'target', elem.target);{x.2}
  if (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  ComposeReference{TFhirReference}(xml, 'authority', elem.authority);{x.2}
  ComposeOrderWhen(xml, 'when', elem.when);{x.2}
  for i := 0 to elem.detailList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrder(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrder(jsn));
end;

function TFHIRJsonParser.ParseOrder(jsn : TJsonObject) : TFhirOrder;
begin
  result := TFhirOrder.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('source') then
        result.source := ParseReference{TFhirPractitioner}(jsn.vObj['source']);{q}
    if jsn.has('target') then
        result.target := ParseReference{Resource}(jsn.vObj['target']);{q}
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('authority') then
        result.authority := ParseReference{TFhirReference}(jsn.vObj['authority']);{q}
    if jsn.has('when') then
        result.when := ParseOrderWhen(jsn.vObj['when']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrder(json : TJSONWriter; name : string; elem : TFhirOrder);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeReference{TFhirPractitioner}(json, 'source', elem.source); {a}
  ComposeReference{Resource}(json, 'target', elem.target); {a}
  if (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  ComposeReference{TFhirReference}(json, 'authority', elem.authority); {a}
  ComposeOrderWhen(json, 'when', elem.when); {a}
  if elem.detailList.Count > 0 then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.detailList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseOrderResponse(element : IXmlDomElement; path : string) : TFhirOrderResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrderResponse.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirOrder}(child, path+'/request') {b}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'who') then
        result.who := ParseReference{Resource}(child, path+'/who') {b}
      else if (child.baseName = 'authorityCodeableConcept') then
        result.authority := ParseCodeableConcept(child, path+'/authorityCodeableConcept'){x.3}
      else if (child.baseName = 'authorityReference') then
        result.authority := ParseReference(child, path+'/authorityReference') {a}
      else if (child.baseName = 'code') then
        result.codeObject := ParseEnum(CODES_TFhirOrderOutcomeCode, path+'/code', child){1a}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'fulfillment') then
        result.fulfillmentList.Add(ParseReference{TFhirReference}(child, path+'/fulfillment')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrderResponse(xml : TXmlBuilder; name : string; elem : TFhirOrderResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirOrder}(xml, 'request', elem.request);{x.2}
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  ComposeReference{Resource}(xml, 'who', elem.who);{x.2}
  if (elem.authority is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'authorityCodeableConcept', TFhirCodeableConcept(elem.authority))
  else if (elem.authority is TFhirReference) {2} then
    ComposeReference(xml, 'authorityReference', TFhirReference(elem.authority));
  ComposeEnum(xml, 'code', elem.CodeObject, CODES_TFhirOrderOutcomeCode);
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  for i := 0 to elem.fulfillmentList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'fulfillment', elem.fulfillmentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrderResponse(jsn));
end;

function TFHIRJsonParser.ParseOrderResponse(jsn : TJsonObject) : TFhirOrderResponse;
begin
  result := TFhirOrderResponse.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirOrder}(jsn.vObj['request']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('who') then
        result.who := ParseReference{Resource}(jsn.vObj['who']);{q}
    if jsn.has('authorityCodeableConcept') {a4} then
      result.authority := ParseCodeableConcept(jsn.vObj['authorityCodeableConcept']);
    if jsn.has('authorityReference') {a3} then
      result.authority := ParseReference(jsn.vObj['authorityReference']);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeObject := parseEnum(jsn['code'], jsn.vObj['_code'], CODES_TFhirOrderOutcomeCode);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('fulfillment') then
      iterateArray(jsn.vArr['fulfillment'], result.fulfillmentList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrderResponse(json : TJSONWriter; name : string; elem : TFhirOrderResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirOrder}(json, 'request', elem.request); {a}
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  ComposeReference{Resource}(json, 'who', elem.who); {a}
  if (elem.authority is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'authorityCodeableConcept', TFhirCodeableConcept(elem.authority)) 
  else if (elem.authority is TFhirReference) then
    ComposeReference(json, 'authorityReference', TFhirReference(elem.authority));
  ComposeEnumValue(json, 'code', elem.CodeObject, CODES_TFhirOrderOutcomeCode, false);
  ComposeEnumProps(json, 'code', elem.CodeObject, CODES_TFhirOrderOutcomeCode, false);
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  if elem.fulfillmentList.Count > 0 then
  begin
    json.valueArray('fulfillment');
    for i := 0 to elem.fulfillmentList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.fulfillmentList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseOrganizationContact(element : IXmlDomElement; path : string) : TFhirOrganizationContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrganizationContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'purpose') then
        result.purpose := ParseCodeableConcept(child, path+'/purpose') {b}
      else if (child.baseName = 'name') then
        result.name := ParseHumanName(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'address') then
        result.address := ParseAddress(child, path+'/address') {b}
      else if (child.baseName = 'gender') then
        result.genderObject := ParseEnum(CODES_TFhirAdministrativeGender, path+'/gender', child){1a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrganizationContact(xml : TXmlBuilder; name : string; elem : TFhirOrganizationContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'purpose', elem.purpose);{x.2}
  ComposeHumanName(xml, 'name', elem.name);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeAddress(xml, 'address', elem.address);{x.2}
  ComposeEnum(xml, 'gender', elem.GenderObject, CODES_TFhirAdministrativeGender);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrganizationContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrganizationContact(jsn));
end;

function TFHIRJsonParser.ParseOrganizationContact(jsn : TJsonObject) : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('purpose') then
        result.purpose := ParseCodeableConcept(jsn.vObj['purpose']);{q}
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q}
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderObject := parseEnum(jsn['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGender);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrganizationContact(json : TJSONWriter; name : string; elem : TFhirOrganizationContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'purpose', elem.purpose); {a}
  ComposeHumanName(json, 'name', elem.name); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeAddress(json, 'address', elem.address); {a}
  ComposeEnumValue(json, 'gender', elem.GenderObject, CODES_TFhirAdministrativeGender, false);
  ComposeEnumProps(json, 'gender', elem.GenderObject, CODES_TFhirAdministrativeGender, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseOrganization(element : IXmlDomElement; path : string) : TFhirOrganization;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrganization.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'address') then
        result.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.baseName = 'partOf') then
        result.partOf := ParseReference{TFhirOrganization}(child, path+'/partOf') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseOrganizationContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'location') then
        result.locationList.Add(ParseReference{TFhirLocation}(child, path+'/location')){y.2}
      else if (child.baseName = 'active') then
        result.activeObject := ParseBoolean(child, path+'/active') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrganization(xml : TXmlBuilder; name : string; elem : TFhirOrganization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  for i := 0 to elem.addressList.Count - 1 do
    ComposeAddress(xml, 'address', elem.addressList[i]);
  ComposeReference{TFhirOrganization}(xml, 'partOf', elem.partOf);{x.2}
  for i := 0 to elem.contactList.Count - 1 do
    ComposeOrganizationContact(xml, 'contact', elem.contactList[i]);
  for i := 0 to elem.locationList.Count - 1 do
    ComposeReference{TFhirLocation}(xml, 'location', elem.locationList[i]);
  ComposeBoolean(xml, 'active', elem.activeObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrganization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrganization(jsn));
end;

function TFHIRJsonParser.ParseOrganization(jsn : TJsonObject) : TFhirOrganization;
begin
  result := TFhirOrganization.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('partOf') then
        result.partOf := ParseReference{TFhirOrganization}(jsn.vObj['partOf']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseOrganizationContact);
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseReference{TFhirLocation});
    if jsn.has('active') or jsn.has('_active') then
        result.activeObject := ParseBoolean(jsn['active'], jsn.vObj['_active']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrganization(json : TJSONWriter; name : string; elem : TFhirOrganization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if elem.addressList.Count > 0 then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '',elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  ComposeReference{TFhirOrganization}(json, 'partOf', elem.partOf); {a}
  if elem.contactList.Count > 0 then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOrganizationContact(json, '',elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  if elem.locationList.Count > 0 then
  begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '',elem.locationList[i]); {z - Reference(Location)}
    json.FinishArray;
  end;
  ComposeBooleanValue(json, 'active', elem.activeObject, false);
  ComposeBooleanProps(json, 'active', elem.activeObject, false);
end;

function TFHIRXmlParser.ParseOther(element : IXmlDomElement; path : string) : TFhirOther;
var
  child : IXMLDOMElement;
begin
  result := TFhirOther.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'created') then
        result.createdObject := ParseDate(child, path+'/created') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOther(xml : TXmlBuilder; name : string; elem : TFhirOther);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{Resource}(xml, 'author', elem.author);{x.2}
  ComposeDate(xml, 'created', elem.createdObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOther(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOther(jsn));
end;

function TFHIRJsonParser.ParseOther(jsn : TJsonObject) : TFhirOther;
begin
  result := TFhirOther.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdObject := ParseDate(jsn['created'], jsn.vObj['_created']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOther(json : TJSONWriter; name : string; elem : TFhirOther);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  ComposeReference{Resource}(json, 'author', elem.author); {a}
  ComposeDateValue(json, 'created', elem.createdObject, false);
  ComposeDateProps(json, 'created', elem.createdObject, false);
end;

function TFHIRXmlParser.ParsePatientContact(element : IXmlDomElement; path : string) : TFhirPatientContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatientContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'relationship') then
        result.relationshipList.Add(ParseCodeableConcept(child, path+'/relationship')){y.2}
      else if (child.baseName = 'name') then
        result.name := ParseHumanName(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'address') then
        result.address := ParseAddress(child, path+'/address') {b}
      else if (child.baseName = 'gender') then
        result.genderObject := ParseEnum(CODES_TFhirAdministrativeGender, path+'/gender', child){1a}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatientContact(xml : TXmlBuilder; name : string; elem : TFhirPatientContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.relationshipList.Count - 1 do
    ComposeCodeableConcept(xml, 'relationship', elem.relationshipList[i]);
  ComposeHumanName(xml, 'name', elem.name);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeAddress(xml, 'address', elem.address);{x.2}
  ComposeEnum(xml, 'gender', elem.GenderObject, CODES_TFhirAdministrativeGender);
  ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatientContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientContact(jsn));
end;

function TFHIRJsonParser.ParsePatientContact(jsn : TJsonObject) : TFhirPatientContact;
begin
  result := TFhirPatientContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('relationship') then
      iterateArray(jsn.vArr['relationship'], result.relationshipList, parseCodeableConcept);
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q}
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderObject := parseEnum(jsn['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGender);
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatientContact(json : TJSONWriter; name : string; elem : TFhirPatientContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.relationshipList.Count > 0 then
  begin
    json.valueArray('relationship');
    for i := 0 to elem.relationshipList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.relationshipList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeHumanName(json, 'name', elem.name); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeAddress(json, 'address', elem.address); {a}
  ComposeEnumValue(json, 'gender', elem.GenderObject, CODES_TFhirAdministrativeGender, false);
  ComposeEnumProps(json, 'gender', elem.GenderObject, CODES_TFhirAdministrativeGender, false);
  ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParsePatientAnimal(element : IXmlDomElement; path : string) : TFhirPatientAnimal;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatientAnimal.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'species') then
        result.species := ParseCodeableConcept(child, path+'/species') {b}
      else if (child.baseName = 'breed') then
        result.breed := ParseCodeableConcept(child, path+'/breed') {b}
      else if (child.baseName = 'genderStatus') then
        result.genderStatus := ParseCodeableConcept(child, path+'/genderStatus') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatientAnimal(xml : TXmlBuilder; name : string; elem : TFhirPatientAnimal);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'species', elem.species);{x.2}
  ComposeCodeableConcept(xml, 'breed', elem.breed);{x.2}
  ComposeCodeableConcept(xml, 'genderStatus', elem.genderStatus);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatientAnimal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientAnimal(jsn));
end;

function TFHIRJsonParser.ParsePatientAnimal(jsn : TJsonObject) : TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('species') then
        result.species := ParseCodeableConcept(jsn.vObj['species']);{q}
    if jsn.has('breed') then
        result.breed := ParseCodeableConcept(jsn.vObj['breed']);{q}
    if jsn.has('genderStatus') then
        result.genderStatus := ParseCodeableConcept(jsn.vObj['genderStatus']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatientAnimal(json : TJSONWriter; name : string; elem : TFhirPatientAnimal);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'species', elem.species); {a}
  ComposeCodeableConcept(json, 'breed', elem.breed); {a}
  ComposeCodeableConcept(json, 'genderStatus', elem.genderStatus); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParsePatientLink(element : IXmlDomElement; path : string) : TFhirPatientLink;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatientLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'other') then
        result.other := ParseReference{TFhirPatient}(child, path+'/other') {b}
      else if (child.baseName = 'type') then
        result.type_Object := ParseEnum(CODES_TFhirLinkType, path+'/type', child){1a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatientLink(xml : TXmlBuilder; name : string; elem : TFhirPatientLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirPatient}(xml, 'other', elem.other);{x.2}
  ComposeEnum(xml, 'type', elem.Type_Object, CODES_TFhirLinkType);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatientLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientLink(jsn));
end;

function TFHIRJsonParser.ParsePatientLink(jsn : TJsonObject) : TFhirPatientLink;
begin
  result := TFhirPatientLink.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('other') then
        result.other := ParseReference{TFhirPatient}(jsn.vObj['other']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Object := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirLinkType);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatientLink(json : TJSONWriter; name : string; elem : TFhirPatientLink);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirPatient}(json, 'other', elem.other); {a}
  ComposeEnumValue(json, 'type', elem.Type_Object, CODES_TFhirLinkType, false);
  ComposeEnumProps(json, 'type', elem.Type_Object, CODES_TFhirLinkType, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParsePatient(element : IXmlDomElement; path : string) : TFhirPatient;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatient.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'name') then
        result.nameList.Add(ParseHumanName(child, path+'/name')){y.2}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'gender') then
        result.genderObject := ParseEnum(CODES_TFhirAdministrativeGender, path+'/gender', child){1a}
      else if (child.baseName = 'birthDate') then
        result.birthDateObject := ParseDateTime(child, path+'/birthDate') {b}
      else if (child.baseName = 'deceasedBoolean') then
        result.deceased := ParseBoolean(child, path+'/deceasedBoolean'){x.3}
      else if (child.baseName = 'deceasedDateTime') then
        result.deceased := ParseDateTime(child, path+'/deceasedDateTime'){x.3}
      else if (child.baseName = 'address') then
        result.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.baseName = 'maritalStatus') then
        result.maritalStatus := ParseCodeableConcept(child, path+'/maritalStatus') {b}
      else if (child.baseName = 'multipleBirthBoolean') then
        result.multipleBirth := ParseBoolean(child, path+'/multipleBirthBoolean'){x.3}
      else if (child.baseName = 'multipleBirthInteger') then
        result.multipleBirth := ParseInteger(child, path+'/multipleBirthInteger'){x.3}
      else if (child.baseName = 'photo') then
        result.photoList.Add(ParseAttachment(child, path+'/photo')){y.2}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParsePatientContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'animal') then
        result.animal := ParsePatientAnimal(child, path+'/animal') {b}
      else if (child.baseName = 'communication') then
        result.communicationList.Add(ParseCodeableConcept(child, path+'/communication')){y.2}
      else if (child.baseName = 'careProvider') then
        result.careProviderList.Add(ParseReference{Resource}(child, path+'/careProvider')){y.2}
      else if (child.baseName = 'managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.baseName = 'link') then
        result.link_List.Add(ParsePatientLink(child, path+'/link')){y.2}
      else if (child.baseName = 'active') then
        result.activeObject := ParseBoolean(child, path+'/active') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatient(xml : TXmlBuilder; name : string; elem : TFhirPatient);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  for i := 0 to elem.nameList.Count - 1 do
    ComposeHumanName(xml, 'name', elem.nameList[i]);
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeEnum(xml, 'gender', elem.GenderObject, CODES_TFhirAdministrativeGender);
  ComposeDateTime(xml, 'birthDate', elem.birthDateObject);{x.2}
  if (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'deceasedBoolean', TFhirBoolean(elem.deceased))
  else if (elem.deceased is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'deceasedDateTime', TFhirDateTime(elem.deceased));
  for i := 0 to elem.addressList.Count - 1 do
    ComposeAddress(xml, 'address', elem.addressList[i]);
  ComposeCodeableConcept(xml, 'maritalStatus', elem.maritalStatus);{x.2}
  if (elem.multipleBirth is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth))
  else if (elem.multipleBirth is TFhirInteger) {6} then
    ComposeInteger(xml, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth));
  if not SummaryOnly then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', elem.photoList[i]);
  if not SummaryOnly then
    for i := 0 to elem.contactList.Count - 1 do
      ComposePatientContact(xml, 'contact', elem.contactList[i]);
  ComposePatientAnimal(xml, 'animal', elem.animal);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'communication', elem.communicationList[i]);
  if not SummaryOnly then
    for i := 0 to elem.careProviderList.Count - 1 do
      ComposeReference{Resource}(xml, 'careProvider', elem.careProviderList[i]);
  ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2}
  for i := 0 to elem.link_List.Count - 1 do
    ComposePatientLink(xml, 'link', elem.link_List[i]);
  ComposeBoolean(xml, 'active', elem.activeObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatient(jsn));
end;

function TFHIRJsonParser.ParsePatient(jsn : TJsonObject) : TFhirPatient;
begin
  result := TFhirPatient.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('name') then
      iterateArray(jsn.vArr['name'], result.nameList, parseHumanName);
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderObject := parseEnum(jsn['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGender);
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDateObject := ParseDateTime(jsn['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('deceasedBoolean') or jsn.has('_deceasedBoolean') then
      result.deceased := parseBoolean(jsn['deceasedBoolean'], jsn.vObj['_deceasedBoolean']);
    if jsn.has('deceasedDateTime') or jsn.has('_deceasedDateTime') then
      result.deceased := parseDateTime(jsn['deceasedDateTime'], jsn.vObj['_deceasedDateTime']);
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('maritalStatus') then
        result.maritalStatus := ParseCodeableConcept(jsn.vObj['maritalStatus']);{q}
    if jsn.has('multipleBirthBoolean') or jsn.has('_multipleBirthBoolean') then
      result.multipleBirth := parseBoolean(jsn['multipleBirthBoolean'], jsn.vObj['_multipleBirthBoolean']);
    if jsn.has('multipleBirthInteger') or jsn.has('_multipleBirthInteger') then
      result.multipleBirth := parseInteger(jsn['multipleBirthInteger'], jsn.vObj['_multipleBirthInteger']);
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parsePatientContact);
    if jsn.has('animal') then
        result.animal := ParsePatientAnimal(jsn.vObj['animal']);{q}
    if jsn.has('communication') then
      iterateArray(jsn.vArr['communication'], result.communicationList, parseCodeableConcept);
    if jsn.has('careProvider') then
      iterateArray(jsn.vArr['careProvider'], result.careProviderList, parseReference{Resource});
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q}
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parsePatientLink);
    if jsn.has('active') or jsn.has('_active') then
        result.activeObject := ParseBoolean(jsn['active'], jsn.vObj['_active']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatient(json : TJSONWriter; name : string; elem : TFhirPatient);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if elem.nameList.Count > 0 then
  begin
    json.valueArray('name');
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(json, '',elem.nameList[i]); {z - HumanName}
    json.FinishArray;
  end;
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'gender', elem.GenderObject, CODES_TFhirAdministrativeGender, false);
  ComposeEnumProps(json, 'gender', elem.GenderObject, CODES_TFhirAdministrativeGender, false);
  ComposeDateTimeValue(json, 'birthDate', elem.birthDateObject, false);
  ComposeDateTimeProps(json, 'birthDate', elem.birthDateObject, false);
  if (elem.deceased is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
    ComposeBooleanProps(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
  end
  else if (elem.deceased is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'deceasedDateTime', TFhirDateTime(elem.deceased), false);
    ComposeDateTimeProps(json, 'deceasedDateTime', TFhirDateTime(elem.deceased), false);
  end;
  if elem.addressList.Count > 0 then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '',elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'maritalStatus', elem.maritalStatus); {a}
  if (elem.multipleBirth is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth), false);
    ComposeBooleanProps(json, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth), false);
  end
  else if (elem.multipleBirth is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth), false);
    ComposeIntegerProps(json, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth), false);
  end;
  if not SummaryOnly and (elem.photoList.Count > 0) then
  begin
    json.valueArray('photo');
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '',elem.photoList[i]); {z - Attachment}
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposePatientContact(json, '',elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  ComposePatientAnimal(json, 'animal', elem.animal); {a}
  if not SummaryOnly and (elem.communicationList.Count > 0) then
  begin
    json.valueArray('communication');
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.communicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.careProviderList.Count > 0) then
  begin
    json.valueArray('careProvider');
    for i := 0 to elem.careProviderList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.careProviderList[i]); {z - Reference(Organization|Practitioner)}
    json.FinishArray;
  end;
  ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if elem.link_List.Count > 0 then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposePatientLink(json, '',elem.link_List[i]); {z - }
    json.FinishArray;
  end;
  ComposeBooleanValue(json, 'active', elem.activeObject, false);
  ComposeBooleanProps(json, 'active', elem.activeObject, false);
end;

function TFHIRXmlParser.ParsePractitionerQualification(element : IXmlDomElement; path : string) : TFhirPractitionerQualification;
var
  child : IXMLDOMElement;
begin
  result := TFhirPractitionerQualification.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'issuer') then
        result.issuer := ParseReference{TFhirOrganization}(child, path+'/issuer') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePractitionerQualification(xml : TXmlBuilder; name : string; elem : TFhirPractitionerQualification);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposePeriod(xml, 'period', elem.period);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'issuer', elem.issuer);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePractitionerQualification(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitionerQualification(jsn));
end;

function TFHIRJsonParser.ParsePractitionerQualification(jsn : TJsonObject) : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('issuer') then
        result.issuer := ParseReference{TFhirOrganization}(jsn.vObj['issuer']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePractitionerQualification(json : TJSONWriter; name : string; elem : TFhirPractitionerQualification);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeReference{TFhirOrganization}(json, 'issuer', elem.issuer); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParsePractitioner(element : IXmlDomElement; path : string) : TFhirPractitioner;
var
  child : IXMLDOMElement;
begin
  result := TFhirPractitioner.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'name') then
        result.name := ParseHumanName(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'address') then
        result.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.baseName = 'gender') then
        result.genderObject := ParseEnum(CODES_TFhirAdministrativeGender, path+'/gender', child){1a}
      else if (child.baseName = 'birthDate') then
        result.birthDateObject := ParseDateTime(child, path+'/birthDate') {b}
      else if (child.baseName = 'photo') then
        result.photoList.Add(ParseAttachment(child, path+'/photo')){y.2}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'role') then
        result.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if (child.baseName = 'specialty') then
        result.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'location') then
        result.locationList.Add(ParseReference{TFhirLocation}(child, path+'/location')){y.2}
      else if (child.baseName = 'qualification') then
        result.qualificationList.Add(ParsePractitionerQualification(child, path+'/qualification')){y.2}
      else if (child.baseName = 'communication') then
        result.communicationList.Add(ParseCodeableConcept(child, path+'/communication')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePractitioner(xml : TXmlBuilder; name : string; elem : TFhirPractitioner);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeHumanName(xml, 'name', elem.name);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  for i := 0 to elem.addressList.Count - 1 do
    ComposeAddress(xml, 'address', elem.addressList[i]);
  ComposeEnum(xml, 'gender', elem.GenderObject, CODES_TFhirAdministrativeGender);
  ComposeDateTime(xml, 'birthDate', elem.birthDateObject);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', elem.photoList[i]);
  ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  for i := 0 to elem.roleList.Count - 1 do
    ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
  for i := 0 to elem.specialtyList.Count - 1 do
    ComposeCodeableConcept(xml, 'specialty', elem.specialtyList[i]);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(xml, 'location', elem.locationList[i]);
  if not SummaryOnly then
    for i := 0 to elem.qualificationList.Count - 1 do
      ComposePractitionerQualification(xml, 'qualification', elem.qualificationList[i]);
  if not SummaryOnly then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'communication', elem.communicationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePractitioner(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitioner(jsn));
end;

function TFHIRJsonParser.ParsePractitioner(jsn : TJsonObject) : TFhirPractitioner;
begin
  result := TFhirPractitioner.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderObject := parseEnum(jsn['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGender);
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDateObject := ParseDateTime(jsn['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
    if jsn.has('specialty') then
      iterateArray(jsn.vArr['specialty'], result.specialtyList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseReference{TFhirLocation});
    if jsn.has('qualification') then
      iterateArray(jsn.vArr['qualification'], result.qualificationList, parsePractitionerQualification);
    if jsn.has('communication') then
      iterateArray(jsn.vArr['communication'], result.communicationList, parseCodeableConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePractitioner(json : TJSONWriter; name : string; elem : TFhirPractitioner);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeHumanName(json, 'name', elem.name); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if elem.addressList.Count > 0 then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '',elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'gender', elem.GenderObject, CODES_TFhirAdministrativeGender, false);
  ComposeEnumProps(json, 'gender', elem.GenderObject, CODES_TFhirAdministrativeGender, false);
  ComposeDateTimeValue(json, 'birthDate', elem.birthDateObject, false);
  ComposeDateTimeProps(json, 'birthDate', elem.birthDateObject, false);
  if not SummaryOnly and (elem.photoList.Count > 0) then
  begin
    json.valueArray('photo');
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '',elem.photoList[i]); {z - Attachment}
    json.FinishArray;
  end;
  ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if elem.roleList.Count > 0 then
  begin
    json.valueArray('role');
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.roleList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.specialtyList.Count > 0 then
  begin
    json.valueArray('specialty');
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.specialtyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
  if not SummaryOnly and (elem.locationList.Count > 0) then
  begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '',elem.locationList[i]); {z - Reference(Location)}
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.qualificationList.Count > 0) then
  begin
    json.valueArray('qualification');
    for i := 0 to elem.qualificationList.Count - 1 do
      ComposePractitionerQualification(json, '',elem.qualificationList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.communicationList.Count > 0) then
  begin
    json.valueArray('communication');
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.communicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseProcedurePerformer(element : IXmlDomElement; path : string) : TFhirProcedurePerformer;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcedurePerformer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'person') then
        result.person := ParseReference{TFhirPractitioner}(child, path+'/person') {b}
      else if (child.baseName = 'role') then
        result.role := ParseCodeableConcept(child, path+'/role') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcedurePerformer(xml : TXmlBuilder; name : string; elem : TFhirProcedurePerformer);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirPractitioner}(xml, 'person', elem.person);{x.2}
  ComposeCodeableConcept(xml, 'role', elem.role);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcedurePerformer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedurePerformer(jsn));
end;

function TFHIRJsonParser.ParseProcedurePerformer(jsn : TJsonObject) : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('person') then
        result.person := ParseReference{TFhirPractitioner}(jsn.vObj['person']);{q}
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcedurePerformer(json : TJSONWriter; name : string; elem : TFhirProcedurePerformer);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirPractitioner}(json, 'person', elem.person); {a}
  ComposeCodeableConcept(json, 'role', elem.role); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseProcedureRelatedItem(element : IXmlDomElement; path : string) : TFhirProcedureRelatedItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcedureRelatedItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Object := ParseEnum(CODES_TFhirProcedureRelationshipType, path+'/type', child){1a}
      else if (child.baseName = 'target') then
        result.target := ParseReference{Resource}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcedureRelatedItem(xml : TXmlBuilder; name : string; elem : TFhirProcedureRelatedItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Object, CODES_TFhirProcedureRelationshipType);
  ComposeReference{Resource}(xml, 'target', elem.target);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcedureRelatedItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedureRelatedItem(jsn));
end;

function TFHIRJsonParser.ParseProcedureRelatedItem(jsn : TJsonObject) : TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Object := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirProcedureRelationshipType);
    if jsn.has('target') then
        result.target := ParseReference{Resource}(jsn.vObj['target']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcedureRelatedItem(json : TJSONWriter; name : string; elem : TFhirProcedureRelatedItem);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Object, CODES_TFhirProcedureRelationshipType, false);
  ComposeEnumProps(json, 'type', elem.Type_Object, CODES_TFhirProcedureRelationshipType, false);
  ComposeReference{Resource}(json, 'target', elem.target); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseProcedure(element : IXmlDomElement; path : string) : TFhirProcedure;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcedure.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'bodySite') then
        result.bodySiteList.Add(ParseCodeableConcept(child, path+'/bodySite')){y.2}
      else if (child.baseName = 'indication') then
        result.indicationList.Add(ParseCodeableConcept(child, path+'/indication')){y.2}
      else if (child.baseName = 'performer') then
        result.performerList.Add(ParseProcedurePerformer(child, path+'/performer')){y.2}
      else if (child.baseName = 'date') then
        result.date := ParsePeriod(child, path+'/date') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'outcome') then
        result.outcomeObject := ParseString(child, path+'/outcome') {b}
      else if (child.baseName = 'report') then
        result.reportList.Add(ParseReference{TFhirDiagnosticReport}(child, path+'/report')){y.2}
      else if (child.baseName = 'complication') then
        result.complicationList.Add(ParseCodeableConcept(child, path+'/complication')){y.2}
      else if (child.baseName = 'followUp') then
        result.followUpObject := ParseString(child, path+'/followUp') {b}
      else if (child.baseName = 'relatedItem') then
        result.relatedItemList.Add(ParseProcedureRelatedItem(child, path+'/relatedItem')){y.2}
      else if (child.baseName = 'notes') then
        result.notesObject := ParseString(child, path+'/notes') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcedure(xml : TXmlBuilder; name : string; elem : TFhirProcedure);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  for i := 0 to elem.bodySiteList.Count - 1 do
    ComposeCodeableConcept(xml, 'bodySite', elem.bodySiteList[i]);
  for i := 0 to elem.indicationList.Count - 1 do
    ComposeCodeableConcept(xml, 'indication', elem.indicationList[i]);
  for i := 0 to elem.performerList.Count - 1 do
    ComposeProcedurePerformer(xml, 'performer', elem.performerList[i]);
  ComposePeriod(xml, 'date', elem.date);{x.2}
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  ComposeString(xml, 'outcome', elem.outcomeObject);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.reportList.Count - 1 do
      ComposeReference{TFhirDiagnosticReport}(xml, 'report', elem.reportList[i]);
  if not SummaryOnly then
    for i := 0 to elem.complicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'complication', elem.complicationList[i]);
  if not SummaryOnly then
    ComposeString(xml, 'followUp', elem.followUpObject);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.relatedItemList.Count - 1 do
      ComposeProcedureRelatedItem(xml, 'relatedItem', elem.relatedItemList[i]);
  if not SummaryOnly then
    ComposeString(xml, 'notes', elem.notesObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedure(jsn));
end;

function TFHIRJsonParser.ParseProcedure(jsn : TJsonObject) : TFhirProcedure;
begin
  result := TFhirProcedure.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('bodySite') then
      iterateArray(jsn.vArr['bodySite'], result.bodySiteList, parseCodeableConcept);
    if jsn.has('indication') then
      iterateArray(jsn.vArr['indication'], result.indicationList, parseCodeableConcept);
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseProcedurePerformer);
    if jsn.has('date') then
        result.date := ParsePeriod(jsn.vObj['date']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('outcome') or jsn.has('_outcome') then
        result.outcomeObject := ParseString(jsn['outcome'], jsn.vObj['_outcome']);{q}
    if jsn.has('report') then
      iterateArray(jsn.vArr['report'], result.reportList, parseReference{TFhirDiagnosticReport});
    if jsn.has('complication') then
      iterateArray(jsn.vArr['complication'], result.complicationList, parseCodeableConcept);
    if jsn.has('followUp') or jsn.has('_followUp') then
        result.followUpObject := ParseString(jsn['followUp'], jsn.vObj['_followUp']);{q}
    if jsn.has('relatedItem') then
      iterateArray(jsn.vArr['relatedItem'], result.relatedItemList, parseProcedureRelatedItem);
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesObject := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcedure(json : TJSONWriter; name : string; elem : TFhirProcedure);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.bodySiteList.Count > 0 then
  begin
    json.valueArray('bodySite');
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.bodySiteList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.indicationList.Count > 0 then
  begin
    json.valueArray('indication');
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.indicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.performerList.Count > 0 then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeProcedurePerformer(json, '',elem.performerList[i]); {z - }
    json.FinishArray;
  end;
  ComposePeriod(json, 'date', elem.date); {a}
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeStringValue(json, 'outcome', elem.outcomeObject, false);
  ComposeStringProps(json, 'outcome', elem.outcomeObject, false);
  if not SummaryOnly and (elem.reportList.Count > 0) then
  begin
    json.valueArray('report');
    for i := 0 to elem.reportList.Count - 1 do
      ComposeReference{TFhirDiagnosticReport}(json, '',elem.reportList[i]); {z - Reference(DiagnosticReport)}
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.complicationList.Count > 0) then
  begin
    json.valueArray('complication');
    for i := 0 to elem.complicationList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.complicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not SummaryOnly then
    ComposeStringValue(json, 'followUp', elem.followUpObject, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'followUp', elem.followUpObject, false);
  if not SummaryOnly and (elem.relatedItemList.Count > 0) then
  begin
    json.valueArray('relatedItem');
    for i := 0 to elem.relatedItemList.Count - 1 do
      ComposeProcedureRelatedItem(json, '',elem.relatedItemList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly then
    ComposeStringValue(json, 'notes', elem.notesObject, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'notes', elem.notesObject, false);
end;

function TFHIRXmlParser.ParseProfileMapping(element : IXmlDomElement; path : string) : TFhirProfileMapping;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileMapping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identity') then
        result.identityObject := ParseId(child, path+'/identity') {b}
      else if (child.baseName = 'uri') then
        result.uriObject := ParseUri(child, path+'/uri') {b}
      else if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'comments') then
        result.commentsObject := ParseString(child, path+'/comments') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileMapping(xml : TXmlBuilder; name : string; elem : TFhirProfileMapping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'identity', elem.identityObject);{x.2}
  ComposeUri(xml, 'uri', elem.uriObject);{x.2}
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeString(xml, 'comments', elem.commentsObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileMapping(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileMapping(jsn));
end;

function TFHIRJsonParser.ParseProfileMapping(jsn : TJsonObject) : TFhirProfileMapping;
begin
  result := TFhirProfileMapping.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identity') or jsn.has('_identity') then
        result.identityObject := ParseId(jsn['identity'], jsn.vObj['_identity']);{q}
    if jsn.has('uri') or jsn.has('_uri') then
        result.uriObject := ParseUri(jsn['uri'], jsn.vObj['_uri']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsObject := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileMapping(json : TJSONWriter; name : string; elem : TFhirProfileMapping);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'identity', elem.identityObject, false);
  ComposeIdProps(json, 'identity', elem.identityObject, false);
  ComposeUriValue(json, 'uri', elem.uriObject, false);
  ComposeUriProps(json, 'uri', elem.uriObject, false);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeStringValue(json, 'comments', elem.commentsObject, false);
  ComposeStringProps(json, 'comments', elem.commentsObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructure(element : IXmlDomElement; path : string) : TFhirProfileStructure;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructure.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Object := ParseCode(child, path+'/type') {b}
      else if (child.baseName = 'base') then
        result.baseObject := ParseUri(child, path+'/base') {b}
      else if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'publish') then
        result.publishObject := ParseBoolean(child, path+'/publish') {b}
      else if (child.baseName = 'purpose') then
        result.purposeObject := ParseString(child, path+'/purpose') {b}
      else if (child.baseName = 'snapshot') then
        result.snapshot := ParseProfileStructureSnapshot(child, path+'/snapshot') {b}
      else if (child.baseName = 'differential') then
        result.differential := ParseProfileStructureSnapshot(child, path+'/differential') {b}
      else if (child.baseName = 'searchParam') then
        result.searchParamList.Add(ParseProfileStructureSearchParam(child, path+'/searchParam')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructure(xml : TXmlBuilder; name : string; elem : TFhirProfileStructure);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'type', elem.type_Object);{x.2}
  ComposeUri(xml, 'base', elem.baseObject);{x.2}
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeBoolean(xml, 'publish', elem.publishObject);{x.2}
  ComposeString(xml, 'purpose', elem.purposeObject);{x.2}
  ComposeProfileStructureSnapshot(xml, 'snapshot', elem.snapshot);{x.2}
  ComposeProfileStructureSnapshot(xml, 'differential', elem.differential);{x.2}
  for i := 0 to elem.searchParamList.Count - 1 do
    ComposeProfileStructureSearchParam(xml, 'searchParam', elem.searchParamList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructure(jsn));
end;

function TFHIRJsonParser.ParseProfileStructure(jsn : TJsonObject) : TFhirProfileStructure;
begin
  result := TFhirProfileStructure.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type') then
        result.type_Object := ParseCode(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('base') or jsn.has('_base') then
        result.baseObject := ParseUri(jsn['base'], jsn.vObj['_base']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('publish') or jsn.has('_publish') then
        result.publishObject := ParseBoolean(jsn['publish'], jsn.vObj['_publish']);{q}
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeObject := ParseString(jsn['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('snapshot') then
        result.snapshot := ParseProfileStructureSnapshot(jsn.vObj['snapshot']);{q}
    if jsn.has('differential') then
        result.differential := ParseProfileStructureSnapshot(jsn.vObj['differential']);{q}
    if jsn.has('searchParam') then
      iterateArray(jsn.vArr['searchParam'], result.searchParamList, parseProfileStructureSearchParam);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructure(json : TJSONWriter; name : string; elem : TFhirProfileStructure);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'type', elem.type_Object, false);
  ComposeCodeProps(json, 'type', elem.type_Object, false);
  ComposeUriValue(json, 'base', elem.baseObject, false);
  ComposeUriProps(json, 'base', elem.baseObject, false);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeBooleanValue(json, 'publish', elem.publishObject, false);
  ComposeBooleanProps(json, 'publish', elem.publishObject, false);
  ComposeStringValue(json, 'purpose', elem.purposeObject, false);
  ComposeStringProps(json, 'purpose', elem.purposeObject, false);
  ComposeProfileStructureSnapshot(json, 'snapshot', elem.snapshot); {a}
  ComposeProfileStructureSnapshot(json, 'differential', elem.differential); {a}
  if elem.searchParamList.Count > 0 then
  begin
    json.valueArray('searchParam');
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeProfileStructureSearchParam(json, '',elem.searchParamList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructureSnapshot(element : IXmlDomElement; path : string) : TFhirProfileStructureSnapshot;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructureSnapshot.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'element') then
        result.elementList.Add(ParseProfileStructureSnapshotElement(child, path+'/element')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructureSnapshot(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSnapshot);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.elementList.Count - 1 do
    ComposeProfileStructureSnapshotElement(xml, 'element', elem.elementList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructureSnapshot(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructureSnapshot(jsn));
end;

function TFHIRJsonParser.ParseProfileStructureSnapshot(jsn : TJsonObject) : TFhirProfileStructureSnapshot;
begin
  result := TFhirProfileStructureSnapshot.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseProfileStructureSnapshotElement);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructureSnapshot(json : TJSONWriter; name : string; elem : TFhirProfileStructureSnapshot);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.elementList.Count > 0 then
  begin
    json.valueArray('element');
    for i := 0 to elem.elementList.Count - 1 do
      ComposeProfileStructureSnapshotElement(json, '',elem.elementList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructureSnapshotElement(element : IXmlDomElement; path : string) : TFhirProfileStructureSnapshotElement;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructureSnapshotElement.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'path') then
        result.pathObject := ParseString(child, path+'/path') {b}
      else if (child.baseName = 'representation') then
        result.representationObject.Add(ParseEnum(CODES_TFhirPropertyRepresentation, path+'/representation', child)){y.1}
      else if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'slicing') then
        result.slicing := ParseProfileStructureSnapshotElementSlicing(child, path+'/slicing') {b}
      else if (child.baseName = 'definition') then
        result.definition := ParseProfileStructureSnapshotElementDefinition(child, path+'/definition') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructureSnapshotElement(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSnapshotElement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'path', elem.pathObject);{x.2}
  for i := 0 to elem.representationObject.Count - 1 do
    ComposeEnum(xml, 'representation', elem.representationObject[i], CODES_TFhirPropertyRepresentation);
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeProfileStructureSnapshotElementSlicing(xml, 'slicing', elem.slicing);{x.2}
  ComposeProfileStructureSnapshotElementDefinition(xml, 'definition', elem.definition);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructureSnapshotElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructureSnapshotElement(jsn));
end;

function TFHIRJsonParser.ParseProfileStructureSnapshotElement(jsn : TJsonObject) : TFhirProfileStructureSnapshotElement;
begin
  result := TFhirProfileStructureSnapshotElement.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('path') or jsn.has('_path') then
        result.pathObject := ParseString(jsn['path'], jsn.vObj['_path']);{q}
    if jsn.has('representation') or jsn.has('_representation') then
      iterateEnumArray(jsn.vArr['representation'], jsn.vArr['_representation'], result.representationObject, parseEnum, CODES_TFhirPropertyRepresentation);
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('slicing') then
        result.slicing := ParseProfileStructureSnapshotElementSlicing(jsn.vObj['slicing']);{q}
    if jsn.has('definition') then
        result.definition := ParseProfileStructureSnapshotElementDefinition(jsn.vObj['definition']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructureSnapshotElement(json : TJSONWriter; name : string; elem : TFhirProfileStructureSnapshotElement);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'path', elem.pathObject, false);
  ComposeStringProps(json, 'path', elem.pathObject, false);
  if elem.representationObject.Count > 0 then
  begin
    json.valueArray('representation');
    ext := false;
    for i := 0 to elem.representationObject.Count - 1 do
    begin
      ext := ext or ((elem.representationObject[i].xmlid <> '') or (elem.representationObject[i].hasExtensions));
      ComposeEnumValue(json, '', elem.representationObject[i], CODES_TFhirPropertyRepresentation, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_representation');
      for i := 0 to elem.representationObject.Count - 1 do
        ComposeEnumProps(json, '', elem.representationObject[i], CODES_TFhirPropertyRepresentation, true);
      json.FinishArray;
    end;
  end;
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeProfileStructureSnapshotElementSlicing(json, 'slicing', elem.slicing); {a}
  ComposeProfileStructureSnapshotElementDefinition(json, 'definition', elem.definition); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructureSnapshotElementSlicing(element : IXmlDomElement; path : string) : TFhirProfileStructureSnapshotElementSlicing;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructureSnapshotElementSlicing.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'discriminator') then
        result.discriminatorObject := ParseId(child, path+'/discriminator') {b}
      else if (child.baseName = 'ordered') then
        result.orderedObject := ParseBoolean(child, path+'/ordered') {b}
      else if (child.baseName = 'rules') then
        result.rulesObject := ParseEnum(CODES_TFhirResourceSlicingRules, path+'/rules', child){1a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructureSnapshotElementSlicing(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSnapshotElementSlicing);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'discriminator', elem.discriminatorObject);{x.2}
  ComposeBoolean(xml, 'ordered', elem.orderedObject);{x.2}
  ComposeEnum(xml, 'rules', elem.RulesObject, CODES_TFhirResourceSlicingRules);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructureSnapshotElementSlicing(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructureSnapshotElementSlicing(jsn));
end;

function TFHIRJsonParser.ParseProfileStructureSnapshotElementSlicing(jsn : TJsonObject) : TFhirProfileStructureSnapshotElementSlicing;
begin
  result := TFhirProfileStructureSnapshotElementSlicing.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('discriminator') or jsn.has('_discriminator') then
        result.discriminatorObject := ParseId(jsn['discriminator'], jsn.vObj['_discriminator']);{q}
    if jsn.has('ordered') or jsn.has('_ordered') then
        result.orderedObject := ParseBoolean(jsn['ordered'], jsn.vObj['_ordered']);{q}
    if jsn.has('rules') or jsn.has('_rules')  then
      result.rulesObject := parseEnum(jsn['rules'], jsn.vObj['_rules'], CODES_TFhirResourceSlicingRules);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructureSnapshotElementSlicing(json : TJSONWriter; name : string; elem : TFhirProfileStructureSnapshotElementSlicing);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'discriminator', elem.discriminatorObject, false);
  ComposeIdProps(json, 'discriminator', elem.discriminatorObject, false);
  ComposeBooleanValue(json, 'ordered', elem.orderedObject, false);
  ComposeBooleanProps(json, 'ordered', elem.orderedObject, false);
  ComposeEnumValue(json, 'rules', elem.RulesObject, CODES_TFhirResourceSlicingRules, false);
  ComposeEnumProps(json, 'rules', elem.RulesObject, CODES_TFhirResourceSlicingRules, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructureSnapshotElementDefinition(element : IXmlDomElement; path : string) : TFhirProfileStructureSnapshotElementDefinition;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructureSnapshotElementDefinition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'short') then
        result.shortObject := ParseString(child, path+'/short') {b}
      else if (child.baseName = 'formal') then
        result.formalObject := ParseString(child, path+'/formal') {b}
      else if (child.baseName = 'comments') then
        result.commentsObject := ParseString(child, path+'/comments') {b}
      else if (child.baseName = 'requirements') then
        result.requirementsObject := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'synonym') then
        result.synonymList.Add(ParseString(child, path+'/synonym')){y.2}
      else if (child.baseName = 'min') then
        result.minObject := ParseInteger(child, path+'/min') {b}
      else if (child.baseName = 'max') then
        result.maxObject := ParseString(child, path+'/max') {b}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseProfileStructureSnapshotElementDefinitionType(child, path+'/type')){y.2}
      else if (child.baseName = 'nameReference') then
        result.nameReferenceObject := ParseString(child, path+'/nameReference') {b}
      else if (child.baseName = 'valueInteger') then
        result.value := ParseInteger(child, path+'.valueInteger') {c}
      else if (child.baseName = 'valueDateTime') then
        result.value := ParseDateTime(child, path+'.valueDateTime') {c}
      else if (child.baseName = 'valueCode') then
        result.value := ParseCode(child, path+'.valueCode') {c}
      else if (child.baseName = 'valueDate') then
        result.value := ParseDate(child, path+'.valueDate') {c}
      else if (child.baseName = 'valueDecimal') then
        result.value := ParseDecimal(child, path+'.valueDecimal') {c}
      else if (child.baseName = 'valueUri') then
        result.value := ParseUri(child, path+'.valueUri') {c}
      else if (child.baseName = 'valueId') then
        result.value := ParseId(child, path+'.valueId') {c}
      else if (child.baseName = 'valueBase64Binary') then
        result.value := ParseBase64Binary(child, path+'.valueBase64Binary') {c}
      else if (child.baseName = 'valueTime') then
        result.value := ParseTime(child, path+'.valueTime') {c}
      else if (child.baseName = 'valueOid') then
        result.value := ParseOid(child, path+'.valueOid') {c}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'.valueString') {c}
      else if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'.valueBoolean') {c}
      else if (child.baseName = 'valueUuid') then
        result.value := ParseUuid(child, path+'.valueUuid') {c}
      else if (child.baseName = 'valueInstant') then
        result.value := ParseInstant(child, path+'.valueInstant') {c}
      else if (child.baseName = 'valuePeriod') then
        result.value := ParsePeriod(child, path+'.valuePeriod') {ePeriod}
      else if (child.baseName = 'valueCoding') then
        result.value := ParseCoding(child, path+'.valueCoding') {eCoding}
      else if (child.baseName = 'valueRange') then
        result.value := ParseRange(child, path+'.valueRange') {eRange}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'.valueQuantity') {eQuantity}
      else if (child.baseName = 'valueAttachment') then
        result.value := ParseAttachment(child, path+'.valueAttachment') {eAttachment}
      else if (child.baseName = 'valueRatio') then
        result.value := ParseRatio(child, path+'.valueRatio') {eRatio}
      else if (child.baseName = 'valueSampledData') then
        result.value := ParseSampledData(child, path+'.valueSampledData') {eSampledData}
      else if (child.baseName = 'valueReference') then
        result.value := ParseReference(child, path+'.valueReference') {eReference}
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'.valueCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'valueIdentifier') then
        result.value := ParseIdentifier(child, path+'.valueIdentifier') {eIdentifier}
      else if (child.baseName = 'valueTiming') then
        result.value := ParseTiming(child, path+'/valueTiming') {f}
      else if (child.baseName = 'valueAddress') then
        result.value := ParseAddress(child, path+'/valueAddress') {f}
      else if (child.baseName = 'valueHumanName') then
        result.value := ParseHumanName(child, path+'/valueHumanName') {f}
      else if (child.baseName = 'valueContactPoint') then
        result.value := ParseContactPoint(child, path+'/valueContactPoint') {f}
      else if (child.baseName = 'exampleInteger') then
        result.example := ParseInteger(child, path+'.exampleInteger') {c}
      else if (child.baseName = 'exampleDateTime') then
        result.example := ParseDateTime(child, path+'.exampleDateTime') {c}
      else if (child.baseName = 'exampleCode') then
        result.example := ParseCode(child, path+'.exampleCode') {c}
      else if (child.baseName = 'exampleDate') then
        result.example := ParseDate(child, path+'.exampleDate') {c}
      else if (child.baseName = 'exampleDecimal') then
        result.example := ParseDecimal(child, path+'.exampleDecimal') {c}
      else if (child.baseName = 'exampleUri') then
        result.example := ParseUri(child, path+'.exampleUri') {c}
      else if (child.baseName = 'exampleId') then
        result.example := ParseId(child, path+'.exampleId') {c}
      else if (child.baseName = 'exampleBase64Binary') then
        result.example := ParseBase64Binary(child, path+'.exampleBase64Binary') {c}
      else if (child.baseName = 'exampleTime') then
        result.example := ParseTime(child, path+'.exampleTime') {c}
      else if (child.baseName = 'exampleOid') then
        result.example := ParseOid(child, path+'.exampleOid') {c}
      else if (child.baseName = 'exampleString') then
        result.example := ParseString(child, path+'.exampleString') {c}
      else if (child.baseName = 'exampleBoolean') then
        result.example := ParseBoolean(child, path+'.exampleBoolean') {c}
      else if (child.baseName = 'exampleUuid') then
        result.example := ParseUuid(child, path+'.exampleUuid') {c}
      else if (child.baseName = 'exampleInstant') then
        result.example := ParseInstant(child, path+'.exampleInstant') {c}
      else if (child.baseName = 'examplePeriod') then
        result.example := ParsePeriod(child, path+'.examplePeriod') {ePeriod}
      else if (child.baseName = 'exampleCoding') then
        result.example := ParseCoding(child, path+'.exampleCoding') {eCoding}
      else if (child.baseName = 'exampleRange') then
        result.example := ParseRange(child, path+'.exampleRange') {eRange}
      else if (child.baseName = 'exampleQuantity') then
        result.example := ParseQuantity(child, path+'.exampleQuantity') {eQuantity}
      else if (child.baseName = 'exampleAttachment') then
        result.example := ParseAttachment(child, path+'.exampleAttachment') {eAttachment}
      else if (child.baseName = 'exampleRatio') then
        result.example := ParseRatio(child, path+'.exampleRatio') {eRatio}
      else if (child.baseName = 'exampleSampledData') then
        result.example := ParseSampledData(child, path+'.exampleSampledData') {eSampledData}
      else if (child.baseName = 'exampleReference') then
        result.example := ParseReference(child, path+'.exampleReference') {eReference}
      else if (child.baseName = 'exampleCodeableConcept') then
        result.example := ParseCodeableConcept(child, path+'.exampleCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'exampleIdentifier') then
        result.example := ParseIdentifier(child, path+'.exampleIdentifier') {eIdentifier}
      else if (child.baseName = 'exampleTiming') then
        result.example := ParseTiming(child, path+'/exampleTiming') {f}
      else if (child.baseName = 'exampleAddress') then
        result.example := ParseAddress(child, path+'/exampleAddress') {f}
      else if (child.baseName = 'exampleHumanName') then
        result.example := ParseHumanName(child, path+'/exampleHumanName') {f}
      else if (child.baseName = 'exampleContactPoint') then
        result.example := ParseContactPoint(child, path+'/exampleContactPoint') {f}
      else if (child.baseName = 'maxLength') then
        result.maxLengthObject := ParseInteger(child, path+'/maxLength') {b}
      else if (child.baseName = 'condition') then
        result.conditionList.Add(ParseId(child, path+'/condition')){y.2}
      else if (child.baseName = 'constraint') then
        result.constraintList.Add(ParseProfileStructureSnapshotElementDefinitionConstraint(child, path+'/constraint')){y.2}
      else if (child.baseName = 'mustSupport') then
        result.mustSupportObject := ParseBoolean(child, path+'/mustSupport') {b}
      else if (child.baseName = 'isModifier') then
        result.isModifierObject := ParseBoolean(child, path+'/isModifier') {b}
      else if (child.baseName = 'binding') then
        result.binding := ParseProfileStructureSnapshotElementDefinitionBinding(child, path+'/binding') {b}
      else if (child.baseName = 'mapping') then
        result.mappingList.Add(ParseProfileStructureSnapshotElementDefinitionMapping(child, path+'/mapping')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructureSnapshotElementDefinition(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSnapshotElementDefinition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'short', elem.shortObject);{x.2}
  ComposeString(xml, 'formal', elem.formalObject);{x.2}
  ComposeString(xml, 'comments', elem.commentsObject);{x.2}
  ComposeString(xml, 'requirements', elem.requirementsObject);{x.2}
  for i := 0 to elem.synonymList.Count - 1 do
    ComposeString(xml, 'synonym', elem.synonymList[i]);
  ComposeInteger(xml, 'min', elem.minObject);{x.2}
  ComposeString(xml, 'max', elem.maxObject);{x.2}
  for i := 0 to elem.type_List.Count - 1 do
    ComposeProfileStructureSnapshotElementDefinitionType(xml, 'type', elem.type_List[i]);
  ComposeString(xml, 'nameReference', elem.nameReferenceObject);{x.2}
  if (elem.value is TFhirInteger) {1} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (elem.value is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (elem.value is TFhirCode) {1} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (elem.value is TFhirDate) {1} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (elem.value is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (elem.value is TFhirUri) {1} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value))
  else if (elem.value is TFhirId) {1} then
    ComposeId(xml, 'valueId', TFhirId(elem.value))
  else if (elem.value is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(elem.value))
  else if (elem.value is TFhirTime) {1} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (elem.value is TFhirOid) {1} then
    ComposeOid(xml, 'valueOid', TFhirOid(elem.value))
  else if (elem.value is TFhirString) {1} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (elem.value is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirUuid) {1} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(elem.value))
  else if (elem.value is TFhirInstant) {1} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (elem.value is TFhirPeriod) {8} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirCoding) {8} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirRange) {8} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirRatio) {8} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirReference) {8} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (elem.value is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (elem.value is TFhirTiming) {9} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(elem.value))
  else if (elem.value is TFhirAddress) {9} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(elem.value))
  else if (elem.value is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(elem.value))
  else if (elem.value is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(elem.value));
  if (elem.example is TFhirInteger) {1} then
    ComposeInteger(xml, 'exampleInteger', TFhirInteger(elem.example))
  else if (elem.example is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'exampleDateTime', TFhirDateTime(elem.example))
  else if (elem.example is TFhirCode) {1} then
    ComposeCode(xml, 'exampleCode', TFhirCode(elem.example))
  else if (elem.example is TFhirDate) {1} then
    ComposeDate(xml, 'exampleDate', TFhirDate(elem.example))
  else if (elem.example is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'exampleDecimal', TFhirDecimal(elem.example))
  else if (elem.example is TFhirUri) {1} then
    ComposeUri(xml, 'exampleUri', TFhirUri(elem.example))
  else if (elem.example is TFhirId) {1} then
    ComposeId(xml, 'exampleId', TFhirId(elem.example))
  else if (elem.example is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'exampleBase64Binary', TFhirBase64Binary(elem.example))
  else if (elem.example is TFhirTime) {1} then
    ComposeTime(xml, 'exampleTime', TFhirTime(elem.example))
  else if (elem.example is TFhirOid) {1} then
    ComposeOid(xml, 'exampleOid', TFhirOid(elem.example))
  else if (elem.example is TFhirString) {1} then
    ComposeString(xml, 'exampleString', TFhirString(elem.example))
  else if (elem.example is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'exampleBoolean', TFhirBoolean(elem.example))
  else if (elem.example is TFhirUuid) {1} then
    ComposeUuid(xml, 'exampleUuid', TFhirUuid(elem.example))
  else if (elem.example is TFhirInstant) {1} then
    ComposeInstant(xml, 'exampleInstant', TFhirInstant(elem.example))
  else if (elem.example is TFhirPeriod) {8} then
    ComposePeriod(xml, 'examplePeriod', TFhirPeriod(elem.example))
  else if (elem.example is TFhirCoding) {8} then
    ComposeCoding(xml, 'exampleCoding', TFhirCoding(elem.example))
  else if (elem.example is TFhirRange) {8} then
    ComposeRange(xml, 'exampleRange', TFhirRange(elem.example))
  else if (elem.example is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'exampleQuantity', TFhirQuantity(elem.example))
  else if (elem.example is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'exampleAttachment', TFhirAttachment(elem.example))
  else if (elem.example is TFhirRatio) {8} then
    ComposeRatio(xml, 'exampleRatio', TFhirRatio(elem.example))
  else if (elem.example is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'exampleSampledData', TFhirSampledData(elem.example))
  else if (elem.example is TFhirReference) {8} then
    ComposeReference(xml, 'exampleReference', TFhirReference(elem.example))
  else if (elem.example is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'exampleCodeableConcept', TFhirCodeableConcept(elem.example))
  else if (elem.example is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'exampleIdentifier', TFhirIdentifier(elem.example))
  else if (elem.example is TFhirTiming) {9} then
    ComposeTiming(xml, 'exampleTiming', TFhirTiming(elem.example))
  else if (elem.example is TFhirAddress) {9} then
    ComposeAddress(xml, 'exampleAddress', TFhirAddress(elem.example))
  else if (elem.example is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'exampleHumanName', TFhirHumanName(elem.example))
  else if (elem.example is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'exampleContactPoint', TFhirContactPoint(elem.example));
  ComposeInteger(xml, 'maxLength', elem.maxLengthObject);{x.2}
  for i := 0 to elem.conditionList.Count - 1 do
    ComposeId(xml, 'condition', elem.conditionList[i]);
  for i := 0 to elem.constraintList.Count - 1 do
    ComposeProfileStructureSnapshotElementDefinitionConstraint(xml, 'constraint', elem.constraintList[i]);
  ComposeBoolean(xml, 'mustSupport', elem.mustSupportObject);{x.2}
  ComposeBoolean(xml, 'isModifier', elem.isModifierObject);{x.2}
  ComposeProfileStructureSnapshotElementDefinitionBinding(xml, 'binding', elem.binding);{x.2}
  for i := 0 to elem.mappingList.Count - 1 do
    ComposeProfileStructureSnapshotElementDefinitionMapping(xml, 'mapping', elem.mappingList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructureSnapshotElementDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructureSnapshotElementDefinition(jsn));
end;

function TFHIRJsonParser.ParseProfileStructureSnapshotElementDefinition(jsn : TJsonObject) : TFhirProfileStructureSnapshotElementDefinition;
begin
  result := TFhirProfileStructureSnapshotElementDefinition.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('short') or jsn.has('_short') then
        result.shortObject := ParseString(jsn['short'], jsn.vObj['_short']);{q}
    if jsn.has('formal') or jsn.has('_formal') then
        result.formalObject := ParseString(jsn['formal'], jsn.vObj['_formal']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsObject := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsObject := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
      if jsn.has('synonym') or jsn.has('_synonym') then
      iteratePrimitiveArray(jsn.vArr['synonym'], jsn.vArr['_synonym'], result.synonymList, parseString);
    if jsn.has('min') or jsn.has('_min') then
        result.minObject := ParseInteger(jsn['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxObject := ParseString(jsn['max'], jsn.vObj['_max']);{q}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseProfileStructureSnapshotElementDefinitionType);
    if jsn.has('nameReference') or jsn.has('_nameReference') then
        result.nameReferenceObject := ParseString(jsn['nameReference'], jsn.vObj['_nameReference']);{q}
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
        result.value := ParseInteger(jsn['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
        result.value := ParseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueCode') or jsn.has('_valueCode') then
        result.value := ParseCode(jsn['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
        result.value := ParseDate(jsn['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
        result.value := ParseDecimal(jsn['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
        result.value := ParseUri(jsn['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('valueId') or jsn.has('_valueId') then
        result.value := ParseId(jsn['valueId'], jsn.vObj['_valueId']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
        result.value := ParseBase64Binary(jsn['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
        result.value := ParseTime(jsn['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueOid') or jsn.has('_valueOid') then
        result.value := ParseOid(jsn['valueOid'], jsn.vObj['_valueOid']);
    if jsn.has('valueString') or jsn.has('_valueString') then
        result.value := ParseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
        result.value := ParseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
        result.value := ParseUuid(jsn['valueUuid'], jsn.vObj['_valueUuid']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
        result.value := ParseInstant(jsn['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valuePeriod') {a7} then
        result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueCoding') {a7} then
        result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueRange') {a7} then
        result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueQuantity') {a7} then
        result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueAttachment') {a7} then
        result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueRatio') {a7} then
        result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueSampledData') {a7} then
        result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueReference') {a7} then
        result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueCodeableConcept') {a7} then
        result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueIdentifier') {a7} then
        result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if jsn.has('valueTiming') {a9} then
        result.value := ParseTiming(jsn.vObj['valueTiming']);
    if jsn.has('valueAddress') {a9} then
        result.value := ParseAddress(jsn.vObj['valueAddress']);
    if jsn.has('valueHumanName') {a9} then
        result.value := ParseHumanName(jsn.vObj['valueHumanName']);
    if jsn.has('valueContactPoint') {a9} then
        result.value := ParseContactPoint(jsn.vObj['valueContactPoint']);
    if jsn.has('exampleInteger') or jsn.has('_exampleInteger') then
        result.example := ParseInteger(jsn['exampleInteger'], jsn.vObj['_exampleInteger']);
    if jsn.has('exampleDateTime') or jsn.has('_exampleDateTime') then
        result.example := ParseDateTime(jsn['exampleDateTime'], jsn.vObj['_exampleDateTime']);
    if jsn.has('exampleCode') or jsn.has('_exampleCode') then
        result.example := ParseCode(jsn['exampleCode'], jsn.vObj['_exampleCode']);
    if jsn.has('exampleDate') or jsn.has('_exampleDate') then
        result.example := ParseDate(jsn['exampleDate'], jsn.vObj['_exampleDate']);
    if jsn.has('exampleDecimal') or jsn.has('_exampleDecimal') then
        result.example := ParseDecimal(jsn['exampleDecimal'], jsn.vObj['_exampleDecimal']);
    if jsn.has('exampleUri') or jsn.has('_exampleUri') then
        result.example := ParseUri(jsn['exampleUri'], jsn.vObj['_exampleUri']);
    if jsn.has('exampleId') or jsn.has('_exampleId') then
        result.example := ParseId(jsn['exampleId'], jsn.vObj['_exampleId']);
    if jsn.has('exampleBase64Binary') or jsn.has('_exampleBase64Binary') then
        result.example := ParseBase64Binary(jsn['exampleBase64Binary'], jsn.vObj['_exampleBase64Binary']);
    if jsn.has('exampleTime') or jsn.has('_exampleTime') then
        result.example := ParseTime(jsn['exampleTime'], jsn.vObj['_exampleTime']);
    if jsn.has('exampleOid') or jsn.has('_exampleOid') then
        result.example := ParseOid(jsn['exampleOid'], jsn.vObj['_exampleOid']);
    if jsn.has('exampleString') or jsn.has('_exampleString') then
        result.example := ParseString(jsn['exampleString'], jsn.vObj['_exampleString']);
    if jsn.has('exampleBoolean') or jsn.has('_exampleBoolean') then
        result.example := ParseBoolean(jsn['exampleBoolean'], jsn.vObj['_exampleBoolean']);
    if jsn.has('exampleUuid') or jsn.has('_exampleUuid') then
        result.example := ParseUuid(jsn['exampleUuid'], jsn.vObj['_exampleUuid']);
    if jsn.has('exampleInstant') or jsn.has('_exampleInstant') then
        result.example := ParseInstant(jsn['exampleInstant'], jsn.vObj['_exampleInstant']);
    if jsn.has('examplePeriod') {a7} then
        result.example := ParsePeriod(jsn.vObj['examplePeriod']);
    if jsn.has('exampleCoding') {a7} then
        result.example := ParseCoding(jsn.vObj['exampleCoding']);
    if jsn.has('exampleRange') {a7} then
        result.example := ParseRange(jsn.vObj['exampleRange']);
    if jsn.has('exampleQuantity') {a7} then
        result.example := ParseQuantity(jsn.vObj['exampleQuantity']);
    if jsn.has('exampleAttachment') {a7} then
        result.example := ParseAttachment(jsn.vObj['exampleAttachment']);
    if jsn.has('exampleRatio') {a7} then
        result.example := ParseRatio(jsn.vObj['exampleRatio']);
    if jsn.has('exampleSampledData') {a7} then
        result.example := ParseSampledData(jsn.vObj['exampleSampledData']);
    if jsn.has('exampleReference') {a7} then
        result.example := ParseReference(jsn.vObj['exampleReference']);
    if jsn.has('exampleCodeableConcept') {a7} then
        result.example := ParseCodeableConcept(jsn.vObj['exampleCodeableConcept']);
    if jsn.has('exampleIdentifier') {a7} then
        result.example := ParseIdentifier(jsn.vObj['exampleIdentifier']);
    if jsn.has('exampleTiming') {a9} then
        result.example := ParseTiming(jsn.vObj['exampleTiming']);
    if jsn.has('exampleAddress') {a9} then
        result.example := ParseAddress(jsn.vObj['exampleAddress']);
    if jsn.has('exampleHumanName') {a9} then
        result.example := ParseHumanName(jsn.vObj['exampleHumanName']);
    if jsn.has('exampleContactPoint') {a9} then
        result.example := ParseContactPoint(jsn.vObj['exampleContactPoint']);
    if jsn.has('maxLength') or jsn.has('_maxLength') then
        result.maxLengthObject := ParseInteger(jsn['maxLength'], jsn.vObj['_maxLength']);{q}
      if jsn.has('condition') or jsn.has('_condition') then
      iteratePrimitiveArray(jsn.vArr['condition'], jsn.vArr['_condition'], result.conditionList, parseId);
    if jsn.has('constraint') then
      iterateArray(jsn.vArr['constraint'], result.constraintList, parseProfileStructureSnapshotElementDefinitionConstraint);
    if jsn.has('mustSupport') or jsn.has('_mustSupport') then
        result.mustSupportObject := ParseBoolean(jsn['mustSupport'], jsn.vObj['_mustSupport']);{q}
    if jsn.has('isModifier') or jsn.has('_isModifier') then
        result.isModifierObject := ParseBoolean(jsn['isModifier'], jsn.vObj['_isModifier']);{q}
    if jsn.has('binding') then
        result.binding := ParseProfileStructureSnapshotElementDefinitionBinding(jsn.vObj['binding']);{q}
    if jsn.has('mapping') then
      iterateArray(jsn.vArr['mapping'], result.mappingList, parseProfileStructureSnapshotElementDefinitionMapping);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructureSnapshotElementDefinition(json : TJSONWriter; name : string; elem : TFhirProfileStructureSnapshotElementDefinition);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'short', elem.shortObject, false);
  ComposeStringProps(json, 'short', elem.shortObject, false);
  ComposeStringValue(json, 'formal', elem.formalObject, false);
  ComposeStringProps(json, 'formal', elem.formalObject, false);
  ComposeStringValue(json, 'comments', elem.commentsObject, false);
  ComposeStringProps(json, 'comments', elem.commentsObject, false);
  ComposeStringValue(json, 'requirements', elem.requirementsObject, false);
  ComposeStringProps(json, 'requirements', elem.requirementsObject, false);
  if elem.synonymList.Count > 0 then
  begin
    json.valueArray('synonym');
    ext := false;
    for i := 0 to elem.synonymList.Count - 1 do
    begin
      ext := ext or ((elem.synonymList[i].xmlid <> '') or (elem.synonymList[i].hasExtensions));
      ComposeStringValue(json, '',elem.synonymList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_synonym');
      for i := 0 to elem.synonymList.Count - 1 do
        ComposeStringProps(json, '',elem.synonymList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeIntegerValue(json, 'min', elem.minObject, false);
  ComposeIntegerProps(json, 'min', elem.minObject, false);
  ComposeStringValue(json, 'max', elem.maxObject, false);
  ComposeStringProps(json, 'max', elem.maxObject, false);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeProfileStructureSnapshotElementDefinitionType(json, '',elem.type_List[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'nameReference', elem.nameReferenceObject, false);
  ComposeStringProps(json, 'nameReference', elem.nameReferenceObject, false);
  if (elem.value is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false)
  end
  else if (elem.value is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false)
  end
  else if (elem.value is TFhirCode) then
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false)
  end
  else if (elem.value is TFhirDate) then
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false)
  end
  else if (elem.value is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false)
  end
  else if (elem.value is TFhirUri) then
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false)
  end
  else if (elem.value is TFhirId) then
  begin
    ComposeIdValue(json, 'valueId', TFhirId(elem.value), false);
    ComposeIdProps(json, 'valueId', TFhirId(elem.value), false)
  end
  else if (elem.value is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false)
  end
  else if (elem.value is TFhirTime) then
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false)
  end
  else if (elem.value is TFhirOid) then
  begin
    ComposeOidValue(json, 'valueOid', TFhirOid(elem.value), false);
    ComposeOidProps(json, 'valueOid', TFhirOid(elem.value), false)
  end
  else if (elem.value is TFhirString) then
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false)
  end
  else if (elem.value is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false)
  end
  else if (elem.value is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'valueUuid', TFhirUuid(elem.value), false);
    ComposeUuidProps(json, 'valueUuid', TFhirUuid(elem.value), false)
  end
  else if (elem.value is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false)
  end
  else if (elem.value is TFhirPeriod) then
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirCoding) then
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirRange) then
    ComposeRange(json, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirQuantity) then
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirAttachment) then
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirRatio) then
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirSampledData) then
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value))
  else if (elem.value is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirIdentifier) then
    ComposeIdentifier(json, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (elem.value is TFhirTiming) then
    ComposeTiming(json, 'valueTiming', TFhirTiming(elem.value))
  else if (elem.value is TFhirAddress) then
    ComposeAddress(json, 'valueAddress', TFhirAddress(elem.value))
  else if (elem.value is TFhirHumanName) then
    ComposeHumanName(json, 'valueHumanName', TFhirHumanName(elem.value))
  else if (elem.value is TFhirContactPoint) then
    ComposeContactPoint(json, 'valueContactPoint', TFhirContactPoint(elem.value));
  if (elem.example is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'exampleInteger', TFhirInteger(elem.example), false);
    ComposeIntegerProps(json, 'exampleInteger', TFhirInteger(elem.example), false)
  end
  else if (elem.example is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'exampleDateTime', TFhirDateTime(elem.example), false);
    ComposeDateTimeProps(json, 'exampleDateTime', TFhirDateTime(elem.example), false)
  end
  else if (elem.example is TFhirCode) then
  begin
    ComposeCodeValue(json, 'exampleCode', TFhirCode(elem.example), false);
    ComposeCodeProps(json, 'exampleCode', TFhirCode(elem.example), false)
  end
  else if (elem.example is TFhirDate) then
  begin
    ComposeDateValue(json, 'exampleDate', TFhirDate(elem.example), false);
    ComposeDateProps(json, 'exampleDate', TFhirDate(elem.example), false)
  end
  else if (elem.example is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'exampleDecimal', TFhirDecimal(elem.example), false);
    ComposeDecimalProps(json, 'exampleDecimal', TFhirDecimal(elem.example), false)
  end
  else if (elem.example is TFhirUri) then
  begin
    ComposeUriValue(json, 'exampleUri', TFhirUri(elem.example), false);
    ComposeUriProps(json, 'exampleUri', TFhirUri(elem.example), false)
  end
  else if (elem.example is TFhirId) then
  begin
    ComposeIdValue(json, 'exampleId', TFhirId(elem.example), false);
    ComposeIdProps(json, 'exampleId', TFhirId(elem.example), false)
  end
  else if (elem.example is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'exampleBase64Binary', TFhirBase64Binary(elem.example), false);
    ComposeBase64BinaryProps(json, 'exampleBase64Binary', TFhirBase64Binary(elem.example), false)
  end
  else if (elem.example is TFhirTime) then
  begin
    ComposeTimeValue(json, 'exampleTime', TFhirTime(elem.example), false);
    ComposeTimeProps(json, 'exampleTime', TFhirTime(elem.example), false)
  end
  else if (elem.example is TFhirOid) then
  begin
    ComposeOidValue(json, 'exampleOid', TFhirOid(elem.example), false);
    ComposeOidProps(json, 'exampleOid', TFhirOid(elem.example), false)
  end
  else if (elem.example is TFhirString) then
  begin
    ComposeStringValue(json, 'exampleString', TFhirString(elem.example), false);
    ComposeStringProps(json, 'exampleString', TFhirString(elem.example), false)
  end
  else if (elem.example is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'exampleBoolean', TFhirBoolean(elem.example), false);
    ComposeBooleanProps(json, 'exampleBoolean', TFhirBoolean(elem.example), false)
  end
  else if (elem.example is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'exampleUuid', TFhirUuid(elem.example), false);
    ComposeUuidProps(json, 'exampleUuid', TFhirUuid(elem.example), false)
  end
  else if (elem.example is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'exampleInstant', TFhirInstant(elem.example), false);
    ComposeInstantProps(json, 'exampleInstant', TFhirInstant(elem.example), false)
  end
  else if (elem.example is TFhirPeriod) then
    ComposePeriod(json, 'examplePeriod', TFhirPeriod(elem.example))
  else if (elem.example is TFhirCoding) then
    ComposeCoding(json, 'exampleCoding', TFhirCoding(elem.example))
  else if (elem.example is TFhirRange) then
    ComposeRange(json, 'exampleRange', TFhirRange(elem.example))
  else if (elem.example is TFhirQuantity) then
    ComposeQuantity(json, 'exampleQuantity', TFhirQuantity(elem.example))
  else if (elem.example is TFhirAttachment) then
    ComposeAttachment(json, 'exampleAttachment', TFhirAttachment(elem.example))
  else if (elem.example is TFhirRatio) then
    ComposeRatio(json, 'exampleRatio', TFhirRatio(elem.example))
  else if (elem.example is TFhirSampledData) then
    ComposeSampledData(json, 'exampleSampledData', TFhirSampledData(elem.example))
  else if (elem.example is TFhirReference) then
    ComposeReference(json, 'exampleReference', TFhirReference(elem.example))
  else if (elem.example is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'exampleCodeableConcept', TFhirCodeableConcept(elem.example))
  else if (elem.example is TFhirIdentifier) then
    ComposeIdentifier(json, 'exampleIdentifier', TFhirIdentifier(elem.example))
  else if (elem.example is TFhirTiming) then
    ComposeTiming(json, 'exampleTiming', TFhirTiming(elem.example))
  else if (elem.example is TFhirAddress) then
    ComposeAddress(json, 'exampleAddress', TFhirAddress(elem.example))
  else if (elem.example is TFhirHumanName) then
    ComposeHumanName(json, 'exampleHumanName', TFhirHumanName(elem.example))
  else if (elem.example is TFhirContactPoint) then
    ComposeContactPoint(json, 'exampleContactPoint', TFhirContactPoint(elem.example));
  ComposeIntegerValue(json, 'maxLength', elem.maxLengthObject, false);
  ComposeIntegerProps(json, 'maxLength', elem.maxLengthObject, false);
  if elem.conditionList.Count > 0 then
  begin
    json.valueArray('condition');
    ext := false;
    for i := 0 to elem.conditionList.Count - 1 do
    begin
      ext := ext or ((elem.conditionList[i].xmlid <> '') or (elem.conditionList[i].hasExtensions));
      ComposeIdValue(json, '',elem.conditionList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_condition');
      for i := 0 to elem.conditionList.Count - 1 do
        ComposeIdProps(json, '',elem.conditionList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.constraintList.Count > 0 then
  begin
    json.valueArray('constraint');
    for i := 0 to elem.constraintList.Count - 1 do
      ComposeProfileStructureSnapshotElementDefinitionConstraint(json, '',elem.constraintList[i]); {z - }
    json.FinishArray;
  end;
  ComposeBooleanValue(json, 'mustSupport', elem.mustSupportObject, false);
  ComposeBooleanProps(json, 'mustSupport', elem.mustSupportObject, false);
  ComposeBooleanValue(json, 'isModifier', elem.isModifierObject, false);
  ComposeBooleanProps(json, 'isModifier', elem.isModifierObject, false);
  ComposeProfileStructureSnapshotElementDefinitionBinding(json, 'binding', elem.binding); {a}
  if elem.mappingList.Count > 0 then
  begin
    json.valueArray('mapping');
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeProfileStructureSnapshotElementDefinitionMapping(json, '',elem.mappingList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructureSnapshotElementDefinitionType(element : IXmlDomElement; path : string) : TFhirProfileStructureSnapshotElementDefinitionType;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructureSnapshotElementDefinitionType.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeObject := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'profile') then
        result.profileObject := ParseUri(child, path+'/profile') {b}
      else if (child.baseName = 'aggregation') then
        result.aggregationObject.Add(ParseEnum(CODES_TFhirResourceAggregationMode, path+'/aggregation', child)){y.1}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructureSnapshotElementDefinitionType(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSnapshotElementDefinitionType);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.codeObject);{x.2}
  ComposeUri(xml, 'profile', elem.profileObject);{x.2}
  for i := 0 to elem.aggregationObject.Count - 1 do
    ComposeEnum(xml, 'aggregation', elem.aggregationObject[i], CODES_TFhirResourceAggregationMode);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructureSnapshotElementDefinitionType(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructureSnapshotElementDefinitionType(jsn));
end;

function TFHIRJsonParser.ParseProfileStructureSnapshotElementDefinitionType(jsn : TJsonObject) : TFhirProfileStructureSnapshotElementDefinitionType;
begin
  result := TFhirProfileStructureSnapshotElementDefinitionType.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeObject := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('profile') or jsn.has('_profile') then
        result.profileObject := ParseUri(jsn['profile'], jsn.vObj['_profile']);{q}
    if jsn.has('aggregation') or jsn.has('_aggregation') then
      iterateEnumArray(jsn.vArr['aggregation'], jsn.vArr['_aggregation'], result.aggregationObject, parseEnum, CODES_TFhirResourceAggregationMode);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructureSnapshotElementDefinitionType(json : TJSONWriter; name : string; elem : TFhirProfileStructureSnapshotElementDefinitionType);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.codeObject, false);
  ComposeCodeProps(json, 'code', elem.codeObject, false);
  ComposeUriValue(json, 'profile', elem.profileObject, false);
  ComposeUriProps(json, 'profile', elem.profileObject, false);
  if elem.aggregationObject.Count > 0 then
  begin
    json.valueArray('aggregation');
    ext := false;
    for i := 0 to elem.aggregationObject.Count - 1 do
    begin
      ext := ext or ((elem.aggregationObject[i].xmlid <> '') or (elem.aggregationObject[i].hasExtensions));
      ComposeEnumValue(json, '', elem.aggregationObject[i], CODES_TFhirResourceAggregationMode, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_aggregation');
      for i := 0 to elem.aggregationObject.Count - 1 do
        ComposeEnumProps(json, '', elem.aggregationObject[i], CODES_TFhirResourceAggregationMode, true);
      json.FinishArray;
    end;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructureSnapshotElementDefinitionConstraint(element : IXmlDomElement; path : string) : TFhirProfileStructureSnapshotElementDefinitionConstraint;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructureSnapshotElementDefinitionConstraint.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'key') then
        result.keyObject := ParseId(child, path+'/key') {b}
      else if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'severity') then
        result.severityObject := ParseEnum(CODES_TFhirConstraintSeverity, path+'/severity', child){1a}
      else if (child.baseName = 'human') then
        result.humanObject := ParseString(child, path+'/human') {b}
      else if (child.baseName = 'xpath') then
        result.xpathObject := ParseString(child, path+'/xpath') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructureSnapshotElementDefinitionConstraint(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSnapshotElementDefinitionConstraint);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'key', elem.keyObject);{x.2}
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeEnum(xml, 'severity', elem.SeverityObject, CODES_TFhirConstraintSeverity);
  ComposeString(xml, 'human', elem.humanObject);{x.2}
  ComposeString(xml, 'xpath', elem.xpathObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructureSnapshotElementDefinitionConstraint(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructureSnapshotElementDefinitionConstraint(jsn));
end;

function TFHIRJsonParser.ParseProfileStructureSnapshotElementDefinitionConstraint(jsn : TJsonObject) : TFhirProfileStructureSnapshotElementDefinitionConstraint;
begin
  result := TFhirProfileStructureSnapshotElementDefinitionConstraint.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('key') or jsn.has('_key') then
        result.keyObject := ParseId(jsn['key'], jsn.vObj['_key']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityObject := parseEnum(jsn['severity'], jsn.vObj['_severity'], CODES_TFhirConstraintSeverity);
    if jsn.has('human') or jsn.has('_human') then
        result.humanObject := ParseString(jsn['human'], jsn.vObj['_human']);{q}
    if jsn.has('xpath') or jsn.has('_xpath') then
        result.xpathObject := ParseString(jsn['xpath'], jsn.vObj['_xpath']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructureSnapshotElementDefinitionConstraint(json : TJSONWriter; name : string; elem : TFhirProfileStructureSnapshotElementDefinitionConstraint);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'key', elem.keyObject, false);
  ComposeIdProps(json, 'key', elem.keyObject, false);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeEnumValue(json, 'severity', elem.SeverityObject, CODES_TFhirConstraintSeverity, false);
  ComposeEnumProps(json, 'severity', elem.SeverityObject, CODES_TFhirConstraintSeverity, false);
  ComposeStringValue(json, 'human', elem.humanObject, false);
  ComposeStringProps(json, 'human', elem.humanObject, false);
  ComposeStringValue(json, 'xpath', elem.xpathObject, false);
  ComposeStringProps(json, 'xpath', elem.xpathObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructureSnapshotElementDefinitionBinding(element : IXmlDomElement; path : string) : TFhirProfileStructureSnapshotElementDefinitionBinding;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructureSnapshotElementDefinitionBinding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'isExtensible') then
        result.isExtensibleObject := ParseBoolean(child, path+'/isExtensible') {b}
      else if (child.baseName = 'conformance') then
        result.conformanceObject := ParseEnum(CODES_TFhirBindingConformance, path+'/conformance', child){1a}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'referenceUri') then
        result.reference := ParseUri(child, path+'/referenceUri'){x.3}
      else if (child.baseName = 'referenceReference') then
        result.reference := ParseReference(child, path+'/referenceReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructureSnapshotElementDefinitionBinding(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSnapshotElementDefinitionBinding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeBoolean(xml, 'isExtensible', elem.isExtensibleObject);{x.2}
  ComposeEnum(xml, 'conformance', elem.ConformanceObject, CODES_TFhirBindingConformance);
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  if (elem.reference is TFhirUri) {6} then
    ComposeUri(xml, 'referenceUri', TFhirUri(elem.reference))
  else if (elem.reference is TFhirReference) {2} then
    ComposeReference(xml, 'referenceReference', TFhirReference(elem.reference));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructureSnapshotElementDefinitionBinding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructureSnapshotElementDefinitionBinding(jsn));
end;

function TFHIRJsonParser.ParseProfileStructureSnapshotElementDefinitionBinding(jsn : TJsonObject) : TFhirProfileStructureSnapshotElementDefinitionBinding;
begin
  result := TFhirProfileStructureSnapshotElementDefinitionBinding.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('isExtensible') or jsn.has('_isExtensible') then
        result.isExtensibleObject := ParseBoolean(jsn['isExtensible'], jsn.vObj['_isExtensible']);{q}
    if jsn.has('conformance') or jsn.has('_conformance')  then
      result.conformanceObject := parseEnum(jsn['conformance'], jsn.vObj['_conformance'], CODES_TFhirBindingConformance);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('referenceUri') or jsn.has('_referenceUri') then
      result.reference := parseUri(jsn['referenceUri'], jsn.vObj['_referenceUri']);
    if jsn.has('referenceReference') {a3} then
      result.reference := ParseReference(jsn.vObj['referenceReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructureSnapshotElementDefinitionBinding(json : TJSONWriter; name : string; elem : TFhirProfileStructureSnapshotElementDefinitionBinding);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeBooleanValue(json, 'isExtensible', elem.isExtensibleObject, false);
  ComposeBooleanProps(json, 'isExtensible', elem.isExtensibleObject, false);
  ComposeEnumValue(json, 'conformance', elem.ConformanceObject, CODES_TFhirBindingConformance, false);
  ComposeEnumProps(json, 'conformance', elem.ConformanceObject, CODES_TFhirBindingConformance, false);
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  if (elem.reference is TFhirUri) then 
  begin
    ComposeUriValue(json, 'referenceUri', TFhirUri(elem.reference), false);
    ComposeUriProps(json, 'referenceUri', TFhirUri(elem.reference), false);
  end
  else if (elem.reference is TFhirReference) then
    ComposeReference(json, 'referenceReference', TFhirReference(elem.reference));
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructureSnapshotElementDefinitionMapping(element : IXmlDomElement; path : string) : TFhirProfileStructureSnapshotElementDefinitionMapping;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructureSnapshotElementDefinitionMapping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identity') then
        result.identityObject := ParseId(child, path+'/identity') {b}
      else if (child.baseName = 'map') then
        result.mapObject := ParseString(child, path+'/map') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructureSnapshotElementDefinitionMapping(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSnapshotElementDefinitionMapping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'identity', elem.identityObject);{x.2}
  ComposeString(xml, 'map', elem.mapObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructureSnapshotElementDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructureSnapshotElementDefinitionMapping(jsn));
end;

function TFHIRJsonParser.ParseProfileStructureSnapshotElementDefinitionMapping(jsn : TJsonObject) : TFhirProfileStructureSnapshotElementDefinitionMapping;
begin
  result := TFhirProfileStructureSnapshotElementDefinitionMapping.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identity') or jsn.has('_identity') then
        result.identityObject := ParseId(jsn['identity'], jsn.vObj['_identity']);{q}
    if jsn.has('map') or jsn.has('_map') then
        result.mapObject := ParseString(jsn['map'], jsn.vObj['_map']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructureSnapshotElementDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirProfileStructureSnapshotElementDefinitionMapping);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'identity', elem.identityObject, false);
  ComposeIdProps(json, 'identity', elem.identityObject, false);
  ComposeStringValue(json, 'map', elem.mapObject, false);
  ComposeStringProps(json, 'map', elem.mapObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructureSearchParam(element : IXmlDomElement; path : string) : TFhirProfileStructureSearchParam;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructureSearchParam.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'type') then
        result.type_Object := ParseEnum(CODES_TFhirSearchParamType, path+'/type', child){1a}
      else if (child.baseName = 'documentation') then
        result.documentationObject := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'xpath') then
        result.xpathObject := ParseString(child, path+'/xpath') {b}
      else if (child.baseName = 'target') then
        result.targetList.Add(ParseCode(child, path+'/target')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructureSearchParam(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSearchParam);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeEnum(xml, 'type', elem.Type_Object, CODES_TFhirSearchParamType);
  ComposeString(xml, 'documentation', elem.documentationObject);{x.2}
  ComposeString(xml, 'xpath', elem.xpathObject);{x.2}
  for i := 0 to elem.targetList.Count - 1 do
    ComposeCode(xml, 'target', elem.targetList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructureSearchParam(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructureSearchParam(jsn));
end;

function TFHIRJsonParser.ParseProfileStructureSearchParam(jsn : TJsonObject) : TFhirProfileStructureSearchParam;
begin
  result := TFhirProfileStructureSearchParam.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Object := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirSearchParamType);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationObject := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('xpath') or jsn.has('_xpath') then
        result.xpathObject := ParseString(jsn['xpath'], jsn.vObj['_xpath']);{q}
      if jsn.has('target') or jsn.has('_target') then
      iteratePrimitiveArray(jsn.vArr['target'], jsn.vArr['_target'], result.targetList, parseCode);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructureSearchParam(json : TJSONWriter; name : string; elem : TFhirProfileStructureSearchParam);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeEnumValue(json, 'type', elem.Type_Object, CODES_TFhirSearchParamType, false);
  ComposeEnumProps(json, 'type', elem.Type_Object, CODES_TFhirSearchParamType, false);
  ComposeStringValue(json, 'documentation', elem.documentationObject, false);
  ComposeStringProps(json, 'documentation', elem.documentationObject, false);
  ComposeStringValue(json, 'xpath', elem.xpathObject, false);
  ComposeStringProps(json, 'xpath', elem.xpathObject, false);
  if elem.targetList.Count > 0 then
  begin
    json.valueArray('target');
    ext := false;
    for i := 0 to elem.targetList.Count - 1 do
    begin
      ext := ext or ((elem.targetList[i].xmlid <> '') or (elem.targetList[i].hasExtensions));
      ComposeCodeValue(json, '',elem.targetList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_target');
      for i := 0 to elem.targetList.Count - 1 do
        ComposeCodeProps(json, '',elem.targetList[i], true);
      json.FinishArray;
    end;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileExtensionDefn(element : IXmlDomElement; path : string) : TFhirProfileExtensionDefn;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileExtensionDefn.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeObject := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'display') then
        result.displayObject := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'contextType') then
        result.contextTypeObject := ParseEnum(CODES_TFhirExtensionContext, path+'/contextType', child){1a}
      else if (child.baseName = 'context') then
        result.contextList.Add(ParseString(child, path+'/context')){y.2}
      else if (child.baseName = 'element') then
        result.elementList.Add(ParseProfileStructureSnapshotElement(child, path+'/element')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileExtensionDefn(xml : TXmlBuilder; name : string; elem : TFhirProfileExtensionDefn);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.codeObject);{x.2}
  ComposeString(xml, 'display', elem.displayObject);{x.2}
  ComposeEnum(xml, 'contextType', elem.ContextTypeObject, CODES_TFhirExtensionContext);
  for i := 0 to elem.contextList.Count - 1 do
    ComposeString(xml, 'context', elem.contextList[i]);
  for i := 0 to elem.elementList.Count - 1 do
    ComposeProfileStructureSnapshotElement(xml, 'element', elem.elementList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileExtensionDefn(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileExtensionDefn(jsn));
end;

function TFHIRJsonParser.ParseProfileExtensionDefn(jsn : TJsonObject) : TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeObject := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayObject := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('contextType') or jsn.has('_contextType')  then
      result.contextTypeObject := parseEnum(jsn['contextType'], jsn.vObj['_contextType'], CODES_TFhirExtensionContext);
      if jsn.has('context') or jsn.has('_context') then
      iteratePrimitiveArray(jsn.vArr['context'], jsn.vArr['_context'], result.contextList, parseString);
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseProfileStructureSnapshotElement);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileExtensionDefn(json : TJSONWriter; name : string; elem : TFhirProfileExtensionDefn);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.codeObject, false);
  ComposeCodeProps(json, 'code', elem.codeObject, false);
  ComposeStringValue(json, 'display', elem.displayObject, false);
  ComposeStringProps(json, 'display', elem.displayObject, false);
  ComposeEnumValue(json, 'contextType', elem.ContextTypeObject, CODES_TFhirExtensionContext, false);
  ComposeEnumProps(json, 'contextType', elem.ContextTypeObject, CODES_TFhirExtensionContext, false);
  if elem.contextList.Count > 0 then
  begin
    json.valueArray('context');
    ext := false;
    for i := 0 to elem.contextList.Count - 1 do
    begin
      ext := ext or ((elem.contextList[i].xmlid <> '') or (elem.contextList[i].hasExtensions));
      ComposeStringValue(json, '',elem.contextList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_context');
      for i := 0 to elem.contextList.Count - 1 do
        ComposeStringProps(json, '',elem.contextList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.elementList.Count > 0 then
  begin
    json.valueArray('element');
    for i := 0 to elem.elementList.Count - 1 do
      ComposeProfileStructureSnapshotElement(json, '',elem.elementList[i]); {z - @Profile.structure.snapshot.element}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfile(element : IXmlDomElement; path : string) : TFhirProfile;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfile.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlObject := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'version') then
        result.versionObject := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'publisher') then
        result.publisherObject := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'code') then
        result.codeList.Add(ParseCoding(child, path+'/code')){y.2}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirResourceProfileStatus, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalObject := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'requirements') then
        result.requirementsObject := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'fhirVersion') then
        result.fhirVersionObject := ParseId(child, path+'/fhirVersion') {b}
      else if (child.baseName = 'mapping') then
        result.mappingList.Add(ParseProfileMapping(child, path+'/mapping')){y.2}
      else if (child.baseName = 'structure') then
        result.structureList.Add(ParseProfileStructure(child, path+'/structure')){y.2}
      else if (child.baseName = 'extensionDefn') then
        result.extensionDefnList.Add(ParseProfileExtensionDefn(child, path+'/extensionDefn')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfile(xml : TXmlBuilder; name : string; elem : TFhirProfile);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  if not SummaryOnly then
    ComposeUri(xml, 'url', elem.urlObject);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeString(xml, 'version', elem.versionObject);{x.2}
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeString(xml, 'publisher', elem.publisherObject);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  for i := 0 to elem.codeList.Count - 1 do
    ComposeCoding(xml, 'code', elem.codeList[i]);
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirResourceProfileStatus);
  ComposeBoolean(xml, 'experimental', elem.experimentalObject);{x.2}
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  if not SummaryOnly then
    ComposeString(xml, 'requirements', elem.requirementsObject);{x.2}
  ComposeId(xml, 'fhirVersion', elem.fhirVersionObject);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeProfileMapping(xml, 'mapping', elem.mappingList[i]);
  if not SummaryOnly then
    for i := 0 to elem.structureList.Count - 1 do
      ComposeProfileStructure(xml, 'structure', elem.structureList[i]);
  if not SummaryOnly then
    for i := 0 to elem.extensionDefnList.Count - 1 do
      ComposeProfileExtensionDefn(xml, 'extensionDefn', elem.extensionDefnList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfile(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfile(jsn));
end;

function TFHIRJsonParser.ParseProfile(jsn : TJsonObject) : TFhirProfile;
begin
  result := TFhirProfile.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlObject := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionObject := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherObject := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCoding);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirResourceProfileStatus);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalObject := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsObject := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('fhirVersion') or jsn.has('_fhirVersion') then
        result.fhirVersionObject := ParseId(jsn['fhirVersion'], jsn.vObj['_fhirVersion']);{q}
    if jsn.has('mapping') then
      iterateArray(jsn.vArr['mapping'], result.mappingList, parseProfileMapping);
    if jsn.has('structure') then
      iterateArray(jsn.vArr['structure'], result.structureList, parseProfileStructure);
    if jsn.has('extensionDefn') then
      iterateArray(jsn.vArr['extensionDefn'], result.extensionDefnList, parseProfileExtensionDefn);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfile(json : TJSONWriter; name : string; elem : TFhirProfile);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if not SummaryOnly then
    ComposeUriValue(json, 'url', elem.urlObject, false);
  if not SummaryOnly then
    ComposeUriProps(json, 'url', elem.urlObject, false);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'version', elem.versionObject, false);
  ComposeStringProps(json, 'version', elem.versionObject, false);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeStringValue(json, 'publisher', elem.publisherObject, false);
  ComposeStringProps(json, 'publisher', elem.publisherObject, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  if elem.codeList.Count > 0 then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(json, '',elem.codeList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirResourceProfileStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirResourceProfileStatus, false);
  ComposeBooleanValue(json, 'experimental', elem.experimentalObject, false);
  ComposeBooleanProps(json, 'experimental', elem.experimentalObject, false);
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  if not SummaryOnly then
    ComposeStringValue(json, 'requirements', elem.requirementsObject, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'requirements', elem.requirementsObject, false);
  ComposeIdValue(json, 'fhirVersion', elem.fhirVersionObject, false);
  ComposeIdProps(json, 'fhirVersion', elem.fhirVersionObject, false);
  if not SummaryOnly and (elem.mappingList.Count > 0) then
  begin
    json.valueArray('mapping');
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeProfileMapping(json, '',elem.mappingList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.structureList.Count > 0) then
  begin
    json.valueArray('structure');
    for i := 0 to elem.structureList.Count - 1 do
      ComposeProfileStructure(json, '',elem.structureList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.extensionDefnList.Count > 0) then
  begin
    json.valueArray('extensionDefn');
    for i := 0 to elem.extensionDefnList.Count - 1 do
      ComposeProfileExtensionDefn(json, '',elem.extensionDefnList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseProvenanceAgent(element : IXmlDomElement; path : string) : TFhirProvenanceAgent;
var
  child : IXMLDOMElement;
begin
  result := TFhirProvenanceAgent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'role') then
        result.role := ParseCoding(child, path+'/role') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'reference') then
        result.referenceObject := ParseUri(child, path+'/reference') {b}
      else if (child.baseName = 'display') then
        result.displayObject := ParseString(child, path+'/display') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProvenanceAgent(xml : TXmlBuilder; name : string; elem : TFhirProvenanceAgent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'role', elem.role);{x.2}
  ComposeCoding(xml, 'type', elem.type_);{x.2}
  ComposeUri(xml, 'reference', elem.referenceObject);{x.2}
  ComposeString(xml, 'display', elem.displayObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProvenanceAgent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenanceAgent(jsn));
end;

function TFHIRJsonParser.ParseProvenanceAgent(jsn : TJsonObject) : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
        result.role := ParseCoding(jsn.vObj['role']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceObject := ParseUri(jsn['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayObject := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProvenanceAgent(json : TJSONWriter; name : string; elem : TFhirProvenanceAgent);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'role', elem.role); {a}
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeUriValue(json, 'reference', elem.referenceObject, false);
  ComposeUriProps(json, 'reference', elem.referenceObject, false);
  ComposeStringValue(json, 'display', elem.displayObject, false);
  ComposeStringProps(json, 'display', elem.displayObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseProvenanceEntity(element : IXmlDomElement; path : string) : TFhirProvenanceEntity;
var
  child : IXMLDOMElement;
begin
  result := TFhirProvenanceEntity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'role') then
        result.roleObject := ParseEnum(CODES_TFhirProvenanceEntityRole, path+'/role', child){1a}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'reference') then
        result.referenceObject := ParseUri(child, path+'/reference') {b}
      else if (child.baseName = 'display') then
        result.displayObject := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'agent') then
        result.agent := ParseProvenanceAgent(child, path+'/agent') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProvenanceEntity(xml : TXmlBuilder; name : string; elem : TFhirProvenanceEntity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'role', elem.RoleObject, CODES_TFhirProvenanceEntityRole);
  ComposeCoding(xml, 'type', elem.type_);{x.2}
  ComposeUri(xml, 'reference', elem.referenceObject);{x.2}
  ComposeString(xml, 'display', elem.displayObject);{x.2}
  ComposeProvenanceAgent(xml, 'agent', elem.agent);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProvenanceEntity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenanceEntity(jsn));
end;

function TFHIRJsonParser.ParseProvenanceEntity(jsn : TJsonObject) : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') or jsn.has('_role')  then
      result.roleObject := parseEnum(jsn['role'], jsn.vObj['_role'], CODES_TFhirProvenanceEntityRole);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceObject := ParseUri(jsn['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayObject := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('agent') then
        result.agent := ParseProvenanceAgent(jsn.vObj['agent']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProvenanceEntity(json : TJSONWriter; name : string; elem : TFhirProvenanceEntity);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'role', elem.RoleObject, CODES_TFhirProvenanceEntityRole, false);
  ComposeEnumProps(json, 'role', elem.RoleObject, CODES_TFhirProvenanceEntityRole, false);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeUriValue(json, 'reference', elem.referenceObject, false);
  ComposeUriProps(json, 'reference', elem.referenceObject, false);
  ComposeStringValue(json, 'display', elem.displayObject, false);
  ComposeStringProps(json, 'display', elem.displayObject, false);
  ComposeProvenanceAgent(json, 'agent', elem.agent); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseProvenance(element : IXmlDomElement; path : string) : TFhirProvenance;
var
  child : IXMLDOMElement;
begin
  result := TFhirProvenance.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'target') then
        result.targetList.Add(ParseReference{TFhirReference}(child, path+'/target')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'recorded') then
        result.recordedObject := ParseInstant(child, path+'/recorded') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'policy') then
        result.policyList.Add(ParseUri(child, path+'/policy')){y.2}
      else if (child.baseName = 'agent') then
        result.agentList.Add(ParseProvenanceAgent(child, path+'/agent')){y.2}
      else if (child.baseName = 'entity') then
        result.entityList.Add(ParseProvenanceEntity(child, path+'/entity')){y.2}
      else if (child.baseName = 'integritySignature') then
        result.integritySignatureObject := ParseString(child, path+'/integritySignature') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProvenance(xml : TXmlBuilder; name : string; elem : TFhirProvenance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.targetList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'target', elem.targetList[i]);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  ComposeInstant(xml, 'recorded', elem.recordedObject);{x.2}
  ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2}
  ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  for i := 0 to elem.policyList.Count - 1 do
    ComposeUri(xml, 'policy', elem.policyList[i]);
  for i := 0 to elem.agentList.Count - 1 do
    ComposeProvenanceAgent(xml, 'agent', elem.agentList[i]);
  for i := 0 to elem.entityList.Count - 1 do
    ComposeProvenanceEntity(xml, 'entity', elem.entityList[i]);
  ComposeString(xml, 'integritySignature', elem.integritySignatureObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProvenance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenance(jsn));
end;

function TFHIRJsonParser.ParseProvenance(jsn : TJsonObject) : TFhirProvenance;
begin
  result := TFhirProvenance.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('target') then
      iterateArray(jsn.vArr['target'], result.targetList, parseReference{TFhirReference});
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('recorded') or jsn.has('_recorded') then
        result.recordedObject := ParseInstant(jsn['recorded'], jsn.vObj['_recorded']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
      if jsn.has('policy') or jsn.has('_policy') then
      iteratePrimitiveArray(jsn.vArr['policy'], jsn.vArr['_policy'], result.policyList, parseUri);
    if jsn.has('agent') then
      iterateArray(jsn.vArr['agent'], result.agentList, parseProvenanceAgent);
    if jsn.has('entity') then
      iterateArray(jsn.vArr['entity'], result.entityList, parseProvenanceEntity);
    if jsn.has('integritySignature') or jsn.has('_integritySignature') then
        result.integritySignatureObject := ParseString(jsn['integritySignature'], jsn.vObj['_integritySignature']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProvenance(json : TJSONWriter; name : string; elem : TFhirProvenance);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.targetList.Count > 0 then
  begin
    json.valueArray('target');
    for i := 0 to elem.targetList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.targetList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeInstantValue(json, 'recorded', elem.recordedObject, false);
  ComposeInstantProps(json, 'recorded', elem.recordedObject, false);
  ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if elem.policyList.Count > 0 then
  begin
    json.valueArray('policy');
    ext := false;
    for i := 0 to elem.policyList.Count - 1 do
    begin
      ext := ext or ((elem.policyList[i].xmlid <> '') or (elem.policyList[i].hasExtensions));
      ComposeUriValue(json, '',elem.policyList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_policy');
      for i := 0 to elem.policyList.Count - 1 do
        ComposeUriProps(json, '',elem.policyList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.agentList.Count > 0 then
  begin
    json.valueArray('agent');
    for i := 0 to elem.agentList.Count - 1 do
      ComposeProvenanceAgent(json, '',elem.agentList[i]); {z - }
    json.FinishArray;
  end;
  if elem.entityList.Count > 0 then
  begin
    json.valueArray('entity');
    for i := 0 to elem.entityList.Count - 1 do
      ComposeProvenanceEntity(json, '',elem.entityList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'integritySignature', elem.integritySignatureObject, false);
  ComposeStringProps(json, 'integritySignature', elem.integritySignatureObject, false);
end;

function TFHIRXmlParser.ParseQueryResponse(element : IXmlDomElement; path : string) : TFhirQueryResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirQueryResponse.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierObject := ParseUri(child, path+'/identifier') {b}
      else if (child.baseName = 'outcome') then
        result.outcomeObject := ParseEnum(CODES_TFhirQueryOutcome, path+'/outcome', child){1a}
      else if (child.baseName = 'total') then
        result.totalObject := ParseInteger(child, path+'/total') {b}
      else if (child.baseName = 'parameter') then
        result.parameterList.Add(ParseExtension(child, path+'/parameter')){y.2}
      else if (child.baseName = 'first') then
        result.firstList.Add(ParseExtension(child, path+'/first')){y.2}
      else if (child.baseName = 'previous') then
        result.previousList.Add(ParseExtension(child, path+'/previous')){y.2}
      else if (child.baseName = 'next') then
        result.nextList.Add(ParseExtension(child, path+'/next')){y.2}
      else if (child.baseName = 'last') then
        result.lastList.Add(ParseExtension(child, path+'/last')){y.2}
      else if (child.baseName = 'reference') then
        result.referenceList.Add(ParseReference{TFhirReference}(child, path+'/reference')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQueryResponse(xml : TXmlBuilder; name : string; elem : TFhirQueryResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'identifier', elem.identifierObject);{x.2}
  ComposeEnum(xml, 'outcome', elem.OutcomeObject, CODES_TFhirQueryOutcome);
  ComposeInteger(xml, 'total', elem.totalObject);{x.2}
  for i := 0 to elem.parameterList.Count - 1 do
    ComposeExtension(xml, 'parameter', elem.parameterList[i]);
  for i := 0 to elem.firstList.Count - 1 do
    ComposeExtension(xml, 'first', elem.firstList[i]);
  for i := 0 to elem.previousList.Count - 1 do
    ComposeExtension(xml, 'previous', elem.previousList[i]);
  for i := 0 to elem.nextList.Count - 1 do
    ComposeExtension(xml, 'next', elem.nextList[i]);
  for i := 0 to elem.lastList.Count - 1 do
    ComposeExtension(xml, 'last', elem.lastList[i]);
  for i := 0 to elem.referenceList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'reference', elem.referenceList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQueryResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQueryResponse(jsn));
end;

function TFHIRJsonParser.ParseQueryResponse(jsn : TJsonObject) : TFhirQueryResponse;
begin
  result := TFhirQueryResponse.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierObject := ParseUri(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeObject := parseEnum(jsn['outcome'], jsn.vObj['_outcome'], CODES_TFhirQueryOutcome);
    if jsn.has('total') or jsn.has('_total') then
        result.totalObject := ParseInteger(jsn['total'], jsn.vObj['_total']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseExtension);
    if jsn.has('first') then
      iterateArray(jsn.vArr['first'], result.firstList, parseExtension);
    if jsn.has('previous') then
      iterateArray(jsn.vArr['previous'], result.previousList, parseExtension);
    if jsn.has('next') then
      iterateArray(jsn.vArr['next'], result.nextList, parseExtension);
    if jsn.has('last') then
      iterateArray(jsn.vArr['last'], result.lastList, parseExtension);
    if jsn.has('reference') then
      iterateArray(jsn.vArr['reference'], result.referenceList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQueryResponse(json : TJSONWriter; name : string; elem : TFhirQueryResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'identifier', elem.identifierObject, false);
  ComposeUriProps(json, 'identifier', elem.identifierObject, false);
  ComposeEnumValue(json, 'outcome', elem.OutcomeObject, CODES_TFhirQueryOutcome, false);
  ComposeEnumProps(json, 'outcome', elem.OutcomeObject, CODES_TFhirQueryOutcome, false);
  ComposeIntegerValue(json, 'total', elem.totalObject, false);
  ComposeIntegerProps(json, 'total', elem.totalObject, false);
  if elem.parameterList.Count > 0 then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeExtension(json, '',elem.parameterList[i]); {z - Extension}
    json.FinishArray;
  end;
  if elem.firstList.Count > 0 then
  begin
    json.valueArray('first');
    for i := 0 to elem.firstList.Count - 1 do
      ComposeExtension(json, '',elem.firstList[i]); {z - Extension}
    json.FinishArray;
  end;
  if elem.previousList.Count > 0 then
  begin
    json.valueArray('previous');
    for i := 0 to elem.previousList.Count - 1 do
      ComposeExtension(json, '',elem.previousList[i]); {z - Extension}
    json.FinishArray;
  end;
  if elem.nextList.Count > 0 then
  begin
    json.valueArray('next');
    for i := 0 to elem.nextList.Count - 1 do
      ComposeExtension(json, '',elem.nextList[i]); {z - Extension}
    json.FinishArray;
  end;
  if elem.lastList.Count > 0 then
  begin
    json.valueArray('last');
    for i := 0 to elem.lastList.Count - 1 do
      ComposeExtension(json, '',elem.lastList[i]); {z - Extension}
    json.FinishArray;
  end;
  if elem.referenceList.Count > 0 then
  begin
    json.valueArray('reference');
    for i := 0 to elem.referenceList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.referenceList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseQuery(element : IXmlDomElement; path : string) : TFhirQuery;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuery.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierObject := ParseUri(child, path+'/identifier') {b}
      else if (child.baseName = 'parameter') then
        result.parameterList.Add(ParseExtension(child, path+'/parameter')){y.2}
      else if (child.baseName = 'response') then
        result.response := ParseQueryResponse(child, path+'/response') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuery(xml : TXmlBuilder; name : string; elem : TFhirQuery);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeUri(xml, 'identifier', elem.identifierObject);{x.2}
  for i := 0 to elem.parameterList.Count - 1 do
    ComposeExtension(xml, 'parameter', elem.parameterList[i]);
  ComposeQueryResponse(xml, 'response', elem.response);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuery(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuery(jsn));
end;

function TFHIRJsonParser.ParseQuery(jsn : TJsonObject) : TFhirQuery;
begin
  result := TFhirQuery.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierObject := ParseUri(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseExtension);
    if jsn.has('response') then
        result.response := ParseQueryResponse(jsn.vObj['response']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuery(json : TJSONWriter; name : string; elem : TFhirQuery);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeUriValue(json, 'identifier', elem.identifierObject, false);
  ComposeUriProps(json, 'identifier', elem.identifierObject, false);
  if elem.parameterList.Count > 0 then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeExtension(json, '',elem.parameterList[i]); {z - Extension}
    json.FinishArray;
  end;
  ComposeQueryResponse(json, 'response', elem.response); {a}
end;

function TFHIRXmlParser.ParseQuestionnaireGroup(element : IXmlDomElement; path : string) : TFhirQuestionnaireGroup;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'linkId') then
        result.linkIdObject := ParseString(child, path+'/linkId') {b}
      else if (child.baseName = 'title') then
        result.titleObject := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseCoding(child, path+'/concept')){y.2}
      else if (child.baseName = 'text') then
        result.textObject := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'required') then
        result.requiredObject := ParseBoolean(child, path+'/required') {b}
      else if (child.baseName = 'repeats') then
        result.repeatsObject := ParseBoolean(child, path+'/repeats') {b}
      else if (child.baseName = 'group') then
        result.groupList.Add(ParseQuestionnaireGroup(child, path+'/group')){y.2}
      else if (child.baseName = 'question') then
        result.questionList.Add(ParseQuestionnaireGroupQuestion(child, path+'/question')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireGroup(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroup);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'linkId', elem.linkIdObject);{x.2}
  ComposeString(xml, 'title', elem.titleObject);{x.2}
  for i := 0 to elem.conceptList.Count - 1 do
    ComposeCoding(xml, 'concept', elem.conceptList[i]);
  ComposeString(xml, 'text', elem.textObject);{x.2}
  ComposeBoolean(xml, 'required', elem.requiredObject);{x.2}
  ComposeBoolean(xml, 'repeats', elem.repeatsObject);{x.2}
  for i := 0 to elem.groupList.Count - 1 do
    ComposeQuestionnaireGroup(xml, 'group', elem.groupList[i]);
  for i := 0 to elem.questionList.Count - 1 do
    ComposeQuestionnaireGroupQuestion(xml, 'question', elem.questionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireGroup(jsn));
end;

function TFHIRJsonParser.ParseQuestionnaireGroup(jsn : TJsonObject) : TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdObject := ParseString(jsn['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleObject := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseCoding);
    if jsn.has('text') or jsn.has('_text') then
        result.textObject := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('required') or jsn.has('_required') then
        result.requiredObject := ParseBoolean(jsn['required'], jsn.vObj['_required']);{q}
    if jsn.has('repeats') or jsn.has('_repeats') then
        result.repeatsObject := ParseBoolean(jsn['repeats'], jsn.vObj['_repeats']);{q}
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireGroup);
    if jsn.has('question') then
      iterateArray(jsn.vArr['question'], result.questionList, parseQuestionnaireGroupQuestion);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroup);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'linkId', elem.linkIdObject, false);
  ComposeStringProps(json, 'linkId', elem.linkIdObject, false);
  ComposeStringValue(json, 'title', elem.titleObject, false);
  ComposeStringProps(json, 'title', elem.titleObject, false);
  if elem.conceptList.Count > 0 then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCoding(json, '',elem.conceptList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'text', elem.textObject, false);
  ComposeStringProps(json, 'text', elem.textObject, false);
  ComposeBooleanValue(json, 'required', elem.requiredObject, false);
  ComposeBooleanProps(json, 'required', elem.requiredObject, false);
  ComposeBooleanValue(json, 'repeats', elem.repeatsObject, false);
  ComposeBooleanProps(json, 'repeats', elem.repeatsObject, false);
  if elem.groupList.Count > 0 then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(json, '',elem.groupList[i]); {z - @Questionnaire.group}
    json.FinishArray;
  end;
  if elem.questionList.Count > 0 then
  begin
    json.valueArray('question');
    for i := 0 to elem.questionList.Count - 1 do
      ComposeQuestionnaireGroupQuestion(json, '',elem.questionList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseQuestionnaireGroupQuestion(element : IXmlDomElement; path : string) : TFhirQuestionnaireGroupQuestion;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireGroupQuestion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'linkId') then
        result.linkIdObject := ParseString(child, path+'/linkId') {b}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseCoding(child, path+'/concept')){y.2}
      else if (child.baseName = 'text') then
        result.textObject := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'type') then
        result.type_Object := ParseEnum(CODES_TFhirAnswerFormat, path+'/type', child){1a}
      else if (child.baseName = 'required') then
        result.requiredObject := ParseBoolean(child, path+'/required') {b}
      else if (child.baseName = 'repeats') then
        result.repeatsObject := ParseBoolean(child, path+'/repeats') {b}
      else if (child.baseName = 'options') then
        result.options := ParseReference{TFhirValueSet}(child, path+'/options') {b}
      else if (child.baseName = 'group') then
        result.groupList.Add(ParseQuestionnaireGroup(child, path+'/group')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireGroupQuestion(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroupQuestion);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'linkId', elem.linkIdObject);{x.2}
  for i := 0 to elem.conceptList.Count - 1 do
    ComposeCoding(xml, 'concept', elem.conceptList[i]);
  ComposeString(xml, 'text', elem.textObject);{x.2}
  ComposeEnum(xml, 'type', elem.Type_Object, CODES_TFhirAnswerFormat);
  ComposeBoolean(xml, 'required', elem.requiredObject);{x.2}
  ComposeBoolean(xml, 'repeats', elem.repeatsObject);{x.2}
  ComposeReference{TFhirValueSet}(xml, 'options', elem.options);{x.2}
  for i := 0 to elem.groupList.Count - 1 do
    ComposeQuestionnaireGroup(xml, 'group', elem.groupList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireGroupQuestion(jsn));
end;

function TFHIRJsonParser.ParseQuestionnaireGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdObject := ParseString(jsn['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseCoding);
    if jsn.has('text') or jsn.has('_text') then
        result.textObject := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Object := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirAnswerFormat);
    if jsn.has('required') or jsn.has('_required') then
        result.requiredObject := ParseBoolean(jsn['required'], jsn.vObj['_required']);{q}
    if jsn.has('repeats') or jsn.has('_repeats') then
        result.repeatsObject := ParseBoolean(jsn['repeats'], jsn.vObj['_repeats']);{q}
    if jsn.has('options') then
        result.options := ParseReference{TFhirValueSet}(jsn.vObj['options']);{q}
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireGroup);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroupQuestion);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'linkId', elem.linkIdObject, false);
  ComposeStringProps(json, 'linkId', elem.linkIdObject, false);
  if elem.conceptList.Count > 0 then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCoding(json, '',elem.conceptList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'text', elem.textObject, false);
  ComposeStringProps(json, 'text', elem.textObject, false);
  ComposeEnumValue(json, 'type', elem.Type_Object, CODES_TFhirAnswerFormat, false);
  ComposeEnumProps(json, 'type', elem.Type_Object, CODES_TFhirAnswerFormat, false);
  ComposeBooleanValue(json, 'required', elem.requiredObject, false);
  ComposeBooleanProps(json, 'required', elem.requiredObject, false);
  ComposeBooleanValue(json, 'repeats', elem.repeatsObject, false);
  ComposeBooleanProps(json, 'repeats', elem.repeatsObject, false);
  ComposeReference{TFhirValueSet}(json, 'options', elem.options); {a}
  if elem.groupList.Count > 0 then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(json, '',elem.groupList[i]); {z - @Questionnaire.group}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseQuestionnaire(element : IXmlDomElement; path : string) : TFhirQuestionnaire;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaire.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'version') then
        result.versionObject := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirQuestionnaireStatus, path+'/status', child){1a}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'publisher') then
        result.publisherObject := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'group') then
        result.group := ParseQuestionnaireGroup(child, path+'/group') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaire(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaire);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeString(xml, 'version', elem.versionObject);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirQuestionnaireStatus);
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  ComposeString(xml, 'publisher', elem.publisherObject);{x.2}
  if not SummaryOnly then
    ComposeQuestionnaireGroup(xml, 'group', elem.group);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaire(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaire(jsn));
end;

function TFHIRJsonParser.ParseQuestionnaire(jsn : TJsonObject) : TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionObject := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirQuestionnaireStatus);
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherObject := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('group') then
        result.group := ParseQuestionnaireGroup(jsn.vObj['group']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaire(json : TJSONWriter; name : string; elem : TFhirQuestionnaire);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'version', elem.versionObject, false);
  ComposeStringProps(json, 'version', elem.versionObject, false);
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirQuestionnaireStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirQuestionnaireStatus, false);
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  ComposeStringValue(json, 'publisher', elem.publisherObject, false);
  ComposeStringProps(json, 'publisher', elem.publisherObject, false);
  if not SummaryOnly then
    ComposeQuestionnaireGroup(json, 'group', elem.group); {a}
end;

function TFHIRXmlParser.ParseQuestionnaireAnswersGroup(element : IXmlDomElement; path : string) : TFhirQuestionnaireAnswersGroup;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireAnswersGroup.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'linkId') then
        result.linkIdObject := ParseString(child, path+'/linkId') {b}
      else if (child.baseName = 'title') then
        result.titleObject := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'text') then
        result.textObject := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.baseName = 'group') then
        result.groupList.Add(ParseQuestionnaireAnswersGroup(child, path+'/group')){y.2}
      else if (child.baseName = 'question') then
        result.questionList.Add(ParseQuestionnaireAnswersGroupQuestion(child, path+'/question')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireAnswersGroup(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireAnswersGroup);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'linkId', elem.linkIdObject);{x.2}
  ComposeString(xml, 'title', elem.titleObject);{x.2}
  ComposeString(xml, 'text', elem.textObject);{x.2}
  ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2}
  for i := 0 to elem.groupList.Count - 1 do
    ComposeQuestionnaireAnswersGroup(xml, 'group', elem.groupList[i]);
  for i := 0 to elem.questionList.Count - 1 do
    ComposeQuestionnaireAnswersGroupQuestion(xml, 'question', elem.questionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireAnswersGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireAnswersGroup(jsn));
end;

function TFHIRJsonParser.ParseQuestionnaireAnswersGroup(jsn : TJsonObject) : TFhirQuestionnaireAnswersGroup;
begin
  result := TFhirQuestionnaireAnswersGroup.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdObject := ParseString(jsn['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleObject := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textObject := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q}
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireAnswersGroup);
    if jsn.has('question') then
      iterateArray(jsn.vArr['question'], result.questionList, parseQuestionnaireAnswersGroupQuestion);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireAnswersGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireAnswersGroup);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'linkId', elem.linkIdObject, false);
  ComposeStringProps(json, 'linkId', elem.linkIdObject, false);
  ComposeStringValue(json, 'title', elem.titleObject, false);
  ComposeStringProps(json, 'title', elem.titleObject, false);
  ComposeStringValue(json, 'text', elem.textObject, false);
  ComposeStringProps(json, 'text', elem.textObject, false);
  ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  if elem.groupList.Count > 0 then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireAnswersGroup(json, '',elem.groupList[i]); {z - @QuestionnaireAnswers.group}
    json.FinishArray;
  end;
  if elem.questionList.Count > 0 then
  begin
    json.valueArray('question');
    for i := 0 to elem.questionList.Count - 1 do
      ComposeQuestionnaireAnswersGroupQuestion(json, '',elem.questionList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseQuestionnaireAnswersGroupQuestion(element : IXmlDomElement; path : string) : TFhirQuestionnaireAnswersGroupQuestion;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireAnswersGroupQuestion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'linkId') then
        result.linkIdObject := ParseString(child, path+'/linkId') {b}
      else if (child.baseName = 'text') then
        result.textObject := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'answer') then
        result.answerList.Add(ParseQuestionnaireAnswersGroupQuestionAnswer(child, path+'/answer')){y.2}
      else if (child.baseName = 'group') then
        result.groupList.Add(ParseQuestionnaireAnswersGroup(child, path+'/group')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireAnswersGroupQuestion(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireAnswersGroupQuestion);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'linkId', elem.linkIdObject);{x.2}
  ComposeString(xml, 'text', elem.textObject);{x.2}
  for i := 0 to elem.answerList.Count - 1 do
    ComposeQuestionnaireAnswersGroupQuestionAnswer(xml, 'answer', elem.answerList[i]);
  for i := 0 to elem.groupList.Count - 1 do
    ComposeQuestionnaireAnswersGroup(xml, 'group', elem.groupList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireAnswersGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireAnswersGroupQuestion(jsn));
end;

function TFHIRJsonParser.ParseQuestionnaireAnswersGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireAnswersGroupQuestion;
begin
  result := TFhirQuestionnaireAnswersGroupQuestion.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdObject := ParseString(jsn['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textObject := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('answer') then
      iterateArray(jsn.vArr['answer'], result.answerList, parseQuestionnaireAnswersGroupQuestionAnswer);
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireAnswersGroup);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireAnswersGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireAnswersGroupQuestion);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'linkId', elem.linkIdObject, false);
  ComposeStringProps(json, 'linkId', elem.linkIdObject, false);
  ComposeStringValue(json, 'text', elem.textObject, false);
  ComposeStringProps(json, 'text', elem.textObject, false);
  if elem.answerList.Count > 0 then
  begin
    json.valueArray('answer');
    for i := 0 to elem.answerList.Count - 1 do
      ComposeQuestionnaireAnswersGroupQuestionAnswer(json, '',elem.answerList[i]); {z - }
    json.FinishArray;
  end;
  if elem.groupList.Count > 0 then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireAnswersGroup(json, '',elem.groupList[i]); {z - @QuestionnaireAnswers.group}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseQuestionnaireAnswersGroupQuestionAnswer(element : IXmlDomElement; path : string) : TFhirQuestionnaireAnswersGroupQuestionAnswer;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireAnswersGroupQuestionAnswer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.baseName = 'valueDecimal') then
        result.value := ParseDecimal(child, path+'/valueDecimal'){x.3}
      else if (child.baseName = 'valueInteger') then
        result.value := ParseInteger(child, path+'/valueInteger'){x.3}
      else if (child.baseName = 'valueDate') then
        result.value := ParseDate(child, path+'/valueDate'){x.3}
      else if (child.baseName = 'valueDateTime') then
        result.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.baseName = 'valueInstant') then
        result.value := ParseInstant(child, path+'/valueInstant'){x.3}
      else if (child.baseName = 'valueTime') then
        result.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.baseName = 'valueAttachment') then
        result.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.baseName = 'valueCoding') then
        result.value := ParseCoding(child, path+'/valueCoding'){x.3}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.baseName = 'valueReference') then
        result.value := ParseReference(child, path+'/valueReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireAnswersGroupQuestionAnswer(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireAnswersGroupQuestionAnswer);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (elem.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (elem.value is TFhirInstant) {6} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirReference) {2} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireAnswersGroupQuestionAnswer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireAnswersGroupQuestionAnswer(jsn));
end;

function TFHIRJsonParser.ParseQuestionnaireAnswersGroupQuestionAnswer(jsn : TJsonObject) : TFhirQuestionnaireAnswersGroupQuestionAnswer;
begin
  result := TFhirQuestionnaireAnswersGroupQuestionAnswer.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := parseDecimal(jsn['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
      result.value := parseDate(jsn['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
      result.value := parseInstant(jsn['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueCoding') {a4} then
      result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueReference') {a3} then
      result.value := ParseReference(jsn.vObj['valueReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireAnswersGroupQuestionAnswer(json : TJSONWriter; name : string; elem : TFhirQuestionnaireAnswersGroupQuestionAnswer);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end
  else if (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (elem.value is TFhirDate) then 
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false);
  end
  else if (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end
  else if (elem.value is TFhirInstant) then 
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false);
  end
  else if (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (elem.value is TFhirCoding) then 
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value)) 
  else if (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value));
  json.finishObject;
end;

function TFHIRXmlParser.ParseQuestionnaireAnswers(element : IXmlDomElement; path : string) : TFhirQuestionnaireAnswers;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireAnswers.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'questionnaire') then
        result.questionnaire := ParseReference{TFhirQuestionnaire}(child, path+'/questionnaire') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirQuestionnaireAnswersStatus, path+'/status', child){1a}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'authored') then
        result.authoredObject := ParseDateTime(child, path+'/authored') {b}
      else if (child.baseName = 'source') then
        result.source := ParseReference{Resource}(child, path+'/source') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'group') then
        result.group := ParseQuestionnaireAnswersGroup(child, path+'/group') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireAnswers(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireAnswers);
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeReference{TFhirQuestionnaire}(xml, 'questionnaire', elem.questionnaire);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirQuestionnaireAnswersStatus);
  ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{Resource}(xml, 'author', elem.author);{x.2}
  ComposeDateTime(xml, 'authored', elem.authoredObject);{x.2}
  ComposeReference{Resource}(xml, 'source', elem.source);{x.2}
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if not SummaryOnly then
    ComposeQuestionnaireAnswersGroup(xml, 'group', elem.group);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireAnswers(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireAnswers(jsn));
end;

function TFHIRJsonParser.ParseQuestionnaireAnswers(jsn : TJsonObject) : TFhirQuestionnaireAnswers;
begin
  result := TFhirQuestionnaireAnswers.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('questionnaire') then
        result.questionnaire := ParseReference{TFhirQuestionnaire}(jsn.vObj['questionnaire']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirQuestionnaireAnswersStatus);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('authored') or jsn.has('_authored') then
        result.authoredObject := ParseDateTime(jsn['authored'], jsn.vObj['_authored']);{q}
    if jsn.has('source') then
        result.source := ParseReference{Resource}(jsn.vObj['source']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('group') then
        result.group := ParseQuestionnaireAnswersGroup(jsn.vObj['group']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireAnswers(json : TJSONWriter; name : string; elem : TFhirQuestionnaireAnswers);
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeReference{TFhirQuestionnaire}(json, 'questionnaire', elem.questionnaire); {a}
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirQuestionnaireAnswersStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirQuestionnaireAnswersStatus, false);
  ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  ComposeReference{Resource}(json, 'author', elem.author); {a}
  ComposeDateTimeValue(json, 'authored', elem.authoredObject, false);
  ComposeDateTimeProps(json, 'authored', elem.authoredObject, false);
  ComposeReference{Resource}(json, 'source', elem.source); {a}
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if not SummaryOnly then
    ComposeQuestionnaireAnswersGroup(json, 'group', elem.group); {a}
end;

function TFHIRXmlParser.ParseReferralRequest(element : IXmlDomElement; path : string) : TFhirReferralRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirReferralRequest.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirReferralstatus, path+'/status', child){1a}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'specialty') then
        result.specialty := ParseCodeableConcept(child, path+'/specialty') {b}
      else if (child.baseName = 'priority') then
        result.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'requester') then
        result.requester := ParseReference{Resource}(child, path+'/requester') {b}
      else if (child.baseName = 'recipient') then
        result.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'dateSent') then
        result.dateSentObject := ParseDateTime(child, path+'/dateSent') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'serviceRequested') then
        result.serviceRequestedList.Add(ParseCodeableConcept(child, path+'/serviceRequested')){y.2}
      else if (child.baseName = 'supportingInformation') then
        result.supportingInformationList.Add(ParseReference{TFhirReference}(child, path+'/supportingInformation')){y.2}
      else if (child.baseName = 'fulfillmentTime') then
        result.fulfillmentTime := ParsePeriod(child, path+'/fulfillmentTime') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeReferralRequest(xml : TXmlBuilder; name : string; elem : TFhirReferralRequest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirReferralstatus);
  if not SummaryOnly then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if not SummaryOnly then
    ComposeCodeableConcept(xml, 'specialty', elem.specialty);{x.2}
  ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2}
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{Resource}(xml, 'requester', elem.requester);{x.2}
  for i := 0 to elem.recipientList.Count - 1 do
    ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  if not SummaryOnly then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  ComposeDateTime(xml, 'dateSent', elem.dateSentObject);{x.2}
  ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2}
  if not SummaryOnly then
    ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  for i := 0 to elem.serviceRequestedList.Count - 1 do
    ComposeCodeableConcept(xml, 'serviceRequested', elem.serviceRequestedList[i]);
  for i := 0 to elem.supportingInformationList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'supportingInformation', elem.supportingInformationList[i]);
  ComposePeriod(xml, 'fulfillmentTime', elem.fulfillmentTime);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseReferralRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseReferralRequest(jsn));
end;

function TFHIRJsonParser.ParseReferralRequest(jsn : TJsonObject) : TFhirReferralRequest;
begin
  result := TFhirReferralRequest.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirReferralstatus);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('specialty') then
        result.specialty := ParseCodeableConcept(jsn.vObj['specialty']);{q}
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('requester') then
        result.requester := ParseReference{Resource}(jsn.vObj['requester']);{q}
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{Resource});
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('dateSent') or jsn.has('_dateSent') then
        result.dateSentObject := ParseDateTime(jsn['dateSent'], jsn.vObj['_dateSent']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('serviceRequested') then
      iterateArray(jsn.vArr['serviceRequested'], result.serviceRequestedList, parseCodeableConcept);
    if jsn.has('supportingInformation') then
      iterateArray(jsn.vArr['supportingInformation'], result.supportingInformationList, parseReference{TFhirReference});
    if jsn.has('fulfillmentTime') then
        result.fulfillmentTime := ParsePeriod(jsn.vObj['fulfillmentTime']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeReferralRequest(json : TJSONWriter; name : string; elem : TFhirReferralRequest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirReferralstatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirReferralstatus, false);
  if not SummaryOnly and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if not SummaryOnly then
    ComposeCodeableConcept(json, 'specialty', elem.specialty); {a}
  ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeReference{Resource}(json, 'requester', elem.requester); {a}
  if elem.recipientList.Count > 0 then
  begin
    json.valueArray('recipient');
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.recipientList[i]); {z - Reference(Practitioner|Organization)}
    json.FinishArray;
  end;
  if not SummaryOnly then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeDateTimeValue(json, 'dateSent', elem.dateSentObject, false);
  ComposeDateTimeProps(json, 'dateSent', elem.dateSentObject, false);
  ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if not SummaryOnly then
    ComposeStringValue(json, 'description', elem.descriptionObject, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'description', elem.descriptionObject, false);
  if elem.serviceRequestedList.Count > 0 then
  begin
    json.valueArray('serviceRequested');
    for i := 0 to elem.serviceRequestedList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.serviceRequestedList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.supportingInformationList.Count > 0 then
  begin
    json.valueArray('supportingInformation');
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.supportingInformationList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  ComposePeriod(json, 'fulfillmentTime', elem.fulfillmentTime); {a}
end;

function TFHIRXmlParser.ParseRelatedPerson(element : IXmlDomElement; path : string) : TFhirRelatedPerson;
var
  child : IXMLDOMElement;
begin
  result := TFhirRelatedPerson.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'relationship') then
        result.relationship := ParseCodeableConcept(child, path+'/relationship') {b}
      else if (child.baseName = 'name') then
        result.name := ParseHumanName(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'gender') then
        result.genderObject := ParseEnum(CODES_TFhirAdministrativeGender, path+'/gender', child){1a}
      else if (child.baseName = 'address') then
        result.address := ParseAddress(child, path+'/address') {b}
      else if (child.baseName = 'photo') then
        result.photoList.Add(ParseAttachment(child, path+'/photo')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRelatedPerson(xml : TXmlBuilder; name : string; elem : TFhirRelatedPerson);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeCodeableConcept(xml, 'relationship', elem.relationship);{x.2}
  ComposeHumanName(xml, 'name', elem.name);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeEnum(xml, 'gender', elem.GenderObject, CODES_TFhirAdministrativeGender);
  ComposeAddress(xml, 'address', elem.address);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', elem.photoList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRelatedPerson(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRelatedPerson(jsn));
end;

function TFHIRJsonParser.ParseRelatedPerson(jsn : TJsonObject) : TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCodeableConcept(jsn.vObj['relationship']);{q}
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderObject := parseEnum(jsn['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGender);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q}
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRelatedPerson(json : TJSONWriter; name : string; elem : TFhirRelatedPerson);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeCodeableConcept(json, 'relationship', elem.relationship); {a}
  ComposeHumanName(json, 'name', elem.name); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'gender', elem.GenderObject, CODES_TFhirAdministrativeGender, false);
  ComposeEnumProps(json, 'gender', elem.GenderObject, CODES_TFhirAdministrativeGender, false);
  ComposeAddress(json, 'address', elem.address); {a}
  if not SummaryOnly and (elem.photoList.Count > 0) then
  begin
    json.valueArray('photo');
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '',elem.photoList[i]); {z - Attachment}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseRiskAssessmentPrediction(element : IXmlDomElement; path : string) : TFhirRiskAssessmentPrediction;
var
  child : IXMLDOMElement;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'outcome') then
        result.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.baseName = 'probabilityDecimal') then
        result.probability := ParseDecimal(child, path+'/probabilityDecimal'){x.3}
      else if (child.baseName = 'probabilityRange') then
        result.probability := ParseRange(child, path+'/probabilityRange'){x.3}
      else if (child.baseName = 'probabilityCodeableConcept') then
        result.probability := ParseCodeableConcept(child, path+'/probabilityCodeableConcept'){x.3}
      else if (child.baseName = 'relativeRisk') then
        result.relativeRiskObject := ParseDecimal(child, path+'/relativeRisk') {b}
      else if (child.baseName = 'whenPeriod') then
        result.when := ParsePeriod(child, path+'/whenPeriod'){x.3}
      else if (child.baseName = 'whenRange') then
        result.when := ParseRange(child, path+'/whenRange'){x.3}
      else if (child.baseName = 'rationale') then
        result.rationaleObject := ParseString(child, path+'/rationale') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessmentPrediction(xml : TXmlBuilder; name : string; elem : TFhirRiskAssessmentPrediction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2}
  if (elem.probability is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'probabilityDecimal', TFhirDecimal(elem.probability))
  else if (elem.probability is TFhirRange) {6} then
    ComposeRange(xml, 'probabilityRange', TFhirRange(elem.probability))
  else if (elem.probability is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'probabilityCodeableConcept', TFhirCodeableConcept(elem.probability));
  ComposeDecimal(xml, 'relativeRisk', elem.relativeRiskObject);{x.2}
  if (elem.when is TFhirPeriod) {6} then
    ComposePeriod(xml, 'whenPeriod', TFhirPeriod(elem.when))
  else if (elem.when is TFhirRange) {6} then
    ComposeRange(xml, 'whenRange', TFhirRange(elem.when));
  ComposeString(xml, 'rationale', elem.rationaleObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRiskAssessmentPrediction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRiskAssessmentPrediction(jsn));
end;

function TFHIRJsonParser.ParseRiskAssessmentPrediction(jsn : TJsonObject) : TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('outcome') then
        result.outcome := ParseCodeableConcept(jsn.vObj['outcome']);{q}
    if jsn.has('probabilityDecimal') or jsn.has('_probabilityDecimal') then
      result.probability := parseDecimal(jsn['probabilityDecimal'], jsn.vObj['_probabilityDecimal']);
    if jsn.has('probabilityRange') {a4} then
      result.probability := ParseRange(jsn.vObj['probabilityRange']);
    if jsn.has('probabilityCodeableConcept') {a4} then
      result.probability := ParseCodeableConcept(jsn.vObj['probabilityCodeableConcept']);
    if jsn.has('relativeRisk') or jsn.has('_relativeRisk') then
        result.relativeRiskObject := ParseDecimal(jsn['relativeRisk'], jsn.vObj['_relativeRisk']);{q}
    if jsn.has('whenPeriod') {a4} then
      result.when := ParsePeriod(jsn.vObj['whenPeriod']);
    if jsn.has('whenRange') {a4} then
      result.when := ParseRange(jsn.vObj['whenRange']);
    if jsn.has('rationale') or jsn.has('_rationale') then
        result.rationaleObject := ParseString(jsn['rationale'], jsn.vObj['_rationale']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRiskAssessmentPrediction(json : TJSONWriter; name : string; elem : TFhirRiskAssessmentPrediction);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'outcome', elem.outcome); {a}
  if (elem.probability is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'probabilityDecimal', TFhirDecimal(elem.probability), false);
    ComposeDecimalProps(json, 'probabilityDecimal', TFhirDecimal(elem.probability), false);
  end
  else if (elem.probability is TFhirRange) then 
    ComposeRange(json, 'probabilityRange', TFhirRange(elem.probability)) 
  else if (elem.probability is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'probabilityCodeableConcept', TFhirCodeableConcept(elem.probability)) ;
  ComposeDecimalValue(json, 'relativeRisk', elem.relativeRiskObject, false);
  ComposeDecimalProps(json, 'relativeRisk', elem.relativeRiskObject, false);
  if (elem.when is TFhirPeriod) then 
    ComposePeriod(json, 'whenPeriod', TFhirPeriod(elem.when)) 
  else if (elem.when is TFhirRange) then 
    ComposeRange(json, 'whenRange', TFhirRange(elem.when)) ;
  ComposeStringValue(json, 'rationale', elem.rationaleObject, false);
  ComposeStringProps(json, 'rationale', elem.rationaleObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseRiskAssessment(element : IXmlDomElement; path : string) : TFhirRiskAssessment;
var
  child : IXMLDOMElement;
begin
  result := TFhirRiskAssessment.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'condition') then
        result.condition := ParseReference{TFhirCondition}(child, path+'/condition') {b}
      else if (child.baseName = 'performer') then
        result.performer := ParseReference{Resource}(child, path+'/performer') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'basis') then
        result.basisList.Add(ParseReference{TFhirReference}(child, path+'/basis')){y.2}
      else if (child.baseName = 'prediction') then
        result.predictionList.Add(ParseRiskAssessmentPrediction(child, path+'/prediction')){y.2}
      else if (child.baseName = 'mitigation') then
        result.mitigationObject := ParseString(child, path+'/mitigation') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessment(xml : TXmlBuilder; name : string; elem : TFhirRiskAssessment);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  ComposeReference{TFhirCondition}(xml, 'condition', elem.condition);{x.2}
  ComposeReference{Resource}(xml, 'performer', elem.performer);{x.2}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  if not SummaryOnly then
    for i := 0 to elem.basisList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'basis', elem.basisList[i]);
  if not SummaryOnly then
    for i := 0 to elem.predictionList.Count - 1 do
      ComposeRiskAssessmentPrediction(xml, 'prediction', elem.predictionList[i]);
  if not SummaryOnly then
    ComposeString(xml, 'mitigation', elem.mitigationObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRiskAssessment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRiskAssessment(jsn));
end;

function TFHIRJsonParser.ParseRiskAssessment(jsn : TJsonObject) : TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('condition') then
        result.condition := ParseReference{TFhirCondition}(jsn.vObj['condition']);{q}
    if jsn.has('performer') then
        result.performer := ParseReference{Resource}(jsn.vObj['performer']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('basis') then
      iterateArray(jsn.vArr['basis'], result.basisList, parseReference{TFhirReference});
    if jsn.has('prediction') then
      iterateArray(jsn.vArr['prediction'], result.predictionList, parseRiskAssessmentPrediction);
    if jsn.has('mitigation') or jsn.has('_mitigation') then
        result.mitigationObject := ParseString(jsn['mitigation'], jsn.vObj['_mitigation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRiskAssessment(json : TJSONWriter; name : string; elem : TFhirRiskAssessment);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  ComposeReference{TFhirCondition}(json, 'condition', elem.condition); {a}
  ComposeReference{Resource}(json, 'performer', elem.performer); {a}
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  if not SummaryOnly and (elem.basisList.Count > 0) then
  begin
    json.valueArray('basis');
    for i := 0 to elem.basisList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.basisList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.predictionList.Count > 0) then
  begin
    json.valueArray('prediction');
    for i := 0 to elem.predictionList.Count - 1 do
      ComposeRiskAssessmentPrediction(json, '',elem.predictionList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly then
    ComposeStringValue(json, 'mitigation', elem.mitigationObject, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'mitigation', elem.mitigationObject, false);
end;

function TFHIRXmlParser.ParseSecurityEventEvent(element : IXmlDomElement; path : string) : TFhirSecurityEventEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirSecurityEventEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'subtype') then
        result.subtypeList.Add(ParseCodeableConcept(child, path+'/subtype')){y.2}
      else if (child.baseName = 'action') then
        result.actionObject := ParseEnum(CODES_TFhirSecurityEventAction, path+'/action', child){1a}
      else if (child.baseName = 'dateTime') then
        result.dateTimeObject := ParseInstant(child, path+'/dateTime') {b}
      else if (child.baseName = 'outcome') then
        result.outcomeObject := ParseEnum(CODES_TFhirSecurityEventOutcome, path+'/outcome', child){1a}
      else if (child.baseName = 'outcomeDesc') then
        result.outcomeDescObject := ParseString(child, path+'/outcomeDesc') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSecurityEventEvent(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  for i := 0 to elem.subtypeList.Count - 1 do
    ComposeCodeableConcept(xml, 'subtype', elem.subtypeList[i]);
  ComposeEnum(xml, 'action', elem.ActionObject, CODES_TFhirSecurityEventAction);
  ComposeInstant(xml, 'dateTime', elem.dateTimeObject);{x.2}
  ComposeEnum(xml, 'outcome', elem.OutcomeObject, CODES_TFhirSecurityEventOutcome);
  ComposeString(xml, 'outcomeDesc', elem.outcomeDescObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSecurityEventEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSecurityEventEvent(jsn));
end;

function TFHIRJsonParser.ParseSecurityEventEvent(jsn : TJsonObject) : TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('subtype') then
      iterateArray(jsn.vArr['subtype'], result.subtypeList, parseCodeableConcept);
    if jsn.has('action') or jsn.has('_action')  then
      result.actionObject := parseEnum(jsn['action'], jsn.vObj['_action'], CODES_TFhirSecurityEventAction);
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeObject := ParseInstant(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeObject := parseEnum(jsn['outcome'], jsn.vObj['_outcome'], CODES_TFhirSecurityEventOutcome);
    if jsn.has('outcomeDesc') or jsn.has('_outcomeDesc') then
        result.outcomeDescObject := ParseString(jsn['outcomeDesc'], jsn.vObj['_outcomeDesc']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSecurityEventEvent(json : TJSONWriter; name : string; elem : TFhirSecurityEventEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.subtypeList.Count > 0 then
  begin
    json.valueArray('subtype');
    for i := 0 to elem.subtypeList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.subtypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'action', elem.ActionObject, CODES_TFhirSecurityEventAction, false);
  ComposeEnumProps(json, 'action', elem.ActionObject, CODES_TFhirSecurityEventAction, false);
  ComposeInstantValue(json, 'dateTime', elem.dateTimeObject, false);
  ComposeInstantProps(json, 'dateTime', elem.dateTimeObject, false);
  ComposeEnumValue(json, 'outcome', elem.OutcomeObject, CODES_TFhirSecurityEventOutcome, false);
  ComposeEnumProps(json, 'outcome', elem.OutcomeObject, CODES_TFhirSecurityEventOutcome, false);
  ComposeStringValue(json, 'outcomeDesc', elem.outcomeDescObject, false);
  ComposeStringProps(json, 'outcomeDesc', elem.outcomeDescObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseSecurityEventParticipant(element : IXmlDomElement; path : string) : TFhirSecurityEventParticipant;
var
  child : IXMLDOMElement;
begin
  result := TFhirSecurityEventParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'role') then
        result.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if (child.baseName = 'reference') then
        result.reference := ParseReference{Resource}(child, path+'/reference') {b}
      else if (child.baseName = 'userId') then
        result.userIdObject := ParseString(child, path+'/userId') {b}
      else if (child.baseName = 'altId') then
        result.altIdObject := ParseString(child, path+'/altId') {b}
      else if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'requestor') then
        result.requestorObject := ParseBoolean(child, path+'/requestor') {b}
      else if (child.baseName = 'media') then
        result.media := ParseCoding(child, path+'/media') {b}
      else if (child.baseName = 'network') then
        result.network := ParseSecurityEventParticipantNetwork(child, path+'/network') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSecurityEventParticipant(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventParticipant);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.roleList.Count - 1 do
    ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
  ComposeReference{Resource}(xml, 'reference', elem.reference);{x.2}
  ComposeString(xml, 'userId', elem.userIdObject);{x.2}
  ComposeString(xml, 'altId', elem.altIdObject);{x.2}
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeBoolean(xml, 'requestor', elem.requestorObject);{x.2}
  ComposeCoding(xml, 'media', elem.media);{x.2}
  ComposeSecurityEventParticipantNetwork(xml, 'network', elem.network);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSecurityEventParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSecurityEventParticipant(jsn));
end;

function TFHIRJsonParser.ParseSecurityEventParticipant(jsn : TJsonObject) : TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
    if jsn.has('reference') then
        result.reference := ParseReference{Resource}(jsn.vObj['reference']);{q}
    if jsn.has('userId') or jsn.has('_userId') then
        result.userIdObject := ParseString(jsn['userId'], jsn.vObj['_userId']);{q}
    if jsn.has('altId') or jsn.has('_altId') then
        result.altIdObject := ParseString(jsn['altId'], jsn.vObj['_altId']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('requestor') or jsn.has('_requestor') then
        result.requestorObject := ParseBoolean(jsn['requestor'], jsn.vObj['_requestor']);{q}
    if jsn.has('media') then
        result.media := ParseCoding(jsn.vObj['media']);{q}
    if jsn.has('network') then
        result.network := ParseSecurityEventParticipantNetwork(jsn.vObj['network']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSecurityEventParticipant(json : TJSONWriter; name : string; elem : TFhirSecurityEventParticipant);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.roleList.Count > 0 then
  begin
    json.valueArray('role');
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.roleList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeReference{Resource}(json, 'reference', elem.reference); {a}
  ComposeStringValue(json, 'userId', elem.userIdObject, false);
  ComposeStringProps(json, 'userId', elem.userIdObject, false);
  ComposeStringValue(json, 'altId', elem.altIdObject, false);
  ComposeStringProps(json, 'altId', elem.altIdObject, false);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeBooleanValue(json, 'requestor', elem.requestorObject, false);
  ComposeBooleanProps(json, 'requestor', elem.requestorObject, false);
  ComposeCoding(json, 'media', elem.media); {a}
  ComposeSecurityEventParticipantNetwork(json, 'network', elem.network); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseSecurityEventParticipantNetwork(element : IXmlDomElement; path : string) : TFhirSecurityEventParticipantNetwork;
var
  child : IXMLDOMElement;
begin
  result := TFhirSecurityEventParticipantNetwork.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierObject := ParseString(child, path+'/identifier') {b}
      else if (child.baseName = 'type') then
        result.type_Object := ParseEnum(CODES_TFhirNetworkType, path+'/type', child){1a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSecurityEventParticipantNetwork(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventParticipantNetwork);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'identifier', elem.identifierObject);{x.2}
  ComposeEnum(xml, 'type', elem.Type_Object, CODES_TFhirNetworkType);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSecurityEventParticipantNetwork(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSecurityEventParticipantNetwork(jsn));
end;

function TFHIRJsonParser.ParseSecurityEventParticipantNetwork(jsn : TJsonObject) : TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierObject := ParseString(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Object := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirNetworkType);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSecurityEventParticipantNetwork(json : TJSONWriter; name : string; elem : TFhirSecurityEventParticipantNetwork);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'identifier', elem.identifierObject, false);
  ComposeStringProps(json, 'identifier', elem.identifierObject, false);
  ComposeEnumValue(json, 'type', elem.Type_Object, CODES_TFhirNetworkType, false);
  ComposeEnumProps(json, 'type', elem.Type_Object, CODES_TFhirNetworkType, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseSecurityEventSource(element : IXmlDomElement; path : string) : TFhirSecurityEventSource;
var
  child : IXMLDOMElement;
begin
  result := TFhirSecurityEventSource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'site') then
        result.siteObject := ParseString(child, path+'/site') {b}
      else if (child.baseName = 'identifier') then
        result.identifierObject := ParseString(child, path+'/identifier') {b}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseCoding(child, path+'/type')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSecurityEventSource(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventSource);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'site', elem.siteObject);{x.2}
  ComposeString(xml, 'identifier', elem.identifierObject);{x.2}
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCoding(xml, 'type', elem.type_List[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSecurityEventSource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSecurityEventSource(jsn));
end;

function TFHIRJsonParser.ParseSecurityEventSource(jsn : TJsonObject) : TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('site') or jsn.has('_site') then
        result.siteObject := ParseString(jsn['site'], jsn.vObj['_site']);{q}
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierObject := ParseString(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCoding);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSecurityEventSource(json : TJSONWriter; name : string; elem : TFhirSecurityEventSource);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'site', elem.siteObject, false);
  ComposeStringProps(json, 'site', elem.siteObject, false);
  ComposeStringValue(json, 'identifier', elem.identifierObject, false);
  ComposeStringProps(json, 'identifier', elem.identifierObject, false);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(json, '',elem.type_List[i]); {z - Coding}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseSecurityEventObject(element : IXmlDomElement; path : string) : TFhirSecurityEventObject;
var
  child : IXMLDOMElement;
begin
  result := TFhirSecurityEventObject.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'reference') then
        result.reference := ParseReference{TFhirReference}(child, path+'/reference') {b}
      else if (child.baseName = 'type') then
        result.type_Object := ParseEnum(CODES_TFhirObjectType, path+'/type', child){1a}
      else if (child.baseName = 'role') then
        result.roleObject := ParseEnum(CODES_TFhirObjectRole, path+'/role', child){1a}
      else if (child.baseName = 'lifecycle') then
        result.lifecycleObject := ParseEnum(CODES_TFhirObjectLifecycle, path+'/lifecycle', child){1a}
      else if (child.baseName = 'sensitivity') then
        result.sensitivity := ParseCodeableConcept(child, path+'/sensitivity') {b}
      else if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'query') then
        result.queryObject := ParseBase64Binary(child, path+'/query') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseSecurityEventObjectDetail(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSecurityEventObject(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventObject);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeReference{TFhirReference}(xml, 'reference', elem.reference);{x.2}
  ComposeEnum(xml, 'type', elem.Type_Object, CODES_TFhirObjectType);
  ComposeEnum(xml, 'role', elem.RoleObject, CODES_TFhirObjectRole);
  ComposeEnum(xml, 'lifecycle', elem.LifecycleObject, CODES_TFhirObjectLifecycle);
  ComposeCodeableConcept(xml, 'sensitivity', elem.sensitivity);{x.2}
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  ComposeBase64Binary(xml, 'query', elem.queryObject);{x.2}
  for i := 0 to elem.detailList.Count - 1 do
    ComposeSecurityEventObjectDetail(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSecurityEventObject(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSecurityEventObject(jsn));
end;

function TFHIRJsonParser.ParseSecurityEventObject(jsn : TJsonObject) : TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('reference') then
        result.reference := ParseReference{TFhirReference}(jsn.vObj['reference']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Object := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirObjectType);
    if jsn.has('role') or jsn.has('_role')  then
      result.roleObject := parseEnum(jsn['role'], jsn.vObj['_role'], CODES_TFhirObjectRole);
    if jsn.has('lifecycle') or jsn.has('_lifecycle')  then
      result.lifecycleObject := parseEnum(jsn['lifecycle'], jsn.vObj['_lifecycle'], CODES_TFhirObjectLifecycle);
    if jsn.has('sensitivity') then
        result.sensitivity := ParseCodeableConcept(jsn.vObj['sensitivity']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('query') or jsn.has('_query') then
        result.queryObject := ParseBase64Binary(jsn['query'], jsn.vObj['_query']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseSecurityEventObjectDetail);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSecurityEventObject(json : TJSONWriter; name : string; elem : TFhirSecurityEventObject);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeReference{TFhirReference}(json, 'reference', elem.reference); {a}
  ComposeEnumValue(json, 'type', elem.Type_Object, CODES_TFhirObjectType, false);
  ComposeEnumProps(json, 'type', elem.Type_Object, CODES_TFhirObjectType, false);
  ComposeEnumValue(json, 'role', elem.RoleObject, CODES_TFhirObjectRole, false);
  ComposeEnumProps(json, 'role', elem.RoleObject, CODES_TFhirObjectRole, false);
  ComposeEnumValue(json, 'lifecycle', elem.LifecycleObject, CODES_TFhirObjectLifecycle, false);
  ComposeEnumProps(json, 'lifecycle', elem.LifecycleObject, CODES_TFhirObjectLifecycle, false);
  ComposeCodeableConcept(json, 'sensitivity', elem.sensitivity); {a}
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  ComposeBase64BinaryValue(json, 'query', elem.queryObject, false);
  ComposeBase64BinaryProps(json, 'query', elem.queryObject, false);
  if elem.detailList.Count > 0 then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeSecurityEventObjectDetail(json, '',elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseSecurityEventObjectDetail(element : IXmlDomElement; path : string) : TFhirSecurityEventObjectDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirSecurityEventObjectDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Object := ParseString(child, path+'/type') {b}
      else if (child.baseName = 'value') then
        result.valueObject := ParseBase64Binary(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSecurityEventObjectDetail(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventObjectDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'type', elem.type_Object);{x.2}
  ComposeBase64Binary(xml, 'value', elem.valueObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSecurityEventObjectDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSecurityEventObjectDetail(jsn));
end;

function TFHIRJsonParser.ParseSecurityEventObjectDetail(jsn : TJsonObject) : TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type') then
        result.type_Object := ParseString(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueObject := ParseBase64Binary(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSecurityEventObjectDetail(json : TJSONWriter; name : string; elem : TFhirSecurityEventObjectDetail);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'type', elem.type_Object, false);
  ComposeStringProps(json, 'type', elem.type_Object, false);
  ComposeBase64BinaryValue(json, 'value', elem.valueObject, false);
  ComposeBase64BinaryProps(json, 'value', elem.valueObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseSecurityEvent(element : IXmlDomElement; path : string) : TFhirSecurityEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirSecurityEvent.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'event') then
        result.event := ParseSecurityEventEvent(child, path+'/event') {b}
      else if (child.baseName = 'participant') then
        result.participantList.Add(ParseSecurityEventParticipant(child, path+'/participant')){y.2}
      else if (child.baseName = 'source') then
        result.source := ParseSecurityEventSource(child, path+'/source') {b}
      else if (child.baseName = 'object') then
        result.object_List.Add(ParseSecurityEventObject(child, path+'/object')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSecurityEvent(xml : TXmlBuilder; name : string; elem : TFhirSecurityEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeSecurityEventEvent(xml, 'event', elem.event);{x.2}
  for i := 0 to elem.participantList.Count - 1 do
    ComposeSecurityEventParticipant(xml, 'participant', elem.participantList[i]);
  ComposeSecurityEventSource(xml, 'source', elem.source);{x.2}
  for i := 0 to elem.object_List.Count - 1 do
    ComposeSecurityEventObject(xml, 'object', elem.object_List[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSecurityEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSecurityEvent(jsn));
end;

function TFHIRJsonParser.ParseSecurityEvent(jsn : TJsonObject) : TFhirSecurityEvent;
begin
  result := TFhirSecurityEvent.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('event') then
        result.event := ParseSecurityEventEvent(jsn.vObj['event']);{q}
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseSecurityEventParticipant);
    if jsn.has('source') then
        result.source := ParseSecurityEventSource(jsn.vObj['source']);{q}
    if jsn.has('object') then
      iterateArray(jsn.vArr['object'], result.object_List, parseSecurityEventObject);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSecurityEvent(json : TJSONWriter; name : string; elem : TFhirSecurityEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeSecurityEventEvent(json, 'event', elem.event); {a}
  if elem.participantList.Count > 0 then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeSecurityEventParticipant(json, '',elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  ComposeSecurityEventSource(json, 'source', elem.source); {a}
  if elem.object_List.Count > 0 then
  begin
    json.valueArray('object');
    for i := 0 to elem.object_List.Count - 1 do
      ComposeSecurityEventObject(json, '',elem.object_List[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseSlot(element : IXmlDomElement; path : string) : TFhirSlot;
var
  child : IXMLDOMElement;
begin
  result := TFhirSlot.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'availability') then
        result.availability := ParseReference{TFhirAvailability}(child, path+'/availability') {b}
      else if (child.baseName = 'freeBusyType') then
        result.freeBusyTypeObject := ParseEnum(CODES_TFhirSlotstatus, path+'/freeBusyType', child){1a}
      else if (child.baseName = 'start') then
        result.startObject := ParseInstant(child, path+'/start') {b}
      else if (child.baseName = 'end') then
        result.end_Object := ParseInstant(child, path+'/end') {b}
      else if (child.baseName = 'overbooked') then
        result.overbookedObject := ParseBoolean(child, path+'/overbooked') {b}
      else if (child.baseName = 'comment') then
        result.commentObject := ParseString(child, path+'/comment') {b}
      else if (child.baseName = 'lastModified') then
        result.lastModifiedObject := ParseDateTime(child, path+'/lastModified') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSlot(xml : TXmlBuilder; name : string; elem : TFhirSlot);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeReference{TFhirAvailability}(xml, 'availability', elem.availability);{x.2}
  ComposeEnum(xml, 'freeBusyType', elem.FreeBusyTypeObject, CODES_TFhirSlotstatus);
  ComposeInstant(xml, 'start', elem.startObject);{x.2}
  ComposeInstant(xml, 'end', elem.end_Object);{x.2}
  ComposeBoolean(xml, 'overbooked', elem.overbookedObject);{x.2}
  ComposeString(xml, 'comment', elem.commentObject);{x.2}
  ComposeDateTime(xml, 'lastModified', elem.lastModifiedObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSlot(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSlot(jsn));
end;

function TFHIRJsonParser.ParseSlot(jsn : TJsonObject) : TFhirSlot;
begin
  result := TFhirSlot.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('availability') then
        result.availability := ParseReference{TFhirAvailability}(jsn.vObj['availability']);{q}
    if jsn.has('freeBusyType') or jsn.has('_freeBusyType')  then
      result.freeBusyTypeObject := parseEnum(jsn['freeBusyType'], jsn.vObj['_freeBusyType'], CODES_TFhirSlotstatus);
    if jsn.has('start') or jsn.has('_start') then
        result.startObject := ParseInstant(jsn['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Object := ParseInstant(jsn['end'], jsn.vObj['_end']);{q}
    if jsn.has('overbooked') or jsn.has('_overbooked') then
        result.overbookedObject := ParseBoolean(jsn['overbooked'], jsn.vObj['_overbooked']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentObject := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('lastModified') or jsn.has('_lastModified') then
        result.lastModifiedObject := ParseDateTime(jsn['lastModified'], jsn.vObj['_lastModified']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSlot(json : TJSONWriter; name : string; elem : TFhirSlot);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeReference{TFhirAvailability}(json, 'availability', elem.availability); {a}
  ComposeEnumValue(json, 'freeBusyType', elem.FreeBusyTypeObject, CODES_TFhirSlotstatus, false);
  ComposeEnumProps(json, 'freeBusyType', elem.FreeBusyTypeObject, CODES_TFhirSlotstatus, false);
  ComposeInstantValue(json, 'start', elem.startObject, false);
  ComposeInstantProps(json, 'start', elem.startObject, false);
  ComposeInstantValue(json, 'end', elem.end_Object, false);
  ComposeInstantProps(json, 'end', elem.end_Object, false);
  ComposeBooleanValue(json, 'overbooked', elem.overbookedObject, false);
  ComposeBooleanProps(json, 'overbooked', elem.overbookedObject, false);
  ComposeStringValue(json, 'comment', elem.commentObject, false);
  ComposeStringProps(json, 'comment', elem.commentObject, false);
  ComposeDateTimeValue(json, 'lastModified', elem.lastModifiedObject, false);
  ComposeDateTimeProps(json, 'lastModified', elem.lastModifiedObject, false);
end;

function TFHIRXmlParser.ParseSpecimenSource(element : IXmlDomElement; path : string) : TFhirSpecimenSource;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimenSource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'relationship') then
        result.relationshipObject := ParseEnum(CODES_TFhirHierarchicalRelationshipType, path+'/relationship', child){1a}
      else if (child.baseName = 'target') then
        result.targetList.Add(ParseReference{TFhirSpecimen}(child, path+'/target')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSpecimenSource(xml : TXmlBuilder; name : string; elem : TFhirSpecimenSource);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'relationship', elem.RelationshipObject, CODES_TFhirHierarchicalRelationshipType);
  for i := 0 to elem.targetList.Count - 1 do
    ComposeReference{TFhirSpecimen}(xml, 'target', elem.targetList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSpecimenSource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenSource(jsn));
end;

function TFHIRJsonParser.ParseSpecimenSource(jsn : TJsonObject) : TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('relationship') or jsn.has('_relationship')  then
      result.relationshipObject := parseEnum(jsn['relationship'], jsn.vObj['_relationship'], CODES_TFhirHierarchicalRelationshipType);
    if jsn.has('target') then
      iterateArray(jsn.vArr['target'], result.targetList, parseReference{TFhirSpecimen});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSpecimenSource(json : TJSONWriter; name : string; elem : TFhirSpecimenSource);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'relationship', elem.RelationshipObject, CODES_TFhirHierarchicalRelationshipType, false);
  ComposeEnumProps(json, 'relationship', elem.RelationshipObject, CODES_TFhirHierarchicalRelationshipType, false);
  if elem.targetList.Count > 0 then
  begin
    json.valueArray('target');
    for i := 0 to elem.targetList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '',elem.targetList[i]); {z - Reference(Specimen)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseSpecimenCollection(element : IXmlDomElement; path : string) : TFhirSpecimenCollection;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimenCollection.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'collector') then
        result.collector := ParseReference{TFhirPractitioner}(child, path+'/collector') {b}
      else if (child.baseName = 'comment') then
        result.commentList.Add(ParseString(child, path+'/comment')){y.2}
      else if (child.baseName = 'collectedDateTime') then
        result.collected := ParseDateTime(child, path+'/collectedDateTime'){x.3}
      else if (child.baseName = 'collectedPeriod') then
        result.collected := ParsePeriod(child, path+'/collectedPeriod'){x.3}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'sourceSite') then
        result.sourceSite := ParseCodeableConcept(child, path+'/sourceSite') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSpecimenCollection(xml : TXmlBuilder; name : string; elem : TFhirSpecimenCollection);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirPractitioner}(xml, 'collector', elem.collector);{x.2}
  for i := 0 to elem.commentList.Count - 1 do
    ComposeString(xml, 'comment', elem.commentList[i]);
  if (elem.collected is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'collectedDateTime', TFhirDateTime(elem.collected))
  else if (elem.collected is TFhirPeriod) {6} then
    ComposePeriod(xml, 'collectedPeriod', TFhirPeriod(elem.collected));
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  ComposeCodeableConcept(xml, 'sourceSite', elem.sourceSite);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSpecimenCollection(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenCollection(jsn));
end;

function TFHIRJsonParser.ParseSpecimenCollection(jsn : TJsonObject) : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('collector') then
        result.collector := ParseReference{TFhirPractitioner}(jsn.vObj['collector']);{q}
      if jsn.has('comment') or jsn.has('_comment') then
      iteratePrimitiveArray(jsn.vArr['comment'], jsn.vArr['_comment'], result.commentList, parseString);
    if jsn.has('collectedDateTime') or jsn.has('_collectedDateTime') then
      result.collected := parseDateTime(jsn['collectedDateTime'], jsn.vObj['_collectedDateTime']);
    if jsn.has('collectedPeriod') {a4} then
      result.collected := ParsePeriod(jsn.vObj['collectedPeriod']);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('sourceSite') then
        result.sourceSite := ParseCodeableConcept(jsn.vObj['sourceSite']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSpecimenCollection(json : TJSONWriter; name : string; elem : TFhirSpecimenCollection);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirPractitioner}(json, 'collector', elem.collector); {a}
  if elem.commentList.Count > 0 then
  begin
    json.valueArray('comment');
    ext := false;
    for i := 0 to elem.commentList.Count - 1 do
    begin
      ext := ext or ((elem.commentList[i].xmlid <> '') or (elem.commentList[i].hasExtensions));
      ComposeStringValue(json, '',elem.commentList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_comment');
      for i := 0 to elem.commentList.Count - 1 do
        ComposeStringProps(json, '',elem.commentList[i], true);
      json.FinishArray;
    end;
  end;
  if (elem.collected is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'collectedDateTime', TFhirDateTime(elem.collected), false);
    ComposeDateTimeProps(json, 'collectedDateTime', TFhirDateTime(elem.collected), false);
  end
  else if (elem.collected is TFhirPeriod) then 
    ComposePeriod(json, 'collectedPeriod', TFhirPeriod(elem.collected)) ;
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  ComposeCodeableConcept(json, 'sourceSite', elem.sourceSite); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseSpecimenTreatment(element : IXmlDomElement; path : string) : TFhirSpecimenTreatment;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimenTreatment.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'procedure') then
        result.procedure_ := ParseCodeableConcept(child, path+'/procedure') {b}
      else if (child.baseName = 'additive') then
        result.additiveList.Add(ParseReference{TFhirSubstance}(child, path+'/additive')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSpecimenTreatment(xml : TXmlBuilder; name : string; elem : TFhirSpecimenTreatment);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  ComposeCodeableConcept(xml, 'procedure', elem.procedure_);{x.2}
  for i := 0 to elem.additiveList.Count - 1 do
    ComposeReference{TFhirSubstance}(xml, 'additive', elem.additiveList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSpecimenTreatment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenTreatment(jsn));
end;

function TFHIRJsonParser.ParseSpecimenTreatment(jsn : TJsonObject) : TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('procedure') then
        result.procedure_ := ParseCodeableConcept(jsn.vObj['procedure']);{q}
    if jsn.has('additive') then
      iterateArray(jsn.vArr['additive'], result.additiveList, parseReference{TFhirSubstance});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSpecimenTreatment(json : TJSONWriter; name : string; elem : TFhirSpecimenTreatment);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  ComposeCodeableConcept(json, 'procedure', elem.procedure_); {a}
  if elem.additiveList.Count > 0 then
  begin
    json.valueArray('additive');
    for i := 0 to elem.additiveList.Count - 1 do
      ComposeReference{TFhirSubstance}(json, '',elem.additiveList[i]); {z - Reference(Substance)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseSpecimenContainer(element : IXmlDomElement; path : string) : TFhirSpecimenContainer;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimenContainer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'capacity') then
        result.capacity := ParseQuantity(child, path+'/capacity') {b}
      else if (child.baseName = 'specimenQuantity') then
        result.specimenQuantity := ParseQuantity(child, path+'/specimenQuantity') {b}
      else if (child.baseName = 'additive') then
        result.additive := ParseReference{TFhirSubstance}(child, path+'/additive') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSpecimenContainer(xml : TXmlBuilder; name : string; elem : TFhirSpecimenContainer);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeQuantity(xml, 'capacity', elem.capacity);{x.2}
  ComposeQuantity(xml, 'specimenQuantity', elem.specimenQuantity);{x.2}
  ComposeReference{TFhirSubstance}(xml, 'additive', elem.additive);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSpecimenContainer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenContainer(jsn));
end;

function TFHIRJsonParser.ParseSpecimenContainer(jsn : TJsonObject) : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('capacity') then
        result.capacity := ParseQuantity(jsn.vObj['capacity']);{q}
    if jsn.has('specimenQuantity') then
        result.specimenQuantity := ParseQuantity(jsn.vObj['specimenQuantity']);{q}
    if jsn.has('additive') then
        result.additive := ParseReference{TFhirSubstance}(jsn.vObj['additive']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSpecimenContainer(json : TJSONWriter; name : string; elem : TFhirSpecimenContainer);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeQuantity(json, 'capacity', elem.capacity); {a}
  ComposeQuantity(json, 'specimenQuantity', elem.specimenQuantity); {a}
  ComposeReference{TFhirSubstance}(json, 'additive', elem.additive); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseSpecimen(element : IXmlDomElement; path : string) : TFhirSpecimen;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimen.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'source') then
        result.sourceList.Add(ParseSpecimenSource(child, path+'/source')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'accessionIdentifier') then
        result.accessionIdentifier := ParseIdentifier(child, path+'/accessionIdentifier') {b}
      else if (child.baseName = 'receivedTime') then
        result.receivedTimeObject := ParseDateTime(child, path+'/receivedTime') {b}
      else if (child.baseName = 'collection') then
        result.collection := ParseSpecimenCollection(child, path+'/collection') {b}
      else if (child.baseName = 'treatment') then
        result.treatmentList.Add(ParseSpecimenTreatment(child, path+'/treatment')){y.2}
      else if (child.baseName = 'container') then
        result.containerList.Add(ParseSpecimenContainer(child, path+'/container')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSpecimen(xml : TXmlBuilder; name : string; elem : TFhirSpecimen);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  for i := 0 to elem.sourceList.Count - 1 do
    ComposeSpecimenSource(xml, 'source', elem.sourceList[i]);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeIdentifier(xml, 'accessionIdentifier', elem.accessionIdentifier);{x.2}
  ComposeDateTime(xml, 'receivedTime', elem.receivedTimeObject);{x.2}
  ComposeSpecimenCollection(xml, 'collection', elem.collection);{x.2}
  for i := 0 to elem.treatmentList.Count - 1 do
    ComposeSpecimenTreatment(xml, 'treatment', elem.treatmentList[i]);
  for i := 0 to elem.containerList.Count - 1 do
    ComposeSpecimenContainer(xml, 'container', elem.containerList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSpecimen(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimen(jsn));
end;

function TFHIRJsonParser.ParseSpecimen(jsn : TJsonObject) : TFhirSpecimen;
begin
  result := TFhirSpecimen.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('source') then
      iterateArray(jsn.vArr['source'], result.sourceList, parseSpecimenSource);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('accessionIdentifier') then
        result.accessionIdentifier := ParseIdentifier(jsn.vObj['accessionIdentifier']);{q}
    if jsn.has('receivedTime') or jsn.has('_receivedTime') then
        result.receivedTimeObject := ParseDateTime(jsn['receivedTime'], jsn.vObj['_receivedTime']);{q}
    if jsn.has('collection') then
        result.collection := ParseSpecimenCollection(jsn.vObj['collection']);{q}
    if jsn.has('treatment') then
      iterateArray(jsn.vArr['treatment'], result.treatmentList, parseSpecimenTreatment);
    if jsn.has('container') then
      iterateArray(jsn.vArr['container'], result.containerList, parseSpecimenContainer);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSpecimen(json : TJSONWriter; name : string; elem : TFhirSpecimen);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.sourceList.Count > 0 then
  begin
    json.valueArray('source');
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeSpecimenSource(json, '',elem.sourceList[i]); {z - }
    json.FinishArray;
  end;
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeIdentifier(json, 'accessionIdentifier', elem.accessionIdentifier); {a}
  ComposeDateTimeValue(json, 'receivedTime', elem.receivedTimeObject, false);
  ComposeDateTimeProps(json, 'receivedTime', elem.receivedTimeObject, false);
  ComposeSpecimenCollection(json, 'collection', elem.collection); {a}
  if elem.treatmentList.Count > 0 then
  begin
    json.valueArray('treatment');
    for i := 0 to elem.treatmentList.Count - 1 do
      ComposeSpecimenTreatment(json, '',elem.treatmentList[i]); {z - }
    json.FinishArray;
  end;
  if elem.containerList.Count > 0 then
  begin
    json.valueArray('container');
    for i := 0 to elem.containerList.Count - 1 do
      ComposeSpecimenContainer(json, '',elem.containerList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseSubscriptionChannel(element : IXmlDomElement; path : string) : TFhirSubscriptionChannel;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubscriptionChannel.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Object := ParseEnum(CODES_TFhirSubscriptionChannelType, path+'/type', child){1a}
      else if (child.baseName = 'url') then
        result.urlObject := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'payload') then
        result.payloadObject := ParseString(child, path+'/payload') {b}
      else if (child.baseName = 'header') then
        result.headerObject := ParseString(child, path+'/header') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionChannel(xml : TXmlBuilder; name : string; elem : TFhirSubscriptionChannel);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Object, CODES_TFhirSubscriptionChannelType);
  ComposeUri(xml, 'url', elem.urlObject);{x.2}
  ComposeString(xml, 'payload', elem.payloadObject);{x.2}
  ComposeString(xml, 'header', elem.headerObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubscriptionChannel(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubscriptionChannel(jsn));
end;

function TFHIRJsonParser.ParseSubscriptionChannel(jsn : TJsonObject) : TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Object := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirSubscriptionChannelType);
    if jsn.has('url') or jsn.has('_url') then
        result.urlObject := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('payload') or jsn.has('_payload') then
        result.payloadObject := ParseString(jsn['payload'], jsn.vObj['_payload']);{q}
    if jsn.has('header') or jsn.has('_header') then
        result.headerObject := ParseString(jsn['header'], jsn.vObj['_header']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubscriptionChannel(json : TJSONWriter; name : string; elem : TFhirSubscriptionChannel);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Object, CODES_TFhirSubscriptionChannelType, false);
  ComposeEnumProps(json, 'type', elem.Type_Object, CODES_TFhirSubscriptionChannelType, false);
  ComposeUriValue(json, 'url', elem.urlObject, false);
  ComposeUriProps(json, 'url', elem.urlObject, false);
  ComposeStringValue(json, 'payload', elem.payloadObject, false);
  ComposeStringProps(json, 'payload', elem.payloadObject, false);
  ComposeStringValue(json, 'header', elem.headerObject, false);
  ComposeStringProps(json, 'header', elem.headerObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseSubscriptionTag(element : IXmlDomElement; path : string) : TFhirSubscriptionTag;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubscriptionTag.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'term') then
        result.termObject := ParseUri(child, path+'/term') {b}
      else if (child.baseName = 'scheme') then
        result.schemeObject := ParseUri(child, path+'/scheme') {b}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionTag(xml : TXmlBuilder; name : string; elem : TFhirSubscriptionTag);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'term', elem.termObject);{x.2}
  ComposeUri(xml, 'scheme', elem.schemeObject);{x.2}
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubscriptionTag(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubscriptionTag(jsn));
end;

function TFHIRJsonParser.ParseSubscriptionTag(jsn : TJsonObject) : TFhirSubscriptionTag;
begin
  result := TFhirSubscriptionTag.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('term') or jsn.has('_term') then
        result.termObject := ParseUri(jsn['term'], jsn.vObj['_term']);{q}
    if jsn.has('scheme') or jsn.has('_scheme') then
        result.schemeObject := ParseUri(jsn['scheme'], jsn.vObj['_scheme']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubscriptionTag(json : TJSONWriter; name : string; elem : TFhirSubscriptionTag);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'term', elem.termObject, false);
  ComposeUriProps(json, 'term', elem.termObject, false);
  ComposeUriValue(json, 'scheme', elem.schemeObject, false);
  ComposeUriProps(json, 'scheme', elem.schemeObject, false);
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseSubscription(element : IXmlDomElement; path : string) : TFhirSubscription;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubscription.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'criteria') then
        result.criteriaObject := ParseString(child, path+'/criteria') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseContactPoint(child, path+'/contact')){y.2}
      else if (child.baseName = 'reason') then
        result.reasonObject := ParseString(child, path+'/reason') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirSubscriptionStatus, path+'/status', child){1a}
      else if (child.baseName = 'error') then
        result.errorObject := ParseString(child, path+'/error') {b}
      else if (child.baseName = 'channel') then
        result.channel := ParseSubscriptionChannel(child, path+'/channel') {b}
      else if (child.baseName = 'end') then
        result.end_Object := ParseInstant(child, path+'/end') {b}
      else if (child.baseName = 'tag') then
        result.tagList.Add(ParseSubscriptionTag(child, path+'/tag')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubscription(xml : TXmlBuilder; name : string; elem : TFhirSubscription);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeString(xml, 'criteria', elem.criteriaObject);{x.2}
  for i := 0 to elem.contactList.Count - 1 do
    ComposeContactPoint(xml, 'contact', elem.contactList[i]);
  ComposeString(xml, 'reason', elem.reasonObject);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirSubscriptionStatus);
  ComposeString(xml, 'error', elem.errorObject);{x.2}
  ComposeSubscriptionChannel(xml, 'channel', elem.channel);{x.2}
  ComposeInstant(xml, 'end', elem.end_Object);{x.2}
  for i := 0 to elem.tagList.Count - 1 do
    ComposeSubscriptionTag(xml, 'tag', elem.tagList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubscription(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubscription(jsn));
end;

function TFHIRJsonParser.ParseSubscription(jsn : TJsonObject) : TFhirSubscription;
begin
  result := TFhirSubscription.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('criteria') or jsn.has('_criteria') then
        result.criteriaObject := ParseString(jsn['criteria'], jsn.vObj['_criteria']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactPoint);
    if jsn.has('reason') or jsn.has('_reason') then
        result.reasonObject := ParseString(jsn['reason'], jsn.vObj['_reason']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirSubscriptionStatus);
    if jsn.has('error') or jsn.has('_error') then
        result.errorObject := ParseString(jsn['error'], jsn.vObj['_error']);{q}
    if jsn.has('channel') then
        result.channel := ParseSubscriptionChannel(jsn.vObj['channel']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Object := ParseInstant(jsn['end'], jsn.vObj['_end']);{q}
    if jsn.has('tag') then
      iterateArray(jsn.vArr['tag'], result.tagList, parseSubscriptionTag);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubscription(json : TJSONWriter; name : string; elem : TFhirSubscription);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeStringValue(json, 'criteria', elem.criteriaObject, false);
  ComposeStringProps(json, 'criteria', elem.criteriaObject, false);
  if elem.contactList.Count > 0 then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(json, '',elem.contactList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'reason', elem.reasonObject, false);
  ComposeStringProps(json, 'reason', elem.reasonObject, false);
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirSubscriptionStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirSubscriptionStatus, false);
  ComposeStringValue(json, 'error', elem.errorObject, false);
  ComposeStringProps(json, 'error', elem.errorObject, false);
  ComposeSubscriptionChannel(json, 'channel', elem.channel); {a}
  ComposeInstantValue(json, 'end', elem.end_Object, false);
  ComposeInstantProps(json, 'end', elem.end_Object, false);
  if elem.tagList.Count > 0 then
  begin
    json.valueArray('tag');
    for i := 0 to elem.tagList.Count - 1 do
      ComposeSubscriptionTag(json, '',elem.tagList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseSubstanceInstance(element : IXmlDomElement; path : string) : TFhirSubstanceInstance;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubstanceInstance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'expiry') then
        result.expiryObject := ParseDateTime(child, path+'/expiry') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubstanceInstance(xml : TXmlBuilder; name : string; elem : TFhirSubstanceInstance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeDateTime(xml, 'expiry', elem.expiryObject);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubstanceInstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceInstance(jsn));
end;

function TFHIRJsonParser.ParseSubstanceInstance(jsn : TJsonObject) : TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('expiry') or jsn.has('_expiry') then
        result.expiryObject := ParseDateTime(jsn['expiry'], jsn.vObj['_expiry']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubstanceInstance(json : TJSONWriter; name : string; elem : TFhirSubstanceInstance);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeDateTimeValue(json, 'expiry', elem.expiryObject, false);
  ComposeDateTimeProps(json, 'expiry', elem.expiryObject, false);
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseSubstanceIngredient(element : IXmlDomElement; path : string) : TFhirSubstanceIngredient;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubstanceIngredient.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'quantity') then
        result.quantity := ParseRatio(child, path+'/quantity') {b}
      else if (child.baseName = 'substance') then
        result.substance := ParseReference{TFhirSubstance}(child, path+'/substance') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubstanceIngredient(xml : TXmlBuilder; name : string; elem : TFhirSubstanceIngredient);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeRatio(xml, 'quantity', elem.quantity);{x.2}
  ComposeReference{TFhirSubstance}(xml, 'substance', elem.substance);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubstanceIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceIngredient(jsn));
end;

function TFHIRJsonParser.ParseSubstanceIngredient(jsn : TJsonObject) : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('quantity') then
        result.quantity := ParseRatio(jsn.vObj['quantity']);{q}
    if jsn.has('substance') then
        result.substance := ParseReference{TFhirSubstance}(jsn.vObj['substance']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubstanceIngredient(json : TJSONWriter; name : string; elem : TFhirSubstanceIngredient);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeRatio(json, 'quantity', elem.quantity); {a}
  ComposeReference{TFhirSubstance}(json, 'substance', elem.substance); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseSubstance(element : IXmlDomElement; path : string) : TFhirSubstance;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubstance.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'instance') then
        result.instance := ParseSubstanceInstance(child, path+'/instance') {b}
      else if (child.baseName = 'ingredient') then
        result.ingredientList.Add(ParseSubstanceIngredient(child, path+'/ingredient')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubstance(xml : TXmlBuilder; name : string; elem : TFhirSubstance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  ComposeSubstanceInstance(xml, 'instance', elem.instance);{x.2}
  for i := 0 to elem.ingredientList.Count - 1 do
    ComposeSubstanceIngredient(xml, 'ingredient', elem.ingredientList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstance(jsn));
end;

function TFHIRJsonParser.ParseSubstance(jsn : TJsonObject) : TFhirSubstance;
begin
  result := TFhirSubstance.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('instance') then
        result.instance := ParseSubstanceInstance(jsn.vObj['instance']);{q}
    if jsn.has('ingredient') then
      iterateArray(jsn.vArr['ingredient'], result.ingredientList, parseSubstanceIngredient);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubstance(json : TJSONWriter; name : string; elem : TFhirSubstance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  ComposeSubstanceInstance(json, 'instance', elem.instance); {a}
  if elem.ingredientList.Count > 0 then
  begin
    json.valueArray('ingredient');
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeSubstanceIngredient(json, '',elem.ingredientList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseSupplyDispense(element : IXmlDomElement; path : string) : TFhirSupplyDispense;
var
  child : IXMLDOMElement;
begin
  result := TFhirSupplyDispense.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirValuesetSupplyDispenseStatus, path+'/status', child){1a}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'suppliedItem') then
        result.suppliedItem := ParseReference{Resource}(child, path+'/suppliedItem') {b}
      else if (child.baseName = 'supplier') then
        result.supplier := ParseReference{TFhirPractitioner}(child, path+'/supplier') {b}
      else if (child.baseName = 'whenPrepared') then
        result.whenPrepared := ParsePeriod(child, path+'/whenPrepared') {b}
      else if (child.baseName = 'whenHandedOver') then
        result.whenHandedOver := ParsePeriod(child, path+'/whenHandedOver') {b}
      else if (child.baseName = 'destination') then
        result.destination := ParseReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.baseName = 'receiver') then
        result.receiverList.Add(ParseReference{TFhirPractitioner}(child, path+'/receiver')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSupplyDispense(xml : TXmlBuilder; name : string; elem : TFhirSupplyDispense);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirValuesetSupplyDispenseStatus);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeReference{Resource}(xml, 'suppliedItem', elem.suppliedItem);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'supplier', elem.supplier);{x.2}
  ComposePeriod(xml, 'whenPrepared', elem.whenPrepared);{x.2}
  ComposePeriod(xml, 'whenHandedOver', elem.whenHandedOver);{x.2}
  ComposeReference{TFhirLocation}(xml, 'destination', elem.destination);{x.2}
  for i := 0 to elem.receiverList.Count - 1 do
    ComposeReference{TFhirPractitioner}(xml, 'receiver', elem.receiverList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSupplyDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupplyDispense(jsn));
end;

function TFHIRJsonParser.ParseSupplyDispense(jsn : TJsonObject) : TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirValuesetSupplyDispenseStatus);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('suppliedItem') then
        result.suppliedItem := ParseReference{Resource}(jsn.vObj['suppliedItem']);{q}
    if jsn.has('supplier') then
        result.supplier := ParseReference{TFhirPractitioner}(jsn.vObj['supplier']);{q}
    if jsn.has('whenPrepared') then
        result.whenPrepared := ParsePeriod(jsn.vObj['whenPrepared']);{q}
    if jsn.has('whenHandedOver') then
        result.whenHandedOver := ParsePeriod(jsn.vObj['whenHandedOver']);{q}
    if jsn.has('destination') then
        result.destination := ParseReference{TFhirLocation}(jsn.vObj['destination']);{q}
    if jsn.has('receiver') then
      iterateArray(jsn.vArr['receiver'], result.receiverList, parseReference{TFhirPractitioner});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSupplyDispense(json : TJSONWriter; name : string; elem : TFhirSupplyDispense);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirValuesetSupplyDispenseStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirValuesetSupplyDispenseStatus, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeReference{Resource}(json, 'suppliedItem', elem.suppliedItem); {a}
  ComposeReference{TFhirPractitioner}(json, 'supplier', elem.supplier); {a}
  ComposePeriod(json, 'whenPrepared', elem.whenPrepared); {a}
  ComposePeriod(json, 'whenHandedOver', elem.whenHandedOver); {a}
  ComposeReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  if elem.receiverList.Count > 0 then
  begin
    json.valueArray('receiver');
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '',elem.receiverList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseSupply(element : IXmlDomElement; path : string) : TFhirSupply;
var
  child : IXMLDOMElement;
begin
  result := TFhirSupply.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'kind') then
        result.kind := ParseCodeableConcept(child, path+'/kind') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirValuesetSupplyStatus, path+'/status', child){1a}
      else if (child.baseName = 'orderedItem') then
        result.orderedItem := ParseReference{Resource}(child, path+'/orderedItem') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'dispense') then
        result.dispenseList.Add(ParseSupplyDispense(child, path+'/dispense')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSupply(xml : TXmlBuilder; name : string; elem : TFhirSupply);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeCodeableConcept(xml, 'kind', elem.kind);{x.2}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirValuesetSupplyStatus);
  ComposeReference{Resource}(xml, 'orderedItem', elem.orderedItem);{x.2}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  for i := 0 to elem.dispenseList.Count - 1 do
    ComposeSupplyDispense(xml, 'dispense', elem.dispenseList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSupply(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupply(jsn));
end;

function TFHIRJsonParser.ParseSupply(jsn : TJsonObject) : TFhirSupply;
begin
  result := TFhirSupply.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('kind') then
        result.kind := ParseCodeableConcept(jsn.vObj['kind']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirValuesetSupplyStatus);
    if jsn.has('orderedItem') then
        result.orderedItem := ParseReference{Resource}(jsn.vObj['orderedItem']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('dispense') then
      iterateArray(jsn.vArr['dispense'], result.dispenseList, parseSupplyDispense);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSupply(json : TJSONWriter; name : string; elem : TFhirSupply);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeCodeableConcept(json, 'kind', elem.kind); {a}
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirValuesetSupplyStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirValuesetSupplyStatus, false);
  ComposeReference{Resource}(json, 'orderedItem', elem.orderedItem); {a}
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if elem.dispenseList.Count > 0 then
  begin
    json.valueArray('dispense');
    for i := 0 to elem.dispenseList.Count - 1 do
      ComposeSupplyDispense(json, '',elem.dispenseList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseValueSetDefine(element : IXmlDomElement; path : string) : TFhirValueSetDefine;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetDefine.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.systemObject := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'version') then
        result.versionObject := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'caseSensitive') then
        result.caseSensitiveObject := ParseBoolean(child, path+'/caseSensitive') {b}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseValueSetDefineConcept(child, path+'/concept')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetDefine(xml : TXmlBuilder; name : string; elem : TFhirValueSetDefine);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.systemObject);{x.2}
  ComposeString(xml, 'version', elem.versionObject);{x.2}
  ComposeBoolean(xml, 'caseSensitive', elem.caseSensitiveObject);{x.2}
  for i := 0 to elem.conceptList.Count - 1 do
    ComposeValueSetDefineConcept(xml, 'concept', elem.conceptList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetDefine(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetDefine(jsn));
end;

function TFHIRJsonParser.ParseValueSetDefine(jsn : TJsonObject) : TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemObject := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionObject := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('caseSensitive') or jsn.has('_caseSensitive') then
        result.caseSensitiveObject := ParseBoolean(jsn['caseSensitive'], jsn.vObj['_caseSensitive']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseValueSetDefineConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetDefine(json : TJSONWriter; name : string; elem : TFhirValueSetDefine);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'system', elem.systemObject, false);
  ComposeUriProps(json, 'system', elem.systemObject, false);
  ComposeStringValue(json, 'version', elem.versionObject, false);
  ComposeStringProps(json, 'version', elem.versionObject, false);
  ComposeBooleanValue(json, 'caseSensitive', elem.caseSensitiveObject, false);
  ComposeBooleanProps(json, 'caseSensitive', elem.caseSensitiveObject, false);
  if elem.conceptList.Count > 0 then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetDefineConcept(json, '',elem.conceptList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetDefineConcept(element : IXmlDomElement; path : string) : TFhirValueSetDefineConcept;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetDefineConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeObject := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'abstract') then
        result.abstractObject := ParseBoolean(child, path+'/abstract') {b}
      else if (child.baseName = 'display') then
        result.displayObject := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'definition') then
        result.definitionObject := ParseString(child, path+'/definition') {b}
      else if (child.baseName = 'designation') then
        result.designationList.Add(ParseValueSetDefineConceptDesignation(child, path+'/designation')){y.2}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseValueSetDefineConcept(child, path+'/concept')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetDefineConcept(xml : TXmlBuilder; name : string; elem : TFhirValueSetDefineConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.codeObject);{x.2}
  ComposeBoolean(xml, 'abstract', elem.abstractObject);{x.2}
  ComposeString(xml, 'display', elem.displayObject);{x.2}
  ComposeString(xml, 'definition', elem.definitionObject);{x.2}
  for i := 0 to elem.designationList.Count - 1 do
    ComposeValueSetDefineConceptDesignation(xml, 'designation', elem.designationList[i]);
  for i := 0 to elem.conceptList.Count - 1 do
    ComposeValueSetDefineConcept(xml, 'concept', elem.conceptList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetDefineConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetDefineConcept(jsn));
end;

function TFHIRJsonParser.ParseValueSetDefineConcept(jsn : TJsonObject) : TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeObject := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('abstract') or jsn.has('_abstract') then
        result.abstractObject := ParseBoolean(jsn['abstract'], jsn.vObj['_abstract']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayObject := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionObject := ParseString(jsn['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('designation') then
      iterateArray(jsn.vArr['designation'], result.designationList, parseValueSetDefineConceptDesignation);
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseValueSetDefineConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetDefineConcept(json : TJSONWriter; name : string; elem : TFhirValueSetDefineConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.codeObject, false);
  ComposeCodeProps(json, 'code', elem.codeObject, false);
  ComposeBooleanValue(json, 'abstract', elem.abstractObject, false);
  ComposeBooleanProps(json, 'abstract', elem.abstractObject, false);
  ComposeStringValue(json, 'display', elem.displayObject, false);
  ComposeStringProps(json, 'display', elem.displayObject, false);
  ComposeStringValue(json, 'definition', elem.definitionObject, false);
  ComposeStringProps(json, 'definition', elem.definitionObject, false);
  if elem.designationList.Count > 0 then
  begin
    json.valueArray('designation');
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetDefineConceptDesignation(json, '',elem.designationList[i]); {z - }
    json.FinishArray;
  end;
  if elem.conceptList.Count > 0 then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetDefineConcept(json, '',elem.conceptList[i]); {z - @ValueSet.define.concept}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetDefineConceptDesignation(element : IXmlDomElement; path : string) : TFhirValueSetDefineConceptDesignation;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetDefineConceptDesignation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'language') then
        result.languageObject := ParseCode(child, path+'/language') {b}
      else if (child.baseName = 'use') then
        result.use := ParseCoding(child, path+'/use') {b}
      else if (child.baseName = 'value') then
        result.valueObject := ParseString(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetDefineConceptDesignation(xml : TXmlBuilder; name : string; elem : TFhirValueSetDefineConceptDesignation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'language', elem.languageObject);{x.2}
  ComposeCoding(xml, 'use', elem.use);{x.2}
  ComposeString(xml, 'value', elem.valueObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetDefineConceptDesignation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetDefineConceptDesignation(jsn));
end;

function TFHIRJsonParser.ParseValueSetDefineConceptDesignation(jsn : TJsonObject) : TFhirValueSetDefineConceptDesignation;
begin
  result := TFhirValueSetDefineConceptDesignation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('language') or jsn.has('_language') then
        result.languageObject := ParseCode(jsn['language'], jsn.vObj['_language']);{q}
    if jsn.has('use') then
        result.use := ParseCoding(jsn.vObj['use']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueObject := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetDefineConceptDesignation(json : TJSONWriter; name : string; elem : TFhirValueSetDefineConceptDesignation);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'language', elem.languageObject, false);
  ComposeCodeProps(json, 'language', elem.languageObject, false);
  ComposeCoding(json, 'use', elem.use); {a}
  ComposeStringValue(json, 'value', elem.valueObject, false);
  ComposeStringProps(json, 'value', elem.valueObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetCompose(element : IXmlDomElement; path : string) : TFhirValueSetCompose;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetCompose.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'import') then
        result.importList.Add(ParseUri(child, path+'/import')){y.2}
      else if (child.baseName = 'include') then
        result.includeList.Add(ParseValueSetComposeInclude(child, path+'/include')){y.2}
      else if (child.baseName = 'exclude') then
        result.excludeList.Add(ParseValueSetComposeInclude(child, path+'/exclude')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetCompose(xml : TXmlBuilder; name : string; elem : TFhirValueSetCompose);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.importList.Count - 1 do
    ComposeUri(xml, 'import', elem.importList[i]);
  for i := 0 to elem.includeList.Count - 1 do
    ComposeValueSetComposeInclude(xml, 'include', elem.includeList[i]);
  for i := 0 to elem.excludeList.Count - 1 do
    ComposeValueSetComposeInclude(xml, 'exclude', elem.excludeList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetCompose(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetCompose(jsn));
end;

function TFHIRJsonParser.ParseValueSetCompose(jsn : TJsonObject) : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('import') or jsn.has('_import') then
      iteratePrimitiveArray(jsn.vArr['import'], jsn.vArr['_import'], result.importList, parseUri);
    if jsn.has('include') then
      iterateArray(jsn.vArr['include'], result.includeList, parseValueSetComposeInclude);
    if jsn.has('exclude') then
      iterateArray(jsn.vArr['exclude'], result.excludeList, parseValueSetComposeInclude);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetCompose(json : TJSONWriter; name : string; elem : TFhirValueSetCompose);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.importList.Count > 0 then
  begin
    json.valueArray('import');
    ext := false;
    for i := 0 to elem.importList.Count - 1 do
    begin
      ext := ext or ((elem.importList[i].xmlid <> '') or (elem.importList[i].hasExtensions));
      ComposeUriValue(json, '',elem.importList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_import');
      for i := 0 to elem.importList.Count - 1 do
        ComposeUriProps(json, '',elem.importList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.includeList.Count > 0 then
  begin
    json.valueArray('include');
    for i := 0 to elem.includeList.Count - 1 do
      ComposeValueSetComposeInclude(json, '',elem.includeList[i]); {z - }
    json.FinishArray;
  end;
  if elem.excludeList.Count > 0 then
  begin
    json.valueArray('exclude');
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeValueSetComposeInclude(json, '',elem.excludeList[i]); {z - @ValueSet.compose.include}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetComposeInclude(element : IXmlDomElement; path : string) : TFhirValueSetComposeInclude;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.systemObject := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'version') then
        result.versionObject := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseValueSetComposeIncludeConcept(child, path+'/concept')){y.2}
      else if (child.baseName = 'filter') then
        result.filterList.Add(ParseValueSetComposeIncludeFilter(child, path+'/filter')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeInclude(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeInclude);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.systemObject);{x.2}
  ComposeString(xml, 'version', elem.versionObject);{x.2}
  for i := 0 to elem.conceptList.Count - 1 do
    ComposeValueSetComposeIncludeConcept(xml, 'concept', elem.conceptList[i]);
  for i := 0 to elem.filterList.Count - 1 do
    ComposeValueSetComposeIncludeFilter(xml, 'filter', elem.filterList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetComposeInclude(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeInclude(jsn));
end;

function TFHIRJsonParser.ParseValueSetComposeInclude(jsn : TJsonObject) : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemObject := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionObject := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseValueSetComposeIncludeConcept);
    if jsn.has('filter') then
      iterateArray(jsn.vArr['filter'], result.filterList, parseValueSetComposeIncludeFilter);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeInclude(json : TJSONWriter; name : string; elem : TFhirValueSetComposeInclude);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'system', elem.systemObject, false);
  ComposeUriProps(json, 'system', elem.systemObject, false);
  ComposeStringValue(json, 'version', elem.versionObject, false);
  ComposeStringProps(json, 'version', elem.versionObject, false);
  if elem.conceptList.Count > 0 then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetComposeIncludeConcept(json, '',elem.conceptList[i]); {z - }
    json.FinishArray;
  end;
  if elem.filterList.Count > 0 then
  begin
    json.valueArray('filter');
    for i := 0 to elem.filterList.Count - 1 do
      ComposeValueSetComposeIncludeFilter(json, '',elem.filterList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeConcept(element : IXmlDomElement; path : string) : TFhirValueSetComposeIncludeConcept;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeObject := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'display') then
        result.displayObject := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'designation') then
        result.designationList.Add(ParseValueSetDefineConceptDesignation(child, path+'/designation')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeConcept(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.codeObject);{x.2}
  ComposeString(xml, 'display', elem.displayObject);{x.2}
  for i := 0 to elem.designationList.Count - 1 do
    ComposeValueSetDefineConceptDesignation(xml, 'designation', elem.designationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeIncludeConcept(jsn));
end;

function TFHIRJsonParser.ParseValueSetComposeIncludeConcept(jsn : TJsonObject) : TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeObject := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayObject := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('designation') then
      iterateArray(jsn.vArr['designation'], result.designationList, parseValueSetDefineConceptDesignation);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeIncludeConcept(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.codeObject, false);
  ComposeCodeProps(json, 'code', elem.codeObject, false);
  ComposeStringValue(json, 'display', elem.displayObject, false);
  ComposeStringProps(json, 'display', elem.displayObject, false);
  if elem.designationList.Count > 0 then
  begin
    json.valueArray('designation');
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetDefineConceptDesignation(json, '',elem.designationList[i]); {z - @ValueSet.define.concept.designation}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeFilter(element : IXmlDomElement; path : string) : TFhirValueSetComposeIncludeFilter;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'property') then
        result.property_Object := ParseCode(child, path+'/property') {b}
      else if (child.baseName = 'op') then
        result.opObject := ParseEnum(CODES_TFhirFilterOperator, path+'/op', child){1a}
      else if (child.baseName = 'value') then
        result.valueObject := ParseCode(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeFilter(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeFilter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'property', elem.property_Object);{x.2}
  ComposeEnum(xml, 'op', elem.OpObject, CODES_TFhirFilterOperator);
  ComposeCode(xml, 'value', elem.valueObject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeFilter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeIncludeFilter(jsn));
end;

function TFHIRJsonParser.ParseValueSetComposeIncludeFilter(jsn : TJsonObject) : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('property') or jsn.has('_property') then
        result.property_Object := ParseCode(jsn['property'], jsn.vObj['_property']);{q}
    if jsn.has('op') or jsn.has('_op')  then
      result.opObject := parseEnum(jsn['op'], jsn.vObj['_op'], CODES_TFhirFilterOperator);
    if jsn.has('value') or jsn.has('_value') then
        result.valueObject := ParseCode(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeIncludeFilter(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeFilter);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'property', elem.property_Object, false);
  ComposeCodeProps(json, 'property', elem.property_Object, false);
  ComposeEnumValue(json, 'op', elem.OpObject, CODES_TFhirFilterOperator, false);
  ComposeEnumProps(json, 'op', elem.OpObject, CODES_TFhirFilterOperator, false);
  ComposeCodeValue(json, 'value', elem.valueObject, false);
  ComposeCodeProps(json, 'value', elem.valueObject, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetExpansion(element : IXmlDomElement; path : string) : TFhirValueSetExpansion;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetExpansion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'timestamp') then
        result.timestampObject := ParseInstant(child, path+'/timestamp') {b}
      else if (child.baseName = 'contains') then
        result.containsList.Add(ParseValueSetExpansionContains(child, path+'/contains')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansion(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansion);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeInstant(xml, 'timestamp', elem.timestampObject);{x.2}
  for i := 0 to elem.containsList.Count - 1 do
    ComposeValueSetExpansionContains(xml, 'contains', elem.containsList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetExpansion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetExpansion(jsn));
end;

function TFHIRJsonParser.ParseValueSetExpansion(jsn : TJsonObject) : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('timestamp') or jsn.has('_timestamp') then
        result.timestampObject := ParseInstant(jsn['timestamp'], jsn.vObj['_timestamp']);{q}
    if jsn.has('contains') then
      iterateArray(jsn.vArr['contains'], result.containsList, parseValueSetExpansionContains);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetExpansion(json : TJSONWriter; name : string; elem : TFhirValueSetExpansion);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeInstantValue(json, 'timestamp', elem.timestampObject, false);
  ComposeInstantProps(json, 'timestamp', elem.timestampObject, false);
  if elem.containsList.Count > 0 then
  begin
    json.valueArray('contains');
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(json, '',elem.containsList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetExpansionContains(element : IXmlDomElement; path : string) : TFhirValueSetExpansionContains;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.systemObject := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'abstract') then
        result.abstractObject := ParseBoolean(child, path+'/abstract') {b}
      else if (child.baseName = 'version') then
        result.versionObject := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'code') then
        result.codeObject := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'display') then
        result.displayObject := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'contains') then
        result.containsList.Add(ParseValueSetExpansionContains(child, path+'/contains')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionContains(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansionContains);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.systemObject);{x.2}
  ComposeBoolean(xml, 'abstract', elem.abstractObject);{x.2}
  ComposeString(xml, 'version', elem.versionObject);{x.2}
  ComposeCode(xml, 'code', elem.codeObject);{x.2}
  ComposeString(xml, 'display', elem.displayObject);{x.2}
  for i := 0 to elem.containsList.Count - 1 do
    ComposeValueSetExpansionContains(xml, 'contains', elem.containsList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetExpansionContains(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetExpansionContains(jsn));
end;

function TFHIRJsonParser.ParseValueSetExpansionContains(jsn : TJsonObject) : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemObject := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('abstract') or jsn.has('_abstract') then
        result.abstractObject := ParseBoolean(jsn['abstract'], jsn.vObj['_abstract']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionObject := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeObject := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayObject := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('contains') then
      iterateArray(jsn.vArr['contains'], result.containsList, parseValueSetExpansionContains);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetExpansionContains(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionContains);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'system', elem.systemObject, false);
  ComposeUriProps(json, 'system', elem.systemObject, false);
  ComposeBooleanValue(json, 'abstract', elem.abstractObject, false);
  ComposeBooleanProps(json, 'abstract', elem.abstractObject, false);
  ComposeStringValue(json, 'version', elem.versionObject, false);
  ComposeStringProps(json, 'version', elem.versionObject, false);
  ComposeCodeValue(json, 'code', elem.codeObject, false);
  ComposeCodeProps(json, 'code', elem.codeObject, false);
  ComposeStringValue(json, 'display', elem.displayObject, false);
  ComposeStringProps(json, 'display', elem.displayObject, false);
  if elem.containsList.Count > 0 then
  begin
    json.valueArray('contains');
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(json, '',elem.containsList[i]); {z - @ValueSet.expansion.contains}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseValueSet(element : IXmlDomElement; path : string) : TFhirValueSet;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSet.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierObject := ParseUri(child, path+'/identifier') {b}
      else if (child.baseName = 'version') then
        result.versionObject := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameObject := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'purpose') then
        result.purposeObject := ParseString(child, path+'/purpose') {b}
      else if (child.baseName = 'immutable') then
        result.immutableObject := ParseBoolean(child, path+'/immutable') {b}
      else if (child.baseName = 'publisher') then
        result.publisherObject := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionObject := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'copyright') then
        result.copyrightObject := ParseString(child, path+'/copyright') {b}
      else if (child.baseName = 'status') then
        result.statusObject := ParseEnum(CODES_TFhirValuesetStatus, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalObject := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'extensible') then
        result.extensibleObject := ParseBoolean(child, path+'/extensible') {b}
      else if (child.baseName = 'date') then
        result.dateObject := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'stableDate') then
        result.stableDateObject := ParseDate(child, path+'/stableDate') {b}
      else if (child.baseName = 'define') then
        result.define := ParseValueSetDefine(child, path+'/define') {b}
      else if (child.baseName = 'compose') then
        result.compose := ParseValueSetCompose(child, path+'/compose') {b}
      else if (child.baseName = 'expansion') then
        result.expansion := ParseValueSetExpansion(child, path+'/expansion') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSet(xml : TXmlBuilder; name : string; elem : TFhirValueSet);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeUri(xml, 'identifier', elem.identifierObject);{x.2}
  ComposeString(xml, 'version', elem.versionObject);{x.2}
  ComposeString(xml, 'name', elem.nameObject);{x.2}
  if not SummaryOnly then
    ComposeString(xml, 'purpose', elem.purposeObject);{x.2}
  if not SummaryOnly then
    ComposeBoolean(xml, 'immutable', elem.immutableObject);{x.2}
  ComposeString(xml, 'publisher', elem.publisherObject);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeString(xml, 'description', elem.descriptionObject);{x.2}
  if not SummaryOnly then
    ComposeString(xml, 'copyright', elem.copyrightObject);{x.2}
  ComposeEnum(xml, 'status', elem.StatusObject, CODES_TFhirValuesetStatus);
  ComposeBoolean(xml, 'experimental', elem.experimentalObject);{x.2}
  if not SummaryOnly then
    ComposeBoolean(xml, 'extensible', elem.extensibleObject);{x.2}
  ComposeDateTime(xml, 'date', elem.dateObject);{x.2}
  if not SummaryOnly then
    ComposeDate(xml, 'stableDate', elem.stableDateObject);{x.2}
  ComposeValueSetDefine(xml, 'define', elem.define);{x.2}
  if not SummaryOnly then
    ComposeValueSetCompose(xml, 'compose', elem.compose);{x.2}
  if not SummaryOnly then
    ComposeValueSetExpansion(xml, 'expansion', elem.expansion);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSet(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSet(jsn));
end;

function TFHIRJsonParser.ParseValueSet(jsn : TJsonObject) : TFhirValueSet;
begin
  result := TFhirValueSet.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierObject := ParseUri(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionObject := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameObject := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeObject := ParseString(jsn['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('immutable') or jsn.has('_immutable') then
        result.immutableObject := ParseBoolean(jsn['immutable'], jsn.vObj['_immutable']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherObject := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionObject := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightObject := ParseString(jsn['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusObject := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirValuesetStatus);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalObject := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('extensible') or jsn.has('_extensible') then
        result.extensibleObject := ParseBoolean(jsn['extensible'], jsn.vObj['_extensible']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateObject := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('stableDate') or jsn.has('_stableDate') then
        result.stableDateObject := ParseDate(jsn['stableDate'], jsn.vObj['_stableDate']);{q}
    if jsn.has('define') then
        result.define := ParseValueSetDefine(jsn.vObj['define']);{q}
    if jsn.has('compose') then
        result.compose := ParseValueSetCompose(jsn.vObj['compose']);{q}
    if jsn.has('expansion') then
        result.expansion := ParseValueSetExpansion(jsn.vObj['expansion']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSet(json : TJSONWriter; name : string; elem : TFhirValueSet);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeUriValue(json, 'identifier', elem.identifierObject, false);
  ComposeUriProps(json, 'identifier', elem.identifierObject, false);
  ComposeStringValue(json, 'version', elem.versionObject, false);
  ComposeStringProps(json, 'version', elem.versionObject, false);
  ComposeStringValue(json, 'name', elem.nameObject, false);
  ComposeStringProps(json, 'name', elem.nameObject, false);
  if not SummaryOnly then
    ComposeStringValue(json, 'purpose', elem.purposeObject, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'purpose', elem.purposeObject, false);
  if not SummaryOnly then
    ComposeBooleanValue(json, 'immutable', elem.immutableObject, false);
  if not SummaryOnly then
    ComposeBooleanProps(json, 'immutable', elem.immutableObject, false);
  ComposeStringValue(json, 'publisher', elem.publisherObject, false);
  ComposeStringProps(json, 'publisher', elem.publisherObject, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionObject, false);
  ComposeStringProps(json, 'description', elem.descriptionObject, false);
  if not SummaryOnly then
    ComposeStringValue(json, 'copyright', elem.copyrightObject, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'copyright', elem.copyrightObject, false);
  ComposeEnumValue(json, 'status', elem.StatusObject, CODES_TFhirValuesetStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusObject, CODES_TFhirValuesetStatus, false);
  ComposeBooleanValue(json, 'experimental', elem.experimentalObject, false);
  ComposeBooleanProps(json, 'experimental', elem.experimentalObject, false);
  if not SummaryOnly then
    ComposeBooleanValue(json, 'extensible', elem.extensibleObject, false);
  if not SummaryOnly then
    ComposeBooleanProps(json, 'extensible', elem.extensibleObject, false);
  ComposeDateTimeValue(json, 'date', elem.dateObject, false);
  ComposeDateTimeProps(json, 'date', elem.dateObject, false);
  if not SummaryOnly then
    ComposeDateValue(json, 'stableDate', elem.stableDateObject, false);
  if not SummaryOnly then
    ComposeDateProps(json, 'stableDate', elem.stableDateObject, false);
  ComposeValueSetDefine(json, 'define', elem.define); {a}
  if not SummaryOnly then
    ComposeValueSetCompose(json, 'compose', elem.compose); {a}
  if not SummaryOnly then
    ComposeValueSetExpansion(json, 'expansion', elem.expansion); {a}
end;

function TFHIRXmlParser.ParseResource(element : IXmlDomElement; path : String) : TFhirResource;
begin
  if (element = nil) Then
    Raise Exception.Create('error - element is nil')
  else if element.baseName = 'AdverseReaction' Then
    result := ParseAdverseReaction(element, path+'/AdverseReaction')
  else if element.baseName = 'Alert' Then
    result := ParseAlert(element, path+'/Alert')
  else if element.baseName = 'AllergyIntolerance' Then
    result := ParseAllergyIntolerance(element, path+'/AllergyIntolerance')
  else if element.baseName = 'Appointment' Then
    result := ParseAppointment(element, path+'/Appointment')
  else if element.baseName = 'AppointmentResponse' Then
    result := ParseAppointmentResponse(element, path+'/AppointmentResponse')
  else if element.baseName = 'Availability' Then
    result := ParseAvailability(element, path+'/Availability')
  else if element.baseName = 'CarePlan' Then
    result := ParseCarePlan(element, path+'/CarePlan')
  else if element.baseName = 'Composition' Then
    result := ParseComposition(element, path+'/Composition')
  else if element.baseName = 'ConceptMap' Then
    result := ParseConceptMap(element, path+'/ConceptMap')
  else if element.baseName = 'Condition' Then
    result := ParseCondition(element, path+'/Condition')
  else if element.baseName = 'Conformance' Then
    result := ParseConformance(element, path+'/Conformance')
  else if element.baseName = 'Contraindication' Then
    result := ParseContraindication(element, path+'/Contraindication')
  else if element.baseName = 'DataElement' Then
    result := ParseDataElement(element, path+'/DataElement')
  else if element.baseName = 'Device' Then
    result := ParseDevice(element, path+'/Device')
  else if element.baseName = 'DeviceObservationReport' Then
    result := ParseDeviceObservationReport(element, path+'/DeviceObservationReport')
  else if element.baseName = 'DiagnosticOrder' Then
    result := ParseDiagnosticOrder(element, path+'/DiagnosticOrder')
  else if element.baseName = 'DiagnosticReport' Then
    result := ParseDiagnosticReport(element, path+'/DiagnosticReport')
  else if element.baseName = 'DocumentManifest' Then
    result := ParseDocumentManifest(element, path+'/DocumentManifest')
  else if element.baseName = 'DocumentReference' Then
    result := ParseDocumentReference(element, path+'/DocumentReference')
  else if element.baseName = 'Encounter' Then
    result := ParseEncounter(element, path+'/Encounter')
  else if element.baseName = 'FamilyHistory' Then
    result := ParseFamilyHistory(element, path+'/FamilyHistory')
  else if element.baseName = 'Group' Then
    result := ParseGroup(element, path+'/Group')
  else if element.baseName = 'ImagingStudy' Then
    result := ParseImagingStudy(element, path+'/ImagingStudy')
  else if element.baseName = 'Immunization' Then
    result := ParseImmunization(element, path+'/Immunization')
  else if element.baseName = 'ImmunizationRecommendation' Then
    result := ParseImmunizationRecommendation(element, path+'/ImmunizationRecommendation')
  else if element.baseName = 'List' Then
    result := ParseList(element, path+'/List')
  else if element.baseName = 'Location' Then
    result := ParseLocation(element, path+'/Location')
  else if element.baseName = 'Media' Then
    result := ParseMedia(element, path+'/Media')
  else if element.baseName = 'Medication' Then
    result := ParseMedication(element, path+'/Medication')
  else if element.baseName = 'MedicationAdministration' Then
    result := ParseMedicationAdministration(element, path+'/MedicationAdministration')
  else if element.baseName = 'MedicationDispense' Then
    result := ParseMedicationDispense(element, path+'/MedicationDispense')
  else if element.baseName = 'MedicationPrescription' Then
    result := ParseMedicationPrescription(element, path+'/MedicationPrescription')
  else if element.baseName = 'MedicationStatement' Then
    result := ParseMedicationStatement(element, path+'/MedicationStatement')
  else if element.baseName = 'MessageHeader' Then
    result := ParseMessageHeader(element, path+'/MessageHeader')
  else if element.baseName = 'Namespace' Then
    result := ParseNamespace(element, path+'/Namespace')
  else if element.baseName = 'NutritionOrder' Then
    result := ParseNutritionOrder(element, path+'/NutritionOrder')
  else if element.baseName = 'Observation' Then
    result := ParseObservation(element, path+'/Observation')
  else if element.baseName = 'OperationDefinition' Then
    result := ParseOperationDefinition(element, path+'/OperationDefinition')
  else if element.baseName = 'OperationOutcome' Then
    result := ParseOperationOutcome(element, path+'/OperationOutcome')
  else if element.baseName = 'Order' Then
    result := ParseOrder(element, path+'/Order')
  else if element.baseName = 'OrderResponse' Then
    result := ParseOrderResponse(element, path+'/OrderResponse')
  else if element.baseName = 'Organization' Then
    result := ParseOrganization(element, path+'/Organization')
  else if element.baseName = 'Other' Then
    result := ParseOther(element, path+'/Other')
  else if element.baseName = 'Patient' Then
    result := ParsePatient(element, path+'/Patient')
  else if element.baseName = 'Practitioner' Then
    result := ParsePractitioner(element, path+'/Practitioner')
  else if element.baseName = 'Procedure' Then
    result := ParseProcedure(element, path+'/Procedure')
  else if element.baseName = 'Profile' Then
    result := ParseProfile(element, path+'/Profile')
  else if element.baseName = 'Provenance' Then
    result := ParseProvenance(element, path+'/Provenance')
  else if element.baseName = 'Query' Then
    result := ParseQuery(element, path+'/Query')
  else if element.baseName = 'Questionnaire' Then
    result := ParseQuestionnaire(element, path+'/Questionnaire')
  else if element.baseName = 'QuestionnaireAnswers' Then
    result := ParseQuestionnaireAnswers(element, path+'/QuestionnaireAnswers')
  else if element.baseName = 'ReferralRequest' Then
    result := ParseReferralRequest(element, path+'/ReferralRequest')
  else if element.baseName = 'RelatedPerson' Then
    result := ParseRelatedPerson(element, path+'/RelatedPerson')
  else if element.baseName = 'RiskAssessment' Then
    result := ParseRiskAssessment(element, path+'/RiskAssessment')
  else if element.baseName = 'SecurityEvent' Then
    result := ParseSecurityEvent(element, path+'/SecurityEvent')
  else if element.baseName = 'Slot' Then
    result := ParseSlot(element, path+'/Slot')
  else if element.baseName = 'Specimen' Then
    result := ParseSpecimen(element, path+'/Specimen')
  else if element.baseName = 'Subscription' Then
    result := ParseSubscription(element, path+'/Subscription')
  else if element.baseName = 'Substance' Then
    result := ParseSubstance(element, path+'/Substance')
  else if element.baseName = 'Supply' Then
    result := ParseSupply(element, path+'/Supply')
  else if element.baseName = 'ValueSet' Then
    result := ParseValueSet(element, path+'/ValueSet')
  else if (element.baseName = 'Binary') Then
    result := ParseBinary(element, path)
  else
    raise Exception.create('Error: the element '+element.baseName+' is not recognised as a valid resource name');
end;

procedure TFHIRXmlComposer.ComposeResource(xml : TXmlBuilder; statedType, id, ver : String; resource: TFhirResource; links : TFHIRAtomLinkList);
begin
  if (resource = nil) Then
    Raise Exception.Create('error - resource is nil');
  Case resource.ResourceType of
    frtAdverseReaction: ComposeAdverseReaction(xml, 'AdverseReaction', TFhirAdverseReaction(resource));
    frtAlert: ComposeAlert(xml, 'Alert', TFhirAlert(resource));
    frtAllergyIntolerance: ComposeAllergyIntolerance(xml, 'AllergyIntolerance', TFhirAllergyIntolerance(resource));
    frtAppointment: ComposeAppointment(xml, 'Appointment', TFhirAppointment(resource));
    frtAppointmentResponse: ComposeAppointmentResponse(xml, 'AppointmentResponse', TFhirAppointmentResponse(resource));
    frtAvailability: ComposeAvailability(xml, 'Availability', TFhirAvailability(resource));
    frtCarePlan: ComposeCarePlan(xml, 'CarePlan', TFhirCarePlan(resource));
    frtComposition: ComposeComposition(xml, 'Composition', TFhirComposition(resource));
    frtConceptMap: ComposeConceptMap(xml, 'ConceptMap', TFhirConceptMap(resource));
    frtCondition: ComposeCondition(xml, 'Condition', TFhirCondition(resource));
    frtConformance: ComposeConformance(xml, 'Conformance', TFhirConformance(resource));
    frtContraindication: ComposeContraindication(xml, 'Contraindication', TFhirContraindication(resource));
    frtDataElement: ComposeDataElement(xml, 'DataElement', TFhirDataElement(resource));
    frtDevice: ComposeDevice(xml, 'Device', TFhirDevice(resource));
    frtDeviceObservationReport: ComposeDeviceObservationReport(xml, 'DeviceObservationReport', TFhirDeviceObservationReport(resource));
    frtDiagnosticOrder: ComposeDiagnosticOrder(xml, 'DiagnosticOrder', TFhirDiagnosticOrder(resource));
    frtDiagnosticReport: ComposeDiagnosticReport(xml, 'DiagnosticReport', TFhirDiagnosticReport(resource));
    frtDocumentManifest: ComposeDocumentManifest(xml, 'DocumentManifest', TFhirDocumentManifest(resource));
    frtDocumentReference: ComposeDocumentReference(xml, 'DocumentReference', TFhirDocumentReference(resource));
    frtEncounter: ComposeEncounter(xml, 'Encounter', TFhirEncounter(resource));
    frtFamilyHistory: ComposeFamilyHistory(xml, 'FamilyHistory', TFhirFamilyHistory(resource));
    frtGroup: ComposeGroup(xml, 'Group', TFhirGroup(resource));
    frtImagingStudy: ComposeImagingStudy(xml, 'ImagingStudy', TFhirImagingStudy(resource));
    frtImmunization: ComposeImmunization(xml, 'Immunization', TFhirImmunization(resource));
    frtImmunizationRecommendation: ComposeImmunizationRecommendation(xml, 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource));
    frtList: ComposeList(xml, 'List', TFhirList(resource));
    frtLocation: ComposeLocation(xml, 'Location', TFhirLocation(resource));
    frtMedia: ComposeMedia(xml, 'Media', TFhirMedia(resource));
    frtMedication: ComposeMedication(xml, 'Medication', TFhirMedication(resource));
    frtMedicationAdministration: ComposeMedicationAdministration(xml, 'MedicationAdministration', TFhirMedicationAdministration(resource));
    frtMedicationDispense: ComposeMedicationDispense(xml, 'MedicationDispense', TFhirMedicationDispense(resource));
    frtMedicationPrescription: ComposeMedicationPrescription(xml, 'MedicationPrescription', TFhirMedicationPrescription(resource));
    frtMedicationStatement: ComposeMedicationStatement(xml, 'MedicationStatement', TFhirMedicationStatement(resource));
    frtMessageHeader: ComposeMessageHeader(xml, 'MessageHeader', TFhirMessageHeader(resource));
    frtNamespace: ComposeNamespace(xml, 'Namespace', TFhirNamespace(resource));
    frtNutritionOrder: ComposeNutritionOrder(xml, 'NutritionOrder', TFhirNutritionOrder(resource));
    frtObservation: ComposeObservation(xml, 'Observation', TFhirObservation(resource));
    frtOperationDefinition: ComposeOperationDefinition(xml, 'OperationDefinition', TFhirOperationDefinition(resource));
    frtOperationOutcome: ComposeOperationOutcome(xml, 'OperationOutcome', TFhirOperationOutcome(resource));
    frtOrder: ComposeOrder(xml, 'Order', TFhirOrder(resource));
    frtOrderResponse: ComposeOrderResponse(xml, 'OrderResponse', TFhirOrderResponse(resource));
    frtOrganization: ComposeOrganization(xml, 'Organization', TFhirOrganization(resource));
    frtOther: ComposeOther(xml, 'Other', TFhirOther(resource));
    frtPatient: ComposePatient(xml, 'Patient', TFhirPatient(resource));
    frtPractitioner: ComposePractitioner(xml, 'Practitioner', TFhirPractitioner(resource));
    frtProcedure: ComposeProcedure(xml, 'Procedure', TFhirProcedure(resource));
    frtProfile: ComposeProfile(xml, 'Profile', TFhirProfile(resource));
    frtProvenance: ComposeProvenance(xml, 'Provenance', TFhirProvenance(resource));
    frtQuery: ComposeQuery(xml, 'Query', TFhirQuery(resource));
    frtQuestionnaire: ComposeQuestionnaire(xml, 'Questionnaire', TFhirQuestionnaire(resource));
    frtQuestionnaireAnswers: ComposeQuestionnaireAnswers(xml, 'QuestionnaireAnswers', TFhirQuestionnaireAnswers(resource));
    frtReferralRequest: ComposeReferralRequest(xml, 'ReferralRequest', TFhirReferralRequest(resource));
    frtRelatedPerson: ComposeRelatedPerson(xml, 'RelatedPerson', TFhirRelatedPerson(resource));
    frtRiskAssessment: ComposeRiskAssessment(xml, 'RiskAssessment', TFhirRiskAssessment(resource));
    frtSecurityEvent: ComposeSecurityEvent(xml, 'SecurityEvent', TFhirSecurityEvent(resource));
    frtSlot: ComposeSlot(xml, 'Slot', TFhirSlot(resource));
    frtSpecimen: ComposeSpecimen(xml, 'Specimen', TFhirSpecimen(resource));
    frtSubscription: ComposeSubscription(xml, 'Subscription', TFhirSubscription(resource));
    frtSubstance: ComposeSubstance(xml, 'Substance', TFhirSubstance(resource));
    frtSupply: ComposeSupply(xml, 'Supply', TFhirSupply(resource));
    frtValueSet: ComposeValueSet(xml, 'ValueSet', TFhirValueSet(resource));
    frtBinary: ComposeBinary(xml, TFhirBinary(resource));
  else
    raise Exception.create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;

function TFHIRJsonParser.ParseResource(jsn : TJsonObject) : TFhirResource;
var
  s : String;
begin
  s := jsn['resourceType'];
  if s = 'AdverseReaction' Then
    result := ParseAdverseReaction(jsn)
  else if s = 'Alert' Then
    result := ParseAlert(jsn)
  else if s = 'AllergyIntolerance' Then
    result := ParseAllergyIntolerance(jsn)
  else if s = 'Appointment' Then
    result := ParseAppointment(jsn)
  else if s = 'AppointmentResponse' Then
    result := ParseAppointmentResponse(jsn)
  else if s = 'Availability' Then
    result := ParseAvailability(jsn)
  else if s = 'CarePlan' Then
    result := ParseCarePlan(jsn)
  else if s = 'Composition' Then
    result := ParseComposition(jsn)
  else if s = 'ConceptMap' Then
    result := ParseConceptMap(jsn)
  else if s = 'Condition' Then
    result := ParseCondition(jsn)
  else if s = 'Conformance' Then
    result := ParseConformance(jsn)
  else if s = 'Contraindication' Then
    result := ParseContraindication(jsn)
  else if s = 'DataElement' Then
    result := ParseDataElement(jsn)
  else if s = 'Device' Then
    result := ParseDevice(jsn)
  else if s = 'DeviceObservationReport' Then
    result := ParseDeviceObservationReport(jsn)
  else if s = 'DiagnosticOrder' Then
    result := ParseDiagnosticOrder(jsn)
  else if s = 'DiagnosticReport' Then
    result := ParseDiagnosticReport(jsn)
  else if s = 'DocumentManifest' Then
    result := ParseDocumentManifest(jsn)
  else if s = 'DocumentReference' Then
    result := ParseDocumentReference(jsn)
  else if s = 'Encounter' Then
    result := ParseEncounter(jsn)
  else if s = 'FamilyHistory' Then
    result := ParseFamilyHistory(jsn)
  else if s = 'Group' Then
    result := ParseGroup(jsn)
  else if s = 'ImagingStudy' Then
    result := ParseImagingStudy(jsn)
  else if s = 'Immunization' Then
    result := ParseImmunization(jsn)
  else if s = 'ImmunizationRecommendation' Then
    result := ParseImmunizationRecommendation(jsn)
  else if s = 'List' Then
    result := ParseList(jsn)
  else if s = 'Location' Then
    result := ParseLocation(jsn)
  else if s = 'Media' Then
    result := ParseMedia(jsn)
  else if s = 'Medication' Then
    result := ParseMedication(jsn)
  else if s = 'MedicationAdministration' Then
    result := ParseMedicationAdministration(jsn)
  else if s = 'MedicationDispense' Then
    result := ParseMedicationDispense(jsn)
  else if s = 'MedicationPrescription' Then
    result := ParseMedicationPrescription(jsn)
  else if s = 'MedicationStatement' Then
    result := ParseMedicationStatement(jsn)
  else if s = 'MessageHeader' Then
    result := ParseMessageHeader(jsn)
  else if s = 'Namespace' Then
    result := ParseNamespace(jsn)
  else if s = 'NutritionOrder' Then
    result := ParseNutritionOrder(jsn)
  else if s = 'Observation' Then
    result := ParseObservation(jsn)
  else if s = 'OperationDefinition' Then
    result := ParseOperationDefinition(jsn)
  else if s = 'OperationOutcome' Then
    result := ParseOperationOutcome(jsn)
  else if s = 'Order' Then
    result := ParseOrder(jsn)
  else if s = 'OrderResponse' Then
    result := ParseOrderResponse(jsn)
  else if s = 'Organization' Then
    result := ParseOrganization(jsn)
  else if s = 'Other' Then
    result := ParseOther(jsn)
  else if s = 'Patient' Then
    result := ParsePatient(jsn)
  else if s = 'Practitioner' Then
    result := ParsePractitioner(jsn)
  else if s = 'Procedure' Then
    result := ParseProcedure(jsn)
  else if s = 'Profile' Then
    result := ParseProfile(jsn)
  else if s = 'Provenance' Then
    result := ParseProvenance(jsn)
  else if s = 'Query' Then
    result := ParseQuery(jsn)
  else if s = 'Questionnaire' Then
    result := ParseQuestionnaire(jsn)
  else if s = 'QuestionnaireAnswers' Then
    result := ParseQuestionnaireAnswers(jsn)
  else if s = 'ReferralRequest' Then
    result := ParseReferralRequest(jsn)
  else if s = 'RelatedPerson' Then
    result := ParseRelatedPerson(jsn)
  else if s = 'RiskAssessment' Then
    result := ParseRiskAssessment(jsn)
  else if s = 'SecurityEvent' Then
    result := ParseSecurityEvent(jsn)
  else if s = 'Slot' Then
    result := ParseSlot(jsn)
  else if s = 'Specimen' Then
    result := ParseSpecimen(jsn)
  else if s = 'Subscription' Then
    result := ParseSubscription(jsn)
  else if s = 'Substance' Then
    result := ParseSubstance(jsn)
  else if s = 'Supply' Then
    result := ParseSupply(jsn)
  else if s = 'ValueSet' Then
    result := ParseValueSet(jsn)
  else if s = 'Binary' Then
    result := ParseBinary(jsn)
  else
    raise Exception.create('error: the element '+s+' is not a valid resource name');
end;

function TFHIRJsonParser.ParseFragment(jsn : TJsonObject; type_ : String) : TFhirElement;
begin
   if (type_ = 'TFhirExtension') then
    result := parseExtension(jsn)
  else if (type_ = 'TFhirNarrative') then
    result := parseNarrative(jsn)
  else if (type_ = 'TFhirPeriod') then
    result := parsePeriod(jsn)
  else if (type_ = 'TFhirCoding') then
    result := parseCoding(jsn)
  else if (type_ = 'TFhirRange') then
    result := parseRange(jsn)
  else if (type_ = 'TFhirQuantity') then
    result := parseQuantity(jsn)
  else if (type_ = 'TFhirAttachment') then
    result := parseAttachment(jsn)
  else if (type_ = 'TFhirRatio') then
    result := parseRatio(jsn)
  else if (type_ = 'TFhirSampledData') then
    result := parseSampledData(jsn)
  else if (type_ = 'TFhirReference') then
    result := parseReference(jsn)
  else if (type_ = 'TFhirCodeableConcept') then
    result := parseCodeableConcept(jsn)
  else if (type_ = 'TFhirIdentifier') then
    result := parseIdentifier(jsn)
  else if (type_ = 'TFhirTiming') then
    result := parseTiming(jsn)
  else if (type_ = 'TFhirAddress') then
    result := parseAddress(jsn)
  else if (type_ = 'TFhirHumanName') then
    result := parseHumanName(jsn)
  else if (type_ = 'TFhirContactPoint') then
    result := parseContactPoint(jsn)
  else if type_ = 'Binary' Then
    result := ParseBinary(jsn)
  else
    raise Exception.create('error: the element '+type_+' is not a valid fragment name');
end;

function TFHIRXmlParser.ParseFragment(element : IXMLDOMElement) : TFhirElement;
begin
   if SameText(element.NodeName, 'TFhirExtension') then
    result := parseExtension(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirNarrative') then
    result := parseNarrative(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirPeriod') then
    result := parsePeriod(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCoding') then
    result := parseCoding(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirRange') then
    result := parseRange(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirQuantity') then
    result := parseQuantity(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAttachment') then
    result := parseAttachment(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirRatio') then
    result := parseRatio(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSampledData') then
    result := parseSampledData(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirReference') then
    result := parseReference(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCodeableConcept') then
    result := parseCodeableConcept(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirIdentifier') then
    result := parseIdentifier(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirTiming') then
    result := parseTiming(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAddress') then
    result := parseAddress(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirHumanName') then
    result := parseHumanName(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirContactPoint') then
    result := parseContactPoint(element, element.nodeName)
  else if sameText(element.nodeName, 'Binary') Then
    result := ParseBinary(element, element.nodeName)
  else
    raise Exception.create('error: the element '+element.nodeName+' is not a valid fragment name');
end;

function TFHIRJsonParser.ParseDataType(jsn : TJsonObject; name : String; type_ : TFHIRTypeClass) : TFHIRType;
begin
   if (type_ = TFhirExtension) then
    result := parseExtension(jsn)
  else if (type_ = TFhirNarrative) then
    result := parseNarrative(jsn)
  else if (type_ = TFhirPeriod) then
    result := parsePeriod(jsn)
  else if (type_ = TFhirCoding) then
    result := parseCoding(jsn)
  else if (type_ = TFhirRange) then
    result := parseRange(jsn)
  else if (type_ = TFhirQuantity) then
    result := parseQuantity(jsn)
  else if (type_ = TFhirAttachment) then
    result := parseAttachment(jsn)
  else if (type_ = TFhirRatio) then
    result := parseRatio(jsn)
  else if (type_ = TFhirSampledData) then
    result := parseSampledData(jsn)
  else if (type_ = TFhirReference) then
    result := parseReference(jsn)
  else if (type_ = TFhirCodeableConcept) then
    result := parseCodeableConcept(jsn)
  else if (type_ = TFhirIdentifier) then
    result := parseIdentifier(jsn)
  else if (type_ = TFhirTiming) then
    result := parseTiming(jsn)
  else if (type_ = TFhirAddress) then
    result := parseAddress(jsn)
  else if (type_ = TFhirHumanName) then
    result := parseHumanName(jsn)
  else if (type_ = TFhirContactPoint) then
    result := parseContactPoint(jsn)
  else
    raise Exception.create('Unknown Type');
end;

function TFHIRXmlParser.ParseDataType(element : IXMLDOMElement; name : String; type_ : TFHIRTypeClass) : TFhirType;
begin
    if (name <> '') and (name <> element.baseName) then
    raise Exception.Create('Expected Name mismatch : expected "'+name+'"+, but found "'+element.baseName+'"');
 if (type_ = TFhirExtension) then
    result := parseExtension(element, name)
  else if (type_ = TFhirNarrative) then
    result := parseNarrative(element, name)
  else if (type_ = TFhirPeriod) then
    result := parsePeriod(element, name)
  else if (type_ = TFhirCoding) then
    result := parseCoding(element, name)
  else if (type_ = TFhirRange) then
    result := parseRange(element, name)
  else if (type_ = TFhirQuantity) then
    result := parseQuantity(element, name)
  else if (type_ = TFhirAttachment) then
    result := parseAttachment(element, name)
  else if (type_ = TFhirRatio) then
    result := parseRatio(element, name)
  else if (type_ = TFhirSampledData) then
    result := parseSampledData(element, name)
  else if (type_ = TFhirReference) then
    result := parseReference(element, name)
  else if (type_ = TFhirCodeableConcept) then
    result := parseCodeableConcept(element, name)
  else if (type_ = TFhirIdentifier) then
    result := parseIdentifier(element, name)
  else if (type_ = TFhirTiming) then
    result := parseTiming(element, name)
  else if (type_ = TFhirAddress) then
    result := parseAddress(element, name)
  else if (type_ = TFhirHumanName) then
    result := parseHumanName(element, name)
  else if (type_ = TFhirContactPoint) then
    result := parseContactPoint(element, name)
  else
    raise Exception.create('Unknown Type');
end;

procedure TFHIRJsonComposer.ComposeResource(json : TJSONWriter; statedType, id, ver : String; resource: TFhirResource; links : TFHIRAtomLinkList);
begin
  if (resource = nil) Then
    Raise Exception.Create('error - resource is nil');
  json.value('resourceType', CODES_TFhirResourceType[resource.ResourceType]);
  Case resource.ResourceType of
    frtAdverseReaction: ComposeAdverseReaction(json, 'AdverseReaction', TFhirAdverseReaction(resource));
    frtAlert: ComposeAlert(json, 'Alert', TFhirAlert(resource));
    frtAllergyIntolerance: ComposeAllergyIntolerance(json, 'AllergyIntolerance', TFhirAllergyIntolerance(resource));
    frtAppointment: ComposeAppointment(json, 'Appointment', TFhirAppointment(resource));
    frtAppointmentResponse: ComposeAppointmentResponse(json, 'AppointmentResponse', TFhirAppointmentResponse(resource));
    frtAvailability: ComposeAvailability(json, 'Availability', TFhirAvailability(resource));
    frtCarePlan: ComposeCarePlan(json, 'CarePlan', TFhirCarePlan(resource));
    frtComposition: ComposeComposition(json, 'Composition', TFhirComposition(resource));
    frtConceptMap: ComposeConceptMap(json, 'ConceptMap', TFhirConceptMap(resource));
    frtCondition: ComposeCondition(json, 'Condition', TFhirCondition(resource));
    frtConformance: ComposeConformance(json, 'Conformance', TFhirConformance(resource));
    frtContraindication: ComposeContraindication(json, 'Contraindication', TFhirContraindication(resource));
    frtDataElement: ComposeDataElement(json, 'DataElement', TFhirDataElement(resource));
    frtDevice: ComposeDevice(json, 'Device', TFhirDevice(resource));
    frtDeviceObservationReport: ComposeDeviceObservationReport(json, 'DeviceObservationReport', TFhirDeviceObservationReport(resource));
    frtDiagnosticOrder: ComposeDiagnosticOrder(json, 'DiagnosticOrder', TFhirDiagnosticOrder(resource));
    frtDiagnosticReport: ComposeDiagnosticReport(json, 'DiagnosticReport', TFhirDiagnosticReport(resource));
    frtDocumentManifest: ComposeDocumentManifest(json, 'DocumentManifest', TFhirDocumentManifest(resource));
    frtDocumentReference: ComposeDocumentReference(json, 'DocumentReference', TFhirDocumentReference(resource));
    frtEncounter: ComposeEncounter(json, 'Encounter', TFhirEncounter(resource));
    frtFamilyHistory: ComposeFamilyHistory(json, 'FamilyHistory', TFhirFamilyHistory(resource));
    frtGroup: ComposeGroup(json, 'Group', TFhirGroup(resource));
    frtImagingStudy: ComposeImagingStudy(json, 'ImagingStudy', TFhirImagingStudy(resource));
    frtImmunization: ComposeImmunization(json, 'Immunization', TFhirImmunization(resource));
    frtImmunizationRecommendation: ComposeImmunizationRecommendation(json, 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource));
    frtList: ComposeList(json, 'List', TFhirList(resource));
    frtLocation: ComposeLocation(json, 'Location', TFhirLocation(resource));
    frtMedia: ComposeMedia(json, 'Media', TFhirMedia(resource));
    frtMedication: ComposeMedication(json, 'Medication', TFhirMedication(resource));
    frtMedicationAdministration: ComposeMedicationAdministration(json, 'MedicationAdministration', TFhirMedicationAdministration(resource));
    frtMedicationDispense: ComposeMedicationDispense(json, 'MedicationDispense', TFhirMedicationDispense(resource));
    frtMedicationPrescription: ComposeMedicationPrescription(json, 'MedicationPrescription', TFhirMedicationPrescription(resource));
    frtMedicationStatement: ComposeMedicationStatement(json, 'MedicationStatement', TFhirMedicationStatement(resource));
    frtMessageHeader: ComposeMessageHeader(json, 'MessageHeader', TFhirMessageHeader(resource));
    frtNamespace: ComposeNamespace(json, 'Namespace', TFhirNamespace(resource));
    frtNutritionOrder: ComposeNutritionOrder(json, 'NutritionOrder', TFhirNutritionOrder(resource));
    frtObservation: ComposeObservation(json, 'Observation', TFhirObservation(resource));
    frtOperationDefinition: ComposeOperationDefinition(json, 'OperationDefinition', TFhirOperationDefinition(resource));
    frtOperationOutcome: ComposeOperationOutcome(json, 'OperationOutcome', TFhirOperationOutcome(resource));
    frtOrder: ComposeOrder(json, 'Order', TFhirOrder(resource));
    frtOrderResponse: ComposeOrderResponse(json, 'OrderResponse', TFhirOrderResponse(resource));
    frtOrganization: ComposeOrganization(json, 'Organization', TFhirOrganization(resource));
    frtOther: ComposeOther(json, 'Other', TFhirOther(resource));
    frtPatient: ComposePatient(json, 'Patient', TFhirPatient(resource));
    frtPractitioner: ComposePractitioner(json, 'Practitioner', TFhirPractitioner(resource));
    frtProcedure: ComposeProcedure(json, 'Procedure', TFhirProcedure(resource));
    frtProfile: ComposeProfile(json, 'Profile', TFhirProfile(resource));
    frtProvenance: ComposeProvenance(json, 'Provenance', TFhirProvenance(resource));
    frtQuery: ComposeQuery(json, 'Query', TFhirQuery(resource));
    frtQuestionnaire: ComposeQuestionnaire(json, 'Questionnaire', TFhirQuestionnaire(resource));
    frtQuestionnaireAnswers: ComposeQuestionnaireAnswers(json, 'QuestionnaireAnswers', TFhirQuestionnaireAnswers(resource));
    frtReferralRequest: ComposeReferralRequest(json, 'ReferralRequest', TFhirReferralRequest(resource));
    frtRelatedPerson: ComposeRelatedPerson(json, 'RelatedPerson', TFhirRelatedPerson(resource));
    frtRiskAssessment: ComposeRiskAssessment(json, 'RiskAssessment', TFhirRiskAssessment(resource));
    frtSecurityEvent: ComposeSecurityEvent(json, 'SecurityEvent', TFhirSecurityEvent(resource));
    frtSlot: ComposeSlot(json, 'Slot', TFhirSlot(resource));
    frtSpecimen: ComposeSpecimen(json, 'Specimen', TFhirSpecimen(resource));
    frtSubscription: ComposeSubscription(json, 'Subscription', TFhirSubscription(resource));
    frtSubstance: ComposeSubstance(json, 'Substance', TFhirSubstance(resource));
    frtSupply: ComposeSupply(json, 'Supply', TFhirSupply(resource));
    frtValueSet: ComposeValueSet(json, 'ValueSet', TFhirValueSet(resource));
    frtBinary: ComposeBinary(json, TFhirBinary(resource));
  else
    raise Exception.create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;


end.

