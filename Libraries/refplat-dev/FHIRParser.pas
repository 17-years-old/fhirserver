unit FHIRParser;

{
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}


{$IFDEF FHIR-DSTU}
This is the dev branch of the FHIR code
{$ENDIF}

interface

// FHIR v0.5.0 generated Tue, Apr 21, 2015 16:18+1000

uses
  SysUtils, Classes, ActiveX, StringSupport, DateSupport, IdSoapMsXml, FHIRParserBase, DateAndTime, FHIRBase, FHIRResources, FHIRConstants, FHIRComponents, FHIRTypes, MsXmlParser, XmlBuilder, AdvJSON, AdvStringMatches;

Type

  TFHIRXmlParser = class (TFHIRXmlParserBase)
  protected
    function ParseElement(element : IXmlDomElement; path : string) : TFhirElement;
    function ParseBackboneElement(element : IXmlDomElement; path : string) : TFhirBackboneElement;

    Procedure ParseElementAttributes(value : TFhirElement; path : string; element : IXmlDomElement);
    Function ParseBackboneElementChild(element : TFhirBackboneElement; path : string; child : IXmlDomElement) : boolean;
    Function ParseElementChild(element : TFhirElement; path : string; child : IXmlDomElement) : boolean;
    function ParseEnum(Const aNames : Array Of String; path : String; element : IXmlDomElement) : TFhirEnum;
    function ParseInteger(element : IXmlDomElement; path : string) : TFhirInteger;
    function ParseDateTime(element : IXmlDomElement; path : string) : TFhirDateTime;
    function ParseDate(element : IXmlDomElement; path : string) : TFhirDate;
    function ParseDecimal(element : IXmlDomElement; path : string) : TFhirDecimal;
    function ParseUri(element : IXmlDomElement; path : string) : TFhirUri;
    function ParseBase64Binary(element : IXmlDomElement; path : string) : TFhirBase64Binary;
    function ParseTime(element : IXmlDomElement; path : string) : TFhirTime;
    function ParseString(element : IXmlDomElement; path : string) : TFhirString;
    function ParseBoolean(element : IXmlDomElement; path : string) : TFhirBoolean;
    function ParseInstant(element : IXmlDomElement; path : string) : TFhirInstant;
    function ParseUnsignedInt(element : IXmlDomElement; path : string) : TFhirUnsignedInt;
    function ParseCode(element : IXmlDomElement; path : string) : TFhirCode;
    function ParseId(element : IXmlDomElement; path : string) : TFhirId;
    function ParseOid(element : IXmlDomElement; path : string) : TFhirOid;
    function ParsePositiveInt(element : IXmlDomElement; path : string) : TFhirPositiveInt;
    function ParseUuid(element : IXmlDomElement; path : string) : TFhirUuid;

    Procedure ParseResourceAttributes(resource : TFhirResource; path : string; element : IXmlDomElement);
    Function ParseResourceChild(resource : TFhirResource; path : string; child : IXmlDomElement) : boolean;
    Procedure ParseDomainResourceAttributes(resource : TFhirDomainResource; path : string; element : IXmlDomElement);
    Function ParseDomainResourceChild(resource : TFhirDomainResource; path : string; child : IXmlDomElement) : boolean;
    function ParseParametersParameter(element : IXmlDomElement; path : string) : TFhirParametersParameter;
    function ParseParametersParameterPart(element : IXmlDomElement; path : string) : TFhirParametersParameterPart;
    function ParseParameters(element : IXmlDomElement; path : string) : TFhirParameters;

    function ParseExtension(element : IXmlDomElement; path : string) : TFhirExtension;
    function ParseNarrative(element : IXmlDomElement; path : string) : TFhirNarrative;
    function ParsePeriod(element : IXmlDomElement; path : string) : TFhirPeriod;
    function ParseCoding(element : IXmlDomElement; path : string) : TFhirCoding;
    function ParseRange(element : IXmlDomElement; path : string) : TFhirRange;
    function ParseQuantity(element : IXmlDomElement; path : string) : TFhirQuantity;
    function ParseAttachment(element : IXmlDomElement; path : string) : TFhirAttachment;
    function ParseRatio(element : IXmlDomElement; path : string) : TFhirRatio;
    function ParseSampledData(element : IXmlDomElement; path : string) : TFhirSampledData;
    function ParseReference(element : IXmlDomElement; path : string) : TFhirReference;
    function ParseCodeableConcept(element : IXmlDomElement; path : string) : TFhirCodeableConcept;
    function ParseIdentifier(element : IXmlDomElement; path : string) : TFhirIdentifier;
    function ParseSignature(element : IXmlDomElement; path : string) : TFhirSignature;
    function ParseElementDefinitionSlicing(element : IXmlDomElement; path : string) : TFhirElementDefinitionSlicing;
    function ParseElementDefinitionType(element : IXmlDomElement; path : string) : TFhirElementDefinitionType;
    function ParseElementDefinitionConstraint(element : IXmlDomElement; path : string) : TFhirElementDefinitionConstraint;
    function ParseElementDefinitionBinding(element : IXmlDomElement; path : string) : TFhirElementDefinitionBinding;
    function ParseElementDefinitionMapping(element : IXmlDomElement; path : string) : TFhirElementDefinitionMapping;
    function ParseElementDefinition(element : IXmlDomElement; path : string) : TFhirElementDefinition;
    function ParseTimingRepeat(element : IXmlDomElement; path : string) : TFhirTimingRepeat;
    function ParseTiming(element : IXmlDomElement; path : string) : TFhirTiming;
    function ParseAddress(element : IXmlDomElement; path : string) : TFhirAddress;
    function ParseHumanName(element : IXmlDomElement; path : string) : TFhirHumanName;
    function ParseMeta(element : IXmlDomElement; path : string) : TFhirMeta;
    function ParseContactPoint(element : IXmlDomElement; path : string) : TFhirContactPoint;
    function ParseAge(element : IXmlDomElement; path : string) : TFhirAge;
    function ParseCount(element : IXmlDomElement; path : string) : TFhirCount;
    function ParseMoney(element : IXmlDomElement; path : string) : TFhirMoney;
    function ParseDistance(element : IXmlDomElement; path : string) : TFhirDistance;
    function ParseDuration(element : IXmlDomElement; path : string) : TFhirDuration;

    function ParseAllergyIntoleranceEvent(element : IXmlDomElement; path : string) : TFhirAllergyIntoleranceEvent;
    function ParseAllergyIntolerance(element : IXmlDomElement; path : string) : TFhirAllergyIntolerance;
    function ParseAppointmentParticipant(element : IXmlDomElement; path : string) : TFhirAppointmentParticipant;
    function ParseAppointment(element : IXmlDomElement; path : string) : TFhirAppointment;
    function ParseAppointmentResponse(element : IXmlDomElement; path : string) : TFhirAppointmentResponse;
    function ParseAuditEventEvent(element : IXmlDomElement; path : string) : TFhirAuditEventEvent;
    function ParseAuditEventParticipant(element : IXmlDomElement; path : string) : TFhirAuditEventParticipant;
    function ParseAuditEventParticipantNetwork(element : IXmlDomElement; path : string) : TFhirAuditEventParticipantNetwork;
    function ParseAuditEventSource(element : IXmlDomElement; path : string) : TFhirAuditEventSource;
    function ParseAuditEventObject(element : IXmlDomElement; path : string) : TFhirAuditEventObject;
    function ParseAuditEventObjectDetail(element : IXmlDomElement; path : string) : TFhirAuditEventObjectDetail;
    function ParseAuditEvent(element : IXmlDomElement; path : string) : TFhirAuditEvent;
    function ParseBasic(element : IXmlDomElement; path : string) : TFhirBasic;
    function ParseBinary(element : IXmlDomElement; path : string) : TFhirBinary;
    function ParseBodySite(element : IXmlDomElement; path : string) : TFhirBodySite;
    function ParseBundleLink(element : IXmlDomElement; path : string) : TFhirBundleLink;
    function ParseBundleEntry(element : IXmlDomElement; path : string) : TFhirBundleEntry;
    function ParseBundleEntrySearch(element : IXmlDomElement; path : string) : TFhirBundleEntrySearch;
    function ParseBundleEntryTransaction(element : IXmlDomElement; path : string) : TFhirBundleEntryTransaction;
    function ParseBundleEntryTransactionResponse(element : IXmlDomElement; path : string) : TFhirBundleEntryTransactionResponse;
    function ParseBundle(element : IXmlDomElement; path : string) : TFhirBundle;
    function ParseCarePlanParticipant(element : IXmlDomElement; path : string) : TFhirCarePlanParticipant;
    function ParseCarePlanActivity(element : IXmlDomElement; path : string) : TFhirCarePlanActivity;
    function ParseCarePlanActivityDetail(element : IXmlDomElement; path : string) : TFhirCarePlanActivityDetail;
    function ParseCarePlan(element : IXmlDomElement; path : string) : TFhirCarePlan;
    function ParseClaimPayee(element : IXmlDomElement; path : string) : TFhirClaimPayee;
    function ParseClaimDiagnosis(element : IXmlDomElement; path : string) : TFhirClaimDiagnosis;
    function ParseClaimCoverage(element : IXmlDomElement; path : string) : TFhirClaimCoverage;
    function ParseClaimItem(element : IXmlDomElement; path : string) : TFhirClaimItem;
    function ParseClaimItemDetail(element : IXmlDomElement; path : string) : TFhirClaimItemDetail;
    function ParseClaimItemDetailSubDetail(element : IXmlDomElement; path : string) : TFhirClaimItemDetailSubDetail;
    function ParseClaimItemProsthesis(element : IXmlDomElement; path : string) : TFhirClaimItemProsthesis;
    function ParseClaimMissingTeeth(element : IXmlDomElement; path : string) : TFhirClaimMissingTeeth;
    function ParseClaim(element : IXmlDomElement; path : string) : TFhirClaim;
    function ParseClaimResponseItem(element : IXmlDomElement; path : string) : TFhirClaimResponseItem;
    function ParseClaimResponseItemAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseItemAdjudication;
    function ParseClaimResponseItemDetail(element : IXmlDomElement; path : string) : TFhirClaimResponseItemDetail;
    function ParseClaimResponseItemDetailAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseItemDetailAdjudication;
    function ParseClaimResponseItemDetailSubDetail(element : IXmlDomElement; path : string) : TFhirClaimResponseItemDetailSubDetail;
    function ParseClaimResponseItemDetailSubDetailAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseItemDetailSubDetailAdjudication;
    function ParseClaimResponseAddItem(element : IXmlDomElement; path : string) : TFhirClaimResponseAddItem;
    function ParseClaimResponseAddItemAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseAddItemAdjudication;
    function ParseClaimResponseAddItemDetail(element : IXmlDomElement; path : string) : TFhirClaimResponseAddItemDetail;
    function ParseClaimResponseAddItemDetailAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseAddItemDetailAdjudication;
    function ParseClaimResponseError(element : IXmlDomElement; path : string) : TFhirClaimResponseError;
    function ParseClaimResponseNote(element : IXmlDomElement; path : string) : TFhirClaimResponseNote;
    function ParseClaimResponseCoverage(element : IXmlDomElement; path : string) : TFhirClaimResponseCoverage;
    function ParseClaimResponse(element : IXmlDomElement; path : string) : TFhirClaimResponse;
    function ParseClinicalImpressionInvestigations(element : IXmlDomElement; path : string) : TFhirClinicalImpressionInvestigations;
    function ParseClinicalImpressionFinding(element : IXmlDomElement; path : string) : TFhirClinicalImpressionFinding;
    function ParseClinicalImpressionRuledOut(element : IXmlDomElement; path : string) : TFhirClinicalImpressionRuledOut;
    function ParseClinicalImpression(element : IXmlDomElement; path : string) : TFhirClinicalImpression;
    function ParseCommunicationPayload(element : IXmlDomElement; path : string) : TFhirCommunicationPayload;
    function ParseCommunication(element : IXmlDomElement; path : string) : TFhirCommunication;
    function ParseCommunicationRequestPayload(element : IXmlDomElement; path : string) : TFhirCommunicationRequestPayload;
    function ParseCommunicationRequest(element : IXmlDomElement; path : string) : TFhirCommunicationRequest;
    function ParseCompositionAttester(element : IXmlDomElement; path : string) : TFhirCompositionAttester;
    function ParseCompositionEvent(element : IXmlDomElement; path : string) : TFhirCompositionEvent;
    function ParseCompositionSection(element : IXmlDomElement; path : string) : TFhirCompositionSection;
    function ParseComposition(element : IXmlDomElement; path : string) : TFhirComposition;
    function ParseConceptMapContact(element : IXmlDomElement; path : string) : TFhirConceptMapContact;
    function ParseConceptMapElement(element : IXmlDomElement; path : string) : TFhirConceptMapElement;
    function ParseConceptMapElementDependsOn(element : IXmlDomElement; path : string) : TFhirConceptMapElementDependsOn;
    function ParseConceptMapElementMap(element : IXmlDomElement; path : string) : TFhirConceptMapElementMap;
    function ParseConceptMap(element : IXmlDomElement; path : string) : TFhirConceptMap;
    function ParseConditionStage(element : IXmlDomElement; path : string) : TFhirConditionStage;
    function ParseConditionEvidence(element : IXmlDomElement; path : string) : TFhirConditionEvidence;
    function ParseConditionLocation(element : IXmlDomElement; path : string) : TFhirConditionLocation;
    function ParseConditionDueTo(element : IXmlDomElement; path : string) : TFhirConditionDueTo;
    function ParseConditionOccurredFollowing(element : IXmlDomElement; path : string) : TFhirConditionOccurredFollowing;
    function ParseCondition(element : IXmlDomElement; path : string) : TFhirCondition;
    function ParseConformanceContact(element : IXmlDomElement; path : string) : TFhirConformanceContact;
    function ParseConformanceSoftware(element : IXmlDomElement; path : string) : TFhirConformanceSoftware;
    function ParseConformanceImplementation(element : IXmlDomElement; path : string) : TFhirConformanceImplementation;
    function ParseConformanceRest(element : IXmlDomElement; path : string) : TFhirConformanceRest;
    function ParseConformanceRestSecurity(element : IXmlDomElement; path : string) : TFhirConformanceRestSecurity;
    function ParseConformanceRestSecurityCertificate(element : IXmlDomElement; path : string) : TFhirConformanceRestSecurityCertificate;
    function ParseConformanceRestResource(element : IXmlDomElement; path : string) : TFhirConformanceRestResource;
    function ParseConformanceRestResourceInteraction(element : IXmlDomElement; path : string) : TFhirConformanceRestResourceInteraction;
    function ParseConformanceRestResourceSearchParam(element : IXmlDomElement; path : string) : TFhirConformanceRestResourceSearchParam;
    function ParseConformanceRestInteraction(element : IXmlDomElement; path : string) : TFhirConformanceRestInteraction;
    function ParseConformanceRestOperation(element : IXmlDomElement; path : string) : TFhirConformanceRestOperation;
    function ParseConformanceMessaging(element : IXmlDomElement; path : string) : TFhirConformanceMessaging;
    function ParseConformanceMessagingEvent(element : IXmlDomElement; path : string) : TFhirConformanceMessagingEvent;
    function ParseConformanceDocument(element : IXmlDomElement; path : string) : TFhirConformanceDocument;
    function ParseConformance(element : IXmlDomElement; path : string) : TFhirConformance;
    function ParseContractActor(element : IXmlDomElement; path : string) : TFhirContractActor;
    function ParseContractValuedItem(element : IXmlDomElement; path : string) : TFhirContractValuedItem;
    function ParseContractSigner(element : IXmlDomElement; path : string) : TFhirContractSigner;
    function ParseContractTerm(element : IXmlDomElement; path : string) : TFhirContractTerm;
    function ParseContractTermActor(element : IXmlDomElement; path : string) : TFhirContractTermActor;
    function ParseContractTermValuedItem(element : IXmlDomElement; path : string) : TFhirContractTermValuedItem;
    function ParseContractFriendly(element : IXmlDomElement; path : string) : TFhirContractFriendly;
    function ParseContractLegal(element : IXmlDomElement; path : string) : TFhirContractLegal;
    function ParseContractRule(element : IXmlDomElement; path : string) : TFhirContractRule;
    function ParseContract(element : IXmlDomElement; path : string) : TFhirContract;
    function ParseContraindicationMitigation(element : IXmlDomElement; path : string) : TFhirContraindicationMitigation;
    function ParseContraindication(element : IXmlDomElement; path : string) : TFhirContraindication;
    function ParseCoverage(element : IXmlDomElement; path : string) : TFhirCoverage;
    function ParseDataElementContact(element : IXmlDomElement; path : string) : TFhirDataElementContact;
    function ParseDataElementMapping(element : IXmlDomElement; path : string) : TFhirDataElementMapping;
    function ParseDataElement(element : IXmlDomElement; path : string) : TFhirDataElement;
    function ParseDevice(element : IXmlDomElement; path : string) : TFhirDevice;
    function ParseDeviceComponentProductionSpecification(element : IXmlDomElement; path : string) : TFhirDeviceComponentProductionSpecification;
    function ParseDeviceComponent(element : IXmlDomElement; path : string) : TFhirDeviceComponent;
    function ParseDeviceMetricCalibration(element : IXmlDomElement; path : string) : TFhirDeviceMetricCalibration;
    function ParseDeviceMetric(element : IXmlDomElement; path : string) : TFhirDeviceMetric;
    function ParseDeviceUseRequest(element : IXmlDomElement; path : string) : TFhirDeviceUseRequest;
    function ParseDeviceUseStatement(element : IXmlDomElement; path : string) : TFhirDeviceUseStatement;
    function ParseDiagnosticOrderEvent(element : IXmlDomElement; path : string) : TFhirDiagnosticOrderEvent;
    function ParseDiagnosticOrderItem(element : IXmlDomElement; path : string) : TFhirDiagnosticOrderItem;
    function ParseDiagnosticOrder(element : IXmlDomElement; path : string) : TFhirDiagnosticOrder;
    function ParseDiagnosticReportImage(element : IXmlDomElement; path : string) : TFhirDiagnosticReportImage;
    function ParseDiagnosticReport(element : IXmlDomElement; path : string) : TFhirDiagnosticReport;
    function ParseDocumentManifestContent(element : IXmlDomElement; path : string) : TFhirDocumentManifestContent;
    function ParseDocumentManifestRelated(element : IXmlDomElement; path : string) : TFhirDocumentManifestRelated;
    function ParseDocumentManifest(element : IXmlDomElement; path : string) : TFhirDocumentManifest;
    function ParseDocumentReferenceRelatesTo(element : IXmlDomElement; path : string) : TFhirDocumentReferenceRelatesTo;
    function ParseDocumentReferenceContext(element : IXmlDomElement; path : string) : TFhirDocumentReferenceContext;
    function ParseDocumentReferenceContextRelated(element : IXmlDomElement; path : string) : TFhirDocumentReferenceContextRelated;
    function ParseDocumentReference(element : IXmlDomElement; path : string) : TFhirDocumentReference;
    function ParseEligibilityRequest(element : IXmlDomElement; path : string) : TFhirEligibilityRequest;
    function ParseEligibilityResponse(element : IXmlDomElement; path : string) : TFhirEligibilityResponse;
    function ParseEncounterStatusHistory(element : IXmlDomElement; path : string) : TFhirEncounterStatusHistory;
    function ParseEncounterParticipant(element : IXmlDomElement; path : string) : TFhirEncounterParticipant;
    function ParseEncounterHospitalization(element : IXmlDomElement; path : string) : TFhirEncounterHospitalization;
    function ParseEncounterLocation(element : IXmlDomElement; path : string) : TFhirEncounterLocation;
    function ParseEncounter(element : IXmlDomElement; path : string) : TFhirEncounter;
    function ParseEnrollmentRequest(element : IXmlDomElement; path : string) : TFhirEnrollmentRequest;
    function ParseEnrollmentResponse(element : IXmlDomElement; path : string) : TFhirEnrollmentResponse;
    function ParseEpisodeOfCareStatusHistory(element : IXmlDomElement; path : string) : TFhirEpisodeOfCareStatusHistory;
    function ParseEpisodeOfCareCareTeam(element : IXmlDomElement; path : string) : TFhirEpisodeOfCareCareTeam;
    function ParseEpisodeOfCare(element : IXmlDomElement; path : string) : TFhirEpisodeOfCare;
    function ParseExplanationOfBenefit(element : IXmlDomElement; path : string) : TFhirExplanationOfBenefit;
    function ParseFamilyMemberHistoryCondition(element : IXmlDomElement; path : string) : TFhirFamilyMemberHistoryCondition;
    function ParseFamilyMemberHistory(element : IXmlDomElement; path : string) : TFhirFamilyMemberHistory;
    function ParseFlag(element : IXmlDomElement; path : string) : TFhirFlag;
    function ParseGoalOutcome(element : IXmlDomElement; path : string) : TFhirGoalOutcome;
    function ParseGoal(element : IXmlDomElement; path : string) : TFhirGoal;
    function ParseGroupCharacteristic(element : IXmlDomElement; path : string) : TFhirGroupCharacteristic;
    function ParseGroup(element : IXmlDomElement; path : string) : TFhirGroup;
    function ParseHealthcareServiceServiceType(element : IXmlDomElement; path : string) : TFhirHealthcareServiceServiceType;
    function ParseHealthcareServiceAvailableTime(element : IXmlDomElement; path : string) : TFhirHealthcareServiceAvailableTime;
    function ParseHealthcareServiceNotAvailable(element : IXmlDomElement; path : string) : TFhirHealthcareServiceNotAvailable;
    function ParseHealthcareService(element : IXmlDomElement; path : string) : TFhirHealthcareService;
    function ParseImagingObjectSelectionStudy(element : IXmlDomElement; path : string) : TFhirImagingObjectSelectionStudy;
    function ParseImagingObjectSelectionStudySeries(element : IXmlDomElement; path : string) : TFhirImagingObjectSelectionStudySeries;
    function ParseImagingObjectSelectionStudySeriesInstance(element : IXmlDomElement; path : string) : TFhirImagingObjectSelectionStudySeriesInstance;
    function ParseImagingObjectSelectionStudySeriesInstanceFrames(element : IXmlDomElement; path : string) : TFhirImagingObjectSelectionStudySeriesInstanceFrames;
    function ParseImagingObjectSelection(element : IXmlDomElement; path : string) : TFhirImagingObjectSelection;
    function ParseImagingStudySeries(element : IXmlDomElement; path : string) : TFhirImagingStudySeries;
    function ParseImagingStudySeriesInstance(element : IXmlDomElement; path : string) : TFhirImagingStudySeriesInstance;
    function ParseImagingStudy(element : IXmlDomElement; path : string) : TFhirImagingStudy;
    function ParseImmunizationExplanation(element : IXmlDomElement; path : string) : TFhirImmunizationExplanation;
    function ParseImmunizationReaction(element : IXmlDomElement; path : string) : TFhirImmunizationReaction;
    function ParseImmunizationVaccinationProtocol(element : IXmlDomElement; path : string) : TFhirImmunizationVaccinationProtocol;
    function ParseImmunization(element : IXmlDomElement; path : string) : TFhirImmunization;
    function ParseImmunizationRecommendationRecommendation(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendation;
    function ParseImmunizationRecommendationRecommendationDateCriterion(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    function ParseImmunizationRecommendationRecommendationProtocol(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendationProtocol;
    function ParseImmunizationRecommendation(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendation;
    function ParseListEntry(element : IXmlDomElement; path : string) : TFhirListEntry;
    function ParseList(element : IXmlDomElement; path : string) : TFhirList;
    function ParseLocationPosition(element : IXmlDomElement; path : string) : TFhirLocationPosition;
    function ParseLocation(element : IXmlDomElement; path : string) : TFhirLocation;
    function ParseMedia(element : IXmlDomElement; path : string) : TFhirMedia;
    function ParseMedicationProduct(element : IXmlDomElement; path : string) : TFhirMedicationProduct;
    function ParseMedicationProductIngredient(element : IXmlDomElement; path : string) : TFhirMedicationProductIngredient;
    function ParseMedicationProductBatch(element : IXmlDomElement; path : string) : TFhirMedicationProductBatch;
    function ParseMedicationPackage(element : IXmlDomElement; path : string) : TFhirMedicationPackage;
    function ParseMedicationPackageContent(element : IXmlDomElement; path : string) : TFhirMedicationPackageContent;
    function ParseMedication(element : IXmlDomElement; path : string) : TFhirMedication;
    function ParseMedicationAdministrationDosage(element : IXmlDomElement; path : string) : TFhirMedicationAdministrationDosage;
    function ParseMedicationAdministration(element : IXmlDomElement; path : string) : TFhirMedicationAdministration;
    function ParseMedicationDispenseDosageInstruction(element : IXmlDomElement; path : string) : TFhirMedicationDispenseDosageInstruction;
    function ParseMedicationDispenseSubstitution(element : IXmlDomElement; path : string) : TFhirMedicationDispenseSubstitution;
    function ParseMedicationDispense(element : IXmlDomElement; path : string) : TFhirMedicationDispense;
    function ParseMedicationPrescriptionDosageInstruction(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionDosageInstruction;
    function ParseMedicationPrescriptionDispense(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionDispense;
    function ParseMedicationPrescriptionSubstitution(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionSubstitution;
    function ParseMedicationPrescription(element : IXmlDomElement; path : string) : TFhirMedicationPrescription;
    function ParseMedicationStatementDosage(element : IXmlDomElement; path : string) : TFhirMedicationStatementDosage;
    function ParseMedicationStatement(element : IXmlDomElement; path : string) : TFhirMedicationStatement;
    function ParseMessageHeaderResponse(element : IXmlDomElement; path : string) : TFhirMessageHeaderResponse;
    function ParseMessageHeaderSource(element : IXmlDomElement; path : string) : TFhirMessageHeaderSource;
    function ParseMessageHeaderDestination(element : IXmlDomElement; path : string) : TFhirMessageHeaderDestination;
    function ParseMessageHeader(element : IXmlDomElement; path : string) : TFhirMessageHeader;
    function ParseNamingSystemUniqueId(element : IXmlDomElement; path : string) : TFhirNamingSystemUniqueId;
    function ParseNamingSystemContact(element : IXmlDomElement; path : string) : TFhirNamingSystemContact;
    function ParseNamingSystem(element : IXmlDomElement; path : string) : TFhirNamingSystem;
    function ParseNutritionOrderOralDiet(element : IXmlDomElement; path : string) : TFhirNutritionOrderOralDiet;
    function ParseNutritionOrderOralDietNutrient(element : IXmlDomElement; path : string) : TFhirNutritionOrderOralDietNutrient;
    function ParseNutritionOrderOralDietTexture(element : IXmlDomElement; path : string) : TFhirNutritionOrderOralDietTexture;
    function ParseNutritionOrderSupplement(element : IXmlDomElement; path : string) : TFhirNutritionOrderSupplement;
    function ParseNutritionOrderEnteralFormula(element : IXmlDomElement; path : string) : TFhirNutritionOrderEnteralFormula;
    function ParseNutritionOrder(element : IXmlDomElement; path : string) : TFhirNutritionOrder;
    function ParseObservationReferenceRange(element : IXmlDomElement; path : string) : TFhirObservationReferenceRange;
    function ParseObservationRelated(element : IXmlDomElement; path : string) : TFhirObservationRelated;
    function ParseObservation(element : IXmlDomElement; path : string) : TFhirObservation;
    function ParseOperationDefinitionContact(element : IXmlDomElement; path : string) : TFhirOperationDefinitionContact;
    function ParseOperationDefinitionParameter(element : IXmlDomElement; path : string) : TFhirOperationDefinitionParameter;
    function ParseOperationDefinitionParameterPart(element : IXmlDomElement; path : string) : TFhirOperationDefinitionParameterPart;
    function ParseOperationDefinition(element : IXmlDomElement; path : string) : TFhirOperationDefinition;
    function ParseOperationOutcomeIssue(element : IXmlDomElement; path : string) : TFhirOperationOutcomeIssue;
    function ParseOperationOutcome(element : IXmlDomElement; path : string) : TFhirOperationOutcome;
    function ParseOrderWhen(element : IXmlDomElement; path : string) : TFhirOrderWhen;
    function ParseOrder(element : IXmlDomElement; path : string) : TFhirOrder;
    function ParseOrderResponse(element : IXmlDomElement; path : string) : TFhirOrderResponse;
    function ParseOrganizationContact(element : IXmlDomElement; path : string) : TFhirOrganizationContact;
    function ParseOrganization(element : IXmlDomElement; path : string) : TFhirOrganization;
    function ParsePatientContact(element : IXmlDomElement; path : string) : TFhirPatientContact;
    function ParsePatientAnimal(element : IXmlDomElement; path : string) : TFhirPatientAnimal;
    function ParsePatientCommunication(element : IXmlDomElement; path : string) : TFhirPatientCommunication;
    function ParsePatientLink(element : IXmlDomElement; path : string) : TFhirPatientLink;
    function ParsePatient(element : IXmlDomElement; path : string) : TFhirPatient;
    function ParsePaymentNotice(element : IXmlDomElement; path : string) : TFhirPaymentNotice;
    function ParsePaymentReconciliationDetail(element : IXmlDomElement; path : string) : TFhirPaymentReconciliationDetail;
    function ParsePaymentReconciliationNote(element : IXmlDomElement; path : string) : TFhirPaymentReconciliationNote;
    function ParsePaymentReconciliation(element : IXmlDomElement; path : string) : TFhirPaymentReconciliation;
    function ParsePersonLink(element : IXmlDomElement; path : string) : TFhirPersonLink;
    function ParsePerson(element : IXmlDomElement; path : string) : TFhirPerson;
    function ParsePractitionerPractitionerRole(element : IXmlDomElement; path : string) : TFhirPractitionerPractitionerRole;
    function ParsePractitionerQualification(element : IXmlDomElement; path : string) : TFhirPractitionerQualification;
    function ParsePractitioner(element : IXmlDomElement; path : string) : TFhirPractitioner;
    function ParseProcedureBodySite(element : IXmlDomElement; path : string) : TFhirProcedureBodySite;
    function ParseProcedurePerformer(element : IXmlDomElement; path : string) : TFhirProcedurePerformer;
    function ParseProcedureRelatedItem(element : IXmlDomElement; path : string) : TFhirProcedureRelatedItem;
    function ParseProcedureDevice(element : IXmlDomElement; path : string) : TFhirProcedureDevice;
    function ParseProcedure(element : IXmlDomElement; path : string) : TFhirProcedure;
    function ParseProcedureRequestBodySite(element : IXmlDomElement; path : string) : TFhirProcedureRequestBodySite;
    function ParseProcedureRequest(element : IXmlDomElement; path : string) : TFhirProcedureRequest;
    function ParseProcessRequestItem(element : IXmlDomElement; path : string) : TFhirProcessRequestItem;
    function ParseProcessRequest(element : IXmlDomElement; path : string) : TFhirProcessRequest;
    function ParseProcessResponseNotes(element : IXmlDomElement; path : string) : TFhirProcessResponseNotes;
    function ParseProcessResponse(element : IXmlDomElement; path : string) : TFhirProcessResponse;
    function ParseProvenanceAgent(element : IXmlDomElement; path : string) : TFhirProvenanceAgent;
    function ParseProvenanceEntity(element : IXmlDomElement; path : string) : TFhirProvenanceEntity;
    function ParseProvenance(element : IXmlDomElement; path : string) : TFhirProvenance;
    function ParseQuestionnaireGroup(element : IXmlDomElement; path : string) : TFhirQuestionnaireGroup;
    function ParseQuestionnaireGroupQuestion(element : IXmlDomElement; path : string) : TFhirQuestionnaireGroupQuestion;
    function ParseQuestionnaire(element : IXmlDomElement; path : string) : TFhirQuestionnaire;
    function ParseQuestionnaireAnswersGroup(element : IXmlDomElement; path : string) : TFhirQuestionnaireAnswersGroup;
    function ParseQuestionnaireAnswersGroupQuestion(element : IXmlDomElement; path : string) : TFhirQuestionnaireAnswersGroupQuestion;
    function ParseQuestionnaireAnswersGroupQuestionAnswer(element : IXmlDomElement; path : string) : TFhirQuestionnaireAnswersGroupQuestionAnswer;
    function ParseQuestionnaireAnswers(element : IXmlDomElement; path : string) : TFhirQuestionnaireAnswers;
    function ParseReferralRequest(element : IXmlDomElement; path : string) : TFhirReferralRequest;
    function ParseRelatedPerson(element : IXmlDomElement; path : string) : TFhirRelatedPerson;
    function ParseRiskAssessmentPrediction(element : IXmlDomElement; path : string) : TFhirRiskAssessmentPrediction;
    function ParseRiskAssessment(element : IXmlDomElement; path : string) : TFhirRiskAssessment;
    function ParseSchedule(element : IXmlDomElement; path : string) : TFhirSchedule;
    function ParseSearchParameterContact(element : IXmlDomElement; path : string) : TFhirSearchParameterContact;
    function ParseSearchParameter(element : IXmlDomElement; path : string) : TFhirSearchParameter;
    function ParseSlot(element : IXmlDomElement; path : string) : TFhirSlot;
    function ParseSpecimenCollection(element : IXmlDomElement; path : string) : TFhirSpecimenCollection;
    function ParseSpecimenTreatment(element : IXmlDomElement; path : string) : TFhirSpecimenTreatment;
    function ParseSpecimenContainer(element : IXmlDomElement; path : string) : TFhirSpecimenContainer;
    function ParseSpecimen(element : IXmlDomElement; path : string) : TFhirSpecimen;
    function ParseStructureDefinitionContact(element : IXmlDomElement; path : string) : TFhirStructureDefinitionContact;
    function ParseStructureDefinitionMapping(element : IXmlDomElement; path : string) : TFhirStructureDefinitionMapping;
    function ParseStructureDefinitionSnapshot(element : IXmlDomElement; path : string) : TFhirStructureDefinitionSnapshot;
    function ParseStructureDefinitionDifferential(element : IXmlDomElement; path : string) : TFhirStructureDefinitionDifferential;
    function ParseStructureDefinition(element : IXmlDomElement; path : string) : TFhirStructureDefinition;
    function ParseSubscriptionChannel(element : IXmlDomElement; path : string) : TFhirSubscriptionChannel;
    function ParseSubscription(element : IXmlDomElement; path : string) : TFhirSubscription;
    function ParseSubstanceInstance(element : IXmlDomElement; path : string) : TFhirSubstanceInstance;
    function ParseSubstanceIngredient(element : IXmlDomElement; path : string) : TFhirSubstanceIngredient;
    function ParseSubstance(element : IXmlDomElement; path : string) : TFhirSubstance;
    function ParseSupplyDispense(element : IXmlDomElement; path : string) : TFhirSupplyDispense;
    function ParseSupply(element : IXmlDomElement; path : string) : TFhirSupply;
    function ParseSupplyDelivery(element : IXmlDomElement; path : string) : TFhirSupplyDelivery;
    function ParseSupplyRequest(element : IXmlDomElement; path : string) : TFhirSupplyRequest;
    function ParseValueSetContact(element : IXmlDomElement; path : string) : TFhirValueSetContact;
    function ParseValueSetDefine(element : IXmlDomElement; path : string) : TFhirValueSetDefine;
    function ParseValueSetDefineConcept(element : IXmlDomElement; path : string) : TFhirValueSetDefineConcept;
    function ParseValueSetDefineConceptDesignation(element : IXmlDomElement; path : string) : TFhirValueSetDefineConceptDesignation;
    function ParseValueSetCompose(element : IXmlDomElement; path : string) : TFhirValueSetCompose;
    function ParseValueSetComposeInclude(element : IXmlDomElement; path : string) : TFhirValueSetComposeInclude;
    function ParseValueSetComposeIncludeConcept(element : IXmlDomElement; path : string) : TFhirValueSetComposeIncludeConcept;
    function ParseValueSetComposeIncludeFilter(element : IXmlDomElement; path : string) : TFhirValueSetComposeIncludeFilter;
    function ParseValueSetExpansion(element : IXmlDomElement; path : string) : TFhirValueSetExpansion;
    function ParseValueSetExpansionParameter(element : IXmlDomElement; path : string) : TFhirValueSetExpansionParameter;
    function ParseValueSetExpansionContains(element : IXmlDomElement; path : string) : TFhirValueSetExpansionContains;
    function ParseValueSet(element : IXmlDomElement; path : string) : TFhirValueSet;
    function ParseVisionPrescriptionDispense(element : IXmlDomElement; path : string) : TFhirVisionPrescriptionDispense;
    function ParseVisionPrescription(element : IXmlDomElement; path : string) : TFhirVisionPrescription;
    function ParseResource(element : IxmlDomElement; path : String) : TFhirResource; override;
    function ParseDataType(element : IXmlDomElement; name : String; type_ : TFHIRTypeClass) : TFHIRType; override;
  public
    function ParseFragment(element : IxmlDomElement) : TFhirBase; overload;
  end;

  TFHIRXmlComposer = class (TFHIRXmlComposerBase)
  protected
    procedure ComposeElement(xml : TXmlBuilder; name : string; elem : TFhirElement);
    procedure ComposeBackboneElement(xml : TXmlBuilder; name : string; elem : TFhirBackboneElement);

    Procedure ComposeElementAttributes(xml : TXmlBuilder; element : TFhirElement);
    Procedure ComposeElementChildren(xml : TXmlBuilder; element : TFhirElement);
    Procedure ComposeBackboneElementChildren(xml : TXmlBuilder; element : TFhirBackboneElement);
    Procedure ComposeEnum(xml : TXmlBuilder; name : String; value : TFhirEnum; Const aNames : Array Of String);
    Procedure ComposeInteger(xml : TXmlBuilder; name : String; value : TFhirInteger);
    Procedure ComposeDateTime(xml : TXmlBuilder; name : String; value : TFhirDateTime);
    Procedure ComposeDate(xml : TXmlBuilder; name : String; value : TFhirDate);
    Procedure ComposeDecimal(xml : TXmlBuilder; name : String; value : TFhirDecimal);
    Procedure ComposeUri(xml : TXmlBuilder; name : String; value : TFhirUri);
    Procedure ComposeBase64Binary(xml : TXmlBuilder; name : String; value : TFhirBase64Binary);
    Procedure ComposeTime(xml : TXmlBuilder; name : String; value : TFhirTime);
    Procedure ComposeString(xml : TXmlBuilder; name : String; value : TFhirString);
    Procedure ComposeBoolean(xml : TXmlBuilder; name : String; value : TFhirBoolean);
    Procedure ComposeInstant(xml : TXmlBuilder; name : String; value : TFhirInstant);
    Procedure ComposeUnsignedInt(xml : TXmlBuilder; name : String; value : TFhirUnsignedInt);
    Procedure ComposeCode(xml : TXmlBuilder; name : String; value : TFhirCode);
    Procedure ComposeId(xml : TXmlBuilder; name : String; value : TFhirId);
    Procedure ComposeOid(xml : TXmlBuilder; name : String; value : TFhirOid);
    Procedure ComposePositiveInt(xml : TXmlBuilder; name : String; value : TFhirPositiveInt);
    Procedure ComposeUuid(xml : TXmlBuilder; name : String; value : TFhirUuid);

    Procedure ComposeResourceAttributes(xml : TXmlBuilder; resource : TFhirResource);
    Procedure ComposeResourceChildren(xml : TXmlBuilder; elem : TFhirResource);
    Procedure ComposeDomainResourceAttributes(xml : TXmlBuilder; resource : TFhirDomainResource);
    Procedure ComposeDomainResourceChildren(xml : TXmlBuilder; elem : TFhirDomainResource);
    procedure ComposeParametersParameter(xml : TXmlBuilder; name : string; elem : TFhirParametersParameter);
    procedure ComposeParametersParameterPart(xml : TXmlBuilder; name : string; elem : TFhirParametersParameterPart);
    procedure ComposeParameters(xml : TXmlBuilder; name : string; elem : TFhirParameters);

    procedure ComposeExtension(xml : TXmlBuilder; name : string; elem : TFhirExtension);
    procedure ComposeNarrative(xml : TXmlBuilder; name : string; elem : TFhirNarrative);
    procedure ComposePeriod(xml : TXmlBuilder; name : string; elem : TFhirPeriod);
    procedure ComposeCoding(xml : TXmlBuilder; name : string; elem : TFhirCoding);
    procedure ComposeRange(xml : TXmlBuilder; name : string; elem : TFhirRange);
    procedure ComposeQuantity(xml : TXmlBuilder; name : string; elem : TFhirQuantity);
    procedure ComposeAttachment(xml : TXmlBuilder; name : string; elem : TFhirAttachment);
    procedure ComposeRatio(xml : TXmlBuilder; name : string; elem : TFhirRatio);
    procedure ComposeSampledData(xml : TXmlBuilder; name : string; elem : TFhirSampledData);
    procedure ComposeReference(xml : TXmlBuilder; name : string; elem : TFhirReference);
    procedure ComposeCodeableConcept(xml : TXmlBuilder; name : string; elem : TFhirCodeableConcept);
    procedure ComposeIdentifier(xml : TXmlBuilder; name : string; elem : TFhirIdentifier);
    procedure ComposeSignature(xml : TXmlBuilder; name : string; elem : TFhirSignature);
    procedure ComposeElementDefinitionSlicing(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionSlicing);
    procedure ComposeElementDefinitionType(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionType);
    procedure ComposeElementDefinitionConstraint(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionConstraint);
    procedure ComposeElementDefinitionBinding(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionBinding);
    procedure ComposeElementDefinitionMapping(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionMapping);
    procedure ComposeElementDefinition(xml : TXmlBuilder; name : string; elem : TFhirElementDefinition);
    procedure ComposeTimingRepeat(xml : TXmlBuilder; name : string; elem : TFhirTimingRepeat);
    procedure ComposeTiming(xml : TXmlBuilder; name : string; elem : TFhirTiming);
    procedure ComposeAddress(xml : TXmlBuilder; name : string; elem : TFhirAddress);
    procedure ComposeHumanName(xml : TXmlBuilder; name : string; elem : TFhirHumanName);
    procedure ComposeMeta(xml : TXmlBuilder; name : string; elem : TFhirMeta);
    procedure ComposeContactPoint(xml : TXmlBuilder; name : string; elem : TFhirContactPoint);
    procedure ComposeAge(xml : TXmlBuilder; name : string; elem : TFhirAge);
    procedure ComposeCount(xml : TXmlBuilder; name : string; elem : TFhirCount);
    procedure ComposeMoney(xml : TXmlBuilder; name : string; elem : TFhirMoney);
    procedure ComposeDistance(xml : TXmlBuilder; name : string; elem : TFhirDistance);
    procedure ComposeDuration(xml : TXmlBuilder; name : string; elem : TFhirDuration);

    procedure ComposeAllergyIntoleranceEvent(xml : TXmlBuilder; name : string; elem : TFhirAllergyIntoleranceEvent);
    procedure ComposeAllergyIntolerance(xml : TXmlBuilder; name : string; elem : TFhirAllergyIntolerance);
    procedure ComposeAppointmentParticipant(xml : TXmlBuilder; name : string; elem : TFhirAppointmentParticipant);
    procedure ComposeAppointment(xml : TXmlBuilder; name : string; elem : TFhirAppointment);
    procedure ComposeAppointmentResponse(xml : TXmlBuilder; name : string; elem : TFhirAppointmentResponse);
    procedure ComposeAuditEventEvent(xml : TXmlBuilder; name : string; elem : TFhirAuditEventEvent);
    procedure ComposeAuditEventParticipant(xml : TXmlBuilder; name : string; elem : TFhirAuditEventParticipant);
    procedure ComposeAuditEventParticipantNetwork(xml : TXmlBuilder; name : string; elem : TFhirAuditEventParticipantNetwork);
    procedure ComposeAuditEventSource(xml : TXmlBuilder; name : string; elem : TFhirAuditEventSource);
    procedure ComposeAuditEventObject(xml : TXmlBuilder; name : string; elem : TFhirAuditEventObject);
    procedure ComposeAuditEventObjectDetail(xml : TXmlBuilder; name : string; elem : TFhirAuditEventObjectDetail);
    procedure ComposeAuditEvent(xml : TXmlBuilder; name : string; elem : TFhirAuditEvent);
    procedure ComposeBasic(xml : TXmlBuilder; name : string; elem : TFhirBasic);
    procedure ComposeBinary(xml : TXmlBuilder; name : string; elem : TFhirBinary);
    procedure ComposeBodySite(xml : TXmlBuilder; name : string; elem : TFhirBodySite);
    procedure ComposeBundleLink(xml : TXmlBuilder; name : string; elem : TFhirBundleLink);
    procedure ComposeBundleEntry(xml : TXmlBuilder; name : string; elem : TFhirBundleEntry);
    procedure ComposeBundleEntrySearch(xml : TXmlBuilder; name : string; elem : TFhirBundleEntrySearch);
    procedure ComposeBundleEntryTransaction(xml : TXmlBuilder; name : string; elem : TFhirBundleEntryTransaction);
    procedure ComposeBundleEntryTransactionResponse(xml : TXmlBuilder; name : string; elem : TFhirBundleEntryTransactionResponse);
    procedure ComposeBundle(xml : TXmlBuilder; name : string; elem : TFhirBundle);
    procedure ComposeCarePlanParticipant(xml : TXmlBuilder; name : string; elem : TFhirCarePlanParticipant);
    procedure ComposeCarePlanActivity(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivity);
    procedure ComposeCarePlanActivityDetail(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivityDetail);
    procedure ComposeCarePlan(xml : TXmlBuilder; name : string; elem : TFhirCarePlan);
    procedure ComposeClaimPayee(xml : TXmlBuilder; name : string; elem : TFhirClaimPayee);
    procedure ComposeClaimDiagnosis(xml : TXmlBuilder; name : string; elem : TFhirClaimDiagnosis);
    procedure ComposeClaimCoverage(xml : TXmlBuilder; name : string; elem : TFhirClaimCoverage);
    procedure ComposeClaimItem(xml : TXmlBuilder; name : string; elem : TFhirClaimItem);
    procedure ComposeClaimItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimItemDetail);
    procedure ComposeClaimItemDetailSubDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimItemDetailSubDetail);
    procedure ComposeClaimItemProsthesis(xml : TXmlBuilder; name : string; elem : TFhirClaimItemProsthesis);
    procedure ComposeClaimMissingTeeth(xml : TXmlBuilder; name : string; elem : TFhirClaimMissingTeeth);
    procedure ComposeClaim(xml : TXmlBuilder; name : string; elem : TFhirClaim);
    procedure ComposeClaimResponseItem(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItem);
    procedure ComposeClaimResponseItemAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemAdjudication);
    procedure ComposeClaimResponseItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetail);
    procedure ComposeClaimResponseItemDetailAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetailAdjudication);
    procedure ComposeClaimResponseItemDetailSubDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetailSubDetail);
    procedure ComposeClaimResponseItemDetailSubDetailAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetailSubDetailAdjudication);
    procedure ComposeClaimResponseAddItem(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItem);
    procedure ComposeClaimResponseAddItemAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItemAdjudication);
    procedure ComposeClaimResponseAddItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItemDetail);
    procedure ComposeClaimResponseAddItemDetailAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItemDetailAdjudication);
    procedure ComposeClaimResponseError(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseError);
    procedure ComposeClaimResponseNote(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseNote);
    procedure ComposeClaimResponseCoverage(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseCoverage);
    procedure ComposeClaimResponse(xml : TXmlBuilder; name : string; elem : TFhirClaimResponse);
    procedure ComposeClinicalImpressionInvestigations(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpressionInvestigations);
    procedure ComposeClinicalImpressionFinding(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpressionFinding);
    procedure ComposeClinicalImpressionRuledOut(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpressionRuledOut);
    procedure ComposeClinicalImpression(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpression);
    procedure ComposeCommunicationPayload(xml : TXmlBuilder; name : string; elem : TFhirCommunicationPayload);
    procedure ComposeCommunication(xml : TXmlBuilder; name : string; elem : TFhirCommunication);
    procedure ComposeCommunicationRequestPayload(xml : TXmlBuilder; name : string; elem : TFhirCommunicationRequestPayload);
    procedure ComposeCommunicationRequest(xml : TXmlBuilder; name : string; elem : TFhirCommunicationRequest);
    procedure ComposeCompositionAttester(xml : TXmlBuilder; name : string; elem : TFhirCompositionAttester);
    procedure ComposeCompositionEvent(xml : TXmlBuilder; name : string; elem : TFhirCompositionEvent);
    procedure ComposeCompositionSection(xml : TXmlBuilder; name : string; elem : TFhirCompositionSection);
    procedure ComposeComposition(xml : TXmlBuilder; name : string; elem : TFhirComposition);
    procedure ComposeConceptMapContact(xml : TXmlBuilder; name : string; elem : TFhirConceptMapContact);
    procedure ComposeConceptMapElement(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElement);
    procedure ComposeConceptMapElementDependsOn(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElementDependsOn);
    procedure ComposeConceptMapElementMap(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElementMap);
    procedure ComposeConceptMap(xml : TXmlBuilder; name : string; elem : TFhirConceptMap);
    procedure ComposeConditionStage(xml : TXmlBuilder; name : string; elem : TFhirConditionStage);
    procedure ComposeConditionEvidence(xml : TXmlBuilder; name : string; elem : TFhirConditionEvidence);
    procedure ComposeConditionLocation(xml : TXmlBuilder; name : string; elem : TFhirConditionLocation);
    procedure ComposeConditionDueTo(xml : TXmlBuilder; name : string; elem : TFhirConditionDueTo);
    procedure ComposeConditionOccurredFollowing(xml : TXmlBuilder; name : string; elem : TFhirConditionOccurredFollowing);
    procedure ComposeCondition(xml : TXmlBuilder; name : string; elem : TFhirCondition);
    procedure ComposeConformanceContact(xml : TXmlBuilder; name : string; elem : TFhirConformanceContact);
    procedure ComposeConformanceSoftware(xml : TXmlBuilder; name : string; elem : TFhirConformanceSoftware);
    procedure ComposeConformanceImplementation(xml : TXmlBuilder; name : string; elem : TFhirConformanceImplementation);
    procedure ComposeConformanceRest(xml : TXmlBuilder; name : string; elem : TFhirConformanceRest);
    procedure ComposeConformanceRestSecurity(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurity);
    procedure ComposeConformanceRestSecurityCertificate(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurityCertificate);
    procedure ComposeConformanceRestResource(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResource);
    procedure ComposeConformanceRestResourceInteraction(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceInteraction);
    procedure ComposeConformanceRestResourceSearchParam(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceSearchParam);
    procedure ComposeConformanceRestInteraction(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestInteraction);
    procedure ComposeConformanceRestOperation(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestOperation);
    procedure ComposeConformanceMessaging(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessaging);
    procedure ComposeConformanceMessagingEvent(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessagingEvent);
    procedure ComposeConformanceDocument(xml : TXmlBuilder; name : string; elem : TFhirConformanceDocument);
    procedure ComposeConformance(xml : TXmlBuilder; name : string; elem : TFhirConformance);
    procedure ComposeContractActor(xml : TXmlBuilder; name : string; elem : TFhirContractActor);
    procedure ComposeContractValuedItem(xml : TXmlBuilder; name : string; elem : TFhirContractValuedItem);
    procedure ComposeContractSigner(xml : TXmlBuilder; name : string; elem : TFhirContractSigner);
    procedure ComposeContractTerm(xml : TXmlBuilder; name : string; elem : TFhirContractTerm);
    procedure ComposeContractTermActor(xml : TXmlBuilder; name : string; elem : TFhirContractTermActor);
    procedure ComposeContractTermValuedItem(xml : TXmlBuilder; name : string; elem : TFhirContractTermValuedItem);
    procedure ComposeContractFriendly(xml : TXmlBuilder; name : string; elem : TFhirContractFriendly);
    procedure ComposeContractLegal(xml : TXmlBuilder; name : string; elem : TFhirContractLegal);
    procedure ComposeContractRule(xml : TXmlBuilder; name : string; elem : TFhirContractRule);
    procedure ComposeContract(xml : TXmlBuilder; name : string; elem : TFhirContract);
    procedure ComposeContraindicationMitigation(xml : TXmlBuilder; name : string; elem : TFhirContraindicationMitigation);
    procedure ComposeContraindication(xml : TXmlBuilder; name : string; elem : TFhirContraindication);
    procedure ComposeCoverage(xml : TXmlBuilder; name : string; elem : TFhirCoverage);
    procedure ComposeDataElementContact(xml : TXmlBuilder; name : string; elem : TFhirDataElementContact);
    procedure ComposeDataElementMapping(xml : TXmlBuilder; name : string; elem : TFhirDataElementMapping);
    procedure ComposeDataElement(xml : TXmlBuilder; name : string; elem : TFhirDataElement);
    procedure ComposeDevice(xml : TXmlBuilder; name : string; elem : TFhirDevice);
    procedure ComposeDeviceComponentProductionSpecification(xml : TXmlBuilder; name : string; elem : TFhirDeviceComponentProductionSpecification);
    procedure ComposeDeviceComponent(xml : TXmlBuilder; name : string; elem : TFhirDeviceComponent);
    procedure ComposeDeviceMetricCalibration(xml : TXmlBuilder; name : string; elem : TFhirDeviceMetricCalibration);
    procedure ComposeDeviceMetric(xml : TXmlBuilder; name : string; elem : TFhirDeviceMetric);
    procedure ComposeDeviceUseRequest(xml : TXmlBuilder; name : string; elem : TFhirDeviceUseRequest);
    procedure ComposeDeviceUseStatement(xml : TXmlBuilder; name : string; elem : TFhirDeviceUseStatement);
    procedure ComposeDiagnosticOrderEvent(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderEvent);
    procedure ComposeDiagnosticOrderItem(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderItem);
    procedure ComposeDiagnosticOrder(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrder);
    procedure ComposeDiagnosticReportImage(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReportImage);
    procedure ComposeDiagnosticReport(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReport);
    procedure ComposeDocumentManifestContent(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifestContent);
    procedure ComposeDocumentManifestRelated(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifestRelated);
    procedure ComposeDocumentManifest(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifest);
    procedure ComposeDocumentReferenceRelatesTo(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceRelatesTo);
    procedure ComposeDocumentReferenceContext(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContext);
    procedure ComposeDocumentReferenceContextRelated(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContextRelated);
    procedure ComposeDocumentReference(xml : TXmlBuilder; name : string; elem : TFhirDocumentReference);
    procedure ComposeEligibilityRequest(xml : TXmlBuilder; name : string; elem : TFhirEligibilityRequest);
    procedure ComposeEligibilityResponse(xml : TXmlBuilder; name : string; elem : TFhirEligibilityResponse);
    procedure ComposeEncounterStatusHistory(xml : TXmlBuilder; name : string; elem : TFhirEncounterStatusHistory);
    procedure ComposeEncounterParticipant(xml : TXmlBuilder; name : string; elem : TFhirEncounterParticipant);
    procedure ComposeEncounterHospitalization(xml : TXmlBuilder; name : string; elem : TFhirEncounterHospitalization);
    procedure ComposeEncounterLocation(xml : TXmlBuilder; name : string; elem : TFhirEncounterLocation);
    procedure ComposeEncounter(xml : TXmlBuilder; name : string; elem : TFhirEncounter);
    procedure ComposeEnrollmentRequest(xml : TXmlBuilder; name : string; elem : TFhirEnrollmentRequest);
    procedure ComposeEnrollmentResponse(xml : TXmlBuilder; name : string; elem : TFhirEnrollmentResponse);
    procedure ComposeEpisodeOfCareStatusHistory(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCareStatusHistory);
    procedure ComposeEpisodeOfCareCareTeam(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCareCareTeam);
    procedure ComposeEpisodeOfCare(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCare);
    procedure ComposeExplanationOfBenefit(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefit);
    procedure ComposeFamilyMemberHistoryCondition(xml : TXmlBuilder; name : string; elem : TFhirFamilyMemberHistoryCondition);
    procedure ComposeFamilyMemberHistory(xml : TXmlBuilder; name : string; elem : TFhirFamilyMemberHistory);
    procedure ComposeFlag(xml : TXmlBuilder; name : string; elem : TFhirFlag);
    procedure ComposeGoalOutcome(xml : TXmlBuilder; name : string; elem : TFhirGoalOutcome);
    procedure ComposeGoal(xml : TXmlBuilder; name : string; elem : TFhirGoal);
    procedure ComposeGroupCharacteristic(xml : TXmlBuilder; name : string; elem : TFhirGroupCharacteristic);
    procedure ComposeGroup(xml : TXmlBuilder; name : string; elem : TFhirGroup);
    procedure ComposeHealthcareServiceServiceType(xml : TXmlBuilder; name : string; elem : TFhirHealthcareServiceServiceType);
    procedure ComposeHealthcareServiceAvailableTime(xml : TXmlBuilder; name : string; elem : TFhirHealthcareServiceAvailableTime);
    procedure ComposeHealthcareServiceNotAvailable(xml : TXmlBuilder; name : string; elem : TFhirHealthcareServiceNotAvailable);
    procedure ComposeHealthcareService(xml : TXmlBuilder; name : string; elem : TFhirHealthcareService);
    procedure ComposeImagingObjectSelectionStudy(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudy);
    procedure ComposeImagingObjectSelectionStudySeries(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudySeries);
    procedure ComposeImagingObjectSelectionStudySeriesInstance(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstance);
    procedure ComposeImagingObjectSelectionStudySeriesInstanceFrames(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames);
    procedure ComposeImagingObjectSelection(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelection);
    procedure ComposeImagingStudySeries(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeries);
    procedure ComposeImagingStudySeriesInstance(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeriesInstance);
    procedure ComposeImagingStudy(xml : TXmlBuilder; name : string; elem : TFhirImagingStudy);
    procedure ComposeImmunizationExplanation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationExplanation);
    procedure ComposeImmunizationReaction(xml : TXmlBuilder; name : string; elem : TFhirImmunizationReaction);
    procedure ComposeImmunizationVaccinationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationVaccinationProtocol);
    procedure ComposeImmunization(xml : TXmlBuilder; name : string; elem : TFhirImmunization);
    procedure ComposeImmunizationRecommendationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendation);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
    procedure ComposeImmunizationRecommendationRecommendationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol);
    procedure ComposeImmunizationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendation);
    procedure ComposeListEntry(xml : TXmlBuilder; name : string; elem : TFhirListEntry);
    procedure ComposeList(xml : TXmlBuilder; name : string; elem : TFhirList);
    procedure ComposeLocationPosition(xml : TXmlBuilder; name : string; elem : TFhirLocationPosition);
    procedure ComposeLocation(xml : TXmlBuilder; name : string; elem : TFhirLocation);
    procedure ComposeMedia(xml : TXmlBuilder; name : string; elem : TFhirMedia);
    procedure ComposeMedicationProduct(xml : TXmlBuilder; name : string; elem : TFhirMedicationProduct);
    procedure ComposeMedicationProductIngredient(xml : TXmlBuilder; name : string; elem : TFhirMedicationProductIngredient);
    procedure ComposeMedicationProductBatch(xml : TXmlBuilder; name : string; elem : TFhirMedicationProductBatch);
    procedure ComposeMedicationPackage(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackage);
    procedure ComposeMedicationPackageContent(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackageContent);
    procedure ComposeMedication(xml : TXmlBuilder; name : string; elem : TFhirMedication);
    procedure ComposeMedicationAdministrationDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministrationDosage);
    procedure ComposeMedicationAdministration(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministration);
    procedure ComposeMedicationDispenseDosageInstruction(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseDosageInstruction);
    procedure ComposeMedicationDispenseSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseSubstitution);
    procedure ComposeMedicationDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispense);
    procedure ComposeMedicationPrescriptionDosageInstruction(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionDosageInstruction);
    procedure ComposeMedicationPrescriptionDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionDispense);
    procedure ComposeMedicationPrescriptionSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionSubstitution);
    procedure ComposeMedicationPrescription(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescription);
    procedure ComposeMedicationStatementDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatementDosage);
    procedure ComposeMedicationStatement(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatement);
    procedure ComposeMessageHeaderResponse(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderResponse);
    procedure ComposeMessageHeaderSource(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderSource);
    procedure ComposeMessageHeaderDestination(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderDestination);
    procedure ComposeMessageHeader(xml : TXmlBuilder; name : string; elem : TFhirMessageHeader);
    procedure ComposeNamingSystemUniqueId(xml : TXmlBuilder; name : string; elem : TFhirNamingSystemUniqueId);
    procedure ComposeNamingSystemContact(xml : TXmlBuilder; name : string; elem : TFhirNamingSystemContact);
    procedure ComposeNamingSystem(xml : TXmlBuilder; name : string; elem : TFhirNamingSystem);
    procedure ComposeNutritionOrderOralDiet(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDiet);
    procedure ComposeNutritionOrderOralDietNutrient(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDietNutrient);
    procedure ComposeNutritionOrderOralDietTexture(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDietTexture);
    procedure ComposeNutritionOrderSupplement(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderSupplement);
    procedure ComposeNutritionOrderEnteralFormula(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderEnteralFormula);
    procedure ComposeNutritionOrder(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrder);
    procedure ComposeObservationReferenceRange(xml : TXmlBuilder; name : string; elem : TFhirObservationReferenceRange);
    procedure ComposeObservationRelated(xml : TXmlBuilder; name : string; elem : TFhirObservationRelated);
    procedure ComposeObservation(xml : TXmlBuilder; name : string; elem : TFhirObservation);
    procedure ComposeOperationDefinitionContact(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionContact);
    procedure ComposeOperationDefinitionParameter(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionParameter);
    procedure ComposeOperationDefinitionParameterPart(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionParameterPart);
    procedure ComposeOperationDefinition(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinition);
    procedure ComposeOperationOutcomeIssue(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcomeIssue);
    procedure ComposeOperationOutcome(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcome);
    procedure ComposeOrderWhen(xml : TXmlBuilder; name : string; elem : TFhirOrderWhen);
    procedure ComposeOrder(xml : TXmlBuilder; name : string; elem : TFhirOrder);
    procedure ComposeOrderResponse(xml : TXmlBuilder; name : string; elem : TFhirOrderResponse);
    procedure ComposeOrganizationContact(xml : TXmlBuilder; name : string; elem : TFhirOrganizationContact);
    procedure ComposeOrganization(xml : TXmlBuilder; name : string; elem : TFhirOrganization);
    procedure ComposePatientContact(xml : TXmlBuilder; name : string; elem : TFhirPatientContact);
    procedure ComposePatientAnimal(xml : TXmlBuilder; name : string; elem : TFhirPatientAnimal);
    procedure ComposePatientCommunication(xml : TXmlBuilder; name : string; elem : TFhirPatientCommunication);
    procedure ComposePatientLink(xml : TXmlBuilder; name : string; elem : TFhirPatientLink);
    procedure ComposePatient(xml : TXmlBuilder; name : string; elem : TFhirPatient);
    procedure ComposePaymentNotice(xml : TXmlBuilder; name : string; elem : TFhirPaymentNotice);
    procedure ComposePaymentReconciliationDetail(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliationDetail);
    procedure ComposePaymentReconciliationNote(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliationNote);
    procedure ComposePaymentReconciliation(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliation);
    procedure ComposePersonLink(xml : TXmlBuilder; name : string; elem : TFhirPersonLink);
    procedure ComposePerson(xml : TXmlBuilder; name : string; elem : TFhirPerson);
    procedure ComposePractitionerPractitionerRole(xml : TXmlBuilder; name : string; elem : TFhirPractitionerPractitionerRole);
    procedure ComposePractitionerQualification(xml : TXmlBuilder; name : string; elem : TFhirPractitionerQualification);
    procedure ComposePractitioner(xml : TXmlBuilder; name : string; elem : TFhirPractitioner);
    procedure ComposeProcedureBodySite(xml : TXmlBuilder; name : string; elem : TFhirProcedureBodySite);
    procedure ComposeProcedurePerformer(xml : TXmlBuilder; name : string; elem : TFhirProcedurePerformer);
    procedure ComposeProcedureRelatedItem(xml : TXmlBuilder; name : string; elem : TFhirProcedureRelatedItem);
    procedure ComposeProcedureDevice(xml : TXmlBuilder; name : string; elem : TFhirProcedureDevice);
    procedure ComposeProcedure(xml : TXmlBuilder; name : string; elem : TFhirProcedure);
    procedure ComposeProcedureRequestBodySite(xml : TXmlBuilder; name : string; elem : TFhirProcedureRequestBodySite);
    procedure ComposeProcedureRequest(xml : TXmlBuilder; name : string; elem : TFhirProcedureRequest);
    procedure ComposeProcessRequestItem(xml : TXmlBuilder; name : string; elem : TFhirProcessRequestItem);
    procedure ComposeProcessRequest(xml : TXmlBuilder; name : string; elem : TFhirProcessRequest);
    procedure ComposeProcessResponseNotes(xml : TXmlBuilder; name : string; elem : TFhirProcessResponseNotes);
    procedure ComposeProcessResponse(xml : TXmlBuilder; name : string; elem : TFhirProcessResponse);
    procedure ComposeProvenanceAgent(xml : TXmlBuilder; name : string; elem : TFhirProvenanceAgent);
    procedure ComposeProvenanceEntity(xml : TXmlBuilder; name : string; elem : TFhirProvenanceEntity);
    procedure ComposeProvenance(xml : TXmlBuilder; name : string; elem : TFhirProvenance);
    procedure ComposeQuestionnaireGroup(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroup);
    procedure ComposeQuestionnaireGroupQuestion(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroupQuestion);
    procedure ComposeQuestionnaire(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaire);
    procedure ComposeQuestionnaireAnswersGroup(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireAnswersGroup);
    procedure ComposeQuestionnaireAnswersGroupQuestion(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireAnswersGroupQuestion);
    procedure ComposeQuestionnaireAnswersGroupQuestionAnswer(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireAnswersGroupQuestionAnswer);
    procedure ComposeQuestionnaireAnswers(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireAnswers);
    procedure ComposeReferralRequest(xml : TXmlBuilder; name : string; elem : TFhirReferralRequest);
    procedure ComposeRelatedPerson(xml : TXmlBuilder; name : string; elem : TFhirRelatedPerson);
    procedure ComposeRiskAssessmentPrediction(xml : TXmlBuilder; name : string; elem : TFhirRiskAssessmentPrediction);
    procedure ComposeRiskAssessment(xml : TXmlBuilder; name : string; elem : TFhirRiskAssessment);
    procedure ComposeSchedule(xml : TXmlBuilder; name : string; elem : TFhirSchedule);
    procedure ComposeSearchParameterContact(xml : TXmlBuilder; name : string; elem : TFhirSearchParameterContact);
    procedure ComposeSearchParameter(xml : TXmlBuilder; name : string; elem : TFhirSearchParameter);
    procedure ComposeSlot(xml : TXmlBuilder; name : string; elem : TFhirSlot);
    procedure ComposeSpecimenCollection(xml : TXmlBuilder; name : string; elem : TFhirSpecimenCollection);
    procedure ComposeSpecimenTreatment(xml : TXmlBuilder; name : string; elem : TFhirSpecimenTreatment);
    procedure ComposeSpecimenContainer(xml : TXmlBuilder; name : string; elem : TFhirSpecimenContainer);
    procedure ComposeSpecimen(xml : TXmlBuilder; name : string; elem : TFhirSpecimen);
    procedure ComposeStructureDefinitionContact(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionContact);
    procedure ComposeStructureDefinitionMapping(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionMapping);
    procedure ComposeStructureDefinitionSnapshot(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionSnapshot);
    procedure ComposeStructureDefinitionDifferential(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionDifferential);
    procedure ComposeStructureDefinition(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinition);
    procedure ComposeSubscriptionChannel(xml : TXmlBuilder; name : string; elem : TFhirSubscriptionChannel);
    procedure ComposeSubscription(xml : TXmlBuilder; name : string; elem : TFhirSubscription);
    procedure ComposeSubstanceInstance(xml : TXmlBuilder; name : string; elem : TFhirSubstanceInstance);
    procedure ComposeSubstanceIngredient(xml : TXmlBuilder; name : string; elem : TFhirSubstanceIngredient);
    procedure ComposeSubstance(xml : TXmlBuilder; name : string; elem : TFhirSubstance);
    procedure ComposeSupplyDispense(xml : TXmlBuilder; name : string; elem : TFhirSupplyDispense);
    procedure ComposeSupply(xml : TXmlBuilder; name : string; elem : TFhirSupply);
    procedure ComposeSupplyDelivery(xml : TXmlBuilder; name : string; elem : TFhirSupplyDelivery);
    procedure ComposeSupplyRequest(xml : TXmlBuilder; name : string; elem : TFhirSupplyRequest);
    procedure ComposeValueSetContact(xml : TXmlBuilder; name : string; elem : TFhirValueSetContact);
    procedure ComposeValueSetDefine(xml : TXmlBuilder; name : string; elem : TFhirValueSetDefine);
    procedure ComposeValueSetDefineConcept(xml : TXmlBuilder; name : string; elem : TFhirValueSetDefineConcept);
    procedure ComposeValueSetDefineConceptDesignation(xml : TXmlBuilder; name : string; elem : TFhirValueSetDefineConceptDesignation);
    procedure ComposeValueSetCompose(xml : TXmlBuilder; name : string; elem : TFhirValueSetCompose);
    procedure ComposeValueSetComposeInclude(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeInclude);
    procedure ComposeValueSetComposeIncludeConcept(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeConcept);
    procedure ComposeValueSetComposeIncludeFilter(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeFilter);
    procedure ComposeValueSetExpansion(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansion);
    procedure ComposeValueSetExpansionParameter(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansionParameter);
    procedure ComposeValueSetExpansionContains(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansionContains);
    procedure ComposeValueSet(xml : TXmlBuilder; name : string; elem : TFhirValueSet);
    procedure ComposeVisionPrescriptionDispense(xml : TXmlBuilder; name : string; elem : TFhirVisionPrescriptionDispense);
    procedure ComposeVisionPrescription(xml : TXmlBuilder; name : string; elem : TFhirVisionPrescription);
    procedure ComposeResource(xml : TXmlBuilder; resource : TFhirResource; links : TFhirBundleLinkList); override;
  end;

  TFHIRJsonParser = class (TFHIRJsonParserBase)
  protected
    function ParseElement(jsn : TJsonObject) : TFhirElement; overload;
    procedure ParseElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBackboneElement(jsn : TJsonObject) : TFhirBackboneElement; overload;
    procedure ParseBackboneElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}

    procedure ParseElementProperties(jsn : TJsonObject; element : TFhirElement);
    procedure ParseBackboneElementProperties(jsn : TJsonObject; element : TFhirBackboneElement);
    procedure ParseEnum(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList; Const aNames : Array Of String); overload;
    function ParseEnum(value : string; jsn : TJsonObject; Const aNames : Array Of String) : TFHIREnum; overload;
    procedure ParseInteger(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseInteger(value : string; jsn : TJsonObject) : TFHIRInteger; overload;
    procedure ParseDateTime(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDateTime(value : string; jsn : TJsonObject) : TFHIRDateTime; overload;
    procedure ParseDate(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDate(value : string; jsn : TJsonObject) : TFHIRDate; overload;
    procedure ParseDecimal(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDecimal(value : string; jsn : TJsonObject) : TFHIRDecimal; overload;
    procedure ParseUri(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseUri(value : string; jsn : TJsonObject) : TFHIRUri; overload;
    procedure ParseBase64Binary(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseBase64Binary(value : string; jsn : TJsonObject) : TFHIRBase64Binary; overload;
    procedure ParseTime(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseTime(value : string; jsn : TJsonObject) : TFHIRTime; overload;
    procedure ParseString(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseString(value : string; jsn : TJsonObject) : TFHIRString; overload;
    procedure ParseBoolean(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseBoolean(value : string; jsn : TJsonObject) : TFHIRBoolean; overload;
    procedure ParseInstant(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseInstant(value : string; jsn : TJsonObject) : TFHIRInstant; overload;
    procedure ParseUnsignedInt(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseUnsignedInt(value : string; jsn : TJsonObject) : TFHIRUnsignedInt; overload;
    procedure ParseCode(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseCode(value : string; jsn : TJsonObject) : TFHIRCode; overload;
    procedure ParseId(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseId(value : string; jsn : TJsonObject) : TFHIRId; overload;
    procedure ParseOid(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseOid(value : string; jsn : TJsonObject) : TFHIROid; overload;
    procedure ParsePositiveInt(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParsePositiveInt(value : string; jsn : TJsonObject) : TFHIRPositiveInt; overload;
    procedure ParseUuid(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseUuid(value : string; jsn : TJsonObject) : TFHIRUuid; overload;

    procedure ParseResourceProperties(jsn : TJsonObject; resource : TFhirResource);
    procedure ParseDomainResourceProperties(jsn : TJsonObject; resource : TFhirDomainResource);
    function ParseParametersParameter(jsn : TJsonObject) : TFhirParametersParameter; overload; {b\}
    procedure ParseParametersParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseParametersParameterPart(jsn : TJsonObject) : TFhirParametersParameterPart; overload; {b\}
    procedure ParseParametersParameterPart(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseParameters(jsn : TJsonObject) : TFhirParameters; overload;
    procedure ParseParameters(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}

    function ParseExtension(jsn : TJsonObject) : TFhirExtension; overload;
    procedure ParseExtension(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNarrative(jsn : TJsonObject) : TFhirNarrative; overload;
    procedure ParseNarrative(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePeriod(jsn : TJsonObject) : TFhirPeriod; overload;
    procedure ParsePeriod(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoding(jsn : TJsonObject) : TFhirCoding; overload;
    procedure ParseCoding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRange(jsn : TJsonObject) : TFhirRange; overload;
    procedure ParseRange(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuantity(jsn : TJsonObject) : TFhirQuantity; overload;
    procedure ParseQuantity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAttachment(jsn : TJsonObject) : TFhirAttachment; overload;
    procedure ParseAttachment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRatio(jsn : TJsonObject) : TFhirRatio; overload;
    procedure ParseRatio(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSampledData(jsn : TJsonObject) : TFhirSampledData; overload;
    procedure ParseSampledData(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseReference(jsn : TJsonObject) : TFhirReference; overload;
    procedure ParseReference(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCodeableConcept(jsn : TJsonObject) : TFhirCodeableConcept; overload;
    procedure ParseCodeableConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseIdentifier(jsn : TJsonObject) : TFhirIdentifier; overload;
    procedure ParseIdentifier(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSignature(jsn : TJsonObject) : TFhirSignature; overload;
    procedure ParseSignature(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionSlicing(jsn : TJsonObject) : TFhirElementDefinitionSlicing; overload; {b\}
    procedure ParseElementDefinitionSlicing(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionType(jsn : TJsonObject) : TFhirElementDefinitionType; overload; {b\}
    procedure ParseElementDefinitionType(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionConstraint(jsn : TJsonObject) : TFhirElementDefinitionConstraint; overload; {b\}
    procedure ParseElementDefinitionConstraint(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionBinding(jsn : TJsonObject) : TFhirElementDefinitionBinding; overload; {b\}
    procedure ParseElementDefinitionBinding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionMapping(jsn : TJsonObject) : TFhirElementDefinitionMapping; overload; {b\}
    procedure ParseElementDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinition(jsn : TJsonObject) : TFhirElementDefinition; overload;
    procedure ParseElementDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTimingRepeat(jsn : TJsonObject) : TFhirTimingRepeat; overload; {b\}
    procedure ParseTimingRepeat(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTiming(jsn : TJsonObject) : TFhirTiming; overload;
    procedure ParseTiming(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAddress(jsn : TJsonObject) : TFhirAddress; overload;
    procedure ParseAddress(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHumanName(jsn : TJsonObject) : TFhirHumanName; overload;
    procedure ParseHumanName(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMeta(jsn : TJsonObject) : TFhirMeta; overload;
    procedure ParseMeta(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContactPoint(jsn : TJsonObject) : TFhirContactPoint; overload;
    procedure ParseContactPoint(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAge(jsn : TJsonObject) : TFhirAge; overload;
    function ParseCount(jsn : TJsonObject) : TFhirCount; overload;
    function ParseMoney(jsn : TJsonObject) : TFhirMoney; overload;
    function ParseDistance(jsn : TJsonObject) : TFhirDistance; overload;
    function ParseDuration(jsn : TJsonObject) : TFhirDuration; overload;

    function ParseAllergyIntoleranceEvent(jsn : TJsonObject) : TFhirAllergyIntoleranceEvent; overload; {b\}
    procedure ParseAllergyIntoleranceEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAllergyIntolerance(jsn : TJsonObject) : TFhirAllergyIntolerance; overload;
    procedure ParseAllergyIntolerance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAppointmentParticipant(jsn : TJsonObject) : TFhirAppointmentParticipant; overload; {b\}
    procedure ParseAppointmentParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAppointment(jsn : TJsonObject) : TFhirAppointment; overload;
    procedure ParseAppointment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAppointmentResponse(jsn : TJsonObject) : TFhirAppointmentResponse; overload;
    procedure ParseAppointmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventEvent(jsn : TJsonObject) : TFhirAuditEventEvent; overload; {b\}
    procedure ParseAuditEventEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventParticipant(jsn : TJsonObject) : TFhirAuditEventParticipant; overload; {b\}
    procedure ParseAuditEventParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventParticipantNetwork(jsn : TJsonObject) : TFhirAuditEventParticipantNetwork; overload; {b\}
    procedure ParseAuditEventParticipantNetwork(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventSource(jsn : TJsonObject) : TFhirAuditEventSource; overload; {b\}
    procedure ParseAuditEventSource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventObject(jsn : TJsonObject) : TFhirAuditEventObject; overload; {b\}
    procedure ParseAuditEventObject(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventObjectDetail(jsn : TJsonObject) : TFhirAuditEventObjectDetail; overload; {b\}
    procedure ParseAuditEventObjectDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEvent(jsn : TJsonObject) : TFhirAuditEvent; overload;
    procedure ParseAuditEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBasic(jsn : TJsonObject) : TFhirBasic; overload;
    procedure ParseBasic(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBinary(jsn : TJsonObject) : TFhirBinary; overload;
    procedure ParseBinary(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBodySite(jsn : TJsonObject) : TFhirBodySite; overload;
    procedure ParseBodySite(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleLink(jsn : TJsonObject) : TFhirBundleLink; overload; {b\}
    procedure ParseBundleLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleEntry(jsn : TJsonObject) : TFhirBundleEntry; overload; {b\}
    procedure ParseBundleEntry(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleEntrySearch(jsn : TJsonObject) : TFhirBundleEntrySearch; overload; {b\}
    procedure ParseBundleEntrySearch(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleEntryTransaction(jsn : TJsonObject) : TFhirBundleEntryTransaction; overload; {b\}
    procedure ParseBundleEntryTransaction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleEntryTransactionResponse(jsn : TJsonObject) : TFhirBundleEntryTransactionResponse; overload; {b\}
    procedure ParseBundleEntryTransactionResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundle(jsn : TJsonObject) : TFhirBundle; overload;
    procedure ParseBundle(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanParticipant(jsn : TJsonObject) : TFhirCarePlanParticipant; overload; {b\}
    procedure ParseCarePlanParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanActivity(jsn : TJsonObject) : TFhirCarePlanActivity; overload; {b\}
    procedure ParseCarePlanActivity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanActivityDetail(jsn : TJsonObject) : TFhirCarePlanActivityDetail; overload; {b\}
    procedure ParseCarePlanActivityDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlan(jsn : TJsonObject) : TFhirCarePlan; overload;
    procedure ParseCarePlan(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimPayee(jsn : TJsonObject) : TFhirClaimPayee; overload; {b\}
    procedure ParseClaimPayee(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimDiagnosis(jsn : TJsonObject) : TFhirClaimDiagnosis; overload; {b\}
    procedure ParseClaimDiagnosis(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimCoverage(jsn : TJsonObject) : TFhirClaimCoverage; overload; {b\}
    procedure ParseClaimCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimItem(jsn : TJsonObject) : TFhirClaimItem; overload; {b\}
    procedure ParseClaimItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimItemDetail(jsn : TJsonObject) : TFhirClaimItemDetail; overload; {b\}
    procedure ParseClaimItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimItemDetailSubDetail; overload; {b\}
    procedure ParseClaimItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimItemProsthesis(jsn : TJsonObject) : TFhirClaimItemProsthesis; overload; {b\}
    procedure ParseClaimItemProsthesis(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimMissingTeeth(jsn : TJsonObject) : TFhirClaimMissingTeeth; overload; {b\}
    procedure ParseClaimMissingTeeth(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaim(jsn : TJsonObject) : TFhirClaim; overload;
    procedure ParseClaim(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItem(jsn : TJsonObject) : TFhirClaimResponseItem; overload; {b\}
    procedure ParseClaimResponseItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemAdjudication; overload; {b\}
    procedure ParseClaimResponseItemAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemDetail(jsn : TJsonObject) : TFhirClaimResponseItemDetail; overload; {b\}
    procedure ParseClaimResponseItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemDetailAdjudication; overload; {b\}
    procedure ParseClaimResponseItemDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimResponseItemDetailSubDetail; overload; {b\}
    procedure ParseClaimResponseItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemDetailSubDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemDetailSubDetailAdjudication; overload; {b\}
    procedure ParseClaimResponseItemDetailSubDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseAddItem(jsn : TJsonObject) : TFhirClaimResponseAddItem; overload; {b\}
    procedure ParseClaimResponseAddItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseAddItemAdjudication(jsn : TJsonObject) : TFhirClaimResponseAddItemAdjudication; overload; {b\}
    procedure ParseClaimResponseAddItemAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseAddItemDetail(jsn : TJsonObject) : TFhirClaimResponseAddItemDetail; overload; {b\}
    procedure ParseClaimResponseAddItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseAddItemDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseAddItemDetailAdjudication; overload; {b\}
    procedure ParseClaimResponseAddItemDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseError(jsn : TJsonObject) : TFhirClaimResponseError; overload; {b\}
    procedure ParseClaimResponseError(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseNote(jsn : TJsonObject) : TFhirClaimResponseNote; overload; {b\}
    procedure ParseClaimResponseNote(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseCoverage(jsn : TJsonObject) : TFhirClaimResponseCoverage; overload; {b\}
    procedure ParseClaimResponseCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponse(jsn : TJsonObject) : TFhirClaimResponse; overload;
    procedure ParseClaimResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClinicalImpressionInvestigations(jsn : TJsonObject) : TFhirClinicalImpressionInvestigations; overload; {b\}
    procedure ParseClinicalImpressionInvestigations(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClinicalImpressionFinding(jsn : TJsonObject) : TFhirClinicalImpressionFinding; overload; {b\}
    procedure ParseClinicalImpressionFinding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClinicalImpressionRuledOut(jsn : TJsonObject) : TFhirClinicalImpressionRuledOut; overload; {b\}
    procedure ParseClinicalImpressionRuledOut(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClinicalImpression(jsn : TJsonObject) : TFhirClinicalImpression; overload;
    procedure ParseClinicalImpression(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCommunicationPayload(jsn : TJsonObject) : TFhirCommunicationPayload; overload; {b\}
    procedure ParseCommunicationPayload(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCommunication(jsn : TJsonObject) : TFhirCommunication; overload;
    procedure ParseCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCommunicationRequestPayload(jsn : TJsonObject) : TFhirCommunicationRequestPayload; overload; {b\}
    procedure ParseCommunicationRequestPayload(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCommunicationRequest(jsn : TJsonObject) : TFhirCommunicationRequest; overload;
    procedure ParseCommunicationRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompositionAttester(jsn : TJsonObject) : TFhirCompositionAttester; overload; {b\}
    procedure ParseCompositionAttester(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompositionEvent(jsn : TJsonObject) : TFhirCompositionEvent; overload; {b\}
    procedure ParseCompositionEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompositionSection(jsn : TJsonObject) : TFhirCompositionSection; overload; {b\}
    procedure ParseCompositionSection(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseComposition(jsn : TJsonObject) : TFhirComposition; overload;
    procedure ParseComposition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapContact(jsn : TJsonObject) : TFhirConceptMapContact; overload; {b\}
    procedure ParseConceptMapContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapElement(jsn : TJsonObject) : TFhirConceptMapElement; overload; {b\}
    procedure ParseConceptMapElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapElementDependsOn(jsn : TJsonObject) : TFhirConceptMapElementDependsOn; overload; {b\}
    procedure ParseConceptMapElementDependsOn(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapElementMap(jsn : TJsonObject) : TFhirConceptMapElementMap; overload; {b\}
    procedure ParseConceptMapElementMap(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMap(jsn : TJsonObject) : TFhirConceptMap; overload;
    procedure ParseConceptMap(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConditionStage(jsn : TJsonObject) : TFhirConditionStage; overload; {b\}
    procedure ParseConditionStage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConditionEvidence(jsn : TJsonObject) : TFhirConditionEvidence; overload; {b\}
    procedure ParseConditionEvidence(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConditionLocation(jsn : TJsonObject) : TFhirConditionLocation; overload; {b\}
    procedure ParseConditionLocation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConditionDueTo(jsn : TJsonObject) : TFhirConditionDueTo; overload; {b\}
    procedure ParseConditionDueTo(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConditionOccurredFollowing(jsn : TJsonObject) : TFhirConditionOccurredFollowing; overload; {b\}
    procedure ParseConditionOccurredFollowing(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCondition(jsn : TJsonObject) : TFhirCondition; overload;
    procedure ParseCondition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceContact(jsn : TJsonObject) : TFhirConformanceContact; overload; {b\}
    procedure ParseConformanceContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceSoftware(jsn : TJsonObject) : TFhirConformanceSoftware; overload; {b\}
    procedure ParseConformanceSoftware(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceImplementation(jsn : TJsonObject) : TFhirConformanceImplementation; overload; {b\}
    procedure ParseConformanceImplementation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRest(jsn : TJsonObject) : TFhirConformanceRest; overload; {b\}
    procedure ParseConformanceRest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestSecurity(jsn : TJsonObject) : TFhirConformanceRestSecurity; overload; {b\}
    procedure ParseConformanceRestSecurity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestSecurityCertificate(jsn : TJsonObject) : TFhirConformanceRestSecurityCertificate; overload; {b\}
    procedure ParseConformanceRestSecurityCertificate(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestResource(jsn : TJsonObject) : TFhirConformanceRestResource; overload; {b\}
    procedure ParseConformanceRestResource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestResourceInteraction(jsn : TJsonObject) : TFhirConformanceRestResourceInteraction; overload; {b\}
    procedure ParseConformanceRestResourceInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestResourceSearchParam(jsn : TJsonObject) : TFhirConformanceRestResourceSearchParam; overload; {b\}
    procedure ParseConformanceRestResourceSearchParam(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestInteraction(jsn : TJsonObject) : TFhirConformanceRestInteraction; overload; {b\}
    procedure ParseConformanceRestInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestOperation(jsn : TJsonObject) : TFhirConformanceRestOperation; overload; {b\}
    procedure ParseConformanceRestOperation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceMessaging(jsn : TJsonObject) : TFhirConformanceMessaging; overload; {b\}
    procedure ParseConformanceMessaging(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceMessagingEvent(jsn : TJsonObject) : TFhirConformanceMessagingEvent; overload; {b\}
    procedure ParseConformanceMessagingEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceDocument(jsn : TJsonObject) : TFhirConformanceDocument; overload; {b\}
    procedure ParseConformanceDocument(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformance(jsn : TJsonObject) : TFhirConformance; overload;
    procedure ParseConformance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractActor(jsn : TJsonObject) : TFhirContractActor; overload; {b\}
    procedure ParseContractActor(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractValuedItem(jsn : TJsonObject) : TFhirContractValuedItem; overload; {b\}
    procedure ParseContractValuedItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractSigner(jsn : TJsonObject) : TFhirContractSigner; overload; {b\}
    procedure ParseContractSigner(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTerm(jsn : TJsonObject) : TFhirContractTerm; overload; {b\}
    procedure ParseContractTerm(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTermActor(jsn : TJsonObject) : TFhirContractTermActor; overload; {b\}
    procedure ParseContractTermActor(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTermValuedItem(jsn : TJsonObject) : TFhirContractTermValuedItem; overload; {b\}
    procedure ParseContractTermValuedItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractFriendly(jsn : TJsonObject) : TFhirContractFriendly; overload; {b\}
    procedure ParseContractFriendly(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractLegal(jsn : TJsonObject) : TFhirContractLegal; overload; {b\}
    procedure ParseContractLegal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractRule(jsn : TJsonObject) : TFhirContractRule; overload; {b\}
    procedure ParseContractRule(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContract(jsn : TJsonObject) : TFhirContract; overload;
    procedure ParseContract(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContraindicationMitigation(jsn : TJsonObject) : TFhirContraindicationMitigation; overload; {b\}
    procedure ParseContraindicationMitigation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContraindication(jsn : TJsonObject) : TFhirContraindication; overload;
    procedure ParseContraindication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoverage(jsn : TJsonObject) : TFhirCoverage; overload;
    procedure ParseCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDataElementContact(jsn : TJsonObject) : TFhirDataElementContact; overload; {b\}
    procedure ParseDataElementContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDataElementMapping(jsn : TJsonObject) : TFhirDataElementMapping; overload; {b\}
    procedure ParseDataElementMapping(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDataElement(jsn : TJsonObject) : TFhirDataElement; overload;
    procedure ParseDataElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDevice(jsn : TJsonObject) : TFhirDevice; overload;
    procedure ParseDevice(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceComponentProductionSpecification(jsn : TJsonObject) : TFhirDeviceComponentProductionSpecification; overload; {b\}
    procedure ParseDeviceComponentProductionSpecification(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceComponent(jsn : TJsonObject) : TFhirDeviceComponent; overload;
    procedure ParseDeviceComponent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceMetricCalibration(jsn : TJsonObject) : TFhirDeviceMetricCalibration; overload; {b\}
    procedure ParseDeviceMetricCalibration(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceMetric(jsn : TJsonObject) : TFhirDeviceMetric; overload;
    procedure ParseDeviceMetric(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceUseRequest(jsn : TJsonObject) : TFhirDeviceUseRequest; overload;
    procedure ParseDeviceUseRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceUseStatement(jsn : TJsonObject) : TFhirDeviceUseStatement; overload;
    procedure ParseDeviceUseStatement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticOrderEvent(jsn : TJsonObject) : TFhirDiagnosticOrderEvent; overload; {b\}
    procedure ParseDiagnosticOrderEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticOrderItem(jsn : TJsonObject) : TFhirDiagnosticOrderItem; overload; {b\}
    procedure ParseDiagnosticOrderItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticOrder(jsn : TJsonObject) : TFhirDiagnosticOrder; overload;
    procedure ParseDiagnosticOrder(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticReportImage(jsn : TJsonObject) : TFhirDiagnosticReportImage; overload; {b\}
    procedure ParseDiagnosticReportImage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticReport(jsn : TJsonObject) : TFhirDiagnosticReport; overload;
    procedure ParseDiagnosticReport(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentManifestContent(jsn : TJsonObject) : TFhirDocumentManifestContent; overload; {b\}
    procedure ParseDocumentManifestContent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentManifestRelated(jsn : TJsonObject) : TFhirDocumentManifestRelated; overload; {b\}
    procedure ParseDocumentManifestRelated(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentManifest(jsn : TJsonObject) : TFhirDocumentManifest; overload;
    procedure ParseDocumentManifest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceRelatesTo(jsn : TJsonObject) : TFhirDocumentReferenceRelatesTo; overload; {b\}
    procedure ParseDocumentReferenceRelatesTo(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceContext(jsn : TJsonObject) : TFhirDocumentReferenceContext; overload; {b\}
    procedure ParseDocumentReferenceContext(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceContextRelated(jsn : TJsonObject) : TFhirDocumentReferenceContextRelated; overload; {b\}
    procedure ParseDocumentReferenceContextRelated(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReference(jsn : TJsonObject) : TFhirDocumentReference; overload;
    procedure ParseDocumentReference(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEligibilityRequest(jsn : TJsonObject) : TFhirEligibilityRequest; overload;
    procedure ParseEligibilityRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEligibilityResponse(jsn : TJsonObject) : TFhirEligibilityResponse; overload;
    procedure ParseEligibilityResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterStatusHistory(jsn : TJsonObject) : TFhirEncounterStatusHistory; overload; {b\}
    procedure ParseEncounterStatusHistory(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterParticipant(jsn : TJsonObject) : TFhirEncounterParticipant; overload; {b\}
    procedure ParseEncounterParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterHospitalization(jsn : TJsonObject) : TFhirEncounterHospitalization; overload; {b\}
    procedure ParseEncounterHospitalization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterLocation(jsn : TJsonObject) : TFhirEncounterLocation; overload; {b\}
    procedure ParseEncounterLocation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounter(jsn : TJsonObject) : TFhirEncounter; overload;
    procedure ParseEncounter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEnrollmentRequest(jsn : TJsonObject) : TFhirEnrollmentRequest; overload;
    procedure ParseEnrollmentRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEnrollmentResponse(jsn : TJsonObject) : TFhirEnrollmentResponse; overload;
    procedure ParseEnrollmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEpisodeOfCareStatusHistory(jsn : TJsonObject) : TFhirEpisodeOfCareStatusHistory; overload; {b\}
    procedure ParseEpisodeOfCareStatusHistory(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEpisodeOfCareCareTeam(jsn : TJsonObject) : TFhirEpisodeOfCareCareTeam; overload; {b\}
    procedure ParseEpisodeOfCareCareTeam(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEpisodeOfCare(jsn : TJsonObject) : TFhirEpisodeOfCare; overload;
    procedure ParseEpisodeOfCare(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefit(jsn : TJsonObject) : TFhirExplanationOfBenefit; overload;
    procedure ParseExplanationOfBenefit(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseFamilyMemberHistoryCondition(jsn : TJsonObject) : TFhirFamilyMemberHistoryCondition; overload; {b\}
    procedure ParseFamilyMemberHistoryCondition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseFamilyMemberHistory(jsn : TJsonObject) : TFhirFamilyMemberHistory; overload;
    procedure ParseFamilyMemberHistory(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseFlag(jsn : TJsonObject) : TFhirFlag; overload;
    procedure ParseFlag(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGoalOutcome(jsn : TJsonObject) : TFhirGoalOutcome; overload; {b\}
    procedure ParseGoalOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGoal(jsn : TJsonObject) : TFhirGoal; overload;
    procedure ParseGoal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGroupCharacteristic(jsn : TJsonObject) : TFhirGroupCharacteristic; overload; {b\}
    procedure ParseGroupCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGroup(jsn : TJsonObject) : TFhirGroup; overload;
    procedure ParseGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHealthcareServiceServiceType(jsn : TJsonObject) : TFhirHealthcareServiceServiceType; overload; {b\}
    procedure ParseHealthcareServiceServiceType(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHealthcareServiceAvailableTime(jsn : TJsonObject) : TFhirHealthcareServiceAvailableTime; overload; {b\}
    procedure ParseHealthcareServiceAvailableTime(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHealthcareServiceNotAvailable(jsn : TJsonObject) : TFhirHealthcareServiceNotAvailable; overload; {b\}
    procedure ParseHealthcareServiceNotAvailable(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHealthcareService(jsn : TJsonObject) : TFhirHealthcareService; overload;
    procedure ParseHealthcareService(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingObjectSelectionStudy(jsn : TJsonObject) : TFhirImagingObjectSelectionStudy; overload; {b\}
    procedure ParseImagingObjectSelectionStudy(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingObjectSelectionStudySeries(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeries; overload; {b\}
    procedure ParseImagingObjectSelectionStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingObjectSelectionStudySeriesInstance(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeriesInstance; overload; {b\}
    procedure ParseImagingObjectSelectionStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingObjectSelectionStudySeriesInstanceFrames(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeriesInstanceFrames; overload; {b\}
    procedure ParseImagingObjectSelectionStudySeriesInstanceFrames(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingObjectSelection(jsn : TJsonObject) : TFhirImagingObjectSelection; overload;
    procedure ParseImagingObjectSelection(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingStudySeries(jsn : TJsonObject) : TFhirImagingStudySeries; overload; {b\}
    procedure ParseImagingStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingStudySeriesInstance(jsn : TJsonObject) : TFhirImagingStudySeriesInstance; overload; {b\}
    procedure ParseImagingStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingStudy(jsn : TJsonObject) : TFhirImagingStudy; overload;
    procedure ParseImagingStudy(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationExplanation(jsn : TJsonObject) : TFhirImmunizationExplanation; overload; {b\}
    procedure ParseImmunizationExplanation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationReaction(jsn : TJsonObject) : TFhirImmunizationReaction; overload; {b\}
    procedure ParseImmunizationReaction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationVaccinationProtocol(jsn : TJsonObject) : TFhirImmunizationVaccinationProtocol; overload; {b\}
    procedure ParseImmunizationVaccinationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunization(jsn : TJsonObject) : TFhirImmunization; overload;
    procedure ParseImmunization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendation; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationDateCriterion; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationProtocol; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendation; overload;
    procedure ParseImmunizationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseListEntry(jsn : TJsonObject) : TFhirListEntry; overload; {b\}
    procedure ParseListEntry(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseList(jsn : TJsonObject) : TFhirList; overload;
    procedure ParseList(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseLocationPosition(jsn : TJsonObject) : TFhirLocationPosition; overload; {b\}
    procedure ParseLocationPosition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseLocation(jsn : TJsonObject) : TFhirLocation; overload;
    procedure ParseLocation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedia(jsn : TJsonObject) : TFhirMedia; overload;
    procedure ParseMedia(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationProduct(jsn : TJsonObject) : TFhirMedicationProduct; overload; {b\}
    procedure ParseMedicationProduct(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationProductIngredient(jsn : TJsonObject) : TFhirMedicationProductIngredient; overload; {b\}
    procedure ParseMedicationProductIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationProductBatch(jsn : TJsonObject) : TFhirMedicationProductBatch; overload; {b\}
    procedure ParseMedicationProductBatch(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPackage(jsn : TJsonObject) : TFhirMedicationPackage; overload; {b\}
    procedure ParseMedicationPackage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPackageContent(jsn : TJsonObject) : TFhirMedicationPackageContent; overload; {b\}
    procedure ParseMedicationPackageContent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedication(jsn : TJsonObject) : TFhirMedication; overload;
    procedure ParseMedication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationAdministrationDosage(jsn : TJsonObject) : TFhirMedicationAdministrationDosage; overload; {b\}
    procedure ParseMedicationAdministrationDosage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationAdministration(jsn : TJsonObject) : TFhirMedicationAdministration; overload;
    procedure ParseMedicationAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispenseDosageInstruction(jsn : TJsonObject) : TFhirMedicationDispenseDosageInstruction; overload; {b\}
    procedure ParseMedicationDispenseDosageInstruction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispenseSubstitution(jsn : TJsonObject) : TFhirMedicationDispenseSubstitution; overload; {b\}
    procedure ParseMedicationDispenseSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispense(jsn : TJsonObject) : TFhirMedicationDispense; overload;
    procedure ParseMedicationDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPrescriptionDosageInstruction(jsn : TJsonObject) : TFhirMedicationPrescriptionDosageInstruction; overload; {b\}
    procedure ParseMedicationPrescriptionDosageInstruction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPrescriptionDispense(jsn : TJsonObject) : TFhirMedicationPrescriptionDispense; overload; {b\}
    procedure ParseMedicationPrescriptionDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPrescriptionSubstitution(jsn : TJsonObject) : TFhirMedicationPrescriptionSubstitution; overload; {b\}
    procedure ParseMedicationPrescriptionSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPrescription(jsn : TJsonObject) : TFhirMedicationPrescription; overload;
    procedure ParseMedicationPrescription(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationStatementDosage(jsn : TJsonObject) : TFhirMedicationStatementDosage; overload; {b\}
    procedure ParseMedicationStatementDosage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationStatement(jsn : TJsonObject) : TFhirMedicationStatement; overload;
    procedure ParseMedicationStatement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeaderResponse(jsn : TJsonObject) : TFhirMessageHeaderResponse; overload; {b\}
    procedure ParseMessageHeaderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeaderSource(jsn : TJsonObject) : TFhirMessageHeaderSource; overload; {b\}
    procedure ParseMessageHeaderSource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeaderDestination(jsn : TJsonObject) : TFhirMessageHeaderDestination; overload; {b\}
    procedure ParseMessageHeaderDestination(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeader(jsn : TJsonObject) : TFhirMessageHeader; overload;
    procedure ParseMessageHeader(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNamingSystemUniqueId(jsn : TJsonObject) : TFhirNamingSystemUniqueId; overload; {b\}
    procedure ParseNamingSystemUniqueId(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNamingSystemContact(jsn : TJsonObject) : TFhirNamingSystemContact; overload; {b\}
    procedure ParseNamingSystemContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNamingSystem(jsn : TJsonObject) : TFhirNamingSystem; overload;
    procedure ParseNamingSystem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderOralDiet(jsn : TJsonObject) : TFhirNutritionOrderOralDiet; overload; {b\}
    procedure ParseNutritionOrderOralDiet(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderOralDietNutrient(jsn : TJsonObject) : TFhirNutritionOrderOralDietNutrient; overload; {b\}
    procedure ParseNutritionOrderOralDietNutrient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderOralDietTexture(jsn : TJsonObject) : TFhirNutritionOrderOralDietTexture; overload; {b\}
    procedure ParseNutritionOrderOralDietTexture(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderSupplement(jsn : TJsonObject) : TFhirNutritionOrderSupplement; overload; {b\}
    procedure ParseNutritionOrderSupplement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderEnteralFormula(jsn : TJsonObject) : TFhirNutritionOrderEnteralFormula; overload; {b\}
    procedure ParseNutritionOrderEnteralFormula(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrder(jsn : TJsonObject) : TFhirNutritionOrder; overload;
    procedure ParseNutritionOrder(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservationReferenceRange(jsn : TJsonObject) : TFhirObservationReferenceRange; overload; {b\}
    procedure ParseObservationReferenceRange(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservationRelated(jsn : TJsonObject) : TFhirObservationRelated; overload; {b\}
    procedure ParseObservationRelated(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservation(jsn : TJsonObject) : TFhirObservation; overload;
    procedure ParseObservation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationDefinitionContact(jsn : TJsonObject) : TFhirOperationDefinitionContact; overload; {b\}
    procedure ParseOperationDefinitionContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationDefinitionParameter(jsn : TJsonObject) : TFhirOperationDefinitionParameter; overload; {b\}
    procedure ParseOperationDefinitionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationDefinitionParameterPart(jsn : TJsonObject) : TFhirOperationDefinitionParameterPart; overload; {b\}
    procedure ParseOperationDefinitionParameterPart(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationDefinition(jsn : TJsonObject) : TFhirOperationDefinition; overload;
    procedure ParseOperationDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationOutcomeIssue(jsn : TJsonObject) : TFhirOperationOutcomeIssue; overload; {b\}
    procedure ParseOperationOutcomeIssue(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationOutcome(jsn : TJsonObject) : TFhirOperationOutcome; overload;
    procedure ParseOperationOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrderWhen(jsn : TJsonObject) : TFhirOrderWhen; overload; {b\}
    procedure ParseOrderWhen(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrder(jsn : TJsonObject) : TFhirOrder; overload;
    procedure ParseOrder(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrderResponse(jsn : TJsonObject) : TFhirOrderResponse; overload;
    procedure ParseOrderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrganizationContact(jsn : TJsonObject) : TFhirOrganizationContact; overload; {b\}
    procedure ParseOrganizationContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrganization(jsn : TJsonObject) : TFhirOrganization; overload;
    procedure ParseOrganization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientContact(jsn : TJsonObject) : TFhirPatientContact; overload; {b\}
    procedure ParsePatientContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientAnimal(jsn : TJsonObject) : TFhirPatientAnimal; overload; {b\}
    procedure ParsePatientAnimal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientCommunication(jsn : TJsonObject) : TFhirPatientCommunication; overload; {b\}
    procedure ParsePatientCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientLink(jsn : TJsonObject) : TFhirPatientLink; overload; {b\}
    procedure ParsePatientLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatient(jsn : TJsonObject) : TFhirPatient; overload;
    procedure ParsePatient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePaymentNotice(jsn : TJsonObject) : TFhirPaymentNotice; overload;
    procedure ParsePaymentNotice(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePaymentReconciliationDetail(jsn : TJsonObject) : TFhirPaymentReconciliationDetail; overload; {b\}
    procedure ParsePaymentReconciliationDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePaymentReconciliationNote(jsn : TJsonObject) : TFhirPaymentReconciliationNote; overload; {b\}
    procedure ParsePaymentReconciliationNote(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePaymentReconciliation(jsn : TJsonObject) : TFhirPaymentReconciliation; overload;
    procedure ParsePaymentReconciliation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePersonLink(jsn : TJsonObject) : TFhirPersonLink; overload; {b\}
    procedure ParsePersonLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePerson(jsn : TJsonObject) : TFhirPerson; overload;
    procedure ParsePerson(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePractitionerPractitionerRole(jsn : TJsonObject) : TFhirPractitionerPractitionerRole; overload; {b\}
    procedure ParsePractitionerPractitionerRole(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePractitionerQualification(jsn : TJsonObject) : TFhirPractitionerQualification; overload; {b\}
    procedure ParsePractitionerQualification(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePractitioner(jsn : TJsonObject) : TFhirPractitioner; overload;
    procedure ParsePractitioner(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedureBodySite(jsn : TJsonObject) : TFhirProcedureBodySite; overload; {b\}
    procedure ParseProcedureBodySite(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedurePerformer(jsn : TJsonObject) : TFhirProcedurePerformer; overload; {b\}
    procedure ParseProcedurePerformer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedureRelatedItem(jsn : TJsonObject) : TFhirProcedureRelatedItem; overload; {b\}
    procedure ParseProcedureRelatedItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedureDevice(jsn : TJsonObject) : TFhirProcedureDevice; overload; {b\}
    procedure ParseProcedureDevice(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedure(jsn : TJsonObject) : TFhirProcedure; overload;
    procedure ParseProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedureRequestBodySite(jsn : TJsonObject) : TFhirProcedureRequestBodySite; overload; {b\}
    procedure ParseProcedureRequestBodySite(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedureRequest(jsn : TJsonObject) : TFhirProcedureRequest; overload;
    procedure ParseProcedureRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcessRequestItem(jsn : TJsonObject) : TFhirProcessRequestItem; overload; {b\}
    procedure ParseProcessRequestItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcessRequest(jsn : TJsonObject) : TFhirProcessRequest; overload;
    procedure ParseProcessRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcessResponseNotes(jsn : TJsonObject) : TFhirProcessResponseNotes; overload; {b\}
    procedure ParseProcessResponseNotes(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcessResponse(jsn : TJsonObject) : TFhirProcessResponse; overload;
    procedure ParseProcessResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenanceAgent(jsn : TJsonObject) : TFhirProvenanceAgent; overload; {b\}
    procedure ParseProvenanceAgent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenanceEntity(jsn : TJsonObject) : TFhirProvenanceEntity; overload; {b\}
    procedure ParseProvenanceEntity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenance(jsn : TJsonObject) : TFhirProvenance; overload;
    procedure ParseProvenance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireGroup(jsn : TJsonObject) : TFhirQuestionnaireGroup; overload; {b\}
    procedure ParseQuestionnaireGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireGroupQuestion; overload; {b\}
    procedure ParseQuestionnaireGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaire(jsn : TJsonObject) : TFhirQuestionnaire; overload;
    procedure ParseQuestionnaire(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireAnswersGroup(jsn : TJsonObject) : TFhirQuestionnaireAnswersGroup; overload; {b\}
    procedure ParseQuestionnaireAnswersGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireAnswersGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireAnswersGroupQuestion; overload; {b\}
    procedure ParseQuestionnaireAnswersGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireAnswersGroupQuestionAnswer(jsn : TJsonObject) : TFhirQuestionnaireAnswersGroupQuestionAnswer; overload; {b\}
    procedure ParseQuestionnaireAnswersGroupQuestionAnswer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireAnswers(jsn : TJsonObject) : TFhirQuestionnaireAnswers; overload;
    procedure ParseQuestionnaireAnswers(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseReferralRequest(jsn : TJsonObject) : TFhirReferralRequest; overload;
    procedure ParseReferralRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRelatedPerson(jsn : TJsonObject) : TFhirRelatedPerson; overload;
    procedure ParseRelatedPerson(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRiskAssessmentPrediction(jsn : TJsonObject) : TFhirRiskAssessmentPrediction; overload; {b\}
    procedure ParseRiskAssessmentPrediction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRiskAssessment(jsn : TJsonObject) : TFhirRiskAssessment; overload;
    procedure ParseRiskAssessment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSchedule(jsn : TJsonObject) : TFhirSchedule; overload;
    procedure ParseSchedule(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSearchParameterContact(jsn : TJsonObject) : TFhirSearchParameterContact; overload; {b\}
    procedure ParseSearchParameterContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSearchParameter(jsn : TJsonObject) : TFhirSearchParameter; overload;
    procedure ParseSearchParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSlot(jsn : TJsonObject) : TFhirSlot; overload;
    procedure ParseSlot(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenCollection(jsn : TJsonObject) : TFhirSpecimenCollection; overload; {b\}
    procedure ParseSpecimenCollection(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenTreatment(jsn : TJsonObject) : TFhirSpecimenTreatment; overload; {b\}
    procedure ParseSpecimenTreatment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenContainer(jsn : TJsonObject) : TFhirSpecimenContainer; overload; {b\}
    procedure ParseSpecimenContainer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimen(jsn : TJsonObject) : TFhirSpecimen; overload;
    procedure ParseSpecimen(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinitionContact(jsn : TJsonObject) : TFhirStructureDefinitionContact; overload; {b\}
    procedure ParseStructureDefinitionContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinitionMapping(jsn : TJsonObject) : TFhirStructureDefinitionMapping; overload; {b\}
    procedure ParseStructureDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinitionSnapshot(jsn : TJsonObject) : TFhirStructureDefinitionSnapshot; overload; {b\}
    procedure ParseStructureDefinitionSnapshot(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinitionDifferential(jsn : TJsonObject) : TFhirStructureDefinitionDifferential; overload; {b\}
    procedure ParseStructureDefinitionDifferential(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinition(jsn : TJsonObject) : TFhirStructureDefinition; overload;
    procedure ParseStructureDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubscriptionChannel(jsn : TJsonObject) : TFhirSubscriptionChannel; overload; {b\}
    procedure ParseSubscriptionChannel(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubscription(jsn : TJsonObject) : TFhirSubscription; overload;
    procedure ParseSubscription(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceInstance(jsn : TJsonObject) : TFhirSubstanceInstance; overload; {b\}
    procedure ParseSubstanceInstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceIngredient(jsn : TJsonObject) : TFhirSubstanceIngredient; overload; {b\}
    procedure ParseSubstanceIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstance(jsn : TJsonObject) : TFhirSubstance; overload;
    procedure ParseSubstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSupplyDispense(jsn : TJsonObject) : TFhirSupplyDispense; overload; {b\}
    procedure ParseSupplyDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSupply(jsn : TJsonObject) : TFhirSupply; overload;
    procedure ParseSupply(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSupplyDelivery(jsn : TJsonObject) : TFhirSupplyDelivery; overload;
    procedure ParseSupplyDelivery(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSupplyRequest(jsn : TJsonObject) : TFhirSupplyRequest; overload;
    procedure ParseSupplyRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetContact(jsn : TJsonObject) : TFhirValueSetContact; overload; {b\}
    procedure ParseValueSetContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetDefine(jsn : TJsonObject) : TFhirValueSetDefine; overload; {b\}
    procedure ParseValueSetDefine(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetDefineConcept(jsn : TJsonObject) : TFhirValueSetDefineConcept; overload; {b\}
    procedure ParseValueSetDefineConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetDefineConceptDesignation(jsn : TJsonObject) : TFhirValueSetDefineConceptDesignation; overload; {b\}
    procedure ParseValueSetDefineConceptDesignation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetCompose(jsn : TJsonObject) : TFhirValueSetCompose; overload; {b\}
    procedure ParseValueSetCompose(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeInclude(jsn : TJsonObject) : TFhirValueSetComposeInclude; overload; {b\}
    procedure ParseValueSetComposeInclude(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeIncludeConcept(jsn : TJsonObject) : TFhirValueSetComposeIncludeConcept; overload; {b\}
    procedure ParseValueSetComposeIncludeConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeIncludeFilter(jsn : TJsonObject) : TFhirValueSetComposeIncludeFilter; overload; {b\}
    procedure ParseValueSetComposeIncludeFilter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetExpansion(jsn : TJsonObject) : TFhirValueSetExpansion; overload; {b\}
    procedure ParseValueSetExpansion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetExpansionParameter(jsn : TJsonObject) : TFhirValueSetExpansionParameter; overload; {b\}
    procedure ParseValueSetExpansionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetExpansionContains(jsn : TJsonObject) : TFhirValueSetExpansionContains; overload; {b\}
    procedure ParseValueSetExpansionContains(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSet(jsn : TJsonObject) : TFhirValueSet; overload;
    procedure ParseValueSet(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseVisionPrescriptionDispense(jsn : TJsonObject) : TFhirVisionPrescriptionDispense; overload; {b\}
    procedure ParseVisionPrescriptionDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseVisionPrescription(jsn : TJsonObject) : TFhirVisionPrescription; overload;
    procedure ParseVisionPrescription(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseResource(jsn : TJsonObject) : TFhirResource; override;
    function ParseDataType(jsn : TJsonObject; name : String; type_ : TFHIRTypeClass) : TFHIRType; override;
  public
    function ParseFragment(jsn : TJsonObject; type_ : String) : TFhirBase;  overload;
  end;

  TFHIRJsonComposer = class (TFHIRJsonComposerBase)
  protected
    procedure ComposeElement(json : TJSONWriter; name : string; elem : TFhirElement; noObj : boolean = false);
    procedure ComposeBackboneElement(json : TJSONWriter; name : string; elem : TFhirBackboneElement; noObj : boolean = false);

    Procedure ComposeElementProperties(json : TJSONWriter; elem : TFhirElement);
    Procedure ComposeBackboneElementProperties(json : TJSONWriter; elem : TFhirBackboneElement);
    Procedure ComposeEnumValue(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
    Procedure ComposeEnumProps(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
    Procedure ComposeIntegerValue(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
    Procedure ComposeIntegerProps(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
    Procedure ComposeDateTimeValue(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
    Procedure ComposeDateTimeProps(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
    Procedure ComposeDateValue(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
    Procedure ComposeDateProps(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
    Procedure ComposeDecimalValue(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
    Procedure ComposeDecimalProps(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
    Procedure ComposeUriValue(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
    Procedure ComposeUriProps(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
    Procedure ComposeBase64BinaryValue(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
    Procedure ComposeBase64BinaryProps(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
    Procedure ComposeTimeValue(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
    Procedure ComposeTimeProps(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
    Procedure ComposeStringValue(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
    Procedure ComposeStringProps(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
    Procedure ComposeBooleanValue(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
    Procedure ComposeBooleanProps(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
    Procedure ComposeInstantValue(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
    Procedure ComposeInstantProps(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
    Procedure ComposeUnsignedIntValue(json : TJSONWriter; name : String; value : TFhirUnsignedInt; inArray : boolean);
    Procedure ComposeUnsignedIntProps(json : TJSONWriter; name : String; value : TFhirUnsignedInt; inArray : boolean);
    Procedure ComposeCodeValue(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
    Procedure ComposeCodeProps(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
    Procedure ComposeIdValue(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
    Procedure ComposeIdProps(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
    Procedure ComposeOidValue(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
    Procedure ComposeOidProps(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
    Procedure ComposePositiveIntValue(json : TJSONWriter; name : String; value : TFhirPositiveInt; inArray : boolean);
    Procedure ComposePositiveIntProps(json : TJSONWriter; name : String; value : TFhirPositiveInt; inArray : boolean);
    Procedure ComposeUuidValue(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
    Procedure ComposeUuidProps(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);

    Procedure ComposeResourceProperties(json : TJSONWriter; elem : TFhirResource);
    Procedure ComposeDomainResourceProperties(json : TJSONWriter; elem : TFhirDomainResource);
    procedure ComposeParametersParameter(json : TJSONWriter; name : string; elem : TFhirParametersParameter; noObj : boolean = false);
    procedure ComposeParametersParameterPart(json : TJSONWriter; name : string; elem : TFhirParametersParameterPart; noObj : boolean = false);
    procedure ComposeParameters(json : TJSONWriter; name : string; elem : TFhirParameters; noObj : boolean = false);

    procedure ComposeExtension(json : TJSONWriter; name : string; elem : TFhirExtension; noObj : boolean = false);
    procedure ComposeNarrative(json : TJSONWriter; name : string; elem : TFhirNarrative; noObj : boolean = false);
    procedure ComposePeriod(json : TJSONWriter; name : string; elem : TFhirPeriod; noObj : boolean = false);
    procedure ComposeCoding(json : TJSONWriter; name : string; elem : TFhirCoding; noObj : boolean = false);
    procedure ComposeRange(json : TJSONWriter; name : string; elem : TFhirRange; noObj : boolean = false);
    procedure ComposeQuantity(json : TJSONWriter; name : string; elem : TFhirQuantity; noObj : boolean = false);
    procedure ComposeAttachment(json : TJSONWriter; name : string; elem : TFhirAttachment; noObj : boolean = false);
    procedure ComposeRatio(json : TJSONWriter; name : string; elem : TFhirRatio; noObj : boolean = false);
    procedure ComposeSampledData(json : TJSONWriter; name : string; elem : TFhirSampledData; noObj : boolean = false);
    procedure ComposeReference(json : TJSONWriter; name : string; elem : TFhirReference; noObj : boolean = false);
    procedure ComposeCodeableConcept(json : TJSONWriter; name : string; elem : TFhirCodeableConcept; noObj : boolean = false);
    procedure ComposeIdentifier(json : TJSONWriter; name : string; elem : TFhirIdentifier; noObj : boolean = false);
    procedure ComposeSignature(json : TJSONWriter; name : string; elem : TFhirSignature; noObj : boolean = false);
    procedure ComposeElementDefinitionSlicing(json : TJSONWriter; name : string; elem : TFhirElementDefinitionSlicing; noObj : boolean = false);
    procedure ComposeElementDefinitionType(json : TJSONWriter; name : string; elem : TFhirElementDefinitionType; noObj : boolean = false);
    procedure ComposeElementDefinitionConstraint(json : TJSONWriter; name : string; elem : TFhirElementDefinitionConstraint; noObj : boolean = false);
    procedure ComposeElementDefinitionBinding(json : TJSONWriter; name : string; elem : TFhirElementDefinitionBinding; noObj : boolean = false);
    procedure ComposeElementDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirElementDefinitionMapping; noObj : boolean = false);
    procedure ComposeElementDefinition(json : TJSONWriter; name : string; elem : TFhirElementDefinition; noObj : boolean = false);
    procedure ComposeTimingRepeat(json : TJSONWriter; name : string; elem : TFhirTimingRepeat; noObj : boolean = false);
    procedure ComposeTiming(json : TJSONWriter; name : string; elem : TFhirTiming; noObj : boolean = false);
    procedure ComposeAddress(json : TJSONWriter; name : string; elem : TFhirAddress; noObj : boolean = false);
    procedure ComposeHumanName(json : TJSONWriter; name : string; elem : TFhirHumanName; noObj : boolean = false);
    procedure ComposeMeta(json : TJSONWriter; name : string; elem : TFhirMeta; noObj : boolean = false);
    procedure ComposeContactPoint(json : TJSONWriter; name : string; elem : TFhirContactPoint; noObj : boolean = false);
    procedure ComposeAge(json : TJSONWriter; name : string; elem : TFhirAge; noObj : boolean = false);
    procedure ComposeCount(json : TJSONWriter; name : string; elem : TFhirCount; noObj : boolean = false);
    procedure ComposeMoney(json : TJSONWriter; name : string; elem : TFhirMoney; noObj : boolean = false);
    procedure ComposeDistance(json : TJSONWriter; name : string; elem : TFhirDistance; noObj : boolean = false);
    procedure ComposeDuration(json : TJSONWriter; name : string; elem : TFhirDuration; noObj : boolean = false);

    procedure ComposeAllergyIntoleranceEvent(json : TJSONWriter; name : string; elem : TFhirAllergyIntoleranceEvent; noObj : boolean = false);
    procedure ComposeAllergyIntolerance(json : TJSONWriter; name : string; elem : TFhirAllergyIntolerance; noObj : boolean = false);
    procedure ComposeAppointmentParticipant(json : TJSONWriter; name : string; elem : TFhirAppointmentParticipant; noObj : boolean = false);
    procedure ComposeAppointment(json : TJSONWriter; name : string; elem : TFhirAppointment; noObj : boolean = false);
    procedure ComposeAppointmentResponse(json : TJSONWriter; name : string; elem : TFhirAppointmentResponse; noObj : boolean = false);
    procedure ComposeAuditEventEvent(json : TJSONWriter; name : string; elem : TFhirAuditEventEvent; noObj : boolean = false);
    procedure ComposeAuditEventParticipant(json : TJSONWriter; name : string; elem : TFhirAuditEventParticipant; noObj : boolean = false);
    procedure ComposeAuditEventParticipantNetwork(json : TJSONWriter; name : string; elem : TFhirAuditEventParticipantNetwork; noObj : boolean = false);
    procedure ComposeAuditEventSource(json : TJSONWriter; name : string; elem : TFhirAuditEventSource; noObj : boolean = false);
    procedure ComposeAuditEventObject(json : TJSONWriter; name : string; elem : TFhirAuditEventObject; noObj : boolean = false);
    procedure ComposeAuditEventObjectDetail(json : TJSONWriter; name : string; elem : TFhirAuditEventObjectDetail; noObj : boolean = false);
    procedure ComposeAuditEvent(json : TJSONWriter; name : string; elem : TFhirAuditEvent; noObj : boolean = false);
    procedure ComposeBasic(json : TJSONWriter; name : string; elem : TFhirBasic; noObj : boolean = false);
    procedure ComposeBinary(json : TJSONWriter; name : string; elem : TFhirBinary; noObj : boolean = false);
    procedure ComposeBodySite(json : TJSONWriter; name : string; elem : TFhirBodySite; noObj : boolean = false);
    procedure ComposeBundleLink(json : TJSONWriter; name : string; elem : TFhirBundleLink; noObj : boolean = false);
    procedure ComposeBundleEntry(json : TJSONWriter; name : string; elem : TFhirBundleEntry; noObj : boolean = false);
    procedure ComposeBundleEntrySearch(json : TJSONWriter; name : string; elem : TFhirBundleEntrySearch; noObj : boolean = false);
    procedure ComposeBundleEntryTransaction(json : TJSONWriter; name : string; elem : TFhirBundleEntryTransaction; noObj : boolean = false);
    procedure ComposeBundleEntryTransactionResponse(json : TJSONWriter; name : string; elem : TFhirBundleEntryTransactionResponse; noObj : boolean = false);
    procedure ComposeBundle(json : TJSONWriter; name : string; elem : TFhirBundle; noObj : boolean = false);
    procedure ComposeCarePlanParticipant(json : TJSONWriter; name : string; elem : TFhirCarePlanParticipant; noObj : boolean = false);
    procedure ComposeCarePlanActivity(json : TJSONWriter; name : string; elem : TFhirCarePlanActivity; noObj : boolean = false);
    procedure ComposeCarePlanActivityDetail(json : TJSONWriter; name : string; elem : TFhirCarePlanActivityDetail; noObj : boolean = false);
    procedure ComposeCarePlan(json : TJSONWriter; name : string; elem : TFhirCarePlan; noObj : boolean = false);
    procedure ComposeClaimPayee(json : TJSONWriter; name : string; elem : TFhirClaimPayee; noObj : boolean = false);
    procedure ComposeClaimDiagnosis(json : TJSONWriter; name : string; elem : TFhirClaimDiagnosis; noObj : boolean = false);
    procedure ComposeClaimCoverage(json : TJSONWriter; name : string; elem : TFhirClaimCoverage; noObj : boolean = false);
    procedure ComposeClaimItem(json : TJSONWriter; name : string; elem : TFhirClaimItem; noObj : boolean = false);
    procedure ComposeClaimItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimItemDetail; noObj : boolean = false);
    procedure ComposeClaimItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimItemDetailSubDetail; noObj : boolean = false);
    procedure ComposeClaimItemProsthesis(json : TJSONWriter; name : string; elem : TFhirClaimItemProsthesis; noObj : boolean = false);
    procedure ComposeClaimMissingTeeth(json : TJSONWriter; name : string; elem : TFhirClaimMissingTeeth; noObj : boolean = false);
    procedure ComposeClaim(json : TJSONWriter; name : string; elem : TFhirClaim; noObj : boolean = false);
    procedure ComposeClaimResponseItem(json : TJSONWriter; name : string; elem : TFhirClaimResponseItem; noObj : boolean = false);
    procedure ComposeClaimResponseItemAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemAdjudication; noObj : boolean = false);
    procedure ComposeClaimResponseItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetail; noObj : boolean = false);
    procedure ComposeClaimResponseItemDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailAdjudication; noObj : boolean = false);
    procedure ComposeClaimResponseItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailSubDetail; noObj : boolean = false);
    procedure ComposeClaimResponseItemDetailSubDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailSubDetailAdjudication; noObj : boolean = false);
    procedure ComposeClaimResponseAddItem(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItem; noObj : boolean = false);
    procedure ComposeClaimResponseAddItemAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemAdjudication; noObj : boolean = false);
    procedure ComposeClaimResponseAddItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemDetail; noObj : boolean = false);
    procedure ComposeClaimResponseAddItemDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemDetailAdjudication; noObj : boolean = false);
    procedure ComposeClaimResponseError(json : TJSONWriter; name : string; elem : TFhirClaimResponseError; noObj : boolean = false);
    procedure ComposeClaimResponseNote(json : TJSONWriter; name : string; elem : TFhirClaimResponseNote; noObj : boolean = false);
    procedure ComposeClaimResponseCoverage(json : TJSONWriter; name : string; elem : TFhirClaimResponseCoverage; noObj : boolean = false);
    procedure ComposeClaimResponse(json : TJSONWriter; name : string; elem : TFhirClaimResponse; noObj : boolean = false);
    procedure ComposeClinicalImpressionInvestigations(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionInvestigations; noObj : boolean = false);
    procedure ComposeClinicalImpressionFinding(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionFinding; noObj : boolean = false);
    procedure ComposeClinicalImpressionRuledOut(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionRuledOut; noObj : boolean = false);
    procedure ComposeClinicalImpression(json : TJSONWriter; name : string; elem : TFhirClinicalImpression; noObj : boolean = false);
    procedure ComposeCommunicationPayload(json : TJSONWriter; name : string; elem : TFhirCommunicationPayload; noObj : boolean = false);
    procedure ComposeCommunication(json : TJSONWriter; name : string; elem : TFhirCommunication; noObj : boolean = false);
    procedure ComposeCommunicationRequestPayload(json : TJSONWriter; name : string; elem : TFhirCommunicationRequestPayload; noObj : boolean = false);
    procedure ComposeCommunicationRequest(json : TJSONWriter; name : string; elem : TFhirCommunicationRequest; noObj : boolean = false);
    procedure ComposeCompositionAttester(json : TJSONWriter; name : string; elem : TFhirCompositionAttester; noObj : boolean = false);
    procedure ComposeCompositionEvent(json : TJSONWriter; name : string; elem : TFhirCompositionEvent; noObj : boolean = false);
    procedure ComposeCompositionSection(json : TJSONWriter; name : string; elem : TFhirCompositionSection; noObj : boolean = false);
    procedure ComposeComposition(json : TJSONWriter; name : string; elem : TFhirComposition; noObj : boolean = false);
    procedure ComposeConceptMapContact(json : TJSONWriter; name : string; elem : TFhirConceptMapContact; noObj : boolean = false);
    procedure ComposeConceptMapElement(json : TJSONWriter; name : string; elem : TFhirConceptMapElement; noObj : boolean = false);
    procedure ComposeConceptMapElementDependsOn(json : TJSONWriter; name : string; elem : TFhirConceptMapElementDependsOn; noObj : boolean = false);
    procedure ComposeConceptMapElementMap(json : TJSONWriter; name : string; elem : TFhirConceptMapElementMap; noObj : boolean = false);
    procedure ComposeConceptMap(json : TJSONWriter; name : string; elem : TFhirConceptMap; noObj : boolean = false);
    procedure ComposeConditionStage(json : TJSONWriter; name : string; elem : TFhirConditionStage; noObj : boolean = false);
    procedure ComposeConditionEvidence(json : TJSONWriter; name : string; elem : TFhirConditionEvidence; noObj : boolean = false);
    procedure ComposeConditionLocation(json : TJSONWriter; name : string; elem : TFhirConditionLocation; noObj : boolean = false);
    procedure ComposeConditionDueTo(json : TJSONWriter; name : string; elem : TFhirConditionDueTo; noObj : boolean = false);
    procedure ComposeConditionOccurredFollowing(json : TJSONWriter; name : string; elem : TFhirConditionOccurredFollowing; noObj : boolean = false);
    procedure ComposeCondition(json : TJSONWriter; name : string; elem : TFhirCondition; noObj : boolean = false);
    procedure ComposeConformanceContact(json : TJSONWriter; name : string; elem : TFhirConformanceContact; noObj : boolean = false);
    procedure ComposeConformanceSoftware(json : TJSONWriter; name : string; elem : TFhirConformanceSoftware; noObj : boolean = false);
    procedure ComposeConformanceImplementation(json : TJSONWriter; name : string; elem : TFhirConformanceImplementation; noObj : boolean = false);
    procedure ComposeConformanceRest(json : TJSONWriter; name : string; elem : TFhirConformanceRest; noObj : boolean = false);
    procedure ComposeConformanceRestSecurity(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurity; noObj : boolean = false);
    procedure ComposeConformanceRestSecurityCertificate(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurityCertificate; noObj : boolean = false);
    procedure ComposeConformanceRestResource(json : TJSONWriter; name : string; elem : TFhirConformanceRestResource; noObj : boolean = false);
    procedure ComposeConformanceRestResourceInteraction(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceInteraction; noObj : boolean = false);
    procedure ComposeConformanceRestResourceSearchParam(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceSearchParam; noObj : boolean = false);
    procedure ComposeConformanceRestInteraction(json : TJSONWriter; name : string; elem : TFhirConformanceRestInteraction; noObj : boolean = false);
    procedure ComposeConformanceRestOperation(json : TJSONWriter; name : string; elem : TFhirConformanceRestOperation; noObj : boolean = false);
    procedure ComposeConformanceMessaging(json : TJSONWriter; name : string; elem : TFhirConformanceMessaging; noObj : boolean = false);
    procedure ComposeConformanceMessagingEvent(json : TJSONWriter; name : string; elem : TFhirConformanceMessagingEvent; noObj : boolean = false);
    procedure ComposeConformanceDocument(json : TJSONWriter; name : string; elem : TFhirConformanceDocument; noObj : boolean = false);
    procedure ComposeConformance(json : TJSONWriter; name : string; elem : TFhirConformance; noObj : boolean = false);
    procedure ComposeContractActor(json : TJSONWriter; name : string; elem : TFhirContractActor; noObj : boolean = false);
    procedure ComposeContractValuedItem(json : TJSONWriter; name : string; elem : TFhirContractValuedItem; noObj : boolean = false);
    procedure ComposeContractSigner(json : TJSONWriter; name : string; elem : TFhirContractSigner; noObj : boolean = false);
    procedure ComposeContractTerm(json : TJSONWriter; name : string; elem : TFhirContractTerm; noObj : boolean = false);
    procedure ComposeContractTermActor(json : TJSONWriter; name : string; elem : TFhirContractTermActor; noObj : boolean = false);
    procedure ComposeContractTermValuedItem(json : TJSONWriter; name : string; elem : TFhirContractTermValuedItem; noObj : boolean = false);
    procedure ComposeContractFriendly(json : TJSONWriter; name : string; elem : TFhirContractFriendly; noObj : boolean = false);
    procedure ComposeContractLegal(json : TJSONWriter; name : string; elem : TFhirContractLegal; noObj : boolean = false);
    procedure ComposeContractRule(json : TJSONWriter; name : string; elem : TFhirContractRule; noObj : boolean = false);
    procedure ComposeContract(json : TJSONWriter; name : string; elem : TFhirContract; noObj : boolean = false);
    procedure ComposeContraindicationMitigation(json : TJSONWriter; name : string; elem : TFhirContraindicationMitigation; noObj : boolean = false);
    procedure ComposeContraindication(json : TJSONWriter; name : string; elem : TFhirContraindication; noObj : boolean = false);
    procedure ComposeCoverage(json : TJSONWriter; name : string; elem : TFhirCoverage; noObj : boolean = false);
    procedure ComposeDataElementContact(json : TJSONWriter; name : string; elem : TFhirDataElementContact; noObj : boolean = false);
    procedure ComposeDataElementMapping(json : TJSONWriter; name : string; elem : TFhirDataElementMapping; noObj : boolean = false);
    procedure ComposeDataElement(json : TJSONWriter; name : string; elem : TFhirDataElement; noObj : boolean = false);
    procedure ComposeDevice(json : TJSONWriter; name : string; elem : TFhirDevice; noObj : boolean = false);
    procedure ComposeDeviceComponentProductionSpecification(json : TJSONWriter; name : string; elem : TFhirDeviceComponentProductionSpecification; noObj : boolean = false);
    procedure ComposeDeviceComponent(json : TJSONWriter; name : string; elem : TFhirDeviceComponent; noObj : boolean = false);
    procedure ComposeDeviceMetricCalibration(json : TJSONWriter; name : string; elem : TFhirDeviceMetricCalibration; noObj : boolean = false);
    procedure ComposeDeviceMetric(json : TJSONWriter; name : string; elem : TFhirDeviceMetric; noObj : boolean = false);
    procedure ComposeDeviceUseRequest(json : TJSONWriter; name : string; elem : TFhirDeviceUseRequest; noObj : boolean = false);
    procedure ComposeDeviceUseStatement(json : TJSONWriter; name : string; elem : TFhirDeviceUseStatement; noObj : boolean = false);
    procedure ComposeDiagnosticOrderEvent(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderEvent; noObj : boolean = false);
    procedure ComposeDiagnosticOrderItem(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderItem; noObj : boolean = false);
    procedure ComposeDiagnosticOrder(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrder; noObj : boolean = false);
    procedure ComposeDiagnosticReportImage(json : TJSONWriter; name : string; elem : TFhirDiagnosticReportImage; noObj : boolean = false);
    procedure ComposeDiagnosticReport(json : TJSONWriter; name : string; elem : TFhirDiagnosticReport; noObj : boolean = false);
    procedure ComposeDocumentManifestContent(json : TJSONWriter; name : string; elem : TFhirDocumentManifestContent; noObj : boolean = false);
    procedure ComposeDocumentManifestRelated(json : TJSONWriter; name : string; elem : TFhirDocumentManifestRelated; noObj : boolean = false);
    procedure ComposeDocumentManifest(json : TJSONWriter; name : string; elem : TFhirDocumentManifest; noObj : boolean = false);
    procedure ComposeDocumentReferenceRelatesTo(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceRelatesTo; noObj : boolean = false);
    procedure ComposeDocumentReferenceContext(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContext; noObj : boolean = false);
    procedure ComposeDocumentReferenceContextRelated(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContextRelated; noObj : boolean = false);
    procedure ComposeDocumentReference(json : TJSONWriter; name : string; elem : TFhirDocumentReference; noObj : boolean = false);
    procedure ComposeEligibilityRequest(json : TJSONWriter; name : string; elem : TFhirEligibilityRequest; noObj : boolean = false);
    procedure ComposeEligibilityResponse(json : TJSONWriter; name : string; elem : TFhirEligibilityResponse; noObj : boolean = false);
    procedure ComposeEncounterStatusHistory(json : TJSONWriter; name : string; elem : TFhirEncounterStatusHistory; noObj : boolean = false);
    procedure ComposeEncounterParticipant(json : TJSONWriter; name : string; elem : TFhirEncounterParticipant; noObj : boolean = false);
    procedure ComposeEncounterHospitalization(json : TJSONWriter; name : string; elem : TFhirEncounterHospitalization; noObj : boolean = false);
    procedure ComposeEncounterLocation(json : TJSONWriter; name : string; elem : TFhirEncounterLocation; noObj : boolean = false);
    procedure ComposeEncounter(json : TJSONWriter; name : string; elem : TFhirEncounter; noObj : boolean = false);
    procedure ComposeEnrollmentRequest(json : TJSONWriter; name : string; elem : TFhirEnrollmentRequest; noObj : boolean = false);
    procedure ComposeEnrollmentResponse(json : TJSONWriter; name : string; elem : TFhirEnrollmentResponse; noObj : boolean = false);
    procedure ComposeEpisodeOfCareStatusHistory(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCareStatusHistory; noObj : boolean = false);
    procedure ComposeEpisodeOfCareCareTeam(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCareCareTeam; noObj : boolean = false);
    procedure ComposeEpisodeOfCare(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCare; noObj : boolean = false);
    procedure ComposeExplanationOfBenefit(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefit; noObj : boolean = false);
    procedure ComposeFamilyMemberHistoryCondition(json : TJSONWriter; name : string; elem : TFhirFamilyMemberHistoryCondition; noObj : boolean = false);
    procedure ComposeFamilyMemberHistory(json : TJSONWriter; name : string; elem : TFhirFamilyMemberHistory; noObj : boolean = false);
    procedure ComposeFlag(json : TJSONWriter; name : string; elem : TFhirFlag; noObj : boolean = false);
    procedure ComposeGoalOutcome(json : TJSONWriter; name : string; elem : TFhirGoalOutcome; noObj : boolean = false);
    procedure ComposeGoal(json : TJSONWriter; name : string; elem : TFhirGoal; noObj : boolean = false);
    procedure ComposeGroupCharacteristic(json : TJSONWriter; name : string; elem : TFhirGroupCharacteristic; noObj : boolean = false);
    procedure ComposeGroup(json : TJSONWriter; name : string; elem : TFhirGroup; noObj : boolean = false);
    procedure ComposeHealthcareServiceServiceType(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceServiceType; noObj : boolean = false);
    procedure ComposeHealthcareServiceAvailableTime(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceAvailableTime; noObj : boolean = false);
    procedure ComposeHealthcareServiceNotAvailable(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceNotAvailable; noObj : boolean = false);
    procedure ComposeHealthcareService(json : TJSONWriter; name : string; elem : TFhirHealthcareService; noObj : boolean = false);
    procedure ComposeImagingObjectSelectionStudy(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudy; noObj : boolean = false);
    procedure ComposeImagingObjectSelectionStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeries; noObj : boolean = false);
    procedure ComposeImagingObjectSelectionStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstance; noObj : boolean = false);
    procedure ComposeImagingObjectSelectionStudySeriesInstanceFrames(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames; noObj : boolean = false);
    procedure ComposeImagingObjectSelection(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelection; noObj : boolean = false);
    procedure ComposeImagingStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingStudySeries; noObj : boolean = false);
    procedure ComposeImagingStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingStudySeriesInstance; noObj : boolean = false);
    procedure ComposeImagingStudy(json : TJSONWriter; name : string; elem : TFhirImagingStudy; noObj : boolean = false);
    procedure ComposeImmunizationExplanation(json : TJSONWriter; name : string; elem : TFhirImmunizationExplanation; noObj : boolean = false);
    procedure ComposeImmunizationReaction(json : TJSONWriter; name : string; elem : TFhirImmunizationReaction; noObj : boolean = false);
    procedure ComposeImmunizationVaccinationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationVaccinationProtocol; noObj : boolean = false);
    procedure ComposeImmunization(json : TJSONWriter; name : string; elem : TFhirImmunization; noObj : boolean = false);
    procedure ComposeImmunizationRecommendationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendation; noObj : boolean = false);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion; noObj : boolean = false);
    procedure ComposeImmunizationRecommendationRecommendationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol; noObj : boolean = false);
    procedure ComposeImmunizationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendation; noObj : boolean = false);
    procedure ComposeListEntry(json : TJSONWriter; name : string; elem : TFhirListEntry; noObj : boolean = false);
    procedure ComposeList(json : TJSONWriter; name : string; elem : TFhirList; noObj : boolean = false);
    procedure ComposeLocationPosition(json : TJSONWriter; name : string; elem : TFhirLocationPosition; noObj : boolean = false);
    procedure ComposeLocation(json : TJSONWriter; name : string; elem : TFhirLocation; noObj : boolean = false);
    procedure ComposeMedia(json : TJSONWriter; name : string; elem : TFhirMedia; noObj : boolean = false);
    procedure ComposeMedicationProduct(json : TJSONWriter; name : string; elem : TFhirMedicationProduct; noObj : boolean = false);
    procedure ComposeMedicationProductIngredient(json : TJSONWriter; name : string; elem : TFhirMedicationProductIngredient; noObj : boolean = false);
    procedure ComposeMedicationProductBatch(json : TJSONWriter; name : string; elem : TFhirMedicationProductBatch; noObj : boolean = false);
    procedure ComposeMedicationPackage(json : TJSONWriter; name : string; elem : TFhirMedicationPackage; noObj : boolean = false);
    procedure ComposeMedicationPackageContent(json : TJSONWriter; name : string; elem : TFhirMedicationPackageContent; noObj : boolean = false);
    procedure ComposeMedication(json : TJSONWriter; name : string; elem : TFhirMedication; noObj : boolean = false);
    procedure ComposeMedicationAdministrationDosage(json : TJSONWriter; name : string; elem : TFhirMedicationAdministrationDosage; noObj : boolean = false);
    procedure ComposeMedicationAdministration(json : TJSONWriter; name : string; elem : TFhirMedicationAdministration; noObj : boolean = false);
    procedure ComposeMedicationDispenseDosageInstruction(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseDosageInstruction; noObj : boolean = false);
    procedure ComposeMedicationDispenseSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseSubstitution; noObj : boolean = false);
    procedure ComposeMedicationDispense(json : TJSONWriter; name : string; elem : TFhirMedicationDispense; noObj : boolean = false);
    procedure ComposeMedicationPrescriptionDosageInstruction(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionDosageInstruction; noObj : boolean = false);
    procedure ComposeMedicationPrescriptionDispense(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionDispense; noObj : boolean = false);
    procedure ComposeMedicationPrescriptionSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionSubstitution; noObj : boolean = false);
    procedure ComposeMedicationPrescription(json : TJSONWriter; name : string; elem : TFhirMedicationPrescription; noObj : boolean = false);
    procedure ComposeMedicationStatementDosage(json : TJSONWriter; name : string; elem : TFhirMedicationStatementDosage; noObj : boolean = false);
    procedure ComposeMedicationStatement(json : TJSONWriter; name : string; elem : TFhirMedicationStatement; noObj : boolean = false);
    procedure ComposeMessageHeaderResponse(json : TJSONWriter; name : string; elem : TFhirMessageHeaderResponse; noObj : boolean = false);
    procedure ComposeMessageHeaderSource(json : TJSONWriter; name : string; elem : TFhirMessageHeaderSource; noObj : boolean = false);
    procedure ComposeMessageHeaderDestination(json : TJSONWriter; name : string; elem : TFhirMessageHeaderDestination; noObj : boolean = false);
    procedure ComposeMessageHeader(json : TJSONWriter; name : string; elem : TFhirMessageHeader; noObj : boolean = false);
    procedure ComposeNamingSystemUniqueId(json : TJSONWriter; name : string; elem : TFhirNamingSystemUniqueId; noObj : boolean = false);
    procedure ComposeNamingSystemContact(json : TJSONWriter; name : string; elem : TFhirNamingSystemContact; noObj : boolean = false);
    procedure ComposeNamingSystem(json : TJSONWriter; name : string; elem : TFhirNamingSystem; noObj : boolean = false);
    procedure ComposeNutritionOrderOralDiet(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDiet; noObj : boolean = false);
    procedure ComposeNutritionOrderOralDietNutrient(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDietNutrient; noObj : boolean = false);
    procedure ComposeNutritionOrderOralDietTexture(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDietTexture; noObj : boolean = false);
    procedure ComposeNutritionOrderSupplement(json : TJSONWriter; name : string; elem : TFhirNutritionOrderSupplement; noObj : boolean = false);
    procedure ComposeNutritionOrderEnteralFormula(json : TJSONWriter; name : string; elem : TFhirNutritionOrderEnteralFormula; noObj : boolean = false);
    procedure ComposeNutritionOrder(json : TJSONWriter; name : string; elem : TFhirNutritionOrder; noObj : boolean = false);
    procedure ComposeObservationReferenceRange(json : TJSONWriter; name : string; elem : TFhirObservationReferenceRange; noObj : boolean = false);
    procedure ComposeObservationRelated(json : TJSONWriter; name : string; elem : TFhirObservationRelated; noObj : boolean = false);
    procedure ComposeObservation(json : TJSONWriter; name : string; elem : TFhirObservation; noObj : boolean = false);
    procedure ComposeOperationDefinitionContact(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionContact; noObj : boolean = false);
    procedure ComposeOperationDefinitionParameter(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameter; noObj : boolean = false);
    procedure ComposeOperationDefinitionParameterPart(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameterPart; noObj : boolean = false);
    procedure ComposeOperationDefinition(json : TJSONWriter; name : string; elem : TFhirOperationDefinition; noObj : boolean = false);
    procedure ComposeOperationOutcomeIssue(json : TJSONWriter; name : string; elem : TFhirOperationOutcomeIssue; noObj : boolean = false);
    procedure ComposeOperationOutcome(json : TJSONWriter; name : string; elem : TFhirOperationOutcome; noObj : boolean = false);
    procedure ComposeOrderWhen(json : TJSONWriter; name : string; elem : TFhirOrderWhen; noObj : boolean = false);
    procedure ComposeOrder(json : TJSONWriter; name : string; elem : TFhirOrder; noObj : boolean = false);
    procedure ComposeOrderResponse(json : TJSONWriter; name : string; elem : TFhirOrderResponse; noObj : boolean = false);
    procedure ComposeOrganizationContact(json : TJSONWriter; name : string; elem : TFhirOrganizationContact; noObj : boolean = false);
    procedure ComposeOrganization(json : TJSONWriter; name : string; elem : TFhirOrganization; noObj : boolean = false);
    procedure ComposePatientContact(json : TJSONWriter; name : string; elem : TFhirPatientContact; noObj : boolean = false);
    procedure ComposePatientAnimal(json : TJSONWriter; name : string; elem : TFhirPatientAnimal; noObj : boolean = false);
    procedure ComposePatientCommunication(json : TJSONWriter; name : string; elem : TFhirPatientCommunication; noObj : boolean = false);
    procedure ComposePatientLink(json : TJSONWriter; name : string; elem : TFhirPatientLink; noObj : boolean = false);
    procedure ComposePatient(json : TJSONWriter; name : string; elem : TFhirPatient; noObj : boolean = false);
    procedure ComposePaymentNotice(json : TJSONWriter; name : string; elem : TFhirPaymentNotice; noObj : boolean = false);
    procedure ComposePaymentReconciliationDetail(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliationDetail; noObj : boolean = false);
    procedure ComposePaymentReconciliationNote(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliationNote; noObj : boolean = false);
    procedure ComposePaymentReconciliation(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliation; noObj : boolean = false);
    procedure ComposePersonLink(json : TJSONWriter; name : string; elem : TFhirPersonLink; noObj : boolean = false);
    procedure ComposePerson(json : TJSONWriter; name : string; elem : TFhirPerson; noObj : boolean = false);
    procedure ComposePractitionerPractitionerRole(json : TJSONWriter; name : string; elem : TFhirPractitionerPractitionerRole; noObj : boolean = false);
    procedure ComposePractitionerQualification(json : TJSONWriter; name : string; elem : TFhirPractitionerQualification; noObj : boolean = false);
    procedure ComposePractitioner(json : TJSONWriter; name : string; elem : TFhirPractitioner; noObj : boolean = false);
    procedure ComposeProcedureBodySite(json : TJSONWriter; name : string; elem : TFhirProcedureBodySite; noObj : boolean = false);
    procedure ComposeProcedurePerformer(json : TJSONWriter; name : string; elem : TFhirProcedurePerformer; noObj : boolean = false);
    procedure ComposeProcedureRelatedItem(json : TJSONWriter; name : string; elem : TFhirProcedureRelatedItem; noObj : boolean = false);
    procedure ComposeProcedureDevice(json : TJSONWriter; name : string; elem : TFhirProcedureDevice; noObj : boolean = false);
    procedure ComposeProcedure(json : TJSONWriter; name : string; elem : TFhirProcedure; noObj : boolean = false);
    procedure ComposeProcedureRequestBodySite(json : TJSONWriter; name : string; elem : TFhirProcedureRequestBodySite; noObj : boolean = false);
    procedure ComposeProcedureRequest(json : TJSONWriter; name : string; elem : TFhirProcedureRequest; noObj : boolean = false);
    procedure ComposeProcessRequestItem(json : TJSONWriter; name : string; elem : TFhirProcessRequestItem; noObj : boolean = false);
    procedure ComposeProcessRequest(json : TJSONWriter; name : string; elem : TFhirProcessRequest; noObj : boolean = false);
    procedure ComposeProcessResponseNotes(json : TJSONWriter; name : string; elem : TFhirProcessResponseNotes; noObj : boolean = false);
    procedure ComposeProcessResponse(json : TJSONWriter; name : string; elem : TFhirProcessResponse; noObj : boolean = false);
    procedure ComposeProvenanceAgent(json : TJSONWriter; name : string; elem : TFhirProvenanceAgent; noObj : boolean = false);
    procedure ComposeProvenanceEntity(json : TJSONWriter; name : string; elem : TFhirProvenanceEntity; noObj : boolean = false);
    procedure ComposeProvenance(json : TJSONWriter; name : string; elem : TFhirProvenance; noObj : boolean = false);
    procedure ComposeQuestionnaireGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroup; noObj : boolean = false);
    procedure ComposeQuestionnaireGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroupQuestion; noObj : boolean = false);
    procedure ComposeQuestionnaire(json : TJSONWriter; name : string; elem : TFhirQuestionnaire; noObj : boolean = false);
    procedure ComposeQuestionnaireAnswersGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireAnswersGroup; noObj : boolean = false);
    procedure ComposeQuestionnaireAnswersGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireAnswersGroupQuestion; noObj : boolean = false);
    procedure ComposeQuestionnaireAnswersGroupQuestionAnswer(json : TJSONWriter; name : string; elem : TFhirQuestionnaireAnswersGroupQuestionAnswer; noObj : boolean = false);
    procedure ComposeQuestionnaireAnswers(json : TJSONWriter; name : string; elem : TFhirQuestionnaireAnswers; noObj : boolean = false);
    procedure ComposeReferralRequest(json : TJSONWriter; name : string; elem : TFhirReferralRequest; noObj : boolean = false);
    procedure ComposeRelatedPerson(json : TJSONWriter; name : string; elem : TFhirRelatedPerson; noObj : boolean = false);
    procedure ComposeRiskAssessmentPrediction(json : TJSONWriter; name : string; elem : TFhirRiskAssessmentPrediction; noObj : boolean = false);
    procedure ComposeRiskAssessment(json : TJSONWriter; name : string; elem : TFhirRiskAssessment; noObj : boolean = false);
    procedure ComposeSchedule(json : TJSONWriter; name : string; elem : TFhirSchedule; noObj : boolean = false);
    procedure ComposeSearchParameterContact(json : TJSONWriter; name : string; elem : TFhirSearchParameterContact; noObj : boolean = false);
    procedure ComposeSearchParameter(json : TJSONWriter; name : string; elem : TFhirSearchParameter; noObj : boolean = false);
    procedure ComposeSlot(json : TJSONWriter; name : string; elem : TFhirSlot; noObj : boolean = false);
    procedure ComposeSpecimenCollection(json : TJSONWriter; name : string; elem : TFhirSpecimenCollection; noObj : boolean = false);
    procedure ComposeSpecimenTreatment(json : TJSONWriter; name : string; elem : TFhirSpecimenTreatment; noObj : boolean = false);
    procedure ComposeSpecimenContainer(json : TJSONWriter; name : string; elem : TFhirSpecimenContainer; noObj : boolean = false);
    procedure ComposeSpecimen(json : TJSONWriter; name : string; elem : TFhirSpecimen; noObj : boolean = false);
    procedure ComposeStructureDefinitionContact(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionContact; noObj : boolean = false);
    procedure ComposeStructureDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionMapping; noObj : boolean = false);
    procedure ComposeStructureDefinitionSnapshot(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionSnapshot; noObj : boolean = false);
    procedure ComposeStructureDefinitionDifferential(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionDifferential; noObj : boolean = false);
    procedure ComposeStructureDefinition(json : TJSONWriter; name : string; elem : TFhirStructureDefinition; noObj : boolean = false);
    procedure ComposeSubscriptionChannel(json : TJSONWriter; name : string; elem : TFhirSubscriptionChannel; noObj : boolean = false);
    procedure ComposeSubscription(json : TJSONWriter; name : string; elem : TFhirSubscription; noObj : boolean = false);
    procedure ComposeSubstanceInstance(json : TJSONWriter; name : string; elem : TFhirSubstanceInstance; noObj : boolean = false);
    procedure ComposeSubstanceIngredient(json : TJSONWriter; name : string; elem : TFhirSubstanceIngredient; noObj : boolean = false);
    procedure ComposeSubstance(json : TJSONWriter; name : string; elem : TFhirSubstance; noObj : boolean = false);
    procedure ComposeSupplyDispense(json : TJSONWriter; name : string; elem : TFhirSupplyDispense; noObj : boolean = false);
    procedure ComposeSupply(json : TJSONWriter; name : string; elem : TFhirSupply; noObj : boolean = false);
    procedure ComposeSupplyDelivery(json : TJSONWriter; name : string; elem : TFhirSupplyDelivery; noObj : boolean = false);
    procedure ComposeSupplyRequest(json : TJSONWriter; name : string; elem : TFhirSupplyRequest; noObj : boolean = false);
    procedure ComposeValueSetContact(json : TJSONWriter; name : string; elem : TFhirValueSetContact; noObj : boolean = false);
    procedure ComposeValueSetDefine(json : TJSONWriter; name : string; elem : TFhirValueSetDefine; noObj : boolean = false);
    procedure ComposeValueSetDefineConcept(json : TJSONWriter; name : string; elem : TFhirValueSetDefineConcept; noObj : boolean = false);
    procedure ComposeValueSetDefineConceptDesignation(json : TJSONWriter; name : string; elem : TFhirValueSetDefineConceptDesignation; noObj : boolean = false);
    procedure ComposeValueSetCompose(json : TJSONWriter; name : string; elem : TFhirValueSetCompose; noObj : boolean = false);
    procedure ComposeValueSetComposeInclude(json : TJSONWriter; name : string; elem : TFhirValueSetComposeInclude; noObj : boolean = false);
    procedure ComposeValueSetComposeIncludeConcept(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeConcept; noObj : boolean = false);
    procedure ComposeValueSetComposeIncludeFilter(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeFilter; noObj : boolean = false);
    procedure ComposeValueSetExpansion(json : TJSONWriter; name : string; elem : TFhirValueSetExpansion; noObj : boolean = false);
    procedure ComposeValueSetExpansionParameter(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionParameter; noObj : boolean = false);
    procedure ComposeValueSetExpansionContains(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionContains; noObj : boolean = false);
    procedure ComposeValueSet(json : TJSONWriter; name : string; elem : TFhirValueSet; noObj : boolean = false);
    procedure ComposeVisionPrescriptionDispense(json : TJSONWriter; name : string; elem : TFhirVisionPrescriptionDispense; noObj : boolean = false);
    procedure ComposeVisionPrescription(json : TJSONWriter; name : string; elem : TFhirVisionPrescription; noObj : boolean = false);
    procedure ComposeResource(json : TJSONWriter; resource : TFhirResource; links : TFhirBundleLinkList); override;
  end;


implementation

{ TFHIRXmlParser }

function TFHIRXmlParser.ParseElement(element : IXmlDomElement; path : string) : TFhirElement;
var
  child : IXMLDOMElement;
begin
  result := TFhirElement.create;
  try
    parseElementAttributes(result, path, element);
    result.id := GetAttribute(element, 'id');{x.4}
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'extension') then
        result.extensionList.Add(ParseExtension(child, path+'/extension')){y.2}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeElement(xml : TXmlBuilder; name : string; elem : TFhirElement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  Attribute(xml, 'id', elem.id  );
  xml.open(name);
  composeElementChildren(xml, elem);
  for i := 0 to elem.extensionList.Count - 1 do
    ComposeExtension(xml, 'extension', elem.extensionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElement(jsn)); {2}
end;

function TFHIRJsonParser.ParseElement(jsn : TJsonObject) : TFhirElement;
begin
  result := TFhirElement.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('id') or jsn.has('_id') then
        result.idElement := ParseId(jsn['id'], jsn.vObj['_id']);{q}
    if jsn.has('extension') then
      iterateArray(jsn.vArr['extension'], result.extensionList, parseExtension);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeElement(json : TJSONWriter; name : string; elem : TFhirElement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeIdValue(json, 'id', elem.idElement, false);
  ComposeIdProps(json, 'id', elem.idElement, false);
  if elem.extensionList.Count > 0 then
  begin
    json.valueArray('extension');
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(json, '',elem.extensionList[i]); {z - Extension}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseBackboneElement(element : IXmlDomElement; path : string) : TFhirBackboneElement;
var
  child : IXMLDOMElement;
begin
  result := TFhirBackboneElement.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'modifierExtension') then
        result.modifierExtensionList.Add(ParseExtension(child, path+'/modifierExtension')){y.2}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBackboneElement(xml : TXmlBuilder; name : string; elem : TFhirBackboneElement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  for i := 0 to elem.modifierExtensionList.Count - 1 do
    ComposeExtension(xml, 'modifierExtension', elem.modifierExtensionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBackboneElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBackboneElement(jsn)); {2}
end;

function TFHIRJsonParser.ParseBackboneElement(jsn : TJsonObject) : TFhirBackboneElement;
begin
  result := TFhirBackboneElement.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('modifierExtension') then
      iterateArray(jsn.vArr['modifierExtension'], result.modifierExtensionList, parseExtension);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBackboneElement(json : TJSONWriter; name : string; elem : TFhirBackboneElement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if elem.modifierExtensionList.Count > 0 then
  begin
    json.valueArray('modifierExtension');
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(json, '',elem.modifierExtensionList[i]); {z - Extension}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

Procedure TFHIRXmlParser.ParseElementAttributes(value : TFhirElement; path : string; element : IXmlDomElement);
begin
  TakeCommentsStart(value);
  value.Id := GetAttribute(element, 'id');
end;

Function TFHIRXmlParser.ParseBackboneElementChild(element : TFhirBackboneElement; path : string; child : IXmlDomElement) : boolean;
begin
  result := true;
  if (child.baseName = 'modifierExtension') then
    element.ModifierExtensionList.add(ParseExtension(child, path+'/modifierExtension'))
  else
    result := ParseElementChild(element, path, child);
end;

Function TFHIRXmlParser.ParseElementChild(element : TFhirElement; path : string; child : IXmlDomElement) : boolean;
begin
  result := true;
  if (child.baseName = 'extension') then
    element.ExtensionList.add(ParseExtension(child, path+'/extension'))
  else
    result := false;
end;

procedure TFHIRJsonParser.ParseElementProperties(jsn : TJsonObject; element : TFhirElement);
begin
  parseComments(element, jsn);

  if jsn.has('id') then
    element.Id := jsn['id']
  else if jsn.has('_id') then
    element.Id := jsn['_id'];
  if jsn.has('extension') then
    iterateArray(jsn.vArr['extension'], element.extensionList, parseExtension);
end;

procedure TFHIRJsonParser.ParseBackboneElementProperties(jsn : TJsonObject; element : TFhirBackboneElement);
begin
  parseElementProperties(jsn, element);

  if jsn.has('modifierExtension') then
    iterateArray(jsn.vArr['modifierExtension'], element.modifierExtensionList, parseExtension);
end;

Procedure TFHIRXmlComposer.ComposeElementAttributes(xml : TXmlBuilder; element : TFhirElement);
begin
  CommentsStart(xml, element);
  Attribute(xml, 'id', element.Id);
end;

Procedure TFHIRXmlComposer.ComposeElementChildren(xml : TXmlBuilder; element : TFhirElement);
var
  i : integer;
begin
  if element.hasExtensionList then
    for i := 0 to element.extensionList.count - 1 do
      ComposeExtension(xml, 'extension', element.extensionList[i]);
end;

Procedure TFHIRXmlComposer.ComposeBackboneElementChildren(xml : TXmlBuilder; element : TFhirBackboneElement);
var
  i : integer;
begin
  ComposeElementChildren(xml, element);
  if element.hasModifierExtensionList then
    for i := 0 to element.modifierExtensionList.count - 1 do
      ComposeExtension(xml, 'modifierExtension', element.modifierExtensionList[i]);
end;

Procedure TFHIRJsonComposer.ComposeElementProperties(json : TJSONWriter; elem : TFhirElement);
var
  i : integer;
begin
  composeComments(json, elem);
  Prop(json, 'id', elem.Id);
  if elem.hasExtensionList then
  begin
    json.valueArray('extension');
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(json, '',elem.extensionList[i]);
    json.FinishArray;
  end;
end;

Procedure TFHIRJsonComposer.ComposeBackboneElementProperties(json : TJSONWriter; elem : TFhirBackboneElement);
var
  i : integer;
begin
  ComposeElementProperties(json, elem);
  if elem.hasModifierExtensionList then
  begin
    json.valueArray('modifierExtension');
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(json, '', elem.modifierExtensionList[i]);
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseEnum(Const aNames : Array Of String; path : String; element : IXmlDomElement) : TFhirEnum;
var
  child : IXMLDOMElement;
begin
  result := TFhirEnum.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    if StringArrayIndexOfSensitive(aNames, result.value) < 0 then
      raise Exception.create('unknown code: '+result.value+' from a set of choices of '+StringArrayToCommaString(aNames)+' for "'+path+'"');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEnum(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList; Const aNames : Array Of String);
begin
  ctxt.add(ParseEnum(value, jsn, aNames));
end;

function TFHIRJsonParser.ParseEnum(value : string; jsn : TJsonObject; Const aNames : Array Of String) : TFHIREnum;
begin
  if StringArrayIndexOfSensitive(aNames, value) < 0 then
    raise Exception.create('unknown code: '+value+' from a set of choices of '+StringArrayToCommaString(aNames)+' for "'+jsn.path+'"');
  result := TFHIREnum.create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeEnum(xml : TXmlBuilder; name : String; value : TFhirEnum; Const aNames : Array Of String);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeEnumValue(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
begin
  if (value = nil) or (value.Value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeEnumProps(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseInteger(element : IXmlDomElement; path : string) : TFhirInteger;
var
  child : IXMLDOMElement;
begin
  result := TFhirInteger.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInteger(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInteger(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseInteger(value : string; jsn : TJsonObject) : TFHIRInteger;
begin
  result := TFhirInteger.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeInteger(xml : TXmlBuilder; name : String; value : TFhirInteger);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeIntegerValue(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    propNumber(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeIntegerProps(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseDateTime(element : IXmlDomElement; path : string) : TFhirDateTime;
var
  child : IXMLDOMElement;
begin
  result := TFhirDateTime.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTDateAndTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDateTime(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDateTime(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseDateTime(value : string; jsn : TJsonObject) : TFHIRDateTime;
begin
  result := TFhirDateTime.Create;
  try
     result.value := toTDateAndTime(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDateTime(xml : TXmlBuilder; name : String; value : TFhirDateTime);
begin
  if (value = nil) or (value.value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', asString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeDateTimeValue(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
begin
  if (value = nil) or (value.value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeDateTimeProps(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseDate(element : IXmlDomElement; path : string) : TFhirDate;
var
  child : IXMLDOMElement;
begin
  result := TFhirDate.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTDateAndTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDate(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDate(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseDate(value : string; jsn : TJsonObject) : TFHIRDate;
begin
  result := TFhirDate.Create;
  try
     result.value := toTDateAndTime(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDate(xml : TXmlBuilder; name : String; value : TFhirDate);
begin
  if (value = nil) or (value.value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', asString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeDateValue(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
begin
  if (value = nil) or (value.value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeDateProps(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseDecimal(element : IXmlDomElement; path : string) : TFhirDecimal;
var
  child : IXMLDOMElement;
begin
  result := TFhirDecimal.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDecimal(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDecimal(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseDecimal(value : string; jsn : TJsonObject) : TFHIRDecimal;
begin
  result := TFhirDecimal.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDecimal(xml : TXmlBuilder; name : String; value : TFhirDecimal);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeDecimalValue(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    propNumber(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeDecimalProps(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseUri(element : IXmlDomElement; path : string) : TFhirUri;
var
  child : IXMLDOMElement;
begin
  result := TFhirUri.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseUri(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUri(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseUri(value : string; jsn : TJsonObject) : TFHIRUri;
begin
  result := TFhirUri.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUri(xml : TXmlBuilder; name : String; value : TFhirUri);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeUriValue(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeUriProps(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseBase64Binary(element : IXmlDomElement; path : string) : TFhirBase64Binary;
var
  child : IXMLDOMElement;
begin
  result := TFhirBase64Binary.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTBytes(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBase64Binary(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBase64Binary(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseBase64Binary(value : string; jsn : TJsonObject) : TFHIRBase64Binary;
begin
  result := TFhirBase64Binary.Create;
  try
     result.value := toTBytes(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeBase64Binary(xml : TXmlBuilder; name : String; value : TFhirBase64Binary);
begin
  if (value = nil) or (value.value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', asString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeBase64BinaryValue(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
begin
  if (value = nil) or (value.value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeBase64BinaryProps(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseTime(element : IXmlDomElement; path : string) : TFhirTime;
var
  child : IXMLDOMElement;
begin
  result := TFhirTime.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTime(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTime(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseTime(value : string; jsn : TJsonObject) : TFHIRTime;
begin
  result := TFhirTime.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeTime(xml : TXmlBuilder; name : String; value : TFhirTime);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeTimeValue(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeTimeProps(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseString(element : IXmlDomElement; path : string) : TFhirString;
var
  child : IXMLDOMElement;
begin
  result := TFhirString.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseString(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseString(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseString(value : string; jsn : TJsonObject) : TFHIRString;
begin
  result := TFhirString.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeString(xml : TXmlBuilder; name : String; value : TFhirString);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeStringValue(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeStringProps(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseBoolean(element : IXmlDomElement; path : string) : TFhirBoolean;
var
  child : IXMLDOMElement;
begin
  result := TFhirBoolean.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := StringToBoolean(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBoolean(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBoolean(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseBoolean(value : string; jsn : TJsonObject) : TFHIRBoolean;
begin
  result := TFhirBoolean.Create;
  try
    result.value := StringToBoolean(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeBoolean(xml : TXmlBuilder; name : String; value : TFhirBoolean);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', LCBooleanToString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeBooleanValue(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
begin
  if (value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeBooleanProps(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseInstant(element : IXmlDomElement; path : string) : TFhirInstant;
var
  child : IXMLDOMElement;
begin
  result := TFhirInstant.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTDateAndTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInstant(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInstant(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseInstant(value : string; jsn : TJsonObject) : TFHIRInstant;
begin
  result := TFhirInstant.Create;
  try
     result.value := toTDateAndTime(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeInstant(xml : TXmlBuilder; name : String; value : TFhirInstant);
begin
  if (value = nil) or (value.value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', asString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeInstantValue(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
begin
  if (value = nil) or (value.value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeInstantProps(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseUnsignedInt(element : IXmlDomElement; path : string) : TFhirUnsignedInt;
var
  child : IXMLDOMElement;
begin
  result := TFhirUnsignedInt.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseUnsignedInt(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUnsignedInt(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseUnsignedInt(value : string; jsn : TJsonObject) : TFHIRUnsignedInt;
begin
  result := TFhirUnsignedInt.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUnsignedInt(xml : TXmlBuilder; name : String; value : TFhirUnsignedInt);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeUnsignedIntValue(json : TJSONWriter; name : String; value : TFhirUnsignedInt; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    propNumber(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeUnsignedIntProps(json : TJSONWriter; name : String; value : TFhirUnsignedInt; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseCode(element : IXmlDomElement; path : string) : TFhirCode;
var
  child : IXMLDOMElement;
begin
  result := TFhirCode.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCode(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCode(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseCode(value : string; jsn : TJsonObject) : TFHIRCode;
begin
  result := TFhirCode.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeCode(xml : TXmlBuilder; name : String; value : TFhirCode);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeCodeValue(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeCodeProps(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseId(element : IXmlDomElement; path : string) : TFhirId;
var
  child : IXMLDOMElement;
begin
  result := TFhirId.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseId(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseId(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseId(value : string; jsn : TJsonObject) : TFHIRId;
begin
  result := TFhirId.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeId(xml : TXmlBuilder; name : String; value : TFhirId);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeIdValue(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeIdProps(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseOid(element : IXmlDomElement; path : string) : TFhirOid;
var
  child : IXMLDOMElement;
begin
  result := TFhirOid.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOid(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOid(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseOid(value : string; jsn : TJsonObject) : TFHIROid;
begin
  result := TFhirOid.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeOid(xml : TXmlBuilder; name : String; value : TFhirOid);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeOidValue(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeOidProps(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParsePositiveInt(element : IXmlDomElement; path : string) : TFhirPositiveInt;
var
  child : IXMLDOMElement;
begin
  result := TFhirPositiveInt.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePositiveInt(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePositiveInt(value, jsn)) {1};
end;

function TFHIRJsonParser.ParsePositiveInt(value : string; jsn : TJsonObject) : TFHIRPositiveInt;
begin
  result := TFhirPositiveInt.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposePositiveInt(xml : TXmlBuilder; name : String; value : TFhirPositiveInt);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposePositiveIntValue(json : TJSONWriter; name : String; value : TFhirPositiveInt; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    propNumber(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposePositiveIntProps(json : TJSONWriter; name : String; value : TFhirPositiveInt; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseUuid(element : IXmlDomElement; path : string) : TFhirUuid;
var
  child : IXMLDOMElement;
begin
  result := TFhirUuid.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseUuid(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUuid(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseUuid(value : string; jsn : TJsonObject) : TFHIRUuid;
begin
  result := TFhirUuid.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUuid(xml : TXmlBuilder; name : String; value : TFhirUuid);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeUuidValue(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeUuidProps(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRXmlParser.ParseResourceAttributes(resource : TFhirResource; path : string; element : IXmlDomElement);
begin
end;

Function TFHIRXmlParser.ParseResourceChild(resource : TFhirResource; path : string; child : IXmlDomElement) : boolean;
begin
  result := true;
  if (child.baseName = 'id') then
    resource.idElement := ParseId(child, path+'/id') {b}
  else if (child.baseName = 'meta') then
    resource.meta := ParseMeta(child, path+'/meta') {b}
  else if (child.baseName = 'implicitRules') then
    resource.implicitRulesElement := ParseUri(child, path+'/implicitRules') {b}
  else if (child.baseName = 'language') then
    resource.languageElement := ParseCode(child, path+'/language') {b}
  else
    result := false;
end;

procedure TFHIRJsonParser.ParseResourceProperties(jsn : TJsonObject; resource : TFhirResource);
begin
  if jsn.has('id') or jsn.has('_id') then
    resource.idElement := ParseId(jsn['id'], jsn.vObj['_id']);{q}
  if jsn.has('meta') then
    resource.meta := ParseMeta(jsn.vObj['meta']);{q}
  if jsn.has('implicitRules') or jsn.has('_implicitRules') then
    resource.implicitRulesElement := ParseUri(jsn['implicitRules'], jsn.vObj['_implicitRules']);{q}
  if jsn.has('language') or jsn.has('_language') then
    resource.languageElement := ParseCode(jsn['language'], jsn.vObj['_language']);{q}
end;

Procedure TFHIRXmlComposer.ComposeResourceAttributes(xml : TXmlBuilder; resource : TFhirResource);
begin
end;

Procedure TFHIRXmlComposer.ComposeResourceChildren(xml : TXmlBuilder; elem : TFhirResource);
var
  i : integer;
begin
  ComposeId(xml, 'id', elem.idElement);{x.2}
  ComposeMeta(xml, 'meta', elem.meta);{x.2}
  ComposeUri(xml, 'implicitRules', elem.implicitRulesElement);{x.2}
  ComposeCode(xml, 'language', elem.languageElement);{x.2}
end;

Procedure TFHIRJsonComposer.ComposeResourceProperties(json : TJSONWriter; elem : TFhirResource);
var
  i : integer;
begin
  ComposeIdValue(json, 'id', elem.idElement, false);
  ComposeIdProps(json, 'id', elem.idElement, false);
  ComposeMeta(json, 'meta', elem.meta); {a}
  ComposeUriValue(json, 'implicitRules', elem.implicitRulesElement, false);
  ComposeUriProps(json, 'implicitRules', elem.implicitRulesElement, false);
  ComposeCodeValue(json, 'language', elem.languageElement, false);
  ComposeCodeProps(json, 'language', elem.languageElement, false);
end;

Procedure TFHIRXmlParser.ParseDomainResourceAttributes(resource : TFhirDomainResource; path : string; element : IXmlDomElement);
begin
  ParseResourceAttributes(resource, path, element);
end;

Function TFHIRXmlParser.ParseDomainResourceChild(resource : TFhirDomainResource; path : string; child : IXmlDomElement) : boolean;
begin
  result := true;
  if (child.baseName = 'text') then
    resource.text := ParseNarrative(child, path+'/text') {b}
  else if (child.baseName = 'contained') then
    resource.containedList.Add(ParseInnerResource(child, path+'/contained')){y.2}
  else if (child.baseName = 'extension') then
    resource.extensionList.Add(ParseExtension(child, path+'/extension')){y.2}
  else if (child.baseName = 'modifierExtension') then
    resource.modifierExtensionList.Add(ParseExtension(child, path+'/modifierExtension')){y.2}
  else if not parseResourceChild(resource, path, child) then
    result := false;
end;

procedure TFHIRJsonParser.ParseDomainResourceProperties(jsn : TJsonObject; resource : TFhirDomainResource);
begin
  ParseResourceProperties(jsn, resource);
  if jsn.has('text') then
    resource.text := ParseNarrative(jsn.vObj['text']);{q}
  if jsn.has('contained') then
    iterateArray(jsn.vArr['contained'], resource.containedList, parseInnerResource);
  if jsn.has('extension') then
    iterateArray(jsn.vArr['extension'], resource.extensionList, parseExtension);
  if jsn.has('modifierExtension') then
    iterateArray(jsn.vArr['modifierExtension'], resource.modifierExtensionList, parseExtension);
end;

Procedure TFHIRXmlComposer.ComposeDomainResourceAttributes(xml : TXmlBuilder; resource : TFhirDomainResource);
begin
  ComposeResourceAttributes(xml, resource);
end;

Procedure TFHIRXmlComposer.ComposeDomainResourceChildren(xml : TXmlBuilder; elem : TFhirDomainResource);
var
  i : integer;
begin
  composeResourceChildren(xml, elem);
  ComposeNarrative(xml, 'text', elem.text);{x.2}
  for i := 0 to elem.containedList.Count - 1 do
    ComposeInnerResource(xml, 'contained', elem.containedList[i]);
  for i := 0 to elem.extensionList.Count - 1 do
    ComposeExtension(xml, 'extension', elem.extensionList[i]);
  for i := 0 to elem.modifierExtensionList.Count - 1 do
    ComposeExtension(xml, 'modifierExtension', elem.modifierExtensionList[i]);
end;

Procedure TFHIRJsonComposer.ComposeDomainResourceProperties(json : TJSONWriter; elem : TFhirDomainResource);
var
  i : integer;
begin
  ComposeResourceProperties(json, elem);
  ComposeNarrative(json, 'text', elem.text); {a}
  if elem.containedList.Count > 0 then
  begin
    json.valueArray('contained');
    for i := 0 to elem.containedList.Count - 1 do
      ComposeInnerResource(json, '',elem.containedList[i]); {z - Resource}
    json.FinishArray;
  end;
  if elem.extensionList.Count > 0 then
  begin
    json.valueArray('extension');
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(json, '',elem.extensionList[i]); {z - Extension}
    json.FinishArray;
  end;
  if elem.modifierExtensionList.Count > 0 then
  begin
    json.valueArray('modifierExtension');
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(json, '',elem.modifierExtensionList[i]); {z - Extension}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseParametersParameter(element : IXmlDomElement; path : string) : TFhirParametersParameter;
var
  child : IXMLDOMElement;
begin
  result := TFhirParametersParameter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'valueInteger') then
        result.value := ParseInteger(child, path+'.valueInteger') {c}
      else if (child.baseName = 'valueDateTime') then
        result.value := ParseDateTime(child, path+'.valueDateTime') {c}
      else if (child.baseName = 'valueUnsignedInt') then
        result.value := ParseUnsignedInt(child, path+'.valueUnsignedInt') {c}
      else if (child.baseName = 'valueCode') then
        result.value := ParseCode(child, path+'.valueCode') {c}
      else if (child.baseName = 'valueDate') then
        result.value := ParseDate(child, path+'.valueDate') {c}
      else if (child.baseName = 'valueDecimal') then
        result.value := ParseDecimal(child, path+'.valueDecimal') {c}
      else if (child.baseName = 'valueUri') then
        result.value := ParseUri(child, path+'.valueUri') {c}
      else if (child.baseName = 'valueId') then
        result.value := ParseId(child, path+'.valueId') {c}
      else if (child.baseName = 'valueBase64Binary') then
        result.value := ParseBase64Binary(child, path+'.valueBase64Binary') {c}
      else if (child.baseName = 'valueTime') then
        result.value := ParseTime(child, path+'.valueTime') {c}
      else if (child.baseName = 'valueOid') then
        result.value := ParseOid(child, path+'.valueOid') {c}
      else if (child.baseName = 'valuePositiveInt') then
        result.value := ParsePositiveInt(child, path+'.valuePositiveInt') {c}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'.valueString') {c}
      else if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'.valueBoolean') {c}
      else if (child.baseName = 'valueUuid') then
        result.value := ParseUuid(child, path+'.valueUuid') {c}
      else if (child.baseName = 'valueInstant') then
        result.value := ParseInstant(child, path+'.valueInstant') {c}
      else if (child.baseName = 'valuePeriod') then
        result.value := ParsePeriod(child, path+'.valuePeriod') {ePeriod}
      else if (child.baseName = 'valueCoding') then
        result.value := ParseCoding(child, path+'.valueCoding') {eCoding}
      else if (child.baseName = 'valueRange') then
        result.value := ParseRange(child, path+'.valueRange') {eRange}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'.valueQuantity') {eQuantity}
      else if (child.baseName = 'valueAttachment') then
        result.value := ParseAttachment(child, path+'.valueAttachment') {eAttachment}
      else if (child.baseName = 'valueRatio') then
        result.value := ParseRatio(child, path+'.valueRatio') {eRatio}
      else if (child.baseName = 'valueSampledData') then
        result.value := ParseSampledData(child, path+'.valueSampledData') {eSampledData}
      else if (child.baseName = 'valueReference') then
        result.value := ParseReference(child, path+'.valueReference') {eReference}
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'.valueCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'valueIdentifier') then
        result.value := ParseIdentifier(child, path+'.valueIdentifier') {eIdentifier}
      else if (child.baseName = 'valueSignature') then
        result.value := ParseSignature(child, path+'.valueSignature') {eSignature}
      else if (child.baseName = 'valueElementDefinition') then
        result.value := ParseElementDefinition(child, path+'/valueElementDefinition') {f}
      else if (child.baseName = 'valueTiming') then
        result.value := ParseTiming(child, path+'/valueTiming') {f}
      else if (child.baseName = 'valueAddress') then
        result.value := ParseAddress(child, path+'/valueAddress') {f}
      else if (child.baseName = 'valueHumanName') then
        result.value := ParseHumanName(child, path+'/valueHumanName') {f}
      else if (child.baseName = 'valueMeta') then
        result.value := ParseMeta(child, path+'/valueMeta') {f}
      else if (child.baseName = 'valueContactPoint') then
        result.value := ParseContactPoint(child, path+'/valueContactPoint') {f}
      else if (child.baseName = 'resource') then
        result.resource := ParseInnerResource(child, path+'/resource') {b}
      else if (child.baseName = 'part') then
        result.partList.Add(ParseParametersParameterPart(child, path+'/part')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeParametersParameter(xml : TXmlBuilder; name : string; elem : TFhirParametersParameter);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (elem.value is TFhirInteger) {1} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (elem.value is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (elem.value is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(elem.value))
  else if (elem.value is TFhirCode) {1} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (elem.value is TFhirDate) {1} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (elem.value is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (elem.value is TFhirUri) {1} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value))
  else if (elem.value is TFhirId) {1} then
    ComposeId(xml, 'valueId', TFhirId(elem.value))
  else if (elem.value is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(elem.value))
  else if (elem.value is TFhirTime) {1} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (elem.value is TFhirOid) {1} then
    ComposeOid(xml, 'valueOid', TFhirOid(elem.value))
  else if (elem.value is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(elem.value))
  else if (elem.value is TFhirString) {1} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (elem.value is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirUuid) {1} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(elem.value))
  else if (elem.value is TFhirInstant) {1} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (elem.value is TFhirPeriod) {8} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirCoding) {8} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirRange) {8} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirRatio) {8} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirReference) {8} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (elem.value is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (elem.value is TFhirSignature) {8} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(elem.value))
  else if (elem.value is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'valueElementDefinition', TFhirElementDefinition(elem.value))
  else if (elem.value is TFhirTiming) {9} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(elem.value))
  else if (elem.value is TFhirAddress) {9} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(elem.value))
  else if (elem.value is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(elem.value))
  else if (elem.value is TFhirMeta) {9} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(elem.value))
  else if (elem.value is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(elem.value));
  ComposeInnerResource(xml, 'resource', elem.resource);{x.2}
  for i := 0 to elem.partList.Count - 1 do
    ComposeParametersParameterPart(xml, 'part', elem.partList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseParametersParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseParametersParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseParametersParameter(jsn : TJsonObject) : TFhirParametersParameter;
begin
  result := TFhirParametersParameter.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
        result.value := ParseInteger(jsn['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
        result.value := ParseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueUnsignedInt') or jsn.has('_valueUnsignedInt') then
        result.value := ParseUnsignedInt(jsn['valueUnsignedInt'], jsn.vObj['_valueUnsignedInt']);
    if jsn.has('valueCode') or jsn.has('_valueCode') then
        result.value := ParseCode(jsn['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
        result.value := ParseDate(jsn['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
        result.value := ParseDecimal(jsn['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
        result.value := ParseUri(jsn['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('valueId') or jsn.has('_valueId') then
        result.value := ParseId(jsn['valueId'], jsn.vObj['_valueId']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
        result.value := ParseBase64Binary(jsn['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
        result.value := ParseTime(jsn['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueOid') or jsn.has('_valueOid') then
        result.value := ParseOid(jsn['valueOid'], jsn.vObj['_valueOid']);
    if jsn.has('valuePositiveInt') or jsn.has('_valuePositiveInt') then
        result.value := ParsePositiveInt(jsn['valuePositiveInt'], jsn.vObj['_valuePositiveInt']);
    if jsn.has('valueString') or jsn.has('_valueString') then
        result.value := ParseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
        result.value := ParseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
        result.value := ParseUuid(jsn['valueUuid'], jsn.vObj['_valueUuid']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
        result.value := ParseInstant(jsn['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valuePeriod') {a7} then
        result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueCoding') {a7} then
        result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueRange') {a7} then
        result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueQuantity') {a7} then
        result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueAttachment') {a7} then
        result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueRatio') {a7} then
        result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueSampledData') {a7} then
        result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueReference') {a7} then
        result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueCodeableConcept') {a7} then
        result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueIdentifier') {a7} then
        result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if jsn.has('valueSignature') {a7} then
        result.value := ParseSignature(jsn.vObj['valueSignature']);
    if jsn.has('valueElementDefinition') {a9} then
        result.value := ParseElementDefinition(jsn.vObj['valueElementDefinition']);
    if jsn.has('valueTiming') {a9} then
        result.value := ParseTiming(jsn.vObj['valueTiming']);
    if jsn.has('valueAddress') {a9} then
        result.value := ParseAddress(jsn.vObj['valueAddress']);
    if jsn.has('valueHumanName') {a9} then
        result.value := ParseHumanName(jsn.vObj['valueHumanName']);
    if jsn.has('valueMeta') {a9} then
        result.value := ParseMeta(jsn.vObj['valueMeta']);
    if jsn.has('valueContactPoint') {a9} then
        result.value := ParseContactPoint(jsn.vObj['valueContactPoint']);
    if jsn.has('resource') then
        result.resource := ParseInnerResource(jsn.vObj['resource']);{q}
    if jsn.has('part') then
      iterateArray(jsn.vArr['part'], result.partList, parseParametersParameterPart);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeParametersParameter(json : TJSONWriter; name : string; elem : TFhirParametersParameter; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (elem.value is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false)
  end
  else if (elem.value is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false)
  end
  else if (elem.value is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false);
    ComposeUnsignedIntProps(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false)
  end
  else if (elem.value is TFhirCode) then
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false)
  end
  else if (elem.value is TFhirDate) then
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false)
  end
  else if (elem.value is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false)
  end
  else if (elem.value is TFhirUri) then
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false)
  end
  else if (elem.value is TFhirId) then
  begin
    ComposeIdValue(json, 'valueId', TFhirId(elem.value), false);
    ComposeIdProps(json, 'valueId', TFhirId(elem.value), false)
  end
  else if (elem.value is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false)
  end
  else if (elem.value is TFhirTime) then
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false)
  end
  else if (elem.value is TFhirOid) then
  begin
    ComposeOidValue(json, 'valueOid', TFhirOid(elem.value), false);
    ComposeOidProps(json, 'valueOid', TFhirOid(elem.value), false)
  end
  else if (elem.value is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false);
    ComposePositiveIntProps(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false)
  end
  else if (elem.value is TFhirString) then
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false)
  end
  else if (elem.value is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false)
  end
  else if (elem.value is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'valueUuid', TFhirUuid(elem.value), false);
    ComposeUuidProps(json, 'valueUuid', TFhirUuid(elem.value), false)
  end
  else if (elem.value is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false)
  end
  else if (elem.value is TFhirPeriod) then
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirCoding) then
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirRange) then
    ComposeRange(json, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirQuantity) then
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirAttachment) then
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirRatio) then
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirSampledData) then
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value))
  else if (elem.value is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirIdentifier) then
    ComposeIdentifier(json, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (elem.value is TFhirSignature) then
    ComposeSignature(json, 'valueSignature', TFhirSignature(elem.value))
  else if (elem.value is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'valueElementDefinition', TFhirElementDefinition(elem.value))
  else if (elem.value is TFhirTiming) then
    ComposeTiming(json, 'valueTiming', TFhirTiming(elem.value))
  else if (elem.value is TFhirAddress) then
    ComposeAddress(json, 'valueAddress', TFhirAddress(elem.value))
  else if (elem.value is TFhirHumanName) then
    ComposeHumanName(json, 'valueHumanName', TFhirHumanName(elem.value))
  else if (elem.value is TFhirMeta) then
    ComposeMeta(json, 'valueMeta', TFhirMeta(elem.value))
  else if (elem.value is TFhirContactPoint) then
    ComposeContactPoint(json, 'valueContactPoint', TFhirContactPoint(elem.value));
  ComposeInnerResource(json, 'resource', elem.resource); {a}
  if elem.partList.Count > 0 then
  begin
    json.valueArray('part');
    for i := 0 to elem.partList.Count - 1 do
      ComposeParametersParameterPart(json, '',elem.partList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseParametersParameterPart(element : IXmlDomElement; path : string) : TFhirParametersParameterPart;
var
  child : IXMLDOMElement;
begin
  result := TFhirParametersParameterPart.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'valueInteger') then
        result.value := ParseInteger(child, path+'.valueInteger') {c}
      else if (child.baseName = 'valueDateTime') then
        result.value := ParseDateTime(child, path+'.valueDateTime') {c}
      else if (child.baseName = 'valueUnsignedInt') then
        result.value := ParseUnsignedInt(child, path+'.valueUnsignedInt') {c}
      else if (child.baseName = 'valueCode') then
        result.value := ParseCode(child, path+'.valueCode') {c}
      else if (child.baseName = 'valueDate') then
        result.value := ParseDate(child, path+'.valueDate') {c}
      else if (child.baseName = 'valueDecimal') then
        result.value := ParseDecimal(child, path+'.valueDecimal') {c}
      else if (child.baseName = 'valueUri') then
        result.value := ParseUri(child, path+'.valueUri') {c}
      else if (child.baseName = 'valueId') then
        result.value := ParseId(child, path+'.valueId') {c}
      else if (child.baseName = 'valueBase64Binary') then
        result.value := ParseBase64Binary(child, path+'.valueBase64Binary') {c}
      else if (child.baseName = 'valueTime') then
        result.value := ParseTime(child, path+'.valueTime') {c}
      else if (child.baseName = 'valueOid') then
        result.value := ParseOid(child, path+'.valueOid') {c}
      else if (child.baseName = 'valuePositiveInt') then
        result.value := ParsePositiveInt(child, path+'.valuePositiveInt') {c}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'.valueString') {c}
      else if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'.valueBoolean') {c}
      else if (child.baseName = 'valueUuid') then
        result.value := ParseUuid(child, path+'.valueUuid') {c}
      else if (child.baseName = 'valueInstant') then
        result.value := ParseInstant(child, path+'.valueInstant') {c}
      else if (child.baseName = 'valuePeriod') then
        result.value := ParsePeriod(child, path+'.valuePeriod') {ePeriod}
      else if (child.baseName = 'valueCoding') then
        result.value := ParseCoding(child, path+'.valueCoding') {eCoding}
      else if (child.baseName = 'valueRange') then
        result.value := ParseRange(child, path+'.valueRange') {eRange}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'.valueQuantity') {eQuantity}
      else if (child.baseName = 'valueAttachment') then
        result.value := ParseAttachment(child, path+'.valueAttachment') {eAttachment}
      else if (child.baseName = 'valueRatio') then
        result.value := ParseRatio(child, path+'.valueRatio') {eRatio}
      else if (child.baseName = 'valueSampledData') then
        result.value := ParseSampledData(child, path+'.valueSampledData') {eSampledData}
      else if (child.baseName = 'valueReference') then
        result.value := ParseReference(child, path+'.valueReference') {eReference}
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'.valueCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'valueIdentifier') then
        result.value := ParseIdentifier(child, path+'.valueIdentifier') {eIdentifier}
      else if (child.baseName = 'valueSignature') then
        result.value := ParseSignature(child, path+'.valueSignature') {eSignature}
      else if (child.baseName = 'valueElementDefinition') then
        result.value := ParseElementDefinition(child, path+'/valueElementDefinition') {f}
      else if (child.baseName = 'valueTiming') then
        result.value := ParseTiming(child, path+'/valueTiming') {f}
      else if (child.baseName = 'valueAddress') then
        result.value := ParseAddress(child, path+'/valueAddress') {f}
      else if (child.baseName = 'valueHumanName') then
        result.value := ParseHumanName(child, path+'/valueHumanName') {f}
      else if (child.baseName = 'valueMeta') then
        result.value := ParseMeta(child, path+'/valueMeta') {f}
      else if (child.baseName = 'valueContactPoint') then
        result.value := ParseContactPoint(child, path+'/valueContactPoint') {f}
      else if (child.baseName = 'resource') then
        result.resource := ParseInnerResource(child, path+'/resource') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeParametersParameterPart(xml : TXmlBuilder; name : string; elem : TFhirParametersParameterPart);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (elem.value is TFhirInteger) {1} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (elem.value is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (elem.value is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(elem.value))
  else if (elem.value is TFhirCode) {1} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (elem.value is TFhirDate) {1} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (elem.value is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (elem.value is TFhirUri) {1} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value))
  else if (elem.value is TFhirId) {1} then
    ComposeId(xml, 'valueId', TFhirId(elem.value))
  else if (elem.value is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(elem.value))
  else if (elem.value is TFhirTime) {1} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (elem.value is TFhirOid) {1} then
    ComposeOid(xml, 'valueOid', TFhirOid(elem.value))
  else if (elem.value is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(elem.value))
  else if (elem.value is TFhirString) {1} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (elem.value is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirUuid) {1} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(elem.value))
  else if (elem.value is TFhirInstant) {1} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (elem.value is TFhirPeriod) {8} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirCoding) {8} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirRange) {8} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirRatio) {8} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirReference) {8} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (elem.value is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (elem.value is TFhirSignature) {8} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(elem.value))
  else if (elem.value is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'valueElementDefinition', TFhirElementDefinition(elem.value))
  else if (elem.value is TFhirTiming) {9} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(elem.value))
  else if (elem.value is TFhirAddress) {9} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(elem.value))
  else if (elem.value is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(elem.value))
  else if (elem.value is TFhirMeta) {9} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(elem.value))
  else if (elem.value is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(elem.value));
  ComposeInnerResource(xml, 'resource', elem.resource);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseParametersParameterPart(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseParametersParameterPart(jsn)); {2}
end;

function TFHIRJsonParser.ParseParametersParameterPart(jsn : TJsonObject) : TFhirParametersParameterPart;
begin
  result := TFhirParametersParameterPart.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
        result.value := ParseInteger(jsn['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
        result.value := ParseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueUnsignedInt') or jsn.has('_valueUnsignedInt') then
        result.value := ParseUnsignedInt(jsn['valueUnsignedInt'], jsn.vObj['_valueUnsignedInt']);
    if jsn.has('valueCode') or jsn.has('_valueCode') then
        result.value := ParseCode(jsn['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
        result.value := ParseDate(jsn['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
        result.value := ParseDecimal(jsn['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
        result.value := ParseUri(jsn['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('valueId') or jsn.has('_valueId') then
        result.value := ParseId(jsn['valueId'], jsn.vObj['_valueId']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
        result.value := ParseBase64Binary(jsn['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
        result.value := ParseTime(jsn['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueOid') or jsn.has('_valueOid') then
        result.value := ParseOid(jsn['valueOid'], jsn.vObj['_valueOid']);
    if jsn.has('valuePositiveInt') or jsn.has('_valuePositiveInt') then
        result.value := ParsePositiveInt(jsn['valuePositiveInt'], jsn.vObj['_valuePositiveInt']);
    if jsn.has('valueString') or jsn.has('_valueString') then
        result.value := ParseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
        result.value := ParseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
        result.value := ParseUuid(jsn['valueUuid'], jsn.vObj['_valueUuid']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
        result.value := ParseInstant(jsn['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valuePeriod') {a7} then
        result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueCoding') {a7} then
        result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueRange') {a7} then
        result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueQuantity') {a7} then
        result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueAttachment') {a7} then
        result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueRatio') {a7} then
        result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueSampledData') {a7} then
        result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueReference') {a7} then
        result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueCodeableConcept') {a7} then
        result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueIdentifier') {a7} then
        result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if jsn.has('valueSignature') {a7} then
        result.value := ParseSignature(jsn.vObj['valueSignature']);
    if jsn.has('valueElementDefinition') {a9} then
        result.value := ParseElementDefinition(jsn.vObj['valueElementDefinition']);
    if jsn.has('valueTiming') {a9} then
        result.value := ParseTiming(jsn.vObj['valueTiming']);
    if jsn.has('valueAddress') {a9} then
        result.value := ParseAddress(jsn.vObj['valueAddress']);
    if jsn.has('valueHumanName') {a9} then
        result.value := ParseHumanName(jsn.vObj['valueHumanName']);
    if jsn.has('valueMeta') {a9} then
        result.value := ParseMeta(jsn.vObj['valueMeta']);
    if jsn.has('valueContactPoint') {a9} then
        result.value := ParseContactPoint(jsn.vObj['valueContactPoint']);
    if jsn.has('resource') then
        result.resource := ParseInnerResource(jsn.vObj['resource']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeParametersParameterPart(json : TJSONWriter; name : string; elem : TFhirParametersParameterPart; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (elem.value is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false)
  end
  else if (elem.value is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false)
  end
  else if (elem.value is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false);
    ComposeUnsignedIntProps(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false)
  end
  else if (elem.value is TFhirCode) then
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false)
  end
  else if (elem.value is TFhirDate) then
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false)
  end
  else if (elem.value is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false)
  end
  else if (elem.value is TFhirUri) then
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false)
  end
  else if (elem.value is TFhirId) then
  begin
    ComposeIdValue(json, 'valueId', TFhirId(elem.value), false);
    ComposeIdProps(json, 'valueId', TFhirId(elem.value), false)
  end
  else if (elem.value is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false)
  end
  else if (elem.value is TFhirTime) then
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false)
  end
  else if (elem.value is TFhirOid) then
  begin
    ComposeOidValue(json, 'valueOid', TFhirOid(elem.value), false);
    ComposeOidProps(json, 'valueOid', TFhirOid(elem.value), false)
  end
  else if (elem.value is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false);
    ComposePositiveIntProps(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false)
  end
  else if (elem.value is TFhirString) then
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false)
  end
  else if (elem.value is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false)
  end
  else if (elem.value is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'valueUuid', TFhirUuid(elem.value), false);
    ComposeUuidProps(json, 'valueUuid', TFhirUuid(elem.value), false)
  end
  else if (elem.value is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false)
  end
  else if (elem.value is TFhirPeriod) then
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirCoding) then
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirRange) then
    ComposeRange(json, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirQuantity) then
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirAttachment) then
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirRatio) then
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirSampledData) then
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value))
  else if (elem.value is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirIdentifier) then
    ComposeIdentifier(json, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (elem.value is TFhirSignature) then
    ComposeSignature(json, 'valueSignature', TFhirSignature(elem.value))
  else if (elem.value is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'valueElementDefinition', TFhirElementDefinition(elem.value))
  else if (elem.value is TFhirTiming) then
    ComposeTiming(json, 'valueTiming', TFhirTiming(elem.value))
  else if (elem.value is TFhirAddress) then
    ComposeAddress(json, 'valueAddress', TFhirAddress(elem.value))
  else if (elem.value is TFhirHumanName) then
    ComposeHumanName(json, 'valueHumanName', TFhirHumanName(elem.value))
  else if (elem.value is TFhirMeta) then
    ComposeMeta(json, 'valueMeta', TFhirMeta(elem.value))
  else if (elem.value is TFhirContactPoint) then
    ComposeContactPoint(json, 'valueContactPoint', TFhirContactPoint(elem.value));
  ComposeInnerResource(json, 'resource', elem.resource); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseParameters(element : IXmlDomElement; path : string) : TFhirParameters;
var
  child : IXMLDOMElement;
begin
  result := TFhirParameters.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'parameter') then
        result.parameterList.Add(ParseParametersParameter(child, path+'/parameter')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeParameters(xml : TXmlBuilder; name : string; elem : TFhirParameters);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.parameterList.Count - 1 do
    ComposeParametersParameter(xml, 'parameter', elem.parameterList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseParameters(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseParameters(jsn)); {2}
end;

function TFHIRJsonParser.ParseParameters(jsn : TJsonObject) : TFhirParameters;
begin
  result := TFhirParameters.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseParametersParameter);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeParameters(json : TJSONWriter; name : string; elem : TFhirParameters; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.parameterList.Count > 0 then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeParametersParameter(json, '',elem.parameterList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseExtension(element : IXmlDomElement; path : string) : TFhirExtension;
var
  child : IXMLDOMElement;
begin
  result := TFhirExtension.create;
  try
    parseElementAttributes(result, path, element);
    result.url := GetAttribute(element, 'url');{x.4}
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'valueInteger') then
        result.value := ParseInteger(child, path+'.valueInteger') {c}
      else if (child.baseName = 'valueDateTime') then
        result.value := ParseDateTime(child, path+'.valueDateTime') {c}
      else if (child.baseName = 'valueUnsignedInt') then
        result.value := ParseUnsignedInt(child, path+'.valueUnsignedInt') {c}
      else if (child.baseName = 'valueCode') then
        result.value := ParseCode(child, path+'.valueCode') {c}
      else if (child.baseName = 'valueDate') then
        result.value := ParseDate(child, path+'.valueDate') {c}
      else if (child.baseName = 'valueDecimal') then
        result.value := ParseDecimal(child, path+'.valueDecimal') {c}
      else if (child.baseName = 'valueUri') then
        result.value := ParseUri(child, path+'.valueUri') {c}
      else if (child.baseName = 'valueId') then
        result.value := ParseId(child, path+'.valueId') {c}
      else if (child.baseName = 'valueBase64Binary') then
        result.value := ParseBase64Binary(child, path+'.valueBase64Binary') {c}
      else if (child.baseName = 'valueTime') then
        result.value := ParseTime(child, path+'.valueTime') {c}
      else if (child.baseName = 'valueOid') then
        result.value := ParseOid(child, path+'.valueOid') {c}
      else if (child.baseName = 'valuePositiveInt') then
        result.value := ParsePositiveInt(child, path+'.valuePositiveInt') {c}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'.valueString') {c}
      else if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'.valueBoolean') {c}
      else if (child.baseName = 'valueUuid') then
        result.value := ParseUuid(child, path+'.valueUuid') {c}
      else if (child.baseName = 'valueInstant') then
        result.value := ParseInstant(child, path+'.valueInstant') {c}
      else if (child.baseName = 'valuePeriod') then
        result.value := ParsePeriod(child, path+'.valuePeriod') {ePeriod}
      else if (child.baseName = 'valueCoding') then
        result.value := ParseCoding(child, path+'.valueCoding') {eCoding}
      else if (child.baseName = 'valueRange') then
        result.value := ParseRange(child, path+'.valueRange') {eRange}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'.valueQuantity') {eQuantity}
      else if (child.baseName = 'valueAttachment') then
        result.value := ParseAttachment(child, path+'.valueAttachment') {eAttachment}
      else if (child.baseName = 'valueRatio') then
        result.value := ParseRatio(child, path+'.valueRatio') {eRatio}
      else if (child.baseName = 'valueSampledData') then
        result.value := ParseSampledData(child, path+'.valueSampledData') {eSampledData}
      else if (child.baseName = 'valueReference') then
        result.value := ParseReference(child, path+'.valueReference') {eReference}
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'.valueCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'valueIdentifier') then
        result.value := ParseIdentifier(child, path+'.valueIdentifier') {eIdentifier}
      else if (child.baseName = 'valueSignature') then
        result.value := ParseSignature(child, path+'.valueSignature') {eSignature}
      else if (child.baseName = 'valueElementDefinition') then
        result.value := ParseElementDefinition(child, path+'/valueElementDefinition') {f}
      else if (child.baseName = 'valueTiming') then
        result.value := ParseTiming(child, path+'/valueTiming') {f}
      else if (child.baseName = 'valueAddress') then
        result.value := ParseAddress(child, path+'/valueAddress') {f}
      else if (child.baseName = 'valueHumanName') then
        result.value := ParseHumanName(child, path+'/valueHumanName') {f}
      else if (child.baseName = 'valueMeta') then
        result.value := ParseMeta(child, path+'/valueMeta') {f}
      else if (child.baseName = 'valueContactPoint') then
        result.value := ParseContactPoint(child, path+'/valueContactPoint') {f}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeExtension(xml : TXmlBuilder; name : string; elem : TFhirExtension);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  Attribute(xml, 'url', elem.url  );
  xml.open(name);
  composeElementChildren(xml, elem);
  if (elem.value is TFhirInteger) {1} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (elem.value is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (elem.value is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(elem.value))
  else if (elem.value is TFhirCode) {1} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (elem.value is TFhirDate) {1} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (elem.value is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (elem.value is TFhirUri) {1} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value))
  else if (elem.value is TFhirId) {1} then
    ComposeId(xml, 'valueId', TFhirId(elem.value))
  else if (elem.value is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(elem.value))
  else if (elem.value is TFhirTime) {1} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (elem.value is TFhirOid) {1} then
    ComposeOid(xml, 'valueOid', TFhirOid(elem.value))
  else if (elem.value is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(elem.value))
  else if (elem.value is TFhirString) {1} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (elem.value is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirUuid) {1} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(elem.value))
  else if (elem.value is TFhirInstant) {1} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (elem.value is TFhirPeriod) {8} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirCoding) {8} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirRange) {8} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirRatio) {8} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirReference) {8} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (elem.value is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (elem.value is TFhirSignature) {8} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(elem.value))
  else if (elem.value is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'valueElementDefinition', TFhirElementDefinition(elem.value))
  else if (elem.value is TFhirTiming) {9} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(elem.value))
  else if (elem.value is TFhirAddress) {9} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(elem.value))
  else if (elem.value is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(elem.value))
  else if (elem.value is TFhirMeta) {9} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(elem.value))
  else if (elem.value is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(elem.value));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseExtension(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExtension(jsn));
end;

function TFHIRJsonParser.ParseExtension(jsn : TJsonObject) : TFhirExtension;
begin
  result := TFhirExtension.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
        result.value := ParseInteger(jsn['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
        result.value := ParseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueUnsignedInt') or jsn.has('_valueUnsignedInt') then
        result.value := ParseUnsignedInt(jsn['valueUnsignedInt'], jsn.vObj['_valueUnsignedInt']);
    if jsn.has('valueCode') or jsn.has('_valueCode') then
        result.value := ParseCode(jsn['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
        result.value := ParseDate(jsn['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
        result.value := ParseDecimal(jsn['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
        result.value := ParseUri(jsn['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('valueId') or jsn.has('_valueId') then
        result.value := ParseId(jsn['valueId'], jsn.vObj['_valueId']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
        result.value := ParseBase64Binary(jsn['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
        result.value := ParseTime(jsn['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueOid') or jsn.has('_valueOid') then
        result.value := ParseOid(jsn['valueOid'], jsn.vObj['_valueOid']);
    if jsn.has('valuePositiveInt') or jsn.has('_valuePositiveInt') then
        result.value := ParsePositiveInt(jsn['valuePositiveInt'], jsn.vObj['_valuePositiveInt']);
    if jsn.has('valueString') or jsn.has('_valueString') then
        result.value := ParseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
        result.value := ParseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
        result.value := ParseUuid(jsn['valueUuid'], jsn.vObj['_valueUuid']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
        result.value := ParseInstant(jsn['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valuePeriod') {a7} then
        result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueCoding') {a7} then
        result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueRange') {a7} then
        result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueQuantity') {a7} then
        result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueAttachment') {a7} then
        result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueRatio') {a7} then
        result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueSampledData') {a7} then
        result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueReference') {a7} then
        result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueCodeableConcept') {a7} then
        result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueIdentifier') {a7} then
        result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if jsn.has('valueSignature') {a7} then
        result.value := ParseSignature(jsn.vObj['valueSignature']);
    if jsn.has('valueElementDefinition') {a9} then
        result.value := ParseElementDefinition(jsn.vObj['valueElementDefinition']);
    if jsn.has('valueTiming') {a9} then
        result.value := ParseTiming(jsn.vObj['valueTiming']);
    if jsn.has('valueAddress') {a9} then
        result.value := ParseAddress(jsn.vObj['valueAddress']);
    if jsn.has('valueHumanName') {a9} then
        result.value := ParseHumanName(jsn.vObj['valueHumanName']);
    if jsn.has('valueMeta') {a9} then
        result.value := ParseMeta(jsn.vObj['valueMeta']);
    if jsn.has('valueContactPoint') {a9} then
        result.value := ParseContactPoint(jsn.vObj['valueContactPoint']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeExtension(json : TJSONWriter; name : string; elem : TFhirExtension; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (elem.value is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false)
  end
  else if (elem.value is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false)
  end
  else if (elem.value is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false);
    ComposeUnsignedIntProps(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false)
  end
  else if (elem.value is TFhirCode) then
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false)
  end
  else if (elem.value is TFhirDate) then
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false)
  end
  else if (elem.value is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false)
  end
  else if (elem.value is TFhirUri) then
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false)
  end
  else if (elem.value is TFhirId) then
  begin
    ComposeIdValue(json, 'valueId', TFhirId(elem.value), false);
    ComposeIdProps(json, 'valueId', TFhirId(elem.value), false)
  end
  else if (elem.value is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false)
  end
  else if (elem.value is TFhirTime) then
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false)
  end
  else if (elem.value is TFhirOid) then
  begin
    ComposeOidValue(json, 'valueOid', TFhirOid(elem.value), false);
    ComposeOidProps(json, 'valueOid', TFhirOid(elem.value), false)
  end
  else if (elem.value is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false);
    ComposePositiveIntProps(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false)
  end
  else if (elem.value is TFhirString) then
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false)
  end
  else if (elem.value is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false)
  end
  else if (elem.value is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'valueUuid', TFhirUuid(elem.value), false);
    ComposeUuidProps(json, 'valueUuid', TFhirUuid(elem.value), false)
  end
  else if (elem.value is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false)
  end
  else if (elem.value is TFhirPeriod) then
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirCoding) then
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirRange) then
    ComposeRange(json, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirQuantity) then
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirAttachment) then
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirRatio) then
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirSampledData) then
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value))
  else if (elem.value is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirIdentifier) then
    ComposeIdentifier(json, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (elem.value is TFhirSignature) then
    ComposeSignature(json, 'valueSignature', TFhirSignature(elem.value))
  else if (elem.value is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'valueElementDefinition', TFhirElementDefinition(elem.value))
  else if (elem.value is TFhirTiming) then
    ComposeTiming(json, 'valueTiming', TFhirTiming(elem.value))
  else if (elem.value is TFhirAddress) then
    ComposeAddress(json, 'valueAddress', TFhirAddress(elem.value))
  else if (elem.value is TFhirHumanName) then
    ComposeHumanName(json, 'valueHumanName', TFhirHumanName(elem.value))
  else if (elem.value is TFhirMeta) then
    ComposeMeta(json, 'valueMeta', TFhirMeta(elem.value))
  else if (elem.value is TFhirContactPoint) then
    ComposeContactPoint(json, 'valueContactPoint', TFhirContactPoint(elem.value));
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseNarrative(element : IXmlDomElement; path : string) : TFhirNarrative;
var
  child : IXMLDOMElement;
begin
  result := TFhirNarrative.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirNarrativeStatus, path+'/status', child){1a}
      else if (child.baseName = 'div') then
        result.div_ := ParseXHtmlNode(child, path+'/div') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNarrative(xml : TXmlBuilder; name : string; elem : TFhirNarrative);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirNarrativeStatus);
  ComposeXHtmlNode(xml, 'div', elem.div_);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNarrative(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNarrative(jsn)); {2}
end;

function TFHIRJsonParser.ParseNarrative(jsn : TJsonObject) : TFhirNarrative;
begin
  result := TFhirNarrative.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirNarrativeStatus);
    if jsn.has('div') then
        result.div_ := ParseXHtmlNode(jsn.path+'.div', jsn['div']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNarrative(json : TJSONWriter; name : string; elem : TFhirNarrative; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirNarrativeStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirNarrativeStatus, false);
  ComposeXHtmlNode(json, 'div', elem.div_); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParsePeriod(element : IXmlDomElement; path : string) : TFhirPeriod;
var
  child : IXMLDOMElement;
begin
  result := TFhirPeriod.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'start') then
        result.startElement := ParseDateTime(child, path+'/start') {b}
      else if (child.baseName = 'end') then
        result.end_Element := ParseDateTime(child, path+'/end') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePeriod(xml : TXmlBuilder; name : string; elem : TFhirPeriod);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeDateTime(xml, 'start', elem.startElement);{x.2}
  ComposeDateTime(xml, 'end', elem.end_Element);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePeriod(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePeriod(jsn)); {2}
end;

function TFHIRJsonParser.ParsePeriod(jsn : TJsonObject) : TFhirPeriod;
begin
  result := TFhirPeriod.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := ParseDateTime(jsn['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := ParseDateTime(jsn['end'], jsn.vObj['_end']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePeriod(json : TJSONWriter; name : string; elem : TFhirPeriod; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeDateTimeValue(json, 'start', elem.startElement, false);
  ComposeDateTimeProps(json, 'start', elem.startElement, false);
  ComposeDateTimeValue(json, 'end', elem.end_Element, false);
  ComposeDateTimeProps(json, 'end', elem.end_Element, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseCoding(element : IXmlDomElement; path : string) : TFhirCoding;
var
  child : IXMLDOMElement;
begin
  result := TFhirCoding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'display') then
        result.displayElement := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'primary') then
        result.primaryElement := ParseBoolean(child, path+'/primary') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCoding(xml : TXmlBuilder; name : string; elem : TFhirCoding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.systemElement);{x.2}
  ComposeString(xml, 'version', elem.versionElement);{x.2}
  ComposeCode(xml, 'code', elem.codeElement);{x.2}
  ComposeString(xml, 'display', elem.displayElement);{x.2}
  ComposeBoolean(xml, 'primary', elem.primaryElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCoding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoding(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoding(jsn : TJsonObject) : TFhirCoding;
begin
  result := TFhirCoding.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('primary') or jsn.has('_primary') then
        result.primaryElement := ParseBoolean(jsn['primary'], jsn.vObj['_primary']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCoding(json : TJSONWriter; name : string; elem : TFhirCoding; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeUriValue(json, 'system', elem.systemElement, false);
  ComposeUriProps(json, 'system', elem.systemElement, false);
  ComposeStringValue(json, 'version', elem.versionElement, false);
  ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  ComposeStringValue(json, 'display', elem.displayElement, false);
  ComposeStringProps(json, 'display', elem.displayElement, false);
  ComposeBooleanValue(json, 'primary', elem.primaryElement, false);
  ComposeBooleanProps(json, 'primary', elem.primaryElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseRange(element : IXmlDomElement; path : string) : TFhirRange;
var
  child : IXMLDOMElement;
begin
  result := TFhirRange.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'low') then
        result.low := ParseQuantity(child, path+'/low') {b}
      else if (child.baseName = 'high') then
        result.high := ParseQuantity(child, path+'/high') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRange(xml : TXmlBuilder; name : string; elem : TFhirRange);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeQuantity(xml, 'low', elem.low);{x.2}
  ComposeQuantity(xml, 'high', elem.high);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRange(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRange(jsn)); {2}
end;

function TFHIRJsonParser.ParseRange(jsn : TJsonObject) : TFhirRange;
begin
  result := TFhirRange.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('low') then
        result.low := ParseQuantity(jsn.vObj['low']);{q}
    if jsn.has('high') then
        result.high := ParseQuantity(jsn.vObj['high']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRange(json : TJSONWriter; name : string; elem : TFhirRange; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeQuantity(json, 'low', elem.low); {a}
  ComposeQuantity(json, 'high', elem.high); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseQuantity(element : IXmlDomElement; path : string) : TFhirQuantity;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuantity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'value') then
        result.valueElement := ParseDecimal(child, path+'/value') {b}
      else if (child.baseName = 'comparator') then
        result.comparatorElement := ParseEnum(CODES_TFhirQuantityComparator, path+'/comparator', child){1a}
      else if (child.baseName = 'units') then
        result.unitsElement := ParseString(child, path+'/units') {b}
      else if (child.baseName = 'system') then
        result.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuantity(xml : TXmlBuilder; name : string; elem : TFhirQuantity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeDecimal(xml, 'value', elem.valueElement);{x.2}
  ComposeEnum(xml, 'comparator', elem.ComparatorElement, CODES_TFhirQuantityComparator);
  ComposeString(xml, 'units', elem.unitsElement);{x.2}
  ComposeUri(xml, 'system', elem.systemElement);{x.2}
  ComposeCode(xml, 'code', elem.codeElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuantity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuantity(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuantity(jsn : TJsonObject) : TFhirQuantity;
begin
  result := TFhirQuantity.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn['value'], jsn.vObj['_value']);{q}
    if jsn.has('comparator') or jsn.has('_comparator')  then
      result.comparatorElement := parseEnum(jsn['comparator'], jsn.vObj['_comparator'], CODES_TFhirQuantityComparator);
    if jsn.has('units') or jsn.has('_units') then
        result.unitsElement := ParseString(jsn['units'], jsn.vObj['_units']);{q}
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuantity(json : TJSONWriter; name : string; elem : TFhirQuantity; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeDecimalValue(json, 'value', elem.valueElement, false);
  ComposeDecimalProps(json, 'value', elem.valueElement, false);
  ComposeEnumValue(json, 'comparator', elem.ComparatorElement, CODES_TFhirQuantityComparator, false);
  ComposeEnumProps(json, 'comparator', elem.ComparatorElement, CODES_TFhirQuantityComparator, false);
  ComposeStringValue(json, 'units', elem.unitsElement, false);
  ComposeStringProps(json, 'units', elem.unitsElement, false);
  ComposeUriValue(json, 'system', elem.systemElement, false);
  ComposeUriProps(json, 'system', elem.systemElement, false);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseAttachment(element : IXmlDomElement; path : string) : TFhirAttachment;
var
  child : IXMLDOMElement;
begin
  result := TFhirAttachment.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'contentType') then
        result.contentTypeElement := ParseCode(child, path+'/contentType') {b}
      else if (child.baseName = 'language') then
        result.languageElement := ParseCode(child, path+'/language') {b}
      else if (child.baseName = 'data') then
        result.dataElement := ParseBase64Binary(child, path+'/data') {b}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'size') then
        result.sizeElement := ParseUnsignedInt(child, path+'/size') {b}
      else if (child.baseName = 'hash') then
        result.hashElement := ParseBase64Binary(child, path+'/hash') {b}
      else if (child.baseName = 'title') then
        result.titleElement := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'creation') then
        result.creationElement := ParseDateTime(child, path+'/creation') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAttachment(xml : TXmlBuilder; name : string; elem : TFhirAttachment);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeCode(xml, 'contentType', elem.contentTypeElement);{x.2}
  ComposeCode(xml, 'language', elem.languageElement);{x.2}
  ComposeBase64Binary(xml, 'data', elem.dataElement);{x.2}
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  ComposeUnsignedInt(xml, 'size', elem.sizeElement);{x.2}
  ComposeBase64Binary(xml, 'hash', elem.hashElement);{x.2}
  ComposeString(xml, 'title', elem.titleElement);{x.2}
  ComposeDateTime(xml, 'creation', elem.creationElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAttachment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAttachment(jsn)); {2}
end;

function TFHIRJsonParser.ParseAttachment(jsn : TJsonObject) : TFhirAttachment;
begin
  result := TFhirAttachment.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('contentType') or jsn.has('_contentType') then
        result.contentTypeElement := ParseCode(jsn['contentType'], jsn.vObj['_contentType']);{q}
    if jsn.has('language') or jsn.has('_language') then
        result.languageElement := ParseCode(jsn['language'], jsn.vObj['_language']);{q}
    if jsn.has('data') or jsn.has('_data') then
        result.dataElement := ParseBase64Binary(jsn['data'], jsn.vObj['_data']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('size') or jsn.has('_size') then
        result.sizeElement := ParseUnsignedInt(jsn['size'], jsn.vObj['_size']);{q}
    if jsn.has('hash') or jsn.has('_hash') then
        result.hashElement := ParseBase64Binary(jsn['hash'], jsn.vObj['_hash']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('creation') or jsn.has('_creation') then
        result.creationElement := ParseDateTime(jsn['creation'], jsn.vObj['_creation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAttachment(json : TJSONWriter; name : string; elem : TFhirAttachment; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeCodeValue(json, 'contentType', elem.contentTypeElement, false);
  ComposeCodeProps(json, 'contentType', elem.contentTypeElement, false);
  ComposeCodeValue(json, 'language', elem.languageElement, false);
  ComposeCodeProps(json, 'language', elem.languageElement, false);
  ComposeBase64BinaryValue(json, 'data', elem.dataElement, false);
  ComposeBase64BinaryProps(json, 'data', elem.dataElement, false);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  ComposeUnsignedIntValue(json, 'size', elem.sizeElement, false);
  ComposeUnsignedIntProps(json, 'size', elem.sizeElement, false);
  ComposeBase64BinaryValue(json, 'hash', elem.hashElement, false);
  ComposeBase64BinaryProps(json, 'hash', elem.hashElement, false);
  ComposeStringValue(json, 'title', elem.titleElement, false);
  ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeDateTimeValue(json, 'creation', elem.creationElement, false);
  ComposeDateTimeProps(json, 'creation', elem.creationElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseRatio(element : IXmlDomElement; path : string) : TFhirRatio;
var
  child : IXMLDOMElement;
begin
  result := TFhirRatio.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'numerator') then
        result.numerator := ParseQuantity(child, path+'/numerator') {b}
      else if (child.baseName = 'denominator') then
        result.denominator := ParseQuantity(child, path+'/denominator') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRatio(xml : TXmlBuilder; name : string; elem : TFhirRatio);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeQuantity(xml, 'numerator', elem.numerator);{x.2}
  ComposeQuantity(xml, 'denominator', elem.denominator);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRatio(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRatio(jsn)); {2}
end;

function TFHIRJsonParser.ParseRatio(jsn : TJsonObject) : TFhirRatio;
begin
  result := TFhirRatio.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('numerator') then
        result.numerator := ParseQuantity(jsn.vObj['numerator']);{q}
    if jsn.has('denominator') then
        result.denominator := ParseQuantity(jsn.vObj['denominator']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRatio(json : TJSONWriter; name : string; elem : TFhirRatio; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeQuantity(json, 'numerator', elem.numerator); {a}
  ComposeQuantity(json, 'denominator', elem.denominator); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseSampledData(element : IXmlDomElement; path : string) : TFhirSampledData;
var
  child : IXMLDOMElement;
begin
  result := TFhirSampledData.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'origin') then
        result.origin := ParseQuantity(child, path+'/origin') {b}
      else if (child.baseName = 'period') then
        result.periodElement := ParseDecimal(child, path+'/period') {b}
      else if (child.baseName = 'factor') then
        result.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.baseName = 'lowerLimit') then
        result.lowerLimitElement := ParseDecimal(child, path+'/lowerLimit') {b}
      else if (child.baseName = 'upperLimit') then
        result.upperLimitElement := ParseDecimal(child, path+'/upperLimit') {b}
      else if (child.baseName = 'dimensions') then
        result.dimensionsElement := ParsePositiveInt(child, path+'/dimensions') {b}
      else if (child.baseName = 'data') then
        result.dataElement := ParseString(child, path+'/data') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSampledData(xml : TXmlBuilder; name : string; elem : TFhirSampledData);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeQuantity(xml, 'origin', elem.origin);{x.2}
  ComposeDecimal(xml, 'period', elem.periodElement);{x.2}
  ComposeDecimal(xml, 'factor', elem.factorElement);{x.2}
  ComposeDecimal(xml, 'lowerLimit', elem.lowerLimitElement);{x.2}
  ComposeDecimal(xml, 'upperLimit', elem.upperLimitElement);{x.2}
  ComposePositiveInt(xml, 'dimensions', elem.dimensionsElement);{x.2}
  ComposeString(xml, 'data', elem.dataElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSampledData(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSampledData(jsn)); {2}
end;

function TFHIRJsonParser.ParseSampledData(jsn : TJsonObject) : TFhirSampledData;
begin
  result := TFhirSampledData.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('origin') then
        result.origin := ParseQuantity(jsn.vObj['origin']);{q}
    if jsn.has('period') or jsn.has('_period') then
        result.periodElement := ParseDecimal(jsn['period'], jsn.vObj['_period']);{q}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('lowerLimit') or jsn.has('_lowerLimit') then
        result.lowerLimitElement := ParseDecimal(jsn['lowerLimit'], jsn.vObj['_lowerLimit']);{q}
    if jsn.has('upperLimit') or jsn.has('_upperLimit') then
        result.upperLimitElement := ParseDecimal(jsn['upperLimit'], jsn.vObj['_upperLimit']);{q}
    if jsn.has('dimensions') or jsn.has('_dimensions') then
        result.dimensionsElement := ParsePositiveInt(jsn['dimensions'], jsn.vObj['_dimensions']);{q}
    if jsn.has('data') or jsn.has('_data') then
        result.dataElement := ParseString(jsn['data'], jsn.vObj['_data']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSampledData(json : TJSONWriter; name : string; elem : TFhirSampledData; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeQuantity(json, 'origin', elem.origin); {a}
  ComposeDecimalValue(json, 'period', elem.periodElement, false);
  ComposeDecimalProps(json, 'period', elem.periodElement, false);
  ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  ComposeDecimalValue(json, 'lowerLimit', elem.lowerLimitElement, false);
  ComposeDecimalProps(json, 'lowerLimit', elem.lowerLimitElement, false);
  ComposeDecimalValue(json, 'upperLimit', elem.upperLimitElement, false);
  ComposeDecimalProps(json, 'upperLimit', elem.upperLimitElement, false);
  ComposePositiveIntValue(json, 'dimensions', elem.dimensionsElement, false);
  ComposePositiveIntProps(json, 'dimensions', elem.dimensionsElement, false);
  ComposeStringValue(json, 'data', elem.dataElement, false);
  ComposeStringProps(json, 'data', elem.dataElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseReference(element : IXmlDomElement; path : string) : TFhirReference;
var
  child : IXMLDOMElement;
begin
  result := TFhirReference.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'reference') then
        result.referenceElement := ParseString(child, path+'/reference') {b}
      else if (child.baseName = 'display') then
        result.displayElement := ParseString(child, path+'/display') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeReference(xml : TXmlBuilder; name : string; elem : TFhirReference);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeString(xml, 'reference', elem.referenceElement);{x.2}
  ComposeString(xml, 'display', elem.displayElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseReference(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseReference(jsn)); {2}
end;

function TFHIRJsonParser.ParseReference(jsn : TJsonObject) : TFhirReference;
begin
  result := TFhirReference.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceElement := ParseString(jsn['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeReference(json : TJSONWriter; name : string; elem : TFhirReference; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeStringValue(json, 'reference', elem.referenceElement, false);
  ComposeStringProps(json, 'reference', elem.referenceElement, false);
  ComposeStringValue(json, 'display', elem.displayElement, false);
  ComposeStringProps(json, 'display', elem.displayElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseCodeableConcept(element : IXmlDomElement; path : string) : TFhirCodeableConcept;
var
  child : IXMLDOMElement;
begin
  result := TFhirCodeableConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'coding') then
        result.codingList.Add(ParseCoding(child, path+'/coding')){y.2}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCodeableConcept(xml : TXmlBuilder; name : string; elem : TFhirCodeableConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  for i := 0 to elem.codingList.Count - 1 do
    ComposeCoding(xml, 'coding', elem.codingList[i]);
  ComposeString(xml, 'text', elem.textElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCodeableConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCodeableConcept(jsn)); {2}
end;

function TFHIRJsonParser.ParseCodeableConcept(jsn : TJsonObject) : TFhirCodeableConcept;
begin
  result := TFhirCodeableConcept.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('coding') then
      iterateArray(jsn.vArr['coding'], result.codingList, parseCoding);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCodeableConcept(json : TJSONWriter; name : string; elem : TFhirCodeableConcept; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if elem.codingList.Count > 0 then
  begin
    json.valueArray('coding');
    for i := 0 to elem.codingList.Count - 1 do
      ComposeCoding(json, '',elem.codingList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'text', elem.textElement, false);
  ComposeStringProps(json, 'text', elem.textElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseIdentifier(element : IXmlDomElement; path : string) : TFhirIdentifier;
var
  child : IXMLDOMElement;
begin
  result := TFhirIdentifier.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'use') then
        result.useElement := ParseEnum(CODES_TFhirIdentifierUse, path+'/use', child){1a}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'system') then
        result.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseString(child, path+'/value') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'assigner') then
        result.assigner := ParseReference{TFhirOrganization}(child, path+'/assigner') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeIdentifier(xml : TXmlBuilder; name : string; elem : TFhirIdentifier);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirIdentifierUse);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeUri(xml, 'system', elem.systemElement);{x.2}
  ComposeString(xml, 'value', elem.valueElement);{x.2}
  ComposePeriod(xml, 'period', elem.period);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'assigner', elem.assigner);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseIdentifier(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseIdentifier(jsn)); {2}
end;

function TFHIRJsonParser.ParseIdentifier(jsn : TJsonObject) : TFhirIdentifier;
begin
  result := TFhirIdentifier.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn['use'], jsn.vObj['_use'], CODES_TFhirIdentifierUse);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('assigner') then
        result.assigner := ParseReference{TFhirOrganization}(jsn.vObj['assigner']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeIdentifier(json : TJSONWriter; name : string; elem : TFhirIdentifier; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirIdentifierUse, false);
  ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirIdentifierUse, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeUriValue(json, 'system', elem.systemElement, false);
  ComposeUriProps(json, 'system', elem.systemElement, false);
  ComposeStringValue(json, 'value', elem.valueElement, false);
  ComposeStringProps(json, 'value', elem.valueElement, false);
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeReference{TFhirOrganization}(json, 'assigner', elem.assigner); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseSignature(element : IXmlDomElement; path : string) : TFhirSignature;
var
  child : IXMLDOMElement;
begin
  result := TFhirSignature.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_List.Add(ParseCoding(child, path+'/type')){y.2}
      else if (child.baseName = 'when') then
        result.whenElement := ParseInstant(child, path+'/when') {b}
      else if (child.baseName = 'whoUri') then
        result.who := ParseUri(child, path+'/whoUri'){x.3}
      else if (child.baseName = 'whoReference') then
        result.who := ParseReference(child, path+'/whoReference') {a}
      else if (child.baseName = 'blob') then
        result.blobElement := ParseBase64Binary(child, path+'/blob') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSignature(xml : TXmlBuilder; name : string; elem : TFhirSignature);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCoding(xml, 'type', elem.type_List[i]);
  ComposeInstant(xml, 'when', elem.whenElement);{x.2}
  if (elem.who is TFhirUri) {6} then
    ComposeUri(xml, 'whoUri', TFhirUri(elem.who))
  else if (elem.who is TFhirReference) {2} then
    ComposeReference(xml, 'whoReference', TFhirReference(elem.who));
  ComposeBase64Binary(xml, 'blob', elem.blobElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSignature(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSignature(jsn)); {2}
end;

function TFHIRJsonParser.ParseSignature(jsn : TJsonObject) : TFhirSignature;
begin
  result := TFhirSignature.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCoding);
    if jsn.has('when') or jsn.has('_when') then
        result.whenElement := ParseInstant(jsn['when'], jsn.vObj['_when']);{q}
    if jsn.has('whoUri') or jsn.has('_whoUri') then
      result.who := parseUri(jsn['whoUri'], jsn.vObj['_whoUri']);
    if jsn.has('whoReference') {a3} then
      result.who := ParseReference(jsn.vObj['whoReference']);
    if jsn.has('blob') or jsn.has('_blob') then
        result.blobElement := ParseBase64Binary(jsn['blob'], jsn.vObj['_blob']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSignature(json : TJSONWriter; name : string; elem : TFhirSignature; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(json, '',elem.type_List[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeInstantValue(json, 'when', elem.whenElement, false);
  ComposeInstantProps(json, 'when', elem.whenElement, false);
  if (elem.who is TFhirUri) then 
  begin
    ComposeUriValue(json, 'whoUri', TFhirUri(elem.who), false);
    ComposeUriProps(json, 'whoUri', TFhirUri(elem.who), false);
  end
  else if (elem.who is TFhirReference) then
    ComposeReference(json, 'whoReference', TFhirReference(elem.who));
  ComposeBase64BinaryValue(json, 'blob', elem.blobElement, false);
  ComposeBase64BinaryProps(json, 'blob', elem.blobElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseElementDefinitionSlicing(element : IXmlDomElement; path : string) : TFhirElementDefinitionSlicing;
var
  child : IXMLDOMElement;
begin
  result := TFhirElementDefinitionSlicing.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'discriminator') then
        result.discriminatorList.Add(ParseString(child, path+'/discriminator')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'ordered') then
        result.orderedElement := ParseBoolean(child, path+'/ordered') {b}
      else if (child.baseName = 'rules') then
        result.rulesElement := ParseEnum(CODES_TFhirResourceSlicingRules, path+'/rules', child){1a}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionSlicing(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionSlicing);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  for i := 0 to elem.discriminatorList.Count - 1 do
    ComposeString(xml, 'discriminator', elem.discriminatorList[i]);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeBoolean(xml, 'ordered', elem.orderedElement);{x.2}
  ComposeEnum(xml, 'rules', elem.RulesElement, CODES_TFhirResourceSlicingRules);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseElementDefinitionSlicing(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionSlicing(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionSlicing(jsn : TJsonObject) : TFhirElementDefinitionSlicing;
begin
  result := TFhirElementDefinitionSlicing.create;
  try
    ParseElementProperties(jsn, result);
      if jsn.has('discriminator') or jsn.has('_discriminator') then
      iteratePrimitiveArray(jsn.vArr['discriminator'], jsn.vArr['_discriminator'], result.discriminatorList, parseString);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('ordered') or jsn.has('_ordered') then
        result.orderedElement := ParseBoolean(jsn['ordered'], jsn.vObj['_ordered']);{q}
    if jsn.has('rules') or jsn.has('_rules')  then
      result.rulesElement := parseEnum(jsn['rules'], jsn.vObj['_rules'], CODES_TFhirResourceSlicingRules);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionSlicing(json : TJSONWriter; name : string; elem : TFhirElementDefinitionSlicing; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if elem.discriminatorList.Count > 0 then
  begin
    json.valueArray('discriminator');
    ext := false;
    for i := 0 to elem.discriminatorList.Count - 1 do
    begin
      ext := ext or ((elem.discriminatorList[i].id <> '') or (elem.discriminatorList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.discriminatorList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_discriminator');
      for i := 0 to elem.discriminatorList.Count - 1 do
        ComposeStringProps(json, '',elem.discriminatorList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeBooleanValue(json, 'ordered', elem.orderedElement, false);
  ComposeBooleanProps(json, 'ordered', elem.orderedElement, false);
  ComposeEnumValue(json, 'rules', elem.RulesElement, CODES_TFhirResourceSlicingRules, false);
  ComposeEnumProps(json, 'rules', elem.RulesElement, CODES_TFhirResourceSlicingRules, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseElementDefinitionType(element : IXmlDomElement; path : string) : TFhirElementDefinitionType;
var
  child : IXMLDOMElement;
begin
  result := TFhirElementDefinitionType.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'profile') then
        result.profileElement := ParseUri(child, path+'/profile') {b}
      else if (child.baseName = 'aggregation') then
        result.aggregationElement.Add(ParseEnum(CODES_TFhirResourceAggregationMode, path+'/aggregation', child)){y.1}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionType(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionType);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.codeElement);{x.2}
  ComposeUri(xml, 'profile', elem.profileElement);{x.2}
  for i := 0 to elem.aggregationElement.Count - 1 do
    ComposeEnum(xml, 'aggregation', elem.aggregationElement[i], CODES_TFhirResourceAggregationMode);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseElementDefinitionType(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionType(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionType(jsn : TJsonObject) : TFhirElementDefinitionType;
begin
  result := TFhirElementDefinitionType.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('profile') or jsn.has('_profile') then
        result.profileElement := ParseUri(jsn['profile'], jsn.vObj['_profile']);{q}
    if jsn.has('aggregation') or jsn.has('_aggregation') then
      iterateEnumArray(jsn.vArr['aggregation'], jsn.vArr['_aggregation'], result.aggregationElement, parseEnum, CODES_TFhirResourceAggregationMode);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionType(json : TJSONWriter; name : string; elem : TFhirElementDefinitionType; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  ComposeUriValue(json, 'profile', elem.profileElement, false);
  ComposeUriProps(json, 'profile', elem.profileElement, false);
  if elem.aggregationElement.Count > 0 then
  begin
    json.valueArray('aggregation');
    ext := false;
    for i := 0 to elem.aggregationElement.Count - 1 do
    begin
      ext := ext or ((elem.aggregationElement[i].id <> '') or (elem.aggregationElement[i].hasExtensionList));
      ComposeEnumValue(json, '', elem.aggregationElement[i], CODES_TFhirResourceAggregationMode, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_aggregation');
      for i := 0 to elem.aggregationElement.Count - 1 do
        ComposeEnumProps(json, '', elem.aggregationElement[i], CODES_TFhirResourceAggregationMode, true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseElementDefinitionConstraint(element : IXmlDomElement; path : string) : TFhirElementDefinitionConstraint;
var
  child : IXMLDOMElement;
begin
  result := TFhirElementDefinitionConstraint.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'key') then
        result.keyElement := ParseId(child, path+'/key') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'severity') then
        result.severityElement := ParseEnum(CODES_TFhirConstraintSeverity, path+'/severity', child){1a}
      else if (child.baseName = 'human') then
        result.humanElement := ParseString(child, path+'/human') {b}
      else if (child.baseName = 'xpath') then
        result.xpathElement := ParseString(child, path+'/xpath') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionConstraint(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionConstraint);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeId(xml, 'key', elem.keyElement);{x.2}
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeEnum(xml, 'severity', elem.SeverityElement, CODES_TFhirConstraintSeverity);
  ComposeString(xml, 'human', elem.humanElement);{x.2}
  ComposeString(xml, 'xpath', elem.xpathElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseElementDefinitionConstraint(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionConstraint(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionConstraint(jsn : TJsonObject) : TFhirElementDefinitionConstraint;
begin
  result := TFhirElementDefinitionConstraint.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('key') or jsn.has('_key') then
        result.keyElement := ParseId(jsn['key'], jsn.vObj['_key']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityElement := parseEnum(jsn['severity'], jsn.vObj['_severity'], CODES_TFhirConstraintSeverity);
    if jsn.has('human') or jsn.has('_human') then
        result.humanElement := ParseString(jsn['human'], jsn.vObj['_human']);{q}
    if jsn.has('xpath') or jsn.has('_xpath') then
        result.xpathElement := ParseString(jsn['xpath'], jsn.vObj['_xpath']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionConstraint(json : TJSONWriter; name : string; elem : TFhirElementDefinitionConstraint; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeIdValue(json, 'key', elem.keyElement, false);
  ComposeIdProps(json, 'key', elem.keyElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'severity', elem.SeverityElement, CODES_TFhirConstraintSeverity, false);
  ComposeEnumProps(json, 'severity', elem.SeverityElement, CODES_TFhirConstraintSeverity, false);
  ComposeStringValue(json, 'human', elem.humanElement, false);
  ComposeStringProps(json, 'human', elem.humanElement, false);
  ComposeStringValue(json, 'xpath', elem.xpathElement, false);
  ComposeStringProps(json, 'xpath', elem.xpathElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseElementDefinitionBinding(element : IXmlDomElement; path : string) : TFhirElementDefinitionBinding;
var
  child : IXMLDOMElement;
begin
  result := TFhirElementDefinitionBinding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'strength') then
        result.strengthElement := ParseEnum(CODES_TFhirBindingStrength, path+'/strength', child){1a}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'valueSetUri') then
        result.valueSet := ParseUri(child, path+'/valueSetUri'){x.3}
      else if (child.baseName = 'valueSetReference') then
        result.valueSet := ParseReference(child, path+'/valueSetReference') {a}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionBinding(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionBinding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeEnum(xml, 'strength', elem.StrengthElement, CODES_TFhirBindingStrength);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (elem.valueSet is TFhirUri) {6} then
    ComposeUri(xml, 'valueSetUri', TFhirUri(elem.valueSet))
  else if (elem.valueSet is TFhirReference) {2} then
    ComposeReference(xml, 'valueSetReference', TFhirReference(elem.valueSet));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseElementDefinitionBinding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionBinding(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionBinding(jsn : TJsonObject) : TFhirElementDefinitionBinding;
begin
  result := TFhirElementDefinitionBinding.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('strength') or jsn.has('_strength')  then
      result.strengthElement := parseEnum(jsn['strength'], jsn.vObj['_strength'], CODES_TFhirBindingStrength);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('valueSetUri') or jsn.has('_valueSetUri') then
      result.valueSet := parseUri(jsn['valueSetUri'], jsn.vObj['_valueSetUri']);
    if jsn.has('valueSetReference') {a3} then
      result.valueSet := ParseReference(jsn.vObj['valueSetReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionBinding(json : TJSONWriter; name : string; elem : TFhirElementDefinitionBinding; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'strength', elem.StrengthElement, CODES_TFhirBindingStrength, false);
  ComposeEnumProps(json, 'strength', elem.StrengthElement, CODES_TFhirBindingStrength, false);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (elem.valueSet is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueSetUri', TFhirUri(elem.valueSet), false);
    ComposeUriProps(json, 'valueSetUri', TFhirUri(elem.valueSet), false);
  end
  else if (elem.valueSet is TFhirReference) then
    ComposeReference(json, 'valueSetReference', TFhirReference(elem.valueSet));
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseElementDefinitionMapping(element : IXmlDomElement; path : string) : TFhirElementDefinitionMapping;
var
  child : IXMLDOMElement;
begin
  result := TFhirElementDefinitionMapping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identity') then
        result.identityElement := ParseId(child, path+'/identity') {b}
      else if (child.baseName = 'language') then
        result.languageElement := ParseCode(child, path+'/language') {b}
      else if (child.baseName = 'map') then
        result.mapElement := ParseString(child, path+'/map') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionMapping(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionMapping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeId(xml, 'identity', elem.identityElement);{x.2}
  ComposeCode(xml, 'language', elem.languageElement);{x.2}
  ComposeString(xml, 'map', elem.mapElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseElementDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionMapping(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionMapping(jsn : TJsonObject) : TFhirElementDefinitionMapping;
begin
  result := TFhirElementDefinitionMapping.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('identity') or jsn.has('_identity') then
        result.identityElement := ParseId(jsn['identity'], jsn.vObj['_identity']);{q}
    if jsn.has('language') or jsn.has('_language') then
        result.languageElement := ParseCode(jsn['language'], jsn.vObj['_language']);{q}
    if jsn.has('map') or jsn.has('_map') then
        result.mapElement := ParseString(jsn['map'], jsn.vObj['_map']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirElementDefinitionMapping; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeIdValue(json, 'identity', elem.identityElement, false);
  ComposeIdProps(json, 'identity', elem.identityElement, false);
  ComposeCodeValue(json, 'language', elem.languageElement, false);
  ComposeCodeProps(json, 'language', elem.languageElement, false);
  ComposeStringValue(json, 'map', elem.mapElement, false);
  ComposeStringProps(json, 'map', elem.mapElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseElementDefinition(element : IXmlDomElement; path : string) : TFhirElementDefinition;
var
  child : IXMLDOMElement;
begin
  result := TFhirElementDefinition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'path') then
        result.pathElement := ParseString(child, path+'/path') {b}
      else if (child.baseName = 'representation') then
        result.representationElement.Add(ParseEnum(CODES_TFhirPropertyRepresentation, path+'/representation', child)){y.1}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'label') then
        result.label_Element := ParseString(child, path+'/label') {b}
      else if (child.baseName = 'code') then
        result.codeList.Add(ParseCoding(child, path+'/code')){y.2}
      else if (child.baseName = 'slicing') then
        result.slicing := ParseElementDefinitionSlicing(child, path+'/slicing') {b}
      else if (child.baseName = 'short') then
        result.shortElement := ParseString(child, path+'/short') {b}
      else if (child.baseName = 'definition') then
        result.definitionElement := ParseString(child, path+'/definition') {b}
      else if (child.baseName = 'comments') then
        result.commentsElement := ParseString(child, path+'/comments') {b}
      else if (child.baseName = 'requirements') then
        result.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'alias') then
        result.aliasList.Add(ParseString(child, path+'/alias')){y.2}
      else if (child.baseName = 'min') then
        result.minElement := ParseInteger(child, path+'/min') {b}
      else if (child.baseName = 'max') then
        result.maxElement := ParseString(child, path+'/max') {b}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseElementDefinitionType(child, path+'/type')){y.2}
      else if (child.baseName = 'nameReference') then
        result.nameReferenceElement := ParseString(child, path+'/nameReference') {b}
      else if (child.baseName = 'defaultValueInteger') then
        result.defaultValue := ParseInteger(child, path+'.defaultValueInteger') {c}
      else if (child.baseName = 'defaultValueDateTime') then
        result.defaultValue := ParseDateTime(child, path+'.defaultValueDateTime') {c}
      else if (child.baseName = 'defaultValueUnsignedInt') then
        result.defaultValue := ParseUnsignedInt(child, path+'.defaultValueUnsignedInt') {c}
      else if (child.baseName = 'defaultValueCode') then
        result.defaultValue := ParseCode(child, path+'.defaultValueCode') {c}
      else if (child.baseName = 'defaultValueDate') then
        result.defaultValue := ParseDate(child, path+'.defaultValueDate') {c}
      else if (child.baseName = 'defaultValueDecimal') then
        result.defaultValue := ParseDecimal(child, path+'.defaultValueDecimal') {c}
      else if (child.baseName = 'defaultValueUri') then
        result.defaultValue := ParseUri(child, path+'.defaultValueUri') {c}
      else if (child.baseName = 'defaultValueId') then
        result.defaultValue := ParseId(child, path+'.defaultValueId') {c}
      else if (child.baseName = 'defaultValueBase64Binary') then
        result.defaultValue := ParseBase64Binary(child, path+'.defaultValueBase64Binary') {c}
      else if (child.baseName = 'defaultValueTime') then
        result.defaultValue := ParseTime(child, path+'.defaultValueTime') {c}
      else if (child.baseName = 'defaultValueOid') then
        result.defaultValue := ParseOid(child, path+'.defaultValueOid') {c}
      else if (child.baseName = 'defaultValuePositiveInt') then
        result.defaultValue := ParsePositiveInt(child, path+'.defaultValuePositiveInt') {c}
      else if (child.baseName = 'defaultValueString') then
        result.defaultValue := ParseString(child, path+'.defaultValueString') {c}
      else if (child.baseName = 'defaultValueBoolean') then
        result.defaultValue := ParseBoolean(child, path+'.defaultValueBoolean') {c}
      else if (child.baseName = 'defaultValueUuid') then
        result.defaultValue := ParseUuid(child, path+'.defaultValueUuid') {c}
      else if (child.baseName = 'defaultValueInstant') then
        result.defaultValue := ParseInstant(child, path+'.defaultValueInstant') {c}
      else if (child.baseName = 'defaultValuePeriod') then
        result.defaultValue := ParsePeriod(child, path+'.defaultValuePeriod') {ePeriod}
      else if (child.baseName = 'defaultValueCoding') then
        result.defaultValue := ParseCoding(child, path+'.defaultValueCoding') {eCoding}
      else if (child.baseName = 'defaultValueRange') then
        result.defaultValue := ParseRange(child, path+'.defaultValueRange') {eRange}
      else if (child.baseName = 'defaultValueQuantity') then
        result.defaultValue := ParseQuantity(child, path+'.defaultValueQuantity') {eQuantity}
      else if (child.baseName = 'defaultValueAttachment') then
        result.defaultValue := ParseAttachment(child, path+'.defaultValueAttachment') {eAttachment}
      else if (child.baseName = 'defaultValueRatio') then
        result.defaultValue := ParseRatio(child, path+'.defaultValueRatio') {eRatio}
      else if (child.baseName = 'defaultValueSampledData') then
        result.defaultValue := ParseSampledData(child, path+'.defaultValueSampledData') {eSampledData}
      else if (child.baseName = 'defaultValueReference') then
        result.defaultValue := ParseReference(child, path+'.defaultValueReference') {eReference}
      else if (child.baseName = 'defaultValueCodeableConcept') then
        result.defaultValue := ParseCodeableConcept(child, path+'.defaultValueCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'defaultValueIdentifier') then
        result.defaultValue := ParseIdentifier(child, path+'.defaultValueIdentifier') {eIdentifier}
      else if (child.baseName = 'defaultValueSignature') then
        result.defaultValue := ParseSignature(child, path+'.defaultValueSignature') {eSignature}
      else if (child.baseName = 'defaultValueElementDefinition') then
        result.defaultValue := ParseElementDefinition(child, path+'/defaultValueElementDefinition') {f}
      else if (child.baseName = 'defaultValueTiming') then
        result.defaultValue := ParseTiming(child, path+'/defaultValueTiming') {f}
      else if (child.baseName = 'defaultValueAddress') then
        result.defaultValue := ParseAddress(child, path+'/defaultValueAddress') {f}
      else if (child.baseName = 'defaultValueHumanName') then
        result.defaultValue := ParseHumanName(child, path+'/defaultValueHumanName') {f}
      else if (child.baseName = 'defaultValueMeta') then
        result.defaultValue := ParseMeta(child, path+'/defaultValueMeta') {f}
      else if (child.baseName = 'defaultValueContactPoint') then
        result.defaultValue := ParseContactPoint(child, path+'/defaultValueContactPoint') {f}
      else if (child.baseName = 'meaningWhenMissing') then
        result.meaningWhenMissingElement := ParseString(child, path+'/meaningWhenMissing') {b}
      else if (child.baseName = 'fixedInteger') then
        result.fixed := ParseInteger(child, path+'.fixedInteger') {c}
      else if (child.baseName = 'fixedDateTime') then
        result.fixed := ParseDateTime(child, path+'.fixedDateTime') {c}
      else if (child.baseName = 'fixedUnsignedInt') then
        result.fixed := ParseUnsignedInt(child, path+'.fixedUnsignedInt') {c}
      else if (child.baseName = 'fixedCode') then
        result.fixed := ParseCode(child, path+'.fixedCode') {c}
      else if (child.baseName = 'fixedDate') then
        result.fixed := ParseDate(child, path+'.fixedDate') {c}
      else if (child.baseName = 'fixedDecimal') then
        result.fixed := ParseDecimal(child, path+'.fixedDecimal') {c}
      else if (child.baseName = 'fixedUri') then
        result.fixed := ParseUri(child, path+'.fixedUri') {c}
      else if (child.baseName = 'fixedId') then
        result.fixed := ParseId(child, path+'.fixedId') {c}
      else if (child.baseName = 'fixedBase64Binary') then
        result.fixed := ParseBase64Binary(child, path+'.fixedBase64Binary') {c}
      else if (child.baseName = 'fixedTime') then
        result.fixed := ParseTime(child, path+'.fixedTime') {c}
      else if (child.baseName = 'fixedOid') then
        result.fixed := ParseOid(child, path+'.fixedOid') {c}
      else if (child.baseName = 'fixedPositiveInt') then
        result.fixed := ParsePositiveInt(child, path+'.fixedPositiveInt') {c}
      else if (child.baseName = 'fixedString') then
        result.fixed := ParseString(child, path+'.fixedString') {c}
      else if (child.baseName = 'fixedBoolean') then
        result.fixed := ParseBoolean(child, path+'.fixedBoolean') {c}
      else if (child.baseName = 'fixedUuid') then
        result.fixed := ParseUuid(child, path+'.fixedUuid') {c}
      else if (child.baseName = 'fixedInstant') then
        result.fixed := ParseInstant(child, path+'.fixedInstant') {c}
      else if (child.baseName = 'fixedPeriod') then
        result.fixed := ParsePeriod(child, path+'.fixedPeriod') {ePeriod}
      else if (child.baseName = 'fixedCoding') then
        result.fixed := ParseCoding(child, path+'.fixedCoding') {eCoding}
      else if (child.baseName = 'fixedRange') then
        result.fixed := ParseRange(child, path+'.fixedRange') {eRange}
      else if (child.baseName = 'fixedQuantity') then
        result.fixed := ParseQuantity(child, path+'.fixedQuantity') {eQuantity}
      else if (child.baseName = 'fixedAttachment') then
        result.fixed := ParseAttachment(child, path+'.fixedAttachment') {eAttachment}
      else if (child.baseName = 'fixedRatio') then
        result.fixed := ParseRatio(child, path+'.fixedRatio') {eRatio}
      else if (child.baseName = 'fixedSampledData') then
        result.fixed := ParseSampledData(child, path+'.fixedSampledData') {eSampledData}
      else if (child.baseName = 'fixedReference') then
        result.fixed := ParseReference(child, path+'.fixedReference') {eReference}
      else if (child.baseName = 'fixedCodeableConcept') then
        result.fixed := ParseCodeableConcept(child, path+'.fixedCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'fixedIdentifier') then
        result.fixed := ParseIdentifier(child, path+'.fixedIdentifier') {eIdentifier}
      else if (child.baseName = 'fixedSignature') then
        result.fixed := ParseSignature(child, path+'.fixedSignature') {eSignature}
      else if (child.baseName = 'fixedElementDefinition') then
        result.fixed := ParseElementDefinition(child, path+'/fixedElementDefinition') {f}
      else if (child.baseName = 'fixedTiming') then
        result.fixed := ParseTiming(child, path+'/fixedTiming') {f}
      else if (child.baseName = 'fixedAddress') then
        result.fixed := ParseAddress(child, path+'/fixedAddress') {f}
      else if (child.baseName = 'fixedHumanName') then
        result.fixed := ParseHumanName(child, path+'/fixedHumanName') {f}
      else if (child.baseName = 'fixedMeta') then
        result.fixed := ParseMeta(child, path+'/fixedMeta') {f}
      else if (child.baseName = 'fixedContactPoint') then
        result.fixed := ParseContactPoint(child, path+'/fixedContactPoint') {f}
      else if (child.baseName = 'patternInteger') then
        result.pattern := ParseInteger(child, path+'.patternInteger') {c}
      else if (child.baseName = 'patternDateTime') then
        result.pattern := ParseDateTime(child, path+'.patternDateTime') {c}
      else if (child.baseName = 'patternUnsignedInt') then
        result.pattern := ParseUnsignedInt(child, path+'.patternUnsignedInt') {c}
      else if (child.baseName = 'patternCode') then
        result.pattern := ParseCode(child, path+'.patternCode') {c}
      else if (child.baseName = 'patternDate') then
        result.pattern := ParseDate(child, path+'.patternDate') {c}
      else if (child.baseName = 'patternDecimal') then
        result.pattern := ParseDecimal(child, path+'.patternDecimal') {c}
      else if (child.baseName = 'patternUri') then
        result.pattern := ParseUri(child, path+'.patternUri') {c}
      else if (child.baseName = 'patternId') then
        result.pattern := ParseId(child, path+'.patternId') {c}
      else if (child.baseName = 'patternBase64Binary') then
        result.pattern := ParseBase64Binary(child, path+'.patternBase64Binary') {c}
      else if (child.baseName = 'patternTime') then
        result.pattern := ParseTime(child, path+'.patternTime') {c}
      else if (child.baseName = 'patternOid') then
        result.pattern := ParseOid(child, path+'.patternOid') {c}
      else if (child.baseName = 'patternPositiveInt') then
        result.pattern := ParsePositiveInt(child, path+'.patternPositiveInt') {c}
      else if (child.baseName = 'patternString') then
        result.pattern := ParseString(child, path+'.patternString') {c}
      else if (child.baseName = 'patternBoolean') then
        result.pattern := ParseBoolean(child, path+'.patternBoolean') {c}
      else if (child.baseName = 'patternUuid') then
        result.pattern := ParseUuid(child, path+'.patternUuid') {c}
      else if (child.baseName = 'patternInstant') then
        result.pattern := ParseInstant(child, path+'.patternInstant') {c}
      else if (child.baseName = 'patternPeriod') then
        result.pattern := ParsePeriod(child, path+'.patternPeriod') {ePeriod}
      else if (child.baseName = 'patternCoding') then
        result.pattern := ParseCoding(child, path+'.patternCoding') {eCoding}
      else if (child.baseName = 'patternRange') then
        result.pattern := ParseRange(child, path+'.patternRange') {eRange}
      else if (child.baseName = 'patternQuantity') then
        result.pattern := ParseQuantity(child, path+'.patternQuantity') {eQuantity}
      else if (child.baseName = 'patternAttachment') then
        result.pattern := ParseAttachment(child, path+'.patternAttachment') {eAttachment}
      else if (child.baseName = 'patternRatio') then
        result.pattern := ParseRatio(child, path+'.patternRatio') {eRatio}
      else if (child.baseName = 'patternSampledData') then
        result.pattern := ParseSampledData(child, path+'.patternSampledData') {eSampledData}
      else if (child.baseName = 'patternReference') then
        result.pattern := ParseReference(child, path+'.patternReference') {eReference}
      else if (child.baseName = 'patternCodeableConcept') then
        result.pattern := ParseCodeableConcept(child, path+'.patternCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'patternIdentifier') then
        result.pattern := ParseIdentifier(child, path+'.patternIdentifier') {eIdentifier}
      else if (child.baseName = 'patternSignature') then
        result.pattern := ParseSignature(child, path+'.patternSignature') {eSignature}
      else if (child.baseName = 'patternElementDefinition') then
        result.pattern := ParseElementDefinition(child, path+'/patternElementDefinition') {f}
      else if (child.baseName = 'patternTiming') then
        result.pattern := ParseTiming(child, path+'/patternTiming') {f}
      else if (child.baseName = 'patternAddress') then
        result.pattern := ParseAddress(child, path+'/patternAddress') {f}
      else if (child.baseName = 'patternHumanName') then
        result.pattern := ParseHumanName(child, path+'/patternHumanName') {f}
      else if (child.baseName = 'patternMeta') then
        result.pattern := ParseMeta(child, path+'/patternMeta') {f}
      else if (child.baseName = 'patternContactPoint') then
        result.pattern := ParseContactPoint(child, path+'/patternContactPoint') {f}
      else if (child.baseName = 'exampleInteger') then
        result.example := ParseInteger(child, path+'.exampleInteger') {c}
      else if (child.baseName = 'exampleDateTime') then
        result.example := ParseDateTime(child, path+'.exampleDateTime') {c}
      else if (child.baseName = 'exampleUnsignedInt') then
        result.example := ParseUnsignedInt(child, path+'.exampleUnsignedInt') {c}
      else if (child.baseName = 'exampleCode') then
        result.example := ParseCode(child, path+'.exampleCode') {c}
      else if (child.baseName = 'exampleDate') then
        result.example := ParseDate(child, path+'.exampleDate') {c}
      else if (child.baseName = 'exampleDecimal') then
        result.example := ParseDecimal(child, path+'.exampleDecimal') {c}
      else if (child.baseName = 'exampleUri') then
        result.example := ParseUri(child, path+'.exampleUri') {c}
      else if (child.baseName = 'exampleId') then
        result.example := ParseId(child, path+'.exampleId') {c}
      else if (child.baseName = 'exampleBase64Binary') then
        result.example := ParseBase64Binary(child, path+'.exampleBase64Binary') {c}
      else if (child.baseName = 'exampleTime') then
        result.example := ParseTime(child, path+'.exampleTime') {c}
      else if (child.baseName = 'exampleOid') then
        result.example := ParseOid(child, path+'.exampleOid') {c}
      else if (child.baseName = 'examplePositiveInt') then
        result.example := ParsePositiveInt(child, path+'.examplePositiveInt') {c}
      else if (child.baseName = 'exampleString') then
        result.example := ParseString(child, path+'.exampleString') {c}
      else if (child.baseName = 'exampleBoolean') then
        result.example := ParseBoolean(child, path+'.exampleBoolean') {c}
      else if (child.baseName = 'exampleUuid') then
        result.example := ParseUuid(child, path+'.exampleUuid') {c}
      else if (child.baseName = 'exampleInstant') then
        result.example := ParseInstant(child, path+'.exampleInstant') {c}
      else if (child.baseName = 'examplePeriod') then
        result.example := ParsePeriod(child, path+'.examplePeriod') {ePeriod}
      else if (child.baseName = 'exampleCoding') then
        result.example := ParseCoding(child, path+'.exampleCoding') {eCoding}
      else if (child.baseName = 'exampleRange') then
        result.example := ParseRange(child, path+'.exampleRange') {eRange}
      else if (child.baseName = 'exampleQuantity') then
        result.example := ParseQuantity(child, path+'.exampleQuantity') {eQuantity}
      else if (child.baseName = 'exampleAttachment') then
        result.example := ParseAttachment(child, path+'.exampleAttachment') {eAttachment}
      else if (child.baseName = 'exampleRatio') then
        result.example := ParseRatio(child, path+'.exampleRatio') {eRatio}
      else if (child.baseName = 'exampleSampledData') then
        result.example := ParseSampledData(child, path+'.exampleSampledData') {eSampledData}
      else if (child.baseName = 'exampleReference') then
        result.example := ParseReference(child, path+'.exampleReference') {eReference}
      else if (child.baseName = 'exampleCodeableConcept') then
        result.example := ParseCodeableConcept(child, path+'.exampleCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'exampleIdentifier') then
        result.example := ParseIdentifier(child, path+'.exampleIdentifier') {eIdentifier}
      else if (child.baseName = 'exampleSignature') then
        result.example := ParseSignature(child, path+'.exampleSignature') {eSignature}
      else if (child.baseName = 'exampleElementDefinition') then
        result.example := ParseElementDefinition(child, path+'/exampleElementDefinition') {f}
      else if (child.baseName = 'exampleTiming') then
        result.example := ParseTiming(child, path+'/exampleTiming') {f}
      else if (child.baseName = 'exampleAddress') then
        result.example := ParseAddress(child, path+'/exampleAddress') {f}
      else if (child.baseName = 'exampleHumanName') then
        result.example := ParseHumanName(child, path+'/exampleHumanName') {f}
      else if (child.baseName = 'exampleMeta') then
        result.example := ParseMeta(child, path+'/exampleMeta') {f}
      else if (child.baseName = 'exampleContactPoint') then
        result.example := ParseContactPoint(child, path+'/exampleContactPoint') {f}
      else if (child.baseName = 'maxLength') then
        result.maxLengthElement := ParseInteger(child, path+'/maxLength') {b}
      else if (child.baseName = 'condition') then
        result.conditionList.Add(ParseId(child, path+'/condition')){y.2}
      else if (child.baseName = 'constraint') then
        result.constraintList.Add(ParseElementDefinitionConstraint(child, path+'/constraint')){y.2}
      else if (child.baseName = 'mustSupport') then
        result.mustSupportElement := ParseBoolean(child, path+'/mustSupport') {b}
      else if (child.baseName = 'isModifier') then
        result.isModifierElement := ParseBoolean(child, path+'/isModifier') {b}
      else if (child.baseName = 'isSummary') then
        result.isSummaryElement := ParseBoolean(child, path+'/isSummary') {b}
      else if (child.baseName = 'binding') then
        result.binding := ParseElementDefinitionBinding(child, path+'/binding') {b}
      else if (child.baseName = 'mapping') then
        result.mappingList.Add(ParseElementDefinitionMapping(child, path+'/mapping')){y.2}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeElementDefinition(xml : TXmlBuilder; name : string; elem : TFhirElementDefinition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeString(xml, 'path', elem.pathElement);{x.2}
  for i := 0 to elem.representationElement.Count - 1 do
    ComposeEnum(xml, 'representation', elem.representationElement[i], CODES_TFhirPropertyRepresentation);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeString(xml, 'label', elem.label_Element);{x.2}
  for i := 0 to elem.codeList.Count - 1 do
    ComposeCoding(xml, 'code', elem.codeList[i]);
  ComposeElementDefinitionSlicing(xml, 'slicing', elem.slicing);{x.2}
  ComposeString(xml, 'short', elem.shortElement);{x.2}
  ComposeString(xml, 'definition', elem.definitionElement);{x.2}
  ComposeString(xml, 'comments', elem.commentsElement);{x.2}
  ComposeString(xml, 'requirements', elem.requirementsElement);{x.2}
  for i := 0 to elem.aliasList.Count - 1 do
    ComposeString(xml, 'alias', elem.aliasList[i]);
  ComposeInteger(xml, 'min', elem.minElement);{x.2}
  ComposeString(xml, 'max', elem.maxElement);{x.2}
  for i := 0 to elem.type_List.Count - 1 do
    ComposeElementDefinitionType(xml, 'type', elem.type_List[i]);
  ComposeString(xml, 'nameReference', elem.nameReferenceElement);{x.2}
  if (elem.defaultValue is TFhirInteger) {1} then
    ComposeInteger(xml, 'defaultValueInteger', TFhirInteger(elem.defaultValue))
  else if (elem.defaultValue is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'defaultValueDateTime', TFhirDateTime(elem.defaultValue))
  else if (elem.defaultValue is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue))
  else if (elem.defaultValue is TFhirCode) {1} then
    ComposeCode(xml, 'defaultValueCode', TFhirCode(elem.defaultValue))
  else if (elem.defaultValue is TFhirDate) {1} then
    ComposeDate(xml, 'defaultValueDate', TFhirDate(elem.defaultValue))
  else if (elem.defaultValue is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'defaultValueDecimal', TFhirDecimal(elem.defaultValue))
  else if (elem.defaultValue is TFhirUri) {1} then
    ComposeUri(xml, 'defaultValueUri', TFhirUri(elem.defaultValue))
  else if (elem.defaultValue is TFhirId) {1} then
    ComposeId(xml, 'defaultValueId', TFhirId(elem.defaultValue))
  else if (elem.defaultValue is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue))
  else if (elem.defaultValue is TFhirTime) {1} then
    ComposeTime(xml, 'defaultValueTime', TFhirTime(elem.defaultValue))
  else if (elem.defaultValue is TFhirOid) {1} then
    ComposeOid(xml, 'defaultValueOid', TFhirOid(elem.defaultValue))
  else if (elem.defaultValue is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue))
  else if (elem.defaultValue is TFhirString) {1} then
    ComposeString(xml, 'defaultValueString', TFhirString(elem.defaultValue))
  else if (elem.defaultValue is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'defaultValueBoolean', TFhirBoolean(elem.defaultValue))
  else if (elem.defaultValue is TFhirUuid) {1} then
    ComposeUuid(xml, 'defaultValueUuid', TFhirUuid(elem.defaultValue))
  else if (elem.defaultValue is TFhirInstant) {1} then
    ComposeInstant(xml, 'defaultValueInstant', TFhirInstant(elem.defaultValue))
  else if (elem.defaultValue is TFhirPeriod) {8} then
    ComposePeriod(xml, 'defaultValuePeriod', TFhirPeriod(elem.defaultValue))
  else if (elem.defaultValue is TFhirCoding) {8} then
    ComposeCoding(xml, 'defaultValueCoding', TFhirCoding(elem.defaultValue))
  else if (elem.defaultValue is TFhirRange) {8} then
    ComposeRange(xml, 'defaultValueRange', TFhirRange(elem.defaultValue))
  else if (elem.defaultValue is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'defaultValueQuantity', TFhirQuantity(elem.defaultValue))
  else if (elem.defaultValue is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'defaultValueAttachment', TFhirAttachment(elem.defaultValue))
  else if (elem.defaultValue is TFhirRatio) {8} then
    ComposeRatio(xml, 'defaultValueRatio', TFhirRatio(elem.defaultValue))
  else if (elem.defaultValue is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'defaultValueSampledData', TFhirSampledData(elem.defaultValue))
  else if (elem.defaultValue is TFhirReference) {8} then
    ComposeReference(xml, 'defaultValueReference', TFhirReference(elem.defaultValue))
  else if (elem.defaultValue is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'defaultValueCodeableConcept', TFhirCodeableConcept(elem.defaultValue))
  else if (elem.defaultValue is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'defaultValueIdentifier', TFhirIdentifier(elem.defaultValue))
  else if (elem.defaultValue is TFhirSignature) {8} then
    ComposeSignature(xml, 'defaultValueSignature', TFhirSignature(elem.defaultValue))
  else if (elem.defaultValue is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'defaultValueElementDefinition', TFhirElementDefinition(elem.defaultValue))
  else if (elem.defaultValue is TFhirTiming) {9} then
    ComposeTiming(xml, 'defaultValueTiming', TFhirTiming(elem.defaultValue))
  else if (elem.defaultValue is TFhirAddress) {9} then
    ComposeAddress(xml, 'defaultValueAddress', TFhirAddress(elem.defaultValue))
  else if (elem.defaultValue is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'defaultValueHumanName', TFhirHumanName(elem.defaultValue))
  else if (elem.defaultValue is TFhirMeta) {9} then
    ComposeMeta(xml, 'defaultValueMeta', TFhirMeta(elem.defaultValue))
  else if (elem.defaultValue is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'defaultValueContactPoint', TFhirContactPoint(elem.defaultValue));
  ComposeString(xml, 'meaningWhenMissing', elem.meaningWhenMissingElement);{x.2}
  if (elem.fixed is TFhirInteger) {1} then
    ComposeInteger(xml, 'fixedInteger', TFhirInteger(elem.fixed))
  else if (elem.fixed is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'fixedDateTime', TFhirDateTime(elem.fixed))
  else if (elem.fixed is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'fixedUnsignedInt', TFhirUnsignedInt(elem.fixed))
  else if (elem.fixed is TFhirCode) {1} then
    ComposeCode(xml, 'fixedCode', TFhirCode(elem.fixed))
  else if (elem.fixed is TFhirDate) {1} then
    ComposeDate(xml, 'fixedDate', TFhirDate(elem.fixed))
  else if (elem.fixed is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'fixedDecimal', TFhirDecimal(elem.fixed))
  else if (elem.fixed is TFhirUri) {1} then
    ComposeUri(xml, 'fixedUri', TFhirUri(elem.fixed))
  else if (elem.fixed is TFhirId) {1} then
    ComposeId(xml, 'fixedId', TFhirId(elem.fixed))
  else if (elem.fixed is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'fixedBase64Binary', TFhirBase64Binary(elem.fixed))
  else if (elem.fixed is TFhirTime) {1} then
    ComposeTime(xml, 'fixedTime', TFhirTime(elem.fixed))
  else if (elem.fixed is TFhirOid) {1} then
    ComposeOid(xml, 'fixedOid', TFhirOid(elem.fixed))
  else if (elem.fixed is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'fixedPositiveInt', TFhirPositiveInt(elem.fixed))
  else if (elem.fixed is TFhirString) {1} then
    ComposeString(xml, 'fixedString', TFhirString(elem.fixed))
  else if (elem.fixed is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'fixedBoolean', TFhirBoolean(elem.fixed))
  else if (elem.fixed is TFhirUuid) {1} then
    ComposeUuid(xml, 'fixedUuid', TFhirUuid(elem.fixed))
  else if (elem.fixed is TFhirInstant) {1} then
    ComposeInstant(xml, 'fixedInstant', TFhirInstant(elem.fixed))
  else if (elem.fixed is TFhirPeriod) {8} then
    ComposePeriod(xml, 'fixedPeriod', TFhirPeriod(elem.fixed))
  else if (elem.fixed is TFhirCoding) {8} then
    ComposeCoding(xml, 'fixedCoding', TFhirCoding(elem.fixed))
  else if (elem.fixed is TFhirRange) {8} then
    ComposeRange(xml, 'fixedRange', TFhirRange(elem.fixed))
  else if (elem.fixed is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'fixedQuantity', TFhirQuantity(elem.fixed))
  else if (elem.fixed is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'fixedAttachment', TFhirAttachment(elem.fixed))
  else if (elem.fixed is TFhirRatio) {8} then
    ComposeRatio(xml, 'fixedRatio', TFhirRatio(elem.fixed))
  else if (elem.fixed is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'fixedSampledData', TFhirSampledData(elem.fixed))
  else if (elem.fixed is TFhirReference) {8} then
    ComposeReference(xml, 'fixedReference', TFhirReference(elem.fixed))
  else if (elem.fixed is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'fixedCodeableConcept', TFhirCodeableConcept(elem.fixed))
  else if (elem.fixed is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'fixedIdentifier', TFhirIdentifier(elem.fixed))
  else if (elem.fixed is TFhirSignature) {8} then
    ComposeSignature(xml, 'fixedSignature', TFhirSignature(elem.fixed))
  else if (elem.fixed is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'fixedElementDefinition', TFhirElementDefinition(elem.fixed))
  else if (elem.fixed is TFhirTiming) {9} then
    ComposeTiming(xml, 'fixedTiming', TFhirTiming(elem.fixed))
  else if (elem.fixed is TFhirAddress) {9} then
    ComposeAddress(xml, 'fixedAddress', TFhirAddress(elem.fixed))
  else if (elem.fixed is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'fixedHumanName', TFhirHumanName(elem.fixed))
  else if (elem.fixed is TFhirMeta) {9} then
    ComposeMeta(xml, 'fixedMeta', TFhirMeta(elem.fixed))
  else if (elem.fixed is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'fixedContactPoint', TFhirContactPoint(elem.fixed));
  if (elem.pattern is TFhirInteger) {1} then
    ComposeInteger(xml, 'patternInteger', TFhirInteger(elem.pattern))
  else if (elem.pattern is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'patternDateTime', TFhirDateTime(elem.pattern))
  else if (elem.pattern is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'patternUnsignedInt', TFhirUnsignedInt(elem.pattern))
  else if (elem.pattern is TFhirCode) {1} then
    ComposeCode(xml, 'patternCode', TFhirCode(elem.pattern))
  else if (elem.pattern is TFhirDate) {1} then
    ComposeDate(xml, 'patternDate', TFhirDate(elem.pattern))
  else if (elem.pattern is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'patternDecimal', TFhirDecimal(elem.pattern))
  else if (elem.pattern is TFhirUri) {1} then
    ComposeUri(xml, 'patternUri', TFhirUri(elem.pattern))
  else if (elem.pattern is TFhirId) {1} then
    ComposeId(xml, 'patternId', TFhirId(elem.pattern))
  else if (elem.pattern is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'patternBase64Binary', TFhirBase64Binary(elem.pattern))
  else if (elem.pattern is TFhirTime) {1} then
    ComposeTime(xml, 'patternTime', TFhirTime(elem.pattern))
  else if (elem.pattern is TFhirOid) {1} then
    ComposeOid(xml, 'patternOid', TFhirOid(elem.pattern))
  else if (elem.pattern is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'patternPositiveInt', TFhirPositiveInt(elem.pattern))
  else if (elem.pattern is TFhirString) {1} then
    ComposeString(xml, 'patternString', TFhirString(elem.pattern))
  else if (elem.pattern is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'patternBoolean', TFhirBoolean(elem.pattern))
  else if (elem.pattern is TFhirUuid) {1} then
    ComposeUuid(xml, 'patternUuid', TFhirUuid(elem.pattern))
  else if (elem.pattern is TFhirInstant) {1} then
    ComposeInstant(xml, 'patternInstant', TFhirInstant(elem.pattern))
  else if (elem.pattern is TFhirPeriod) {8} then
    ComposePeriod(xml, 'patternPeriod', TFhirPeriod(elem.pattern))
  else if (elem.pattern is TFhirCoding) {8} then
    ComposeCoding(xml, 'patternCoding', TFhirCoding(elem.pattern))
  else if (elem.pattern is TFhirRange) {8} then
    ComposeRange(xml, 'patternRange', TFhirRange(elem.pattern))
  else if (elem.pattern is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'patternQuantity', TFhirQuantity(elem.pattern))
  else if (elem.pattern is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'patternAttachment', TFhirAttachment(elem.pattern))
  else if (elem.pattern is TFhirRatio) {8} then
    ComposeRatio(xml, 'patternRatio', TFhirRatio(elem.pattern))
  else if (elem.pattern is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'patternSampledData', TFhirSampledData(elem.pattern))
  else if (elem.pattern is TFhirReference) {8} then
    ComposeReference(xml, 'patternReference', TFhirReference(elem.pattern))
  else if (elem.pattern is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'patternCodeableConcept', TFhirCodeableConcept(elem.pattern))
  else if (elem.pattern is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'patternIdentifier', TFhirIdentifier(elem.pattern))
  else if (elem.pattern is TFhirSignature) {8} then
    ComposeSignature(xml, 'patternSignature', TFhirSignature(elem.pattern))
  else if (elem.pattern is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'patternElementDefinition', TFhirElementDefinition(elem.pattern))
  else if (elem.pattern is TFhirTiming) {9} then
    ComposeTiming(xml, 'patternTiming', TFhirTiming(elem.pattern))
  else if (elem.pattern is TFhirAddress) {9} then
    ComposeAddress(xml, 'patternAddress', TFhirAddress(elem.pattern))
  else if (elem.pattern is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'patternHumanName', TFhirHumanName(elem.pattern))
  else if (elem.pattern is TFhirMeta) {9} then
    ComposeMeta(xml, 'patternMeta', TFhirMeta(elem.pattern))
  else if (elem.pattern is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'patternContactPoint', TFhirContactPoint(elem.pattern));
  if (elem.example is TFhirInteger) {1} then
    ComposeInteger(xml, 'exampleInteger', TFhirInteger(elem.example))
  else if (elem.example is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'exampleDateTime', TFhirDateTime(elem.example))
  else if (elem.example is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'exampleUnsignedInt', TFhirUnsignedInt(elem.example))
  else if (elem.example is TFhirCode) {1} then
    ComposeCode(xml, 'exampleCode', TFhirCode(elem.example))
  else if (elem.example is TFhirDate) {1} then
    ComposeDate(xml, 'exampleDate', TFhirDate(elem.example))
  else if (elem.example is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'exampleDecimal', TFhirDecimal(elem.example))
  else if (elem.example is TFhirUri) {1} then
    ComposeUri(xml, 'exampleUri', TFhirUri(elem.example))
  else if (elem.example is TFhirId) {1} then
    ComposeId(xml, 'exampleId', TFhirId(elem.example))
  else if (elem.example is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'exampleBase64Binary', TFhirBase64Binary(elem.example))
  else if (elem.example is TFhirTime) {1} then
    ComposeTime(xml, 'exampleTime', TFhirTime(elem.example))
  else if (elem.example is TFhirOid) {1} then
    ComposeOid(xml, 'exampleOid', TFhirOid(elem.example))
  else if (elem.example is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'examplePositiveInt', TFhirPositiveInt(elem.example))
  else if (elem.example is TFhirString) {1} then
    ComposeString(xml, 'exampleString', TFhirString(elem.example))
  else if (elem.example is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'exampleBoolean', TFhirBoolean(elem.example))
  else if (elem.example is TFhirUuid) {1} then
    ComposeUuid(xml, 'exampleUuid', TFhirUuid(elem.example))
  else if (elem.example is TFhirInstant) {1} then
    ComposeInstant(xml, 'exampleInstant', TFhirInstant(elem.example))
  else if (elem.example is TFhirPeriod) {8} then
    ComposePeriod(xml, 'examplePeriod', TFhirPeriod(elem.example))
  else if (elem.example is TFhirCoding) {8} then
    ComposeCoding(xml, 'exampleCoding', TFhirCoding(elem.example))
  else if (elem.example is TFhirRange) {8} then
    ComposeRange(xml, 'exampleRange', TFhirRange(elem.example))
  else if (elem.example is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'exampleQuantity', TFhirQuantity(elem.example))
  else if (elem.example is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'exampleAttachment', TFhirAttachment(elem.example))
  else if (elem.example is TFhirRatio) {8} then
    ComposeRatio(xml, 'exampleRatio', TFhirRatio(elem.example))
  else if (elem.example is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'exampleSampledData', TFhirSampledData(elem.example))
  else if (elem.example is TFhirReference) {8} then
    ComposeReference(xml, 'exampleReference', TFhirReference(elem.example))
  else if (elem.example is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'exampleCodeableConcept', TFhirCodeableConcept(elem.example))
  else if (elem.example is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'exampleIdentifier', TFhirIdentifier(elem.example))
  else if (elem.example is TFhirSignature) {8} then
    ComposeSignature(xml, 'exampleSignature', TFhirSignature(elem.example))
  else if (elem.example is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'exampleElementDefinition', TFhirElementDefinition(elem.example))
  else if (elem.example is TFhirTiming) {9} then
    ComposeTiming(xml, 'exampleTiming', TFhirTiming(elem.example))
  else if (elem.example is TFhirAddress) {9} then
    ComposeAddress(xml, 'exampleAddress', TFhirAddress(elem.example))
  else if (elem.example is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'exampleHumanName', TFhirHumanName(elem.example))
  else if (elem.example is TFhirMeta) {9} then
    ComposeMeta(xml, 'exampleMeta', TFhirMeta(elem.example))
  else if (elem.example is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'exampleContactPoint', TFhirContactPoint(elem.example));
  ComposeInteger(xml, 'maxLength', elem.maxLengthElement);{x.2}
  for i := 0 to elem.conditionList.Count - 1 do
    ComposeId(xml, 'condition', elem.conditionList[i]);
  for i := 0 to elem.constraintList.Count - 1 do
    ComposeElementDefinitionConstraint(xml, 'constraint', elem.constraintList[i]);
  ComposeBoolean(xml, 'mustSupport', elem.mustSupportElement);{x.2}
  ComposeBoolean(xml, 'isModifier', elem.isModifierElement);{x.2}
  ComposeBoolean(xml, 'isSummary', elem.isSummaryElement);{x.2}
  ComposeElementDefinitionBinding(xml, 'binding', elem.binding);{x.2}
  for i := 0 to elem.mappingList.Count - 1 do
    ComposeElementDefinitionMapping(xml, 'mapping', elem.mappingList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseElementDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinition(jsn : TJsonObject) : TFhirElementDefinition;
begin
  result := TFhirElementDefinition.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := ParseString(jsn['path'], jsn.vObj['_path']);{q}
    if jsn.has('representation') or jsn.has('_representation') then
      iterateEnumArray(jsn.vArr['representation'], jsn.vArr['_representation'], result.representationElement, parseEnum, CODES_TFhirPropertyRepresentation);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('label') or jsn.has('_label') then
        result.label_Element := ParseString(jsn['label'], jsn.vObj['_label']);{q}
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCoding);
    if jsn.has('slicing') then
        result.slicing := ParseElementDefinitionSlicing(jsn.vObj['slicing']);{q}
    if jsn.has('short') or jsn.has('_short') then
        result.shortElement := ParseString(jsn['short'], jsn.vObj['_short']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := ParseString(jsn['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsElement := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
      if jsn.has('alias') or jsn.has('_alias') then
      iteratePrimitiveArray(jsn.vArr['alias'], jsn.vArr['_alias'], result.aliasList, parseString);
    if jsn.has('min') or jsn.has('_min') then
        result.minElement := ParseInteger(jsn['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxElement := ParseString(jsn['max'], jsn.vObj['_max']);{q}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseElementDefinitionType);
    if jsn.has('nameReference') or jsn.has('_nameReference') then
        result.nameReferenceElement := ParseString(jsn['nameReference'], jsn.vObj['_nameReference']);{q}
    if jsn.has('defaultValueInteger') or jsn.has('_defaultValueInteger') then
        result.defaultValue := ParseInteger(jsn['defaultValueInteger'], jsn.vObj['_defaultValueInteger']);
    if jsn.has('defaultValueDateTime') or jsn.has('_defaultValueDateTime') then
        result.defaultValue := ParseDateTime(jsn['defaultValueDateTime'], jsn.vObj['_defaultValueDateTime']);
    if jsn.has('defaultValueUnsignedInt') or jsn.has('_defaultValueUnsignedInt') then
        result.defaultValue := ParseUnsignedInt(jsn['defaultValueUnsignedInt'], jsn.vObj['_defaultValueUnsignedInt']);
    if jsn.has('defaultValueCode') or jsn.has('_defaultValueCode') then
        result.defaultValue := ParseCode(jsn['defaultValueCode'], jsn.vObj['_defaultValueCode']);
    if jsn.has('defaultValueDate') or jsn.has('_defaultValueDate') then
        result.defaultValue := ParseDate(jsn['defaultValueDate'], jsn.vObj['_defaultValueDate']);
    if jsn.has('defaultValueDecimal') or jsn.has('_defaultValueDecimal') then
        result.defaultValue := ParseDecimal(jsn['defaultValueDecimal'], jsn.vObj['_defaultValueDecimal']);
    if jsn.has('defaultValueUri') or jsn.has('_defaultValueUri') then
        result.defaultValue := ParseUri(jsn['defaultValueUri'], jsn.vObj['_defaultValueUri']);
    if jsn.has('defaultValueId') or jsn.has('_defaultValueId') then
        result.defaultValue := ParseId(jsn['defaultValueId'], jsn.vObj['_defaultValueId']);
    if jsn.has('defaultValueBase64Binary') or jsn.has('_defaultValueBase64Binary') then
        result.defaultValue := ParseBase64Binary(jsn['defaultValueBase64Binary'], jsn.vObj['_defaultValueBase64Binary']);
    if jsn.has('defaultValueTime') or jsn.has('_defaultValueTime') then
        result.defaultValue := ParseTime(jsn['defaultValueTime'], jsn.vObj['_defaultValueTime']);
    if jsn.has('defaultValueOid') or jsn.has('_defaultValueOid') then
        result.defaultValue := ParseOid(jsn['defaultValueOid'], jsn.vObj['_defaultValueOid']);
    if jsn.has('defaultValuePositiveInt') or jsn.has('_defaultValuePositiveInt') then
        result.defaultValue := ParsePositiveInt(jsn['defaultValuePositiveInt'], jsn.vObj['_defaultValuePositiveInt']);
    if jsn.has('defaultValueString') or jsn.has('_defaultValueString') then
        result.defaultValue := ParseString(jsn['defaultValueString'], jsn.vObj['_defaultValueString']);
    if jsn.has('defaultValueBoolean') or jsn.has('_defaultValueBoolean') then
        result.defaultValue := ParseBoolean(jsn['defaultValueBoolean'], jsn.vObj['_defaultValueBoolean']);
    if jsn.has('defaultValueUuid') or jsn.has('_defaultValueUuid') then
        result.defaultValue := ParseUuid(jsn['defaultValueUuid'], jsn.vObj['_defaultValueUuid']);
    if jsn.has('defaultValueInstant') or jsn.has('_defaultValueInstant') then
        result.defaultValue := ParseInstant(jsn['defaultValueInstant'], jsn.vObj['_defaultValueInstant']);
    if jsn.has('defaultValuePeriod') {a7} then
        result.defaultValue := ParsePeriod(jsn.vObj['defaultValuePeriod']);
    if jsn.has('defaultValueCoding') {a7} then
        result.defaultValue := ParseCoding(jsn.vObj['defaultValueCoding']);
    if jsn.has('defaultValueRange') {a7} then
        result.defaultValue := ParseRange(jsn.vObj['defaultValueRange']);
    if jsn.has('defaultValueQuantity') {a7} then
        result.defaultValue := ParseQuantity(jsn.vObj['defaultValueQuantity']);
    if jsn.has('defaultValueAttachment') {a7} then
        result.defaultValue := ParseAttachment(jsn.vObj['defaultValueAttachment']);
    if jsn.has('defaultValueRatio') {a7} then
        result.defaultValue := ParseRatio(jsn.vObj['defaultValueRatio']);
    if jsn.has('defaultValueSampledData') {a7} then
        result.defaultValue := ParseSampledData(jsn.vObj['defaultValueSampledData']);
    if jsn.has('defaultValueReference') {a7} then
        result.defaultValue := ParseReference(jsn.vObj['defaultValueReference']);
    if jsn.has('defaultValueCodeableConcept') {a7} then
        result.defaultValue := ParseCodeableConcept(jsn.vObj['defaultValueCodeableConcept']);
    if jsn.has('defaultValueIdentifier') {a7} then
        result.defaultValue := ParseIdentifier(jsn.vObj['defaultValueIdentifier']);
    if jsn.has('defaultValueSignature') {a7} then
        result.defaultValue := ParseSignature(jsn.vObj['defaultValueSignature']);
    if jsn.has('defaultValueElementDefinition') {a9} then
        result.defaultValue := ParseElementDefinition(jsn.vObj['defaultValueElementDefinition']);
    if jsn.has('defaultValueTiming') {a9} then
        result.defaultValue := ParseTiming(jsn.vObj['defaultValueTiming']);
    if jsn.has('defaultValueAddress') {a9} then
        result.defaultValue := ParseAddress(jsn.vObj['defaultValueAddress']);
    if jsn.has('defaultValueHumanName') {a9} then
        result.defaultValue := ParseHumanName(jsn.vObj['defaultValueHumanName']);
    if jsn.has('defaultValueMeta') {a9} then
        result.defaultValue := ParseMeta(jsn.vObj['defaultValueMeta']);
    if jsn.has('defaultValueContactPoint') {a9} then
        result.defaultValue := ParseContactPoint(jsn.vObj['defaultValueContactPoint']);
    if jsn.has('meaningWhenMissing') or jsn.has('_meaningWhenMissing') then
        result.meaningWhenMissingElement := ParseString(jsn['meaningWhenMissing'], jsn.vObj['_meaningWhenMissing']);{q}
    if jsn.has('fixedInteger') or jsn.has('_fixedInteger') then
        result.fixed := ParseInteger(jsn['fixedInteger'], jsn.vObj['_fixedInteger']);
    if jsn.has('fixedDateTime') or jsn.has('_fixedDateTime') then
        result.fixed := ParseDateTime(jsn['fixedDateTime'], jsn.vObj['_fixedDateTime']);
    if jsn.has('fixedUnsignedInt') or jsn.has('_fixedUnsignedInt') then
        result.fixed := ParseUnsignedInt(jsn['fixedUnsignedInt'], jsn.vObj['_fixedUnsignedInt']);
    if jsn.has('fixedCode') or jsn.has('_fixedCode') then
        result.fixed := ParseCode(jsn['fixedCode'], jsn.vObj['_fixedCode']);
    if jsn.has('fixedDate') or jsn.has('_fixedDate') then
        result.fixed := ParseDate(jsn['fixedDate'], jsn.vObj['_fixedDate']);
    if jsn.has('fixedDecimal') or jsn.has('_fixedDecimal') then
        result.fixed := ParseDecimal(jsn['fixedDecimal'], jsn.vObj['_fixedDecimal']);
    if jsn.has('fixedUri') or jsn.has('_fixedUri') then
        result.fixed := ParseUri(jsn['fixedUri'], jsn.vObj['_fixedUri']);
    if jsn.has('fixedId') or jsn.has('_fixedId') then
        result.fixed := ParseId(jsn['fixedId'], jsn.vObj['_fixedId']);
    if jsn.has('fixedBase64Binary') or jsn.has('_fixedBase64Binary') then
        result.fixed := ParseBase64Binary(jsn['fixedBase64Binary'], jsn.vObj['_fixedBase64Binary']);
    if jsn.has('fixedTime') or jsn.has('_fixedTime') then
        result.fixed := ParseTime(jsn['fixedTime'], jsn.vObj['_fixedTime']);
    if jsn.has('fixedOid') or jsn.has('_fixedOid') then
        result.fixed := ParseOid(jsn['fixedOid'], jsn.vObj['_fixedOid']);
    if jsn.has('fixedPositiveInt') or jsn.has('_fixedPositiveInt') then
        result.fixed := ParsePositiveInt(jsn['fixedPositiveInt'], jsn.vObj['_fixedPositiveInt']);
    if jsn.has('fixedString') or jsn.has('_fixedString') then
        result.fixed := ParseString(jsn['fixedString'], jsn.vObj['_fixedString']);
    if jsn.has('fixedBoolean') or jsn.has('_fixedBoolean') then
        result.fixed := ParseBoolean(jsn['fixedBoolean'], jsn.vObj['_fixedBoolean']);
    if jsn.has('fixedUuid') or jsn.has('_fixedUuid') then
        result.fixed := ParseUuid(jsn['fixedUuid'], jsn.vObj['_fixedUuid']);
    if jsn.has('fixedInstant') or jsn.has('_fixedInstant') then
        result.fixed := ParseInstant(jsn['fixedInstant'], jsn.vObj['_fixedInstant']);
    if jsn.has('fixedPeriod') {a7} then
        result.fixed := ParsePeriod(jsn.vObj['fixedPeriod']);
    if jsn.has('fixedCoding') {a7} then
        result.fixed := ParseCoding(jsn.vObj['fixedCoding']);
    if jsn.has('fixedRange') {a7} then
        result.fixed := ParseRange(jsn.vObj['fixedRange']);
    if jsn.has('fixedQuantity') {a7} then
        result.fixed := ParseQuantity(jsn.vObj['fixedQuantity']);
    if jsn.has('fixedAttachment') {a7} then
        result.fixed := ParseAttachment(jsn.vObj['fixedAttachment']);
    if jsn.has('fixedRatio') {a7} then
        result.fixed := ParseRatio(jsn.vObj['fixedRatio']);
    if jsn.has('fixedSampledData') {a7} then
        result.fixed := ParseSampledData(jsn.vObj['fixedSampledData']);
    if jsn.has('fixedReference') {a7} then
        result.fixed := ParseReference(jsn.vObj['fixedReference']);
    if jsn.has('fixedCodeableConcept') {a7} then
        result.fixed := ParseCodeableConcept(jsn.vObj['fixedCodeableConcept']);
    if jsn.has('fixedIdentifier') {a7} then
        result.fixed := ParseIdentifier(jsn.vObj['fixedIdentifier']);
    if jsn.has('fixedSignature') {a7} then
        result.fixed := ParseSignature(jsn.vObj['fixedSignature']);
    if jsn.has('fixedElementDefinition') {a9} then
        result.fixed := ParseElementDefinition(jsn.vObj['fixedElementDefinition']);
    if jsn.has('fixedTiming') {a9} then
        result.fixed := ParseTiming(jsn.vObj['fixedTiming']);
    if jsn.has('fixedAddress') {a9} then
        result.fixed := ParseAddress(jsn.vObj['fixedAddress']);
    if jsn.has('fixedHumanName') {a9} then
        result.fixed := ParseHumanName(jsn.vObj['fixedHumanName']);
    if jsn.has('fixedMeta') {a9} then
        result.fixed := ParseMeta(jsn.vObj['fixedMeta']);
    if jsn.has('fixedContactPoint') {a9} then
        result.fixed := ParseContactPoint(jsn.vObj['fixedContactPoint']);
    if jsn.has('patternInteger') or jsn.has('_patternInteger') then
        result.pattern := ParseInteger(jsn['patternInteger'], jsn.vObj['_patternInteger']);
    if jsn.has('patternDateTime') or jsn.has('_patternDateTime') then
        result.pattern := ParseDateTime(jsn['patternDateTime'], jsn.vObj['_patternDateTime']);
    if jsn.has('patternUnsignedInt') or jsn.has('_patternUnsignedInt') then
        result.pattern := ParseUnsignedInt(jsn['patternUnsignedInt'], jsn.vObj['_patternUnsignedInt']);
    if jsn.has('patternCode') or jsn.has('_patternCode') then
        result.pattern := ParseCode(jsn['patternCode'], jsn.vObj['_patternCode']);
    if jsn.has('patternDate') or jsn.has('_patternDate') then
        result.pattern := ParseDate(jsn['patternDate'], jsn.vObj['_patternDate']);
    if jsn.has('patternDecimal') or jsn.has('_patternDecimal') then
        result.pattern := ParseDecimal(jsn['patternDecimal'], jsn.vObj['_patternDecimal']);
    if jsn.has('patternUri') or jsn.has('_patternUri') then
        result.pattern := ParseUri(jsn['patternUri'], jsn.vObj['_patternUri']);
    if jsn.has('patternId') or jsn.has('_patternId') then
        result.pattern := ParseId(jsn['patternId'], jsn.vObj['_patternId']);
    if jsn.has('patternBase64Binary') or jsn.has('_patternBase64Binary') then
        result.pattern := ParseBase64Binary(jsn['patternBase64Binary'], jsn.vObj['_patternBase64Binary']);
    if jsn.has('patternTime') or jsn.has('_patternTime') then
        result.pattern := ParseTime(jsn['patternTime'], jsn.vObj['_patternTime']);
    if jsn.has('patternOid') or jsn.has('_patternOid') then
        result.pattern := ParseOid(jsn['patternOid'], jsn.vObj['_patternOid']);
    if jsn.has('patternPositiveInt') or jsn.has('_patternPositiveInt') then
        result.pattern := ParsePositiveInt(jsn['patternPositiveInt'], jsn.vObj['_patternPositiveInt']);
    if jsn.has('patternString') or jsn.has('_patternString') then
        result.pattern := ParseString(jsn['patternString'], jsn.vObj['_patternString']);
    if jsn.has('patternBoolean') or jsn.has('_patternBoolean') then
        result.pattern := ParseBoolean(jsn['patternBoolean'], jsn.vObj['_patternBoolean']);
    if jsn.has('patternUuid') or jsn.has('_patternUuid') then
        result.pattern := ParseUuid(jsn['patternUuid'], jsn.vObj['_patternUuid']);
    if jsn.has('patternInstant') or jsn.has('_patternInstant') then
        result.pattern := ParseInstant(jsn['patternInstant'], jsn.vObj['_patternInstant']);
    if jsn.has('patternPeriod') {a7} then
        result.pattern := ParsePeriod(jsn.vObj['patternPeriod']);
    if jsn.has('patternCoding') {a7} then
        result.pattern := ParseCoding(jsn.vObj['patternCoding']);
    if jsn.has('patternRange') {a7} then
        result.pattern := ParseRange(jsn.vObj['patternRange']);
    if jsn.has('patternQuantity') {a7} then
        result.pattern := ParseQuantity(jsn.vObj['patternQuantity']);
    if jsn.has('patternAttachment') {a7} then
        result.pattern := ParseAttachment(jsn.vObj['patternAttachment']);
    if jsn.has('patternRatio') {a7} then
        result.pattern := ParseRatio(jsn.vObj['patternRatio']);
    if jsn.has('patternSampledData') {a7} then
        result.pattern := ParseSampledData(jsn.vObj['patternSampledData']);
    if jsn.has('patternReference') {a7} then
        result.pattern := ParseReference(jsn.vObj['patternReference']);
    if jsn.has('patternCodeableConcept') {a7} then
        result.pattern := ParseCodeableConcept(jsn.vObj['patternCodeableConcept']);
    if jsn.has('patternIdentifier') {a7} then
        result.pattern := ParseIdentifier(jsn.vObj['patternIdentifier']);
    if jsn.has('patternSignature') {a7} then
        result.pattern := ParseSignature(jsn.vObj['patternSignature']);
    if jsn.has('patternElementDefinition') {a9} then
        result.pattern := ParseElementDefinition(jsn.vObj['patternElementDefinition']);
    if jsn.has('patternTiming') {a9} then
        result.pattern := ParseTiming(jsn.vObj['patternTiming']);
    if jsn.has('patternAddress') {a9} then
        result.pattern := ParseAddress(jsn.vObj['patternAddress']);
    if jsn.has('patternHumanName') {a9} then
        result.pattern := ParseHumanName(jsn.vObj['patternHumanName']);
    if jsn.has('patternMeta') {a9} then
        result.pattern := ParseMeta(jsn.vObj['patternMeta']);
    if jsn.has('patternContactPoint') {a9} then
        result.pattern := ParseContactPoint(jsn.vObj['patternContactPoint']);
    if jsn.has('exampleInteger') or jsn.has('_exampleInteger') then
        result.example := ParseInteger(jsn['exampleInteger'], jsn.vObj['_exampleInteger']);
    if jsn.has('exampleDateTime') or jsn.has('_exampleDateTime') then
        result.example := ParseDateTime(jsn['exampleDateTime'], jsn.vObj['_exampleDateTime']);
    if jsn.has('exampleUnsignedInt') or jsn.has('_exampleUnsignedInt') then
        result.example := ParseUnsignedInt(jsn['exampleUnsignedInt'], jsn.vObj['_exampleUnsignedInt']);
    if jsn.has('exampleCode') or jsn.has('_exampleCode') then
        result.example := ParseCode(jsn['exampleCode'], jsn.vObj['_exampleCode']);
    if jsn.has('exampleDate') or jsn.has('_exampleDate') then
        result.example := ParseDate(jsn['exampleDate'], jsn.vObj['_exampleDate']);
    if jsn.has('exampleDecimal') or jsn.has('_exampleDecimal') then
        result.example := ParseDecimal(jsn['exampleDecimal'], jsn.vObj['_exampleDecimal']);
    if jsn.has('exampleUri') or jsn.has('_exampleUri') then
        result.example := ParseUri(jsn['exampleUri'], jsn.vObj['_exampleUri']);
    if jsn.has('exampleId') or jsn.has('_exampleId') then
        result.example := ParseId(jsn['exampleId'], jsn.vObj['_exampleId']);
    if jsn.has('exampleBase64Binary') or jsn.has('_exampleBase64Binary') then
        result.example := ParseBase64Binary(jsn['exampleBase64Binary'], jsn.vObj['_exampleBase64Binary']);
    if jsn.has('exampleTime') or jsn.has('_exampleTime') then
        result.example := ParseTime(jsn['exampleTime'], jsn.vObj['_exampleTime']);
    if jsn.has('exampleOid') or jsn.has('_exampleOid') then
        result.example := ParseOid(jsn['exampleOid'], jsn.vObj['_exampleOid']);
    if jsn.has('examplePositiveInt') or jsn.has('_examplePositiveInt') then
        result.example := ParsePositiveInt(jsn['examplePositiveInt'], jsn.vObj['_examplePositiveInt']);
    if jsn.has('exampleString') or jsn.has('_exampleString') then
        result.example := ParseString(jsn['exampleString'], jsn.vObj['_exampleString']);
    if jsn.has('exampleBoolean') or jsn.has('_exampleBoolean') then
        result.example := ParseBoolean(jsn['exampleBoolean'], jsn.vObj['_exampleBoolean']);
    if jsn.has('exampleUuid') or jsn.has('_exampleUuid') then
        result.example := ParseUuid(jsn['exampleUuid'], jsn.vObj['_exampleUuid']);
    if jsn.has('exampleInstant') or jsn.has('_exampleInstant') then
        result.example := ParseInstant(jsn['exampleInstant'], jsn.vObj['_exampleInstant']);
    if jsn.has('examplePeriod') {a7} then
        result.example := ParsePeriod(jsn.vObj['examplePeriod']);
    if jsn.has('exampleCoding') {a7} then
        result.example := ParseCoding(jsn.vObj['exampleCoding']);
    if jsn.has('exampleRange') {a7} then
        result.example := ParseRange(jsn.vObj['exampleRange']);
    if jsn.has('exampleQuantity') {a7} then
        result.example := ParseQuantity(jsn.vObj['exampleQuantity']);
    if jsn.has('exampleAttachment') {a7} then
        result.example := ParseAttachment(jsn.vObj['exampleAttachment']);
    if jsn.has('exampleRatio') {a7} then
        result.example := ParseRatio(jsn.vObj['exampleRatio']);
    if jsn.has('exampleSampledData') {a7} then
        result.example := ParseSampledData(jsn.vObj['exampleSampledData']);
    if jsn.has('exampleReference') {a7} then
        result.example := ParseReference(jsn.vObj['exampleReference']);
    if jsn.has('exampleCodeableConcept') {a7} then
        result.example := ParseCodeableConcept(jsn.vObj['exampleCodeableConcept']);
    if jsn.has('exampleIdentifier') {a7} then
        result.example := ParseIdentifier(jsn.vObj['exampleIdentifier']);
    if jsn.has('exampleSignature') {a7} then
        result.example := ParseSignature(jsn.vObj['exampleSignature']);
    if jsn.has('exampleElementDefinition') {a9} then
        result.example := ParseElementDefinition(jsn.vObj['exampleElementDefinition']);
    if jsn.has('exampleTiming') {a9} then
        result.example := ParseTiming(jsn.vObj['exampleTiming']);
    if jsn.has('exampleAddress') {a9} then
        result.example := ParseAddress(jsn.vObj['exampleAddress']);
    if jsn.has('exampleHumanName') {a9} then
        result.example := ParseHumanName(jsn.vObj['exampleHumanName']);
    if jsn.has('exampleMeta') {a9} then
        result.example := ParseMeta(jsn.vObj['exampleMeta']);
    if jsn.has('exampleContactPoint') {a9} then
        result.example := ParseContactPoint(jsn.vObj['exampleContactPoint']);
    if jsn.has('maxLength') or jsn.has('_maxLength') then
        result.maxLengthElement := ParseInteger(jsn['maxLength'], jsn.vObj['_maxLength']);{q}
      if jsn.has('condition') or jsn.has('_condition') then
      iteratePrimitiveArray(jsn.vArr['condition'], jsn.vArr['_condition'], result.conditionList, parseId);
    if jsn.has('constraint') then
      iterateArray(jsn.vArr['constraint'], result.constraintList, parseElementDefinitionConstraint);
    if jsn.has('mustSupport') or jsn.has('_mustSupport') then
        result.mustSupportElement := ParseBoolean(jsn['mustSupport'], jsn.vObj['_mustSupport']);{q}
    if jsn.has('isModifier') or jsn.has('_isModifier') then
        result.isModifierElement := ParseBoolean(jsn['isModifier'], jsn.vObj['_isModifier']);{q}
    if jsn.has('isSummary') or jsn.has('_isSummary') then
        result.isSummaryElement := ParseBoolean(jsn['isSummary'], jsn.vObj['_isSummary']);{q}
    if jsn.has('binding') then
        result.binding := ParseElementDefinitionBinding(jsn.vObj['binding']);{q}
    if jsn.has('mapping') then
      iterateArray(jsn.vArr['mapping'], result.mappingList, parseElementDefinitionMapping);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeElementDefinition(json : TJSONWriter; name : string; elem : TFhirElementDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeStringValue(json, 'path', elem.pathElement, false);
  ComposeStringProps(json, 'path', elem.pathElement, false);
  if elem.representationElement.Count > 0 then
  begin
    json.valueArray('representation');
    ext := false;
    for i := 0 to elem.representationElement.Count - 1 do
    begin
      ext := ext or ((elem.representationElement[i].id <> '') or (elem.representationElement[i].hasExtensionList));
      ComposeEnumValue(json, '', elem.representationElement[i], CODES_TFhirPropertyRepresentation, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_representation');
      for i := 0 to elem.representationElement.Count - 1 do
        ComposeEnumProps(json, '', elem.representationElement[i], CODES_TFhirPropertyRepresentation, true);
      json.FinishArray;
    end;
  end;
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeStringValue(json, 'label', elem.label_Element, false);
  ComposeStringProps(json, 'label', elem.label_Element, false);
  if elem.codeList.Count > 0 then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(json, '',elem.codeList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeElementDefinitionSlicing(json, 'slicing', elem.slicing); {a}
  ComposeStringValue(json, 'short', elem.shortElement, false);
  ComposeStringProps(json, 'short', elem.shortElement, false);
  ComposeStringValue(json, 'definition', elem.definitionElement, false);
  ComposeStringProps(json, 'definition', elem.definitionElement, false);
  ComposeStringValue(json, 'comments', elem.commentsElement, false);
  ComposeStringProps(json, 'comments', elem.commentsElement, false);
  ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  if elem.aliasList.Count > 0 then
  begin
    json.valueArray('alias');
    ext := false;
    for i := 0 to elem.aliasList.Count - 1 do
    begin
      ext := ext or ((elem.aliasList[i].id <> '') or (elem.aliasList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.aliasList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_alias');
      for i := 0 to elem.aliasList.Count - 1 do
        ComposeStringProps(json, '',elem.aliasList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeIntegerValue(json, 'min', elem.minElement, false);
  ComposeIntegerProps(json, 'min', elem.minElement, false);
  ComposeStringValue(json, 'max', elem.maxElement, false);
  ComposeStringProps(json, 'max', elem.maxElement, false);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeElementDefinitionType(json, '',elem.type_List[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'nameReference', elem.nameReferenceElement, false);
  ComposeStringProps(json, 'nameReference', elem.nameReferenceElement, false);
  if (elem.defaultValue is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'defaultValueInteger', TFhirInteger(elem.defaultValue), false);
    ComposeIntegerProps(json, 'defaultValueInteger', TFhirInteger(elem.defaultValue), false)
  end
  else if (elem.defaultValue is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'defaultValueDateTime', TFhirDateTime(elem.defaultValue), false);
    ComposeDateTimeProps(json, 'defaultValueDateTime', TFhirDateTime(elem.defaultValue), false)
  end
  else if (elem.defaultValue is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue), false);
    ComposeUnsignedIntProps(json, 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue), false)
  end
  else if (elem.defaultValue is TFhirCode) then
  begin
    ComposeCodeValue(json, 'defaultValueCode', TFhirCode(elem.defaultValue), false);
    ComposeCodeProps(json, 'defaultValueCode', TFhirCode(elem.defaultValue), false)
  end
  else if (elem.defaultValue is TFhirDate) then
  begin
    ComposeDateValue(json, 'defaultValueDate', TFhirDate(elem.defaultValue), false);
    ComposeDateProps(json, 'defaultValueDate', TFhirDate(elem.defaultValue), false)
  end
  else if (elem.defaultValue is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'defaultValueDecimal', TFhirDecimal(elem.defaultValue), false);
    ComposeDecimalProps(json, 'defaultValueDecimal', TFhirDecimal(elem.defaultValue), false)
  end
  else if (elem.defaultValue is TFhirUri) then
  begin
    ComposeUriValue(json, 'defaultValueUri', TFhirUri(elem.defaultValue), false);
    ComposeUriProps(json, 'defaultValueUri', TFhirUri(elem.defaultValue), false)
  end
  else if (elem.defaultValue is TFhirId) then
  begin
    ComposeIdValue(json, 'defaultValueId', TFhirId(elem.defaultValue), false);
    ComposeIdProps(json, 'defaultValueId', TFhirId(elem.defaultValue), false)
  end
  else if (elem.defaultValue is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue), false);
    ComposeBase64BinaryProps(json, 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue), false)
  end
  else if (elem.defaultValue is TFhirTime) then
  begin
    ComposeTimeValue(json, 'defaultValueTime', TFhirTime(elem.defaultValue), false);
    ComposeTimeProps(json, 'defaultValueTime', TFhirTime(elem.defaultValue), false)
  end
  else if (elem.defaultValue is TFhirOid) then
  begin
    ComposeOidValue(json, 'defaultValueOid', TFhirOid(elem.defaultValue), false);
    ComposeOidProps(json, 'defaultValueOid', TFhirOid(elem.defaultValue), false)
  end
  else if (elem.defaultValue is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue), false);
    ComposePositiveIntProps(json, 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue), false)
  end
  else if (elem.defaultValue is TFhirString) then
  begin
    ComposeStringValue(json, 'defaultValueString', TFhirString(elem.defaultValue), false);
    ComposeStringProps(json, 'defaultValueString', TFhirString(elem.defaultValue), false)
  end
  else if (elem.defaultValue is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'defaultValueBoolean', TFhirBoolean(elem.defaultValue), false);
    ComposeBooleanProps(json, 'defaultValueBoolean', TFhirBoolean(elem.defaultValue), false)
  end
  else if (elem.defaultValue is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'defaultValueUuid', TFhirUuid(elem.defaultValue), false);
    ComposeUuidProps(json, 'defaultValueUuid', TFhirUuid(elem.defaultValue), false)
  end
  else if (elem.defaultValue is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'defaultValueInstant', TFhirInstant(elem.defaultValue), false);
    ComposeInstantProps(json, 'defaultValueInstant', TFhirInstant(elem.defaultValue), false)
  end
  else if (elem.defaultValue is TFhirPeriod) then
    ComposePeriod(json, 'defaultValuePeriod', TFhirPeriod(elem.defaultValue))
  else if (elem.defaultValue is TFhirCoding) then
    ComposeCoding(json, 'defaultValueCoding', TFhirCoding(elem.defaultValue))
  else if (elem.defaultValue is TFhirRange) then
    ComposeRange(json, 'defaultValueRange', TFhirRange(elem.defaultValue))
  else if (elem.defaultValue is TFhirQuantity) then
    ComposeQuantity(json, 'defaultValueQuantity', TFhirQuantity(elem.defaultValue))
  else if (elem.defaultValue is TFhirAttachment) then
    ComposeAttachment(json, 'defaultValueAttachment', TFhirAttachment(elem.defaultValue))
  else if (elem.defaultValue is TFhirRatio) then
    ComposeRatio(json, 'defaultValueRatio', TFhirRatio(elem.defaultValue))
  else if (elem.defaultValue is TFhirSampledData) then
    ComposeSampledData(json, 'defaultValueSampledData', TFhirSampledData(elem.defaultValue))
  else if (elem.defaultValue is TFhirReference) then
    ComposeReference(json, 'defaultValueReference', TFhirReference(elem.defaultValue))
  else if (elem.defaultValue is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'defaultValueCodeableConcept', TFhirCodeableConcept(elem.defaultValue))
  else if (elem.defaultValue is TFhirIdentifier) then
    ComposeIdentifier(json, 'defaultValueIdentifier', TFhirIdentifier(elem.defaultValue))
  else if (elem.defaultValue is TFhirSignature) then
    ComposeSignature(json, 'defaultValueSignature', TFhirSignature(elem.defaultValue))
  else if (elem.defaultValue is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'defaultValueElementDefinition', TFhirElementDefinition(elem.defaultValue))
  else if (elem.defaultValue is TFhirTiming) then
    ComposeTiming(json, 'defaultValueTiming', TFhirTiming(elem.defaultValue))
  else if (elem.defaultValue is TFhirAddress) then
    ComposeAddress(json, 'defaultValueAddress', TFhirAddress(elem.defaultValue))
  else if (elem.defaultValue is TFhirHumanName) then
    ComposeHumanName(json, 'defaultValueHumanName', TFhirHumanName(elem.defaultValue))
  else if (elem.defaultValue is TFhirMeta) then
    ComposeMeta(json, 'defaultValueMeta', TFhirMeta(elem.defaultValue))
  else if (elem.defaultValue is TFhirContactPoint) then
    ComposeContactPoint(json, 'defaultValueContactPoint', TFhirContactPoint(elem.defaultValue));
  ComposeStringValue(json, 'meaningWhenMissing', elem.meaningWhenMissingElement, false);
  ComposeStringProps(json, 'meaningWhenMissing', elem.meaningWhenMissingElement, false);
  if (elem.fixed is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'fixedInteger', TFhirInteger(elem.fixed), false);
    ComposeIntegerProps(json, 'fixedInteger', TFhirInteger(elem.fixed), false)
  end
  else if (elem.fixed is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'fixedDateTime', TFhirDateTime(elem.fixed), false);
    ComposeDateTimeProps(json, 'fixedDateTime', TFhirDateTime(elem.fixed), false)
  end
  else if (elem.fixed is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'fixedUnsignedInt', TFhirUnsignedInt(elem.fixed), false);
    ComposeUnsignedIntProps(json, 'fixedUnsignedInt', TFhirUnsignedInt(elem.fixed), false)
  end
  else if (elem.fixed is TFhirCode) then
  begin
    ComposeCodeValue(json, 'fixedCode', TFhirCode(elem.fixed), false);
    ComposeCodeProps(json, 'fixedCode', TFhirCode(elem.fixed), false)
  end
  else if (elem.fixed is TFhirDate) then
  begin
    ComposeDateValue(json, 'fixedDate', TFhirDate(elem.fixed), false);
    ComposeDateProps(json, 'fixedDate', TFhirDate(elem.fixed), false)
  end
  else if (elem.fixed is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'fixedDecimal', TFhirDecimal(elem.fixed), false);
    ComposeDecimalProps(json, 'fixedDecimal', TFhirDecimal(elem.fixed), false)
  end
  else if (elem.fixed is TFhirUri) then
  begin
    ComposeUriValue(json, 'fixedUri', TFhirUri(elem.fixed), false);
    ComposeUriProps(json, 'fixedUri', TFhirUri(elem.fixed), false)
  end
  else if (elem.fixed is TFhirId) then
  begin
    ComposeIdValue(json, 'fixedId', TFhirId(elem.fixed), false);
    ComposeIdProps(json, 'fixedId', TFhirId(elem.fixed), false)
  end
  else if (elem.fixed is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'fixedBase64Binary', TFhirBase64Binary(elem.fixed), false);
    ComposeBase64BinaryProps(json, 'fixedBase64Binary', TFhirBase64Binary(elem.fixed), false)
  end
  else if (elem.fixed is TFhirTime) then
  begin
    ComposeTimeValue(json, 'fixedTime', TFhirTime(elem.fixed), false);
    ComposeTimeProps(json, 'fixedTime', TFhirTime(elem.fixed), false)
  end
  else if (elem.fixed is TFhirOid) then
  begin
    ComposeOidValue(json, 'fixedOid', TFhirOid(elem.fixed), false);
    ComposeOidProps(json, 'fixedOid', TFhirOid(elem.fixed), false)
  end
  else if (elem.fixed is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'fixedPositiveInt', TFhirPositiveInt(elem.fixed), false);
    ComposePositiveIntProps(json, 'fixedPositiveInt', TFhirPositiveInt(elem.fixed), false)
  end
  else if (elem.fixed is TFhirString) then
  begin
    ComposeStringValue(json, 'fixedString', TFhirString(elem.fixed), false);
    ComposeStringProps(json, 'fixedString', TFhirString(elem.fixed), false)
  end
  else if (elem.fixed is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'fixedBoolean', TFhirBoolean(elem.fixed), false);
    ComposeBooleanProps(json, 'fixedBoolean', TFhirBoolean(elem.fixed), false)
  end
  else if (elem.fixed is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'fixedUuid', TFhirUuid(elem.fixed), false);
    ComposeUuidProps(json, 'fixedUuid', TFhirUuid(elem.fixed), false)
  end
  else if (elem.fixed is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'fixedInstant', TFhirInstant(elem.fixed), false);
    ComposeInstantProps(json, 'fixedInstant', TFhirInstant(elem.fixed), false)
  end
  else if (elem.fixed is TFhirPeriod) then
    ComposePeriod(json, 'fixedPeriod', TFhirPeriod(elem.fixed))
  else if (elem.fixed is TFhirCoding) then
    ComposeCoding(json, 'fixedCoding', TFhirCoding(elem.fixed))
  else if (elem.fixed is TFhirRange) then
    ComposeRange(json, 'fixedRange', TFhirRange(elem.fixed))
  else if (elem.fixed is TFhirQuantity) then
    ComposeQuantity(json, 'fixedQuantity', TFhirQuantity(elem.fixed))
  else if (elem.fixed is TFhirAttachment) then
    ComposeAttachment(json, 'fixedAttachment', TFhirAttachment(elem.fixed))
  else if (elem.fixed is TFhirRatio) then
    ComposeRatio(json, 'fixedRatio', TFhirRatio(elem.fixed))
  else if (elem.fixed is TFhirSampledData) then
    ComposeSampledData(json, 'fixedSampledData', TFhirSampledData(elem.fixed))
  else if (elem.fixed is TFhirReference) then
    ComposeReference(json, 'fixedReference', TFhirReference(elem.fixed))
  else if (elem.fixed is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'fixedCodeableConcept', TFhirCodeableConcept(elem.fixed))
  else if (elem.fixed is TFhirIdentifier) then
    ComposeIdentifier(json, 'fixedIdentifier', TFhirIdentifier(elem.fixed))
  else if (elem.fixed is TFhirSignature) then
    ComposeSignature(json, 'fixedSignature', TFhirSignature(elem.fixed))
  else if (elem.fixed is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'fixedElementDefinition', TFhirElementDefinition(elem.fixed))
  else if (elem.fixed is TFhirTiming) then
    ComposeTiming(json, 'fixedTiming', TFhirTiming(elem.fixed))
  else if (elem.fixed is TFhirAddress) then
    ComposeAddress(json, 'fixedAddress', TFhirAddress(elem.fixed))
  else if (elem.fixed is TFhirHumanName) then
    ComposeHumanName(json, 'fixedHumanName', TFhirHumanName(elem.fixed))
  else if (elem.fixed is TFhirMeta) then
    ComposeMeta(json, 'fixedMeta', TFhirMeta(elem.fixed))
  else if (elem.fixed is TFhirContactPoint) then
    ComposeContactPoint(json, 'fixedContactPoint', TFhirContactPoint(elem.fixed));
  if (elem.pattern is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'patternInteger', TFhirInteger(elem.pattern), false);
    ComposeIntegerProps(json, 'patternInteger', TFhirInteger(elem.pattern), false)
  end
  else if (elem.pattern is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'patternDateTime', TFhirDateTime(elem.pattern), false);
    ComposeDateTimeProps(json, 'patternDateTime', TFhirDateTime(elem.pattern), false)
  end
  else if (elem.pattern is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'patternUnsignedInt', TFhirUnsignedInt(elem.pattern), false);
    ComposeUnsignedIntProps(json, 'patternUnsignedInt', TFhirUnsignedInt(elem.pattern), false)
  end
  else if (elem.pattern is TFhirCode) then
  begin
    ComposeCodeValue(json, 'patternCode', TFhirCode(elem.pattern), false);
    ComposeCodeProps(json, 'patternCode', TFhirCode(elem.pattern), false)
  end
  else if (elem.pattern is TFhirDate) then
  begin
    ComposeDateValue(json, 'patternDate', TFhirDate(elem.pattern), false);
    ComposeDateProps(json, 'patternDate', TFhirDate(elem.pattern), false)
  end
  else if (elem.pattern is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'patternDecimal', TFhirDecimal(elem.pattern), false);
    ComposeDecimalProps(json, 'patternDecimal', TFhirDecimal(elem.pattern), false)
  end
  else if (elem.pattern is TFhirUri) then
  begin
    ComposeUriValue(json, 'patternUri', TFhirUri(elem.pattern), false);
    ComposeUriProps(json, 'patternUri', TFhirUri(elem.pattern), false)
  end
  else if (elem.pattern is TFhirId) then
  begin
    ComposeIdValue(json, 'patternId', TFhirId(elem.pattern), false);
    ComposeIdProps(json, 'patternId', TFhirId(elem.pattern), false)
  end
  else if (elem.pattern is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'patternBase64Binary', TFhirBase64Binary(elem.pattern), false);
    ComposeBase64BinaryProps(json, 'patternBase64Binary', TFhirBase64Binary(elem.pattern), false)
  end
  else if (elem.pattern is TFhirTime) then
  begin
    ComposeTimeValue(json, 'patternTime', TFhirTime(elem.pattern), false);
    ComposeTimeProps(json, 'patternTime', TFhirTime(elem.pattern), false)
  end
  else if (elem.pattern is TFhirOid) then
  begin
    ComposeOidValue(json, 'patternOid', TFhirOid(elem.pattern), false);
    ComposeOidProps(json, 'patternOid', TFhirOid(elem.pattern), false)
  end
  else if (elem.pattern is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'patternPositiveInt', TFhirPositiveInt(elem.pattern), false);
    ComposePositiveIntProps(json, 'patternPositiveInt', TFhirPositiveInt(elem.pattern), false)
  end
  else if (elem.pattern is TFhirString) then
  begin
    ComposeStringValue(json, 'patternString', TFhirString(elem.pattern), false);
    ComposeStringProps(json, 'patternString', TFhirString(elem.pattern), false)
  end
  else if (elem.pattern is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'patternBoolean', TFhirBoolean(elem.pattern), false);
    ComposeBooleanProps(json, 'patternBoolean', TFhirBoolean(elem.pattern), false)
  end
  else if (elem.pattern is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'patternUuid', TFhirUuid(elem.pattern), false);
    ComposeUuidProps(json, 'patternUuid', TFhirUuid(elem.pattern), false)
  end
  else if (elem.pattern is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'patternInstant', TFhirInstant(elem.pattern), false);
    ComposeInstantProps(json, 'patternInstant', TFhirInstant(elem.pattern), false)
  end
  else if (elem.pattern is TFhirPeriod) then
    ComposePeriod(json, 'patternPeriod', TFhirPeriod(elem.pattern))
  else if (elem.pattern is TFhirCoding) then
    ComposeCoding(json, 'patternCoding', TFhirCoding(elem.pattern))
  else if (elem.pattern is TFhirRange) then
    ComposeRange(json, 'patternRange', TFhirRange(elem.pattern))
  else if (elem.pattern is TFhirQuantity) then
    ComposeQuantity(json, 'patternQuantity', TFhirQuantity(elem.pattern))
  else if (elem.pattern is TFhirAttachment) then
    ComposeAttachment(json, 'patternAttachment', TFhirAttachment(elem.pattern))
  else if (elem.pattern is TFhirRatio) then
    ComposeRatio(json, 'patternRatio', TFhirRatio(elem.pattern))
  else if (elem.pattern is TFhirSampledData) then
    ComposeSampledData(json, 'patternSampledData', TFhirSampledData(elem.pattern))
  else if (elem.pattern is TFhirReference) then
    ComposeReference(json, 'patternReference', TFhirReference(elem.pattern))
  else if (elem.pattern is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'patternCodeableConcept', TFhirCodeableConcept(elem.pattern))
  else if (elem.pattern is TFhirIdentifier) then
    ComposeIdentifier(json, 'patternIdentifier', TFhirIdentifier(elem.pattern))
  else if (elem.pattern is TFhirSignature) then
    ComposeSignature(json, 'patternSignature', TFhirSignature(elem.pattern))
  else if (elem.pattern is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'patternElementDefinition', TFhirElementDefinition(elem.pattern))
  else if (elem.pattern is TFhirTiming) then
    ComposeTiming(json, 'patternTiming', TFhirTiming(elem.pattern))
  else if (elem.pattern is TFhirAddress) then
    ComposeAddress(json, 'patternAddress', TFhirAddress(elem.pattern))
  else if (elem.pattern is TFhirHumanName) then
    ComposeHumanName(json, 'patternHumanName', TFhirHumanName(elem.pattern))
  else if (elem.pattern is TFhirMeta) then
    ComposeMeta(json, 'patternMeta', TFhirMeta(elem.pattern))
  else if (elem.pattern is TFhirContactPoint) then
    ComposeContactPoint(json, 'patternContactPoint', TFhirContactPoint(elem.pattern));
  if (elem.example is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'exampleInteger', TFhirInteger(elem.example), false);
    ComposeIntegerProps(json, 'exampleInteger', TFhirInteger(elem.example), false)
  end
  else if (elem.example is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'exampleDateTime', TFhirDateTime(elem.example), false);
    ComposeDateTimeProps(json, 'exampleDateTime', TFhirDateTime(elem.example), false)
  end
  else if (elem.example is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'exampleUnsignedInt', TFhirUnsignedInt(elem.example), false);
    ComposeUnsignedIntProps(json, 'exampleUnsignedInt', TFhirUnsignedInt(elem.example), false)
  end
  else if (elem.example is TFhirCode) then
  begin
    ComposeCodeValue(json, 'exampleCode', TFhirCode(elem.example), false);
    ComposeCodeProps(json, 'exampleCode', TFhirCode(elem.example), false)
  end
  else if (elem.example is TFhirDate) then
  begin
    ComposeDateValue(json, 'exampleDate', TFhirDate(elem.example), false);
    ComposeDateProps(json, 'exampleDate', TFhirDate(elem.example), false)
  end
  else if (elem.example is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'exampleDecimal', TFhirDecimal(elem.example), false);
    ComposeDecimalProps(json, 'exampleDecimal', TFhirDecimal(elem.example), false)
  end
  else if (elem.example is TFhirUri) then
  begin
    ComposeUriValue(json, 'exampleUri', TFhirUri(elem.example), false);
    ComposeUriProps(json, 'exampleUri', TFhirUri(elem.example), false)
  end
  else if (elem.example is TFhirId) then
  begin
    ComposeIdValue(json, 'exampleId', TFhirId(elem.example), false);
    ComposeIdProps(json, 'exampleId', TFhirId(elem.example), false)
  end
  else if (elem.example is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'exampleBase64Binary', TFhirBase64Binary(elem.example), false);
    ComposeBase64BinaryProps(json, 'exampleBase64Binary', TFhirBase64Binary(elem.example), false)
  end
  else if (elem.example is TFhirTime) then
  begin
    ComposeTimeValue(json, 'exampleTime', TFhirTime(elem.example), false);
    ComposeTimeProps(json, 'exampleTime', TFhirTime(elem.example), false)
  end
  else if (elem.example is TFhirOid) then
  begin
    ComposeOidValue(json, 'exampleOid', TFhirOid(elem.example), false);
    ComposeOidProps(json, 'exampleOid', TFhirOid(elem.example), false)
  end
  else if (elem.example is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'examplePositiveInt', TFhirPositiveInt(elem.example), false);
    ComposePositiveIntProps(json, 'examplePositiveInt', TFhirPositiveInt(elem.example), false)
  end
  else if (elem.example is TFhirString) then
  begin
    ComposeStringValue(json, 'exampleString', TFhirString(elem.example), false);
    ComposeStringProps(json, 'exampleString', TFhirString(elem.example), false)
  end
  else if (elem.example is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'exampleBoolean', TFhirBoolean(elem.example), false);
    ComposeBooleanProps(json, 'exampleBoolean', TFhirBoolean(elem.example), false)
  end
  else if (elem.example is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'exampleUuid', TFhirUuid(elem.example), false);
    ComposeUuidProps(json, 'exampleUuid', TFhirUuid(elem.example), false)
  end
  else if (elem.example is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'exampleInstant', TFhirInstant(elem.example), false);
    ComposeInstantProps(json, 'exampleInstant', TFhirInstant(elem.example), false)
  end
  else if (elem.example is TFhirPeriod) then
    ComposePeriod(json, 'examplePeriod', TFhirPeriod(elem.example))
  else if (elem.example is TFhirCoding) then
    ComposeCoding(json, 'exampleCoding', TFhirCoding(elem.example))
  else if (elem.example is TFhirRange) then
    ComposeRange(json, 'exampleRange', TFhirRange(elem.example))
  else if (elem.example is TFhirQuantity) then
    ComposeQuantity(json, 'exampleQuantity', TFhirQuantity(elem.example))
  else if (elem.example is TFhirAttachment) then
    ComposeAttachment(json, 'exampleAttachment', TFhirAttachment(elem.example))
  else if (elem.example is TFhirRatio) then
    ComposeRatio(json, 'exampleRatio', TFhirRatio(elem.example))
  else if (elem.example is TFhirSampledData) then
    ComposeSampledData(json, 'exampleSampledData', TFhirSampledData(elem.example))
  else if (elem.example is TFhirReference) then
    ComposeReference(json, 'exampleReference', TFhirReference(elem.example))
  else if (elem.example is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'exampleCodeableConcept', TFhirCodeableConcept(elem.example))
  else if (elem.example is TFhirIdentifier) then
    ComposeIdentifier(json, 'exampleIdentifier', TFhirIdentifier(elem.example))
  else if (elem.example is TFhirSignature) then
    ComposeSignature(json, 'exampleSignature', TFhirSignature(elem.example))
  else if (elem.example is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'exampleElementDefinition', TFhirElementDefinition(elem.example))
  else if (elem.example is TFhirTiming) then
    ComposeTiming(json, 'exampleTiming', TFhirTiming(elem.example))
  else if (elem.example is TFhirAddress) then
    ComposeAddress(json, 'exampleAddress', TFhirAddress(elem.example))
  else if (elem.example is TFhirHumanName) then
    ComposeHumanName(json, 'exampleHumanName', TFhirHumanName(elem.example))
  else if (elem.example is TFhirMeta) then
    ComposeMeta(json, 'exampleMeta', TFhirMeta(elem.example))
  else if (elem.example is TFhirContactPoint) then
    ComposeContactPoint(json, 'exampleContactPoint', TFhirContactPoint(elem.example));
  ComposeIntegerValue(json, 'maxLength', elem.maxLengthElement, false);
  ComposeIntegerProps(json, 'maxLength', elem.maxLengthElement, false);
  if elem.conditionList.Count > 0 then
  begin
    json.valueArray('condition');
    ext := false;
    for i := 0 to elem.conditionList.Count - 1 do
    begin
      ext := ext or ((elem.conditionList[i].id <> '') or (elem.conditionList[i].hasExtensionList));
      ComposeIdValue(json, '',elem.conditionList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_condition');
      for i := 0 to elem.conditionList.Count - 1 do
        ComposeIdProps(json, '',elem.conditionList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.constraintList.Count > 0 then
  begin
    json.valueArray('constraint');
    for i := 0 to elem.constraintList.Count - 1 do
      ComposeElementDefinitionConstraint(json, '',elem.constraintList[i]); {z - }
    json.FinishArray;
  end;
  ComposeBooleanValue(json, 'mustSupport', elem.mustSupportElement, false);
  ComposeBooleanProps(json, 'mustSupport', elem.mustSupportElement, false);
  ComposeBooleanValue(json, 'isModifier', elem.isModifierElement, false);
  ComposeBooleanProps(json, 'isModifier', elem.isModifierElement, false);
  ComposeBooleanValue(json, 'isSummary', elem.isSummaryElement, false);
  ComposeBooleanProps(json, 'isSummary', elem.isSummaryElement, false);
  ComposeElementDefinitionBinding(json, 'binding', elem.binding); {a}
  if elem.mappingList.Count > 0 then
  begin
    json.valueArray('mapping');
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeElementDefinitionMapping(json, '',elem.mappingList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseTimingRepeat(element : IXmlDomElement; path : string) : TFhirTimingRepeat;
var
  child : IXMLDOMElement;
begin
  result := TFhirTimingRepeat.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'bounds') then
        result.bounds := ParsePeriod(child, path+'/bounds') {b}
      else if (child.baseName = 'count') then
        result.countElement := ParseInteger(child, path+'/count') {b}
      else if (child.baseName = 'duration') then
        result.durationElement := ParseDecimal(child, path+'/duration') {b}
      else if (child.baseName = 'durationUnits') then
        result.durationUnitsElement := ParseEnum(CODES_TFhirUnitsOfTime, path+'/durationUnits', child){1a}
      else if (child.baseName = 'frequency') then
        result.frequencyElement := ParseInteger(child, path+'/frequency') {b}
      else if (child.baseName = 'frequencyMax') then
        result.frequencyMaxElement := ParseInteger(child, path+'/frequencyMax') {b}
      else if (child.baseName = 'period') then
        result.periodElement := ParseDecimal(child, path+'/period') {b}
      else if (child.baseName = 'periodMax') then
        result.periodMaxElement := ParseDecimal(child, path+'/periodMax') {b}
      else if (child.baseName = 'periodUnits') then
        result.periodUnitsElement := ParseEnum(CODES_TFhirUnitsOfTime, path+'/periodUnits', child){1a}
      else if (child.baseName = 'when') then
        result.whenElement := ParseEnum(CODES_TFhirEventTiming, path+'/when', child){1a}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTimingRepeat(xml : TXmlBuilder; name : string; elem : TFhirTimingRepeat);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposePeriod(xml, 'bounds', elem.bounds);{x.2}
  ComposeInteger(xml, 'count', elem.countElement);{x.2}
  ComposeDecimal(xml, 'duration', elem.durationElement);{x.2}
  ComposeEnum(xml, 'durationUnits', elem.DurationUnitsElement, CODES_TFhirUnitsOfTime);
  ComposeInteger(xml, 'frequency', elem.frequencyElement);{x.2}
  ComposeInteger(xml, 'frequencyMax', elem.frequencyMaxElement);{x.2}
  ComposeDecimal(xml, 'period', elem.periodElement);{x.2}
  ComposeDecimal(xml, 'periodMax', elem.periodMaxElement);{x.2}
  ComposeEnum(xml, 'periodUnits', elem.PeriodUnitsElement, CODES_TFhirUnitsOfTime);
  ComposeEnum(xml, 'when', elem.WhenElement, CODES_TFhirEventTiming);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTimingRepeat(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTimingRepeat(jsn)); {2}
end;

function TFHIRJsonParser.ParseTimingRepeat(jsn : TJsonObject) : TFhirTimingRepeat;
begin
  result := TFhirTimingRepeat.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('bounds') then
        result.bounds := ParsePeriod(jsn.vObj['bounds']);{q}
    if jsn.has('count') or jsn.has('_count') then
        result.countElement := ParseInteger(jsn['count'], jsn.vObj['_count']);{q}
    if jsn.has('duration') or jsn.has('_duration') then
        result.durationElement := ParseDecimal(jsn['duration'], jsn.vObj['_duration']);{q}
    if jsn.has('durationUnits') or jsn.has('_durationUnits')  then
      result.durationUnitsElement := parseEnum(jsn['durationUnits'], jsn.vObj['_durationUnits'], CODES_TFhirUnitsOfTime);
    if jsn.has('frequency') or jsn.has('_frequency') then
        result.frequencyElement := ParseInteger(jsn['frequency'], jsn.vObj['_frequency']);{q}
    if jsn.has('frequencyMax') or jsn.has('_frequencyMax') then
        result.frequencyMaxElement := ParseInteger(jsn['frequencyMax'], jsn.vObj['_frequencyMax']);{q}
    if jsn.has('period') or jsn.has('_period') then
        result.periodElement := ParseDecimal(jsn['period'], jsn.vObj['_period']);{q}
    if jsn.has('periodMax') or jsn.has('_periodMax') then
        result.periodMaxElement := ParseDecimal(jsn['periodMax'], jsn.vObj['_periodMax']);{q}
    if jsn.has('periodUnits') or jsn.has('_periodUnits')  then
      result.periodUnitsElement := parseEnum(jsn['periodUnits'], jsn.vObj['_periodUnits'], CODES_TFhirUnitsOfTime);
    if jsn.has('when') or jsn.has('_when')  then
      result.whenElement := parseEnum(jsn['when'], jsn.vObj['_when'], CODES_TFhirEventTiming);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTimingRepeat(json : TJSONWriter; name : string; elem : TFhirTimingRepeat; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposePeriod(json, 'bounds', elem.bounds); {a}
  ComposeIntegerValue(json, 'count', elem.countElement, false);
  ComposeIntegerProps(json, 'count', elem.countElement, false);
  ComposeDecimalValue(json, 'duration', elem.durationElement, false);
  ComposeDecimalProps(json, 'duration', elem.durationElement, false);
  ComposeEnumValue(json, 'durationUnits', elem.DurationUnitsElement, CODES_TFhirUnitsOfTime, false);
  ComposeEnumProps(json, 'durationUnits', elem.DurationUnitsElement, CODES_TFhirUnitsOfTime, false);
  ComposeIntegerValue(json, 'frequency', elem.frequencyElement, false);
  ComposeIntegerProps(json, 'frequency', elem.frequencyElement, false);
  ComposeIntegerValue(json, 'frequencyMax', elem.frequencyMaxElement, false);
  ComposeIntegerProps(json, 'frequencyMax', elem.frequencyMaxElement, false);
  ComposeDecimalValue(json, 'period', elem.periodElement, false);
  ComposeDecimalProps(json, 'period', elem.periodElement, false);
  ComposeDecimalValue(json, 'periodMax', elem.periodMaxElement, false);
  ComposeDecimalProps(json, 'periodMax', elem.periodMaxElement, false);
  ComposeEnumValue(json, 'periodUnits', elem.PeriodUnitsElement, CODES_TFhirUnitsOfTime, false);
  ComposeEnumProps(json, 'periodUnits', elem.PeriodUnitsElement, CODES_TFhirUnitsOfTime, false);
  ComposeEnumValue(json, 'when', elem.WhenElement, CODES_TFhirEventTiming, false);
  ComposeEnumProps(json, 'when', elem.WhenElement, CODES_TFhirEventTiming, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseTiming(element : IXmlDomElement; path : string) : TFhirTiming;
var
  child : IXMLDOMElement;
begin
  result := TFhirTiming.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'event') then
        result.eventList.Add(ParseDateTime(child, path+'/event')){y.2}
      else if (child.baseName = 'repeat') then
        result.repeat_ := ParseTimingRepeat(child, path+'/repeat') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTiming(xml : TXmlBuilder; name : string; elem : TFhirTiming);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  for i := 0 to elem.eventList.Count - 1 do
    ComposeDateTime(xml, 'event', elem.eventList[i]);
  ComposeTimingRepeat(xml, 'repeat', elem.repeat_);{x.2}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTiming(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTiming(jsn)); {2}
end;

function TFHIRJsonParser.ParseTiming(jsn : TJsonObject) : TFhirTiming;
begin
  result := TFhirTiming.create;
  try
    ParseElementProperties(jsn, result);
      if jsn.has('event') or jsn.has('_event') then
      iteratePrimitiveArray(jsn.vArr['event'], jsn.vArr['_event'], result.eventList, parseDateTime);
    if jsn.has('repeat') then
        result.repeat_ := ParseTimingRepeat(jsn.vObj['repeat']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTiming(json : TJSONWriter; name : string; elem : TFhirTiming; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    ext := false;
    for i := 0 to elem.eventList.Count - 1 do
    begin
      ext := ext or ((elem.eventList[i].id <> '') or (elem.eventList[i].hasExtensionList));
      ComposeDateTimeValue(json, '',elem.eventList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_event');
      for i := 0 to elem.eventList.Count - 1 do
        ComposeDateTimeProps(json, '',elem.eventList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeTimingRepeat(json, 'repeat', elem.repeat_); {a}
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseAddress(element : IXmlDomElement; path : string) : TFhirAddress;
var
  child : IXMLDOMElement;
begin
  result := TFhirAddress.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'use') then
        result.useElement := ParseEnum(CODES_TFhirAddressUse, path+'/use', child){1a}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'line') then
        result.lineList.Add(ParseString(child, path+'/line')){y.2}
      else if (child.baseName = 'city') then
        result.cityElement := ParseString(child, path+'/city') {b}
      else if (child.baseName = 'state') then
        result.stateElement := ParseString(child, path+'/state') {b}
      else if (child.baseName = 'postalCode') then
        result.postalCodeElement := ParseString(child, path+'/postalCode') {b}
      else if (child.baseName = 'country') then
        result.countryElement := ParseString(child, path+'/country') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAddress(xml : TXmlBuilder; name : string; elem : TFhirAddress);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirAddressUse);
  ComposeString(xml, 'text', elem.textElement);{x.2}
  for i := 0 to elem.lineList.Count - 1 do
    ComposeString(xml, 'line', elem.lineList[i]);
  ComposeString(xml, 'city', elem.cityElement);{x.2}
  ComposeString(xml, 'state', elem.stateElement);{x.2}
  ComposeString(xml, 'postalCode', elem.postalCodeElement);{x.2}
  ComposeString(xml, 'country', elem.countryElement);{x.2}
  ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAddress(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAddress(jsn)); {2}
end;

function TFHIRJsonParser.ParseAddress(jsn : TJsonObject) : TFhirAddress;
begin
  result := TFhirAddress.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn['use'], jsn.vObj['_use'], CODES_TFhirAddressUse);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
      if jsn.has('line') or jsn.has('_line') then
      iteratePrimitiveArray(jsn.vArr['line'], jsn.vArr['_line'], result.lineList, parseString);
    if jsn.has('city') or jsn.has('_city') then
        result.cityElement := ParseString(jsn['city'], jsn.vObj['_city']);{q}
    if jsn.has('state') or jsn.has('_state') then
        result.stateElement := ParseString(jsn['state'], jsn.vObj['_state']);{q}
    if jsn.has('postalCode') or jsn.has('_postalCode') then
        result.postalCodeElement := ParseString(jsn['postalCode'], jsn.vObj['_postalCode']);{q}
    if jsn.has('country') or jsn.has('_country') then
        result.countryElement := ParseString(jsn['country'], jsn.vObj['_country']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAddress(json : TJSONWriter; name : string; elem : TFhirAddress; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirAddressUse, false);
  ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirAddressUse, false);
  ComposeStringValue(json, 'text', elem.textElement, false);
  ComposeStringProps(json, 'text', elem.textElement, false);
  if elem.lineList.Count > 0 then
  begin
    json.valueArray('line');
    ext := false;
    for i := 0 to elem.lineList.Count - 1 do
    begin
      ext := ext or ((elem.lineList[i].id <> '') or (elem.lineList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.lineList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_line');
      for i := 0 to elem.lineList.Count - 1 do
        ComposeStringProps(json, '',elem.lineList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeStringValue(json, 'city', elem.cityElement, false);
  ComposeStringProps(json, 'city', elem.cityElement, false);
  ComposeStringValue(json, 'state', elem.stateElement, false);
  ComposeStringProps(json, 'state', elem.stateElement, false);
  ComposeStringValue(json, 'postalCode', elem.postalCodeElement, false);
  ComposeStringProps(json, 'postalCode', elem.postalCodeElement, false);
  ComposeStringValue(json, 'country', elem.countryElement, false);
  ComposeStringProps(json, 'country', elem.countryElement, false);
  ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseHumanName(element : IXmlDomElement; path : string) : TFhirHumanName;
var
  child : IXMLDOMElement;
begin
  result := TFhirHumanName.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'use') then
        result.useElement := ParseEnum(CODES_TFhirNameUse, path+'/use', child){1a}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'family') then
        result.familyList.Add(ParseString(child, path+'/family')){y.2}
      else if (child.baseName = 'given') then
        result.givenList.Add(ParseString(child, path+'/given')){y.2}
      else if (child.baseName = 'prefix') then
        result.prefixList.Add(ParseString(child, path+'/prefix')){y.2}
      else if (child.baseName = 'suffix') then
        result.suffixList.Add(ParseString(child, path+'/suffix')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeHumanName(xml : TXmlBuilder; name : string; elem : TFhirHumanName);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirNameUse);
  ComposeString(xml, 'text', elem.textElement);{x.2}
  for i := 0 to elem.familyList.Count - 1 do
    ComposeString(xml, 'family', elem.familyList[i]);
  for i := 0 to elem.givenList.Count - 1 do
    ComposeString(xml, 'given', elem.givenList[i]);
  for i := 0 to elem.prefixList.Count - 1 do
    ComposeString(xml, 'prefix', elem.prefixList[i]);
  for i := 0 to elem.suffixList.Count - 1 do
    ComposeString(xml, 'suffix', elem.suffixList[i]);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseHumanName(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHumanName(jsn)); {2}
end;

function TFHIRJsonParser.ParseHumanName(jsn : TJsonObject) : TFhirHumanName;
begin
  result := TFhirHumanName.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn['use'], jsn.vObj['_use'], CODES_TFhirNameUse);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
      if jsn.has('family') or jsn.has('_family') then
      iteratePrimitiveArray(jsn.vArr['family'], jsn.vArr['_family'], result.familyList, parseString);
      if jsn.has('given') or jsn.has('_given') then
      iteratePrimitiveArray(jsn.vArr['given'], jsn.vArr['_given'], result.givenList, parseString);
      if jsn.has('prefix') or jsn.has('_prefix') then
      iteratePrimitiveArray(jsn.vArr['prefix'], jsn.vArr['_prefix'], result.prefixList, parseString);
      if jsn.has('suffix') or jsn.has('_suffix') then
      iteratePrimitiveArray(jsn.vArr['suffix'], jsn.vArr['_suffix'], result.suffixList, parseString);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeHumanName(json : TJSONWriter; name : string; elem : TFhirHumanName; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirNameUse, false);
  ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirNameUse, false);
  ComposeStringValue(json, 'text', elem.textElement, false);
  ComposeStringProps(json, 'text', elem.textElement, false);
  if elem.familyList.Count > 0 then
  begin
    json.valueArray('family');
    ext := false;
    for i := 0 to elem.familyList.Count - 1 do
    begin
      ext := ext or ((elem.familyList[i].id <> '') or (elem.familyList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.familyList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_family');
      for i := 0 to elem.familyList.Count - 1 do
        ComposeStringProps(json, '',elem.familyList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.givenList.Count > 0 then
  begin
    json.valueArray('given');
    ext := false;
    for i := 0 to elem.givenList.Count - 1 do
    begin
      ext := ext or ((elem.givenList[i].id <> '') or (elem.givenList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.givenList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_given');
      for i := 0 to elem.givenList.Count - 1 do
        ComposeStringProps(json, '',elem.givenList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.prefixList.Count > 0 then
  begin
    json.valueArray('prefix');
    ext := false;
    for i := 0 to elem.prefixList.Count - 1 do
    begin
      ext := ext or ((elem.prefixList[i].id <> '') or (elem.prefixList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.prefixList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_prefix');
      for i := 0 to elem.prefixList.Count - 1 do
        ComposeStringProps(json, '',elem.prefixList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.suffixList.Count > 0 then
  begin
    json.valueArray('suffix');
    ext := false;
    for i := 0 to elem.suffixList.Count - 1 do
    begin
      ext := ext or ((elem.suffixList[i].id <> '') or (elem.suffixList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.suffixList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_suffix');
      for i := 0 to elem.suffixList.Count - 1 do
        ComposeStringProps(json, '',elem.suffixList[i], true);
      json.FinishArray;
    end;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseMeta(element : IXmlDomElement; path : string) : TFhirMeta;
var
  child : IXMLDOMElement;
begin
  result := TFhirMeta.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'versionId') then
        result.versionIdElement := ParseId(child, path+'/versionId') {b}
      else if (child.baseName = 'lastUpdated') then
        result.lastUpdatedElement := ParseInstant(child, path+'/lastUpdated') {b}
      else if (child.baseName = 'profile') then
        result.profileList.Add(ParseUri(child, path+'/profile')){y.2}
      else if (child.baseName = 'security') then
        result.securityList.Add(ParseCoding(child, path+'/security')){y.2}
      else if (child.baseName = 'tag') then
        result.tagList.Add(ParseCoding(child, path+'/tag')){y.2}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMeta(xml : TXmlBuilder; name : string; elem : TFhirMeta);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeId(xml, 'versionId', elem.versionIdElement);{x.2}
  ComposeInstant(xml, 'lastUpdated', elem.lastUpdatedElement);{x.2}
  for i := 0 to elem.profileList.Count - 1 do
    ComposeUri(xml, 'profile', elem.profileList[i]);
  for i := 0 to elem.securityList.Count - 1 do
    ComposeCoding(xml, 'security', elem.securityList[i]);
  for i := 0 to elem.tagList.Count - 1 do
    ComposeCoding(xml, 'tag', elem.tagList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMeta(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMeta(jsn)); {2}
end;

function TFHIRJsonParser.ParseMeta(jsn : TJsonObject) : TFhirMeta;
begin
  result := TFhirMeta.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('versionId') or jsn.has('_versionId') then
        result.versionIdElement := ParseId(jsn['versionId'], jsn.vObj['_versionId']);{q}
    if jsn.has('lastUpdated') or jsn.has('_lastUpdated') then
        result.lastUpdatedElement := ParseInstant(jsn['lastUpdated'], jsn.vObj['_lastUpdated']);{q}
      if jsn.has('profile') or jsn.has('_profile') then
      iteratePrimitiveArray(jsn.vArr['profile'], jsn.vArr['_profile'], result.profileList, parseUri);
    if jsn.has('security') then
      iterateArray(jsn.vArr['security'], result.securityList, parseCoding);
    if jsn.has('tag') then
      iterateArray(jsn.vArr['tag'], result.tagList, parseCoding);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMeta(json : TJSONWriter; name : string; elem : TFhirMeta; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeIdValue(json, 'versionId', elem.versionIdElement, false);
  ComposeIdProps(json, 'versionId', elem.versionIdElement, false);
  ComposeInstantValue(json, 'lastUpdated', elem.lastUpdatedElement, false);
  ComposeInstantProps(json, 'lastUpdated', elem.lastUpdatedElement, false);
  if elem.profileList.Count > 0 then
  begin
    json.valueArray('profile');
    ext := false;
    for i := 0 to elem.profileList.Count - 1 do
    begin
      ext := ext or ((elem.profileList[i].id <> '') or (elem.profileList[i].hasExtensionList));
      ComposeUriValue(json, '',elem.profileList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_profile');
      for i := 0 to elem.profileList.Count - 1 do
        ComposeUriProps(json, '',elem.profileList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.securityList.Count > 0 then
  begin
    json.valueArray('security');
    for i := 0 to elem.securityList.Count - 1 do
      ComposeCoding(json, '',elem.securityList[i]); {z - Coding}
    json.FinishArray;
  end;
  if elem.tagList.Count > 0 then
  begin
    json.valueArray('tag');
    for i := 0 to elem.tagList.Count - 1 do
      ComposeCoding(json, '',elem.tagList[i]); {z - Coding}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseContactPoint(element : IXmlDomElement; path : string) : TFhirContactPoint;
var
  child : IXMLDOMElement;
begin
  result := TFhirContactPoint.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.systemElement := ParseEnum(CODES_TFhirContactPointSystem, path+'/system', child){1a}
      else if (child.baseName = 'value') then
        result.valueElement := ParseString(child, path+'/value') {b}
      else if (child.baseName = 'use') then
        result.useElement := ParseEnum(CODES_TFhirContactPointUse, path+'/use', child){1a}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContactPoint(xml : TXmlBuilder; name : string; elem : TFhirContactPoint);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'system', elem.SystemElement, CODES_TFhirContactPointSystem);
  ComposeString(xml, 'value', elem.valueElement);{x.2}
  ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirContactPointUse);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContactPoint(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContactPoint(jsn)); {2}
end;

function TFHIRJsonParser.ParseContactPoint(jsn : TJsonObject) : TFhirContactPoint;
begin
  result := TFhirContactPoint.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system')  then
      result.systemElement := parseEnum(jsn['system'], jsn.vObj['_system'], CODES_TFhirContactPointSystem);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn['use'], jsn.vObj['_use'], CODES_TFhirContactPointUse);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContactPoint(json : TJSONWriter; name : string; elem : TFhirContactPoint; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'system', elem.SystemElement, CODES_TFhirContactPointSystem, false);
  ComposeEnumProps(json, 'system', elem.SystemElement, CODES_TFhirContactPointSystem, false);
  ComposeStringValue(json, 'value', elem.valueElement, false);
  ComposeStringProps(json, 'value', elem.valueElement, false);
  ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirContactPointUse, false);
  ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirContactPointUse, false);
  ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseAge(element : IXmlDomElement; path : string) : TFhirAge;
begin
  result := ParseQuantity(element, path);
end;

procedure TFHIRXmlComposer.ComposeAge(xml : TXmlBuilder; name : string; elem : TFhirAge);
begin
  ComposeQuantity(xml, name, elem);
end;

function TFHIRJsonParser.ParseAge(jsn : TJsonObject) : TFhirAge;
begin
  result := ParseQuantity(jsn);
end;

procedure TFHIRJsonComposer.ComposeAge(json : TJSONWriter; name : string; elem : TFhirAge; noObj : boolean = false);
begin
  ComposeQuantity(json, name, elem, noObj);
end;

function TFHIRXmlParser.ParseCount(element : IXmlDomElement; path : string) : TFhirCount;
begin
  result := ParseQuantity(element, path);
end;

procedure TFHIRXmlComposer.ComposeCount(xml : TXmlBuilder; name : string; elem : TFhirCount);
begin
  ComposeQuantity(xml, name, elem);
end;

function TFHIRJsonParser.ParseCount(jsn : TJsonObject) : TFhirCount;
begin
  result := ParseQuantity(jsn);
end;

procedure TFHIRJsonComposer.ComposeCount(json : TJSONWriter; name : string; elem : TFhirCount; noObj : boolean = false);
begin
  ComposeQuantity(json, name, elem, noObj);
end;

function TFHIRXmlParser.ParseMoney(element : IXmlDomElement; path : string) : TFhirMoney;
begin
  result := ParseQuantity(element, path);
end;

procedure TFHIRXmlComposer.ComposeMoney(xml : TXmlBuilder; name : string; elem : TFhirMoney);
begin
  ComposeQuantity(xml, name, elem);
end;

function TFHIRJsonParser.ParseMoney(jsn : TJsonObject) : TFhirMoney;
begin
  result := ParseQuantity(jsn);
end;

procedure TFHIRJsonComposer.ComposeMoney(json : TJSONWriter; name : string; elem : TFhirMoney; noObj : boolean = false);
begin
  ComposeQuantity(json, name, elem, noObj);
end;

function TFHIRXmlParser.ParseDistance(element : IXmlDomElement; path : string) : TFhirDistance;
begin
  result := ParseQuantity(element, path);
end;

procedure TFHIRXmlComposer.ComposeDistance(xml : TXmlBuilder; name : string; elem : TFhirDistance);
begin
  ComposeQuantity(xml, name, elem);
end;

function TFHIRJsonParser.ParseDistance(jsn : TJsonObject) : TFhirDistance;
begin
  result := ParseQuantity(jsn);
end;

procedure TFHIRJsonComposer.ComposeDistance(json : TJSONWriter; name : string; elem : TFhirDistance; noObj : boolean = false);
begin
  ComposeQuantity(json, name, elem, noObj);
end;

function TFHIRXmlParser.ParseDuration(element : IXmlDomElement; path : string) : TFhirDuration;
begin
  result := ParseQuantity(element, path);
end;

procedure TFHIRXmlComposer.ComposeDuration(xml : TXmlBuilder; name : string; elem : TFhirDuration);
begin
  ComposeQuantity(xml, name, elem);
end;

function TFHIRJsonParser.ParseDuration(jsn : TJsonObject) : TFhirDuration;
begin
  result := ParseQuantity(jsn);
end;

procedure TFHIRJsonComposer.ComposeDuration(json : TJSONWriter; name : string; elem : TFhirDuration; noObj : boolean = false);
begin
  ComposeQuantity(json, name, elem, noObj);
end;

function TFHIRXmlParser.ParseAllergyIntoleranceEvent(element : IXmlDomElement; path : string) : TFhirAllergyIntoleranceEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirAllergyIntoleranceEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'substance') then
        result.substance := ParseCodeableConcept(child, path+'/substance') {b}
      else if (child.baseName = 'certainty') then
        result.certaintyElement := ParseEnum(CODES_TFhirReactionEventCertainty, path+'/certainty', child){1a}
      else if (child.baseName = 'manifestation') then
        result.manifestationList.Add(ParseCodeableConcept(child, path+'/manifestation')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'onset') then
        result.onsetElement := ParseDateTime(child, path+'/onset') {b}
      else if (child.baseName = 'duration') then
        result.duration := ParseQuantity(child, path+'/duration') {b}
      else if (child.baseName = 'severity') then
        result.severityElement := ParseEnum(CODES_TFhirReactionEventSeverity, path+'/severity', child){1a}
      else if (child.baseName = 'exposureRoute') then
        result.exposureRoute := ParseCodeableConcept(child, path+'/exposureRoute') {b}
      else if (child.baseName = 'comment') then
        result.commentElement := ParseString(child, path+'/comment') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntoleranceEvent(xml : TXmlBuilder; name : string; elem : TFhirAllergyIntoleranceEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'substance', elem.substance);{x.2}
  ComposeEnum(xml, 'certainty', elem.CertaintyElement, CODES_TFhirReactionEventCertainty);
  for i := 0 to elem.manifestationList.Count - 1 do
    ComposeCodeableConcept(xml, 'manifestation', elem.manifestationList[i]);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeDateTime(xml, 'onset', elem.onsetElement);{x.2}
  ComposeQuantity(xml, 'duration', elem.duration);{x.2}
  ComposeEnum(xml, 'severity', elem.SeverityElement, CODES_TFhirReactionEventSeverity);
  ComposeCodeableConcept(xml, 'exposureRoute', elem.exposureRoute);{x.2}
  ComposeString(xml, 'comment', elem.commentElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAllergyIntoleranceEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAllergyIntoleranceEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseAllergyIntoleranceEvent(jsn : TJsonObject) : TFhirAllergyIntoleranceEvent;
begin
  result := TFhirAllergyIntoleranceEvent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('substance') then
        result.substance := ParseCodeableConcept(jsn.vObj['substance']);{q}
    if jsn.has('certainty') or jsn.has('_certainty')  then
      result.certaintyElement := parseEnum(jsn['certainty'], jsn.vObj['_certainty'], CODES_TFhirReactionEventCertainty);
    if jsn.has('manifestation') then
      iterateArray(jsn.vArr['manifestation'], result.manifestationList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('onset') or jsn.has('_onset') then
        result.onsetElement := ParseDateTime(jsn['onset'], jsn.vObj['_onset']);{q}
    if jsn.has('duration') then
        result.duration := ParseQuantity(jsn.vObj['duration']);{q}
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityElement := parseEnum(jsn['severity'], jsn.vObj['_severity'], CODES_TFhirReactionEventSeverity);
    if jsn.has('exposureRoute') then
        result.exposureRoute := ParseCodeableConcept(jsn.vObj['exposureRoute']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAllergyIntoleranceEvent(json : TJSONWriter; name : string; elem : TFhirAllergyIntoleranceEvent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'substance', elem.substance); {a}
  ComposeEnumValue(json, 'certainty', elem.CertaintyElement, CODES_TFhirReactionEventCertainty, false);
  ComposeEnumProps(json, 'certainty', elem.CertaintyElement, CODES_TFhirReactionEventCertainty, false);
  if elem.manifestationList.Count > 0 then
  begin
    json.valueArray('manifestation');
    for i := 0 to elem.manifestationList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.manifestationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeDateTimeValue(json, 'onset', elem.onsetElement, false);
  ComposeDateTimeProps(json, 'onset', elem.onsetElement, false);
  ComposeQuantity(json, 'duration', elem.duration); {a}
  ComposeEnumValue(json, 'severity', elem.SeverityElement, CODES_TFhirReactionEventSeverity, false);
  ComposeEnumProps(json, 'severity', elem.SeverityElement, CODES_TFhirReactionEventSeverity, false);
  ComposeCodeableConcept(json, 'exposureRoute', elem.exposureRoute); {a}
  ComposeStringValue(json, 'comment', elem.commentElement, false);
  ComposeStringProps(json, 'comment', elem.commentElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseAllergyIntolerance(element : IXmlDomElement; path : string) : TFhirAllergyIntolerance;
var
  child : IXMLDOMElement;
begin
  result := TFhirAllergyIntolerance.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'recordedDate') then
        result.recordedDateElement := ParseDateTime(child, path+'/recordedDate') {b}
      else if (child.baseName = 'recorder') then
        result.recorder := ParseReference{Resource}(child, path+'/recorder') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'reporter') then
        result.reporter := ParseReference{Resource}(child, path+'/reporter') {b}
      else if (child.baseName = 'substance') then
        result.substance := ParseCodeableConcept(child, path+'/substance') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirAllergyIntoleranceStatus, path+'/status', child){1a}
      else if (child.baseName = 'criticality') then
        result.criticalityElement := ParseEnum(CODES_TFhirAllergyIntoleranceCriticality, path+'/criticality', child){1a}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirAllergyIntoleranceType, path+'/type', child){1a}
      else if (child.baseName = 'category') then
        result.categoryElement := ParseEnum(CODES_TFhirAllergyIntoleranceCategory, path+'/category', child){1a}
      else if (child.baseName = 'lastOccurence') then
        result.lastOccurenceElement := ParseDateTime(child, path+'/lastOccurence') {b}
      else if (child.baseName = 'comment') then
        result.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.baseName = 'event') then
        result.eventList.Add(ParseAllergyIntoleranceEvent(child, path+'/event')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntolerance(xml : TXmlBuilder; name : string; elem : TFhirAllergyIntolerance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeDateTime(xml, 'recordedDate', elem.recordedDateElement);{x.2}
  ComposeReference{Resource}(xml, 'recorder', elem.recorder);{x.2}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeReference{Resource}(xml, 'reporter', elem.reporter);{x.2}
  ComposeCodeableConcept(xml, 'substance', elem.substance);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirAllergyIntoleranceStatus);
  ComposeEnum(xml, 'criticality', elem.CriticalityElement, CODES_TFhirAllergyIntoleranceCriticality);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirAllergyIntoleranceType);
  ComposeEnum(xml, 'category', elem.CategoryElement, CODES_TFhirAllergyIntoleranceCategory);
  ComposeDateTime(xml, 'lastOccurence', elem.lastOccurenceElement);{x.2}
  ComposeString(xml, 'comment', elem.commentElement);{x.2}
  for i := 0 to elem.eventList.Count - 1 do
    ComposeAllergyIntoleranceEvent(xml, 'event', elem.eventList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAllergyIntolerance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAllergyIntolerance(jsn)); {2}
end;

function TFHIRJsonParser.ParseAllergyIntolerance(jsn : TJsonObject) : TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('recordedDate') or jsn.has('_recordedDate') then
        result.recordedDateElement := ParseDateTime(jsn['recordedDate'], jsn.vObj['_recordedDate']);{q}
    if jsn.has('recorder') then
        result.recorder := ParseReference{Resource}(jsn.vObj['recorder']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('reporter') then
        result.reporter := ParseReference{Resource}(jsn.vObj['reporter']);{q}
    if jsn.has('substance') then
        result.substance := ParseCodeableConcept(jsn.vObj['substance']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirAllergyIntoleranceStatus);
    if jsn.has('criticality') or jsn.has('_criticality')  then
      result.criticalityElement := parseEnum(jsn['criticality'], jsn.vObj['_criticality'], CODES_TFhirAllergyIntoleranceCriticality);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirAllergyIntoleranceType);
    if jsn.has('category') or jsn.has('_category')  then
      result.categoryElement := parseEnum(jsn['category'], jsn.vObj['_category'], CODES_TFhirAllergyIntoleranceCategory);
    if jsn.has('lastOccurence') or jsn.has('_lastOccurence') then
        result.lastOccurenceElement := ParseDateTime(jsn['lastOccurence'], jsn.vObj['_lastOccurence']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseAllergyIntoleranceEvent);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAllergyIntolerance(json : TJSONWriter; name : string; elem : TFhirAllergyIntolerance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'recordedDate', elem.recordedDateElement, false);
  ComposeDateTimeProps(json, 'recordedDate', elem.recordedDateElement, false);
  ComposeReference{Resource}(json, 'recorder', elem.recorder); {a}
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeReference{Resource}(json, 'reporter', elem.reporter); {a}
  ComposeCodeableConcept(json, 'substance', elem.substance); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirAllergyIntoleranceStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirAllergyIntoleranceStatus, false);
  ComposeEnumValue(json, 'criticality', elem.CriticalityElement, CODES_TFhirAllergyIntoleranceCriticality, false);
  ComposeEnumProps(json, 'criticality', elem.CriticalityElement, CODES_TFhirAllergyIntoleranceCriticality, false);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirAllergyIntoleranceType, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirAllergyIntoleranceType, false);
  ComposeEnumValue(json, 'category', elem.CategoryElement, CODES_TFhirAllergyIntoleranceCategory, false);
  ComposeEnumProps(json, 'category', elem.CategoryElement, CODES_TFhirAllergyIntoleranceCategory, false);
  ComposeDateTimeValue(json, 'lastOccurence', elem.lastOccurenceElement, false);
  ComposeDateTimeProps(json, 'lastOccurence', elem.lastOccurenceElement, false);
  ComposeStringValue(json, 'comment', elem.commentElement, false);
  ComposeStringProps(json, 'comment', elem.commentElement, false);
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeAllergyIntoleranceEvent(json, '',elem.eventList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseAppointmentParticipant(element : IXmlDomElement; path : string) : TFhirAppointmentParticipant;
var
  child : IXMLDOMElement;
begin
  result := TFhirAppointmentParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.baseName = 'actor') then
        result.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.baseName = 'required') then
        result.requiredElement := ParseEnum(CODES_TFhirParticipantrequired, path+'/required', child){1a}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirParticipationstatus, path+'/status', child){1a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAppointmentParticipant(xml : TXmlBuilder; name : string; elem : TFhirAppointmentParticipant);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2}
  ComposeEnum(xml, 'required', elem.RequiredElement, CODES_TFhirParticipantrequired);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirParticipationstatus);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAppointmentParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAppointmentParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseAppointmentParticipant(jsn : TJsonObject) : TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('actor') then
        result.actor := ParseReference{Resource}(jsn.vObj['actor']);{q}
    if jsn.has('required') or jsn.has('_required')  then
      result.requiredElement := parseEnum(jsn['required'], jsn.vObj['_required'], CODES_TFhirParticipantrequired);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirParticipationstatus);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAppointmentParticipant(json : TJSONWriter; name : string; elem : TFhirAppointmentParticipant; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '',elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeReference{Resource}(json, 'actor', elem.actor); {a}
  ComposeEnumValue(json, 'required', elem.RequiredElement, CODES_TFhirParticipantrequired, false);
  ComposeEnumProps(json, 'required', elem.RequiredElement, CODES_TFhirParticipantrequired, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirParticipationstatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirParticipationstatus, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseAppointment(element : IXmlDomElement; path : string) : TFhirAppointment;
var
  child : IXMLDOMElement;
begin
  result := TFhirAppointment.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirAppointmentstatus, path+'/status', child){1a}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.baseName = 'priority') then
        result.priorityElement := ParseUnsignedInt(child, path+'/priority') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'start') then
        result.startElement := ParseInstant(child, path+'/start') {b}
      else if (child.baseName = 'end') then
        result.end_Element := ParseInstant(child, path+'/end') {b}
      else if (child.baseName = 'slot') then
        result.slotList.Add(ParseReference{TFhirSlot}(child, path+'/slot')){y.2}
      else if (child.baseName = 'comment') then
        result.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.baseName = 'order') then
        result.order := ParseReference{TFhirOrder}(child, path+'/order') {b}
      else if (child.baseName = 'participant') then
        result.participantList.Add(ParseAppointmentParticipant(child, path+'/participant')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAppointment(xml : TXmlBuilder; name : string; elem : TFhirAppointment);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirAppointmentstatus);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2}
  ComposeUnsignedInt(xml, 'priority', elem.priorityElement);{x.2}
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeInstant(xml, 'start', elem.startElement);{x.2}
  ComposeInstant(xml, 'end', elem.end_Element);{x.2}
  for i := 0 to elem.slotList.Count - 1 do
    ComposeReference{TFhirSlot}(xml, 'slot', elem.slotList[i]);
  ComposeString(xml, 'comment', elem.commentElement);{x.2}
  ComposeReference{TFhirOrder}(xml, 'order', elem.order);{x.2}
  for i := 0 to elem.participantList.Count - 1 do
    ComposeAppointmentParticipant(xml, 'participant', elem.participantList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAppointment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAppointment(jsn)); {2}
end;

function TFHIRJsonParser.ParseAppointment(jsn : TJsonObject) : TFhirAppointment;
begin
  result := TFhirAppointment.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirAppointmentstatus);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    if jsn.has('priority') or jsn.has('_priority') then
        result.priorityElement := ParseUnsignedInt(jsn['priority'], jsn.vObj['_priority']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := ParseInstant(jsn['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := ParseInstant(jsn['end'], jsn.vObj['_end']);{q}
    if jsn.has('slot') then
      iterateArray(jsn.vArr['slot'], result.slotList, parseReference{TFhirSlot});
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('order') then
        result.order := ParseReference{TFhirOrder}(jsn.vObj['order']);{q}
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseAppointmentParticipant);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAppointment(json : TJSONWriter; name : string; elem : TFhirAppointment; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirAppointmentstatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirAppointmentstatus, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  ComposeUnsignedIntValue(json, 'priority', elem.priorityElement, false);
  ComposeUnsignedIntProps(json, 'priority', elem.priorityElement, false);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeInstantValue(json, 'start', elem.startElement, false);
  ComposeInstantProps(json, 'start', elem.startElement, false);
  ComposeInstantValue(json, 'end', elem.end_Element, false);
  ComposeInstantProps(json, 'end', elem.end_Element, false);
  if elem.slotList.Count > 0 then
  begin
    json.valueArray('slot');
    for i := 0 to elem.slotList.Count - 1 do
      ComposeReference{TFhirSlot}(json, '',elem.slotList[i]); {z - Reference(Slot)}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'comment', elem.commentElement, false);
  ComposeStringProps(json, 'comment', elem.commentElement, false);
  ComposeReference{TFhirOrder}(json, 'order', elem.order); {a}
  if elem.participantList.Count > 0 then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeAppointmentParticipant(json, '',elem.participantList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseAppointmentResponse(element : IXmlDomElement; path : string) : TFhirAppointmentResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirAppointmentResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'appointment') then
        result.appointment := ParseReference{TFhirAppointment}(child, path+'/appointment') {b}
      else if (child.baseName = 'participantType') then
        result.participantTypeList.Add(ParseCodeableConcept(child, path+'/participantType')){y.2}
      else if (child.baseName = 'actor') then
        result.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.baseName = 'participantStatus') then
        result.participantStatusElement := ParseEnum(CODES_TFhirParticipantstatus, path+'/participantStatus', child){1a}
      else if (child.baseName = 'comment') then
        result.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.baseName = 'start') then
        result.startElement := ParseInstant(child, path+'/start') {b}
      else if (child.baseName = 'end') then
        result.end_Element := ParseInstant(child, path+'/end') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAppointmentResponse(xml : TXmlBuilder; name : string; elem : TFhirAppointmentResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirAppointment}(xml, 'appointment', elem.appointment);{x.2}
  for i := 0 to elem.participantTypeList.Count - 1 do
    ComposeCodeableConcept(xml, 'participantType', elem.participantTypeList[i]);
  ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2}
  ComposeEnum(xml, 'participantStatus', elem.ParticipantStatusElement, CODES_TFhirParticipantstatus);
  ComposeString(xml, 'comment', elem.commentElement);{x.2}
  ComposeInstant(xml, 'start', elem.startElement);{x.2}
  ComposeInstant(xml, 'end', elem.end_Element);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAppointmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAppointmentResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseAppointmentResponse(jsn : TJsonObject) : TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('appointment') then
        result.appointment := ParseReference{TFhirAppointment}(jsn.vObj['appointment']);{q}
    if jsn.has('participantType') then
      iterateArray(jsn.vArr['participantType'], result.participantTypeList, parseCodeableConcept);
    if jsn.has('actor') then
        result.actor := ParseReference{Resource}(jsn.vObj['actor']);{q}
    if jsn.has('participantStatus') or jsn.has('_participantStatus')  then
      result.participantStatusElement := parseEnum(jsn['participantStatus'], jsn.vObj['_participantStatus'], CODES_TFhirParticipantstatus);
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := ParseInstant(jsn['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := ParseInstant(jsn['end'], jsn.vObj['_end']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAppointmentResponse(json : TJSONWriter; name : string; elem : TFhirAppointmentResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirAppointment}(json, 'appointment', elem.appointment); {a}
  if elem.participantTypeList.Count > 0 then
  begin
    json.valueArray('participantType');
    for i := 0 to elem.participantTypeList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.participantTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeReference{Resource}(json, 'actor', elem.actor); {a}
  ComposeEnumValue(json, 'participantStatus', elem.ParticipantStatusElement, CODES_TFhirParticipantstatus, false);
  ComposeEnumProps(json, 'participantStatus', elem.ParticipantStatusElement, CODES_TFhirParticipantstatus, false);
  ComposeStringValue(json, 'comment', elem.commentElement, false);
  ComposeStringProps(json, 'comment', elem.commentElement, false);
  ComposeInstantValue(json, 'start', elem.startElement, false);
  ComposeInstantProps(json, 'start', elem.startElement, false);
  ComposeInstantValue(json, 'end', elem.end_Element, false);
  ComposeInstantProps(json, 'end', elem.end_Element, false);
end;

function TFHIRXmlParser.ParseAuditEventEvent(element : IXmlDomElement; path : string) : TFhirAuditEventEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirAuditEventEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'subtype') then
        result.subtypeList.Add(ParseCodeableConcept(child, path+'/subtype')){y.2}
      else if (child.baseName = 'action') then
        result.actionElement := ParseEnum(CODES_TFhirAuditEventAction, path+'/action', child){1a}
      else if (child.baseName = 'dateTime') then
        result.dateTimeElement := ParseInstant(child, path+'/dateTime') {b}
      else if (child.baseName = 'outcome') then
        result.outcomeElement := ParseEnum(CODES_TFhirAuditEventOutcome, path+'/outcome', child){1a}
      else if (child.baseName = 'outcomeDesc') then
        result.outcomeDescElement := ParseString(child, path+'/outcomeDesc') {b}
      else if (child.baseName = 'purposeOfEvent') then
        result.purposeOfEventList.Add(ParseCoding(child, path+'/purposeOfEvent')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAuditEventEvent(xml : TXmlBuilder; name : string; elem : TFhirAuditEventEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  for i := 0 to elem.subtypeList.Count - 1 do
    ComposeCodeableConcept(xml, 'subtype', elem.subtypeList[i]);
  ComposeEnum(xml, 'action', elem.ActionElement, CODES_TFhirAuditEventAction);
  ComposeInstant(xml, 'dateTime', elem.dateTimeElement);{x.2}
  ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirAuditEventOutcome);
  ComposeString(xml, 'outcomeDesc', elem.outcomeDescElement);{x.2}
  for i := 0 to elem.purposeOfEventList.Count - 1 do
    ComposeCoding(xml, 'purposeOfEvent', elem.purposeOfEventList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAuditEventEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventEvent(jsn : TJsonObject) : TFhirAuditEventEvent;
begin
  result := TFhirAuditEventEvent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('subtype') then
      iterateArray(jsn.vArr['subtype'], result.subtypeList, parseCodeableConcept);
    if jsn.has('action') or jsn.has('_action')  then
      result.actionElement := parseEnum(jsn['action'], jsn.vObj['_action'], CODES_TFhirAuditEventAction);
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeElement := ParseInstant(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn['outcome'], jsn.vObj['_outcome'], CODES_TFhirAuditEventOutcome);
    if jsn.has('outcomeDesc') or jsn.has('_outcomeDesc') then
        result.outcomeDescElement := ParseString(jsn['outcomeDesc'], jsn.vObj['_outcomeDesc']);{q}
    if jsn.has('purposeOfEvent') then
      iterateArray(jsn.vArr['purposeOfEvent'], result.purposeOfEventList, parseCoding);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAuditEventEvent(json : TJSONWriter; name : string; elem : TFhirAuditEventEvent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.subtypeList.Count > 0 then
  begin
    json.valueArray('subtype');
    for i := 0 to elem.subtypeList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.subtypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'action', elem.ActionElement, CODES_TFhirAuditEventAction, false);
  ComposeEnumProps(json, 'action', elem.ActionElement, CODES_TFhirAuditEventAction, false);
  ComposeInstantValue(json, 'dateTime', elem.dateTimeElement, false);
  ComposeInstantProps(json, 'dateTime', elem.dateTimeElement, false);
  ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirAuditEventOutcome, false);
  ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirAuditEventOutcome, false);
  ComposeStringValue(json, 'outcomeDesc', elem.outcomeDescElement, false);
  ComposeStringProps(json, 'outcomeDesc', elem.outcomeDescElement, false);
  if elem.purposeOfEventList.Count > 0 then
  begin
    json.valueArray('purposeOfEvent');
    for i := 0 to elem.purposeOfEventList.Count - 1 do
      ComposeCoding(json, '',elem.purposeOfEventList[i]); {z - Coding}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseAuditEventParticipant(element : IXmlDomElement; path : string) : TFhirAuditEventParticipant;
var
  child : IXMLDOMElement;
begin
  result := TFhirAuditEventParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'role') then
        result.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if (child.baseName = 'reference') then
        result.reference := ParseReference{Resource}(child, path+'/reference') {b}
      else if (child.baseName = 'userId') then
        result.userIdElement := ParseString(child, path+'/userId') {b}
      else if (child.baseName = 'altId') then
        result.altIdElement := ParseString(child, path+'/altId') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'requestor') then
        result.requestorElement := ParseBoolean(child, path+'/requestor') {b}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'policy') then
        result.policyList.Add(ParseUri(child, path+'/policy')){y.2}
      else if (child.baseName = 'media') then
        result.media := ParseCoding(child, path+'/media') {b}
      else if (child.baseName = 'network') then
        result.network := ParseAuditEventParticipantNetwork(child, path+'/network') {b}
      else if (child.baseName = 'purposeOfUse') then
        result.purposeOfUseList.Add(ParseCoding(child, path+'/purposeOfUse')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAuditEventParticipant(xml : TXmlBuilder; name : string; elem : TFhirAuditEventParticipant);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.roleList.Count - 1 do
    ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
  ComposeReference{Resource}(xml, 'reference', elem.reference);{x.2}
  ComposeString(xml, 'userId', elem.userIdElement);{x.2}
  ComposeString(xml, 'altId', elem.altIdElement);{x.2}
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeBoolean(xml, 'requestor', elem.requestorElement);{x.2}
  ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  for i := 0 to elem.policyList.Count - 1 do
    ComposeUri(xml, 'policy', elem.policyList[i]);
  ComposeCoding(xml, 'media', elem.media);{x.2}
  ComposeAuditEventParticipantNetwork(xml, 'network', elem.network);{x.2}
  for i := 0 to elem.purposeOfUseList.Count - 1 do
    ComposeCoding(xml, 'purposeOfUse', elem.purposeOfUseList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAuditEventParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventParticipant(jsn : TJsonObject) : TFhirAuditEventParticipant;
begin
  result := TFhirAuditEventParticipant.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
    if jsn.has('reference') then
        result.reference := ParseReference{Resource}(jsn.vObj['reference']);{q}
    if jsn.has('userId') or jsn.has('_userId') then
        result.userIdElement := ParseString(jsn['userId'], jsn.vObj['_userId']);{q}
    if jsn.has('altId') or jsn.has('_altId') then
        result.altIdElement := ParseString(jsn['altId'], jsn.vObj['_altId']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('requestor') or jsn.has('_requestor') then
        result.requestorElement := ParseBoolean(jsn['requestor'], jsn.vObj['_requestor']);{q}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
      if jsn.has('policy') or jsn.has('_policy') then
      iteratePrimitiveArray(jsn.vArr['policy'], jsn.vArr['_policy'], result.policyList, parseUri);
    if jsn.has('media') then
        result.media := ParseCoding(jsn.vObj['media']);{q}
    if jsn.has('network') then
        result.network := ParseAuditEventParticipantNetwork(jsn.vObj['network']);{q}
    if jsn.has('purposeOfUse') then
      iterateArray(jsn.vArr['purposeOfUse'], result.purposeOfUseList, parseCoding);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAuditEventParticipant(json : TJSONWriter; name : string; elem : TFhirAuditEventParticipant; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.roleList.Count > 0 then
  begin
    json.valueArray('role');
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.roleList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeReference{Resource}(json, 'reference', elem.reference); {a}
  ComposeStringValue(json, 'userId', elem.userIdElement, false);
  ComposeStringProps(json, 'userId', elem.userIdElement, false);
  ComposeStringValue(json, 'altId', elem.altIdElement, false);
  ComposeStringProps(json, 'altId', elem.altIdElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeBooleanValue(json, 'requestor', elem.requestorElement, false);
  ComposeBooleanProps(json, 'requestor', elem.requestorElement, false);
  ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if elem.policyList.Count > 0 then
  begin
    json.valueArray('policy');
    ext := false;
    for i := 0 to elem.policyList.Count - 1 do
    begin
      ext := ext or ((elem.policyList[i].id <> '') or (elem.policyList[i].hasExtensionList));
      ComposeUriValue(json, '',elem.policyList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_policy');
      for i := 0 to elem.policyList.Count - 1 do
        ComposeUriProps(json, '',elem.policyList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeCoding(json, 'media', elem.media); {a}
  ComposeAuditEventParticipantNetwork(json, 'network', elem.network); {a}
  if elem.purposeOfUseList.Count > 0 then
  begin
    json.valueArray('purposeOfUse');
    for i := 0 to elem.purposeOfUseList.Count - 1 do
      ComposeCoding(json, '',elem.purposeOfUseList[i]); {z - Coding}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseAuditEventParticipantNetwork(element : IXmlDomElement; path : string) : TFhirAuditEventParticipantNetwork;
var
  child : IXMLDOMElement;
begin
  result := TFhirAuditEventParticipantNetwork.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierElement := ParseString(child, path+'/identifier') {b}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirNetworkType, path+'/type', child){1a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAuditEventParticipantNetwork(xml : TXmlBuilder; name : string; elem : TFhirAuditEventParticipantNetwork);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'identifier', elem.identifierElement);{x.2}
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirNetworkType);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAuditEventParticipantNetwork(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventParticipantNetwork(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventParticipantNetwork(jsn : TJsonObject) : TFhirAuditEventParticipantNetwork;
begin
  result := TFhirAuditEventParticipantNetwork.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierElement := ParseString(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirNetworkType);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAuditEventParticipantNetwork(json : TJSONWriter; name : string; elem : TFhirAuditEventParticipantNetwork; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'identifier', elem.identifierElement, false);
  ComposeStringProps(json, 'identifier', elem.identifierElement, false);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirNetworkType, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirNetworkType, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseAuditEventSource(element : IXmlDomElement; path : string) : TFhirAuditEventSource;
var
  child : IXMLDOMElement;
begin
  result := TFhirAuditEventSource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'site') then
        result.siteElement := ParseString(child, path+'/site') {b}
      else if (child.baseName = 'identifier') then
        result.identifierElement := ParseString(child, path+'/identifier') {b}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseCoding(child, path+'/type')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAuditEventSource(xml : TXmlBuilder; name : string; elem : TFhirAuditEventSource);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'site', elem.siteElement);{x.2}
  ComposeString(xml, 'identifier', elem.identifierElement);{x.2}
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCoding(xml, 'type', elem.type_List[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAuditEventSource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventSource(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventSource(jsn : TJsonObject) : TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('site') or jsn.has('_site') then
        result.siteElement := ParseString(jsn['site'], jsn.vObj['_site']);{q}
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierElement := ParseString(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCoding);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAuditEventSource(json : TJSONWriter; name : string; elem : TFhirAuditEventSource; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'site', elem.siteElement, false);
  ComposeStringProps(json, 'site', elem.siteElement, false);
  ComposeStringValue(json, 'identifier', elem.identifierElement, false);
  ComposeStringProps(json, 'identifier', elem.identifierElement, false);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(json, '',elem.type_List[i]); {z - Coding}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseAuditEventObject(element : IXmlDomElement; path : string) : TFhirAuditEventObject;
var
  child : IXMLDOMElement;
begin
  result := TFhirAuditEventObject.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'reference') then
        result.reference := ParseReference{TFhirReference}(child, path+'/reference') {b}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirObjectType, path+'/type', child){1a}
      else if (child.baseName = 'role') then
        result.roleElement := ParseEnum(CODES_TFhirObjectRole, path+'/role', child){1a}
      else if (child.baseName = 'lifecycle') then
        result.lifecycleElement := ParseEnum(CODES_TFhirObjectLifecycle, path+'/lifecycle', child){1a}
      else if (child.baseName = 'sensitivity') then
        result.sensitivity := ParseCodeableConcept(child, path+'/sensitivity') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'query') then
        result.queryElement := ParseBase64Binary(child, path+'/query') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseAuditEventObjectDetail(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAuditEventObject(xml : TXmlBuilder; name : string; elem : TFhirAuditEventObject);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeReference{TFhirReference}(xml, 'reference', elem.reference);{x.2}
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirObjectType);
  ComposeEnum(xml, 'role', elem.RoleElement, CODES_TFhirObjectRole);
  ComposeEnum(xml, 'lifecycle', elem.LifecycleElement, CODES_TFhirObjectLifecycle);
  ComposeCodeableConcept(xml, 'sensitivity', elem.sensitivity);{x.2}
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeBase64Binary(xml, 'query', elem.queryElement);{x.2}
  for i := 0 to elem.detailList.Count - 1 do
    ComposeAuditEventObjectDetail(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAuditEventObject(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventObject(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventObject(jsn : TJsonObject) : TFhirAuditEventObject;
begin
  result := TFhirAuditEventObject.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('reference') then
        result.reference := ParseReference{TFhirReference}(jsn.vObj['reference']);{q}
    if jsn.has('type') or jsn.has('_type') then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirObjectType);
    if jsn.has('role') or jsn.has('_role')  then
      result.roleElement := parseEnum(jsn['role'], jsn.vObj['_role'], CODES_TFhirObjectRole);
    if jsn.has('lifecycle') or jsn.has('_lifecycle')  then
      result.lifecycleElement := parseEnum(jsn['lifecycle'], jsn.vObj['_lifecycle'], CODES_TFhirObjectLifecycle);
    if jsn.has('sensitivity') then
        result.sensitivity := ParseCodeableConcept(jsn.vObj['sensitivity']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('query') or jsn.has('_query') then
        result.queryElement := ParseBase64Binary(jsn['query'], jsn.vObj['_query']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseAuditEventObjectDetail);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAuditEventObject(json : TJSONWriter; name : string; elem : TFhirAuditEventObject; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeReference{TFhirReference}(json, 'reference', elem.reference); {a}
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirObjectType, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirObjectType, false);
  ComposeEnumValue(json, 'role', elem.RoleElement, CODES_TFhirObjectRole, false);
  ComposeEnumProps(json, 'role', elem.RoleElement, CODES_TFhirObjectRole, false);
  ComposeEnumValue(json, 'lifecycle', elem.LifecycleElement, CODES_TFhirObjectLifecycle, false);
  ComposeEnumProps(json, 'lifecycle', elem.LifecycleElement, CODES_TFhirObjectLifecycle, false);
  ComposeCodeableConcept(json, 'sensitivity', elem.sensitivity); {a}
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeBase64BinaryValue(json, 'query', elem.queryElement, false);
  ComposeBase64BinaryProps(json, 'query', elem.queryElement, false);
  if elem.detailList.Count > 0 then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeAuditEventObjectDetail(json, '',elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseAuditEventObjectDetail(element : IXmlDomElement; path : string) : TFhirAuditEventObjectDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirAuditEventObjectDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseString(child, path+'/type') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseBase64Binary(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAuditEventObjectDetail(xml : TXmlBuilder; name : string; elem : TFhirAuditEventObjectDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'type', elem.type_Element);{x.2}
  ComposeBase64Binary(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAuditEventObjectDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventObjectDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventObjectDetail(jsn : TJsonObject) : TFhirAuditEventObjectDetail;
begin
  result := TFhirAuditEventObjectDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := ParseString(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseBase64Binary(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAuditEventObjectDetail(json : TJSONWriter; name : string; elem : TFhirAuditEventObjectDetail; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'type', elem.type_Element, false);
  ComposeStringProps(json, 'type', elem.type_Element, false);
  ComposeBase64BinaryValue(json, 'value', elem.valueElement, false);
  ComposeBase64BinaryProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseAuditEvent(element : IXmlDomElement; path : string) : TFhirAuditEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirAuditEvent.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'event') then
        result.event := ParseAuditEventEvent(child, path+'/event') {b}
      else if (child.baseName = 'participant') then
        result.participantList.Add(ParseAuditEventParticipant(child, path+'/participant')){y.2}
      else if (child.baseName = 'source') then
        result.source := ParseAuditEventSource(child, path+'/source') {b}
      else if (child.baseName = 'object') then
        result.object_List.Add(ParseAuditEventObject(child, path+'/object')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAuditEvent(xml : TXmlBuilder; name : string; elem : TFhirAuditEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeAuditEventEvent(xml, 'event', elem.event);{x.2}
  for i := 0 to elem.participantList.Count - 1 do
    ComposeAuditEventParticipant(xml, 'participant', elem.participantList[i]);
  ComposeAuditEventSource(xml, 'source', elem.source);{x.2}
  for i := 0 to elem.object_List.Count - 1 do
    ComposeAuditEventObject(xml, 'object', elem.object_List[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAuditEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEvent(jsn : TJsonObject) : TFhirAuditEvent;
begin
  result := TFhirAuditEvent.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('event') then
        result.event := ParseAuditEventEvent(jsn.vObj['event']);{q}
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseAuditEventParticipant);
    if jsn.has('source') then
        result.source := ParseAuditEventSource(jsn.vObj['source']);{q}
    if jsn.has('object') then
      iterateArray(jsn.vArr['object'], result.object_List, parseAuditEventObject);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAuditEvent(json : TJSONWriter; name : string; elem : TFhirAuditEvent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeAuditEventEvent(json, 'event', elem.event); {a}
  if elem.participantList.Count > 0 then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeAuditEventParticipant(json, '',elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  ComposeAuditEventSource(json, 'source', elem.source); {a}
  if elem.object_List.Count > 0 then
  begin
    json.valueArray('object');
    for i := 0 to elem.object_List.Count - 1 do
      ComposeAuditEventObject(json, '',elem.object_List[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseBasic(element : IXmlDomElement; path : string) : TFhirBasic;
var
  child : IXMLDOMElement;
begin
  result := TFhirBasic.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDate(child, path+'/created') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBasic(xml : TXmlBuilder; name : string; elem : TFhirBasic);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{Resource}(xml, 'author', elem.author);{x.2}
  ComposeDate(xml, 'created', elem.createdElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBasic(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBasic(jsn)); {2}
end;

function TFHIRJsonParser.ParseBasic(jsn : TJsonObject) : TFhirBasic;
begin
  result := TFhirBasic.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDate(jsn['created'], jsn.vObj['_created']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBasic(json : TJSONWriter; name : string; elem : TFhirBasic; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  ComposeReference{Resource}(json, 'author', elem.author); {a}
  ComposeDateValue(json, 'created', elem.createdElement, false);
  ComposeDateProps(json, 'created', elem.createdElement, false);
end;

function TFHIRXmlParser.ParseBinary(element : IXmlDomElement; path : string) : TFhirBinary;
var
  child : IXMLDOMElement;
begin
  result := TFhirBinary.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'contentType') then
        result.contentTypeElement := ParseCode(child, path+'/contentType') {b}
      else if (child.baseName = 'content') then
        result.contentElement := ParseBase64Binary(child, path+'/content') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBinary(xml : TXmlBuilder; name : string; elem : TFhirBinary);
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeCode(xml, 'contentType', elem.contentTypeElement);{x.2}
  ComposeBase64Binary(xml, 'content', elem.contentElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBinary(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBinary(jsn)); {2}
end;

function TFHIRJsonParser.ParseBinary(jsn : TJsonObject) : TFhirBinary;
begin
  result := TFhirBinary.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('contentType') or jsn.has('_contentType') then
        result.contentTypeElement := ParseCode(jsn['contentType'], jsn.vObj['_contentType']);{q}
    if jsn.has('content') or jsn.has('_content') then
        result.contentElement := ParseBase64Binary(jsn['content'], jsn.vObj['_content']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBinary(json : TJSONWriter; name : string; elem : TFhirBinary; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeCodeValue(json, 'contentType', elem.contentTypeElement, false);
  ComposeCodeProps(json, 'contentType', elem.contentTypeElement, false);
  ComposeBase64BinaryValue(json, 'content', elem.contentElement, false);
  ComposeBase64BinaryProps(json, 'content', elem.contentElement, false);
end;

function TFHIRXmlParser.ParseBodySite(element : IXmlDomElement; path : string) : TFhirBodySite;
var
  child : IXMLDOMElement;
begin
  result := TFhirBodySite.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'modifier') then
        result.modifierList.Add(ParseCodeableConcept(child, path+'/modifier')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'image') then
        result.imageList.Add(ParseAttachment(child, path+'/image')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBodySite(xml : TXmlBuilder; name : string; elem : TFhirBodySite);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  for i := 0 to elem.modifierList.Count - 1 do
    ComposeCodeableConcept(xml, 'modifier', elem.modifierList[i]);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  for i := 0 to elem.imageList.Count - 1 do
    ComposeAttachment(xml, 'image', elem.imageList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBodySite(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBodySite(jsn)); {2}
end;

function TFHIRJsonParser.ParseBodySite(jsn : TJsonObject) : TFhirBodySite;
begin
  result := TFhirBodySite.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('image') then
      iterateArray(jsn.vArr['image'], result.imageList, parseAttachment);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBodySite(json : TJSONWriter; name : string; elem : TFhirBodySite; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if elem.modifierList.Count > 0 then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.modifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if elem.imageList.Count > 0 then
  begin
    json.valueArray('image');
    for i := 0 to elem.imageList.Count - 1 do
      ComposeAttachment(json, '',elem.imageList[i]); {z - Attachment}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseBundleLink(element : IXmlDomElement; path : string) : TFhirBundleLink;
var
  child : IXMLDOMElement;
begin
  result := TFhirBundleLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'relation') then
        result.relationElement := ParseString(child, path+'/relation') {b}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBundleLink(xml : TXmlBuilder; name : string; elem : TFhirBundleLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'relation', elem.relationElement);{x.2}
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBundleLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleLink(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleLink(jsn : TJsonObject) : TFhirBundleLink;
begin
  result := TFhirBundleLink.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('relation') or jsn.has('_relation') then
        result.relationElement := ParseString(jsn['relation'], jsn.vObj['_relation']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBundleLink(json : TJSONWriter; name : string; elem : TFhirBundleLink; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'relation', elem.relationElement, false);
  ComposeStringProps(json, 'relation', elem.relationElement, false);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseBundleEntry(element : IXmlDomElement; path : string) : TFhirBundleEntry;
var
  child : IXMLDOMElement;
begin
  result := TFhirBundleEntry.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'base') then
        result.baseElement := ParseUri(child, path+'/base') {b}
      else if (child.baseName = 'link') then
        result.link_List.Add(ParseBundleLink(child, path+'/link')){y.2}
      else if (child.baseName = 'resource') then
        result.resource := ParseInnerResource(child, path+'/resource') {b}
      else if (child.baseName = 'search') then
        result.search := ParseBundleEntrySearch(child, path+'/search') {b}
      else if (child.baseName = 'transaction') then
        result.transaction := ParseBundleEntryTransaction(child, path+'/transaction') {b}
      else if (child.baseName = 'transactionResponse') then
        result.transactionResponse := ParseBundleEntryTransactionResponse(child, path+'/transactionResponse') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBundleEntry(xml : TXmlBuilder; name : string; elem : TFhirBundleEntry);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'base', elem.baseElement);{x.2}
  for i := 0 to elem.link_List.Count - 1 do
    ComposeBundleLink(xml, 'link', elem.link_List[i]);
  ComposeInnerResource(xml, 'resource', elem.resource);{x.2}
  ComposeBundleEntrySearch(xml, 'search', elem.search);{x.2}
  ComposeBundleEntryTransaction(xml, 'transaction', elem.transaction);{x.2}
  ComposeBundleEntryTransactionResponse(xml, 'transactionResponse', elem.transactionResponse);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBundleEntry(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleEntry(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleEntry(jsn : TJsonObject) : TFhirBundleEntry;
begin
  result := TFhirBundleEntry.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('base') or jsn.has('_base') then
        result.baseElement := ParseUri(jsn['base'], jsn.vObj['_base']);{q}
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parseBundleLink);
    if jsn.has('resource') then
        result.resource := ParseInnerResource(jsn.vObj['resource']);{q}
    if jsn.has('search') then
        result.search := ParseBundleEntrySearch(jsn.vObj['search']);{q}
    if jsn.has('transaction') then
        result.transaction := ParseBundleEntryTransaction(jsn.vObj['transaction']);{q}
    if jsn.has('transactionResponse') then
        result.transactionResponse := ParseBundleEntryTransactionResponse(jsn.vObj['transactionResponse']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBundleEntry(json : TJSONWriter; name : string; elem : TFhirBundleEntry; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'base', elem.baseElement, false);
  ComposeUriProps(json, 'base', elem.baseElement, false);
  if elem.link_List.Count > 0 then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(json, '',elem.link_List[i]); {z - @Bundle.link}
    json.FinishArray;
  end;
  ComposeInnerResource(json, 'resource', elem.resource); {a}
  ComposeBundleEntrySearch(json, 'search', elem.search); {a}
  ComposeBundleEntryTransaction(json, 'transaction', elem.transaction); {a}
  ComposeBundleEntryTransactionResponse(json, 'transactionResponse', elem.transactionResponse); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseBundleEntrySearch(element : IXmlDomElement; path : string) : TFhirBundleEntrySearch;
var
  child : IXMLDOMElement;
begin
  result := TFhirBundleEntrySearch.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'mode') then
        result.modeElement := ParseEnum(CODES_TFhirSearchEntryMode, path+'/mode', child){1a}
      else if (child.baseName = 'score') then
        result.scoreElement := ParseDecimal(child, path+'/score') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBundleEntrySearch(xml : TXmlBuilder; name : string; elem : TFhirBundleEntrySearch);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirSearchEntryMode);
  ComposeDecimal(xml, 'score', elem.scoreElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBundleEntrySearch(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleEntrySearch(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleEntrySearch(jsn : TJsonObject) : TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn['mode'], jsn.vObj['_mode'], CODES_TFhirSearchEntryMode);
    if jsn.has('score') or jsn.has('_score') then
        result.scoreElement := ParseDecimal(jsn['score'], jsn.vObj['_score']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBundleEntrySearch(json : TJSONWriter; name : string; elem : TFhirBundleEntrySearch; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirSearchEntryMode, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirSearchEntryMode, false);
  ComposeDecimalValue(json, 'score', elem.scoreElement, false);
  ComposeDecimalProps(json, 'score', elem.scoreElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseBundleEntryTransaction(element : IXmlDomElement; path : string) : TFhirBundleEntryTransaction;
var
  child : IXMLDOMElement;
begin
  result := TFhirBundleEntryTransaction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'method') then
        result.methodElement := ParseEnum(CODES_TFhirHttpVerb, path+'/method', child){1a}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'ifNoneMatch') then
        result.ifNoneMatchElement := ParseString(child, path+'/ifNoneMatch') {b}
      else if (child.baseName = 'ifMatch') then
        result.ifMatchElement := ParseString(child, path+'/ifMatch') {b}
      else if (child.baseName = 'ifModifiedSince') then
        result.ifModifiedSinceElement := ParseInstant(child, path+'/ifModifiedSince') {b}
      else if (child.baseName = 'ifNoneExist') then
        result.ifNoneExistElement := ParseString(child, path+'/ifNoneExist') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryTransaction(xml : TXmlBuilder; name : string; elem : TFhirBundleEntryTransaction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'method', elem.MethodElement, CODES_TFhirHttpVerb);
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  ComposeString(xml, 'ifNoneMatch', elem.ifNoneMatchElement);{x.2}
  ComposeString(xml, 'ifMatch', elem.ifMatchElement);{x.2}
  ComposeInstant(xml, 'ifModifiedSince', elem.ifModifiedSinceElement);{x.2}
  ComposeString(xml, 'ifNoneExist', elem.ifNoneExistElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBundleEntryTransaction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleEntryTransaction(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleEntryTransaction(jsn : TJsonObject) : TFhirBundleEntryTransaction;
begin
  result := TFhirBundleEntryTransaction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('method') or jsn.has('_method')  then
      result.methodElement := parseEnum(jsn['method'], jsn.vObj['_method'], CODES_TFhirHttpVerb);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('ifNoneMatch') or jsn.has('_ifNoneMatch') then
        result.ifNoneMatchElement := ParseString(jsn['ifNoneMatch'], jsn.vObj['_ifNoneMatch']);{q}
    if jsn.has('ifMatch') or jsn.has('_ifMatch') then
        result.ifMatchElement := ParseString(jsn['ifMatch'], jsn.vObj['_ifMatch']);{q}
    if jsn.has('ifModifiedSince') or jsn.has('_ifModifiedSince') then
        result.ifModifiedSinceElement := ParseInstant(jsn['ifModifiedSince'], jsn.vObj['_ifModifiedSince']);{q}
    if jsn.has('ifNoneExist') or jsn.has('_ifNoneExist') then
        result.ifNoneExistElement := ParseString(jsn['ifNoneExist'], jsn.vObj['_ifNoneExist']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBundleEntryTransaction(json : TJSONWriter; name : string; elem : TFhirBundleEntryTransaction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'method', elem.MethodElement, CODES_TFhirHttpVerb, false);
  ComposeEnumProps(json, 'method', elem.MethodElement, CODES_TFhirHttpVerb, false);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  ComposeStringValue(json, 'ifNoneMatch', elem.ifNoneMatchElement, false);
  ComposeStringProps(json, 'ifNoneMatch', elem.ifNoneMatchElement, false);
  ComposeStringValue(json, 'ifMatch', elem.ifMatchElement, false);
  ComposeStringProps(json, 'ifMatch', elem.ifMatchElement, false);
  ComposeInstantValue(json, 'ifModifiedSince', elem.ifModifiedSinceElement, false);
  ComposeInstantProps(json, 'ifModifiedSince', elem.ifModifiedSinceElement, false);
  ComposeStringValue(json, 'ifNoneExist', elem.ifNoneExistElement, false);
  ComposeStringProps(json, 'ifNoneExist', elem.ifNoneExistElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseBundleEntryTransactionResponse(element : IXmlDomElement; path : string) : TFhirBundleEntryTransactionResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirBundleEntryTransactionResponse.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.statusElement := ParseString(child, path+'/status') {b}
      else if (child.baseName = 'location') then
        result.locationElement := ParseUri(child, path+'/location') {b}
      else if (child.baseName = 'etag') then
        result.etagElement := ParseString(child, path+'/etag') {b}
      else if (child.baseName = 'lastModified') then
        result.lastModifiedElement := ParseInstant(child, path+'/lastModified') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryTransactionResponse(xml : TXmlBuilder; name : string; elem : TFhirBundleEntryTransactionResponse);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'status', elem.statusElement);{x.2}
  ComposeUri(xml, 'location', elem.locationElement);{x.2}
  ComposeString(xml, 'etag', elem.etagElement);{x.2}
  ComposeInstant(xml, 'lastModified', elem.lastModifiedElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBundleEntryTransactionResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleEntryTransactionResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleEntryTransactionResponse(jsn : TJsonObject) : TFhirBundleEntryTransactionResponse;
begin
  result := TFhirBundleEntryTransactionResponse.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status') then
        result.statusElement := ParseString(jsn['status'], jsn.vObj['_status']);{q}
    if jsn.has('location') or jsn.has('_location') then
        result.locationElement := ParseUri(jsn['location'], jsn.vObj['_location']);{q}
    if jsn.has('etag') or jsn.has('_etag') then
        result.etagElement := ParseString(jsn['etag'], jsn.vObj['_etag']);{q}
    if jsn.has('lastModified') or jsn.has('_lastModified') then
        result.lastModifiedElement := ParseInstant(jsn['lastModified'], jsn.vObj['_lastModified']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBundleEntryTransactionResponse(json : TJSONWriter; name : string; elem : TFhirBundleEntryTransactionResponse; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'status', elem.statusElement, false);
  ComposeStringProps(json, 'status', elem.statusElement, false);
  ComposeUriValue(json, 'location', elem.locationElement, false);
  ComposeUriProps(json, 'location', elem.locationElement, false);
  ComposeStringValue(json, 'etag', elem.etagElement, false);
  ComposeStringProps(json, 'etag', elem.etagElement, false);
  ComposeInstantValue(json, 'lastModified', elem.lastModifiedElement, false);
  ComposeInstantProps(json, 'lastModified', elem.lastModifiedElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseBundle(element : IXmlDomElement; path : string) : TFhirBundle;
var
  child : IXMLDOMElement;
begin
  result := TFhirBundle.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirBundleType, path+'/type', child){1a}
      else if (child.baseName = 'base') then
        result.baseElement := ParseUri(child, path+'/base') {b}
      else if (child.baseName = 'total') then
        result.totalElement := ParseUnsignedInt(child, path+'/total') {b}
      else if (child.baseName = 'link') then
        result.link_List.Add(ParseBundleLink(child, path+'/link')){y.2}
      else if (child.baseName = 'entry') then
        result.entryList.Add(ParseBundleEntry(child, path+'/entry')){y.2}
      else if (child.baseName = 'signature') then
        result.signatureElement := ParseBase64Binary(child, path+'/signature') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBundle(xml : TXmlBuilder; name : string; elem : TFhirBundle);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirBundleType);
  ComposeUri(xml, 'base', elem.baseElement);{x.2}
  ComposeUnsignedInt(xml, 'total', elem.totalElement);{x.2}
  for i := 0 to elem.link_List.Count - 1 do
    ComposeBundleLink(xml, 'link', elem.link_List[i]);
  for i := 0 to elem.entryList.Count - 1 do
    ComposeBundleEntry(xml, 'entry', elem.entryList[i]);
  ComposeBase64Binary(xml, 'signature', elem.signatureElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBundle(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundle(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundle(jsn : TJsonObject) : TFhirBundle;
begin
  result := TFhirBundle.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirBundleType);
    if jsn.has('base') or jsn.has('_base') then
        result.baseElement := ParseUri(jsn['base'], jsn.vObj['_base']);{q}
    if jsn.has('total') or jsn.has('_total') then
        result.totalElement := ParseUnsignedInt(jsn['total'], jsn.vObj['_total']);{q}
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parseBundleLink);
    if jsn.has('entry') then
      iterateArray(jsn.vArr['entry'], result.entryList, parseBundleEntry);
    if jsn.has('signature') or jsn.has('_signature') then
        result.signatureElement := ParseBase64Binary(jsn['signature'], jsn.vObj['_signature']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBundle(json : TJSONWriter; name : string; elem : TFhirBundle; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirBundleType, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirBundleType, false);
  ComposeUriValue(json, 'base', elem.baseElement, false);
  ComposeUriProps(json, 'base', elem.baseElement, false);
  ComposeUnsignedIntValue(json, 'total', elem.totalElement, false);
  ComposeUnsignedIntProps(json, 'total', elem.totalElement, false);
  if elem.link_List.Count > 0 then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(json, '',elem.link_List[i]); {z - }
    json.FinishArray;
  end;
  if elem.entryList.Count > 0 then
  begin
    json.valueArray('entry');
    for i := 0 to elem.entryList.Count - 1 do
      ComposeBundleEntry(json, '',elem.entryList[i]); {z - }
    json.FinishArray;
  end;
  ComposeBase64BinaryValue(json, 'signature', elem.signatureElement, false);
  ComposeBase64BinaryProps(json, 'signature', elem.signatureElement, false);
end;

function TFHIRXmlParser.ParseCarePlanParticipant(element : IXmlDomElement; path : string) : TFhirCarePlanParticipant;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlanParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'role') then
        result.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.baseName = 'member') then
        result.member := ParseReference{Resource}(child, path+'/member') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlanParticipant(xml : TXmlBuilder; name : string; elem : TFhirCarePlanParticipant);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'role', elem.role);{x.2}
  ComposeReference{Resource}(xml, 'member', elem.member);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlanParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseCarePlanParticipant(jsn : TJsonObject) : TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q}
    if jsn.has('member') then
        result.member := ParseReference{Resource}(jsn.vObj['member']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlanParticipant(json : TJSONWriter; name : string; elem : TFhirCarePlanParticipant; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'role', elem.role); {a}
  ComposeReference{Resource}(json, 'member', elem.member); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseCarePlanActivity(element : IXmlDomElement; path : string) : TFhirCarePlanActivity;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlanActivity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'actionResulting') then
        result.actionResultingList.Add(ParseReference{TFhirReference}(child, path+'/actionResulting')){y.2}
      else if (child.baseName = 'notes') then
        result.notesElement := ParseString(child, path+'/notes') {b}
      else if (child.baseName = 'reference') then
        result.reference := ParseReference{Resource}(child, path+'/reference') {b}
      else if (child.baseName = 'detail') then
        result.detail := ParseCarePlanActivityDetail(child, path+'/detail') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivity(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivity);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.actionResultingList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'actionResulting', elem.actionResultingList[i]);
  ComposeString(xml, 'notes', elem.notesElement);{x.2}
  ComposeReference{Resource}(xml, 'reference', elem.reference);{x.2}
  ComposeCarePlanActivityDetail(xml, 'detail', elem.detail);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlanActivity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanActivity(jsn)); {2}
end;

function TFHIRJsonParser.ParseCarePlanActivity(jsn : TJsonObject) : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('actionResulting') then
      iterateArray(jsn.vArr['actionResulting'], result.actionResultingList, parseReference{TFhirReference});
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesElement := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    if jsn.has('reference') then
        result.reference := ParseReference{Resource}(jsn.vObj['reference']);{q}
    if jsn.has('detail') then
        result.detail := ParseCarePlanActivityDetail(jsn.vObj['detail']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlanActivity(json : TJSONWriter; name : string; elem : TFhirCarePlanActivity; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.actionResultingList.Count > 0 then
  begin
    json.valueArray('actionResulting');
    for i := 0 to elem.actionResultingList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.actionResultingList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'notes', elem.notesElement, false);
  ComposeStringProps(json, 'notes', elem.notesElement, false);
  ComposeReference{Resource}(json, 'reference', elem.reference); {a}
  ComposeCarePlanActivityDetail(json, 'detail', elem.detail); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseCarePlanActivityDetail(element : IXmlDomElement; path : string) : TFhirCarePlanActivityDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlanActivityDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'category') then
        result.categoryElement := ParseEnum(CODES_TFhirCarePlanActivityCategory, path+'/category', child){1a}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'reasonCodeableConcept') then
        result.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.baseName = 'reasonReference') then
        result.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.baseName = 'goal') then
        result.goalList.Add(ParseReference{TFhirGoal}(child, path+'/goal')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirCarePlanActivityStatus, path+'/status', child){1a}
      else if (child.baseName = 'statusReason') then
        result.statusReason := ParseCodeableConcept(child, path+'/statusReason') {b}
      else if (child.baseName = 'prohibited') then
        result.prohibitedElement := ParseBoolean(child, path+'/prohibited') {b}
      else if (child.baseName = 'scheduledTiming') then
        result.scheduled := ParseTiming(child, path+'/scheduledTiming'){x.3}
      else if (child.baseName = 'scheduledPeriod') then
        result.scheduled := ParsePeriod(child, path+'/scheduledPeriod'){x.3}
      else if (child.baseName = 'scheduledString') then
        result.scheduled := ParseString(child, path+'/scheduledString'){x.3}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'performer') then
        result.performerList.Add(ParseReference{Resource}(child, path+'/performer')){y.2}
      else if (child.baseName = 'product') then
        result.product := ParseReference{Resource}(child, path+'/product') {b}
      else if (child.baseName = 'dailyAmount') then
        result.dailyAmount := ParseQuantity(child, path+'/dailyAmount') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'note') then
        result.noteElement := ParseString(child, path+'/note') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivityDetail(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivityDetail);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'category', elem.CategoryElement, CODES_TFhirCarePlanActivityCategory);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  for i := 0 to elem.goalList.Count - 1 do
    ComposeReference{TFhirGoal}(xml, 'goal', elem.goalList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCarePlanActivityStatus);
  ComposeCodeableConcept(xml, 'statusReason', elem.statusReason);{x.2}
  ComposeBoolean(xml, 'prohibited', elem.prohibitedElement);{x.2}
  if (elem.scheduled is TFhirTiming) {6} then
    ComposeTiming(xml, 'scheduledTiming', TFhirTiming(elem.scheduled))
  else if (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(xml, 'scheduledPeriod', TFhirPeriod(elem.scheduled))
  else if (elem.scheduled is TFhirString) {6} then
    ComposeString(xml, 'scheduledString', TFhirString(elem.scheduled));
  ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  for i := 0 to elem.performerList.Count - 1 do
    ComposeReference{Resource}(xml, 'performer', elem.performerList[i]);
  ComposeReference{Resource}(xml, 'product', elem.product);{x.2}
  ComposeQuantity(xml, 'dailyAmount', elem.dailyAmount);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeString(xml, 'note', elem.noteElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlanActivityDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanActivityDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseCarePlanActivityDetail(jsn : TJsonObject) : TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('category') or jsn.has('_category')  then
      result.categoryElement := parseEnum(jsn['category'], jsn.vObj['_category'], CODES_TFhirCarePlanActivityCategory);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('goal') then
      iterateArray(jsn.vArr['goal'], result.goalList, parseReference{TFhirGoal});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirCarePlanActivityStatus);
    if jsn.has('statusReason') then
        result.statusReason := ParseCodeableConcept(jsn.vObj['statusReason']);{q}
    if jsn.has('prohibited') or jsn.has('_prohibited') then
        result.prohibitedElement := ParseBoolean(jsn['prohibited'], jsn.vObj['_prohibited']);{q}
    if jsn.has('scheduledTiming') {a4} then
      result.scheduled := ParseTiming(jsn.vObj['scheduledTiming']);
    if jsn.has('scheduledPeriod') {a4} then
      result.scheduled := ParsePeriod(jsn.vObj['scheduledPeriod']);
    if jsn.has('scheduledString') or jsn.has('_scheduledString') then
      result.scheduled := parseString(jsn['scheduledString'], jsn.vObj['_scheduledString']);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseReference{Resource});
    if jsn.has('product') then
        result.product := ParseReference{Resource}(jsn.vObj['product']);{q}
    if jsn.has('dailyAmount') then
        result.dailyAmount := ParseQuantity(jsn.vObj['dailyAmount']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlanActivityDetail(json : TJSONWriter; name : string; elem : TFhirCarePlanActivityDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'category', elem.CategoryElement, CODES_TFhirCarePlanActivityCategory, false);
  ComposeEnumProps(json, 'category', elem.CategoryElement, CODES_TFhirCarePlanActivityCategory, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  if elem.goalList.Count > 0 then
  begin
    json.valueArray('goal');
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(json, '',elem.goalList[i]); {z - Reference(Goal)}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCarePlanActivityStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCarePlanActivityStatus, false);
  ComposeCodeableConcept(json, 'statusReason', elem.statusReason); {a}
  ComposeBooleanValue(json, 'prohibited', elem.prohibitedElement, false);
  ComposeBooleanProps(json, 'prohibited', elem.prohibitedElement, false);
  if (elem.scheduled is TFhirTiming) then 
    ComposeTiming(json, 'scheduledTiming', TFhirTiming(elem.scheduled)) 
  else if (elem.scheduled is TFhirPeriod) then 
    ComposePeriod(json, 'scheduledPeriod', TFhirPeriod(elem.scheduled)) 
  else if (elem.scheduled is TFhirString) then 
  begin
    ComposeStringValue(json, 'scheduledString', TFhirString(elem.scheduled), false);
    ComposeStringProps(json, 'scheduledString', TFhirString(elem.scheduled), false);
  end;
  ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if elem.performerList.Count > 0 then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.performerList[i]); {z - Reference(Practitioner|Organization|RelatedPerson|Patient)}
    json.FinishArray;
  end;
  ComposeReference{Resource}(json, 'product', elem.product); {a}
  ComposeQuantity(json, 'dailyAmount', elem.dailyAmount); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeStringValue(json, 'note', elem.noteElement, false);
  ComposeStringProps(json, 'note', elem.noteElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseCarePlan(element : IXmlDomElement; path : string) : TFhirCarePlan;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlan.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirCarePlanStatus, path+'/status', child){1a}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'author') then
        result.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.baseName = 'modified') then
        result.modifiedElement := ParseDateTime(child, path+'/modified') {b}
      else if (child.baseName = 'category') then
        result.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.baseName = 'concern') then
        result.concernList.Add(ParseReference{TFhirCondition}(child, path+'/concern')){y.2}
      else if (child.baseName = 'support') then
        result.supportList.Add(ParseReference{TFhirReference}(child, path+'/support')){y.2}
      else if (child.baseName = 'participant') then
        result.participantList.Add(ParseCarePlanParticipant(child, path+'/participant')){y.2}
      else if (child.baseName = 'goal') then
        result.goalList.Add(ParseReference{TFhirGoal}(child, path+'/goal')){y.2}
      else if (child.baseName = 'activity') then
        result.activityList.Add(ParseCarePlanActivity(child, path+'/activity')){y.2}
      else if (child.baseName = 'notes') then
        result.notesElement := ParseString(child, path+'/notes') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlan(xml : TXmlBuilder; name : string; elem : TFhirCarePlan);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCarePlanStatus);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  for i := 0 to elem.authorList.Count - 1 do
    ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  ComposeDateTime(xml, 'modified', elem.modifiedElement);{x.2}
  for i := 0 to elem.categoryList.Count - 1 do
    ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  for i := 0 to elem.concernList.Count - 1 do
    ComposeReference{TFhirCondition}(xml, 'concern', elem.concernList[i]);
  for i := 0 to elem.supportList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'support', elem.supportList[i]);
  for i := 0 to elem.participantList.Count - 1 do
    ComposeCarePlanParticipant(xml, 'participant', elem.participantList[i]);
  for i := 0 to elem.goalList.Count - 1 do
    ComposeReference{TFhirGoal}(xml, 'goal', elem.goalList[i]);
  for i := 0 to elem.activityList.Count - 1 do
    ComposeCarePlanActivity(xml, 'activity', elem.activityList[i]);
  ComposeString(xml, 'notes', elem.notesElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlan(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlan(jsn)); {2}
end;

function TFHIRJsonParser.ParseCarePlan(jsn : TJsonObject) : TFhirCarePlan;
begin
  result := TFhirCarePlan.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirCarePlanStatus);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{Resource});
    if jsn.has('modified') or jsn.has('_modified') then
        result.modifiedElement := ParseDateTime(jsn['modified'], jsn.vObj['_modified']);{q}
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('concern') then
      iterateArray(jsn.vArr['concern'], result.concernList, parseReference{TFhirCondition});
    if jsn.has('support') then
      iterateArray(jsn.vArr['support'], result.supportList, parseReference{TFhirReference});
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseCarePlanParticipant);
    if jsn.has('goal') then
      iterateArray(jsn.vArr['goal'], result.goalList, parseReference{TFhirGoal});
    if jsn.has('activity') then
      iterateArray(jsn.vArr['activity'], result.activityList, parseCarePlanActivity);
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesElement := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlan(json : TJSONWriter; name : string; elem : TFhirCarePlan; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCarePlanStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCarePlanStatus, false);
  ComposePeriod(json, 'period', elem.period); {a}
  if elem.authorList.Count > 0 then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.authorList[i]); {z - Reference(Patient|Practitioner|RelatedPerson|Organization)}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'modified', elem.modifiedElement, false);
  ComposeDateTimeProps(json, 'modified', elem.modifiedElement, false);
  if elem.categoryList.Count > 0 then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.concernList.Count > 0 then
  begin
    json.valueArray('concern');
  for i := 0 to elem.concernList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '',elem.concernList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if elem.supportList.Count > 0 then
  begin
    json.valueArray('support');
    for i := 0 to elem.supportList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.supportList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if elem.participantList.Count > 0 then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeCarePlanParticipant(json, '',elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  if elem.goalList.Count > 0 then
  begin
    json.valueArray('goal');
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(json, '',elem.goalList[i]); {z - Reference(Goal)}
    json.FinishArray;
  end;
  if elem.activityList.Count > 0 then
  begin
    json.valueArray('activity');
    for i := 0 to elem.activityList.Count - 1 do
      ComposeCarePlanActivity(json, '',elem.activityList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'notes', elem.notesElement, false);
  ComposeStringProps(json, 'notes', elem.notesElement, false);
end;

function TFHIRXmlParser.ParseClaimPayee(element : IXmlDomElement; path : string) : TFhirClaimPayee;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimPayee.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'provider') then
        result.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'person') then
        result.person := ParseReference{TFhirPatient}(child, path+'/person') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimPayee(xml : TXmlBuilder; name : string; elem : TFhirClaimPayee);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'type', elem.type_);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  ComposeReference{TFhirPatient}(xml, 'person', elem.person);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimPayee(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimPayee(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimPayee(jsn : TJsonObject) : TFhirClaimPayee;
begin
  result := TFhirClaimPayee.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('person') then
        result.person := ParseReference{TFhirPatient}(jsn.vObj['person']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimPayee(json : TJSONWriter; name : string; elem : TFhirClaimPayee; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  ComposeReference{TFhirPatient}(json, 'person', elem.person); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimDiagnosis(element : IXmlDomElement; path : string) : TFhirClaimDiagnosis;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimDiagnosis.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequence') then
        result.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.baseName = 'diagnosis') then
        result.diagnosis := ParseCoding(child, path+'/diagnosis') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimDiagnosis(xml : TXmlBuilder; name : string; elem : TFhirClaimDiagnosis);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2}
  ComposeCoding(xml, 'diagnosis', elem.diagnosis);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimDiagnosis(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimDiagnosis(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimDiagnosis(jsn : TJsonObject) : TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('diagnosis') then
        result.diagnosis := ParseCoding(jsn.vObj['diagnosis']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimDiagnosis(json : TJSONWriter; name : string; elem : TFhirClaimDiagnosis; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeCoding(json, 'diagnosis', elem.diagnosis); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimCoverage(element : IXmlDomElement; path : string) : TFhirClaimCoverage;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimCoverage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequence') then
        result.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.baseName = 'focal') then
        result.focalElement := ParseBoolean(child, path+'/focal') {b}
      else if (child.baseName = 'coverage') then
        result.coverage := ParseReference{TFhirCoverage}(child, path+'/coverage') {b}
      else if (child.baseName = 'businessArrangement') then
        result.businessArrangementElement := ParseString(child, path+'/businessArrangement') {b}
      else if (child.baseName = 'relationship') then
        result.relationship := ParseCoding(child, path+'/relationship') {b}
      else if (child.baseName = 'preAuthRef') then
        result.preAuthRefList.Add(ParseString(child, path+'/preAuthRef')){y.2}
      else if (child.baseName = 'claimResponse') then
        result.claimResponse := ParseReference{TFhirClaimResponse}(child, path+'/claimResponse') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimCoverage(xml : TXmlBuilder; name : string; elem : TFhirClaimCoverage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2}
  ComposeBoolean(xml, 'focal', elem.focalElement);{x.2}
  ComposeReference{TFhirCoverage}(xml, 'coverage', elem.coverage);{x.2}
  ComposeString(xml, 'businessArrangement', elem.businessArrangementElement);{x.2}
  ComposeCoding(xml, 'relationship', elem.relationship);{x.2}
  for i := 0 to elem.preAuthRefList.Count - 1 do
    ComposeString(xml, 'preAuthRef', elem.preAuthRefList[i]);
  ComposeReference{TFhirClaimResponse}(xml, 'claimResponse', elem.claimResponse);{x.2}
  ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimCoverage(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimCoverage(jsn : TJsonObject) : TFhirClaimCoverage;
begin
  result := TFhirClaimCoverage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('focal') or jsn.has('_focal') then
        result.focalElement := ParseBoolean(jsn['focal'], jsn.vObj['_focal']);{q}
    if jsn.has('coverage') then
        result.coverage := ParseReference{TFhirCoverage}(jsn.vObj['coverage']);{q}
    if jsn.has('businessArrangement') or jsn.has('_businessArrangement') then
        result.businessArrangementElement := ParseString(jsn['businessArrangement'], jsn.vObj['_businessArrangement']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCoding(jsn.vObj['relationship']);{q}
      if jsn.has('preAuthRef') or jsn.has('_preAuthRef') then
      iteratePrimitiveArray(jsn.vArr['preAuthRef'], jsn.vArr['_preAuthRef'], result.preAuthRefList, parseString);
    if jsn.has('claimResponse') then
        result.claimResponse := ParseReference{TFhirClaimResponse}(jsn.vObj['claimResponse']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimCoverage(json : TJSONWriter; name : string; elem : TFhirClaimCoverage; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeBooleanValue(json, 'focal', elem.focalElement, false);
  ComposeBooleanProps(json, 'focal', elem.focalElement, false);
  ComposeReference{TFhirCoverage}(json, 'coverage', elem.coverage); {a}
  ComposeStringValue(json, 'businessArrangement', elem.businessArrangementElement, false);
  ComposeStringProps(json, 'businessArrangement', elem.businessArrangementElement, false);
  ComposeCoding(json, 'relationship', elem.relationship); {a}
  if elem.preAuthRefList.Count > 0 then
  begin
    json.valueArray('preAuthRef');
    ext := false;
    for i := 0 to elem.preAuthRefList.Count - 1 do
  begin
      ext := ext or ((elem.preAuthRefList[i].id <> '') or (elem.preAuthRefList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.preAuthRefList[i], true);
    end;
    json.FinishArray;
    if ext then
  begin
      json.valueArray('_preAuthRef');
      for i := 0 to elem.preAuthRefList.Count - 1 do
        ComposeStringProps(json, '',elem.preAuthRefList[i], true);
    json.FinishArray;
  end;
  end;
  ComposeReference{TFhirClaimResponse}(json, 'claimResponse', elem.claimResponse); {a}
  ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimItem(element : IXmlDomElement; path : string) : TFhirClaimItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequence') then
        result.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'provider') then
        result.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.baseName = 'diagnosisLinkId') then
        result.diagnosisLinkIdList.Add(ParsePositiveInt(child, path+'/diagnosisLinkId')){y.2}
      else if (child.baseName = 'service') then
        result.service := ParseCoding(child, path+'/service') {b}
      else if (child.baseName = 'serviceDate') then
        result.serviceDateElement := ParseDate(child, path+'/serviceDate') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'unitPrice') then
        result.unitPrice := ParseQuantity(child, path+'/unitPrice') {b}
      else if (child.baseName = 'factor') then
        result.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.baseName = 'points') then
        result.pointsElement := ParseDecimal(child, path+'/points') {b}
      else if (child.baseName = 'net') then
        result.net := ParseQuantity(child, path+'/net') {b}
      else if (child.baseName = 'udi') then
        result.udi := ParseCoding(child, path+'/udi') {b}
      else if (child.baseName = 'bodySite') then
        result.bodySite := ParseCoding(child, path+'/bodySite') {b}
      else if (child.baseName = 'subSite') then
        result.subSiteList.Add(ParseCoding(child, path+'/subSite')){y.2}
      else if (child.baseName = 'modifier') then
        result.modifierList.Add(ParseCoding(child, path+'/modifier')){y.2}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseClaimItemDetail(child, path+'/detail')){y.2}
      else if (child.baseName = 'prosthesis') then
        result.prosthesis := ParseClaimItemProsthesis(child, path+'/prosthesis') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimItem(xml : TXmlBuilder; name : string; elem : TFhirClaimItem);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2}
  ComposeCoding(xml, 'type', elem.type_);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2}
  for i := 0 to elem.diagnosisLinkIdList.Count - 1 do
    ComposePositiveInt(xml, 'diagnosisLinkId', elem.diagnosisLinkIdList[i]);
  ComposeCoding(xml, 'service', elem.service);{x.2}
  ComposeDate(xml, 'serviceDate', elem.serviceDateElement);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeQuantity(xml, 'unitPrice', elem.unitPrice);{x.2}
  ComposeDecimal(xml, 'factor', elem.factorElement);{x.2}
  ComposeDecimal(xml, 'points', elem.pointsElement);{x.2}
  ComposeQuantity(xml, 'net', elem.net);{x.2}
  ComposeCoding(xml, 'udi', elem.udi);{x.2}
  ComposeCoding(xml, 'bodySite', elem.bodySite);{x.2}
  for i := 0 to elem.subSiteList.Count - 1 do
    ComposeCoding(xml, 'subSite', elem.subSiteList[i]);
  for i := 0 to elem.modifierList.Count - 1 do
    ComposeCoding(xml, 'modifier', elem.modifierList[i]);
  for i := 0 to elem.detailList.Count - 1 do
    ComposeClaimItemDetail(xml, 'detail', elem.detailList[i]);
  ComposeClaimItemProsthesis(xml, 'prosthesis', elem.prosthesis);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimItem(jsn : TJsonObject) : TFhirClaimItem;
begin
  result := TFhirClaimItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q}
      if jsn.has('diagnosisLinkId') or jsn.has('_diagnosisLinkId') then
      iteratePrimitiveArray(jsn.vArr['diagnosisLinkId'], jsn.vArr['_diagnosisLinkId'], result.diagnosisLinkIdList, parsePositiveInt);
    if jsn.has('service') then
        result.service := ParseCoding(jsn.vObj['service']);{q}
    if jsn.has('serviceDate') or jsn.has('_serviceDate') then
        result.serviceDateElement := ParseDate(jsn['serviceDate'], jsn.vObj['_serviceDate']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseQuantity(jsn.vObj['unitPrice']);{q}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('points') or jsn.has('_points') then
        result.pointsElement := ParseDecimal(jsn['points'], jsn.vObj['_points']);{q}
    if jsn.has('net') then
        result.net := ParseQuantity(jsn.vObj['net']);{q}
    if jsn.has('udi') then
        result.udi := ParseCoding(jsn.vObj['udi']);{q}
    if jsn.has('bodySite') then
        result.bodySite := ParseCoding(jsn.vObj['bodySite']);{q}
    if jsn.has('subSite') then
      iterateArray(jsn.vArr['subSite'], result.subSiteList, parseCoding);
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCoding);
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseClaimItemDetail);
    if jsn.has('prosthesis') then
        result.prosthesis := ParseClaimItemProsthesis(jsn.vObj['prosthesis']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimItem(json : TJSONWriter; name : string; elem : TFhirClaimItem; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if elem.diagnosisLinkIdList.Count > 0 then
  begin
    json.valueArray('diagnosisLinkId');
    ext := false;
    for i := 0 to elem.diagnosisLinkIdList.Count - 1 do
    begin
      ext := ext or ((elem.diagnosisLinkIdList[i].id <> '') or (elem.diagnosisLinkIdList[i].hasExtensionList));
      ComposePositiveIntValue(json, '',elem.diagnosisLinkIdList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_diagnosisLinkId');
      for i := 0 to elem.diagnosisLinkIdList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.diagnosisLinkIdList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeCoding(json, 'service', elem.service); {a}
  ComposeDateValue(json, 'serviceDate', elem.serviceDateElement, false);
  ComposeDateProps(json, 'serviceDate', elem.serviceDateElement, false);
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeQuantity(json, 'unitPrice', elem.unitPrice); {a}
  ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  ComposeDecimalValue(json, 'points', elem.pointsElement, false);
  ComposeDecimalProps(json, 'points', elem.pointsElement, false);
  ComposeQuantity(json, 'net', elem.net); {a}
  ComposeCoding(json, 'udi', elem.udi); {a}
  ComposeCoding(json, 'bodySite', elem.bodySite); {a}
  if elem.subSiteList.Count > 0 then
  begin
    json.valueArray('subSite');
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCoding(json, '',elem.subSiteList[i]); {z - Coding}
    json.FinishArray;
  end;
  if elem.modifierList.Count > 0 then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCoding(json, '',elem.modifierList[i]); {z - Coding}
    json.FinishArray;
  end;
  if elem.detailList.Count > 0 then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimItemDetail(json, '',elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  ComposeClaimItemProsthesis(json, 'prosthesis', elem.prosthesis); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimItemDetail(element : IXmlDomElement; path : string) : TFhirClaimItemDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimItemDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequence') then
        result.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'service') then
        result.service := ParseCoding(child, path+'/service') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'unitPrice') then
        result.unitPrice := ParseQuantity(child, path+'/unitPrice') {b}
      else if (child.baseName = 'factor') then
        result.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.baseName = 'points') then
        result.pointsElement := ParseDecimal(child, path+'/points') {b}
      else if (child.baseName = 'net') then
        result.net := ParseQuantity(child, path+'/net') {b}
      else if (child.baseName = 'udi') then
        result.udi := ParseCoding(child, path+'/udi') {b}
      else if (child.baseName = 'subDetail') then
        result.subDetailList.Add(ParseClaimItemDetailSubDetail(child, path+'/subDetail')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimItemDetail);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2}
  ComposeCoding(xml, 'type', elem.type_);{x.2}
  ComposeCoding(xml, 'service', elem.service);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeQuantity(xml, 'unitPrice', elem.unitPrice);{x.2}
  ComposeDecimal(xml, 'factor', elem.factorElement);{x.2}
  ComposeDecimal(xml, 'points', elem.pointsElement);{x.2}
  ComposeQuantity(xml, 'net', elem.net);{x.2}
  ComposeCoding(xml, 'udi', elem.udi);{x.2}
  for i := 0 to elem.subDetailList.Count - 1 do
    ComposeClaimItemDetailSubDetail(xml, 'subDetail', elem.subDetailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimItemDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimItemDetail(jsn : TJsonObject) : TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('service') then
        result.service := ParseCoding(jsn.vObj['service']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseQuantity(jsn.vObj['unitPrice']);{q}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('points') or jsn.has('_points') then
        result.pointsElement := ParseDecimal(jsn['points'], jsn.vObj['_points']);{q}
    if jsn.has('net') then
        result.net := ParseQuantity(jsn.vObj['net']);{q}
    if jsn.has('udi') then
        result.udi := ParseCoding(jsn.vObj['udi']);{q}
    if jsn.has('subDetail') then
      iterateArray(jsn.vArr['subDetail'], result.subDetailList, parseClaimItemDetailSubDetail);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimItemDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeCoding(json, 'service', elem.service); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeQuantity(json, 'unitPrice', elem.unitPrice); {a}
  ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  ComposeDecimalValue(json, 'points', elem.pointsElement, false);
  ComposeDecimalProps(json, 'points', elem.pointsElement, false);
  ComposeQuantity(json, 'net', elem.net); {a}
  ComposeCoding(json, 'udi', elem.udi); {a}
  if elem.subDetailList.Count > 0 then
  begin
    json.valueArray('subDetail');
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimItemDetailSubDetail(json, '',elem.subDetailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimItemDetailSubDetail(element : IXmlDomElement; path : string) : TFhirClaimItemDetailSubDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequence') then
        result.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'service') then
        result.service := ParseCoding(child, path+'/service') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'unitPrice') then
        result.unitPrice := ParseQuantity(child, path+'/unitPrice') {b}
      else if (child.baseName = 'factor') then
        result.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.baseName = 'points') then
        result.pointsElement := ParseDecimal(child, path+'/points') {b}
      else if (child.baseName = 'net') then
        result.net := ParseQuantity(child, path+'/net') {b}
      else if (child.baseName = 'udi') then
        result.udi := ParseCoding(child, path+'/udi') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimItemDetailSubDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimItemDetailSubDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2}
  ComposeCoding(xml, 'type', elem.type_);{x.2}
  ComposeCoding(xml, 'service', elem.service);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeQuantity(xml, 'unitPrice', elem.unitPrice);{x.2}
  ComposeDecimal(xml, 'factor', elem.factorElement);{x.2}
  ComposeDecimal(xml, 'points', elem.pointsElement);{x.2}
  ComposeQuantity(xml, 'net', elem.net);{x.2}
  ComposeCoding(xml, 'udi', elem.udi);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimItemDetailSubDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('service') then
        result.service := ParseCoding(jsn.vObj['service']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseQuantity(jsn.vObj['unitPrice']);{q}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('points') or jsn.has('_points') then
        result.pointsElement := ParseDecimal(jsn['points'], jsn.vObj['_points']);{q}
    if jsn.has('net') then
        result.net := ParseQuantity(jsn.vObj['net']);{q}
    if jsn.has('udi') then
        result.udi := ParseCoding(jsn.vObj['udi']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimItemDetailSubDetail; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeCoding(json, 'service', elem.service); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeQuantity(json, 'unitPrice', elem.unitPrice); {a}
  ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  ComposeDecimalValue(json, 'points', elem.pointsElement, false);
  ComposeDecimalProps(json, 'points', elem.pointsElement, false);
  ComposeQuantity(json, 'net', elem.net); {a}
  ComposeCoding(json, 'udi', elem.udi); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimItemProsthesis(element : IXmlDomElement; path : string) : TFhirClaimItemProsthesis;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimItemProsthesis.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'initial') then
        result.initialElement := ParseBoolean(child, path+'/initial') {b}
      else if (child.baseName = 'priorDate') then
        result.priorDateElement := ParseDate(child, path+'/priorDate') {b}
      else if (child.baseName = 'priorMaterial') then
        result.priorMaterial := ParseCoding(child, path+'/priorMaterial') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimItemProsthesis(xml : TXmlBuilder; name : string; elem : TFhirClaimItemProsthesis);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeBoolean(xml, 'initial', elem.initialElement);{x.2}
  ComposeDate(xml, 'priorDate', elem.priorDateElement);{x.2}
  ComposeCoding(xml, 'priorMaterial', elem.priorMaterial);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimItemProsthesis(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimItemProsthesis(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimItemProsthesis(jsn : TJsonObject) : TFhirClaimItemProsthesis;
begin
  result := TFhirClaimItemProsthesis.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('initial') or jsn.has('_initial') then
        result.initialElement := ParseBoolean(jsn['initial'], jsn.vObj['_initial']);{q}
    if jsn.has('priorDate') or jsn.has('_priorDate') then
        result.priorDateElement := ParseDate(jsn['priorDate'], jsn.vObj['_priorDate']);{q}
    if jsn.has('priorMaterial') then
        result.priorMaterial := ParseCoding(jsn.vObj['priorMaterial']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimItemProsthesis(json : TJSONWriter; name : string; elem : TFhirClaimItemProsthesis; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeBooleanValue(json, 'initial', elem.initialElement, false);
  ComposeBooleanProps(json, 'initial', elem.initialElement, false);
  ComposeDateValue(json, 'priorDate', elem.priorDateElement, false);
  ComposeDateProps(json, 'priorDate', elem.priorDateElement, false);
  ComposeCoding(json, 'priorMaterial', elem.priorMaterial); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimMissingTeeth(element : IXmlDomElement; path : string) : TFhirClaimMissingTeeth;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimMissingTeeth.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'tooth') then
        result.tooth := ParseCoding(child, path+'/tooth') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCoding(child, path+'/reason') {b}
      else if (child.baseName = 'extractionDate') then
        result.extractionDateElement := ParseDate(child, path+'/extractionDate') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimMissingTeeth(xml : TXmlBuilder; name : string; elem : TFhirClaimMissingTeeth);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'tooth', elem.tooth);{x.2}
  ComposeCoding(xml, 'reason', elem.reason);{x.2}
  ComposeDate(xml, 'extractionDate', elem.extractionDateElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimMissingTeeth(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimMissingTeeth(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimMissingTeeth(jsn : TJsonObject) : TFhirClaimMissingTeeth;
begin
  result := TFhirClaimMissingTeeth.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('tooth') then
        result.tooth := ParseCoding(jsn.vObj['tooth']);{q}
    if jsn.has('reason') then
        result.reason := ParseCoding(jsn.vObj['reason']);{q}
    if jsn.has('extractionDate') or jsn.has('_extractionDate') then
        result.extractionDateElement := ParseDate(jsn['extractionDate'], jsn.vObj['_extractionDate']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimMissingTeeth(json : TJSONWriter; name : string; elem : TFhirClaimMissingTeeth; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'tooth', elem.tooth); {a}
  ComposeCoding(json, 'reason', elem.reason); {a}
  ComposeDateValue(json, 'extractionDate', elem.extractionDateElement, false);
  ComposeDateProps(json, 'extractionDate', elem.extractionDateElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaim(element : IXmlDomElement; path : string) : TFhirClaim;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaim.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirTypeLink, path+'/type', child){1a}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirOrganization}(child, path+'/target') {b}
      else if (child.baseName = 'provider') then
        result.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'use') then
        result.useElement := ParseEnum(CODES_TFhirUseLink, path+'/use', child){1a}
      else if (child.baseName = 'priority') then
        result.priority := ParseCoding(child, path+'/priority') {b}
      else if (child.baseName = 'fundsReserve') then
        result.fundsReserve := ParseCoding(child, path+'/fundsReserve') {b}
      else if (child.baseName = 'enterer') then
        result.enterer := ParseReference{TFhirPractitioner}(child, path+'/enterer') {b}
      else if (child.baseName = 'facility') then
        result.facility := ParseReference{TFhirLocation}(child, path+'/facility') {b}
      else if (child.baseName = 'prescription') then
        result.prescription := ParseReference{Resource}(child, path+'/prescription') {b}
      else if (child.baseName = 'originalPrescription') then
        result.originalPrescription := ParseReference{TFhirMedicationPrescription}(child, path+'/originalPrescription') {b}
      else if (child.baseName = 'payee') then
        result.payee := ParseClaimPayee(child, path+'/payee') {b}
      else if (child.baseName = 'referral') then
        result.referral := ParseReference{TFhirReferralRequest}(child, path+'/referral') {b}
      else if (child.baseName = 'diagnosis') then
        result.diagnosisList.Add(ParseClaimDiagnosis(child, path+'/diagnosis')){y.2}
      else if (child.baseName = 'condition') then
        result.conditionList.Add(ParseCoding(child, path+'/condition')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'coverage') then
        result.coverageList.Add(ParseClaimCoverage(child, path+'/coverage')){y.2}
      else if (child.baseName = 'exception') then
        result.exceptionList.Add(ParseCoding(child, path+'/exception')){y.2}
      else if (child.baseName = 'school') then
        result.schoolElement := ParseString(child, path+'/school') {b}
      else if (child.baseName = 'accident') then
        result.accidentElement := ParseDate(child, path+'/accident') {b}
      else if (child.baseName = 'accidentType') then
        result.accidentType := ParseCoding(child, path+'/accidentType') {b}
      else if (child.baseName = 'interventionException') then
        result.interventionExceptionList.Add(ParseCoding(child, path+'/interventionException')){y.2}
      else if (child.baseName = 'item') then
        result.itemList.Add(ParseClaimItem(child, path+'/item')){y.2}
      else if (child.baseName = 'additionalMaterials') then
        result.additionalMaterialsList.Add(ParseCoding(child, path+'/additionalMaterials')){y.2}
      else if (child.baseName = 'missingTeeth') then
        result.missingTeethList.Add(ParseClaimMissingTeeth(child, path+'/missingTeeth')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaim(xml : TXmlBuilder; name : string; elem : TFhirClaim);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirTypeLink);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'target', elem.target);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirUseLink);
  ComposeCoding(xml, 'priority', elem.priority);{x.2}
  ComposeCoding(xml, 'fundsReserve', elem.fundsReserve);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'enterer', elem.enterer);{x.2}
  ComposeReference{TFhirLocation}(xml, 'facility', elem.facility);{x.2}
  ComposeReference{Resource}(xml, 'prescription', elem.prescription);{x.2}
  ComposeReference{TFhirMedicationPrescription}(xml, 'originalPrescription', elem.originalPrescription);{x.2}
  ComposeClaimPayee(xml, 'payee', elem.payee);{x.2}
  ComposeReference{TFhirReferralRequest}(xml, 'referral', elem.referral);{x.2}
  for i := 0 to elem.diagnosisList.Count - 1 do
    ComposeClaimDiagnosis(xml, 'diagnosis', elem.diagnosisList[i]);
  for i := 0 to elem.conditionList.Count - 1 do
    ComposeCoding(xml, 'condition', elem.conditionList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  for i := 0 to elem.coverageList.Count - 1 do
    ComposeClaimCoverage(xml, 'coverage', elem.coverageList[i]);
  for i := 0 to elem.exceptionList.Count - 1 do
    ComposeCoding(xml, 'exception', elem.exceptionList[i]);
  ComposeString(xml, 'school', elem.schoolElement);{x.2}
  ComposeDate(xml, 'accident', elem.accidentElement);{x.2}
  ComposeCoding(xml, 'accidentType', elem.accidentType);{x.2}
  for i := 0 to elem.interventionExceptionList.Count - 1 do
    ComposeCoding(xml, 'interventionException', elem.interventionExceptionList[i]);
  for i := 0 to elem.itemList.Count - 1 do
    ComposeClaimItem(xml, 'item', elem.itemList[i]);
  for i := 0 to elem.additionalMaterialsList.Count - 1 do
    ComposeCoding(xml, 'additionalMaterials', elem.additionalMaterialsList[i]);
  for i := 0 to elem.missingTeethList.Count - 1 do
    ComposeClaimMissingTeeth(xml, 'missingTeeth', elem.missingTeethList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaim(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaim(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaim(jsn : TJsonObject) : TFhirClaim;
begin
  result := TFhirClaim.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirTypeLink);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirOrganization}(jsn.vObj['target']);{q}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn['use'], jsn.vObj['_use'], CODES_TFhirUseLink);
    if jsn.has('priority') then
        result.priority := ParseCoding(jsn.vObj['priority']);{q}
    if jsn.has('fundsReserve') then
        result.fundsReserve := ParseCoding(jsn.vObj['fundsReserve']);{q}
    if jsn.has('enterer') then
        result.enterer := ParseReference{TFhirPractitioner}(jsn.vObj['enterer']);{q}
    if jsn.has('facility') then
        result.facility := ParseReference{TFhirLocation}(jsn.vObj['facility']);{q}
    if jsn.has('prescription') then
        result.prescription := ParseReference{Resource}(jsn.vObj['prescription']);{q}
    if jsn.has('originalPrescription') then
        result.originalPrescription := ParseReference{TFhirMedicationPrescription}(jsn.vObj['originalPrescription']);{q}
    if jsn.has('payee') then
        result.payee := ParseClaimPayee(jsn.vObj['payee']);{q}
    if jsn.has('referral') then
        result.referral := ParseReference{TFhirReferralRequest}(jsn.vObj['referral']);{q}
    if jsn.has('diagnosis') then
      iterateArray(jsn.vArr['diagnosis'], result.diagnosisList, parseClaimDiagnosis);
    if jsn.has('condition') then
      iterateArray(jsn.vArr['condition'], result.conditionList, parseCoding);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('coverage') then
      iterateArray(jsn.vArr['coverage'], result.coverageList, parseClaimCoverage);
    if jsn.has('exception') then
      iterateArray(jsn.vArr['exception'], result.exceptionList, parseCoding);
    if jsn.has('school') or jsn.has('_school') then
        result.schoolElement := ParseString(jsn['school'], jsn.vObj['_school']);{q}
    if jsn.has('accident') or jsn.has('_accident') then
        result.accidentElement := ParseDate(jsn['accident'], jsn.vObj['_accident']);{q}
    if jsn.has('accidentType') then
        result.accidentType := ParseCoding(jsn.vObj['accidentType']);{q}
    if jsn.has('interventionException') then
      iterateArray(jsn.vArr['interventionException'], result.interventionExceptionList, parseCoding);
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseClaimItem);
    if jsn.has('additionalMaterials') then
      iterateArray(jsn.vArr['additionalMaterials'], result.additionalMaterialsList, parseCoding);
    if jsn.has('missingTeeth') then
      iterateArray(jsn.vArr['missingTeeth'], result.missingTeethList, parseClaimMissingTeeth);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaim(json : TJSONWriter; name : string; elem : TFhirClaim; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirTypeLink, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirTypeLink, false);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  ComposeReference{TFhirOrganization}(json, 'target', elem.target); {a}
  ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirUseLink, false);
  ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirUseLink, false);
  ComposeCoding(json, 'priority', elem.priority); {a}
  ComposeCoding(json, 'fundsReserve', elem.fundsReserve); {a}
  ComposeReference{TFhirPractitioner}(json, 'enterer', elem.enterer); {a}
  ComposeReference{TFhirLocation}(json, 'facility', elem.facility); {a}
  ComposeReference{Resource}(json, 'prescription', elem.prescription); {a}
  ComposeReference{TFhirMedicationPrescription}(json, 'originalPrescription', elem.originalPrescription); {a}
  ComposeClaimPayee(json, 'payee', elem.payee); {a}
  ComposeReference{TFhirReferralRequest}(json, 'referral', elem.referral); {a}
  if elem.diagnosisList.Count > 0 then
  begin
    json.valueArray('diagnosis');
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeClaimDiagnosis(json, '',elem.diagnosisList[i]); {z - }
    json.FinishArray;
end;
  if elem.conditionList.Count > 0 then
begin
    json.valueArray('condition');
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeCoding(json, '',elem.conditionList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if elem.coverageList.Count > 0 then
  begin
    json.valueArray('coverage');
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeClaimCoverage(json, '',elem.coverageList[i]); {z - }
    json.FinishArray;
  end;
  if elem.exceptionList.Count > 0 then
  begin
    json.valueArray('exception');
    for i := 0 to elem.exceptionList.Count - 1 do
      ComposeCoding(json, '',elem.exceptionList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'school', elem.schoolElement, false);
  ComposeStringProps(json, 'school', elem.schoolElement, false);
  ComposeDateValue(json, 'accident', elem.accidentElement, false);
  ComposeDateProps(json, 'accident', elem.accidentElement, false);
  ComposeCoding(json, 'accidentType', elem.accidentType); {a}
  if elem.interventionExceptionList.Count > 0 then
  begin
    json.valueArray('interventionException');
    for i := 0 to elem.interventionExceptionList.Count - 1 do
      ComposeCoding(json, '',elem.interventionExceptionList[i]); {z - Coding}
    json.FinishArray;
  end;
  if elem.itemList.Count > 0 then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimItem(json, '',elem.itemList[i]); {z - }
    json.FinishArray;
  end;
  if elem.additionalMaterialsList.Count > 0 then
  begin
    json.valueArray('additionalMaterials');
    for i := 0 to elem.additionalMaterialsList.Count - 1 do
      ComposeCoding(json, '',elem.additionalMaterialsList[i]); {z - Coding}
    json.FinishArray;
  end;
  if elem.missingTeethList.Count > 0 then
  begin
    json.valueArray('missingTeeth');
    for i := 0 to elem.missingTeethList.Count - 1 do
      ComposeClaimMissingTeeth(json, '',elem.missingTeethList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseItem(element : IXmlDomElement; path : string) : TFhirClaimResponseItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(child, path+'/sequenceLinkId') {b}
      else if (child.baseName = 'noteNumber') then
        result.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber')){y.2}
      else if (child.baseName = 'adjudication') then
        result.adjudicationList.Add(ParseClaimResponseItemAdjudication(child, path+'/adjudication')){y.2}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseClaimResponseItemDetail(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItem(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItem);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2}
  for i := 0 to elem.noteNumberList.Count - 1 do
    ComposePositiveInt(xml, 'noteNumber', elem.noteNumberList[i]);
  for i := 0 to elem.adjudicationList.Count - 1 do
    ComposeClaimResponseItemAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  for i := 0 to elem.detailList.Count - 1 do
    ComposeClaimResponseItemDetail(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItem(jsn : TJsonObject) : TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(jsn['sequenceLinkId'], jsn.vObj['_sequenceLinkId']);{q}
      if jsn.has('noteNumber') or jsn.has('_noteNumber') then
      iteratePrimitiveArray(jsn.vArr['noteNumber'], jsn.vArr['_noteNumber'], result.noteNumberList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseItemAdjudication);
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseClaimResponseItemDetail);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItem(json : TJSONWriter; name : string; elem : TFhirClaimResponseItem; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  ComposePositiveIntProps(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if elem.noteNumberList.Count > 0 then
  begin
    json.valueArray('noteNumber');
    ext := false;
    for i := 0 to elem.noteNumberList.Count - 1 do
    begin
      ext := ext or ((elem.noteNumberList[i].id <> '') or (elem.noteNumberList[i].hasExtensionList));
      ComposePositiveIntValue(json, '',elem.noteNumberList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.adjudicationList.Count > 0 then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(json, '',elem.adjudicationList[i]); {z - }
    json.FinishArray;
  end;
  if elem.detailList.Count > 0 then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseItemDetail(json, '',elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimResponseItemAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseItemAdjudication;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCoding(child, path+'/code') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseDecimal(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemAdjudication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'code', elem.code);{x.2}
  ComposeQuantity(xml, 'amount', elem.amount);{x.2}
  ComposeDecimal(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseItemAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemAdjudication(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemAdjudication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'code', elem.code); {a}
  ComposeQuantity(json, 'amount', elem.amount); {a}
  ComposeDecimalValue(json, 'value', elem.valueElement, false);
  ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimResponseItemDetail(element : IXmlDomElement; path : string) : TFhirClaimResponseItemDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(child, path+'/sequenceLinkId') {b}
      else if (child.baseName = 'adjudication') then
        result.adjudicationList.Add(ParseClaimResponseItemDetailAdjudication(child, path+'/adjudication')){y.2}
      else if (child.baseName = 'subDetail') then
        result.subDetailList.Add(ParseClaimResponseItemDetailSubDetail(child, path+'/subDetail')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetail);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2}
  for i := 0 to elem.adjudicationList.Count - 1 do
    ComposeClaimResponseItemDetailAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  for i := 0 to elem.subDetailList.Count - 1 do
    ComposeClaimResponseItemDetailSubDetail(xml, 'subDetail', elem.subDetailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemDetail(jsn : TJsonObject) : TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(jsn['sequenceLinkId'], jsn.vObj['_sequenceLinkId']);{q}
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseItemDetailAdjudication);
    if jsn.has('subDetail') then
      iterateArray(jsn.vArr['subDetail'], result.subDetailList, parseClaimResponseItemDetailSubDetail);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  ComposePositiveIntProps(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if elem.adjudicationList.Count > 0 then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemDetailAdjudication(json, '',elem.adjudicationList[i]); {z - }
    json.FinishArray;
  end;
  if elem.subDetailList.Count > 0 then
  begin
    json.valueArray('subDetail');
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetail(json, '',elem.subDetailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseItemDetailAdjudication;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseItemDetailAdjudication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCoding(child, path+'/code') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseDecimal(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetailAdjudication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'code', elem.code);{x.2}
  ComposeQuantity(xml, 'amount', elem.amount);{x.2}
  ComposeDecimal(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemDetailAdjudication(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailAdjudication.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailAdjudication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'code', elem.code); {a}
  ComposeQuantity(json, 'amount', elem.amount); {a}
  ComposeDecimalValue(json, 'value', elem.valueElement, false);
  ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailSubDetail(element : IXmlDomElement; path : string) : TFhirClaimResponseItemDetailSubDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(child, path+'/sequenceLinkId') {b}
      else if (child.baseName = 'adjudication') then
        result.adjudicationList.Add(ParseClaimResponseItemDetailSubDetailAdjudication(child, path+'/adjudication')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailSubDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetailSubDetail);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2}
  for i := 0 to elem.adjudicationList.Count - 1 do
    ComposeClaimResponseItemDetailSubDetailAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemDetailSubDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(jsn['sequenceLinkId'], jsn.vObj['_sequenceLinkId']);{q}
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseItemDetailSubDetailAdjudication);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailSubDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  ComposePositiveIntProps(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if elem.adjudicationList.Count > 0 then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetailAdjudication(json, '',elem.adjudicationList[i]); {z - }
      json.FinishArray;
    end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailSubDetailAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseItemDetailSubDetailAdjudication;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseItemDetailSubDetailAdjudication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCoding(child, path+'/code') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseDecimal(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailSubDetailAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetailSubDetailAdjudication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'code', elem.code);{x.2}
  ComposeQuantity(xml, 'amount', elem.amount);{x.2}
  ComposeDecimal(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetailSubDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemDetailSubDetailAdjudication(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemDetailSubDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemDetailSubDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailSubDetailAdjudication.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemDetailSubDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailSubDetailAdjudication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'code', elem.code); {a}
  ComposeQuantity(json, 'amount', elem.amount); {a}
  ComposeDecimalValue(json, 'value', elem.valueElement, false);
  ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimResponseAddItem(element : IXmlDomElement; path : string) : TFhirClaimResponseAddItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequenceLinkId') then
        result.sequenceLinkIdList.Add(ParsePositiveInt(child, path+'/sequenceLinkId')){y.2}
      else if (child.baseName = 'service') then
        result.service := ParseCoding(child, path+'/service') {b}
      else if (child.baseName = 'fee') then
        result.fee := ParseQuantity(child, path+'/fee') {b}
      else if (child.baseName = 'noteNumberLinkId') then
        result.noteNumberLinkIdList.Add(ParsePositiveInt(child, path+'/noteNumberLinkId')){y.2}
      else if (child.baseName = 'adjudication') then
        result.adjudicationList.Add(ParseClaimResponseAddItemAdjudication(child, path+'/adjudication')){y.2}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseClaimResponseAddItemDetail(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItem(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItem);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.sequenceLinkIdList.Count - 1 do
    ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdList[i]);
  ComposeCoding(xml, 'service', elem.service);{x.2}
  ComposeQuantity(xml, 'fee', elem.fee);{x.2}
  for i := 0 to elem.noteNumberLinkIdList.Count - 1 do
    ComposePositiveInt(xml, 'noteNumberLinkId', elem.noteNumberLinkIdList[i]);
  for i := 0 to elem.adjudicationList.Count - 1 do
    ComposeClaimResponseAddItemAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  for i := 0 to elem.detailList.Count - 1 do
    ComposeClaimResponseAddItemDetail(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseAddItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseAddItem(jsn : TJsonObject) : TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
      iteratePrimitiveArray(jsn.vArr['sequenceLinkId'], jsn.vArr['_sequenceLinkId'], result.sequenceLinkIdList, parsePositiveInt);
    if jsn.has('service') then
        result.service := ParseCoding(jsn.vObj['service']);{q}
    if jsn.has('fee') then
        result.fee := ParseQuantity(jsn.vObj['fee']);{q}
      if jsn.has('noteNumberLinkId') or jsn.has('_noteNumberLinkId') then
      iteratePrimitiveArray(jsn.vArr['noteNumberLinkId'], jsn.vArr['_noteNumberLinkId'], result.noteNumberLinkIdList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseAddItemAdjudication);
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseClaimResponseAddItemDetail);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseAddItem(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItem; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.sequenceLinkIdList.Count > 0 then
  begin
    json.valueArray('sequenceLinkId');
    ext := false;
    for i := 0 to elem.sequenceLinkIdList.Count - 1 do
  begin
      ext := ext or ((elem.sequenceLinkIdList[i].id <> '') or (elem.sequenceLinkIdList[i].hasExtensionList));
      ComposePositiveIntValue(json, '',elem.sequenceLinkIdList[i], true);
    end;
    json.FinishArray;
    if ext then
  begin
      json.valueArray('_sequenceLinkId');
      for i := 0 to elem.sequenceLinkIdList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.sequenceLinkIdList[i], true);
    json.FinishArray;
  end;
  end;
  ComposeCoding(json, 'service', elem.service); {a}
  ComposeQuantity(json, 'fee', elem.fee); {a}
  if elem.noteNumberLinkIdList.Count > 0 then
  begin
    json.valueArray('noteNumberLinkId');
    ext := false;
    for i := 0 to elem.noteNumberLinkIdList.Count - 1 do
  begin
      ext := ext or ((elem.noteNumberLinkIdList[i].id <> '') or (elem.noteNumberLinkIdList[i].hasExtensionList));
      ComposePositiveIntValue(json, '',elem.noteNumberLinkIdList[i], true);
    end;
    json.FinishArray;
    if ext then
  begin
      json.valueArray('_noteNumberLinkId');
      for i := 0 to elem.noteNumberLinkIdList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberLinkIdList[i], true);
    json.FinishArray;
  end;
  end;
  if elem.adjudicationList.Count > 0 then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseAddItemAdjudication(json, '',elem.adjudicationList[i]); {z - }
    json.FinishArray;
  end;
  if elem.detailList.Count > 0 then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseAddItemDetail(json, '',elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimResponseAddItemAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseAddItemAdjudication;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseAddItemAdjudication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCoding(child, path+'/code') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseDecimal(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItemAdjudication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'code', elem.code);{x.2}
  ComposeQuantity(xml, 'amount', elem.amount);{x.2}
  ComposeDecimal(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseAddItemAdjudication(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseAddItemAdjudication(jsn : TJsonObject) : TFhirClaimResponseAddItemAdjudication;
begin
  result := TFhirClaimResponseAddItemAdjudication.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseAddItemAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemAdjudication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'code', elem.code); {a}
  ComposeQuantity(json, 'amount', elem.amount); {a}
  ComposeDecimalValue(json, 'value', elem.valueElement, false);
  ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimResponseAddItemDetail(element : IXmlDomElement; path : string) : TFhirClaimResponseAddItemDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'service') then
        result.service := ParseCoding(child, path+'/service') {b}
      else if (child.baseName = 'fee') then
        result.fee := ParseQuantity(child, path+'/fee') {b}
      else if (child.baseName = 'adjudication') then
        result.adjudicationList.Add(ParseClaimResponseAddItemDetailAdjudication(child, path+'/adjudication')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItemDetail);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'service', elem.service);{x.2}
  ComposeQuantity(xml, 'fee', elem.fee);{x.2}
  for i := 0 to elem.adjudicationList.Count - 1 do
    ComposeClaimResponseAddItemDetailAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseAddItemDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseAddItemDetail(jsn : TJsonObject) : TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('service') then
        result.service := ParseCoding(jsn.vObj['service']);{q}
    if jsn.has('fee') then
        result.fee := ParseQuantity(jsn.vObj['fee']);{q}
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseAddItemDetailAdjudication);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseAddItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'service', elem.service); {a}
  ComposeQuantity(json, 'fee', elem.fee); {a}
  if elem.adjudicationList.Count > 0 then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseAddItemDetailAdjudication(json, '',elem.adjudicationList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimResponseAddItemDetailAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseAddItemDetailAdjudication;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseAddItemDetailAdjudication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCoding(child, path+'/code') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseDecimal(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemDetailAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItemDetailAdjudication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'code', elem.code);{x.2}
  ComposeQuantity(xml, 'amount', elem.amount);{x.2}
  ComposeDecimal(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseAddItemDetailAdjudication(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseAddItemDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseAddItemDetailAdjudication;
begin
  result := TFhirClaimResponseAddItemDetailAdjudication.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseAddItemDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemDetailAdjudication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'code', elem.code); {a}
  ComposeQuantity(json, 'amount', elem.amount); {a}
  ComposeDecimalValue(json, 'value', elem.valueElement, false);
  ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimResponseError(element : IXmlDomElement; path : string) : TFhirClaimResponseError;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseError.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(child, path+'/sequenceLinkId') {b}
      else if (child.baseName = 'detailSequenceLinkId') then
        result.detailSequenceLinkIdElement := ParsePositiveInt(child, path+'/detailSequenceLinkId') {b}
      else if (child.baseName = 'subdetailSequenceLinkId') then
        result.subdetailSequenceLinkIdElement := ParsePositiveInt(child, path+'/subdetailSequenceLinkId') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCoding(child, path+'/code') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseError(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseError);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2}
  ComposePositiveInt(xml, 'detailSequenceLinkId', elem.detailSequenceLinkIdElement);{x.2}
  ComposePositiveInt(xml, 'subdetailSequenceLinkId', elem.subdetailSequenceLinkIdElement);{x.2}
  ComposeCoding(xml, 'code', elem.code);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseError(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseError(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseError(jsn : TJsonObject) : TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(jsn['sequenceLinkId'], jsn.vObj['_sequenceLinkId']);{q}
    if jsn.has('detailSequenceLinkId') or jsn.has('_detailSequenceLinkId') then
        result.detailSequenceLinkIdElement := ParsePositiveInt(jsn['detailSequenceLinkId'], jsn.vObj['_detailSequenceLinkId']);{q}
    if jsn.has('subdetailSequenceLinkId') or jsn.has('_subdetailSequenceLinkId') then
        result.subdetailSequenceLinkIdElement := ParsePositiveInt(jsn['subdetailSequenceLinkId'], jsn.vObj['_subdetailSequenceLinkId']);{q}
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseError(json : TJSONWriter; name : string; elem : TFhirClaimResponseError; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  ComposePositiveIntProps(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  ComposePositiveIntValue(json, 'detailSequenceLinkId', elem.detailSequenceLinkIdElement, false);
  ComposePositiveIntProps(json, 'detailSequenceLinkId', elem.detailSequenceLinkIdElement, false);
  ComposePositiveIntValue(json, 'subdetailSequenceLinkId', elem.subdetailSequenceLinkIdElement, false);
  ComposePositiveIntProps(json, 'subdetailSequenceLinkId', elem.subdetailSequenceLinkIdElement, false);
  ComposeCoding(json, 'code', elem.code); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimResponseNote(element : IXmlDomElement; path : string) : TFhirClaimResponseNote;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseNote.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'number') then
        result.numberElement := ParsePositiveInt(child, path+'/number') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseNote(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseNote);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'number', elem.numberElement);{x.2}
  ComposeCoding(xml, 'type', elem.type_);{x.2}
  ComposeString(xml, 'text', elem.textElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseNote(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseNote(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseNote(jsn : TJsonObject) : TFhirClaimResponseNote;
begin
  result := TFhirClaimResponseNote.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('number') or jsn.has('_number') then
        result.numberElement := ParsePositiveInt(jsn['number'], jsn.vObj['_number']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseNote(json : TJSONWriter; name : string; elem : TFhirClaimResponseNote; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'number', elem.numberElement, false);
  ComposePositiveIntProps(json, 'number', elem.numberElement, false);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeStringValue(json, 'text', elem.textElement, false);
  ComposeStringProps(json, 'text', elem.textElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimResponseCoverage(element : IXmlDomElement; path : string) : TFhirClaimResponseCoverage;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseCoverage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequence') then
        result.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.baseName = 'focal') then
        result.focalElement := ParseBoolean(child, path+'/focal') {b}
      else if (child.baseName = 'coverage') then
        result.coverage := ParseReference{TFhirCoverage}(child, path+'/coverage') {b}
      else if (child.baseName = 'businessArrangement') then
        result.businessArrangementElement := ParseString(child, path+'/businessArrangement') {b}
      else if (child.baseName = 'relationship') then
        result.relationship := ParseCoding(child, path+'/relationship') {b}
      else if (child.baseName = 'preAuthRef') then
        result.preAuthRefList.Add(ParseString(child, path+'/preAuthRef')){y.2}
      else if (child.baseName = 'claimResponse') then
        result.claimResponse := ParseReference{TFhirClaimResponse}(child, path+'/claimResponse') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseCoverage(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseCoverage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2}
  ComposeBoolean(xml, 'focal', elem.focalElement);{x.2}
  ComposeReference{TFhirCoverage}(xml, 'coverage', elem.coverage);{x.2}
  ComposeString(xml, 'businessArrangement', elem.businessArrangementElement);{x.2}
  ComposeCoding(xml, 'relationship', elem.relationship);{x.2}
  for i := 0 to elem.preAuthRefList.Count - 1 do
    ComposeString(xml, 'preAuthRef', elem.preAuthRefList[i]);
  ComposeReference{TFhirClaimResponse}(xml, 'claimResponse', elem.claimResponse);{x.2}
  ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseCoverage(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseCoverage(jsn : TJsonObject) : TFhirClaimResponseCoverage;
begin
  result := TFhirClaimResponseCoverage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('focal') or jsn.has('_focal') then
        result.focalElement := ParseBoolean(jsn['focal'], jsn.vObj['_focal']);{q}
    if jsn.has('coverage') then
        result.coverage := ParseReference{TFhirCoverage}(jsn.vObj['coverage']);{q}
    if jsn.has('businessArrangement') or jsn.has('_businessArrangement') then
        result.businessArrangementElement := ParseString(jsn['businessArrangement'], jsn.vObj['_businessArrangement']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCoding(jsn.vObj['relationship']);{q}
      if jsn.has('preAuthRef') or jsn.has('_preAuthRef') then
      iteratePrimitiveArray(jsn.vArr['preAuthRef'], jsn.vArr['_preAuthRef'], result.preAuthRefList, parseString);
    if jsn.has('claimResponse') then
        result.claimResponse := ParseReference{TFhirClaimResponse}(jsn.vObj['claimResponse']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseCoverage(json : TJSONWriter; name : string; elem : TFhirClaimResponseCoverage; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeBooleanValue(json, 'focal', elem.focalElement, false);
  ComposeBooleanProps(json, 'focal', elem.focalElement, false);
  ComposeReference{TFhirCoverage}(json, 'coverage', elem.coverage); {a}
  ComposeStringValue(json, 'businessArrangement', elem.businessArrangementElement, false);
  ComposeStringProps(json, 'businessArrangement', elem.businessArrangementElement, false);
  ComposeCoding(json, 'relationship', elem.relationship); {a}
  if elem.preAuthRefList.Count > 0 then
  begin
    json.valueArray('preAuthRef');
    ext := false;
    for i := 0 to elem.preAuthRefList.Count - 1 do
  begin
      ext := ext or ((elem.preAuthRefList[i].id <> '') or (elem.preAuthRefList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.preAuthRefList[i], true);
  end;
    json.FinishArray;
    if ext then
  begin
      json.valueArray('_preAuthRef');
      for i := 0 to elem.preAuthRefList.Count - 1 do
        ComposeStringProps(json, '',elem.preAuthRefList[i], true);
    json.FinishArray;
  end;
  end;
  ComposeReference{TFhirClaimResponse}(json, 'claimResponse', elem.claimResponse); {a}
  ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClaimResponse(element : IXmlDomElement; path : string) : TFhirClaimResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirClaim}(child, path+'/request') {b}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.baseName = 'requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if (child.baseName = 'outcome') then
        result.outcomeElement := ParseEnum(CODES_TFhirRSLink, path+'/outcome', child){1a}
      else if (child.baseName = 'disposition') then
        result.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.baseName = 'payeeType') then
        result.payeeType := ParseCoding(child, path+'/payeeType') {b}
      else if (child.baseName = 'item') then
        result.itemList.Add(ParseClaimResponseItem(child, path+'/item')){y.2}
      else if (child.baseName = 'addItem') then
        result.addItemList.Add(ParseClaimResponseAddItem(child, path+'/addItem')){y.2}
      else if (child.baseName = 'error') then
        result.errorList.Add(ParseClaimResponseError(child, path+'/error')){y.2}
      else if (child.baseName = 'totalCost') then
        result.totalCost := ParseQuantity(child, path+'/totalCost') {b}
      else if (child.baseName = 'unallocDeductable') then
        result.unallocDeductable := ParseQuantity(child, path+'/unallocDeductable') {b}
      else if (child.baseName = 'totalBenefit') then
        result.totalBenefit := ParseQuantity(child, path+'/totalBenefit') {b}
      else if (child.baseName = 'paymentAdjustment') then
        result.paymentAdjustment := ParseQuantity(child, path+'/paymentAdjustment') {b}
      else if (child.baseName = 'paymentAdjustmentReason') then
        result.paymentAdjustmentReason := ParseCoding(child, path+'/paymentAdjustmentReason') {b}
      else if (child.baseName = 'paymentDate') then
        result.paymentDateElement := ParseDate(child, path+'/paymentDate') {b}
      else if (child.baseName = 'paymentAmount') then
        result.paymentAmount := ParseQuantity(child, path+'/paymentAmount') {b}
      else if (child.baseName = 'paymentRef') then
        result.paymentRef := ParseIdentifier(child, path+'/paymentRef') {b}
      else if (child.baseName = 'reserved') then
        result.reserved := ParseCoding(child, path+'/reserved') {b}
      else if (child.baseName = 'form') then
        result.form := ParseCoding(child, path+'/form') {b}
      else if (child.baseName = 'note') then
        result.noteList.Add(ParseClaimResponseNote(child, path+'/note')){y.2}
      else if (child.baseName = 'coverage') then
        result.coverageList.Add(ParseClaimResponseCoverage(child, path+'/coverage')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponse(xml : TXmlBuilder; name : string; elem : TFhirClaimResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirClaim}(xml, 'request', elem.request);{x.2}
  ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2}
  ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirRSLink);
  ComposeString(xml, 'disposition', elem.dispositionElement);{x.2}
  ComposeCoding(xml, 'payeeType', elem.payeeType);{x.2}
  for i := 0 to elem.itemList.Count - 1 do
    ComposeClaimResponseItem(xml, 'item', elem.itemList[i]);
  for i := 0 to elem.addItemList.Count - 1 do
    ComposeClaimResponseAddItem(xml, 'addItem', elem.addItemList[i]);
  for i := 0 to elem.errorList.Count - 1 do
    ComposeClaimResponseError(xml, 'error', elem.errorList[i]);
  ComposeQuantity(xml, 'totalCost', elem.totalCost);{x.2}
  ComposeQuantity(xml, 'unallocDeductable', elem.unallocDeductable);{x.2}
  ComposeQuantity(xml, 'totalBenefit', elem.totalBenefit);{x.2}
  ComposeQuantity(xml, 'paymentAdjustment', elem.paymentAdjustment);{x.2}
  ComposeCoding(xml, 'paymentAdjustmentReason', elem.paymentAdjustmentReason);{x.2}
  ComposeDate(xml, 'paymentDate', elem.paymentDateElement);{x.2}
  ComposeQuantity(xml, 'paymentAmount', elem.paymentAmount);{x.2}
  ComposeIdentifier(xml, 'paymentRef', elem.paymentRef);{x.2}
  ComposeCoding(xml, 'reserved', elem.reserved);{x.2}
  ComposeCoding(xml, 'form', elem.form);{x.2}
  for i := 0 to elem.noteList.Count - 1 do
    ComposeClaimResponseNote(xml, 'note', elem.noteList[i]);
  for i := 0 to elem.coverageList.Count - 1 do
    ComposeClaimResponseCoverage(xml, 'coverage', elem.coverageList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponse(jsn : TJsonObject) : TFhirClaimResponse;
begin
  result := TFhirClaimResponse.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirClaim}(jsn.vObj['request']);{q}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn['outcome'], jsn.vObj['_outcome'], CODES_TFhirRSLink);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('payeeType') then
        result.payeeType := ParseCoding(jsn.vObj['payeeType']);{q}
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseClaimResponseItem);
    if jsn.has('addItem') then
      iterateArray(jsn.vArr['addItem'], result.addItemList, parseClaimResponseAddItem);
    if jsn.has('error') then
      iterateArray(jsn.vArr['error'], result.errorList, parseClaimResponseError);
    if jsn.has('totalCost') then
        result.totalCost := ParseQuantity(jsn.vObj['totalCost']);{q}
    if jsn.has('unallocDeductable') then
        result.unallocDeductable := ParseQuantity(jsn.vObj['unallocDeductable']);{q}
    if jsn.has('totalBenefit') then
        result.totalBenefit := ParseQuantity(jsn.vObj['totalBenefit']);{q}
    if jsn.has('paymentAdjustment') then
        result.paymentAdjustment := ParseQuantity(jsn.vObj['paymentAdjustment']);{q}
    if jsn.has('paymentAdjustmentReason') then
        result.paymentAdjustmentReason := ParseCoding(jsn.vObj['paymentAdjustmentReason']);{q}
    if jsn.has('paymentDate') or jsn.has('_paymentDate') then
        result.paymentDateElement := ParseDate(jsn['paymentDate'], jsn.vObj['_paymentDate']);{q}
    if jsn.has('paymentAmount') then
        result.paymentAmount := ParseQuantity(jsn.vObj['paymentAmount']);{q}
    if jsn.has('paymentRef') then
        result.paymentRef := ParseIdentifier(jsn.vObj['paymentRef']);{q}
    if jsn.has('reserved') then
        result.reserved := ParseCoding(jsn.vObj['reserved']);{q}
    if jsn.has('form') then
        result.form := ParseCoding(jsn.vObj['form']);{q}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseClaimResponseNote);
    if jsn.has('coverage') then
      iterateArray(jsn.vArr['coverage'], result.coverageList, parseClaimResponseCoverage);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponse(json : TJSONWriter; name : string; elem : TFhirClaimResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
end;
  ComposeReference{TFhirClaim}(json, 'request', elem.request); {a}
  ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
  ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRSLink, false);
  ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRSLink, false);
  ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  ComposeCoding(json, 'payeeType', elem.payeeType); {a}
  if elem.itemList.Count > 0 then
begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimResponseItem(json, '',elem.itemList[i]); {z - }
    json.FinishArray;
  end;
  if elem.addItemList.Count > 0 then
  begin
    json.valueArray('addItem');
    for i := 0 to elem.addItemList.Count - 1 do
      ComposeClaimResponseAddItem(json, '',elem.addItemList[i]); {z - }
    json.FinishArray;
  end;
  if elem.errorList.Count > 0 then
  begin
    json.valueArray('error');
    for i := 0 to elem.errorList.Count - 1 do
      ComposeClaimResponseError(json, '',elem.errorList[i]); {z - }
    json.FinishArray;
  end;
  ComposeQuantity(json, 'totalCost', elem.totalCost); {a}
  ComposeQuantity(json, 'unallocDeductable', elem.unallocDeductable); {a}
  ComposeQuantity(json, 'totalBenefit', elem.totalBenefit); {a}
  ComposeQuantity(json, 'paymentAdjustment', elem.paymentAdjustment); {a}
  ComposeCoding(json, 'paymentAdjustmentReason', elem.paymentAdjustmentReason); {a}
  ComposeDateValue(json, 'paymentDate', elem.paymentDateElement, false);
  ComposeDateProps(json, 'paymentDate', elem.paymentDateElement, false);
  ComposeQuantity(json, 'paymentAmount', elem.paymentAmount); {a}
  ComposeIdentifier(json, 'paymentRef', elem.paymentRef); {a}
  ComposeCoding(json, 'reserved', elem.reserved); {a}
  ComposeCoding(json, 'form', elem.form); {a}
  if elem.noteList.Count > 0 then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeClaimResponseNote(json, '',elem.noteList[i]); {z - }
    json.FinishArray;
  end;
  if elem.coverageList.Count > 0 then
  begin
    json.valueArray('coverage');
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeClaimResponseCoverage(json, '',elem.coverageList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseClinicalImpressionInvestigations(element : IXmlDomElement; path : string) : TFhirClinicalImpressionInvestigations;
var
  child : IXMLDOMElement;
begin
  result := TFhirClinicalImpressionInvestigations.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'item') then
        result.itemList.Add(ParseReference{Resource}(child, path+'/item')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionInvestigations(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpressionInvestigations);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  for i := 0 to elem.itemList.Count - 1 do
    ComposeReference{Resource}(xml, 'item', elem.itemList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClinicalImpressionInvestigations(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClinicalImpressionInvestigations(jsn)); {2}
end;

function TFHIRJsonParser.ParseClinicalImpressionInvestigations(jsn : TJsonObject) : TFhirClinicalImpressionInvestigations;
begin
  result := TFhirClinicalImpressionInvestigations.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClinicalImpressionInvestigations(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionInvestigations; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if elem.itemList.Count > 0 then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.itemList[i]); {z - Reference(Observation|QuestionnaireAnswers|FamilyMemberHistory|DiagnosticReport)}
      json.FinishArray;
    end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClinicalImpressionFinding(element : IXmlDomElement; path : string) : TFhirClinicalImpressionFinding;
var
  child : IXMLDOMElement;
begin
  result := TFhirClinicalImpressionFinding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'item') then
        result.item := ParseCodeableConcept(child, path+'/item') {b}
      else if (child.baseName = 'cause') then
        result.causeElement := ParseString(child, path+'/cause') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionFinding(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpressionFinding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'item', elem.item);{x.2}
  ComposeString(xml, 'cause', elem.causeElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClinicalImpressionFinding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClinicalImpressionFinding(jsn)); {2}
end;

function TFHIRJsonParser.ParseClinicalImpressionFinding(jsn : TJsonObject) : TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('item') then
        result.item := ParseCodeableConcept(jsn.vObj['item']);{q}
    if jsn.has('cause') or jsn.has('_cause') then
        result.causeElement := ParseString(jsn['cause'], jsn.vObj['_cause']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClinicalImpressionFinding(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionFinding; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'item', elem.item); {a}
  ComposeStringValue(json, 'cause', elem.causeElement, false);
  ComposeStringProps(json, 'cause', elem.causeElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClinicalImpressionRuledOut(element : IXmlDomElement; path : string) : TFhirClinicalImpressionRuledOut;
var
  child : IXMLDOMElement;
begin
  result := TFhirClinicalImpressionRuledOut.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'item') then
        result.item := ParseCodeableConcept(child, path+'/item') {b}
      else if (child.baseName = 'reason') then
        result.reasonElement := ParseString(child, path+'/reason') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionRuledOut(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpressionRuledOut);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'item', elem.item);{x.2}
  ComposeString(xml, 'reason', elem.reasonElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClinicalImpressionRuledOut(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClinicalImpressionRuledOut(jsn)); {2}
end;

function TFHIRJsonParser.ParseClinicalImpressionRuledOut(jsn : TJsonObject) : TFhirClinicalImpressionRuledOut;
begin
  result := TFhirClinicalImpressionRuledOut.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('item') then
        result.item := ParseCodeableConcept(jsn.vObj['item']);{q}
    if jsn.has('reason') or jsn.has('_reason') then
        result.reasonElement := ParseString(jsn['reason'], jsn.vObj['_reason']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClinicalImpressionRuledOut(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionRuledOut; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'item', elem.item); {a}
  ComposeStringValue(json, 'reason', elem.reasonElement, false);
  ComposeStringProps(json, 'reason', elem.reasonElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseClinicalImpression(element : IXmlDomElement; path : string) : TFhirClinicalImpression;
var
  child : IXMLDOMElement;
begin
  result := TFhirClinicalImpression.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'assessor') then
        result.assessor := ParseReference{TFhirPractitioner}(child, path+'/assessor') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirClinicalImpressionStatus, path+'/status', child){1a}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'previous') then
        result.previous := ParseReference{TFhirClinicalImpression}(child, path+'/previous') {b}
      else if (child.baseName = 'problem') then
        result.problemList.Add(ParseReference{Resource}(child, path+'/problem')){y.2}
      else if (child.baseName = 'triggerCodeableConcept') then
        result.trigger := ParseCodeableConcept(child, path+'/triggerCodeableConcept'){x.3}
      else if (child.baseName = 'triggerReference') then
        result.trigger := ParseReference(child, path+'/triggerReference') {a}
      else if (child.baseName = 'investigations') then
        result.investigationsList.Add(ParseClinicalImpressionInvestigations(child, path+'/investigations')){y.2}
      else if (child.baseName = 'protocol') then
        result.protocolElement := ParseUri(child, path+'/protocol') {b}
      else if (child.baseName = 'summary') then
        result.summaryElement := ParseString(child, path+'/summary') {b}
      else if (child.baseName = 'finding') then
        result.findingList.Add(ParseClinicalImpressionFinding(child, path+'/finding')){y.2}
      else if (child.baseName = 'resolved') then
        result.resolvedList.Add(ParseCodeableConcept(child, path+'/resolved')){y.2}
      else if (child.baseName = 'ruledOut') then
        result.ruledOutList.Add(ParseClinicalImpressionRuledOut(child, path+'/ruledOut')){y.2}
      else if (child.baseName = 'prognosis') then
        result.prognosisElement := ParseString(child, path+'/prognosis') {b}
      else if (child.baseName = 'plan') then
        result.planList.Add(ParseReference{Resource}(child, path+'/plan')){y.2}
      else if (child.baseName = 'action') then
        result.actionList.Add(ParseReference{Resource}(child, path+'/action')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpression(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpression);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'assessor', elem.assessor);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirClinicalImpressionStatus);
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeReference{TFhirClinicalImpression}(xml, 'previous', elem.previous);{x.2}
  for i := 0 to elem.problemList.Count - 1 do
    ComposeReference{Resource}(xml, 'problem', elem.problemList[i]);
  if (elem.trigger is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'triggerCodeableConcept', TFhirCodeableConcept(elem.trigger))
  else if (elem.trigger is TFhirReference) {2} then
    ComposeReference(xml, 'triggerReference', TFhirReference(elem.trigger));
  for i := 0 to elem.investigationsList.Count - 1 do
    ComposeClinicalImpressionInvestigations(xml, 'investigations', elem.investigationsList[i]);
  ComposeUri(xml, 'protocol', elem.protocolElement);{x.2}
  ComposeString(xml, 'summary', elem.summaryElement);{x.2}
  for i := 0 to elem.findingList.Count - 1 do
    ComposeClinicalImpressionFinding(xml, 'finding', elem.findingList[i]);
  for i := 0 to elem.resolvedList.Count - 1 do
    ComposeCodeableConcept(xml, 'resolved', elem.resolvedList[i]);
  for i := 0 to elem.ruledOutList.Count - 1 do
    ComposeClinicalImpressionRuledOut(xml, 'ruledOut', elem.ruledOutList[i]);
  ComposeString(xml, 'prognosis', elem.prognosisElement);{x.2}
  for i := 0 to elem.planList.Count - 1 do
    ComposeReference{Resource}(xml, 'plan', elem.planList[i]);
  for i := 0 to elem.actionList.Count - 1 do
    ComposeReference{Resource}(xml, 'action', elem.actionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClinicalImpression(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClinicalImpression(jsn)); {2}
end;

function TFHIRJsonParser.ParseClinicalImpression(jsn : TJsonObject) : TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('assessor') then
        result.assessor := ParseReference{TFhirPractitioner}(jsn.vObj['assessor']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirClinicalImpressionStatus);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('previous') then
        result.previous := ParseReference{TFhirClinicalImpression}(jsn.vObj['previous']);{q}
    if jsn.has('problem') then
      iterateArray(jsn.vArr['problem'], result.problemList, parseReference{Resource});
    if jsn.has('triggerCodeableConcept') {a4} then
      result.trigger := ParseCodeableConcept(jsn.vObj['triggerCodeableConcept']);
    if jsn.has('triggerReference') {a3} then
      result.trigger := ParseReference(jsn.vObj['triggerReference']);
    if jsn.has('investigations') then
      iterateArray(jsn.vArr['investigations'], result.investigationsList, parseClinicalImpressionInvestigations);
    if jsn.has('protocol') or jsn.has('_protocol') then
        result.protocolElement := ParseUri(jsn['protocol'], jsn.vObj['_protocol']);{q}
    if jsn.has('summary') or jsn.has('_summary') then
        result.summaryElement := ParseString(jsn['summary'], jsn.vObj['_summary']);{q}
    if jsn.has('finding') then
      iterateArray(jsn.vArr['finding'], result.findingList, parseClinicalImpressionFinding);
    if jsn.has('resolved') then
      iterateArray(jsn.vArr['resolved'], result.resolvedList, parseCodeableConcept);
    if jsn.has('ruledOut') then
      iterateArray(jsn.vArr['ruledOut'], result.ruledOutList, parseClinicalImpressionRuledOut);
    if jsn.has('prognosis') or jsn.has('_prognosis') then
        result.prognosisElement := ParseString(jsn['prognosis'], jsn.vObj['_prognosis']);{q}
    if jsn.has('plan') then
      iterateArray(jsn.vArr['plan'], result.planList, parseReference{Resource});
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClinicalImpression(json : TJSONWriter; name : string; elem : TFhirClinicalImpression; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeReference{TFhirPractitioner}(json, 'assessor', elem.assessor); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirClinicalImpressionStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirClinicalImpressionStatus, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeReference{TFhirClinicalImpression}(json, 'previous', elem.previous); {a}
  if elem.problemList.Count > 0 then
  begin
    json.valueArray('problem');
    for i := 0 to elem.problemList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.problemList[i]); {z - Reference(Condition|AllergyIntolerance)}
    json.FinishArray;
  end;
  if (elem.trigger is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'triggerCodeableConcept', TFhirCodeableConcept(elem.trigger)) 
  else if (elem.trigger is TFhirReference) then
    ComposeReference(json, 'triggerReference', TFhirReference(elem.trigger));
  if elem.investigationsList.Count > 0 then
  begin
    json.valueArray('investigations');
    for i := 0 to elem.investigationsList.Count - 1 do
      ComposeClinicalImpressionInvestigations(json, '',elem.investigationsList[i]); {z - }
    json.FinishArray;
  end;
  ComposeUriValue(json, 'protocol', elem.protocolElement, false);
  ComposeUriProps(json, 'protocol', elem.protocolElement, false);
  ComposeStringValue(json, 'summary', elem.summaryElement, false);
  ComposeStringProps(json, 'summary', elem.summaryElement, false);
  if elem.findingList.Count > 0 then
  begin
    json.valueArray('finding');
    for i := 0 to elem.findingList.Count - 1 do
      ComposeClinicalImpressionFinding(json, '',elem.findingList[i]); {z - }
    json.FinishArray;
  end;
  if elem.resolvedList.Count > 0 then
  begin
    json.valueArray('resolved');
    for i := 0 to elem.resolvedList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.resolvedList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.ruledOutList.Count > 0 then
  begin
    json.valueArray('ruledOut');
    for i := 0 to elem.ruledOutList.Count - 1 do
      ComposeClinicalImpressionRuledOut(json, '',elem.ruledOutList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'prognosis', elem.prognosisElement, false);
  ComposeStringProps(json, 'prognosis', elem.prognosisElement, false);
  if elem.planList.Count > 0 then
  begin
    json.valueArray('plan');
    for i := 0 to elem.planList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.planList[i]); {z - Reference(CarePlan|Appointment|CommunicationRequest|DeviceUseRequest|DiagnosticOrder|MedicationPrescription|NutritionOrder|Order|ProcedureRequest|ProcessRequest|ReferralRequest|Supply|VisionPrescription)}
    json.FinishArray;
  end;
  if elem.actionList.Count > 0 then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.actionList[i]); {z - Reference(ReferralRequest|ProcedureRequest|Procedure|MedicationPrescription|DiagnosticOrder|NutritionOrder|Supply|Appointment)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseCommunicationPayload(element : IXmlDomElement; path : string) : TFhirCommunicationPayload;
var
  child : IXMLDOMElement;
begin
  result := TFhirCommunicationPayload.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'contentString') then
        result.content := ParseString(child, path+'/contentString'){x.3}
      else if (child.baseName = 'contentAttachment') then
        result.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.baseName = 'contentReference') then
        result.content := ParseReference(child, path+'/contentReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCommunicationPayload(xml : TXmlBuilder; name : string; elem : TFhirCommunicationPayload);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (elem.content is TFhirString) {6} then
    ComposeString(xml, 'contentString', TFhirString(elem.content))
  else if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCommunicationPayload(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCommunicationPayload(jsn)); {2}
end;

function TFHIRJsonParser.ParseCommunicationPayload(jsn : TJsonObject) : TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentString') or jsn.has('_contentString') then
      result.content := parseString(jsn['contentString'], jsn.vObj['_contentString']);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCommunicationPayload(json : TJSONWriter; name : string; elem : TFhirCommunicationPayload; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.content is TFhirString) then 
  begin
    ComposeStringValue(json, 'contentString', TFhirString(elem.content), false);
    ComposeStringProps(json, 'contentString', TFhirString(elem.content), false);
  end
  else if (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content));
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseCommunication(element : IXmlDomElement; path : string) : TFhirCommunication;
var
  child : IXMLDOMElement;
begin
  result := TFhirCommunication.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'sender') then
        result.sender := ParseReference{Resource}(child, path+'/sender') {b}
      else if (child.baseName = 'recipient') then
        result.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.baseName = 'payload') then
        result.payloadList.Add(ParseCommunicationPayload(child, path+'/payload')){y.2}
      else if (child.baseName = 'medium') then
        result.mediumList.Add(ParseCodeableConcept(child, path+'/medium')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirCommunicationStatus, path+'/status', child){1a}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'sent') then
        result.sentElement := ParseDateTime(child, path+'/sent') {b}
      else if (child.baseName = 'received') then
        result.receivedElement := ParseDateTime(child, path+'/received') {b}
      else if (child.baseName = 'reason') then
        result.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCommunication(xml : TXmlBuilder; name : string; elem : TFhirCommunication);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  ComposeReference{Resource}(xml, 'sender', elem.sender);{x.2}
  for i := 0 to elem.recipientList.Count - 1 do
    ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  for i := 0 to elem.payloadList.Count - 1 do
    ComposeCommunicationPayload(xml, 'payload', elem.payloadList[i]);
  for i := 0 to elem.mediumList.Count - 1 do
    ComposeCodeableConcept(xml, 'medium', elem.mediumList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCommunicationStatus);
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  ComposeDateTime(xml, 'sent', elem.sentElement);{x.2}
  ComposeDateTime(xml, 'received', elem.receivedElement);{x.2}
  for i := 0 to elem.reasonList.Count - 1 do
    ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCommunication(jsn)); {2}
end;

function TFHIRJsonParser.ParseCommunication(jsn : TJsonObject) : TFhirCommunication;
begin
  result := TFhirCommunication.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('sender') then
        result.sender := ParseReference{Resource}(jsn.vObj['sender']);{q}
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{Resource});
    if jsn.has('payload') then
      iterateArray(jsn.vArr['payload'], result.payloadList, parseCommunicationPayload);
    if jsn.has('medium') then
      iterateArray(jsn.vArr['medium'], result.mediumList, parseCodeableConcept);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirCommunicationStatus);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('sent') or jsn.has('_sent') then
        result.sentElement := ParseDateTime(jsn['sent'], jsn.vObj['_sent']);{q}
    if jsn.has('received') or jsn.has('_received') then
        result.receivedElement := ParseDateTime(jsn['received'], jsn.vObj['_received']);{q}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCommunication(json : TJSONWriter; name : string; elem : TFhirCommunication; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeReference{Resource}(json, 'sender', elem.sender); {a}
  if elem.recipientList.Count > 0 then
  begin
    json.valueArray('recipient');
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.recipientList[i]); {z - Reference(Device|Organization|Patient|Practitioner|RelatedPerson)}
    json.FinishArray;
  end;
  if elem.payloadList.Count > 0 then
  begin
    json.valueArray('payload');
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationPayload(json, '',elem.payloadList[i]); {z - }
    json.FinishArray;
  end;
  if elem.mediumList.Count > 0 then
  begin
    json.valueArray('medium');
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.mediumList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCommunicationStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCommunicationStatus, false);
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeDateTimeValue(json, 'sent', elem.sentElement, false);
  ComposeDateTimeProps(json, 'sent', elem.sentElement, false);
  ComposeDateTimeValue(json, 'received', elem.receivedElement, false);
  ComposeDateTimeProps(json, 'received', elem.receivedElement, false);
  if elem.reasonList.Count > 0 then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
end;

function TFHIRXmlParser.ParseCommunicationRequestPayload(element : IXmlDomElement; path : string) : TFhirCommunicationRequestPayload;
var
  child : IXMLDOMElement;
begin
  result := TFhirCommunicationRequestPayload.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'contentString') then
        result.content := ParseString(child, path+'/contentString'){x.3}
      else if (child.baseName = 'contentAttachment') then
        result.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.baseName = 'contentReference') then
        result.content := ParseReference(child, path+'/contentReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequestPayload(xml : TXmlBuilder; name : string; elem : TFhirCommunicationRequestPayload);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (elem.content is TFhirString) {6} then
    ComposeString(xml, 'contentString', TFhirString(elem.content))
  else if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCommunicationRequestPayload(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCommunicationRequestPayload(jsn)); {2}
end;

function TFHIRJsonParser.ParseCommunicationRequestPayload(jsn : TJsonObject) : TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentString') or jsn.has('_contentString') then
      result.content := parseString(jsn['contentString'], jsn.vObj['_contentString']);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCommunicationRequestPayload(json : TJSONWriter; name : string; elem : TFhirCommunicationRequestPayload; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.content is TFhirString) then 
  begin
    ComposeStringValue(json, 'contentString', TFhirString(elem.content), false);
    ComposeStringProps(json, 'contentString', TFhirString(elem.content), false);
  end
  else if (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content));
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseCommunicationRequest(element : IXmlDomElement; path : string) : TFhirCommunicationRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirCommunicationRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'sender') then
        result.sender := ParseReference{Resource}(child, path+'/sender') {b}
      else if (child.baseName = 'recipient') then
        result.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.baseName = 'payload') then
        result.payloadList.Add(ParseCommunicationRequestPayload(child, path+'/payload')){y.2}
      else if (child.baseName = 'medium') then
        result.mediumList.Add(ParseCodeableConcept(child, path+'/medium')){y.2}
      else if (child.baseName = 'requester') then
        result.requester := ParseReference{Resource}(child, path+'/requester') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirCommunicationRequestStatus, path+'/status', child){1a}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'scheduledTime') then
        result.scheduledTimeElement := ParseDateTime(child, path+'/scheduledTime') {b}
      else if (child.baseName = 'reason') then
        result.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.baseName = 'orderedOn') then
        result.orderedOnElement := ParseDateTime(child, path+'/orderedOn') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'priority') then
        result.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequest(xml : TXmlBuilder; name : string; elem : TFhirCommunicationRequest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  ComposeReference{Resource}(xml, 'sender', elem.sender);{x.2}
  for i := 0 to elem.recipientList.Count - 1 do
    ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  for i := 0 to elem.payloadList.Count - 1 do
    ComposeCommunicationRequestPayload(xml, 'payload', elem.payloadList[i]);
  for i := 0 to elem.mediumList.Count - 1 do
    ComposeCodeableConcept(xml, 'medium', elem.mediumList[i]);
  ComposeReference{Resource}(xml, 'requester', elem.requester);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCommunicationRequestStatus);
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  ComposeDateTime(xml, 'scheduledTime', elem.scheduledTimeElement);{x.2}
  for i := 0 to elem.reasonList.Count - 1 do
    ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  ComposeDateTime(xml, 'orderedOn', elem.orderedOnElement);{x.2}
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCommunicationRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCommunicationRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseCommunicationRequest(jsn : TJsonObject) : TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('sender') then
        result.sender := ParseReference{Resource}(jsn.vObj['sender']);{q}
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{Resource});
    if jsn.has('payload') then
      iterateArray(jsn.vArr['payload'], result.payloadList, parseCommunicationRequestPayload);
    if jsn.has('medium') then
      iterateArray(jsn.vArr['medium'], result.mediumList, parseCodeableConcept);
    if jsn.has('requester') then
        result.requester := ParseReference{Resource}(jsn.vObj['requester']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirCommunicationRequestStatus);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('scheduledTime') or jsn.has('_scheduledTime') then
        result.scheduledTimeElement := ParseDateTime(jsn['scheduledTime'], jsn.vObj['_scheduledTime']);{q}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('orderedOn') or jsn.has('_orderedOn') then
        result.orderedOnElement := ParseDateTime(jsn['orderedOn'], jsn.vObj['_orderedOn']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCommunicationRequest(json : TJSONWriter; name : string; elem : TFhirCommunicationRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeReference{Resource}(json, 'sender', elem.sender); {a}
  if elem.recipientList.Count > 0 then
begin
    json.valueArray('recipient');
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.recipientList[i]); {z - Reference(Device|Organization|Patient|Practitioner|RelatedPerson)}
    json.FinishArray;
    end;
  if elem.payloadList.Count > 0 then
begin
    json.valueArray('payload');
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationRequestPayload(json, '',elem.payloadList[i]); {z - }
    json.FinishArray;
  end;
  if elem.mediumList.Count > 0 then
  begin
    json.valueArray('medium');
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.mediumList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeReference{Resource}(json, 'requester', elem.requester); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCommunicationRequestStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCommunicationRequestStatus, false);
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeDateTimeValue(json, 'scheduledTime', elem.scheduledTimeElement, false);
  ComposeDateTimeProps(json, 'scheduledTime', elem.scheduledTimeElement, false);
  if elem.reasonList.Count > 0 then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'orderedOn', elem.orderedOnElement, false);
  ComposeDateTimeProps(json, 'orderedOn', elem.orderedOnElement, false);
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeCodeableConcept(json, 'priority', elem.priority); {a}
end;

function TFHIRXmlParser.ParseCompositionAttester(element : IXmlDomElement; path : string) : TFhirCompositionAttester;
var
  child : IXMLDOMElement;
begin
  result := TFhirCompositionAttester.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'mode') then
        result.modeElement.Add(ParseEnum(CODES_TFhirCompositionAttestationMode, path+'/mode', child)){y.1}
      else if (child.baseName = 'time') then
        result.timeElement := ParseDateTime(child, path+'/time') {b}
      else if (child.baseName = 'party') then
        result.party := ParseReference{Resource}(child, path+'/party') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCompositionAttester(xml : TXmlBuilder; name : string; elem : TFhirCompositionAttester);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.modeElement.Count - 1 do
    ComposeEnum(xml, 'mode', elem.modeElement[i], CODES_TFhirCompositionAttestationMode);
  ComposeDateTime(xml, 'time', elem.timeElement);{x.2}
  ComposeReference{Resource}(xml, 'party', elem.party);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCompositionAttester(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionAttester(jsn)); {2}
end;

function TFHIRJsonParser.ParseCompositionAttester(jsn : TJsonObject) : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode') then
      iterateEnumArray(jsn.vArr['mode'], jsn.vArr['_mode'], result.modeElement, parseEnum, CODES_TFhirCompositionAttestationMode);
    if jsn.has('time') or jsn.has('_time') then
        result.timeElement := ParseDateTime(jsn['time'], jsn.vObj['_time']);{q}
    if jsn.has('party') then
        result.party := ParseReference{Resource}(jsn.vObj['party']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCompositionAttester(json : TJSONWriter; name : string; elem : TFhirCompositionAttester; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.modeElement.Count > 0 then
  begin
    json.valueArray('mode');
    ext := false;
    for i := 0 to elem.modeElement.Count - 1 do
    begin
      ext := ext or ((elem.modeElement[i].id <> '') or (elem.modeElement[i].hasExtensionList));
      ComposeEnumValue(json, '', elem.modeElement[i], CODES_TFhirCompositionAttestationMode, true);
    end;
    json.FinishArray;
    if ext then
  begin
      json.valueArray('_mode');
      for i := 0 to elem.modeElement.Count - 1 do
        ComposeEnumProps(json, '', elem.modeElement[i], CODES_TFhirCompositionAttestationMode, true);
    json.FinishArray;
  end;
  end;
  ComposeDateTimeValue(json, 'time', elem.timeElement, false);
  ComposeDateTimeProps(json, 'time', elem.timeElement, false);
  ComposeReference{Resource}(json, 'party', elem.party); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseCompositionEvent(element : IXmlDomElement; path : string) : TFhirCompositionEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirCompositionEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeList.Add(ParseCodeableConcept(child, path+'/code')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseReference{TFhirReference}(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCompositionEvent(xml : TXmlBuilder; name : string; elem : TFhirCompositionEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.codeList.Count - 1 do
    ComposeCodeableConcept(xml, 'code', elem.codeList[i]);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  for i := 0 to elem.detailList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCompositionEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseCompositionEvent(jsn : TJsonObject) : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCompositionEvent(json : TJSONWriter; name : string; elem : TFhirCompositionEvent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.codeList.Count > 0 then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.codeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
  if elem.detailList.Count > 0 then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.detailList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseCompositionSection(element : IXmlDomElement; path : string) : TFhirCompositionSection;
var
  child : IXMLDOMElement;
begin
  result := TFhirCompositionSection.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'title') then
        result.titleElement := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'content') then
        result.content := ParseReference{TFhirList}(child, path+'/content') {b}
      else if (child.baseName = 'section') then
        result.sectionList.Add(ParseCompositionSection(child, path+'/section')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCompositionSection(xml : TXmlBuilder; name : string; elem : TFhirCompositionSection);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'title', elem.titleElement);{x.2}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeReference{TFhirList}(xml, 'content', elem.content);{x.2}
  for i := 0 to elem.sectionList.Count - 1 do
    ComposeCompositionSection(xml, 'section', elem.sectionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCompositionSection(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionSection(jsn)); {2}
end;

function TFHIRJsonParser.ParseCompositionSection(jsn : TJsonObject) : TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('content') then
        result.content := ParseReference{TFhirList}(jsn.vObj['content']);{q}
    if jsn.has('section') then
      iterateArray(jsn.vArr['section'], result.sectionList, parseCompositionSection);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCompositionSection(json : TJSONWriter; name : string; elem : TFhirCompositionSection; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'title', elem.titleElement, false);
  ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeReference{TFhirList}(json, 'content', elem.content); {a}
  if elem.sectionList.Count > 0 then
  begin
    json.valueArray('section');
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(json, '',elem.sectionList[i]); {z - @Composition.section}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseComposition(element : IXmlDomElement; path : string) : TFhirComposition;
var
  child : IXMLDOMElement;
begin
  result := TFhirComposition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'class') then
        result.class_ := ParseCodeableConcept(child, path+'/class') {b}
      else if (child.baseName = 'title') then
        result.titleElement := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirCompositionStatus, path+'/status', child){1a}
      else if (child.baseName = 'confidentiality') then
        result.confidentialityElement := ParseCode(child, path+'/confidentiality') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.baseName = 'author') then
        result.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.baseName = 'attester') then
        result.attesterList.Add(ParseCompositionAttester(child, path+'/attester')){y.2}
      else if (child.baseName = 'custodian') then
        result.custodian := ParseReference{TFhirOrganization}(child, path+'/custodian') {b}
      else if (child.baseName = 'event') then
        result.eventList.Add(ParseCompositionEvent(child, path+'/event')){y.2}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'section') then
        result.sectionList.Add(ParseCompositionSection(child, path+'/section')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeComposition(xml : TXmlBuilder; name : string; elem : TFhirComposition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeCodeableConcept(xml, 'class', elem.class_);{x.2}
  ComposeString(xml, 'title', elem.titleElement);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCompositionStatus);
  ComposeCode(xml, 'confidentiality', elem.confidentialityElement);{x.2}
  ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2}
  for i := 0 to elem.authorList.Count - 1 do
    ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  for i := 0 to elem.attesterList.Count - 1 do
    ComposeCompositionAttester(xml, 'attester', elem.attesterList[i]);
  ComposeReference{TFhirOrganization}(xml, 'custodian', elem.custodian);{x.2}
  for i := 0 to elem.eventList.Count - 1 do
    ComposeCompositionEvent(xml, 'event', elem.eventList[i]);
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  for i := 0 to elem.sectionList.Count - 1 do
    ComposeCompositionSection(xml, 'section', elem.sectionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseComposition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseComposition(jsn)); {2}
end;

function TFHIRJsonParser.ParseComposition(jsn : TJsonObject) : TFhirComposition;
begin
  result := TFhirComposition.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('class') then
        result.class_ := ParseCodeableConcept(jsn.vObj['class']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirCompositionStatus);
    if jsn.has('confidentiality') or jsn.has('_confidentiality') then
        result.confidentialityElement := ParseCode(jsn['confidentiality'], jsn.vObj['_confidentiality']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{Resource});
    if jsn.has('attester') then
      iterateArray(jsn.vArr['attester'], result.attesterList, parseCompositionAttester);
    if jsn.has('custodian') then
        result.custodian := ParseReference{TFhirOrganization}(jsn.vObj['custodian']);{q}
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseCompositionEvent);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('section') then
      iterateArray(jsn.vArr['section'], result.sectionList, parseCompositionSection);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeComposition(json : TJSONWriter; name : string; elem : TFhirComposition; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeCodeableConcept(json, 'class', elem.class_); {a}
  ComposeStringValue(json, 'title', elem.titleElement, false);
  ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCompositionStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCompositionStatus, false);
  ComposeCodeValue(json, 'confidentiality', elem.confidentialityElement, false);
  ComposeCodeProps(json, 'confidentiality', elem.confidentialityElement, false);
  ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  if elem.authorList.Count > 0 then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.authorList[i]); {z - Reference(Practitioner|Device|Patient|RelatedPerson)}
    json.FinishArray;
  end;
  if elem.attesterList.Count > 0 then
  begin
    json.valueArray('attester');
    for i := 0 to elem.attesterList.Count - 1 do
      ComposeCompositionAttester(json, '',elem.attesterList[i]); {z - }
    json.FinishArray;
  end;
  ComposeReference{TFhirOrganization}(json, 'custodian', elem.custodian); {a}
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCompositionEvent(json, '',elem.eventList[i]); {z - }
    json.FinishArray;
  end;
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if elem.sectionList.Count > 0 then
  begin
    json.valueArray('section');
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(json, '',elem.sectionList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseConceptMapContact(element : IXmlDomElement; path : string) : TFhirConceptMapContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMapContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMapContact(xml : TXmlBuilder; name : string; elem : TFhirConceptMapContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMapContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMapContact(jsn : TJsonObject) : TFhirConceptMapContact;
begin
  result := TFhirConceptMapContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMapContact(json : TJSONWriter; name : string; elem : TFhirConceptMapContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConceptMapElement(element : IXmlDomElement; path : string) : TFhirConceptMapElement;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMapElement.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'codeSystem') then
        result.codeSystemElement := ParseUri(child, path+'/codeSystem') {b}
      else if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'dependsOn') then
        result.dependsOnList.Add(ParseConceptMapElementDependsOn(child, path+'/dependsOn')){y.2}
      else if (child.baseName = 'map') then
        result.mapList.Add(ParseConceptMapElementMap(child, path+'/map')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMapElement(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'codeSystem', elem.codeSystemElement);{x.2}
  ComposeCode(xml, 'code', elem.codeElement);{x.2}
  for i := 0 to elem.dependsOnList.Count - 1 do
    ComposeConceptMapElementDependsOn(xml, 'dependsOn', elem.dependsOnList[i]);
  for i := 0 to elem.mapList.Count - 1 do
    ComposeConceptMapElementMap(xml, 'map', elem.mapList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMapElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapElement(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMapElement(jsn : TJsonObject) : TFhirConceptMapElement;
begin
  result := TFhirConceptMapElement.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('codeSystem') or jsn.has('_codeSystem') then
        result.codeSystemElement := ParseUri(jsn['codeSystem'], jsn.vObj['_codeSystem']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('dependsOn') then
      iterateArray(jsn.vArr['dependsOn'], result.dependsOnList, parseConceptMapElementDependsOn);
    if jsn.has('map') then
      iterateArray(jsn.vArr['map'], result.mapList, parseConceptMapElementMap);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMapElement(json : TJSONWriter; name : string; elem : TFhirConceptMapElement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'codeSystem', elem.codeSystemElement, false);
  ComposeUriProps(json, 'codeSystem', elem.codeSystemElement, false);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  if elem.dependsOnList.Count > 0 then
  begin
    json.valueArray('dependsOn');
    for i := 0 to elem.dependsOnList.Count - 1 do
      ComposeConceptMapElementDependsOn(json, '',elem.dependsOnList[i]); {z - }
    json.FinishArray;
  end;
  if elem.mapList.Count > 0 then
  begin
    json.valueArray('map');
    for i := 0 to elem.mapList.Count - 1 do
      ComposeConceptMapElementMap(json, '',elem.mapList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConceptMapElementDependsOn(element : IXmlDomElement; path : string) : TFhirConceptMapElementDependsOn;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMapElementDependsOn.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'element') then
        result.elementElement := ParseUri(child, path+'/element') {b}
      else if (child.baseName = 'codeSystem') then
        result.codeSystemElement := ParseUri(child, path+'/codeSystem') {b}
      else if (child.baseName = 'code') then
        result.codeElement := ParseString(child, path+'/code') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMapElementDependsOn(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElementDependsOn);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'element', elem.elementElement);{x.2}
  ComposeUri(xml, 'codeSystem', elem.codeSystemElement);{x.2}
  ComposeString(xml, 'code', elem.codeElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMapElementDependsOn(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapElementDependsOn(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMapElementDependsOn(jsn : TJsonObject) : TFhirConceptMapElementDependsOn;
begin
  result := TFhirConceptMapElementDependsOn.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('element') or jsn.has('_element') then
        result.elementElement := ParseUri(jsn['element'], jsn.vObj['_element']);{q}
    if jsn.has('codeSystem') or jsn.has('_codeSystem') then
        result.codeSystemElement := ParseUri(jsn['codeSystem'], jsn.vObj['_codeSystem']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseString(jsn['code'], jsn.vObj['_code']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMapElementDependsOn(json : TJSONWriter; name : string; elem : TFhirConceptMapElementDependsOn; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'element', elem.elementElement, false);
  ComposeUriProps(json, 'element', elem.elementElement, false);
  ComposeUriValue(json, 'codeSystem', elem.codeSystemElement, false);
  ComposeUriProps(json, 'codeSystem', elem.codeSystemElement, false);
  ComposeStringValue(json, 'code', elem.codeElement, false);
  ComposeStringProps(json, 'code', elem.codeElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConceptMapElementMap(element : IXmlDomElement; path : string) : TFhirConceptMapElementMap;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMapElementMap.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'codeSystem') then
        result.codeSystemElement := ParseUri(child, path+'/codeSystem') {b}
      else if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'equivalence') then
        result.equivalenceElement := ParseEnum(CODES_TFhirConceptEquivalence, path+'/equivalence', child){1a}
      else if (child.baseName = 'comments') then
        result.commentsElement := ParseString(child, path+'/comments') {b}
      else if (child.baseName = 'product') then
        result.productList.Add(ParseConceptMapElementDependsOn(child, path+'/product')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMapElementMap(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElementMap);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'codeSystem', elem.codeSystemElement);{x.2}
  ComposeCode(xml, 'code', elem.codeElement);{x.2}
  ComposeEnum(xml, 'equivalence', elem.EquivalenceElement, CODES_TFhirConceptEquivalence);
  ComposeString(xml, 'comments', elem.commentsElement);{x.2}
  for i := 0 to elem.productList.Count - 1 do
    ComposeConceptMapElementDependsOn(xml, 'product', elem.productList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMapElementMap(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapElementMap(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMapElementMap(jsn : TJsonObject) : TFhirConceptMapElementMap;
begin
  result := TFhirConceptMapElementMap.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('codeSystem') or jsn.has('_codeSystem') then
        result.codeSystemElement := ParseUri(jsn['codeSystem'], jsn.vObj['_codeSystem']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('equivalence') or jsn.has('_equivalence')  then
      result.equivalenceElement := parseEnum(jsn['equivalence'], jsn.vObj['_equivalence'], CODES_TFhirConceptEquivalence);
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsElement := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    if jsn.has('product') then
      iterateArray(jsn.vArr['product'], result.productList, parseConceptMapElementDependsOn);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMapElementMap(json : TJSONWriter; name : string; elem : TFhirConceptMapElementMap; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'codeSystem', elem.codeSystemElement, false);
  ComposeUriProps(json, 'codeSystem', elem.codeSystemElement, false);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  ComposeEnumValue(json, 'equivalence', elem.EquivalenceElement, CODES_TFhirConceptEquivalence, false);
  ComposeEnumProps(json, 'equivalence', elem.EquivalenceElement, CODES_TFhirConceptEquivalence, false);
  ComposeStringValue(json, 'comments', elem.commentsElement, false);
  ComposeStringProps(json, 'comments', elem.commentsElement, false);
  if elem.productList.Count > 0 then
  begin
    json.valueArray('product');
    for i := 0 to elem.productList.Count - 1 do
      ComposeConceptMapElementDependsOn(json, '',elem.productList[i]); {z - @ConceptMap.element.dependsOn}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConceptMap(element : IXmlDomElement; path : string) : TFhirConceptMap;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMap.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'useContext') then
        result.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseConceptMapContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'requirements') then
        result.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'copyright') then
        result.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatus, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'sourceUri') then
        result.source := ParseUri(child, path+'/sourceUri'){x.3}
      else if (child.baseName = 'sourceReference') then
        result.source := ParseReference(child, path+'/sourceReference') {a}
      else if (child.baseName = 'targetUri') then
        result.target := ParseUri(child, path+'/targetUri'){x.3}
      else if (child.baseName = 'targetReference') then
        result.target := ParseReference(child, path+'/targetReference') {a}
      else if (child.baseName = 'element') then
        result.elementList.Add(ParseConceptMapElement(child, path+'/element')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMap(xml : TXmlBuilder; name : string; elem : TFhirConceptMap);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeString(xml, 'version', elem.versionElement);{x.2}
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  for i := 0 to elem.useContextList.Count - 1 do
    ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  for i := 0 to elem.contactList.Count - 1 do
    ComposeConceptMapContact(xml, 'contact', elem.contactList[i]);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeString(xml, 'requirements', elem.requirementsElement);{x.2}
  ComposeString(xml, 'copyright', elem.copyrightElement);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus);
  ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (elem.source is TFhirUri) {6} then
    ComposeUri(xml, 'sourceUri', TFhirUri(elem.source))
  else if (elem.source is TFhirReference) {2} then
    ComposeReference(xml, 'sourceReference', TFhirReference(elem.source));
  if (elem.target is TFhirUri) {6} then
    ComposeUri(xml, 'targetUri', TFhirUri(elem.target))
  else if (elem.target is TFhirReference) {2} then
    ComposeReference(xml, 'targetReference', TFhirReference(elem.target));
  for i := 0 to elem.elementList.Count - 1 do
    ComposeConceptMapElement(xml, 'element', elem.elementList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMap(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMap(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMap(jsn : TJsonObject) : TFhirConceptMap;
begin
  result := TFhirConceptMap.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseConceptMapContact);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatus);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('sourceUri') or jsn.has('_sourceUri') then
      result.source := parseUri(jsn['sourceUri'], jsn.vObj['_sourceUri']);
    if jsn.has('sourceReference') {a3} then
      result.source := ParseReference(jsn.vObj['sourceReference']);
    if jsn.has('targetUri') or jsn.has('_targetUri') then
      result.target := parseUri(jsn['targetUri'], jsn.vObj['_targetUri']);
    if jsn.has('targetReference') {a3} then
      result.target := ParseReference(jsn.vObj['targetReference']);
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseConceptMapElement);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMap(json : TJSONWriter; name : string; elem : TFhirConceptMap; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeStringValue(json, 'version', elem.versionElement, false);
  ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if elem.useContextList.Count > 0 then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.useContextList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if elem.contactList.Count > 0 then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeConceptMapContact(json, '',elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus, false);
  ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (elem.source is TFhirUri) then 
  begin
    ComposeUriValue(json, 'sourceUri', TFhirUri(elem.source), false);
    ComposeUriProps(json, 'sourceUri', TFhirUri(elem.source), false);
  end
  else if (elem.source is TFhirReference) then
    ComposeReference(json, 'sourceReference', TFhirReference(elem.source));
  if (elem.target is TFhirUri) then 
  begin
    ComposeUriValue(json, 'targetUri', TFhirUri(elem.target), false);
    ComposeUriProps(json, 'targetUri', TFhirUri(elem.target), false);
  end
  else if (elem.target is TFhirReference) then
    ComposeReference(json, 'targetReference', TFhirReference(elem.target));
  if elem.elementList.Count > 0 then
  begin
    json.valueArray('element');
    for i := 0 to elem.elementList.Count - 1 do
      ComposeConceptMapElement(json, '',elem.elementList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseConditionStage(element : IXmlDomElement; path : string) : TFhirConditionStage;
var
  child : IXMLDOMElement;
begin
  result := TFhirConditionStage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'summary') then
        result.summary := ParseCodeableConcept(child, path+'/summary') {b}
      else if (child.baseName = 'assessment') then
        result.assessmentList.Add(ParseReference{Resource}(child, path+'/assessment')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConditionStage(xml : TXmlBuilder; name : string; elem : TFhirConditionStage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'summary', elem.summary);{x.2}
  for i := 0 to elem.assessmentList.Count - 1 do
    ComposeReference{Resource}(xml, 'assessment', elem.assessmentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConditionStage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionStage(jsn)); {2}
end;

function TFHIRJsonParser.ParseConditionStage(jsn : TJsonObject) : TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('summary') then
        result.summary := ParseCodeableConcept(jsn.vObj['summary']);{q}
    if jsn.has('assessment') then
      iterateArray(jsn.vArr['assessment'], result.assessmentList, parseReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConditionStage(json : TJSONWriter; name : string; elem : TFhirConditionStage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'summary', elem.summary); {a}
  if elem.assessmentList.Count > 0 then
  begin
    json.valueArray('assessment');
    for i := 0 to elem.assessmentList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.assessmentList[i]); {z - Reference(ClinicalImpression|DiagnosticReport|Observation)}
      json.FinishArray;
    end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConditionEvidence(element : IXmlDomElement; path : string) : TFhirConditionEvidence;
var
  child : IXMLDOMElement;
begin
  result := TFhirConditionEvidence.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseReference{TFhirReference}(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConditionEvidence(xml : TXmlBuilder; name : string; elem : TFhirConditionEvidence);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  for i := 0 to elem.detailList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConditionEvidence(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionEvidence(jsn)); {2}
end;

function TFHIRJsonParser.ParseConditionEvidence(jsn : TJsonObject) : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConditionEvidence(json : TJSONWriter; name : string; elem : TFhirConditionEvidence; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if elem.detailList.Count > 0 then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.detailList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConditionLocation(element : IXmlDomElement; path : string) : TFhirConditionLocation;
var
  child : IXMLDOMElement;
begin
  result := TFhirConditionLocation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'siteCodeableConcept') then
        result.site := ParseCodeableConcept(child, path+'/siteCodeableConcept'){x.3}
      else if (child.baseName = 'siteReference') then
        result.site := ParseReference(child, path+'/siteReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConditionLocation(xml : TXmlBuilder; name : string; elem : TFhirConditionLocation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'siteCodeableConcept', TFhirCodeableConcept(elem.site))
  else if (elem.site is TFhirReference) {2} then
    ComposeReference(xml, 'siteReference', TFhirReference(elem.site));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConditionLocation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionLocation(jsn)); {2}
end;

function TFHIRJsonParser.ParseConditionLocation(jsn : TJsonObject) : TFhirConditionLocation;
begin
  result := TFhirConditionLocation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('siteCodeableConcept') {a4} then
      result.site := ParseCodeableConcept(jsn.vObj['siteCodeableConcept']);
    if jsn.has('siteReference') {a3} then
      result.site := ParseReference(jsn.vObj['siteReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConditionLocation(json : TJSONWriter; name : string; elem : TFhirConditionLocation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.site is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'siteCodeableConcept', TFhirCodeableConcept(elem.site)) 
  else if (elem.site is TFhirReference) then
    ComposeReference(json, 'siteReference', TFhirReference(elem.site));
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConditionDueTo(element : IXmlDomElement; path : string) : TFhirConditionDueTo;
var
  child : IXMLDOMElement;
begin
  result := TFhirConditionDueTo.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{Resource}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConditionDueTo(xml : TXmlBuilder; name : string; elem : TFhirConditionDueTo);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeReference{Resource}(xml, 'target', elem.target);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConditionDueTo(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionDueTo(jsn)); {2}
end;

function TFHIRJsonParser.ParseConditionDueTo(jsn : TJsonObject) : TFhirConditionDueTo;
begin
  result := TFhirConditionDueTo.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('target') then
        result.target := ParseReference{Resource}(jsn.vObj['target']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConditionDueTo(json : TJSONWriter; name : string; elem : TFhirConditionDueTo; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeReference{Resource}(json, 'target', elem.target); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConditionOccurredFollowing(element : IXmlDomElement; path : string) : TFhirConditionOccurredFollowing;
var
  child : IXMLDOMElement;
  begin
  result := TFhirConditionOccurredFollowing.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{Resource}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConditionOccurredFollowing(xml : TXmlBuilder; name : string; elem : TFhirConditionOccurredFollowing);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeReference{Resource}(xml, 'target', elem.target);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConditionOccurredFollowing(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionOccurredFollowing(jsn)); {2}
end;

function TFHIRJsonParser.ParseConditionOccurredFollowing(jsn : TJsonObject) : TFhirConditionOccurredFollowing;
begin
  result := TFhirConditionOccurredFollowing.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('target') then
        result.target := ParseReference{Resource}(jsn.vObj['target']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConditionOccurredFollowing(json : TJSONWriter; name : string; elem : TFhirConditionOccurredFollowing; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeReference{Resource}(json, 'target', elem.target); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseCondition(element : IXmlDomElement; path : string) : TFhirCondition;
var
  child : IXMLDOMElement;
begin
  result := TFhirCondition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'asserter') then
        result.asserter := ParseReference{Resource}(child, path+'/asserter') {b}
      else if (child.baseName = 'dateAsserted') then
        result.dateAssertedElement := ParseDate(child, path+'/dateAsserted') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'clinicalStatus') then
        result.clinicalStatusElement := ParseEnum(CODES_TFhirConditionStatus, path+'/clinicalStatus', child){1a}
      else if (child.baseName = 'severity') then
        result.severity := ParseCodeableConcept(child, path+'/severity') {b}
      else if (child.baseName = 'onsetDateTime') then
        result.onset := ParseDateTime(child, path+'/onsetDateTime'){x.3}
      else if (child.baseName = 'onsetAge') then
        result.onset := ParseAge(child, path+'/onsetAge'){x.3}
      else if (child.baseName = 'onsetPeriod') then
        result.onset := ParsePeriod(child, path+'/onsetPeriod'){x.3}
      else if (child.baseName = 'onsetRange') then
        result.onset := ParseRange(child, path+'/onsetRange'){x.3}
      else if (child.baseName = 'onsetString') then
        result.onset := ParseString(child, path+'/onsetString'){x.3}
      else if (child.baseName = 'abatementDate') then
        result.abatement := ParseDate(child, path+'/abatementDate'){x.3}
      else if (child.baseName = 'abatementAge') then
        result.abatement := ParseAge(child, path+'/abatementAge'){x.3}
      else if (child.baseName = 'abatementBoolean') then
        result.abatement := ParseBoolean(child, path+'/abatementBoolean'){x.3}
      else if (child.baseName = 'abatementPeriod') then
        result.abatement := ParsePeriod(child, path+'/abatementPeriod'){x.3}
      else if (child.baseName = 'abatementRange') then
        result.abatement := ParseRange(child, path+'/abatementRange'){x.3}
      else if (child.baseName = 'abatementString') then
        result.abatement := ParseString(child, path+'/abatementString'){x.3}
      else if (child.baseName = 'stage') then
        result.stage := ParseConditionStage(child, path+'/stage') {b}
      else if (child.baseName = 'evidence') then
        result.evidenceList.Add(ParseConditionEvidence(child, path+'/evidence')){y.2}
      else if (child.baseName = 'location') then
        result.locationList.Add(ParseConditionLocation(child, path+'/location')){y.2}
      else if (child.baseName = 'dueTo') then
        result.dueToList.Add(ParseConditionDueTo(child, path+'/dueTo')){y.2}
      else if (child.baseName = 'occurredFollowing') then
        result.occurredFollowingList.Add(ParseConditionOccurredFollowing(child, path+'/occurredFollowing')){y.2}
      else if (child.baseName = 'notes') then
        result.notesElement := ParseString(child, path+'/notes') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCondition(xml : TXmlBuilder; name : string; elem : TFhirCondition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  ComposeReference{Resource}(xml, 'asserter', elem.asserter);{x.2}
  ComposeDate(xml, 'dateAsserted', elem.dateAssertedElement);{x.2}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  ComposeEnum(xml, 'clinicalStatus', elem.ClinicalStatusElement, CODES_TFhirConditionStatus);
  ComposeCodeableConcept(xml, 'severity', elem.severity);{x.2}
  if (elem.onset is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'onsetDateTime', TFhirDateTime(elem.onset))
  else if (elem.onset is TFhirQuantity) {6} then
    ComposeAge(xml, 'onsetAge', TFhirQuantity(elem.onset))
  else if (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(xml, 'onsetPeriod', TFhirPeriod(elem.onset))
  else if (elem.onset is TFhirRange) {6} then
    ComposeRange(xml, 'onsetRange', TFhirRange(elem.onset))
  else if (elem.onset is TFhirString) {6} then
    ComposeString(xml, 'onsetString', TFhirString(elem.onset));
  if (elem.abatement is TFhirDate) {6} then
    ComposeDate(xml, 'abatementDate', TFhirDate(elem.abatement))
  else if (elem.abatement is TFhirQuantity) {6} then
    ComposeAge(xml, 'abatementAge', TFhirQuantity(elem.abatement))
  else if (elem.abatement is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'abatementBoolean', TFhirBoolean(elem.abatement))
  else if (elem.abatement is TFhirPeriod) {6} then
    ComposePeriod(xml, 'abatementPeriod', TFhirPeriod(elem.abatement))
  else if (elem.abatement is TFhirRange) {6} then
    ComposeRange(xml, 'abatementRange', TFhirRange(elem.abatement))
  else if (elem.abatement is TFhirString) {6} then
    ComposeString(xml, 'abatementString', TFhirString(elem.abatement));
  ComposeConditionStage(xml, 'stage', elem.stage);{x.2}
  for i := 0 to elem.evidenceList.Count - 1 do
    ComposeConditionEvidence(xml, 'evidence', elem.evidenceList[i]);
  for i := 0 to elem.locationList.Count - 1 do
    ComposeConditionLocation(xml, 'location', elem.locationList[i]);
  for i := 0 to elem.dueToList.Count - 1 do
    ComposeConditionDueTo(xml, 'dueTo', elem.dueToList[i]);
  for i := 0 to elem.occurredFollowingList.Count - 1 do
    ComposeConditionOccurredFollowing(xml, 'occurredFollowing', elem.occurredFollowingList[i]);
  ComposeString(xml, 'notes', elem.notesElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCondition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCondition(jsn)); {2}
end;

function TFHIRJsonParser.ParseCondition(jsn : TJsonObject) : TFhirCondition;
begin
  result := TFhirCondition.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('asserter') then
        result.asserter := ParseReference{Resource}(jsn.vObj['asserter']);{q}
    if jsn.has('dateAsserted') or jsn.has('_dateAsserted') then
        result.dateAssertedElement := ParseDate(jsn['dateAsserted'], jsn.vObj['_dateAsserted']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('clinicalStatus') or jsn.has('_clinicalStatus')  then
      result.clinicalStatusElement := parseEnum(jsn['clinicalStatus'], jsn.vObj['_clinicalStatus'], CODES_TFhirConditionStatus);
    if jsn.has('severity') then
        result.severity := ParseCodeableConcept(jsn.vObj['severity']);{q}
    if jsn.has('onsetDateTime') or jsn.has('_onsetDateTime') then
      result.onset := parseDateTime(jsn['onsetDateTime'], jsn.vObj['_onsetDateTime']);
    if jsn.has('onsetAge') {a4} then
      result.onset := ParseAge(jsn.vObj['onsetAge']);
    if jsn.has('onsetPeriod') {a4} then
      result.onset := ParsePeriod(jsn.vObj['onsetPeriod']);
    if jsn.has('onsetRange') {a4} then
      result.onset := ParseRange(jsn.vObj['onsetRange']);
    if jsn.has('onsetString') or jsn.has('_onsetString') then
      result.onset := parseString(jsn['onsetString'], jsn.vObj['_onsetString']);
    if jsn.has('abatementDate') or jsn.has('_abatementDate') then
      result.abatement := parseDate(jsn['abatementDate'], jsn.vObj['_abatementDate']);
    if jsn.has('abatementAge') {a4} then
      result.abatement := ParseAge(jsn.vObj['abatementAge']);
    if jsn.has('abatementBoolean') or jsn.has('_abatementBoolean') then
      result.abatement := parseBoolean(jsn['abatementBoolean'], jsn.vObj['_abatementBoolean']);
    if jsn.has('abatementPeriod') {a4} then
      result.abatement := ParsePeriod(jsn.vObj['abatementPeriod']);
    if jsn.has('abatementRange') {a4} then
      result.abatement := ParseRange(jsn.vObj['abatementRange']);
    if jsn.has('abatementString') or jsn.has('_abatementString') then
      result.abatement := parseString(jsn['abatementString'], jsn.vObj['_abatementString']);
    if jsn.has('stage') then
        result.stage := ParseConditionStage(jsn.vObj['stage']);{q}
    if jsn.has('evidence') then
      iterateArray(jsn.vArr['evidence'], result.evidenceList, parseConditionEvidence);
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseConditionLocation);
    if jsn.has('dueTo') then
      iterateArray(jsn.vArr['dueTo'], result.dueToList, parseConditionDueTo);
    if jsn.has('occurredFollowing') then
      iterateArray(jsn.vArr['occurredFollowing'], result.occurredFollowingList, parseConditionOccurredFollowing);
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesElement := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCondition(json : TJSONWriter; name : string; elem : TFhirCondition; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeReference{Resource}(json, 'asserter', elem.asserter); {a}
  ComposeDateValue(json, 'dateAsserted', elem.dateAssertedElement, false);
  ComposeDateProps(json, 'dateAsserted', elem.dateAssertedElement, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeEnumValue(json, 'clinicalStatus', elem.ClinicalStatusElement, CODES_TFhirConditionStatus, false);
  ComposeEnumProps(json, 'clinicalStatus', elem.ClinicalStatusElement, CODES_TFhirConditionStatus, false);
  ComposeCodeableConcept(json, 'severity', elem.severity); {a}
  if (elem.onset is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'onsetDateTime', TFhirDateTime(elem.onset), false);
    ComposeDateTimeProps(json, 'onsetDateTime', TFhirDateTime(elem.onset), false);
  end
  else if (elem.onset is TFhirQuantity) then 
    ComposeAge(json, 'onsetAge', TFhirQuantity(elem.onset)) 
  else if (elem.onset is TFhirPeriod) then 
    ComposePeriod(json, 'onsetPeriod', TFhirPeriod(elem.onset)) 
  else if (elem.onset is TFhirRange) then 
    ComposeRange(json, 'onsetRange', TFhirRange(elem.onset)) 
  else if (elem.onset is TFhirString) then 
  begin
    ComposeStringValue(json, 'onsetString', TFhirString(elem.onset), false);
    ComposeStringProps(json, 'onsetString', TFhirString(elem.onset), false);
  end;
  if (elem.abatement is TFhirDate) then 
  begin
    ComposeDateValue(json, 'abatementDate', TFhirDate(elem.abatement), false);
    ComposeDateProps(json, 'abatementDate', TFhirDate(elem.abatement), false);
  end
  else if (elem.abatement is TFhirQuantity) then 
    ComposeAge(json, 'abatementAge', TFhirQuantity(elem.abatement)) 
  else if (elem.abatement is TFhirBoolean) then 
    begin
    ComposeBooleanValue(json, 'abatementBoolean', TFhirBoolean(elem.abatement), false);
    ComposeBooleanProps(json, 'abatementBoolean', TFhirBoolean(elem.abatement), false);
  end
  else if (elem.abatement is TFhirPeriod) then 
    ComposePeriod(json, 'abatementPeriod', TFhirPeriod(elem.abatement)) 
  else if (elem.abatement is TFhirRange) then 
    ComposeRange(json, 'abatementRange', TFhirRange(elem.abatement)) 
  else if (elem.abatement is TFhirString) then 
  begin
    ComposeStringValue(json, 'abatementString', TFhirString(elem.abatement), false);
    ComposeStringProps(json, 'abatementString', TFhirString(elem.abatement), false);
    end;
  ComposeConditionStage(json, 'stage', elem.stage); {a}
  if elem.evidenceList.Count > 0 then
  begin
    json.valueArray('evidence');
    for i := 0 to elem.evidenceList.Count - 1 do
      ComposeConditionEvidence(json, '',elem.evidenceList[i]); {z - }
    json.FinishArray;
  end;
  if elem.locationList.Count > 0 then
    begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeConditionLocation(json, '',elem.locationList[i]); {z - }
      json.FinishArray;
    end;
  if elem.dueToList.Count > 0 then
  begin
    json.valueArray('dueTo');
    for i := 0 to elem.dueToList.Count - 1 do
      ComposeConditionDueTo(json, '',elem.dueToList[i]); {z - }
    json.FinishArray;
    end;
  if elem.occurredFollowingList.Count > 0 then
    begin
    json.valueArray('occurredFollowing');
    for i := 0 to elem.occurredFollowingList.Count - 1 do
      ComposeConditionOccurredFollowing(json, '',elem.occurredFollowingList[i]); {z - }
      json.FinishArray;
    end;
  ComposeStringValue(json, 'notes', elem.notesElement, false);
  ComposeStringProps(json, 'notes', elem.notesElement, false);
end;

function TFHIRXmlParser.ParseConformanceContact(element : IXmlDomElement; path : string) : TFhirConformanceContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceContact(xml : TXmlBuilder; name : string; elem : TFhirConformanceContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceContact(jsn : TJsonObject) : TFhirConformanceContact;
begin
  result := TFhirConformanceContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceContact(json : TJSONWriter; name : string; elem : TFhirConformanceContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceSoftware(element : IXmlDomElement; path : string) : TFhirConformanceSoftware;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceSoftware.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'releaseDate') then
        result.releaseDateElement := ParseDateTime(child, path+'/releaseDate') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceSoftware(xml : TXmlBuilder; name : string; elem : TFhirConformanceSoftware);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeString(xml, 'version', elem.versionElement);{x.2}
  ComposeDateTime(xml, 'releaseDate', elem.releaseDateElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceSoftware(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceSoftware(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceSoftware(jsn : TJsonObject) : TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('releaseDate') or jsn.has('_releaseDate') then
        result.releaseDateElement := ParseDateTime(jsn['releaseDate'], jsn.vObj['_releaseDate']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceSoftware(json : TJSONWriter; name : string; elem : TFhirConformanceSoftware; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeStringValue(json, 'version', elem.versionElement, false);
  ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeDateTimeValue(json, 'releaseDate', elem.releaseDateElement, false);
  ComposeDateTimeProps(json, 'releaseDate', elem.releaseDateElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceImplementation(element : IXmlDomElement; path : string) : TFhirConformanceImplementation;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceImplementation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceImplementation(xml : TXmlBuilder; name : string; elem : TFhirConformanceImplementation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceImplementation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceImplementation(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceImplementation(jsn : TJsonObject) : TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceImplementation(json : TJSONWriter; name : string; elem : TFhirConformanceImplementation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRest(element : IXmlDomElement; path : string) : TFhirConformanceRest;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRest.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'mode') then
        result.modeElement := ParseEnum(CODES_TFhirRestfulConformanceMode, path+'/mode', child){1a}
      else if (child.baseName = 'documentation') then
        result.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'security') then
        result.security := ParseConformanceRestSecurity(child, path+'/security') {b}
      else if (child.baseName = 'resource') then
        result.resourceList.Add(ParseConformanceRestResource(child, path+'/resource')){y.2}
      else if (child.baseName = 'interaction') then
        result.interactionList.Add(ParseConformanceRestInteraction(child, path+'/interaction')){y.2}
      else if (child.baseName = 'operation') then
        result.operationList.Add(ParseConformanceRestOperation(child, path+'/operation')){y.2}
      else if (child.baseName = 'documentMailbox') then
        result.documentMailboxList.Add(ParseUri(child, path+'/documentMailbox')){y.2}
      else if (child.baseName = 'compartment') then
        result.compartmentList.Add(ParseUri(child, path+'/compartment')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRest(xml : TXmlBuilder; name : string; elem : TFhirConformanceRest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirRestfulConformanceMode);
  ComposeString(xml, 'documentation', elem.documentationElement);{x.2}
  ComposeConformanceRestSecurity(xml, 'security', elem.security);{x.2}
  for i := 0 to elem.resourceList.Count - 1 do
    ComposeConformanceRestResource(xml, 'resource', elem.resourceList[i]);
  for i := 0 to elem.interactionList.Count - 1 do
    ComposeConformanceRestInteraction(xml, 'interaction', elem.interactionList[i]);
  for i := 0 to elem.operationList.Count - 1 do
    ComposeConformanceRestOperation(xml, 'operation', elem.operationList[i]);
  for i := 0 to elem.documentMailboxList.Count - 1 do
    ComposeUri(xml, 'documentMailbox', elem.documentMailboxList[i]);
  for i := 0 to elem.compartmentList.Count - 1 do
    ComposeUri(xml, 'compartment', elem.compartmentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRest(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRest(jsn : TJsonObject) : TFhirConformanceRest;
begin
  result := TFhirConformanceRest.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn['mode'], jsn.vObj['_mode'], CODES_TFhirRestfulConformanceMode);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('security') then
        result.security := ParseConformanceRestSecurity(jsn.vObj['security']);{q}
    if jsn.has('resource') then
      iterateArray(jsn.vArr['resource'], result.resourceList, parseConformanceRestResource);
    if jsn.has('interaction') then
      iterateArray(jsn.vArr['interaction'], result.interactionList, parseConformanceRestInteraction);
    if jsn.has('operation') then
      iterateArray(jsn.vArr['operation'], result.operationList, parseConformanceRestOperation);
      if jsn.has('documentMailbox') or jsn.has('_documentMailbox') then
      iteratePrimitiveArray(jsn.vArr['documentMailbox'], jsn.vArr['_documentMailbox'], result.documentMailboxList, parseUri);
      if jsn.has('compartment') or jsn.has('_compartment') then
      iteratePrimitiveArray(jsn.vArr['compartment'], jsn.vArr['_compartment'], result.compartmentList, parseUri);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRest(json : TJSONWriter; name : string; elem : TFhirConformanceRest; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirRestfulConformanceMode, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirRestfulConformanceMode, false);
  ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  ComposeConformanceRestSecurity(json, 'security', elem.security); {a}
  if elem.resourceList.Count > 0 then
  begin
    json.valueArray('resource');
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeConformanceRestResource(json, '',elem.resourceList[i]); {z - }
    json.FinishArray;
  end;
  if elem.interactionList.Count > 0 then
  begin
    json.valueArray('interaction');
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeConformanceRestInteraction(json, '',elem.interactionList[i]); {z - }
    json.FinishArray;
  end;
  if elem.operationList.Count > 0 then
  begin
    json.valueArray('operation');
    for i := 0 to elem.operationList.Count - 1 do
      ComposeConformanceRestOperation(json, '',elem.operationList[i]); {z - }
    json.FinishArray;
end;
  if elem.documentMailboxList.Count > 0 then
begin
    json.valueArray('documentMailbox');
    ext := false;
    for i := 0 to elem.documentMailboxList.Count - 1 do
    begin
      ext := ext or ((elem.documentMailboxList[i].id <> '') or (elem.documentMailboxList[i].hasExtensionList));
      ComposeUriValue(json, '',elem.documentMailboxList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_documentMailbox');
      for i := 0 to elem.documentMailboxList.Count - 1 do
        ComposeUriProps(json, '',elem.documentMailboxList[i], true);
      json.FinishArray;
  end;
end;
  if elem.compartmentList.Count > 0 then
begin
    json.valueArray('compartment');
    ext := false;
    for i := 0 to elem.compartmentList.Count - 1 do
begin
      ext := ext or ((elem.compartmentList[i].id <> '') or (elem.compartmentList[i].hasExtensionList));
      ComposeUriValue(json, '',elem.compartmentList[i], true);
end;
    json.FinishArray;
    if ext then
begin
      json.valueArray('_compartment');
      for i := 0 to elem.compartmentList.Count - 1 do
        ComposeUriProps(json, '',elem.compartmentList[i], true);
      json.FinishArray;
  end;
end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestSecurity(element : IXmlDomElement; path : string) : TFhirConformanceRestSecurity;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'cors') then
        result.corsElement := ParseBoolean(child, path+'/cors') {b}
      else if (child.baseName = 'service') then
        result.serviceList.Add(ParseCodeableConcept(child, path+'/service')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'certificate') then
        result.certificateList.Add(ParseConformanceRestSecurityCertificate(child, path+'/certificate')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestSecurity(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurity);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeBoolean(xml, 'cors', elem.corsElement);{x.2}
  for i := 0 to elem.serviceList.Count - 1 do
    ComposeCodeableConcept(xml, 'service', elem.serviceList[i]);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  for i := 0 to elem.certificateList.Count - 1 do
    ComposeConformanceRestSecurityCertificate(xml, 'certificate', elem.certificateList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestSecurity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestSecurity(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestSecurity(jsn : TJsonObject) : TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('cors') or jsn.has('_cors') then
        result.corsElement := ParseBoolean(jsn['cors'], jsn.vObj['_cors']);{q}
    if jsn.has('service') then
      iterateArray(jsn.vArr['service'], result.serviceList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('certificate') then
      iterateArray(jsn.vArr['certificate'], result.certificateList, parseConformanceRestSecurityCertificate);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestSecurity(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurity; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeBooleanValue(json, 'cors', elem.corsElement, false);
  ComposeBooleanProps(json, 'cors', elem.corsElement, false);
  if elem.serviceList.Count > 0 then
  begin
    json.valueArray('service');
    for i := 0 to elem.serviceList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.serviceList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if elem.certificateList.Count > 0 then
  begin
    json.valueArray('certificate');
    for i := 0 to elem.certificateList.Count - 1 do
      ComposeConformanceRestSecurityCertificate(json, '',elem.certificateList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestSecurityCertificate(element : IXmlDomElement; path : string) : TFhirConformanceRestSecurityCertificate;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseCode(child, path+'/type') {b}
      else if (child.baseName = 'blob') then
        result.blobElement := ParseBase64Binary(child, path+'/blob') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestSecurityCertificate(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurityCertificate);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'type', elem.type_Element);{x.2}
  ComposeBase64Binary(xml, 'blob', elem.blobElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestSecurityCertificate(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestSecurityCertificate(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestSecurityCertificate(jsn : TJsonObject) : TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := ParseCode(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('blob') or jsn.has('_blob') then
        result.blobElement := ParseBase64Binary(jsn['blob'], jsn.vObj['_blob']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestSecurityCertificate(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurityCertificate; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'type', elem.type_Element, false);
  ComposeCodeProps(json, 'type', elem.type_Element, false);
  ComposeBase64BinaryValue(json, 'blob', elem.blobElement, false);
  ComposeBase64BinaryProps(json, 'blob', elem.blobElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestResource(element : IXmlDomElement; path : string) : TFhirConformanceRestResource;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestResource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseCode(child, path+'/type') {b}
      else if (child.baseName = 'profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if (child.baseName = 'interaction') then
        result.interactionList.Add(ParseConformanceRestResourceInteraction(child, path+'/interaction')){y.2}
      else if (child.baseName = 'versioning') then
        result.versioningElement := ParseEnum(CODES_TFhirVersioningPolicy, path+'/versioning', child){1a}
      else if (child.baseName = 'readHistory') then
        result.readHistoryElement := ParseBoolean(child, path+'/readHistory') {b}
      else if (child.baseName = 'updateCreate') then
        result.updateCreateElement := ParseBoolean(child, path+'/updateCreate') {b}
      else if (child.baseName = 'conditionalCreate') then
        result.conditionalCreateElement := ParseBoolean(child, path+'/conditionalCreate') {b}
      else if (child.baseName = 'conditionalUpdate') then
        result.conditionalUpdateElement := ParseBoolean(child, path+'/conditionalUpdate') {b}
      else if (child.baseName = 'conditionalDelete') then
        result.conditionalDeleteElement := ParseBoolean(child, path+'/conditionalDelete') {b}
      else if (child.baseName = 'searchInclude') then
        result.searchIncludeList.Add(ParseString(child, path+'/searchInclude')){y.2}
      else if (child.baseName = 'searchParam') then
        result.searchParamList.Add(ParseConformanceRestResourceSearchParam(child, path+'/searchParam')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResource(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResource);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'type', elem.type_Element);{x.2}
  ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2}
  for i := 0 to elem.interactionList.Count - 1 do
    ComposeConformanceRestResourceInteraction(xml, 'interaction', elem.interactionList[i]);
  ComposeEnum(xml, 'versioning', elem.VersioningElement, CODES_TFhirVersioningPolicy);
  ComposeBoolean(xml, 'readHistory', elem.readHistoryElement);{x.2}
  ComposeBoolean(xml, 'updateCreate', elem.updateCreateElement);{x.2}
  ComposeBoolean(xml, 'conditionalCreate', elem.conditionalCreateElement);{x.2}
  ComposeBoolean(xml, 'conditionalUpdate', elem.conditionalUpdateElement);{x.2}
  ComposeBoolean(xml, 'conditionalDelete', elem.conditionalDeleteElement);{x.2}
  for i := 0 to elem.searchIncludeList.Count - 1 do
    ComposeString(xml, 'searchInclude', elem.searchIncludeList[i]);
  for i := 0 to elem.searchParamList.Count - 1 do
    ComposeConformanceRestResourceSearchParam(xml, 'searchParam', elem.searchParamList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestResource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestResource(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestResource(jsn : TJsonObject) : TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := ParseCode(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(jsn.vObj['profile']);{q}
    if jsn.has('interaction') then
      iterateArray(jsn.vArr['interaction'], result.interactionList, parseConformanceRestResourceInteraction);
    if jsn.has('versioning') or jsn.has('_versioning')  then
      result.versioningElement := parseEnum(jsn['versioning'], jsn.vObj['_versioning'], CODES_TFhirVersioningPolicy);
    if jsn.has('readHistory') or jsn.has('_readHistory') then
        result.readHistoryElement := ParseBoolean(jsn['readHistory'], jsn.vObj['_readHistory']);{q}
    if jsn.has('updateCreate') or jsn.has('_updateCreate') then
        result.updateCreateElement := ParseBoolean(jsn['updateCreate'], jsn.vObj['_updateCreate']);{q}
    if jsn.has('conditionalCreate') or jsn.has('_conditionalCreate') then
        result.conditionalCreateElement := ParseBoolean(jsn['conditionalCreate'], jsn.vObj['_conditionalCreate']);{q}
    if jsn.has('conditionalUpdate') or jsn.has('_conditionalUpdate') then
        result.conditionalUpdateElement := ParseBoolean(jsn['conditionalUpdate'], jsn.vObj['_conditionalUpdate']);{q}
    if jsn.has('conditionalDelete') or jsn.has('_conditionalDelete') then
        result.conditionalDeleteElement := ParseBoolean(jsn['conditionalDelete'], jsn.vObj['_conditionalDelete']);{q}
      if jsn.has('searchInclude') or jsn.has('_searchInclude') then
      iteratePrimitiveArray(jsn.vArr['searchInclude'], jsn.vArr['_searchInclude'], result.searchIncludeList, parseString);
    if jsn.has('searchParam') then
      iterateArray(jsn.vArr['searchParam'], result.searchParamList, parseConformanceRestResourceSearchParam);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestResource(json : TJSONWriter; name : string; elem : TFhirConformanceRestResource; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'type', elem.type_Element, false);
  ComposeCodeProps(json, 'type', elem.type_Element, false);
  ComposeReference{TFhirStructureDefinition}(json, 'profile', elem.profile); {a}
  if elem.interactionList.Count > 0 then
  begin
    json.valueArray('interaction');
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeConformanceRestResourceInteraction(json, '',elem.interactionList[i]); {z - }
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'versioning', elem.VersioningElement, CODES_TFhirVersioningPolicy, false);
  ComposeEnumProps(json, 'versioning', elem.VersioningElement, CODES_TFhirVersioningPolicy, false);
  ComposeBooleanValue(json, 'readHistory', elem.readHistoryElement, false);
  ComposeBooleanProps(json, 'readHistory', elem.readHistoryElement, false);
  ComposeBooleanValue(json, 'updateCreate', elem.updateCreateElement, false);
  ComposeBooleanProps(json, 'updateCreate', elem.updateCreateElement, false);
  ComposeBooleanValue(json, 'conditionalCreate', elem.conditionalCreateElement, false);
  ComposeBooleanProps(json, 'conditionalCreate', elem.conditionalCreateElement, false);
  ComposeBooleanValue(json, 'conditionalUpdate', elem.conditionalUpdateElement, false);
  ComposeBooleanProps(json, 'conditionalUpdate', elem.conditionalUpdateElement, false);
  ComposeBooleanValue(json, 'conditionalDelete', elem.conditionalDeleteElement, false);
  ComposeBooleanProps(json, 'conditionalDelete', elem.conditionalDeleteElement, false);
  if elem.searchIncludeList.Count > 0 then
  begin
    json.valueArray('searchInclude');
    ext := false;
    for i := 0 to elem.searchIncludeList.Count - 1 do
    begin
      ext := ext or ((elem.searchIncludeList[i].id <> '') or (elem.searchIncludeList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.searchIncludeList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_searchInclude');
      for i := 0 to elem.searchIncludeList.Count - 1 do
        ComposeStringProps(json, '',elem.searchIncludeList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.searchParamList.Count > 0 then
  begin
    json.valueArray('searchParam');
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeConformanceRestResourceSearchParam(json, '',elem.searchParamList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestResourceInteraction(element : IXmlDomElement; path : string) : TFhirConformanceRestResourceInteraction;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestResourceInteraction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeElement := ParseEnum(CODES_TFhirTypeRestfulInteraction, path+'/code', child){1a}
      else if (child.baseName = 'documentation') then
        result.documentationElement := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResourceInteraction(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceInteraction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirTypeRestfulInteraction);
  ComposeString(xml, 'documentation', elem.documentationElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestResourceInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestResourceInteraction(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestResourceInteraction(jsn : TJsonObject) : TFhirConformanceRestResourceInteraction;
begin
  result := TFhirConformanceRestResourceInteraction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn['code'], jsn.vObj['_code'], CODES_TFhirTypeRestfulInteraction);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestResourceInteraction(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceInteraction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirTypeRestfulInteraction, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirTypeRestfulInteraction, false);
  ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestResourceSearchParam(element : IXmlDomElement; path : string) : TFhirConformanceRestResourceSearchParam;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'definition') then
        result.definitionElement := ParseUri(child, path+'/definition') {b}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirSearchParamType, path+'/type', child){1a}
      else if (child.baseName = 'documentation') then
        result.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'target') then
        result.targetList.Add(ParseCode(child, path+'/target')){y.2}
      else if (child.baseName = 'chain') then
        result.chainList.Add(ParseString(child, path+'/chain')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResourceSearchParam(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceSearchParam);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeUri(xml, 'definition', elem.definitionElement);{x.2}
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirSearchParamType);
  ComposeString(xml, 'documentation', elem.documentationElement);{x.2}
  for i := 0 to elem.targetList.Count - 1 do
    ComposeCode(xml, 'target', elem.targetList[i]);
  for i := 0 to elem.chainList.Count - 1 do
    ComposeString(xml, 'chain', elem.chainList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestResourceSearchParam(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestResourceSearchParam(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestResourceSearchParam(jsn : TJsonObject) : TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := ParseUri(jsn['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirSearchParamType);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
      if jsn.has('target') or jsn.has('_target') then
      iteratePrimitiveArray(jsn.vArr['target'], jsn.vArr['_target'], result.targetList, parseCode);
      if jsn.has('chain') or jsn.has('_chain') then
      iteratePrimitiveArray(jsn.vArr['chain'], jsn.vArr['_chain'], result.chainList, parseString);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestResourceSearchParam(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceSearchParam; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeUriValue(json, 'definition', elem.definitionElement, false);
  ComposeUriProps(json, 'definition', elem.definitionElement, false);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirSearchParamType, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirSearchParamType, false);
  ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if elem.targetList.Count > 0 then
  begin
    json.valueArray('target');
    ext := false;
    for i := 0 to elem.targetList.Count - 1 do
  begin
      ext := ext or ((elem.targetList[i].id <> '') or (elem.targetList[i].hasExtensionList));
      ComposeCodeValue(json, '',elem.targetList[i], true);
    end;
    json.FinishArray;
    if ext then
  begin
      json.valueArray('_target');
      for i := 0 to elem.targetList.Count - 1 do
        ComposeCodeProps(json, '',elem.targetList[i], true);
    json.FinishArray;
  end;
  end;
  if elem.chainList.Count > 0 then
  begin
    json.valueArray('chain');
    ext := false;
    for i := 0 to elem.chainList.Count - 1 do
  begin
      ext := ext or ((elem.chainList[i].id <> '') or (elem.chainList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.chainList[i], true);
    end;
    json.FinishArray;
    if ext then
  begin
      json.valueArray('_chain');
      for i := 0 to elem.chainList.Count - 1 do
        ComposeStringProps(json, '',elem.chainList[i], true);
    json.FinishArray;
  end;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestInteraction(element : IXmlDomElement; path : string) : TFhirConformanceRestInteraction;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestInteraction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeElement := ParseEnum(CODES_TFhirSystemRestfulInteraction, path+'/code', child){1a}
      else if (child.baseName = 'documentation') then
        result.documentationElement := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestInteraction(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestInteraction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirSystemRestfulInteraction);
  ComposeString(xml, 'documentation', elem.documentationElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestInteraction(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestInteraction(jsn : TJsonObject) : TFhirConformanceRestInteraction;
begin
  result := TFhirConformanceRestInteraction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn['code'], jsn.vObj['_code'], CODES_TFhirSystemRestfulInteraction);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestInteraction(json : TJSONWriter; name : string; elem : TFhirConformanceRestInteraction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirSystemRestfulInteraction, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirSystemRestfulInteraction, false);
  ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestOperation(element : IXmlDomElement; path : string) : TFhirConformanceRestOperation;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestOperation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'definition') then
        result.definition := ParseReference{TFhirOperationDefinition}(child, path+'/definition') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestOperation(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestOperation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeReference{TFhirOperationDefinition}(xml, 'definition', elem.definition);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestOperation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestOperation(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestOperation(jsn : TJsonObject) : TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('definition') then
        result.definition := ParseReference{TFhirOperationDefinition}(jsn.vObj['definition']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestOperation(json : TJSONWriter; name : string; elem : TFhirConformanceRestOperation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeReference{TFhirOperationDefinition}(json, 'definition', elem.definition); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceMessaging(element : IXmlDomElement; path : string) : TFhirConformanceMessaging;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceMessaging.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'endpoint') then
        result.endpointElement := ParseUri(child, path+'/endpoint') {b}
      else if (child.baseName = 'reliableCache') then
        result.reliableCacheElement := ParseUnsignedInt(child, path+'/reliableCache') {b}
      else if (child.baseName = 'documentation') then
        result.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'event') then
        result.eventList.Add(ParseConformanceMessagingEvent(child, path+'/event')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceMessaging(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessaging);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'endpoint', elem.endpointElement);{x.2}
  ComposeUnsignedInt(xml, 'reliableCache', elem.reliableCacheElement);{x.2}
  ComposeString(xml, 'documentation', elem.documentationElement);{x.2}
  for i := 0 to elem.eventList.Count - 1 do
    ComposeConformanceMessagingEvent(xml, 'event', elem.eventList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceMessaging(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceMessaging(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceMessaging(jsn : TJsonObject) : TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpointElement := ParseUri(jsn['endpoint'], jsn.vObj['_endpoint']);{q}
    if jsn.has('reliableCache') or jsn.has('_reliableCache') then
        result.reliableCacheElement := ParseUnsignedInt(jsn['reliableCache'], jsn.vObj['_reliableCache']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseConformanceMessagingEvent);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceMessaging(json : TJSONWriter; name : string; elem : TFhirConformanceMessaging; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'endpoint', elem.endpointElement, false);
  ComposeUriProps(json, 'endpoint', elem.endpointElement, false);
  ComposeUnsignedIntValue(json, 'reliableCache', elem.reliableCacheElement, false);
  ComposeUnsignedIntProps(json, 'reliableCache', elem.reliableCacheElement, false);
  ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeConformanceMessagingEvent(json, '',elem.eventList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceMessagingEvent(element : IXmlDomElement; path : string) : TFhirConformanceMessagingEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCoding(child, path+'/code') {b}
      else if (child.baseName = 'category') then
        result.categoryElement := ParseEnum(CODES_TFhirMessageSignificanceCategory, path+'/category', child){1a}
      else if (child.baseName = 'mode') then
        result.modeElement := ParseEnum(CODES_TFhirMessageConformanceEventMode, path+'/mode', child){1a}
      else if (child.baseName = 'protocol') then
        result.protocolList.Add(ParseCoding(child, path+'/protocol')){y.2}
      else if (child.baseName = 'focus') then
        result.focusElement := ParseCode(child, path+'/focus') {b}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirStructureDefinition}(child, path+'/request') {b}
      else if (child.baseName = 'response') then
        result.response := ParseReference{TFhirStructureDefinition}(child, path+'/response') {b}
      else if (child.baseName = 'documentation') then
        result.documentationElement := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceMessagingEvent(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessagingEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'code', elem.code);{x.2}
  ComposeEnum(xml, 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategory);
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirMessageConformanceEventMode);
  for i := 0 to elem.protocolList.Count - 1 do
    ComposeCoding(xml, 'protocol', elem.protocolList[i]);
  ComposeCode(xml, 'focus', elem.focusElement);{x.2}
  ComposeReference{TFhirStructureDefinition}(xml, 'request', elem.request);{x.2}
  ComposeReference{TFhirStructureDefinition}(xml, 'response', elem.response);{x.2}
  ComposeString(xml, 'documentation', elem.documentationElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceMessagingEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceMessagingEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceMessagingEvent(jsn : TJsonObject) : TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q}
    if jsn.has('category') or jsn.has('_category')  then
      result.categoryElement := parseEnum(jsn['category'], jsn.vObj['_category'], CODES_TFhirMessageSignificanceCategory);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn['mode'], jsn.vObj['_mode'], CODES_TFhirMessageConformanceEventMode);
    if jsn.has('protocol') then
      iterateArray(jsn.vArr['protocol'], result.protocolList, parseCoding);
    if jsn.has('focus') or jsn.has('_focus') then
        result.focusElement := ParseCode(jsn['focus'], jsn.vObj['_focus']);{q}
    if jsn.has('request') then
        result.request := ParseReference{TFhirStructureDefinition}(jsn.vObj['request']);{q}
    if jsn.has('response') then
        result.response := ParseReference{TFhirStructureDefinition}(jsn.vObj['response']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceMessagingEvent(json : TJSONWriter; name : string; elem : TFhirConformanceMessagingEvent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'code', elem.code); {a}
  ComposeEnumValue(json, 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategory, false);
  ComposeEnumProps(json, 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategory, false);
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirMessageConformanceEventMode, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirMessageConformanceEventMode, false);
  if elem.protocolList.Count > 0 then
  begin
    json.valueArray('protocol');
    for i := 0 to elem.protocolList.Count - 1 do
      ComposeCoding(json, '',elem.protocolList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeCodeValue(json, 'focus', elem.focusElement, false);
  ComposeCodeProps(json, 'focus', elem.focusElement, false);
  ComposeReference{TFhirStructureDefinition}(json, 'request', elem.request); {a}
  ComposeReference{TFhirStructureDefinition}(json, 'response', elem.response); {a}
  ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceDocument(element : IXmlDomElement; path : string) : TFhirConformanceDocument;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceDocument.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'mode') then
        result.modeElement := ParseEnum(CODES_TFhirDocumentMode, path+'/mode', child){1a}
      else if (child.baseName = 'documentation') then
        result.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceDocument(xml : TXmlBuilder; name : string; elem : TFhirConformanceDocument);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirDocumentMode);
  ComposeString(xml, 'documentation', elem.documentationElement);{x.2}
  ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceDocument(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceDocument(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceDocument(jsn : TJsonObject) : TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn['mode'], jsn.vObj['_mode'], CODES_TFhirDocumentMode);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(jsn.vObj['profile']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceDocument(json : TJSONWriter; name : string; elem : TFhirConformanceDocument; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirDocumentMode, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirDocumentMode, false);
  ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  ComposeReference{TFhirStructureDefinition}(json, 'profile', elem.profile); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseConformance(element : IXmlDomElement; path : string) : TFhirConformance;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformance.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseConformanceContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'requirements') then
        result.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'copyright') then
        result.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatus, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'software') then
        result.software := ParseConformanceSoftware(child, path+'/software') {b}
      else if (child.baseName = 'implementation') then
        result.implementation_ := ParseConformanceImplementation(child, path+'/implementation') {b}
      else if (child.baseName = 'fhirVersion') then
        result.fhirVersionElement := ParseId(child, path+'/fhirVersion') {b}
      else if (child.baseName = 'acceptUnknown') then
        result.acceptUnknownElement := ParseBoolean(child, path+'/acceptUnknown') {b}
      else if (child.baseName = 'format') then
        result.formatList.Add(ParseCode(child, path+'/format')){y.2}
      else if (child.baseName = 'profile') then
        result.profileList.Add(ParseReference{TFhirStructureDefinition}(child, path+'/profile')){y.2}
      else if (child.baseName = 'rest') then
        result.restList.Add(ParseConformanceRest(child, path+'/rest')){y.2}
      else if (child.baseName = 'messaging') then
        result.messagingList.Add(ParseConformanceMessaging(child, path+'/messaging')){y.2}
      else if (child.baseName = 'document') then
        result.documentList.Add(ParseConformanceDocument(child, path+'/document')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformance(xml : TXmlBuilder; name : string; elem : TFhirConformance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  ComposeString(xml, 'version', elem.versionElement);{x.2}
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  for i := 0 to elem.contactList.Count - 1 do
    ComposeConformanceContact(xml, 'contact', elem.contactList[i]);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeString(xml, 'requirements', elem.requirementsElement);{x.2}
  ComposeString(xml, 'copyright', elem.copyrightElement);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus);
  ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeConformanceSoftware(xml, 'software', elem.software);{x.2}
  ComposeConformanceImplementation(xml, 'implementation', elem.implementation_);{x.2}
  ComposeId(xml, 'fhirVersion', elem.fhirVersionElement);{x.2}
  ComposeBoolean(xml, 'acceptUnknown', elem.acceptUnknownElement);{x.2}
  for i := 0 to elem.formatList.Count - 1 do
    ComposeCode(xml, 'format', elem.formatList[i]);
  for i := 0 to elem.profileList.Count - 1 do
    ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profileList[i]);
  for i := 0 to elem.restList.Count - 1 do
    ComposeConformanceRest(xml, 'rest', elem.restList[i]);
  for i := 0 to elem.messagingList.Count - 1 do
    ComposeConformanceMessaging(xml, 'messaging', elem.messagingList[i]);
  for i := 0 to elem.documentList.Count - 1 do
    ComposeConformanceDocument(xml, 'document', elem.documentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformance(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformance(jsn : TJsonObject) : TFhirConformance;
begin
  result := TFhirConformance.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseConformanceContact);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatus);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('software') then
        result.software := ParseConformanceSoftware(jsn.vObj['software']);{q}
    if jsn.has('implementation') then
        result.implementation_ := ParseConformanceImplementation(jsn.vObj['implementation']);{q}
    if jsn.has('fhirVersion') or jsn.has('_fhirVersion') then
        result.fhirVersionElement := ParseId(jsn['fhirVersion'], jsn.vObj['_fhirVersion']);{q}
    if jsn.has('acceptUnknown') or jsn.has('_acceptUnknown') then
        result.acceptUnknownElement := ParseBoolean(jsn['acceptUnknown'], jsn.vObj['_acceptUnknown']);{q}
      if jsn.has('format') or jsn.has('_format') then
      iteratePrimitiveArray(jsn.vArr['format'], jsn.vArr['_format'], result.formatList, parseCode);
    if jsn.has('profile') then
      iterateArray(jsn.vArr['profile'], result.profileList, parseReference{TFhirStructureDefinition});
    if jsn.has('rest') then
      iterateArray(jsn.vArr['rest'], result.restList, parseConformanceRest);
    if jsn.has('messaging') then
      iterateArray(jsn.vArr['messaging'], result.messagingList, parseConformanceMessaging);
    if jsn.has('document') then
      iterateArray(jsn.vArr['document'], result.documentList, parseConformanceDocument);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformance(json : TJSONWriter; name : string; elem : TFhirConformance; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  ComposeStringValue(json, 'version', elem.versionElement, false);
  ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if elem.contactList.Count > 0 then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeConformanceContact(json, '',elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus, false);
  ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeConformanceSoftware(json, 'software', elem.software); {a}
  ComposeConformanceImplementation(json, 'implementation', elem.implementation_); {a}
  ComposeIdValue(json, 'fhirVersion', elem.fhirVersionElement, false);
  ComposeIdProps(json, 'fhirVersion', elem.fhirVersionElement, false);
  ComposeBooleanValue(json, 'acceptUnknown', elem.acceptUnknownElement, false);
  ComposeBooleanProps(json, 'acceptUnknown', elem.acceptUnknownElement, false);
  if elem.formatList.Count > 0 then
  begin
    json.valueArray('format');
    ext := false;
    for i := 0 to elem.formatList.Count - 1 do
  begin
      ext := ext or ((elem.formatList[i].id <> '') or (elem.formatList[i].hasExtensionList));
      ComposeCodeValue(json, '',elem.formatList[i], true);
  end;
    json.FinishArray;
    if ext then
  begin
      json.valueArray('_format');
      for i := 0 to elem.formatList.Count - 1 do
        ComposeCodeProps(json, '',elem.formatList[i], true);
    json.FinishArray;
  end;
  end;
  if elem.profileList.Count > 0 then
  begin
    json.valueArray('profile');
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirStructureDefinition}(json, '',elem.profileList[i]); {z - Reference(StructureDefinition)}
    json.FinishArray;
  end;
  if elem.restList.Count > 0 then
  begin
    json.valueArray('rest');
    for i := 0 to elem.restList.Count - 1 do
      ComposeConformanceRest(json, '',elem.restList[i]); {z - }
    json.FinishArray;
  end;
  if elem.messagingList.Count > 0 then
  begin
    json.valueArray('messaging');
    for i := 0 to elem.messagingList.Count - 1 do
      ComposeConformanceMessaging(json, '',elem.messagingList[i]); {z - }
    json.FinishArray;
  end;
  if elem.documentList.Count > 0 then
  begin
    json.valueArray('document');
    for i := 0 to elem.documentList.Count - 1 do
      ComposeConformanceDocument(json, '',elem.documentList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseContractActor(element : IXmlDomElement; path : string) : TFhirContractActor;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractActor.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'entity') then
        result.entity := ParseReference{Resource}(child, path+'/entity') {b}
      else if (child.baseName = 'role') then
        result.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractActor(xml : TXmlBuilder; name : string; elem : TFhirContractActor);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'entity', elem.entity);{x.2}
  for i := 0 to elem.roleList.Count - 1 do
    ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractActor(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractActor(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractActor(jsn : TJsonObject) : TFhirContractActor;
begin
  result := TFhirContractActor.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('entity') then
        result.entity := ParseReference{Resource}(jsn.vObj['entity']);{q}
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContractActor(json : TJSONWriter; name : string; elem : TFhirContractActor; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{Resource}(json, 'entity', elem.entity); {a}
  if elem.roleList.Count > 0 then
  begin
    json.valueArray('role');
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.roleList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseContractValuedItem(element : IXmlDomElement; path : string) : TFhirContractValuedItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractValuedItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'entityCodeableConcept') then
        result.entity := ParseCodeableConcept(child, path+'/entityCodeableConcept'){x.3}
      else if (child.baseName = 'entityReference') then
        result.entity := ParseReference(child, path+'/entityReference') {a}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'effectiveTime') then
        result.effectiveTimeElement := ParseDateTime(child, path+'/effectiveTime') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'unitPrice') then
        result.unitPrice := ParseQuantity(child, path+'/unitPrice') {b}
      else if (child.baseName = 'factor') then
        result.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.baseName = 'points') then
        result.pointsElement := ParseDecimal(child, path+'/points') {b}
      else if (child.baseName = 'net') then
        result.net := ParseQuantity(child, path+'/net') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractValuedItem(xml : TXmlBuilder; name : string; elem : TFhirContractValuedItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (elem.entity is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'entityCodeableConcept', TFhirCodeableConcept(elem.entity))
  else if (elem.entity is TFhirReference) {2} then
    ComposeReference(xml, 'entityReference', TFhirReference(elem.entity));
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeDateTime(xml, 'effectiveTime', elem.effectiveTimeElement);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeQuantity(xml, 'unitPrice', elem.unitPrice);{x.2}
  ComposeDecimal(xml, 'factor', elem.factorElement);{x.2}
  ComposeDecimal(xml, 'points', elem.pointsElement);{x.2}
  ComposeQuantity(xml, 'net', elem.net);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractValuedItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractValuedItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractValuedItem(jsn : TJsonObject) : TFhirContractValuedItem;
begin
  result := TFhirContractValuedItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('entityCodeableConcept') {a4} then
      result.entity := ParseCodeableConcept(jsn.vObj['entityCodeableConcept']);
    if jsn.has('entityReference') {a3} then
      result.entity := ParseReference(jsn.vObj['entityReference']);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('effectiveTime') or jsn.has('_effectiveTime') then
        result.effectiveTimeElement := ParseDateTime(jsn['effectiveTime'], jsn.vObj['_effectiveTime']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseQuantity(jsn.vObj['unitPrice']);{q}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('points') or jsn.has('_points') then
        result.pointsElement := ParseDecimal(jsn['points'], jsn.vObj['_points']);{q}
    if jsn.has('net') then
        result.net := ParseQuantity(jsn.vObj['net']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContractValuedItem(json : TJSONWriter; name : string; elem : TFhirContractValuedItem; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.entity is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'entityCodeableConcept', TFhirCodeableConcept(elem.entity)) 
  else if (elem.entity is TFhirReference) then
    ComposeReference(json, 'entityReference', TFhirReference(elem.entity));
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeDateTimeValue(json, 'effectiveTime', elem.effectiveTimeElement, false);
  ComposeDateTimeProps(json, 'effectiveTime', elem.effectiveTimeElement, false);
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeQuantity(json, 'unitPrice', elem.unitPrice); {a}
  ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  ComposeDecimalValue(json, 'points', elem.pointsElement, false);
  ComposeDecimalProps(json, 'points', elem.pointsElement, false);
  ComposeQuantity(json, 'net', elem.net); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseContractSigner(element : IXmlDomElement; path : string) : TFhirContractSigner;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractSigner.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'party') then
        result.party := ParseReference{Resource}(child, path+'/party') {b}
      else if (child.baseName = 'signature') then
        result.signatureElement := ParseString(child, path+'/signature') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractSigner(xml : TXmlBuilder; name : string; elem : TFhirContractSigner);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'type', elem.type_);{x.2}
  ComposeReference{Resource}(xml, 'party', elem.party);{x.2}
  ComposeString(xml, 'signature', elem.signatureElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractSigner(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractSigner(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractSigner(jsn : TJsonObject) : TFhirContractSigner;
begin
  result := TFhirContractSigner.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('party') then
        result.party := ParseReference{Resource}(jsn.vObj['party']);{q}
    if jsn.has('signature') or jsn.has('_signature') then
        result.signatureElement := ParseString(jsn['signature'], jsn.vObj['_signature']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContractSigner(json : TJSONWriter; name : string; elem : TFhirContractSigner; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeReference{Resource}(json, 'party', elem.party); {a}
  ComposeStringValue(json, 'signature', elem.signatureElement, false);
  ComposeStringProps(json, 'signature', elem.signatureElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseContractTerm(element : IXmlDomElement; path : string) : TFhirContractTerm;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractTerm.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'issued') then
        result.issuedElement := ParseDateTime(child, path+'/issued') {b}
      else if (child.baseName = 'applies') then
        result.applies := ParsePeriod(child, path+'/applies') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'subType') then
        result.subType := ParseCodeableConcept(child, path+'/subType') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.baseName = 'action') then
        result.actionList.Add(ParseCodeableConcept(child, path+'/action')){y.2}
      else if (child.baseName = 'actionReason') then
        result.actionReasonList.Add(ParseCodeableConcept(child, path+'/actionReason')){y.2}
      else if (child.baseName = 'actor') then
        result.actorList.Add(ParseContractTermActor(child, path+'/actor')){y.2}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'valuedItem') then
        result.valuedItemList.Add(ParseContractTermValuedItem(child, path+'/valuedItem')){y.2}
      else if (child.baseName = 'group') then
        result.groupList.Add(ParseContractTerm(child, path+'/group')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractTerm(xml : TXmlBuilder; name : string; elem : TFhirContractTerm);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeDateTime(xml, 'issued', elem.issuedElement);{x.2}
  ComposePeriod(xml, 'applies', elem.applies);{x.2}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeCodeableConcept(xml, 'subType', elem.subType);{x.2}
  ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2}
  for i := 0 to elem.actionList.Count - 1 do
    ComposeCodeableConcept(xml, 'action', elem.actionList[i]);
  for i := 0 to elem.actionReasonList.Count - 1 do
    ComposeCodeableConcept(xml, 'actionReason', elem.actionReasonList[i]);
  for i := 0 to elem.actorList.Count - 1 do
    ComposeContractTermActor(xml, 'actor', elem.actorList[i]);
  ComposeString(xml, 'text', elem.textElement);{x.2}
  for i := 0 to elem.valuedItemList.Count - 1 do
    ComposeContractTermValuedItem(xml, 'valuedItem', elem.valuedItemList[i]);
  for i := 0 to elem.groupList.Count - 1 do
    ComposeContractTerm(xml, 'group', elem.groupList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractTerm(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTerm(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTerm(jsn : TJsonObject) : TFhirContractTerm;
begin
  result := TFhirContractTerm.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := ParseDateTime(jsn['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('applies') then
        result.applies := ParsePeriod(jsn.vObj['applies']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('subType') then
        result.subType := ParseCodeableConcept(jsn.vObj['subType']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q}
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseCodeableConcept);
    if jsn.has('actionReason') then
      iterateArray(jsn.vArr['actionReason'], result.actionReasonList, parseCodeableConcept);
    if jsn.has('actor') then
      iterateArray(jsn.vArr['actor'], result.actorList, parseContractTermActor);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('valuedItem') then
      iterateArray(jsn.vArr['valuedItem'], result.valuedItemList, parseContractTermValuedItem);
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseContractTerm);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContractTerm(json : TJSONWriter; name : string; elem : TFhirContractTerm; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeDateTimeValue(json, 'issued', elem.issuedElement, false);
  ComposeDateTimeProps(json, 'issued', elem.issuedElement, false);
  ComposePeriod(json, 'applies', elem.applies); {a}
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeCodeableConcept(json, 'subType', elem.subType); {a}
  ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  if elem.actionList.Count > 0 then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.actionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.actionReasonList.Count > 0 then
  begin
    json.valueArray('actionReason');
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.actionReasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.actorList.Count > 0 then
  begin
    json.valueArray('actor');
    for i := 0 to elem.actorList.Count - 1 do
      ComposeContractTermActor(json, '',elem.actorList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'text', elem.textElement, false);
  ComposeStringProps(json, 'text', elem.textElement, false);
  if elem.valuedItemList.Count > 0 then
  begin
    json.valueArray('valuedItem');
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractTermValuedItem(json, '',elem.valuedItemList[i]); {z - }
    json.FinishArray;
  end;
  if elem.groupList.Count > 0 then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeContractTerm(json, '',elem.groupList[i]); {z - @Contract.term}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseContractTermActor(element : IXmlDomElement; path : string) : TFhirContractTermActor;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractTermActor.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'entity') then
        result.entity := ParseReference{Resource}(child, path+'/entity') {b}
      else if (child.baseName = 'role') then
        result.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractTermActor(xml : TXmlBuilder; name : string; elem : TFhirContractTermActor);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'entity', elem.entity);{x.2}
  for i := 0 to elem.roleList.Count - 1 do
    ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractTermActor(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTermActor(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTermActor(jsn : TJsonObject) : TFhirContractTermActor;
begin
  result := TFhirContractTermActor.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('entity') then
        result.entity := ParseReference{Resource}(jsn.vObj['entity']);{q}
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContractTermActor(json : TJSONWriter; name : string; elem : TFhirContractTermActor; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{Resource}(json, 'entity', elem.entity); {a}
  if elem.roleList.Count > 0 then
  begin
    json.valueArray('role');
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.roleList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseContractTermValuedItem(element : IXmlDomElement; path : string) : TFhirContractTermValuedItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractTermValuedItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'entityCodeableConcept') then
        result.entity := ParseCodeableConcept(child, path+'/entityCodeableConcept'){x.3}
      else if (child.baseName = 'entityReference') then
        result.entity := ParseReference(child, path+'/entityReference') {a}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'effectiveTime') then
        result.effectiveTimeElement := ParseDateTime(child, path+'/effectiveTime') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'unitPrice') then
        result.unitPrice := ParseQuantity(child, path+'/unitPrice') {b}
      else if (child.baseName = 'factor') then
        result.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.baseName = 'points') then
        result.pointsElement := ParseDecimal(child, path+'/points') {b}
      else if (child.baseName = 'net') then
        result.net := ParseQuantity(child, path+'/net') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractTermValuedItem(xml : TXmlBuilder; name : string; elem : TFhirContractTermValuedItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (elem.entity is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'entityCodeableConcept', TFhirCodeableConcept(elem.entity))
  else if (elem.entity is TFhirReference) {2} then
    ComposeReference(xml, 'entityReference', TFhirReference(elem.entity));
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeDateTime(xml, 'effectiveTime', elem.effectiveTimeElement);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeQuantity(xml, 'unitPrice', elem.unitPrice);{x.2}
  ComposeDecimal(xml, 'factor', elem.factorElement);{x.2}
  ComposeDecimal(xml, 'points', elem.pointsElement);{x.2}
  ComposeQuantity(xml, 'net', elem.net);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractTermValuedItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTermValuedItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTermValuedItem(jsn : TJsonObject) : TFhirContractTermValuedItem;
begin
  result := TFhirContractTermValuedItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('entityCodeableConcept') {a4} then
      result.entity := ParseCodeableConcept(jsn.vObj['entityCodeableConcept']);
    if jsn.has('entityReference') {a3} then
      result.entity := ParseReference(jsn.vObj['entityReference']);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('effectiveTime') or jsn.has('_effectiveTime') then
        result.effectiveTimeElement := ParseDateTime(jsn['effectiveTime'], jsn.vObj['_effectiveTime']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseQuantity(jsn.vObj['unitPrice']);{q}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('points') or jsn.has('_points') then
        result.pointsElement := ParseDecimal(jsn['points'], jsn.vObj['_points']);{q}
    if jsn.has('net') then
        result.net := ParseQuantity(jsn.vObj['net']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContractTermValuedItem(json : TJSONWriter; name : string; elem : TFhirContractTermValuedItem; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.entity is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'entityCodeableConcept', TFhirCodeableConcept(elem.entity)) 
  else if (elem.entity is TFhirReference) then
    ComposeReference(json, 'entityReference', TFhirReference(elem.entity));
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeDateTimeValue(json, 'effectiveTime', elem.effectiveTimeElement, false);
  ComposeDateTimeProps(json, 'effectiveTime', elem.effectiveTimeElement, false);
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeQuantity(json, 'unitPrice', elem.unitPrice); {a}
  ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  ComposeDecimalValue(json, 'points', elem.pointsElement, false);
  ComposeDecimalProps(json, 'points', elem.pointsElement, false);
  ComposeQuantity(json, 'net', elem.net); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseContractFriendly(element : IXmlDomElement; path : string) : TFhirContractFriendly;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractFriendly.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'contentAttachment') then
        result.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.baseName = 'contentReference') then
        result.content := ParseReference(child, path+'/contentReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractFriendly(xml : TXmlBuilder; name : string; elem : TFhirContractFriendly);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractFriendly(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractFriendly(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractFriendly(jsn : TJsonObject) : TFhirContractFriendly;
begin
  result := TFhirContractFriendly.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContractFriendly(json : TJSONWriter; name : string; elem : TFhirContractFriendly; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content));
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseContractLegal(element : IXmlDomElement; path : string) : TFhirContractLegal;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractLegal.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
  begin
      if (child.baseName = 'contentAttachment') then
        result.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.baseName = 'contentReference') then
        result.content := ParseReference(child, path+'/contentReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractLegal(xml : TXmlBuilder; name : string; elem : TFhirContractLegal);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractLegal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractLegal(jsn)); {2}
  end;

function TFHIRJsonParser.ParseContractLegal(jsn : TJsonObject) : TFhirContractLegal;
  begin
  result := TFhirContractLegal.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
    result.link;
  finally
    result.free;
  end;
  end;

procedure TFHIRJsonComposer.ComposeContractLegal(json : TJSONWriter; name : string; elem : TFhirContractLegal; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content));
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseContractRule(element : IXmlDomElement; path : string) : TFhirContractRule;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractRule.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'contentAttachment') then
        result.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.baseName = 'contentReference') then
        result.content := ParseReference(child, path+'/contentReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractRule(xml : TXmlBuilder; name : string; elem : TFhirContractRule);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractRule(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractRule(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractRule(jsn : TJsonObject) : TFhirContractRule;
begin
  result := TFhirContractRule.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContractRule(json : TJSONWriter; name : string; elem : TFhirContractRule; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content));
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseContract(element : IXmlDomElement; path : string) : TFhirContract;
var
  child : IXMLDOMElement;
begin
  result := TFhirContract.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'issued') then
        result.issuedElement := ParseDateTime(child, path+'/issued') {b}
      else if (child.baseName = 'applies') then
        result.applies := ParsePeriod(child, path+'/applies') {b}
      else if (child.baseName = 'subject') then
        result.subjectList.Add(ParseReference{TFhirReference}(child, path+'/subject')){y.2}
      else if (child.baseName = 'authority') then
        result.authorityList.Add(ParseReference{TFhirOrganization}(child, path+'/authority')){y.2}
      else if (child.baseName = 'domain') then
        result.domainList.Add(ParseReference{TFhirLocation}(child, path+'/domain')){y.2}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'subType') then
        result.subTypeList.Add(ParseCodeableConcept(child, path+'/subType')){y.2}
      else if (child.baseName = 'action') then
        result.actionList.Add(ParseCodeableConcept(child, path+'/action')){y.2}
      else if (child.baseName = 'actionReason') then
        result.actionReasonList.Add(ParseCodeableConcept(child, path+'/actionReason')){y.2}
      else if (child.baseName = 'actor') then
        result.actorList.Add(ParseContractActor(child, path+'/actor')){y.2}
      else if (child.baseName = 'valuedItem') then
        result.valuedItemList.Add(ParseContractValuedItem(child, path+'/valuedItem')){y.2}
      else if (child.baseName = 'signer') then
        result.signerList.Add(ParseContractSigner(child, path+'/signer')){y.2}
      else if (child.baseName = 'term') then
        result.termList.Add(ParseContractTerm(child, path+'/term')){y.2}
      else if (child.baseName = 'bindingAttachment') then
        result.binding := ParseAttachment(child, path+'/bindingAttachment'){x.3}
      else if (child.baseName = 'bindingReference') then
        result.binding := ParseReference(child, path+'/bindingReference') {a}
      else if (child.baseName = 'friendly') then
        result.friendlyList.Add(ParseContractFriendly(child, path+'/friendly')){y.2}
      else if (child.baseName = 'legal') then
        result.legalList.Add(ParseContractLegal(child, path+'/legal')){y.2}
      else if (child.baseName = 'rule') then
        result.ruleList.Add(ParseContractRule(child, path+'/rule')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContract(xml : TXmlBuilder; name : string; elem : TFhirContract);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeDateTime(xml, 'issued', elem.issuedElement);{x.2}
  ComposePeriod(xml, 'applies', elem.applies);{x.2}
  for i := 0 to elem.subjectList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'subject', elem.subjectList[i]);
  for i := 0 to elem.authorityList.Count - 1 do
    ComposeReference{TFhirOrganization}(xml, 'authority', elem.authorityList[i]);
  for i := 0 to elem.domainList.Count - 1 do
    ComposeReference{TFhirLocation}(xml, 'domain', elem.domainList[i]);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  for i := 0 to elem.subTypeList.Count - 1 do
    ComposeCodeableConcept(xml, 'subType', elem.subTypeList[i]);
  for i := 0 to elem.actionList.Count - 1 do
    ComposeCodeableConcept(xml, 'action', elem.actionList[i]);
  for i := 0 to elem.actionReasonList.Count - 1 do
    ComposeCodeableConcept(xml, 'actionReason', elem.actionReasonList[i]);
  for i := 0 to elem.actorList.Count - 1 do
    ComposeContractActor(xml, 'actor', elem.actorList[i]);
  for i := 0 to elem.valuedItemList.Count - 1 do
    ComposeContractValuedItem(xml, 'valuedItem', elem.valuedItemList[i]);
  for i := 0 to elem.signerList.Count - 1 do
    ComposeContractSigner(xml, 'signer', elem.signerList[i]);
  for i := 0 to elem.termList.Count - 1 do
    ComposeContractTerm(xml, 'term', elem.termList[i]);
  if (elem.binding is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'bindingAttachment', TFhirAttachment(elem.binding))
  else if (elem.binding is TFhirReference) {2} then
    ComposeReference(xml, 'bindingReference', TFhirReference(elem.binding));
  for i := 0 to elem.friendlyList.Count - 1 do
    ComposeContractFriendly(xml, 'friendly', elem.friendlyList[i]);
  for i := 0 to elem.legalList.Count - 1 do
    ComposeContractLegal(xml, 'legal', elem.legalList[i]);
  for i := 0 to elem.ruleList.Count - 1 do
    ComposeContractRule(xml, 'rule', elem.ruleList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContract(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContract(jsn)); {2}
end;

function TFHIRJsonParser.ParseContract(jsn : TJsonObject) : TFhirContract;
begin
  result := TFhirContract.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := ParseDateTime(jsn['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('applies') then
        result.applies := ParsePeriod(jsn.vObj['applies']);{q}
    if jsn.has('subject') then
      iterateArray(jsn.vArr['subject'], result.subjectList, parseReference{TFhirReference});
    if jsn.has('authority') then
      iterateArray(jsn.vArr['authority'], result.authorityList, parseReference{TFhirOrganization});
    if jsn.has('domain') then
      iterateArray(jsn.vArr['domain'], result.domainList, parseReference{TFhirLocation});
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('subType') then
      iterateArray(jsn.vArr['subType'], result.subTypeList, parseCodeableConcept);
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseCodeableConcept);
    if jsn.has('actionReason') then
      iterateArray(jsn.vArr['actionReason'], result.actionReasonList, parseCodeableConcept);
    if jsn.has('actor') then
      iterateArray(jsn.vArr['actor'], result.actorList, parseContractActor);
    if jsn.has('valuedItem') then
      iterateArray(jsn.vArr['valuedItem'], result.valuedItemList, parseContractValuedItem);
    if jsn.has('signer') then
      iterateArray(jsn.vArr['signer'], result.signerList, parseContractSigner);
    if jsn.has('term') then
      iterateArray(jsn.vArr['term'], result.termList, parseContractTerm);
    if jsn.has('bindingAttachment') {a4} then
      result.binding := ParseAttachment(jsn.vObj['bindingAttachment']);
    if jsn.has('bindingReference') {a3} then
      result.binding := ParseReference(jsn.vObj['bindingReference']);
    if jsn.has('friendly') then
      iterateArray(jsn.vArr['friendly'], result.friendlyList, parseContractFriendly);
    if jsn.has('legal') then
      iterateArray(jsn.vArr['legal'], result.legalList, parseContractLegal);
    if jsn.has('rule') then
      iterateArray(jsn.vArr['rule'], result.ruleList, parseContractRule);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContract(json : TJSONWriter; name : string; elem : TFhirContract; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeDateTimeValue(json, 'issued', elem.issuedElement, false);
  ComposeDateTimeProps(json, 'issued', elem.issuedElement, false);
  ComposePeriod(json, 'applies', elem.applies); {a}
  if elem.subjectList.Count > 0 then
  begin
    json.valueArray('subject');
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.subjectList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if elem.authorityList.Count > 0 then
  begin
    json.valueArray('authority');
    for i := 0 to elem.authorityList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '',elem.authorityList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if elem.domainList.Count > 0 then
  begin
    json.valueArray('domain');
    for i := 0 to elem.domainList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '',elem.domainList[i]); {z - Reference(Location)}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.subTypeList.Count > 0 then
  begin
    json.valueArray('subType');
    for i := 0 to elem.subTypeList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.subTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.actionList.Count > 0 then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.actionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.actionReasonList.Count > 0 then
  begin
    json.valueArray('actionReason');
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.actionReasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.actorList.Count > 0 then
  begin
    json.valueArray('actor');
    for i := 0 to elem.actorList.Count - 1 do
      ComposeContractActor(json, '',elem.actorList[i]); {z - }
    json.FinishArray;
  end;
  if elem.valuedItemList.Count > 0 then
  begin
    json.valueArray('valuedItem');
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractValuedItem(json, '',elem.valuedItemList[i]); {z - }
    json.FinishArray;
  end;
  if elem.signerList.Count > 0 then
  begin
    json.valueArray('signer');
    for i := 0 to elem.signerList.Count - 1 do
      ComposeContractSigner(json, '',elem.signerList[i]); {z - }
    json.FinishArray;
  end;
  if elem.termList.Count > 0 then
  begin
    json.valueArray('term');
    for i := 0 to elem.termList.Count - 1 do
      ComposeContractTerm(json, '',elem.termList[i]); {z - }
    json.FinishArray;
  end;
  if (elem.binding is TFhirAttachment) then 
    ComposeAttachment(json, 'bindingAttachment', TFhirAttachment(elem.binding)) 
  else if (elem.binding is TFhirReference) then
    ComposeReference(json, 'bindingReference', TFhirReference(elem.binding));
  if elem.friendlyList.Count > 0 then
  begin
    json.valueArray('friendly');
    for i := 0 to elem.friendlyList.Count - 1 do
      ComposeContractFriendly(json, '',elem.friendlyList[i]); {z - }
    json.FinishArray;
  end;
  if elem.legalList.Count > 0 then
  begin
    json.valueArray('legal');
    for i := 0 to elem.legalList.Count - 1 do
      ComposeContractLegal(json, '',elem.legalList[i]); {z - }
    json.FinishArray;
  end;
  if elem.ruleList.Count > 0 then
  begin
    json.valueArray('rule');
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeContractRule(json, '',elem.ruleList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseContraindicationMitigation(element : IXmlDomElement; path : string) : TFhirContraindicationMitigation;
var
  child : IXMLDOMElement;
begin
  result := TFhirContraindicationMitigation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'action') then
        result.action := ParseCodeableConcept(child, path+'/action') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{TFhirPractitioner}(child, path+'/author') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContraindicationMitigation(xml : TXmlBuilder; name : string; elem : TFhirContraindicationMitigation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'action', elem.action);{x.2}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'author', elem.author);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContraindicationMitigation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContraindicationMitigation(jsn)); {2}
end;

function TFHIRJsonParser.ParseContraindicationMitigation(jsn : TJsonObject) : TFhirContraindicationMitigation;
begin
  result := TFhirContraindicationMitigation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('action') then
        result.action := ParseCodeableConcept(jsn.vObj['action']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('author') then
        result.author := ParseReference{TFhirPractitioner}(jsn.vObj['author']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContraindicationMitigation(json : TJSONWriter; name : string; elem : TFhirContraindicationMitigation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'action', elem.action); {a}
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeReference{TFhirPractitioner}(json, 'author', elem.author); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseContraindication(element : IXmlDomElement; path : string) : TFhirContraindication;
var
  child : IXMLDOMElement;
begin
  result := TFhirContraindication.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'severity') then
        result.severityElement := ParseCode(child, path+'/severity') {b}
      else if (child.baseName = 'implicated') then
        result.implicatedList.Add(ParseReference{TFhirReference}(child, path+'/implicated')){y.2}
      else if (child.baseName = 'detail') then
        result.detailElement := ParseString(child, path+'/detail') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'reference') then
        result.referenceElement := ParseUri(child, path+'/reference') {b}
      else if (child.baseName = 'mitigation') then
        result.mitigationList.Add(ParseContraindicationMitigation(child, path+'/mitigation')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContraindication(xml : TXmlBuilder; name : string; elem : TFhirContraindication);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  ComposeCode(xml, 'severity', elem.severityElement);{x.2}
  for i := 0 to elem.implicatedList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'implicated', elem.implicatedList[i]);
  ComposeString(xml, 'detail', elem.detailElement);{x.2}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeReference{Resource}(xml, 'author', elem.author);{x.2}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeUri(xml, 'reference', elem.referenceElement);{x.2}
  for i := 0 to elem.mitigationList.Count - 1 do
    ComposeContraindicationMitigation(xml, 'mitigation', elem.mitigationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContraindication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContraindication(jsn)); {2}
end;

function TFHIRJsonParser.ParseContraindication(jsn : TJsonObject) : TFhirContraindication;
begin
  result := TFhirContraindication.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('severity') or jsn.has('_severity') then
        result.severityElement := ParseCode(jsn['severity'], jsn.vObj['_severity']);{q}
    if jsn.has('implicated') then
      iterateArray(jsn.vArr['implicated'], result.implicatedList, parseReference{TFhirReference});
    if jsn.has('detail') or jsn.has('_detail') then
        result.detailElement := ParseString(jsn['detail'], jsn.vObj['_detail']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceElement := ParseUri(jsn['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('mitigation') then
      iterateArray(jsn.vArr['mitigation'], result.mitigationList, parseContraindicationMitigation);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContraindication(json : TJSONWriter; name : string; elem : TFhirContraindication; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeCodeValue(json, 'severity', elem.severityElement, false);
  ComposeCodeProps(json, 'severity', elem.severityElement, false);
  if elem.implicatedList.Count > 0 then
  begin
    json.valueArray('implicated');
    for i := 0 to elem.implicatedList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.implicatedList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'detail', elem.detailElement, false);
  ComposeStringProps(json, 'detail', elem.detailElement, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeReference{Resource}(json, 'author', elem.author); {a}
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeUriValue(json, 'reference', elem.referenceElement, false);
  ComposeUriProps(json, 'reference', elem.referenceElement, false);
  if elem.mitigationList.Count > 0 then
  begin
    json.valueArray('mitigation');
    for i := 0 to elem.mitigationList.Count - 1 do
      ComposeContraindicationMitigation(json, '',elem.mitigationList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseCoverage(element : IXmlDomElement; path : string) : TFhirCoverage;
var
  child : IXMLDOMElement;
begin
  result := TFhirCoverage.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'issuer') then
        result.issuer := ParseReference{TFhirOrganization}(child, path+'/issuer') {b}
      else if (child.baseName = 'bin') then
        result.bin := ParseIdentifier(child, path+'/bin') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'subscriberId') then
        result.subscriberId := ParseIdentifier(child, path+'/subscriberId') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'group') then
        result.groupElement := ParseString(child, path+'/group') {b}
      else if (child.baseName = 'plan') then
        result.planElement := ParseString(child, path+'/plan') {b}
      else if (child.baseName = 'subPlan') then
        result.subPlanElement := ParseString(child, path+'/subPlan') {b}
      else if (child.baseName = 'dependent') then
        result.dependentElement := ParsePositiveInt(child, path+'/dependent') {b}
      else if (child.baseName = 'sequence') then
        result.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.baseName = 'subscriber') then
        result.subscriber := ParseReference{TFhirPatient}(child, path+'/subscriber') {b}
      else if (child.baseName = 'network') then
        result.network := ParseIdentifier(child, path+'/network') {b}
      else if (child.baseName = 'contract') then
        result.contractList.Add(ParseReference{TFhirContract}(child, path+'/contract')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCoverage(xml : TXmlBuilder; name : string; elem : TFhirCoverage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeReference{TFhirOrganization}(xml, 'issuer', elem.issuer);{x.2}
  ComposeIdentifier(xml, 'bin', elem.bin);{x.2}
  ComposePeriod(xml, 'period', elem.period);{x.2}
  ComposeCoding(xml, 'type', elem.type_);{x.2}
  ComposeIdentifier(xml, 'subscriberId', elem.subscriberId);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeString(xml, 'group', elem.groupElement);{x.2}
  ComposeString(xml, 'plan', elem.planElement);{x.2}
  ComposeString(xml, 'subPlan', elem.subPlanElement);{x.2}
  ComposePositiveInt(xml, 'dependent', elem.dependentElement);{x.2}
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2}
  ComposeReference{TFhirPatient}(xml, 'subscriber', elem.subscriber);{x.2}
  ComposeIdentifier(xml, 'network', elem.network);{x.2}
  for i := 0 to elem.contractList.Count - 1 do
    ComposeReference{TFhirContract}(xml, 'contract', elem.contractList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoverage(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoverage(jsn : TJsonObject) : TFhirCoverage;
begin
  result := TFhirCoverage.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('issuer') then
        result.issuer := ParseReference{TFhirOrganization}(jsn.vObj['issuer']);{q}
    if jsn.has('bin') then
        result.bin := ParseIdentifier(jsn.vObj['bin']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('subscriberId') then
        result.subscriberId := ParseIdentifier(jsn.vObj['subscriberId']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('group') or jsn.has('_group') then
        result.groupElement := ParseString(jsn['group'], jsn.vObj['_group']);{q}
    if jsn.has('plan') or jsn.has('_plan') then
        result.planElement := ParseString(jsn['plan'], jsn.vObj['_plan']);{q}
    if jsn.has('subPlan') or jsn.has('_subPlan') then
        result.subPlanElement := ParseString(jsn['subPlan'], jsn.vObj['_subPlan']);{q}
    if jsn.has('dependent') or jsn.has('_dependent') then
        result.dependentElement := ParsePositiveInt(jsn['dependent'], jsn.vObj['_dependent']);{q}
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('subscriber') then
        result.subscriber := ParseReference{TFhirPatient}(jsn.vObj['subscriber']);{q}
    if jsn.has('network') then
        result.network := ParseIdentifier(jsn.vObj['network']);{q}
    if jsn.has('contract') then
      iterateArray(jsn.vArr['contract'], result.contractList, parseReference{TFhirContract});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCoverage(json : TJSONWriter; name : string; elem : TFhirCoverage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeReference{TFhirOrganization}(json, 'issuer', elem.issuer); {a}
  ComposeIdentifier(json, 'bin', elem.bin); {a}
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeIdentifier(json, 'subscriberId', elem.subscriberId); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'group', elem.groupElement, false);
  ComposeStringProps(json, 'group', elem.groupElement, false);
  ComposeStringValue(json, 'plan', elem.planElement, false);
  ComposeStringProps(json, 'plan', elem.planElement, false);
  ComposeStringValue(json, 'subPlan', elem.subPlanElement, false);
  ComposeStringProps(json, 'subPlan', elem.subPlanElement, false);
  ComposePositiveIntValue(json, 'dependent', elem.dependentElement, false);
  ComposePositiveIntProps(json, 'dependent', elem.dependentElement, false);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeReference{TFhirPatient}(json, 'subscriber', elem.subscriber); {a}
  ComposeIdentifier(json, 'network', elem.network); {a}
  if elem.contractList.Count > 0 then
  begin
    json.valueArray('contract');
    for i := 0 to elem.contractList.Count - 1 do
      ComposeReference{TFhirContract}(json, '',elem.contractList[i]); {z - Reference(Contract)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseDataElementContact(element : IXmlDomElement; path : string) : TFhirDataElementContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirDataElementContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDataElementContact(xml : TXmlBuilder; name : string; elem : TFhirDataElementContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDataElementContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDataElementContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseDataElementContact(jsn : TJsonObject) : TFhirDataElementContact;
begin
  result := TFhirDataElementContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDataElementContact(json : TJSONWriter; name : string; elem : TFhirDataElementContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseDataElementMapping(element : IXmlDomElement; path : string) : TFhirDataElementMapping;
var
  child : IXMLDOMElement;
begin
  result := TFhirDataElementMapping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identity') then
        result.identityElement := ParseId(child, path+'/identity') {b}
      else if (child.baseName = 'uri') then
        result.uriElement := ParseUri(child, path+'/uri') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'comments') then
        result.commentsElement := ParseString(child, path+'/comments') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDataElementMapping(xml : TXmlBuilder; name : string; elem : TFhirDataElementMapping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'identity', elem.identityElement);{x.2}
  ComposeUri(xml, 'uri', elem.uriElement);{x.2}
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeString(xml, 'comments', elem.commentsElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDataElementMapping(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDataElementMapping(jsn)); {2}
end;

function TFHIRJsonParser.ParseDataElementMapping(jsn : TJsonObject) : TFhirDataElementMapping;
begin
  result := TFhirDataElementMapping.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identity') or jsn.has('_identity') then
        result.identityElement := ParseId(jsn['identity'], jsn.vObj['_identity']);{q}
    if jsn.has('uri') or jsn.has('_uri') then
        result.uriElement := ParseUri(jsn['uri'], jsn.vObj['_uri']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsElement := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDataElementMapping(json : TJSONWriter; name : string; elem : TFhirDataElementMapping; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'identity', elem.identityElement, false);
  ComposeIdProps(json, 'identity', elem.identityElement, false);
  ComposeUriValue(json, 'uri', elem.uriElement, false);
  ComposeUriProps(json, 'uri', elem.uriElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeStringValue(json, 'comments', elem.commentsElement, false);
  ComposeStringProps(json, 'comments', elem.commentsElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseDataElement(element : IXmlDomElement; path : string) : TFhirDataElement;
var
  child : IXMLDOMElement;
begin
  result := TFhirDataElement.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'useContext') then
        result.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.baseName = 'experimental') then
        result.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatus, path+'/status', child){1a}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'copyright') then
        result.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseDataElementContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'specificity') then
        result.specificityElement := ParseEnum(CODES_TFhirDataelementSpecificity, path+'/specificity', child){1a}
      else if (child.baseName = 'mapping') then
        result.mappingList.Add(ParseDataElementMapping(child, path+'/mapping')){y.2}
      else if (child.baseName = 'element') then
        result.elementList.Add(ParseElementDefinition(child, path+'/element')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDataElement(xml : TXmlBuilder; name : string; elem : TFhirDataElement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeString(xml, 'version', elem.versionElement);{x.2}
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  for i := 0 to elem.useContextList.Count - 1 do
    ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus);
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeString(xml, 'copyright', elem.copyrightElement);{x.2}
  ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  for i := 0 to elem.contactList.Count - 1 do
    ComposeDataElementContact(xml, 'contact', elem.contactList[i]);
  ComposeEnum(xml, 'specificity', elem.SpecificityElement, CODES_TFhirDataelementSpecificity);
  for i := 0 to elem.mappingList.Count - 1 do
    ComposeDataElementMapping(xml, 'mapping', elem.mappingList[i]);
  for i := 0 to elem.elementList.Count - 1 do
    ComposeElementDefinition(xml, 'element', elem.elementList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDataElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDataElement(jsn)); {2}
end;

function TFHIRJsonParser.ParseDataElement(jsn : TJsonObject) : TFhirDataElement;
begin
  result := TFhirDataElement.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatus);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseDataElementContact);
    if jsn.has('specificity') or jsn.has('_specificity')  then
      result.specificityElement := parseEnum(jsn['specificity'], jsn.vObj['_specificity'], CODES_TFhirDataelementSpecificity);
    if jsn.has('mapping') then
      iterateArray(jsn.vArr['mapping'], result.mappingList, parseDataElementMapping);
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseElementDefinition);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDataElement(json : TJSONWriter; name : string; elem : TFhirDataElement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeStringValue(json, 'version', elem.versionElement, false);
  ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if elem.useContextList.Count > 0 then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.useContextList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if elem.contactList.Count > 0 then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeDataElementContact(json, '',elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'specificity', elem.SpecificityElement, CODES_TFhirDataelementSpecificity, false);
  ComposeEnumProps(json, 'specificity', elem.SpecificityElement, CODES_TFhirDataelementSpecificity, false);
  if elem.mappingList.Count > 0 then
  begin
    json.valueArray('mapping');
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeDataElementMapping(json, '',elem.mappingList[i]); {z - }
    json.FinishArray;
  end;
  if elem.elementList.Count > 0 then
  begin
    json.valueArray('element');
    for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(json, '',elem.elementList[i]); {z - ElementDefinition}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseDevice(element : IXmlDomElement; path : string) : TFhirDevice;
var
  child : IXMLDOMElement;
begin
  result := TFhirDevice.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirDevicestatus, path+'/status', child){1a}
      else if (child.baseName = 'manufacturer') then
        result.manufacturerElement := ParseString(child, path+'/manufacturer') {b}
      else if (child.baseName = 'model') then
        result.modelElement := ParseString(child, path+'/model') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'manufactureDate') then
        result.manufactureDateElement := ParseDateTime(child, path+'/manufactureDate') {b}
      else if (child.baseName = 'expiry') then
        result.expiryElement := ParseDateTime(child, path+'/expiry') {b}
      else if (child.baseName = 'udi') then
        result.udiElement := ParseString(child, path+'/udi') {b}
      else if (child.baseName = 'lotNumber') then
        result.lotNumberElement := ParseString(child, path+'/lotNumber') {b}
      else if (child.baseName = 'owner') then
        result.owner := ParseReference{TFhirOrganization}(child, path+'/owner') {b}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseContactPoint(child, path+'/contact')){y.2}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDevice(xml : TXmlBuilder; name : string; elem : TFhirDevice);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDevicestatus);
  ComposeString(xml, 'manufacturer', elem.manufacturerElement);{x.2}
  ComposeString(xml, 'model', elem.modelElement);{x.2}
  ComposeString(xml, 'version', elem.versionElement);{x.2}
  ComposeDateTime(xml, 'manufactureDate', elem.manufactureDateElement);{x.2}
  ComposeDateTime(xml, 'expiry', elem.expiryElement);{x.2}
  ComposeString(xml, 'udi', elem.udiElement);{x.2}
  ComposeString(xml, 'lotNumber', elem.lotNumberElement);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'owner', elem.owner);{x.2}
  ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  for i := 0 to elem.contactList.Count - 1 do
    ComposeContactPoint(xml, 'contact', elem.contactList[i]);
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDevice(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDevice(jsn)); {2}
end;

function TFHIRJsonParser.ParseDevice(jsn : TJsonObject) : TFhirDevice;
begin
  result := TFhirDevice.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDevicestatus);
    if jsn.has('manufacturer') or jsn.has('_manufacturer') then
        result.manufacturerElement := ParseString(jsn['manufacturer'], jsn.vObj['_manufacturer']);{q}
    if jsn.has('model') or jsn.has('_model') then
        result.modelElement := ParseString(jsn['model'], jsn.vObj['_model']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('manufactureDate') or jsn.has('_manufactureDate') then
        result.manufactureDateElement := ParseDateTime(jsn['manufactureDate'], jsn.vObj['_manufactureDate']);{q}
    if jsn.has('expiry') or jsn.has('_expiry') then
        result.expiryElement := ParseDateTime(jsn['expiry'], jsn.vObj['_expiry']);{q}
    if jsn.has('udi') or jsn.has('_udi') then
        result.udiElement := ParseString(jsn['udi'], jsn.vObj['_udi']);{q}
    if jsn.has('lotNumber') or jsn.has('_lotNumber') then
        result.lotNumberElement := ParseString(jsn['lotNumber'], jsn.vObj['_lotNumber']);{q}
    if jsn.has('owner') then
        result.owner := ParseReference{TFhirOrganization}(jsn.vObj['owner']);{q}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactPoint);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDevice(json : TJSONWriter; name : string; elem : TFhirDevice; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDevicestatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDevicestatus, false);
  ComposeStringValue(json, 'manufacturer', elem.manufacturerElement, false);
  ComposeStringProps(json, 'manufacturer', elem.manufacturerElement, false);
  ComposeStringValue(json, 'model', elem.modelElement, false);
  ComposeStringProps(json, 'model', elem.modelElement, false);
  ComposeStringValue(json, 'version', elem.versionElement, false);
  ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeDateTimeValue(json, 'manufactureDate', elem.manufactureDateElement, false);
  ComposeDateTimeProps(json, 'manufactureDate', elem.manufactureDateElement, false);
  ComposeDateTimeValue(json, 'expiry', elem.expiryElement, false);
  ComposeDateTimeProps(json, 'expiry', elem.expiryElement, false);
  ComposeStringValue(json, 'udi', elem.udiElement, false);
  ComposeStringProps(json, 'udi', elem.udiElement, false);
  ComposeStringValue(json, 'lotNumber', elem.lotNumberElement, false);
  ComposeStringProps(json, 'lotNumber', elem.lotNumberElement, false);
  ComposeReference{TFhirOrganization}(json, 'owner', elem.owner); {a}
  ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if elem.contactList.Count > 0 then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(json, '',elem.contactList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
end;

function TFHIRXmlParser.ParseDeviceComponentProductionSpecification(element : IXmlDomElement; path : string) : TFhirDeviceComponentProductionSpecification;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceComponentProductionSpecification.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'specType') then
        result.specType := ParseCodeableConcept(child, path+'/specType') {b}
      else if (child.baseName = 'componentId') then
        result.componentId := ParseIdentifier(child, path+'/componentId') {b}
      else if (child.baseName = 'productionSpec') then
        result.productionSpecElement := ParseString(child, path+'/productionSpec') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceComponentProductionSpecification(xml : TXmlBuilder; name : string; elem : TFhirDeviceComponentProductionSpecification);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'specType', elem.specType);{x.2}
  ComposeIdentifier(xml, 'componentId', elem.componentId);{x.2}
  ComposeString(xml, 'productionSpec', elem.productionSpecElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceComponentProductionSpecification(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceComponentProductionSpecification(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceComponentProductionSpecification(jsn : TJsonObject) : TFhirDeviceComponentProductionSpecification;
begin
  result := TFhirDeviceComponentProductionSpecification.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('specType') then
        result.specType := ParseCodeableConcept(jsn.vObj['specType']);{q}
    if jsn.has('componentId') then
        result.componentId := ParseIdentifier(jsn.vObj['componentId']);{q}
    if jsn.has('productionSpec') or jsn.has('_productionSpec') then
        result.productionSpecElement := ParseString(jsn['productionSpec'], jsn.vObj['_productionSpec']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceComponentProductionSpecification(json : TJSONWriter; name : string; elem : TFhirDeviceComponentProductionSpecification; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'specType', elem.specType); {a}
  ComposeIdentifier(json, 'componentId', elem.componentId); {a}
  ComposeStringValue(json, 'productionSpec', elem.productionSpecElement, false);
  ComposeStringProps(json, 'productionSpec', elem.productionSpecElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseDeviceComponent(element : IXmlDomElement; path : string) : TFhirDeviceComponent;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceComponent.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'lastSystemChange') then
        result.lastSystemChangeElement := ParseInstant(child, path+'/lastSystemChange') {b}
      else if (child.baseName = 'source') then
        result.source := ParseReference{TFhirDevice}(child, path+'/source') {b}
      else if (child.baseName = 'parent') then
        result.parent := ParseReference{TFhirDeviceComponent}(child, path+'/parent') {b}
      else if (child.baseName = 'operationalStatus') then
        result.operationalStatusList.Add(ParseCodeableConcept(child, path+'/operationalStatus')){y.2}
      else if (child.baseName = 'parameterGroup') then
        result.parameterGroup := ParseCodeableConcept(child, path+'/parameterGroup') {b}
      else if (child.baseName = 'measurementPrinciple') then
        result.measurementPrincipleElement := ParseEnum(CODES_TFhirMeasurementPrinciple, path+'/measurementPrinciple', child){1a}
      else if (child.baseName = 'productionSpecification') then
        result.productionSpecificationList.Add(ParseDeviceComponentProductionSpecification(child, path+'/productionSpecification')){y.2}
      else if (child.baseName = 'languageCode') then
        result.languageCode := ParseCodeableConcept(child, path+'/languageCode') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceComponent(xml : TXmlBuilder; name : string; elem : TFhirDeviceComponent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeInstant(xml, 'lastSystemChange', elem.lastSystemChangeElement);{x.2}
  ComposeReference{TFhirDevice}(xml, 'source', elem.source);{x.2}
  ComposeReference{TFhirDeviceComponent}(xml, 'parent', elem.parent);{x.2}
  for i := 0 to elem.operationalStatusList.Count - 1 do
    ComposeCodeableConcept(xml, 'operationalStatus', elem.operationalStatusList[i]);
  ComposeCodeableConcept(xml, 'parameterGroup', elem.parameterGroup);{x.2}
  ComposeEnum(xml, 'measurementPrinciple', elem.MeasurementPrincipleElement, CODES_TFhirMeasurementPrinciple);
  for i := 0 to elem.productionSpecificationList.Count - 1 do
    ComposeDeviceComponentProductionSpecification(xml, 'productionSpecification', elem.productionSpecificationList[i]);
  ComposeCodeableConcept(xml, 'languageCode', elem.languageCode);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceComponent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceComponent(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceComponent(jsn : TJsonObject) : TFhirDeviceComponent;
begin
  result := TFhirDeviceComponent.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('lastSystemChange') or jsn.has('_lastSystemChange') then
        result.lastSystemChangeElement := ParseInstant(jsn['lastSystemChange'], jsn.vObj['_lastSystemChange']);{q}
    if jsn.has('source') then
        result.source := ParseReference{TFhirDevice}(jsn.vObj['source']);{q}
    if jsn.has('parent') then
        result.parent := ParseReference{TFhirDeviceComponent}(jsn.vObj['parent']);{q}
    if jsn.has('operationalStatus') then
      iterateArray(jsn.vArr['operationalStatus'], result.operationalStatusList, parseCodeableConcept);
    if jsn.has('parameterGroup') then
        result.parameterGroup := ParseCodeableConcept(jsn.vObj['parameterGroup']);{q}
    if jsn.has('measurementPrinciple') or jsn.has('_measurementPrinciple')  then
      result.measurementPrincipleElement := parseEnum(jsn['measurementPrinciple'], jsn.vObj['_measurementPrinciple'], CODES_TFhirMeasurementPrinciple);
    if jsn.has('productionSpecification') then
      iterateArray(jsn.vArr['productionSpecification'], result.productionSpecificationList, parseDeviceComponentProductionSpecification);
    if jsn.has('languageCode') then
        result.languageCode := ParseCodeableConcept(jsn.vObj['languageCode']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceComponent(json : TJSONWriter; name : string; elem : TFhirDeviceComponent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeInstantValue(json, 'lastSystemChange', elem.lastSystemChangeElement, false);
  ComposeInstantProps(json, 'lastSystemChange', elem.lastSystemChangeElement, false);
  ComposeReference{TFhirDevice}(json, 'source', elem.source); {a}
  ComposeReference{TFhirDeviceComponent}(json, 'parent', elem.parent); {a}
  if elem.operationalStatusList.Count > 0 then
  begin
    json.valueArray('operationalStatus');
    for i := 0 to elem.operationalStatusList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.operationalStatusList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'parameterGroup', elem.parameterGroup); {a}
  ComposeEnumValue(json, 'measurementPrinciple', elem.MeasurementPrincipleElement, CODES_TFhirMeasurementPrinciple, false);
  ComposeEnumProps(json, 'measurementPrinciple', elem.MeasurementPrincipleElement, CODES_TFhirMeasurementPrinciple, false);
  if elem.productionSpecificationList.Count > 0 then
  begin
    json.valueArray('productionSpecification');
    for i := 0 to elem.productionSpecificationList.Count - 1 do
      ComposeDeviceComponentProductionSpecification(json, '',elem.productionSpecificationList[i]); {z - }
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'languageCode', elem.languageCode); {a}
end;

function TFHIRXmlParser.ParseDeviceMetricCalibration(element : IXmlDomElement; path : string) : TFhirDeviceMetricCalibration;
var
  child : IXMLDOMElement;
  begin
  result := TFhirDeviceMetricCalibration.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
  begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirMetricCalibrationType, path+'/type', child){1a}
      else if (child.baseName = 'state') then
        result.stateElement := ParseEnum(CODES_TFhirMetricCalibrationState, path+'/state', child){1a}
      else if (child.baseName = 'time') then
        result.timeElement := ParseInstant(child, path+'/time') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
  end;

procedure TFHIRXmlComposer.ComposeDeviceMetricCalibration(xml : TXmlBuilder; name : string; elem : TFhirDeviceMetricCalibration);
  begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirMetricCalibrationType);
  ComposeEnum(xml, 'state', elem.StateElement, CODES_TFhirMetricCalibrationState);
  ComposeInstant(xml, 'time', elem.timeElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
  end;

procedure TFHIRJsonParser.ParseDeviceMetricCalibration(jsn : TJsonObject; ctxt : TFHIRObjectList);
  begin
  ctxt.add(ParseDeviceMetricCalibration(jsn)); {2}
  end;

function TFHIRJsonParser.ParseDeviceMetricCalibration(jsn : TJsonObject) : TFhirDeviceMetricCalibration;
  begin
  result := TFhirDeviceMetricCalibration.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirMetricCalibrationType);
    if jsn.has('state') or jsn.has('_state')  then
      result.stateElement := parseEnum(jsn['state'], jsn.vObj['_state'], CODES_TFhirMetricCalibrationState);
    if jsn.has('time') or jsn.has('_time') then
        result.timeElement := ParseInstant(jsn['time'], jsn.vObj['_time']);{q}
    result.link;
  finally
    result.free;
  end;
  end;

procedure TFHIRJsonComposer.ComposeDeviceMetricCalibration(json : TJSONWriter; name : string; elem : TFhirDeviceMetricCalibration; noObj : boolean = false);
  begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirMetricCalibrationType, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirMetricCalibrationType, false);
  ComposeEnumValue(json, 'state', elem.StateElement, CODES_TFhirMetricCalibrationState, false);
  ComposeEnumProps(json, 'state', elem.StateElement, CODES_TFhirMetricCalibrationState, false);
  ComposeInstantValue(json, 'time', elem.timeElement, false);
  ComposeInstantProps(json, 'time', elem.timeElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseDeviceMetric(element : IXmlDomElement; path : string) : TFhirDeviceMetric;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceMetric.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'unit') then
        result.unit_ := ParseCodeableConcept(child, path+'/unit') {b}
      else if (child.baseName = 'source') then
        result.source := ParseReference{TFhirDevice}(child, path+'/source') {b}
      else if (child.baseName = 'parent') then
        result.parent := ParseReference{TFhirDeviceComponent}(child, path+'/parent') {b}
      else if (child.baseName = 'operationalStatus') then
        result.operationalStatusElement := ParseEnum(CODES_TFhirMetricOperationalStatus, path+'/operationalStatus', child){1a}
      else if (child.baseName = 'color') then
        result.colorElement := ParseEnum(CODES_TFhirMetricColor, path+'/color', child){1a}
      else if (child.baseName = 'category') then
        result.categoryElement := ParseEnum(CODES_TFhirMetricCategory, path+'/category', child){1a}
      else if (child.baseName = 'measurementPeriod') then
        result.measurementPeriod := ParseTiming(child, path+'/measurementPeriod') {b}
      else if (child.baseName = 'calibration') then
        result.calibrationList.Add(ParseDeviceMetricCalibration(child, path+'/calibration')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceMetric(xml : TXmlBuilder; name : string; elem : TFhirDeviceMetric);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeCodeableConcept(xml, 'unit', elem.unit_);{x.2}
  ComposeReference{TFhirDevice}(xml, 'source', elem.source);{x.2}
  ComposeReference{TFhirDeviceComponent}(xml, 'parent', elem.parent);{x.2}
  ComposeEnum(xml, 'operationalStatus', elem.OperationalStatusElement, CODES_TFhirMetricOperationalStatus);
  ComposeEnum(xml, 'color', elem.ColorElement, CODES_TFhirMetricColor);
  ComposeEnum(xml, 'category', elem.CategoryElement, CODES_TFhirMetricCategory);
  ComposeTiming(xml, 'measurementPeriod', elem.measurementPeriod);{x.2}
  for i := 0 to elem.calibrationList.Count - 1 do
    ComposeDeviceMetricCalibration(xml, 'calibration', elem.calibrationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceMetric(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceMetric(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceMetric(jsn : TJsonObject) : TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('unit') then
        result.unit_ := ParseCodeableConcept(jsn.vObj['unit']);{q}
    if jsn.has('source') then
        result.source := ParseReference{TFhirDevice}(jsn.vObj['source']);{q}
    if jsn.has('parent') then
        result.parent := ParseReference{TFhirDeviceComponent}(jsn.vObj['parent']);{q}
    if jsn.has('operationalStatus') or jsn.has('_operationalStatus')  then
      result.operationalStatusElement := parseEnum(jsn['operationalStatus'], jsn.vObj['_operationalStatus'], CODES_TFhirMetricOperationalStatus);
    if jsn.has('color') or jsn.has('_color')  then
      result.colorElement := parseEnum(jsn['color'], jsn.vObj['_color'], CODES_TFhirMetricColor);
    if jsn.has('category') or jsn.has('_category')  then
      result.categoryElement := parseEnum(jsn['category'], jsn.vObj['_category'], CODES_TFhirMetricCategory);
    if jsn.has('measurementPeriod') then
        result.measurementPeriod := ParseTiming(jsn.vObj['measurementPeriod']);{q}
    if jsn.has('calibration') then
      iterateArray(jsn.vArr['calibration'], result.calibrationList, parseDeviceMetricCalibration);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceMetric(json : TJSONWriter; name : string; elem : TFhirDeviceMetric; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeCodeableConcept(json, 'unit', elem.unit_); {a}
  ComposeReference{TFhirDevice}(json, 'source', elem.source); {a}
  ComposeReference{TFhirDeviceComponent}(json, 'parent', elem.parent); {a}
  ComposeEnumValue(json, 'operationalStatus', elem.OperationalStatusElement, CODES_TFhirMetricOperationalStatus, false);
  ComposeEnumProps(json, 'operationalStatus', elem.OperationalStatusElement, CODES_TFhirMetricOperationalStatus, false);
  ComposeEnumValue(json, 'color', elem.ColorElement, CODES_TFhirMetricColor, false);
  ComposeEnumProps(json, 'color', elem.ColorElement, CODES_TFhirMetricColor, false);
  ComposeEnumValue(json, 'category', elem.CategoryElement, CODES_TFhirMetricCategory, false);
  ComposeEnumProps(json, 'category', elem.CategoryElement, CODES_TFhirMetricCategory, false);
  ComposeTiming(json, 'measurementPeriod', elem.measurementPeriod); {a}
  if elem.calibrationList.Count > 0 then
  begin
    json.valueArray('calibration');
    for i := 0 to elem.calibrationList.Count - 1 do
      ComposeDeviceMetricCalibration(json, '',elem.calibrationList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseDeviceUseRequest(element : IXmlDomElement; path : string) : TFhirDeviceUseRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceUseRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'bodySiteCodeableConcept') then
        result.bodySite := ParseCodeableConcept(child, path+'/bodySiteCodeableConcept'){x.3}
      else if (child.baseName = 'bodySiteReference') then
        result.bodySite := ParseReference(child, path+'/bodySiteReference') {a}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirDeviceUseRequestStatus, path+'/status', child){1a}
      else if (child.baseName = 'device') then
        result.device := ParseReference{TFhirDevice}(child, path+'/device') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'indication') then
        result.indicationList.Add(ParseCodeableConcept(child, path+'/indication')){y.2}
      else if (child.baseName = 'notes') then
        result.notesList.Add(ParseString(child, path+'/notes')){y.2}
      else if (child.baseName = 'prnReason') then
        result.prnReasonList.Add(ParseCodeableConcept(child, path+'/prnReason')){y.2}
      else if (child.baseName = 'orderedOn') then
        result.orderedOnElement := ParseDateTime(child, path+'/orderedOn') {b}
      else if (child.baseName = 'recordedOn') then
        result.recordedOnElement := ParseDateTime(child, path+'/recordedOn') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'timingTiming') then
        result.timing := ParseTiming(child, path+'/timingTiming'){x.3}
      else if (child.baseName = 'timingPeriod') then
        result.timing := ParsePeriod(child, path+'/timingPeriod'){x.3}
      else if (child.baseName = 'timingDateTime') then
        result.timing := ParseDateTime(child, path+'/timingDateTime'){x.3}
      else if (child.baseName = 'priority') then
        result.priorityElement := ParseEnum(CODES_TFhirDeviceUseRequestPriority, path+'/priority', child){1a}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceUseRequest(xml : TXmlBuilder; name : string; elem : TFhirDeviceUseRequest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (elem.bodySite is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite))
  else if (elem.bodySite is TFhirReference) {2} then
    ComposeReference(xml, 'bodySiteReference', TFhirReference(elem.bodySite));
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDeviceUseRequestStatus);
  ComposeReference{TFhirDevice}(xml, 'device', elem.device);{x.2}
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  for i := 0 to elem.indicationList.Count - 1 do
    ComposeCodeableConcept(xml, 'indication', elem.indicationList[i]);
  for i := 0 to elem.notesList.Count - 1 do
    ComposeString(xml, 'notes', elem.notesList[i]);
  for i := 0 to elem.prnReasonList.Count - 1 do
    ComposeCodeableConcept(xml, 'prnReason', elem.prnReasonList[i]);
  ComposeDateTime(xml, 'orderedOn', elem.orderedOnElement);{x.2}
  ComposeDateTime(xml, 'recordedOn', elem.recordedOnElement);{x.2}
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  if (elem.timing is TFhirTiming) {6} then
    ComposeTiming(xml, 'timingTiming', TFhirTiming(elem.timing))
  else if (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing))
  else if (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(elem.timing));
  ComposeEnum(xml, 'priority', elem.PriorityElement, CODES_TFhirDeviceUseRequestPriority);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceUseRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceUseRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceUseRequest(jsn : TJsonObject) : TFhirDeviceUseRequest;
begin
  result := TFhirDeviceUseRequest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('bodySiteCodeableConcept') {a4} then
      result.bodySite := ParseCodeableConcept(jsn.vObj['bodySiteCodeableConcept']);
    if jsn.has('bodySiteReference') {a3} then
      result.bodySite := ParseReference(jsn.vObj['bodySiteReference']);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDeviceUseRequestStatus);
    if jsn.has('device') then
        result.device := ParseReference{TFhirDevice}(jsn.vObj['device']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('indication') then
      iterateArray(jsn.vArr['indication'], result.indicationList, parseCodeableConcept);
      if jsn.has('notes') or jsn.has('_notes') then
      iteratePrimitiveArray(jsn.vArr['notes'], jsn.vArr['_notes'], result.notesList, parseString);
    if jsn.has('prnReason') then
      iterateArray(jsn.vArr['prnReason'], result.prnReasonList, parseCodeableConcept);
    if jsn.has('orderedOn') or jsn.has('_orderedOn') then
        result.orderedOnElement := ParseDateTime(jsn['orderedOn'], jsn.vObj['_orderedOn']);{q}
    if jsn.has('recordedOn') or jsn.has('_recordedOn') then
        result.recordedOnElement := ParseDateTime(jsn['recordedOn'], jsn.vObj['_recordedOn']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('timingTiming') {a4} then
      result.timing := ParseTiming(jsn.vObj['timingTiming']);
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('timingDateTime') or jsn.has('_timingDateTime') then
      result.timing := parseDateTime(jsn['timingDateTime'], jsn.vObj['_timingDateTime']);
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn['priority'], jsn.vObj['_priority'], CODES_TFhirDeviceUseRequestPriority);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceUseRequest(json : TJSONWriter; name : string; elem : TFhirDeviceUseRequest; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (elem.bodySite is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite)) 
  else if (elem.bodySite is TFhirReference) then
    ComposeReference(json, 'bodySiteReference', TFhirReference(elem.bodySite));
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDeviceUseRequestStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDeviceUseRequestStatus, false);
  ComposeReference{TFhirDevice}(json, 'device', elem.device); {a}
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
end;
  if elem.indicationList.Count > 0 then
begin
    json.valueArray('indication');
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.indicationList[i]); {z - CodeableConcept}
    json.FinishArray;
    end;
  if elem.notesList.Count > 0 then
begin
    json.valueArray('notes');
    ext := false;
    for i := 0 to elem.notesList.Count - 1 do
begin
      ext := ext or ((elem.notesList[i].id <> '') or (elem.notesList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.notesList[i], true);
end;
    json.FinishArray;
    if ext then
begin
      json.valueArray('_notes');
      for i := 0 to elem.notesList.Count - 1 do
        ComposeStringProps(json, '',elem.notesList[i], true);
      json.FinishArray;
  end;
end;
  if elem.prnReasonList.Count > 0 then
begin
    json.valueArray('prnReason');
    for i := 0 to elem.prnReasonList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.prnReasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'orderedOn', elem.orderedOnElement, false);
  ComposeDateTimeProps(json, 'orderedOn', elem.orderedOnElement, false);
  ComposeDateTimeValue(json, 'recordedOn', elem.recordedOnElement, false);
  ComposeDateTimeProps(json, 'recordedOn', elem.recordedOnElement, false);
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (elem.timing is TFhirTiming) then 
    ComposeTiming(json, 'timingTiming', TFhirTiming(elem.timing)) 
  else if (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) 
  else if (elem.timing is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
    ComposeDateTimeProps(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
  end;
  ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirDeviceUseRequestPriority, false);
  ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirDeviceUseRequestPriority, false);
end;

function TFHIRXmlParser.ParseDeviceUseStatement(element : IXmlDomElement; path : string) : TFhirDeviceUseStatement;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceUseStatement.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'bodySiteCodeableConcept') then
        result.bodySite := ParseCodeableConcept(child, path+'/bodySiteCodeableConcept'){x.3}
      else if (child.baseName = 'bodySiteReference') then
        result.bodySite := ParseReference(child, path+'/bodySiteReference') {a}
      else if (child.baseName = 'whenUsed') then
        result.whenUsed := ParsePeriod(child, path+'/whenUsed') {b}
      else if (child.baseName = 'device') then
        result.device := ParseReference{TFhirDevice}(child, path+'/device') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'indication') then
        result.indicationList.Add(ParseCodeableConcept(child, path+'/indication')){y.2}
      else if (child.baseName = 'notes') then
        result.notesList.Add(ParseString(child, path+'/notes')){y.2}
      else if (child.baseName = 'recordedOn') then
        result.recordedOnElement := ParseDateTime(child, path+'/recordedOn') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'timingTiming') then
        result.timing := ParseTiming(child, path+'/timingTiming'){x.3}
      else if (child.baseName = 'timingPeriod') then
        result.timing := ParsePeriod(child, path+'/timingPeriod'){x.3}
      else if (child.baseName = 'timingDateTime') then
        result.timing := ParseDateTime(child, path+'/timingDateTime'){x.3}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceUseStatement(xml : TXmlBuilder; name : string; elem : TFhirDeviceUseStatement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (elem.bodySite is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite))
  else if (elem.bodySite is TFhirReference) {2} then
    ComposeReference(xml, 'bodySiteReference', TFhirReference(elem.bodySite));
  ComposePeriod(xml, 'whenUsed', elem.whenUsed);{x.2}
  ComposeReference{TFhirDevice}(xml, 'device', elem.device);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  for i := 0 to elem.indicationList.Count - 1 do
    ComposeCodeableConcept(xml, 'indication', elem.indicationList[i]);
  for i := 0 to elem.notesList.Count - 1 do
    ComposeString(xml, 'notes', elem.notesList[i]);
  ComposeDateTime(xml, 'recordedOn', elem.recordedOnElement);{x.2}
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  if (elem.timing is TFhirTiming) {6} then
    ComposeTiming(xml, 'timingTiming', TFhirTiming(elem.timing))
  else if (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing))
  else if (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(elem.timing));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceUseStatement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceUseStatement(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceUseStatement(jsn : TJsonObject) : TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('bodySiteCodeableConcept') {a4} then
      result.bodySite := ParseCodeableConcept(jsn.vObj['bodySiteCodeableConcept']);
    if jsn.has('bodySiteReference') {a3} then
      result.bodySite := ParseReference(jsn.vObj['bodySiteReference']);
    if jsn.has('whenUsed') then
        result.whenUsed := ParsePeriod(jsn.vObj['whenUsed']);{q}
    if jsn.has('device') then
        result.device := ParseReference{TFhirDevice}(jsn.vObj['device']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('indication') then
      iterateArray(jsn.vArr['indication'], result.indicationList, parseCodeableConcept);
      if jsn.has('notes') or jsn.has('_notes') then
      iteratePrimitiveArray(jsn.vArr['notes'], jsn.vArr['_notes'], result.notesList, parseString);
    if jsn.has('recordedOn') or jsn.has('_recordedOn') then
        result.recordedOnElement := ParseDateTime(jsn['recordedOn'], jsn.vObj['_recordedOn']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('timingTiming') {a4} then
      result.timing := ParseTiming(jsn.vObj['timingTiming']);
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('timingDateTime') or jsn.has('_timingDateTime') then
      result.timing := parseDateTime(jsn['timingDateTime'], jsn.vObj['_timingDateTime']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceUseStatement(json : TJSONWriter; name : string; elem : TFhirDeviceUseStatement; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (elem.bodySite is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite)) 
  else if (elem.bodySite is TFhirReference) then
    ComposeReference(json, 'bodySiteReference', TFhirReference(elem.bodySite));
  ComposePeriod(json, 'whenUsed', elem.whenUsed); {a}
  ComposeReference{TFhirDevice}(json, 'device', elem.device); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if elem.indicationList.Count > 0 then
  begin
    json.valueArray('indication');
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.indicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.notesList.Count > 0 then
  begin
    json.valueArray('notes');
    ext := false;
    for i := 0 to elem.notesList.Count - 1 do
    begin
      ext := ext or ((elem.notesList[i].id <> '') or (elem.notesList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.notesList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_notes');
      for i := 0 to elem.notesList.Count - 1 do
        ComposeStringProps(json, '',elem.notesList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeDateTimeValue(json, 'recordedOn', elem.recordedOnElement, false);
  ComposeDateTimeProps(json, 'recordedOn', elem.recordedOnElement, false);
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (elem.timing is TFhirTiming) then 
    ComposeTiming(json, 'timingTiming', TFhirTiming(elem.timing)) 
  else if (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) 
  else if (elem.timing is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
    ComposeDateTimeProps(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
    end;
end;

function TFHIRXmlParser.ParseDiagnosticOrderEvent(element : IXmlDomElement; path : string) : TFhirDiagnosticOrderEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirDiagnosticOrderStatus, path+'/status', child){1a}
      else if (child.baseName = 'description') then
        result.description := ParseCodeableConcept(child, path+'/description') {b}
      else if (child.baseName = 'dateTime') then
        result.dateTimeElement := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.baseName = 'actor') then
        result.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrderEvent(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderEvent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatus);
  ComposeCodeableConcept(xml, 'description', elem.description);{x.2}
  ComposeDateTime(xml, 'dateTime', elem.dateTimeElement);{x.2}
  ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticOrderEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticOrderEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseDiagnosticOrderEvent(jsn : TJsonObject) : TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticOrderStatus);
    if jsn.has('description') then
        result.description := ParseCodeableConcept(jsn.vObj['description']);{q}
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeElement := ParseDateTime(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('actor') then
        result.actor := ParseReference{Resource}(jsn.vObj['actor']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticOrderEvent(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderEvent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatus, false);
  ComposeCodeableConcept(json, 'description', elem.description); {a}
  ComposeDateTimeValue(json, 'dateTime', elem.dateTimeElement, false);
  ComposeDateTimeProps(json, 'dateTime', elem.dateTimeElement, false);
  ComposeReference{Resource}(json, 'actor', elem.actor); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseDiagnosticOrderItem(element : IXmlDomElement; path : string) : TFhirDiagnosticOrderItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'specimen') then
        result.specimenList.Add(ParseReference{TFhirSpecimen}(child, path+'/specimen')){y.2}
      else if (child.baseName = 'bodySiteCodeableConcept') then
        result.bodySite := ParseCodeableConcept(child, path+'/bodySiteCodeableConcept'){x.3}
      else if (child.baseName = 'bodySiteReference') then
        result.bodySite := ParseReference(child, path+'/bodySiteReference') {a}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirDiagnosticOrderStatus, path+'/status', child){1a}
      else if (child.baseName = 'event') then
        result.eventList.Add(ParseDiagnosticOrderEvent(child, path+'/event')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrderItem(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderItem);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  for i := 0 to elem.specimenList.Count - 1 do
    ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimenList[i]);
  if (elem.bodySite is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite))
  else if (elem.bodySite is TFhirReference) {2} then
    ComposeReference(xml, 'bodySiteReference', TFhirReference(elem.bodySite));
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatus);
  for i := 0 to elem.eventList.Count - 1 do
    ComposeDiagnosticOrderEvent(xml, 'event', elem.eventList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticOrderItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticOrderItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseDiagnosticOrderItem(jsn : TJsonObject) : TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseReference{TFhirSpecimen});
    if jsn.has('bodySiteCodeableConcept') {a4} then
      result.bodySite := ParseCodeableConcept(jsn.vObj['bodySiteCodeableConcept']);
    if jsn.has('bodySiteReference') {a3} then
      result.bodySite := ParseReference(jsn.vObj['bodySiteReference']);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticOrderStatus);
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseDiagnosticOrderEvent);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticOrderItem(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderItem; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if elem.specimenList.Count > 0 then
  begin
    json.valueArray('specimen');
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '',elem.specimenList[i]); {z - Reference(Specimen)}
    json.FinishArray;
  end;
  if (elem.bodySite is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite)) 
  else if (elem.bodySite is TFhirReference) then
    ComposeReference(json, 'bodySiteReference', TFhirReference(elem.bodySite));
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatus, false);
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(json, '',elem.eventList[i]); {z - @DiagnosticOrder.event}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseDiagnosticOrder(element : IXmlDomElement; path : string) : TFhirDiagnosticOrder;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticOrder.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'orderer') then
        result.orderer := ParseReference{TFhirPractitioner}(child, path+'/orderer') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'clinicalNotes') then
        result.clinicalNotesElement := ParseString(child, path+'/clinicalNotes') {b}
      else if (child.baseName = 'supportingInformation') then
        result.supportingInformationList.Add(ParseReference{Resource}(child, path+'/supportingInformation')){y.2}
      else if (child.baseName = 'specimen') then
        result.specimenList.Add(ParseReference{TFhirSpecimen}(child, path+'/specimen')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirDiagnosticOrderStatus, path+'/status', child){1a}
      else if (child.baseName = 'priority') then
        result.priorityElement := ParseEnum(CODES_TFhirDiagnosticOrderPriority, path+'/priority', child){1a}
      else if (child.baseName = 'event') then
        result.eventList.Add(ParseDiagnosticOrderEvent(child, path+'/event')){y.2}
      else if (child.baseName = 'item') then
        result.itemList.Add(ParseDiagnosticOrderItem(child, path+'/item')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrder(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrder);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'orderer', elem.orderer);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  ComposeString(xml, 'clinicalNotes', elem.clinicalNotesElement);{x.2}
  for i := 0 to elem.supportingInformationList.Count - 1 do
    ComposeReference{Resource}(xml, 'supportingInformation', elem.supportingInformationList[i]);
  for i := 0 to elem.specimenList.Count - 1 do
    ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimenList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatus);
  ComposeEnum(xml, 'priority', elem.PriorityElement, CODES_TFhirDiagnosticOrderPriority);
  for i := 0 to elem.eventList.Count - 1 do
    ComposeDiagnosticOrderEvent(xml, 'event', elem.eventList[i]);
  for i := 0 to elem.itemList.Count - 1 do
    ComposeDiagnosticOrderItem(xml, 'item', elem.itemList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticOrder(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticOrder(jsn)); {2}
end;

function TFHIRJsonParser.ParseDiagnosticOrder(jsn : TJsonObject) : TFhirDiagnosticOrder;
begin
  result := TFhirDiagnosticOrder.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('orderer') then
        result.orderer := ParseReference{TFhirPractitioner}(jsn.vObj['orderer']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('clinicalNotes') or jsn.has('_clinicalNotes') then
        result.clinicalNotesElement := ParseString(jsn['clinicalNotes'], jsn.vObj['_clinicalNotes']);{q}
    if jsn.has('supportingInformation') then
      iterateArray(jsn.vArr['supportingInformation'], result.supportingInformationList, parseReference{Resource});
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseReference{TFhirSpecimen});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticOrderStatus);
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn['priority'], jsn.vObj['_priority'], CODES_TFhirDiagnosticOrderPriority);
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseDiagnosticOrderEvent);
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseDiagnosticOrderItem);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticOrder(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrder; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeReference{TFhirPractitioner}(json, 'orderer', elem.orderer); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeStringValue(json, 'clinicalNotes', elem.clinicalNotesElement, false);
  ComposeStringProps(json, 'clinicalNotes', elem.clinicalNotesElement, false);
  if elem.supportingInformationList.Count > 0 then
  begin
    json.valueArray('supportingInformation');
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.supportingInformationList[i]); {z - Reference(Observation|Condition|DocumentReference)}
    json.FinishArray;
  end;
  if elem.specimenList.Count > 0 then
  begin
    json.valueArray('specimen');
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '',elem.specimenList[i]); {z - Reference(Specimen)}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatus, false);
  ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirDiagnosticOrderPriority, false);
  ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirDiagnosticOrderPriority, false);
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(json, '',elem.eventList[i]); {z - }
    json.FinishArray;
  end;
  if elem.itemList.Count > 0 then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeDiagnosticOrderItem(json, '',elem.itemList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseDiagnosticReportImage(element : IXmlDomElement; path : string) : TFhirDiagnosticReportImage;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'comment') then
        result.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.baseName = 'link') then
        result.link_ := ParseReference{TFhirMedia}(child, path+'/link') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReportImage(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReportImage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'comment', elem.commentElement);{x.2}
  ComposeReference{TFhirMedia}(xml, 'link', elem.link_);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticReportImage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticReportImage(jsn)); {2}
end;

function TFHIRJsonParser.ParseDiagnosticReportImage(jsn : TJsonObject) : TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('link') then
        result.link_ := ParseReference{TFhirMedia}(jsn.vObj['link']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticReportImage(json : TJSONWriter; name : string; elem : TFhirDiagnosticReportImage; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'comment', elem.commentElement, false);
  ComposeStringProps(json, 'comment', elem.commentElement, false);
  ComposeReference{TFhirMedia}(json, 'link', elem.link_); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseDiagnosticReport(element : IXmlDomElement; path : string) : TFhirDiagnosticReport;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticReport.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseCodeableConcept(child, path+'/name') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirDiagnosticReportStatus, path+'/status', child){1a}
      else if (child.baseName = 'issued') then
        result.issuedElement := ParseDateTime(child, path+'/issued') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'performer') then
        result.performer := ParseReference{Resource}(child, path+'/performer') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'requestDetail') then
        result.requestDetailList.Add(ParseReference{TFhirDiagnosticOrder}(child, path+'/requestDetail')){y.2}
      else if (child.baseName = 'serviceCategory') then
        result.serviceCategory := ParseCodeableConcept(child, path+'/serviceCategory') {b}
      else if (child.baseName = 'diagnosticDateTime') then
        result.diagnostic := ParseDateTime(child, path+'/diagnosticDateTime'){x.3}
      else if (child.baseName = 'diagnosticPeriod') then
        result.diagnostic := ParsePeriod(child, path+'/diagnosticPeriod'){x.3}
      else if (child.baseName = 'specimen') then
        result.specimenList.Add(ParseReference{TFhirSpecimen}(child, path+'/specimen')){y.2}
      else if (child.baseName = 'result') then
        result.resultList.Add(ParseReference{TFhirObservation}(child, path+'/result')){y.2}
      else if (child.baseName = 'imagingStudy') then
        result.imagingStudyList.Add(ParseReference{TFhirImagingStudy}(child, path+'/imagingStudy')){y.2}
      else if (child.baseName = 'image') then
        result.imageList.Add(ParseDiagnosticReportImage(child, path+'/image')){y.2}
      else if (child.baseName = 'conclusion') then
        result.conclusionElement := ParseString(child, path+'/conclusion') {b}
      else if (child.baseName = 'codedDiagnosis') then
        result.codedDiagnosisList.Add(ParseCodeableConcept(child, path+'/codedDiagnosis')){y.2}
      else if (child.baseName = 'presentedForm') then
        result.presentedFormList.Add(ParseAttachment(child, path+'/presentedForm')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReport(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReport);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeCodeableConcept(xml, 'name', elem.name);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDiagnosticReportStatus);
  ComposeDateTime(xml, 'issued', elem.issuedElement);{x.2}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{Resource}(xml, 'performer', elem.performer);{x.2}
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  for i := 0 to elem.requestDetailList.Count - 1 do
    ComposeReference{TFhirDiagnosticOrder}(xml, 'requestDetail', elem.requestDetailList[i]);
  ComposeCodeableConcept(xml, 'serviceCategory', elem.serviceCategory);{x.2}
  if (elem.diagnostic is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'diagnosticDateTime', TFhirDateTime(elem.diagnostic))
  else if (elem.diagnostic is TFhirPeriod) {6} then
    ComposePeriod(xml, 'diagnosticPeriod', TFhirPeriod(elem.diagnostic));
  for i := 0 to elem.specimenList.Count - 1 do
    ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimenList[i]);
  for i := 0 to elem.resultList.Count - 1 do
    ComposeReference{TFhirObservation}(xml, 'result', elem.resultList[i]);
  for i := 0 to elem.imagingStudyList.Count - 1 do
    ComposeReference{TFhirImagingStudy}(xml, 'imagingStudy', elem.imagingStudyList[i]);
  for i := 0 to elem.imageList.Count - 1 do
    ComposeDiagnosticReportImage(xml, 'image', elem.imageList[i]);
  ComposeString(xml, 'conclusion', elem.conclusionElement);{x.2}
  for i := 0 to elem.codedDiagnosisList.Count - 1 do
    ComposeCodeableConcept(xml, 'codedDiagnosis', elem.codedDiagnosisList[i]);
  for i := 0 to elem.presentedFormList.Count - 1 do
    ComposeAttachment(xml, 'presentedForm', elem.presentedFormList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticReport(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticReport(jsn)); {2}
end;

function TFHIRJsonParser.ParseDiagnosticReport(jsn : TJsonObject) : TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('name') then
        result.name := ParseCodeableConcept(jsn.vObj['name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticReportStatus);
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := ParseDateTime(jsn['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('performer') then
        result.performer := ParseReference{Resource}(jsn.vObj['performer']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('requestDetail') then
      iterateArray(jsn.vArr['requestDetail'], result.requestDetailList, parseReference{TFhirDiagnosticOrder});
    if jsn.has('serviceCategory') then
        result.serviceCategory := ParseCodeableConcept(jsn.vObj['serviceCategory']);{q}
    if jsn.has('diagnosticDateTime') or jsn.has('_diagnosticDateTime') then
      result.diagnostic := parseDateTime(jsn['diagnosticDateTime'], jsn.vObj['_diagnosticDateTime']);
    if jsn.has('diagnosticPeriod') {a4} then
      result.diagnostic := ParsePeriod(jsn.vObj['diagnosticPeriod']);
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseReference{TFhirSpecimen});
    if jsn.has('result') then
      iterateArray(jsn.vArr['result'], result.resultList, parseReference{TFhirObservation});
    if jsn.has('imagingStudy') then
      iterateArray(jsn.vArr['imagingStudy'], result.imagingStudyList, parseReference{TFhirImagingStudy});
    if jsn.has('image') then
      iterateArray(jsn.vArr['image'], result.imageList, parseDiagnosticReportImage);
    if jsn.has('conclusion') or jsn.has('_conclusion') then
        result.conclusionElement := ParseString(jsn['conclusion'], jsn.vObj['_conclusion']);{q}
    if jsn.has('codedDiagnosis') then
      iterateArray(jsn.vArr['codedDiagnosis'], result.codedDiagnosisList, parseCodeableConcept);
    if jsn.has('presentedForm') then
      iterateArray(jsn.vArr['presentedForm'], result.presentedFormList, parseAttachment);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticReport(json : TJSONWriter; name : string; elem : TFhirDiagnosticReport; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeCodeableConcept(json, 'name', elem.name); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticReportStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticReportStatus, false);
  ComposeDateTimeValue(json, 'issued', elem.issuedElement, false);
  ComposeDateTimeProps(json, 'issued', elem.issuedElement, false);
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeReference{Resource}(json, 'performer', elem.performer); {a}
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if elem.requestDetailList.Count > 0 then
  begin
    json.valueArray('requestDetail');
    for i := 0 to elem.requestDetailList.Count - 1 do
      ComposeReference{TFhirDiagnosticOrder}(json, '',elem.requestDetailList[i]); {z - Reference(DiagnosticOrder)}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'serviceCategory', elem.serviceCategory); {a}
  if (elem.diagnostic is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'diagnosticDateTime', TFhirDateTime(elem.diagnostic), false);
    ComposeDateTimeProps(json, 'diagnosticDateTime', TFhirDateTime(elem.diagnostic), false);
  end
  else if (elem.diagnostic is TFhirPeriod) then 
    ComposePeriod(json, 'diagnosticPeriod', TFhirPeriod(elem.diagnostic)) ;
  if elem.specimenList.Count > 0 then
  begin
    json.valueArray('specimen');
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '',elem.specimenList[i]); {z - Reference(Specimen)}
    json.FinishArray;
  end;
  if elem.resultList.Count > 0 then
  begin
    json.valueArray('result');
    for i := 0 to elem.resultList.Count - 1 do
      ComposeReference{TFhirObservation}(json, '',elem.resultList[i]); {z - Reference(Observation)}
    json.FinishArray;
  end;
  if elem.imagingStudyList.Count > 0 then
  begin
    json.valueArray('imagingStudy');
    for i := 0 to elem.imagingStudyList.Count - 1 do
      ComposeReference{TFhirImagingStudy}(json, '',elem.imagingStudyList[i]); {z - Reference(ImagingStudy)}
    json.FinishArray;
  end;
  if elem.imageList.Count > 0 then
  begin
    json.valueArray('image');
    for i := 0 to elem.imageList.Count - 1 do
      ComposeDiagnosticReportImage(json, '',elem.imageList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'conclusion', elem.conclusionElement, false);
  ComposeStringProps(json, 'conclusion', elem.conclusionElement, false);
  if elem.codedDiagnosisList.Count > 0 then
  begin
    json.valueArray('codedDiagnosis');
    for i := 0 to elem.codedDiagnosisList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.codedDiagnosisList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.presentedFormList.Count > 0 then
  begin
    json.valueArray('presentedForm');
    for i := 0 to elem.presentedFormList.Count - 1 do
      ComposeAttachment(json, '',elem.presentedFormList[i]); {z - Attachment}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseDocumentManifestContent(element : IXmlDomElement; path : string) : TFhirDocumentManifestContent;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentManifestContent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'pAttachment') then
        result.p := ParseAttachment(child, path+'/pAttachment'){x.3}
      else if (child.baseName = 'pReference') then
        result.p := ParseReference(child, path+'/pReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifestContent(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifestContent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (elem.p is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'pAttachment', TFhirAttachment(elem.p))
  else if (elem.p is TFhirReference) {2} then
    ComposeReference(xml, 'pReference', TFhirReference(elem.p));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentManifestContent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentManifestContent(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentManifestContent(jsn : TJsonObject) : TFhirDocumentManifestContent;
begin
  result := TFhirDocumentManifestContent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('pAttachment') {a4} then
      result.p := ParseAttachment(jsn.vObj['pAttachment']);
    if jsn.has('pReference') {a3} then
      result.p := ParseReference(jsn.vObj['pReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentManifestContent(json : TJSONWriter; name : string; elem : TFhirDocumentManifestContent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.p is TFhirAttachment) then 
    ComposeAttachment(json, 'pAttachment', TFhirAttachment(elem.p)) 
  else if (elem.p is TFhirReference) then
    ComposeReference(json, 'pReference', TFhirReference(elem.p));
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseDocumentManifestRelated(element : IXmlDomElement; path : string) : TFhirDocumentManifestRelated;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentManifestRelated.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'ref') then
        result.ref := ParseReference{TFhirReference}(child, path+'/ref') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifestRelated(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifestRelated);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeReference{TFhirReference}(xml, 'ref', elem.ref);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentManifestRelated(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentManifestRelated(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentManifestRelated(jsn : TJsonObject) : TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('ref') then
        result.ref := ParseReference{TFhirReference}(jsn.vObj['ref']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentManifestRelated(json : TJSONWriter; name : string; elem : TFhirDocumentManifestRelated; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeReference{TFhirReference}(json, 'ref', elem.ref); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseDocumentManifest(element : IXmlDomElement; path : string) : TFhirDocumentManifest;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentManifest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(child, path+'/masterIdentifier') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'recipient') then
        result.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'author') then
        result.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'source') then
        result.sourceElement := ParseUri(child, path+'/source') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirDocumentReferenceStatus, path+'/status', child){1a}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'content') then
        result.contentList.Add(ParseDocumentManifestContent(child, path+'/content')){y.2}
      else if (child.baseName = 'related') then
        result.relatedList.Add(ParseDocumentManifestRelated(child, path+'/related')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifest(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'masterIdentifier', elem.masterIdentifier);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  for i := 0 to elem.recipientList.Count - 1 do
    ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  for i := 0 to elem.authorList.Count - 1 do
    ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  ComposeUri(xml, 'source', elem.sourceElement);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatus);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  for i := 0 to elem.contentList.Count - 1 do
    ComposeDocumentManifestContent(xml, 'content', elem.contentList[i]);
  for i := 0 to elem.relatedList.Count - 1 do
    ComposeDocumentManifestRelated(xml, 'related', elem.relatedList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentManifest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentManifest(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentManifest(jsn : TJsonObject) : TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(jsn.vObj['masterIdentifier']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{Resource});
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{Resource});
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('source') or jsn.has('_source') then
        result.sourceElement := ParseUri(jsn['source'], jsn.vObj['_source']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDocumentReferenceStatus);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseDocumentManifestContent);
    if jsn.has('related') then
      iterateArray(jsn.vArr['related'], result.relatedList, parseDocumentManifestRelated);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentManifest(json : TJSONWriter; name : string; elem : TFhirDocumentManifest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeIdentifier(json, 'masterIdentifier', elem.masterIdentifier); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if elem.recipientList.Count > 0 then
  begin
    json.valueArray('recipient');
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.recipientList[i]); {z - Reference(Patient|Practitioner|Organization)}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.authorList.Count > 0 then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.authorList[i]); {z - Reference(Practitioner|Organization|Device|Patient|RelatedPerson)}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  ComposeUriValue(json, 'source', elem.sourceElement, false);
  ComposeUriProps(json, 'source', elem.sourceElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatus, false);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if elem.contentList.Count > 0 then
  begin
    json.valueArray('content');
    for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentManifestContent(json, '',elem.contentList[i]); {z - }
    json.FinishArray;
  end;
  if elem.relatedList.Count > 0 then
  begin
    json.valueArray('related');
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentManifestRelated(json, '',elem.relatedList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceRelatesTo(element : IXmlDomElement; path : string) : TFhirDocumentReferenceRelatesTo;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeElement := ParseEnum(CODES_TFhirDocumentRelationshipType, path+'/code', child){1a}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirDocumentReference}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceRelatesTo(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceRelatesTo);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipType);
  ComposeReference{TFhirDocumentReference}(xml, 'target', elem.target);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceRelatesTo(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceRelatesTo(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReferenceRelatesTo(jsn : TJsonObject) : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn['code'], jsn.vObj['_code'], CODES_TFhirDocumentRelationshipType);
    if jsn.has('target') then
        result.target := ParseReference{TFhirDocumentReference}(jsn.vObj['target']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceRelatesTo(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceRelatesTo; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipType, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipType, false);
  ComposeReference{TFhirDocumentReference}(json, 'target', elem.target); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseDocumentReferenceContext(element : IXmlDomElement; path : string) : TFhirDocumentReferenceContext;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'event') then
        result.eventList.Add(ParseCodeableConcept(child, path+'/event')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'facilityType') then
        result.facilityType := ParseCodeableConcept(child, path+'/facilityType') {b}
      else if (child.baseName = 'practiceSetting') then
        result.practiceSetting := ParseCodeableConcept(child, path+'/practiceSetting') {b}
      else if (child.baseName = 'sourcePatientInfo') then
        result.sourcePatientInfo := ParseReference{TFhirPatient}(child, path+'/sourcePatientInfo') {b}
      else if (child.baseName = 'related') then
        result.relatedList.Add(ParseDocumentReferenceContextRelated(child, path+'/related')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContext(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContext);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.eventList.Count - 1 do
    ComposeCodeableConcept(xml, 'event', elem.eventList[i]);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  ComposeCodeableConcept(xml, 'facilityType', elem.facilityType);{x.2}
  ComposeCodeableConcept(xml, 'practiceSetting', elem.practiceSetting);{x.2}
  ComposeReference{TFhirPatient}(xml, 'sourcePatientInfo', elem.sourcePatientInfo);{x.2}
  for i := 0 to elem.relatedList.Count - 1 do
    ComposeDocumentReferenceContextRelated(xml, 'related', elem.relatedList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceContext(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceContext(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReferenceContext(jsn : TJsonObject) : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('facilityType') then
        result.facilityType := ParseCodeableConcept(jsn.vObj['facilityType']);{q}
    if jsn.has('practiceSetting') then
        result.practiceSetting := ParseCodeableConcept(jsn.vObj['practiceSetting']);{q}
    if jsn.has('sourcePatientInfo') then
        result.sourcePatientInfo := ParseReference{TFhirPatient}(jsn.vObj['sourcePatientInfo']);{q}
    if jsn.has('related') then
      iterateArray(jsn.vArr['related'], result.relatedList, parseDocumentReferenceContextRelated);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceContext(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContext; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.eventList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeCodeableConcept(json, 'facilityType', elem.facilityType); {a}
  ComposeCodeableConcept(json, 'practiceSetting', elem.practiceSetting); {a}
  ComposeReference{TFhirPatient}(json, 'sourcePatientInfo', elem.sourcePatientInfo); {a}
  if elem.relatedList.Count > 0 then
  begin
    json.valueArray('related');
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentReferenceContextRelated(json, '',elem.relatedList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseDocumentReferenceContextRelated(element : IXmlDomElement; path : string) : TFhirDocumentReferenceContextRelated;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReferenceContextRelated.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'ref') then
        result.ref := ParseReference{TFhirReference}(child, path+'/ref') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContextRelated(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContextRelated);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeReference{TFhirReference}(xml, 'ref', elem.ref);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceContextRelated(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceContextRelated(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReferenceContextRelated(jsn : TJsonObject) : TFhirDocumentReferenceContextRelated;
begin
  result := TFhirDocumentReferenceContextRelated.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('ref') then
        result.ref := ParseReference{TFhirReference}(jsn.vObj['ref']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceContextRelated(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContextRelated; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeReference{TFhirReference}(json, 'ref', elem.ref); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseDocumentReference(element : IXmlDomElement; path : string) : TFhirDocumentReference;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReference.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(child, path+'/masterIdentifier') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'class') then
        result.class_ := ParseCodeableConcept(child, path+'/class') {b}
      else if (child.baseName = 'format') then
        result.formatList.Add(ParseUri(child, path+'/format')){y.2}
      else if (child.baseName = 'author') then
        result.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.baseName = 'custodian') then
        result.custodian := ParseReference{TFhirOrganization}(child, path+'/custodian') {b}
      else if (child.baseName = 'authenticator') then
        result.authenticator := ParseReference{Resource}(child, path+'/authenticator') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'indexed') then
        result.indexedElement := ParseInstant(child, path+'/indexed') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirDocumentReferenceStatus, path+'/status', child){1a}
      else if (child.baseName = 'docStatus') then
        result.docStatus := ParseCodeableConcept(child, path+'/docStatus') {b}
      else if (child.baseName = 'relatesTo') then
        result.relatesToList.Add(ParseDocumentReferenceRelatesTo(child, path+'/relatesTo')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'confidentiality') then
        result.confidentialityList.Add(ParseCodeableConcept(child, path+'/confidentiality')){y.2}
      else if (child.baseName = 'content') then
        result.contentList.Add(ParseAttachment(child, path+'/content')){y.2}
      else if (child.baseName = 'context') then
        result.context := ParseDocumentReferenceContext(child, path+'/context') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReference(xml : TXmlBuilder; name : string; elem : TFhirDocumentReference);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'masterIdentifier', elem.masterIdentifier);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeCodeableConcept(xml, 'class', elem.class_);{x.2}
  for i := 0 to elem.formatList.Count - 1 do
    ComposeUri(xml, 'format', elem.formatList[i]);
  for i := 0 to elem.authorList.Count - 1 do
    ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  ComposeReference{TFhirOrganization}(xml, 'custodian', elem.custodian);{x.2}
  ComposeReference{Resource}(xml, 'authenticator', elem.authenticator);{x.2}
  ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  ComposeInstant(xml, 'indexed', elem.indexedElement);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatus);
  ComposeCodeableConcept(xml, 'docStatus', elem.docStatus);{x.2}
  for i := 0 to elem.relatesToList.Count - 1 do
    ComposeDocumentReferenceRelatesTo(xml, 'relatesTo', elem.relatesToList[i]);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  for i := 0 to elem.confidentialityList.Count - 1 do
    ComposeCodeableConcept(xml, 'confidentiality', elem.confidentialityList[i]);
  for i := 0 to elem.contentList.Count - 1 do
    ComposeAttachment(xml, 'content', elem.contentList[i]);
  ComposeDocumentReferenceContext(xml, 'context', elem.context);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReference(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReference(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReference(jsn : TJsonObject) : TFhirDocumentReference;
begin
  result := TFhirDocumentReference.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(jsn.vObj['masterIdentifier']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('class') then
        result.class_ := ParseCodeableConcept(jsn.vObj['class']);{q}
      if jsn.has('format') or jsn.has('_format') then
      iteratePrimitiveArray(jsn.vArr['format'], jsn.vArr['_format'], result.formatList, parseUri);
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{Resource});
    if jsn.has('custodian') then
        result.custodian := ParseReference{TFhirOrganization}(jsn.vObj['custodian']);{q}
    if jsn.has('authenticator') then
        result.authenticator := ParseReference{Resource}(jsn.vObj['authenticator']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('indexed') or jsn.has('_indexed') then
        result.indexedElement := ParseInstant(jsn['indexed'], jsn.vObj['_indexed']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDocumentReferenceStatus);
    if jsn.has('docStatus') then
        result.docStatus := ParseCodeableConcept(jsn.vObj['docStatus']);{q}
    if jsn.has('relatesTo') then
      iterateArray(jsn.vArr['relatesTo'], result.relatesToList, parseDocumentReferenceRelatesTo);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('confidentiality') then
      iterateArray(jsn.vArr['confidentiality'], result.confidentialityList, parseCodeableConcept);
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseAttachment);
    if jsn.has('context') then
        result.context := ParseDocumentReferenceContext(jsn.vObj['context']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReference(json : TJSONWriter; name : string; elem : TFhirDocumentReference; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeIdentifier(json, 'masterIdentifier', elem.masterIdentifier); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeCodeableConcept(json, 'class', elem.class_); {a}
  if elem.formatList.Count > 0 then
  begin
    json.valueArray('format');
    ext := false;
    for i := 0 to elem.formatList.Count - 1 do
    begin
      ext := ext or ((elem.formatList[i].id <> '') or (elem.formatList[i].hasExtensionList));
      ComposeUriValue(json, '',elem.formatList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_format');
      for i := 0 to elem.formatList.Count - 1 do
        ComposeUriProps(json, '',elem.formatList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.authorList.Count > 0 then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.authorList[i]); {z - Reference(Practitioner|Organization|Device|Patient|RelatedPerson)}
    json.FinishArray;
  end;
  ComposeReference{TFhirOrganization}(json, 'custodian', elem.custodian); {a}
  ComposeReference{Resource}(json, 'authenticator', elem.authenticator); {a}
  ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  ComposeInstantValue(json, 'indexed', elem.indexedElement, false);
  ComposeInstantProps(json, 'indexed', elem.indexedElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatus, false);
  ComposeCodeableConcept(json, 'docStatus', elem.docStatus); {a}
  if elem.relatesToList.Count > 0 then
  begin
    json.valueArray('relatesTo');
    for i := 0 to elem.relatesToList.Count - 1 do
      ComposeDocumentReferenceRelatesTo(json, '',elem.relatesToList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if elem.confidentialityList.Count > 0 then
  begin
    json.valueArray('confidentiality');
    for i := 0 to elem.confidentialityList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.confidentialityList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.contentList.Count > 0 then
  begin
    json.valueArray('content');
    for i := 0 to elem.contentList.Count - 1 do
      ComposeAttachment(json, '',elem.contentList[i]); {z - Attachment}
    json.FinishArray;
  end;
  ComposeDocumentReferenceContext(json, 'context', elem.context); {a}
end;

function TFHIRXmlParser.ParseEligibilityRequest(element : IXmlDomElement; path : string) : TFhirEligibilityRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirEligibilityRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirOrganization}(child, path+'/target') {b}
      else if (child.baseName = 'provider') then
        result.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEligibilityRequest(xml : TXmlBuilder; name : string; elem : TFhirEligibilityRequest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'target', elem.target);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEligibilityRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEligibilityRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseEligibilityRequest(jsn : TJsonObject) : TFhirEligibilityRequest;
begin
  result := TFhirEligibilityRequest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirOrganization}(jsn.vObj['target']);{q}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEligibilityRequest(json : TJSONWriter; name : string; elem : TFhirEligibilityRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  ComposeReference{TFhirOrganization}(json, 'target', elem.target); {a}
  ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
end;

function TFHIRXmlParser.ParseEligibilityResponse(element : IXmlDomElement; path : string) : TFhirEligibilityResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirEligibilityResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirEligibilityRequest}(child, path+'/request') {b}
      else if (child.baseName = 'outcome') then
        result.outcomeElement := ParseEnum(CODES_TFhirRSLink, path+'/outcome', child){1a}
      else if (child.baseName = 'disposition') then
        result.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.baseName = 'requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEligibilityResponse(xml : TXmlBuilder; name : string; elem : TFhirEligibilityResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirEligibilityRequest}(xml, 'request', elem.request);{x.2}
  ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirRSLink);
  ComposeString(xml, 'disposition', elem.dispositionElement);{x.2}
  ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEligibilityResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEligibilityResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseEligibilityResponse(jsn : TJsonObject) : TFhirEligibilityResponse;
begin
  result := TFhirEligibilityResponse.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirEligibilityRequest}(jsn.vObj['request']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn['outcome'], jsn.vObj['_outcome'], CODES_TFhirRSLink);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEligibilityResponse(json : TJSONWriter; name : string; elem : TFhirEligibilityResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirEligibilityRequest}(json, 'request', elem.request); {a}
  ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRSLink, false);
  ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRSLink, false);
  ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
end;

function TFHIRXmlParser.ParseEncounterStatusHistory(element : IXmlDomElement; path : string) : TFhirEncounterStatusHistory;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounterStatusHistory.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirEncounterState, path+'/status', child){1a}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounterStatusHistory(xml : TXmlBuilder; name : string; elem : TFhirEncounterStatusHistory);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEncounterState);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounterStatusHistory(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterStatusHistory(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterStatusHistory(jsn : TJsonObject) : TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirEncounterState);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounterStatusHistory(json : TJSONWriter; name : string; elem : TFhirEncounterStatusHistory; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEncounterState, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEncounterState, false);
  ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseEncounterParticipant(element : IXmlDomElement; path : string) : TFhirEncounterParticipant;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounterParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'individual') then
        result.individual := ParseReference{Resource}(child, path+'/individual') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounterParticipant(xml : TXmlBuilder; name : string; elem : TFhirEncounterParticipant);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  ComposeReference{Resource}(xml, 'individual', elem.individual);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounterParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterParticipant(jsn : TJsonObject) : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('individual') then
        result.individual := ParseReference{Resource}(jsn.vObj['individual']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounterParticipant(json : TJSONWriter; name : string; elem : TFhirEncounterParticipant; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '',elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeReference{Resource}(json, 'individual', elem.individual); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseEncounterHospitalization(element : IXmlDomElement; path : string) : TFhirEncounterHospitalization;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounterHospitalization.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'preAdmissionIdentifier') then
        result.preAdmissionIdentifier := ParseIdentifier(child, path+'/preAdmissionIdentifier') {b}
      else if (child.baseName = 'origin') then
        result.origin := ParseReference{TFhirLocation}(child, path+'/origin') {b}
      else if (child.baseName = 'admitSource') then
        result.admitSource := ParseCodeableConcept(child, path+'/admitSource') {b}
      else if (child.baseName = 'dietPreference') then
        result.dietPreference := ParseCodeableConcept(child, path+'/dietPreference') {b}
      else if (child.baseName = 'specialCourtesy') then
        result.specialCourtesyList.Add(ParseCodeableConcept(child, path+'/specialCourtesy')){y.2}
      else if (child.baseName = 'specialArrangement') then
        result.specialArrangementList.Add(ParseCodeableConcept(child, path+'/specialArrangement')){y.2}
      else if (child.baseName = 'destination') then
        result.destination := ParseReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.baseName = 'dischargeDisposition') then
        result.dischargeDisposition := ParseCodeableConcept(child, path+'/dischargeDisposition') {b}
      else if (child.baseName = 'dischargeDiagnosis') then
        result.dischargeDiagnosis := ParseReference{TFhirReference}(child, path+'/dischargeDiagnosis') {b}
      else if (child.baseName = 'reAdmission') then
        result.reAdmissionElement := ParseBoolean(child, path+'/reAdmission') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounterHospitalization(xml : TXmlBuilder; name : string; elem : TFhirEncounterHospitalization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'preAdmissionIdentifier', elem.preAdmissionIdentifier);{x.2}
  ComposeReference{TFhirLocation}(xml, 'origin', elem.origin);{x.2}
  ComposeCodeableConcept(xml, 'admitSource', elem.admitSource);{x.2}
  ComposeCodeableConcept(xml, 'dietPreference', elem.dietPreference);{x.2}
  for i := 0 to elem.specialCourtesyList.Count - 1 do
    ComposeCodeableConcept(xml, 'specialCourtesy', elem.specialCourtesyList[i]);
  for i := 0 to elem.specialArrangementList.Count - 1 do
    ComposeCodeableConcept(xml, 'specialArrangement', elem.specialArrangementList[i]);
  ComposeReference{TFhirLocation}(xml, 'destination', elem.destination);{x.2}
  ComposeCodeableConcept(xml, 'dischargeDisposition', elem.dischargeDisposition);{x.2}
  ComposeReference{TFhirReference}(xml, 'dischargeDiagnosis', elem.dischargeDiagnosis);{x.2}
  ComposeBoolean(xml, 'reAdmission', elem.reAdmissionElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounterHospitalization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterHospitalization(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterHospitalization(jsn : TJsonObject) : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('preAdmissionIdentifier') then
        result.preAdmissionIdentifier := ParseIdentifier(jsn.vObj['preAdmissionIdentifier']);{q}
    if jsn.has('origin') then
        result.origin := ParseReference{TFhirLocation}(jsn.vObj['origin']);{q}
    if jsn.has('admitSource') then
        result.admitSource := ParseCodeableConcept(jsn.vObj['admitSource']);{q}
    if jsn.has('dietPreference') then
        result.dietPreference := ParseCodeableConcept(jsn.vObj['dietPreference']);{q}
    if jsn.has('specialCourtesy') then
      iterateArray(jsn.vArr['specialCourtesy'], result.specialCourtesyList, parseCodeableConcept);
    if jsn.has('specialArrangement') then
      iterateArray(jsn.vArr['specialArrangement'], result.specialArrangementList, parseCodeableConcept);
    if jsn.has('destination') then
        result.destination := ParseReference{TFhirLocation}(jsn.vObj['destination']);{q}
    if jsn.has('dischargeDisposition') then
        result.dischargeDisposition := ParseCodeableConcept(jsn.vObj['dischargeDisposition']);{q}
    if jsn.has('dischargeDiagnosis') then
        result.dischargeDiagnosis := ParseReference{TFhirReference}(jsn.vObj['dischargeDiagnosis']);{q}
    if jsn.has('reAdmission') or jsn.has('_reAdmission') then
        result.reAdmissionElement := ParseBoolean(jsn['reAdmission'], jsn.vObj['_reAdmission']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounterHospitalization(json : TJSONWriter; name : string; elem : TFhirEncounterHospitalization; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'preAdmissionIdentifier', elem.preAdmissionIdentifier); {a}
  ComposeReference{TFhirLocation}(json, 'origin', elem.origin); {a}
  ComposeCodeableConcept(json, 'admitSource', elem.admitSource); {a}
  ComposeCodeableConcept(json, 'dietPreference', elem.dietPreference); {a}
  if elem.specialCourtesyList.Count > 0 then
  begin
    json.valueArray('specialCourtesy');
    for i := 0 to elem.specialCourtesyList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.specialCourtesyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.specialArrangementList.Count > 0 then
  begin
    json.valueArray('specialArrangement');
    for i := 0 to elem.specialArrangementList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.specialArrangementList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  ComposeCodeableConcept(json, 'dischargeDisposition', elem.dischargeDisposition); {a}
  ComposeReference{TFhirReference}(json, 'dischargeDiagnosis', elem.dischargeDiagnosis); {a}
  ComposeBooleanValue(json, 'reAdmission', elem.reAdmissionElement, false);
  ComposeBooleanProps(json, 'reAdmission', elem.reAdmissionElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseEncounterLocation(element : IXmlDomElement; path : string) : TFhirEncounterLocation;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounterLocation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirEncounterLocationStatus, path+'/status', child){1a}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounterLocation(xml : TXmlBuilder; name : string; elem : TFhirEncounterLocation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEncounterLocationStatus);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounterLocation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterLocation(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterLocation(jsn : TJsonObject) : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirEncounterLocationStatus);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounterLocation(json : TJSONWriter; name : string; elem : TFhirEncounterLocation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEncounterLocationStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEncounterLocationStatus, false);
  ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseEncounter(element : IXmlDomElement; path : string) : TFhirEncounter;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounter.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirEncounterState, path+'/status', child){1a}
      else if (child.baseName = 'statusHistory') then
        result.statusHistoryList.Add(ParseEncounterStatusHistory(child, path+'/statusHistory')){y.2}
      else if (child.baseName = 'class') then
        result.class_Element := ParseEnum(CODES_TFhirEncounterClass, path+'/class', child){1a}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'episodeOfCare') then
        result.episodeOfCare := ParseReference{TFhirEpisodeOfCare}(child, path+'/episodeOfCare') {b}
      else if (child.baseName = 'incomingReferralRequest') then
        result.incomingReferralRequestList.Add(ParseReference{TFhirReferralRequest}(child, path+'/incomingReferralRequest')){y.2}
      else if (child.baseName = 'participant') then
        result.participantList.Add(ParseEncounterParticipant(child, path+'/participant')){y.2}
      else if (child.baseName = 'fulfills') then
        result.fulfills := ParseReference{TFhirAppointment}(child, path+'/fulfills') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'length') then
        result.length := ParseQuantity(child, path+'/length') {b}
      else if (child.baseName = 'reason') then
        result.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.baseName = 'indication') then
        result.indicationList.Add(ParseReference{TFhirReference}(child, path+'/indication')){y.2}
      else if (child.baseName = 'priority') then
        result.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if (child.baseName = 'hospitalization') then
        result.hospitalization := ParseEncounterHospitalization(child, path+'/hospitalization') {b}
      else if (child.baseName = 'location') then
        result.locationList.Add(ParseEncounterLocation(child, path+'/location')){y.2}
      else if (child.baseName = 'serviceProvider') then
        result.serviceProvider := ParseReference{TFhirOrganization}(child, path+'/serviceProvider') {b}
      else if (child.baseName = 'partOf') then
        result.partOf := ParseReference{TFhirEncounter}(child, path+'/partOf') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounter(xml : TXmlBuilder; name : string; elem : TFhirEncounter);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEncounterState);
  for i := 0 to elem.statusHistoryList.Count - 1 do
    ComposeEncounterStatusHistory(xml, 'statusHistory', elem.statusHistoryList[i]);
  ComposeEnum(xml, 'class', elem.Class_Element, CODES_TFhirEncounterClass);
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeReference{TFhirEpisodeOfCare}(xml, 'episodeOfCare', elem.episodeOfCare);{x.2}
  for i := 0 to elem.incomingReferralRequestList.Count - 1 do
    ComposeReference{TFhirReferralRequest}(xml, 'incomingReferralRequest', elem.incomingReferralRequestList[i]);
  for i := 0 to elem.participantList.Count - 1 do
    ComposeEncounterParticipant(xml, 'participant', elem.participantList[i]);
  ComposeReference{TFhirAppointment}(xml, 'fulfills', elem.fulfills);{x.2}
  ComposePeriod(xml, 'period', elem.period);{x.2}
  ComposeQuantity(xml, 'length', elem.length);{x.2}
  for i := 0 to elem.reasonList.Count - 1 do
    ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  for i := 0 to elem.indicationList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'indication', elem.indicationList[i]);
  ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2}
  ComposeEncounterHospitalization(xml, 'hospitalization', elem.hospitalization);{x.2}
  for i := 0 to elem.locationList.Count - 1 do
    ComposeEncounterLocation(xml, 'location', elem.locationList[i]);
  ComposeReference{TFhirOrganization}(xml, 'serviceProvider', elem.serviceProvider);{x.2}
  ComposeReference{TFhirEncounter}(xml, 'partOf', elem.partOf);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounter(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounter(jsn : TJsonObject) : TFhirEncounter;
begin
  result := TFhirEncounter.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirEncounterState);
    if jsn.has('statusHistory') then
      iterateArray(jsn.vArr['statusHistory'], result.statusHistoryList, parseEncounterStatusHistory);
    if jsn.has('class') or jsn.has('_class')  then
      result.class_Element := parseEnum(jsn['class'], jsn.vObj['_class'], CODES_TFhirEncounterClass);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('episodeOfCare') then
        result.episodeOfCare := ParseReference{TFhirEpisodeOfCare}(jsn.vObj['episodeOfCare']);{q}
    if jsn.has('incomingReferralRequest') then
      iterateArray(jsn.vArr['incomingReferralRequest'], result.incomingReferralRequestList, parseReference{TFhirReferralRequest});
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseEncounterParticipant);
    if jsn.has('fulfills') then
        result.fulfills := ParseReference{TFhirAppointment}(jsn.vObj['fulfills']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('length') then
        result.length := ParseQuantity(jsn.vObj['length']);{q}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('indication') then
      iterateArray(jsn.vArr['indication'], result.indicationList, parseReference{TFhirReference});
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q}
    if jsn.has('hospitalization') then
        result.hospitalization := ParseEncounterHospitalization(jsn.vObj['hospitalization']);{q}
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseEncounterLocation);
    if jsn.has('serviceProvider') then
        result.serviceProvider := ParseReference{TFhirOrganization}(jsn.vObj['serviceProvider']);{q}
    if jsn.has('partOf') then
        result.partOf := ParseReference{TFhirEncounter}(jsn.vObj['partOf']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounter(json : TJSONWriter; name : string; elem : TFhirEncounter; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEncounterState, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEncounterState, false);
  if elem.statusHistoryList.Count > 0 then
  begin
    json.valueArray('statusHistory');
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEncounterStatusHistory(json, '',elem.statusHistoryList[i]); {z - }
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'class', elem.Class_Element, CODES_TFhirEncounterClass, false);
  ComposeEnumProps(json, 'class', elem.Class_Element, CODES_TFhirEncounterClass, false);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '',elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeReference{TFhirEpisodeOfCare}(json, 'episodeOfCare', elem.episodeOfCare); {a}
  if elem.incomingReferralRequestList.Count > 0 then
  begin
    json.valueArray('incomingReferralRequest');
    for i := 0 to elem.incomingReferralRequestList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(json, '',elem.incomingReferralRequestList[i]); {z - Reference(ReferralRequest)}
    json.FinishArray;
  end;
  if elem.participantList.Count > 0 then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeEncounterParticipant(json, '',elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  ComposeReference{TFhirAppointment}(json, 'fulfills', elem.fulfills); {a}
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeQuantity(json, 'length', elem.length); {a}
  if elem.reasonList.Count > 0 then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.indicationList.Count > 0 then
  begin
    json.valueArray('indication');
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.indicationList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  ComposeEncounterHospitalization(json, 'hospitalization', elem.hospitalization); {a}
  if elem.locationList.Count > 0 then
  begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeEncounterLocation(json, '',elem.locationList[i]); {z - }
    json.FinishArray;
  end;
  ComposeReference{TFhirOrganization}(json, 'serviceProvider', elem.serviceProvider); {a}
  ComposeReference{TFhirEncounter}(json, 'partOf', elem.partOf); {a}
end;

function TFHIRXmlParser.ParseEnrollmentRequest(element : IXmlDomElement; path : string) : TFhirEnrollmentRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirEnrollmentRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirOrganization}(child, path+'/target') {b}
      else if (child.baseName = 'provider') then
        result.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'coverage') then
        result.coverage := ParseReference{TFhirCoverage}(child, path+'/coverage') {b}
      else if (child.baseName = 'relationship') then
        result.relationship := ParseCoding(child, path+'/relationship') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEnrollmentRequest(xml : TXmlBuilder; name : string; elem : TFhirEnrollmentRequest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'target', elem.target);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{TFhirCoverage}(xml, 'coverage', elem.coverage);{x.2}
  ComposeCoding(xml, 'relationship', elem.relationship);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEnrollmentRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEnrollmentRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseEnrollmentRequest(jsn : TJsonObject) : TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirOrganization}(jsn.vObj['target']);{q}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('coverage') then
        result.coverage := ParseReference{TFhirCoverage}(jsn.vObj['coverage']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCoding(jsn.vObj['relationship']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEnrollmentRequest(json : TJSONWriter; name : string; elem : TFhirEnrollmentRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  ComposeReference{TFhirOrganization}(json, 'target', elem.target); {a}
  ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeReference{TFhirCoverage}(json, 'coverage', elem.coverage); {a}
  ComposeCoding(json, 'relationship', elem.relationship); {a}
end;

function TFHIRXmlParser.ParseEnrollmentResponse(element : IXmlDomElement; path : string) : TFhirEnrollmentResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirEnrollmentResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirEnrollmentRequest}(child, path+'/request') {b}
      else if (child.baseName = 'outcome') then
        result.outcomeElement := ParseEnum(CODES_TFhirRSLink, path+'/outcome', child){1a}
      else if (child.baseName = 'disposition') then
        result.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.baseName = 'requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEnrollmentResponse(xml : TXmlBuilder; name : string; elem : TFhirEnrollmentResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirEnrollmentRequest}(xml, 'request', elem.request);{x.2}
  ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirRSLink);
  ComposeString(xml, 'disposition', elem.dispositionElement);{x.2}
  ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEnrollmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEnrollmentResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseEnrollmentResponse(jsn : TJsonObject) : TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirEnrollmentRequest}(jsn.vObj['request']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn['outcome'], jsn.vObj['_outcome'], CODES_TFhirRSLink);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEnrollmentResponse(json : TJSONWriter; name : string; elem : TFhirEnrollmentResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirEnrollmentRequest}(json, 'request', elem.request); {a}
  ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRSLink, false);
  ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRSLink, false);
  ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
end;

function TFHIRXmlParser.ParseEpisodeOfCareStatusHistory(element : IXmlDomElement; path : string) : TFhirEpisodeOfCareStatusHistory;
var
  child : IXMLDOMElement;
begin
  result := TFhirEpisodeOfCareStatusHistory.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirEpisodeOfCareStatus, path+'/status', child){1a}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareStatusHistory(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCareStatusHistory);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatus);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEpisodeOfCareStatusHistory(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEpisodeOfCareStatusHistory(jsn)); {2}
end;

function TFHIRJsonParser.ParseEpisodeOfCareStatusHistory(jsn : TJsonObject) : TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirEpisodeOfCareStatus);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEpisodeOfCareStatusHistory(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCareStatusHistory; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatus, false);
  ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseEpisodeOfCareCareTeam(element : IXmlDomElement; path : string) : TFhirEpisodeOfCareCareTeam;
var
  child : IXMLDOMElement;
begin
  result := TFhirEpisodeOfCareCareTeam.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'member') then
        result.member := ParseReference{Resource}(child, path+'/member') {b}
      else if (child.baseName = 'role') then
        result.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareCareTeam(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCareCareTeam);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'member', elem.member);{x.2}
  for i := 0 to elem.roleList.Count - 1 do
    ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEpisodeOfCareCareTeam(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEpisodeOfCareCareTeam(jsn)); {2}
end;

function TFHIRJsonParser.ParseEpisodeOfCareCareTeam(jsn : TJsonObject) : TFhirEpisodeOfCareCareTeam;
begin
  result := TFhirEpisodeOfCareCareTeam.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('member') then
        result.member := ParseReference{Resource}(jsn.vObj['member']);{q}
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEpisodeOfCareCareTeam(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCareCareTeam; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{Resource}(json, 'member', elem.member); {a}
  if elem.roleList.Count > 0 then
  begin
    json.valueArray('role');
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.roleList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseEpisodeOfCare(element : IXmlDomElement; path : string) : TFhirEpisodeOfCare;
var
  child : IXMLDOMElement;
begin
  result := TFhirEpisodeOfCare.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirEpisodeOfCareStatus, path+'/status', child){1a}
      else if (child.baseName = 'statusHistory') then
        result.statusHistoryList.Add(ParseEpisodeOfCareStatusHistory(child, path+'/statusHistory')){y.2}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'condition') then
        result.conditionList.Add(ParseReference{TFhirCondition}(child, path+'/condition')){y.2}
      else if (child.baseName = 'referralRequest') then
        result.referralRequestList.Add(ParseReference{TFhirReferralRequest}(child, path+'/referralRequest')){y.2}
      else if (child.baseName = 'careManager') then
        result.careManager := ParseReference{TFhirPractitioner}(child, path+'/careManager') {b}
      else if (child.baseName = 'careTeam') then
        result.careTeamList.Add(ParseEpisodeOfCareCareTeam(child, path+'/careTeam')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCare(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCare);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatus);
  for i := 0 to elem.statusHistoryList.Count - 1 do
    ComposeEpisodeOfCareStatusHistory(xml, 'statusHistory', elem.statusHistoryList[i]);
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2}
  ComposePeriod(xml, 'period', elem.period);{x.2}
  for i := 0 to elem.conditionList.Count - 1 do
    ComposeReference{TFhirCondition}(xml, 'condition', elem.conditionList[i]);
  for i := 0 to elem.referralRequestList.Count - 1 do
    ComposeReference{TFhirReferralRequest}(xml, 'referralRequest', elem.referralRequestList[i]);
  ComposeReference{TFhirPractitioner}(xml, 'careManager', elem.careManager);{x.2}
  for i := 0 to elem.careTeamList.Count - 1 do
    ComposeEpisodeOfCareCareTeam(xml, 'careTeam', elem.careTeamList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEpisodeOfCare(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEpisodeOfCare(jsn)); {2}
end;

function TFHIRJsonParser.ParseEpisodeOfCare(jsn : TJsonObject) : TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirEpisodeOfCareStatus);
    if jsn.has('statusHistory') then
      iterateArray(jsn.vArr['statusHistory'], result.statusHistoryList, parseEpisodeOfCareStatusHistory);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('condition') then
      iterateArray(jsn.vArr['condition'], result.conditionList, parseReference{TFhirCondition});
    if jsn.has('referralRequest') then
      iterateArray(jsn.vArr['referralRequest'], result.referralRequestList, parseReference{TFhirReferralRequest});
    if jsn.has('careManager') then
        result.careManager := ParseReference{TFhirPractitioner}(jsn.vObj['careManager']);{q}
    if jsn.has('careTeam') then
      iterateArray(jsn.vArr['careTeam'], result.careTeamList, parseEpisodeOfCareCareTeam);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEpisodeOfCare(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCare; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatus, false);
  if elem.statusHistoryList.Count > 0 then
  begin
    json.valueArray('statusHistory');
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEpisodeOfCareStatusHistory(json, '',elem.statusHistoryList[i]); {z - }
    json.FinishArray;
  end;
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '',elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  ComposePeriod(json, 'period', elem.period); {a}
  if elem.conditionList.Count > 0 then
  begin
    json.valueArray('condition');
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '',elem.conditionList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if elem.referralRequestList.Count > 0 then
  begin
    json.valueArray('referralRequest');
    for i := 0 to elem.referralRequestList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(json, '',elem.referralRequestList[i]); {z - Reference(ReferralRequest)}
    json.FinishArray;
  end;
  ComposeReference{TFhirPractitioner}(json, 'careManager', elem.careManager); {a}
  if elem.careTeamList.Count > 0 then
  begin
    json.valueArray('careTeam');
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeEpisodeOfCareCareTeam(json, '',elem.careTeamList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefit(element : IXmlDomElement; path : string) : TFhirExplanationOfBenefit;
var
  child : IXMLDOMElement;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirClaim}(child, path+'/request') {b}
      else if (child.baseName = 'outcome') then
        result.outcomeElement := ParseEnum(CODES_TFhirRSLink, path+'/outcome', child){1a}
      else if (child.baseName = 'disposition') then
        result.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.baseName = 'requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefit(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefit);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirClaim}(xml, 'request', elem.request);{x.2}
  ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirRSLink);
  ComposeString(xml, 'disposition', elem.dispositionElement);{x.2}
  ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefit(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefit(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefit(jsn : TJsonObject) : TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirClaim}(jsn.vObj['request']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn['outcome'], jsn.vObj['_outcome'], CODES_TFhirRSLink);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefit(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefit; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirClaim}(json, 'request', elem.request); {a}
  ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRSLink, false);
  ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRSLink, false);
  ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
end;

function TFHIRXmlParser.ParseFamilyMemberHistoryCondition(element : IXmlDomElement; path : string) : TFhirFamilyMemberHistoryCondition;
var
  child : IXMLDOMElement;
begin
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'outcome') then
        result.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.baseName = 'onsetAge') then
        result.onset := ParseAge(child, path+'/onsetAge'){x.3}
      else if (child.baseName = 'onsetRange') then
        result.onset := ParseRange(child, path+'/onsetRange'){x.3}
      else if (child.baseName = 'onsetString') then
        result.onset := ParseString(child, path+'/onsetString'){x.3}
      else if (child.baseName = 'note') then
        result.noteElement := ParseString(child, path+'/note') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistoryCondition(xml : TXmlBuilder; name : string; elem : TFhirFamilyMemberHistoryCondition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2}
  if (elem.onset is TFhirQuantity) {6} then
    ComposeAge(xml, 'onsetAge', TFhirQuantity(elem.onset))
  else if (elem.onset is TFhirRange) {6} then
    ComposeRange(xml, 'onsetRange', TFhirRange(elem.onset))
  else if (elem.onset is TFhirString) {6} then
    ComposeString(xml, 'onsetString', TFhirString(elem.onset));
  ComposeString(xml, 'note', elem.noteElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseFamilyMemberHistoryCondition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFamilyMemberHistoryCondition(jsn)); {2}
end;

function TFHIRJsonParser.ParseFamilyMemberHistoryCondition(jsn : TJsonObject) : TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('outcome') then
        result.outcome := ParseCodeableConcept(jsn.vObj['outcome']);{q}
    if jsn.has('onsetAge') {a4} then
      result.onset := ParseAge(jsn.vObj['onsetAge']);
    if jsn.has('onsetRange') {a4} then
      result.onset := ParseRange(jsn.vObj['onsetRange']);
    if jsn.has('onsetString') or jsn.has('_onsetString') then
      result.onset := parseString(jsn['onsetString'], jsn.vObj['_onsetString']);
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeFamilyMemberHistoryCondition(json : TJSONWriter; name : string; elem : TFhirFamilyMemberHistoryCondition; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeCodeableConcept(json, 'outcome', elem.outcome); {a}
  if (elem.onset is TFhirQuantity) then 
    ComposeAge(json, 'onsetAge', TFhirQuantity(elem.onset)) 
  else if (elem.onset is TFhirRange) then 
    ComposeRange(json, 'onsetRange', TFhirRange(elem.onset)) 
  else if (elem.onset is TFhirString) then 
  begin
    ComposeStringValue(json, 'onsetString', TFhirString(elem.onset), false);
    ComposeStringProps(json, 'onsetString', TFhirString(elem.onset), false);
  end;
  ComposeStringValue(json, 'note', elem.noteElement, false);
  ComposeStringProps(json, 'note', elem.noteElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseFamilyMemberHistory(element : IXmlDomElement; path : string) : TFhirFamilyMemberHistory;
var
  child : IXMLDOMElement;
begin
  result := TFhirFamilyMemberHistory.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'relationship') then
        result.relationship := ParseCodeableConcept(child, path+'/relationship') {b}
      else if (child.baseName = 'gender') then
        result.genderElement := ParseEnum(CODES_TFhirAdministrativeGender, path+'/gender', child){1a}
      else if (child.baseName = 'bornPeriod') then
        result.born := ParsePeriod(child, path+'/bornPeriod'){x.3}
      else if (child.baseName = 'bornDate') then
        result.born := ParseDate(child, path+'/bornDate'){x.3}
      else if (child.baseName = 'bornString') then
        result.born := ParseString(child, path+'/bornString'){x.3}
      else if (child.baseName = 'ageAge') then
        result.age := ParseAge(child, path+'/ageAge'){x.3}
      else if (child.baseName = 'ageRange') then
        result.age := ParseRange(child, path+'/ageRange'){x.3}
      else if (child.baseName = 'ageString') then
        result.age := ParseString(child, path+'/ageString'){x.3}
      else if (child.baseName = 'deceasedBoolean') then
        result.deceased := ParseBoolean(child, path+'/deceasedBoolean'){x.3}
      else if (child.baseName = 'deceasedAge') then
        result.deceased := ParseAge(child, path+'/deceasedAge'){x.3}
      else if (child.baseName = 'deceasedRange') then
        result.deceased := ParseRange(child, path+'/deceasedRange'){x.3}
      else if (child.baseName = 'deceasedDate') then
        result.deceased := ParseDate(child, path+'/deceasedDate'){x.3}
      else if (child.baseName = 'deceasedString') then
        result.deceased := ParseString(child, path+'/deceasedString'){x.3}
      else if (child.baseName = 'note') then
        result.noteElement := ParseString(child, path+'/note') {b}
      else if (child.baseName = 'condition') then
        result.conditionList.Add(ParseFamilyMemberHistoryCondition(child, path+'/condition')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistory(xml : TXmlBuilder; name : string; elem : TFhirFamilyMemberHistory);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeCodeableConcept(xml, 'relationship', elem.relationship);{x.2}
  ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender);
  if (elem.born is TFhirPeriod) {6} then
    ComposePeriod(xml, 'bornPeriod', TFhirPeriod(elem.born))
  else if (elem.born is TFhirDate) {6} then
    ComposeDate(xml, 'bornDate', TFhirDate(elem.born))
  else if (elem.born is TFhirString) {6} then
    ComposeString(xml, 'bornString', TFhirString(elem.born));
  if (elem.age is TFhirQuantity) {6} then
    ComposeAge(xml, 'ageAge', TFhirQuantity(elem.age))
  else if (elem.age is TFhirRange) {6} then
    ComposeRange(xml, 'ageRange', TFhirRange(elem.age))
  else if (elem.age is TFhirString) {6} then
    ComposeString(xml, 'ageString', TFhirString(elem.age));
  if (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'deceasedBoolean', TFhirBoolean(elem.deceased))
  else if (elem.deceased is TFhirQuantity) {6} then
    ComposeAge(xml, 'deceasedAge', TFhirQuantity(elem.deceased))
  else if (elem.deceased is TFhirRange) {6} then
    ComposeRange(xml, 'deceasedRange', TFhirRange(elem.deceased))
  else if (elem.deceased is TFhirDate) {6} then
    ComposeDate(xml, 'deceasedDate', TFhirDate(elem.deceased))
  else if (elem.deceased is TFhirString) {6} then
    ComposeString(xml, 'deceasedString', TFhirString(elem.deceased));
  ComposeString(xml, 'note', elem.noteElement);{x.2}
  for i := 0 to elem.conditionList.Count - 1 do
    ComposeFamilyMemberHistoryCondition(xml, 'condition', elem.conditionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseFamilyMemberHistory(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFamilyMemberHistory(jsn)); {2}
end;

function TFHIRJsonParser.ParseFamilyMemberHistory(jsn : TJsonObject) : TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCodeableConcept(jsn.vObj['relationship']);{q}
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGender);
    if jsn.has('bornPeriod') {a4} then
      result.born := ParsePeriod(jsn.vObj['bornPeriod']);
    if jsn.has('bornDate') or jsn.has('_bornDate') then
      result.born := parseDate(jsn['bornDate'], jsn.vObj['_bornDate']);
    if jsn.has('bornString') or jsn.has('_bornString') then
      result.born := parseString(jsn['bornString'], jsn.vObj['_bornString']);
    if jsn.has('ageAge') {a4} then
      result.age := ParseAge(jsn.vObj['ageAge']);
    if jsn.has('ageRange') {a4} then
      result.age := ParseRange(jsn.vObj['ageRange']);
    if jsn.has('ageString') or jsn.has('_ageString') then
      result.age := parseString(jsn['ageString'], jsn.vObj['_ageString']);
    if jsn.has('deceasedBoolean') or jsn.has('_deceasedBoolean') then
      result.deceased := parseBoolean(jsn['deceasedBoolean'], jsn.vObj['_deceasedBoolean']);
    if jsn.has('deceasedAge') {a4} then
      result.deceased := ParseAge(jsn.vObj['deceasedAge']);
    if jsn.has('deceasedRange') {a4} then
      result.deceased := ParseRange(jsn.vObj['deceasedRange']);
    if jsn.has('deceasedDate') or jsn.has('_deceasedDate') then
      result.deceased := parseDate(jsn['deceasedDate'], jsn.vObj['_deceasedDate']);
    if jsn.has('deceasedString') or jsn.has('_deceasedString') then
      result.deceased := parseString(jsn['deceasedString'], jsn.vObj['_deceasedString']);
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    if jsn.has('condition') then
      iterateArray(jsn.vArr['condition'], result.conditionList, parseFamilyMemberHistoryCondition);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeFamilyMemberHistory(json : TJSONWriter; name : string; elem : TFhirFamilyMemberHistory; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeCodeableConcept(json, 'relationship', elem.relationship); {a}
  ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender, false);
  ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender, false);
  if (elem.born is TFhirPeriod) then 
    ComposePeriod(json, 'bornPeriod', TFhirPeriod(elem.born)) 
  else if (elem.born is TFhirDate) then 
  begin
    ComposeDateValue(json, 'bornDate', TFhirDate(elem.born), false);
    ComposeDateProps(json, 'bornDate', TFhirDate(elem.born), false);
  end
  else if (elem.born is TFhirString) then 
  begin
    ComposeStringValue(json, 'bornString', TFhirString(elem.born), false);
    ComposeStringProps(json, 'bornString', TFhirString(elem.born), false);
  end;
  if (elem.age is TFhirQuantity) then 
    ComposeAge(json, 'ageAge', TFhirQuantity(elem.age)) 
  else if (elem.age is TFhirRange) then 
    ComposeRange(json, 'ageRange', TFhirRange(elem.age)) 
  else if (elem.age is TFhirString) then 
  begin
    ComposeStringValue(json, 'ageString', TFhirString(elem.age), false);
    ComposeStringProps(json, 'ageString', TFhirString(elem.age), false);
  end;
  if (elem.deceased is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
    ComposeBooleanProps(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
  end
  else if (elem.deceased is TFhirQuantity) then 
    ComposeAge(json, 'deceasedAge', TFhirQuantity(elem.deceased)) 
  else if (elem.deceased is TFhirRange) then 
    ComposeRange(json, 'deceasedRange', TFhirRange(elem.deceased)) 
  else if (elem.deceased is TFhirDate) then 
  begin
    ComposeDateValue(json, 'deceasedDate', TFhirDate(elem.deceased), false);
    ComposeDateProps(json, 'deceasedDate', TFhirDate(elem.deceased), false);
  end
  else if (elem.deceased is TFhirString) then 
  begin
    ComposeStringValue(json, 'deceasedString', TFhirString(elem.deceased), false);
    ComposeStringProps(json, 'deceasedString', TFhirString(elem.deceased), false);
  end;
  ComposeStringValue(json, 'note', elem.noteElement, false);
  ComposeStringProps(json, 'note', elem.noteElement, false);
  if elem.conditionList.Count > 0 then
  begin
    json.valueArray('condition');
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeFamilyMemberHistoryCondition(json, '',elem.conditionList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseFlag(element : IXmlDomElement; path : string) : TFhirFlag;
var
  child : IXMLDOMElement;
begin
  result := TFhirFlag.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirFlagStatus, path+'/status', child){1a}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeFlag(xml : TXmlBuilder; name : string; elem : TFhirFlag);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirFlagStatus);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeReference{Resource}(xml, 'author', elem.author);{x.2}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseFlag(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFlag(jsn)); {2}
end;

function TFHIRJsonParser.ParseFlag(jsn : TJsonObject) : TFhirFlag;
begin
  result := TFhirFlag.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirFlagStatus);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeFlag(json : TJSONWriter; name : string; elem : TFhirFlag; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirFlagStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirFlagStatus, false);
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeReference{Resource}(json, 'author', elem.author); {a}
  ComposeCodeableConcept(json, 'code', elem.code); {a}
end;

function TFHIRXmlParser.ParseGoalOutcome(element : IXmlDomElement; path : string) : TFhirGoalOutcome;
var
  child : IXMLDOMElement;
begin
  result := TFhirGoalOutcome.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'resultCodeableConcept') then
        result.result := ParseCodeableConcept(child, path+'/resultCodeableConcept'){x.3}
      else if (child.baseName = 'resultReference') then
        result.result := ParseReference(child, path+'/resultReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeGoalOutcome(xml : TXmlBuilder; name : string; elem : TFhirGoalOutcome);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (elem.result is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'resultCodeableConcept', TFhirCodeableConcept(elem.result))
  else if (elem.result is TFhirReference) {2} then
    ComposeReference(xml, 'resultReference', TFhirReference(elem.result));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseGoalOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGoalOutcome(jsn)); {2}
end;

function TFHIRJsonParser.ParseGoalOutcome(jsn : TJsonObject) : TFhirGoalOutcome;
begin
  result := TFhirGoalOutcome.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('resultCodeableConcept') {a4} then
      result.result := ParseCodeableConcept(jsn.vObj['resultCodeableConcept']);
    if jsn.has('resultReference') {a3} then
      result.result := ParseReference(jsn.vObj['resultReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeGoalOutcome(json : TJSONWriter; name : string; elem : TFhirGoalOutcome; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.result is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'resultCodeableConcept', TFhirCodeableConcept(elem.result)) 
  else if (elem.result is TFhirReference) then
    ComposeReference(json, 'resultReference', TFhirReference(elem.result));
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseGoal(element : IXmlDomElement; path : string) : TFhirGoal;
var
  child : IXMLDOMElement;
begin
  result := TFhirGoal.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'targetDate') then
        result.targetDateElement := ParseDate(child, path+'/targetDate') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirGoalStatus, path+'/status', child){1a}
      else if (child.baseName = 'statusDate') then
        result.statusDateElement := ParseDate(child, path+'/statusDate') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'priority') then
        result.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if (child.baseName = 'concern') then
        result.concernList.Add(ParseReference{Resource}(child, path+'/concern')){y.2}
      else if (child.baseName = 'notes') then
        result.notesElement := ParseString(child, path+'/notes') {b}
      else if (child.baseName = 'outcome') then
        result.outcomeList.Add(ParseGoalOutcome(child, path+'/outcome')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeGoal(xml : TXmlBuilder; name : string; elem : TFhirGoal);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeDate(xml, 'targetDate', elem.targetDateElement);{x.2}
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirGoalStatus);
  ComposeDate(xml, 'statusDate', elem.statusDateElement);{x.2}
  ComposeReference{Resource}(xml, 'author', elem.author);{x.2}
  ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2}
  for i := 0 to elem.concernList.Count - 1 do
    ComposeReference{Resource}(xml, 'concern', elem.concernList[i]);
  ComposeString(xml, 'notes', elem.notesElement);{x.2}
  for i := 0 to elem.outcomeList.Count - 1 do
    ComposeGoalOutcome(xml, 'outcome', elem.outcomeList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseGoal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGoal(jsn)); {2}
end;

function TFHIRJsonParser.ParseGoal(jsn : TJsonObject) : TFhirGoal;
begin
  result := TFhirGoal.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('targetDate') or jsn.has('_targetDate') then
        result.targetDateElement := ParseDate(jsn['targetDate'], jsn.vObj['_targetDate']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirGoalStatus);
    if jsn.has('statusDate') or jsn.has('_statusDate') then
        result.statusDateElement := ParseDate(jsn['statusDate'], jsn.vObj['_statusDate']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q}
    if jsn.has('concern') then
      iterateArray(jsn.vArr['concern'], result.concernList, parseReference{Resource});
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesElement := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    if jsn.has('outcome') then
      iterateArray(jsn.vArr['outcome'], result.outcomeList, parseGoalOutcome);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeGoal(json : TJSONWriter; name : string; elem : TFhirGoal; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeDateValue(json, 'targetDate', elem.targetDateElement, false);
  ComposeDateProps(json, 'targetDate', elem.targetDateElement, false);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirGoalStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirGoalStatus, false);
  ComposeDateValue(json, 'statusDate', elem.statusDateElement, false);
  ComposeDateProps(json, 'statusDate', elem.statusDateElement, false);
  ComposeReference{Resource}(json, 'author', elem.author); {a}
  ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  if elem.concernList.Count > 0 then
  begin
    json.valueArray('concern');
    for i := 0 to elem.concernList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.concernList[i]); {z - Reference(Condition|Observation|MedicationStatement|NutritionOrder|ProcedureRequest|RiskAssessment)}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'notes', elem.notesElement, false);
  ComposeStringProps(json, 'notes', elem.notesElement, false);
  if elem.outcomeList.Count > 0 then
  begin
    json.valueArray('outcome');
    for i := 0 to elem.outcomeList.Count - 1 do
      ComposeGoalOutcome(json, '',elem.outcomeList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseGroupCharacteristic(element : IXmlDomElement; path : string) : TFhirGroupCharacteristic;
var
  child : IXMLDOMElement;
begin
  result := TFhirGroupCharacteristic.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.baseName = 'valueRange') then
        result.value := ParseRange(child, path+'/valueRange'){x.3}
      else if (child.baseName = 'exclude') then
        result.excludeElement := ParseBoolean(child, path+'/exclude') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeGroupCharacteristic(xml : TXmlBuilder; name : string; elem : TFhirGroupCharacteristic);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value));
  ComposeBoolean(xml, 'exclude', elem.excludeElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseGroupCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGroupCharacteristic(jsn)); {2}
end;

function TFHIRJsonParser.ParseGroupCharacteristic(jsn : TJsonObject) : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('exclude') or jsn.has('_exclude') then
        result.excludeElement := ParseBoolean(jsn['exclude'], jsn.vObj['_exclude']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeGroupCharacteristic(json : TJSONWriter; name : string; elem : TFhirGroupCharacteristic; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) ;
  ComposeBooleanValue(json, 'exclude', elem.excludeElement, false);
  ComposeBooleanProps(json, 'exclude', elem.excludeElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseGroup(element : IXmlDomElement; path : string) : TFhirGroup;
var
  child : IXMLDOMElement;
begin
  result := TFhirGroup.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirGroupType, path+'/type', child){1a}
      else if (child.baseName = 'actual') then
        result.actualElement := ParseBoolean(child, path+'/actual') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'quantity') then
        result.quantityElement := ParseUnsignedInt(child, path+'/quantity') {b}
      else if (child.baseName = 'characteristic') then
        result.characteristicList.Add(ParseGroupCharacteristic(child, path+'/characteristic')){y.2}
      else if (child.baseName = 'member') then
        result.memberList.Add(ParseReference{Resource}(child, path+'/member')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeGroup(xml : TXmlBuilder; name : string; elem : TFhirGroup);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirGroupType);
  ComposeBoolean(xml, 'actual', elem.actualElement);{x.2}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeUnsignedInt(xml, 'quantity', elem.quantityElement);{x.2}
  for i := 0 to elem.characteristicList.Count - 1 do
    ComposeGroupCharacteristic(xml, 'characteristic', elem.characteristicList[i]);
  for i := 0 to elem.memberList.Count - 1 do
    ComposeReference{Resource}(xml, 'member', elem.memberList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGroup(jsn)); {2}
end;

function TFHIRJsonParser.ParseGroup(jsn : TJsonObject) : TFhirGroup;
begin
  result := TFhirGroup.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirGroupType);
    if jsn.has('actual') or jsn.has('_actual') then
        result.actualElement := ParseBoolean(jsn['actual'], jsn.vObj['_actual']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('quantity') or jsn.has('_quantity') then
        result.quantityElement := ParseUnsignedInt(jsn['quantity'], jsn.vObj['_quantity']);{q}
    if jsn.has('characteristic') then
      iterateArray(jsn.vArr['characteristic'], result.characteristicList, parseGroupCharacteristic);
    if jsn.has('member') then
      iterateArray(jsn.vArr['member'], result.memberList, parseReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeGroup(json : TJSONWriter; name : string; elem : TFhirGroup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirGroupType, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirGroupType, false);
  ComposeBooleanValue(json, 'actual', elem.actualElement, false);
  ComposeBooleanProps(json, 'actual', elem.actualElement, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeUnsignedIntValue(json, 'quantity', elem.quantityElement, false);
  ComposeUnsignedIntProps(json, 'quantity', elem.quantityElement, false);
  if elem.characteristicList.Count > 0 then
  begin
    json.valueArray('characteristic');
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeGroupCharacteristic(json, '',elem.characteristicList[i]); {z - }
    json.FinishArray;
  end;
  if elem.memberList.Count > 0 then
  begin
    json.valueArray('member');
    for i := 0 to elem.memberList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.memberList[i]); {z - Reference(Patient|Practitioner|Device|Medication|Substance)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseHealthcareServiceServiceType(element : IXmlDomElement; path : string) : TFhirHealthcareServiceServiceType;
var
  child : IXMLDOMElement;
begin
  result := TFhirHealthcareServiceServiceType.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'specialty') then
        result.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceServiceType(xml : TXmlBuilder; name : string; elem : TFhirHealthcareServiceServiceType);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  for i := 0 to elem.specialtyList.Count - 1 do
    ComposeCodeableConcept(xml, 'specialty', elem.specialtyList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseHealthcareServiceServiceType(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHealthcareServiceServiceType(jsn)); {2}
end;

function TFHIRJsonParser.ParseHealthcareServiceServiceType(jsn : TJsonObject) : TFhirHealthcareServiceServiceType;
begin
  result := TFhirHealthcareServiceServiceType.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('specialty') then
      iterateArray(jsn.vArr['specialty'], result.specialtyList, parseCodeableConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeHealthcareServiceServiceType(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceServiceType; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.specialtyList.Count > 0 then
  begin
    json.valueArray('specialty');
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.specialtyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseHealthcareServiceAvailableTime(element : IXmlDomElement; path : string) : TFhirHealthcareServiceAvailableTime;
var
  child : IXMLDOMElement;
begin
  result := TFhirHealthcareServiceAvailableTime.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'daysOfWeek') then
        result.daysOfWeekElement.Add(ParseEnum(CODES_TFhirDaysOfWeek, path+'/daysOfWeek', child)){y.1}
      else if (child.baseName = 'allDay') then
        result.allDayElement := ParseBoolean(child, path+'/allDay') {b}
      else if (child.baseName = 'availableStartTime') then
        result.availableStartTimeElement := ParseTime(child, path+'/availableStartTime') {b}
      else if (child.baseName = 'availableEndTime') then
        result.availableEndTimeElement := ParseTime(child, path+'/availableEndTime') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceAvailableTime(xml : TXmlBuilder; name : string; elem : TFhirHealthcareServiceAvailableTime);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.daysOfWeekElement.Count - 1 do
    ComposeEnum(xml, 'daysOfWeek', elem.daysOfWeekElement[i], CODES_TFhirDaysOfWeek);
  ComposeBoolean(xml, 'allDay', elem.allDayElement);{x.2}
  ComposeTime(xml, 'availableStartTime', elem.availableStartTimeElement);{x.2}
  ComposeTime(xml, 'availableEndTime', elem.availableEndTimeElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseHealthcareServiceAvailableTime(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHealthcareServiceAvailableTime(jsn)); {2}
end;

function TFHIRJsonParser.ParseHealthcareServiceAvailableTime(jsn : TJsonObject) : TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('daysOfWeek') or jsn.has('_daysOfWeek') then
      iterateEnumArray(jsn.vArr['daysOfWeek'], jsn.vArr['_daysOfWeek'], result.daysOfWeekElement, parseEnum, CODES_TFhirDaysOfWeek);
    if jsn.has('allDay') or jsn.has('_allDay') then
        result.allDayElement := ParseBoolean(jsn['allDay'], jsn.vObj['_allDay']);{q}
    if jsn.has('availableStartTime') or jsn.has('_availableStartTime') then
        result.availableStartTimeElement := ParseTime(jsn['availableStartTime'], jsn.vObj['_availableStartTime']);{q}
    if jsn.has('availableEndTime') or jsn.has('_availableEndTime') then
        result.availableEndTimeElement := ParseTime(jsn['availableEndTime'], jsn.vObj['_availableEndTime']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeHealthcareServiceAvailableTime(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceAvailableTime; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.daysOfWeekElement.Count > 0 then
  begin
    json.valueArray('daysOfWeek');
    ext := false;
    for i := 0 to elem.daysOfWeekElement.Count - 1 do
    begin
      ext := ext or ((elem.daysOfWeekElement[i].id <> '') or (elem.daysOfWeekElement[i].hasExtensionList));
      ComposeEnumValue(json, '', elem.daysOfWeekElement[i], CODES_TFhirDaysOfWeek, true);
    end;
      json.FinishArray;
    if ext then
    begin
      json.valueArray('_daysOfWeek');
      for i := 0 to elem.daysOfWeekElement.Count - 1 do
        ComposeEnumProps(json, '', elem.daysOfWeekElement[i], CODES_TFhirDaysOfWeek, true);
      json.FinishArray;
    end;
    end;
  ComposeBooleanValue(json, 'allDay', elem.allDayElement, false);
  ComposeBooleanProps(json, 'allDay', elem.allDayElement, false);
  ComposeTimeValue(json, 'availableStartTime', elem.availableStartTimeElement, false);
  ComposeTimeProps(json, 'availableStartTime', elem.availableStartTimeElement, false);
  ComposeTimeValue(json, 'availableEndTime', elem.availableEndTimeElement, false);
  ComposeTimeProps(json, 'availableEndTime', elem.availableEndTimeElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseHealthcareServiceNotAvailable(element : IXmlDomElement; path : string) : TFhirHealthcareServiceNotAvailable;
var
  child : IXMLDOMElement;
begin
  result := TFhirHealthcareServiceNotAvailable.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'during') then
        result.during := ParsePeriod(child, path+'/during') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceNotAvailable(xml : TXmlBuilder; name : string; elem : TFhirHealthcareServiceNotAvailable);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposePeriod(xml, 'during', elem.during);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseHealthcareServiceNotAvailable(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHealthcareServiceNotAvailable(jsn)); {2}
end;

function TFHIRJsonParser.ParseHealthcareServiceNotAvailable(jsn : TJsonObject) : TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('during') then
        result.during := ParsePeriod(jsn.vObj['during']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeHealthcareServiceNotAvailable(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceNotAvailable; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposePeriod(json, 'during', elem.during); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseHealthcareService(element : IXmlDomElement; path : string) : TFhirHealthcareService;
var
  child : IXMLDOMElement;
begin
  result := TFhirHealthcareService.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'providedBy') then
        result.providedBy := ParseReference{TFhirOrganization}(child, path+'/providedBy') {b}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'serviceCategory') then
        result.serviceCategory := ParseCodeableConcept(child, path+'/serviceCategory') {b}
      else if (child.baseName = 'serviceType') then
        result.serviceTypeList.Add(ParseHealthcareServiceServiceType(child, path+'/serviceType')){y.2}
      else if (child.baseName = 'serviceName') then
        result.serviceNameElement := ParseString(child, path+'/serviceName') {b}
      else if (child.baseName = 'comment') then
        result.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.baseName = 'extraDetails') then
        result.extraDetailsElement := ParseString(child, path+'/extraDetails') {b}
      else if (child.baseName = 'photo') then
        result.photo := ParseAttachment(child, path+'/photo') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'coverageArea') then
        result.coverageAreaList.Add(ParseReference{TFhirLocation}(child, path+'/coverageArea')){y.2}
      else if (child.baseName = 'serviceProvisionCode') then
        result.serviceProvisionCodeList.Add(ParseCodeableConcept(child, path+'/serviceProvisionCode')){y.2}
      else if (child.baseName = 'eligibility') then
        result.eligibility := ParseCodeableConcept(child, path+'/eligibility') {b}
      else if (child.baseName = 'eligibilityNote') then
        result.eligibilityNoteElement := ParseString(child, path+'/eligibilityNote') {b}
      else if (child.baseName = 'programName') then
        result.programNameList.Add(ParseString(child, path+'/programName')){y.2}
      else if (child.baseName = 'characteristic') then
        result.characteristicList.Add(ParseCodeableConcept(child, path+'/characteristic')){y.2}
      else if (child.baseName = 'referralMethod') then
        result.referralMethodList.Add(ParseCodeableConcept(child, path+'/referralMethod')){y.2}
      else if (child.baseName = 'publicKey') then
        result.publicKeyElement := ParseString(child, path+'/publicKey') {b}
      else if (child.baseName = 'appointmentRequired') then
        result.appointmentRequiredElement := ParseBoolean(child, path+'/appointmentRequired') {b}
      else if (child.baseName = 'availableTime') then
        result.availableTimeList.Add(ParseHealthcareServiceAvailableTime(child, path+'/availableTime')){y.2}
      else if (child.baseName = 'notAvailable') then
        result.notAvailableList.Add(ParseHealthcareServiceNotAvailable(child, path+'/notAvailable')){y.2}
      else if (child.baseName = 'availabilityExceptions') then
        result.availabilityExceptionsElement := ParseString(child, path+'/availabilityExceptions') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeHealthcareService(xml : TXmlBuilder; name : string; elem : TFhirHealthcareService);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirOrganization}(xml, 'providedBy', elem.providedBy);{x.2}
  ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  ComposeCodeableConcept(xml, 'serviceCategory', elem.serviceCategory);{x.2}
  for i := 0 to elem.serviceTypeList.Count - 1 do
    ComposeHealthcareServiceServiceType(xml, 'serviceType', elem.serviceTypeList[i]);
  ComposeString(xml, 'serviceName', elem.serviceNameElement);{x.2}
  ComposeString(xml, 'comment', elem.commentElement);{x.2}
  ComposeString(xml, 'extraDetails', elem.extraDetailsElement);{x.2}
  ComposeAttachment(xml, 'photo', elem.photo);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  for i := 0 to elem.coverageAreaList.Count - 1 do
    ComposeReference{TFhirLocation}(xml, 'coverageArea', elem.coverageAreaList[i]);
  for i := 0 to elem.serviceProvisionCodeList.Count - 1 do
    ComposeCodeableConcept(xml, 'serviceProvisionCode', elem.serviceProvisionCodeList[i]);
  ComposeCodeableConcept(xml, 'eligibility', elem.eligibility);{x.2}
  ComposeString(xml, 'eligibilityNote', elem.eligibilityNoteElement);{x.2}
  for i := 0 to elem.programNameList.Count - 1 do
    ComposeString(xml, 'programName', elem.programNameList[i]);
  for i := 0 to elem.characteristicList.Count - 1 do
    ComposeCodeableConcept(xml, 'characteristic', elem.characteristicList[i]);
  for i := 0 to elem.referralMethodList.Count - 1 do
    ComposeCodeableConcept(xml, 'referralMethod', elem.referralMethodList[i]);
  ComposeString(xml, 'publicKey', elem.publicKeyElement);{x.2}
  ComposeBoolean(xml, 'appointmentRequired', elem.appointmentRequiredElement);{x.2}
  for i := 0 to elem.availableTimeList.Count - 1 do
    ComposeHealthcareServiceAvailableTime(xml, 'availableTime', elem.availableTimeList[i]);
  for i := 0 to elem.notAvailableList.Count - 1 do
    ComposeHealthcareServiceNotAvailable(xml, 'notAvailable', elem.notAvailableList[i]);
  ComposeString(xml, 'availabilityExceptions', elem.availabilityExceptionsElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseHealthcareService(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHealthcareService(jsn)); {2}
end;

function TFHIRJsonParser.ParseHealthcareService(jsn : TJsonObject) : TFhirHealthcareService;
begin
  result := TFhirHealthcareService.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('providedBy') then
        result.providedBy := ParseReference{TFhirOrganization}(jsn.vObj['providedBy']);{q}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('serviceCategory') then
        result.serviceCategory := ParseCodeableConcept(jsn.vObj['serviceCategory']);{q}
    if jsn.has('serviceType') then
      iterateArray(jsn.vArr['serviceType'], result.serviceTypeList, parseHealthcareServiceServiceType);
    if jsn.has('serviceName') or jsn.has('_serviceName') then
        result.serviceNameElement := ParseString(jsn['serviceName'], jsn.vObj['_serviceName']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('extraDetails') or jsn.has('_extraDetails') then
        result.extraDetailsElement := ParseString(jsn['extraDetails'], jsn.vObj['_extraDetails']);{q}
    if jsn.has('photo') then
        result.photo := ParseAttachment(jsn.vObj['photo']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('coverageArea') then
      iterateArray(jsn.vArr['coverageArea'], result.coverageAreaList, parseReference{TFhirLocation});
    if jsn.has('serviceProvisionCode') then
      iterateArray(jsn.vArr['serviceProvisionCode'], result.serviceProvisionCodeList, parseCodeableConcept);
    if jsn.has('eligibility') then
        result.eligibility := ParseCodeableConcept(jsn.vObj['eligibility']);{q}
    if jsn.has('eligibilityNote') or jsn.has('_eligibilityNote') then
        result.eligibilityNoteElement := ParseString(jsn['eligibilityNote'], jsn.vObj['_eligibilityNote']);{q}
      if jsn.has('programName') or jsn.has('_programName') then
      iteratePrimitiveArray(jsn.vArr['programName'], jsn.vArr['_programName'], result.programNameList, parseString);
    if jsn.has('characteristic') then
      iterateArray(jsn.vArr['characteristic'], result.characteristicList, parseCodeableConcept);
    if jsn.has('referralMethod') then
      iterateArray(jsn.vArr['referralMethod'], result.referralMethodList, parseCodeableConcept);
    if jsn.has('publicKey') or jsn.has('_publicKey') then
        result.publicKeyElement := ParseString(jsn['publicKey'], jsn.vObj['_publicKey']);{q}
    if jsn.has('appointmentRequired') or jsn.has('_appointmentRequired') then
        result.appointmentRequiredElement := ParseBoolean(jsn['appointmentRequired'], jsn.vObj['_appointmentRequired']);{q}
    if jsn.has('availableTime') then
      iterateArray(jsn.vArr['availableTime'], result.availableTimeList, parseHealthcareServiceAvailableTime);
    if jsn.has('notAvailable') then
      iterateArray(jsn.vArr['notAvailable'], result.notAvailableList, parseHealthcareServiceNotAvailable);
    if jsn.has('availabilityExceptions') or jsn.has('_availabilityExceptions') then
        result.availabilityExceptionsElement := ParseString(jsn['availabilityExceptions'], jsn.vObj['_availabilityExceptions']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeHealthcareService(json : TJSONWriter; name : string; elem : TFhirHealthcareService; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirOrganization}(json, 'providedBy', elem.providedBy); {a}
  ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  ComposeCodeableConcept(json, 'serviceCategory', elem.serviceCategory); {a}
  if elem.serviceTypeList.Count > 0 then
  begin
    json.valueArray('serviceType');
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeHealthcareServiceServiceType(json, '',elem.serviceTypeList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'serviceName', elem.serviceNameElement, false);
  ComposeStringProps(json, 'serviceName', elem.serviceNameElement, false);
  ComposeStringValue(json, 'comment', elem.commentElement, false);
  ComposeStringProps(json, 'comment', elem.commentElement, false);
  ComposeStringValue(json, 'extraDetails', elem.extraDetailsElement, false);
  ComposeStringProps(json, 'extraDetails', elem.extraDetailsElement, false);
  ComposeAttachment(json, 'photo', elem.photo); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if elem.coverageAreaList.Count > 0 then
  begin
    json.valueArray('coverageArea');
    for i := 0 to elem.coverageAreaList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '',elem.coverageAreaList[i]); {z - Reference(Location)}
    json.FinishArray;
  end;
  if elem.serviceProvisionCodeList.Count > 0 then
  begin
    json.valueArray('serviceProvisionCode');
    for i := 0 to elem.serviceProvisionCodeList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.serviceProvisionCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'eligibility', elem.eligibility); {a}
  ComposeStringValue(json, 'eligibilityNote', elem.eligibilityNoteElement, false);
  ComposeStringProps(json, 'eligibilityNote', elem.eligibilityNoteElement, false);
  if elem.programNameList.Count > 0 then
  begin
    json.valueArray('programName');
    ext := false;
    for i := 0 to elem.programNameList.Count - 1 do
    begin
      ext := ext or ((elem.programNameList[i].id <> '') or (elem.programNameList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.programNameList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_programName');
      for i := 0 to elem.programNameList.Count - 1 do
        ComposeStringProps(json, '',elem.programNameList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.characteristicList.Count > 0 then
  begin
    json.valueArray('characteristic');
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.characteristicList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.referralMethodList.Count > 0 then
  begin
    json.valueArray('referralMethod');
    for i := 0 to elem.referralMethodList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.referralMethodList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'publicKey', elem.publicKeyElement, false);
  ComposeStringProps(json, 'publicKey', elem.publicKeyElement, false);
  ComposeBooleanValue(json, 'appointmentRequired', elem.appointmentRequiredElement, false);
  ComposeBooleanProps(json, 'appointmentRequired', elem.appointmentRequiredElement, false);
  if elem.availableTimeList.Count > 0 then
  begin
    json.valueArray('availableTime');
    for i := 0 to elem.availableTimeList.Count - 1 do
      ComposeHealthcareServiceAvailableTime(json, '',elem.availableTimeList[i]); {z - }
    json.FinishArray;
  end;
  if elem.notAvailableList.Count > 0 then
  begin
    json.valueArray('notAvailable');
    for i := 0 to elem.notAvailableList.Count - 1 do
      ComposeHealthcareServiceNotAvailable(json, '',elem.notAvailableList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'availabilityExceptions', elem.availabilityExceptionsElement, false);
  ComposeStringProps(json, 'availabilityExceptions', elem.availabilityExceptionsElement, false);
end;

function TFHIRXmlParser.ParseImagingObjectSelectionStudy(element : IXmlDomElement; path : string) : TFhirImagingObjectSelectionStudy;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingObjectSelectionStudy.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'uid') then
        result.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'series') then
        result.seriesList.Add(ParseImagingObjectSelectionStudySeries(child, path+'/series')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelectionStudy(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudy);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeOid(xml, 'uid', elem.uidElement);{x.2}
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  for i := 0 to elem.seriesList.Count - 1 do
    ComposeImagingObjectSelectionStudySeries(xml, 'series', elem.seriesList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingObjectSelectionStudy(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingObjectSelectionStudy(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingObjectSelectionStudy(jsn : TJsonObject) : TFhirImagingObjectSelectionStudy;
begin
  result := TFhirImagingObjectSelectionStudy.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('series') then
      iterateArray(jsn.vArr['series'], result.seriesList, parseImagingObjectSelectionStudySeries);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingObjectSelectionStudy(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudy; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeOidValue(json, 'uid', elem.uidElement, false);
  ComposeOidProps(json, 'uid', elem.uidElement, false);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if elem.seriesList.Count > 0 then
  begin
    json.valueArray('series');
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingObjectSelectionStudySeries(json, '',elem.seriesList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseImagingObjectSelectionStudySeries(element : IXmlDomElement; path : string) : TFhirImagingObjectSelectionStudySeries;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingObjectSelectionStudySeries.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'uid') then
        result.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'instance') then
        result.instanceList.Add(ParseImagingObjectSelectionStudySeriesInstance(child, path+'/instance')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelectionStudySeries(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudySeries);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeOid(xml, 'uid', elem.uidElement);{x.2}
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  for i := 0 to elem.instanceList.Count - 1 do
    ComposeImagingObjectSelectionStudySeriesInstance(xml, 'instance', elem.instanceList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingObjectSelectionStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingObjectSelectionStudySeries(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingObjectSelectionStudySeries(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeries;
begin
  result := TFhirImagingObjectSelectionStudySeries.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('instance') then
      iterateArray(jsn.vArr['instance'], result.instanceList, parseImagingObjectSelectionStudySeriesInstance);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingObjectSelectionStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeries; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeOidValue(json, 'uid', elem.uidElement, false);
  ComposeOidProps(json, 'uid', elem.uidElement, false);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if elem.instanceList.Count > 0 then
  begin
    json.valueArray('instance');
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingObjectSelectionStudySeriesInstance(json, '',elem.instanceList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseImagingObjectSelectionStudySeriesInstance(element : IXmlDomElement; path : string) : TFhirImagingObjectSelectionStudySeriesInstance;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sopClass') then
        result.sopClassElement := ParseOid(child, path+'/sopClass') {b}
      else if (child.baseName = 'uid') then
        result.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'frames') then
        result.framesList.Add(ParseImagingObjectSelectionStudySeriesInstanceFrames(child, path+'/frames')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelectionStudySeriesInstance(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeOid(xml, 'sopClass', elem.sopClassElement);{x.2}
  ComposeOid(xml, 'uid', elem.uidElement);{x.2}
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  for i := 0 to elem.framesList.Count - 1 do
    ComposeImagingObjectSelectionStudySeriesInstanceFrames(xml, 'frames', elem.framesList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingObjectSelectionStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingObjectSelectionStudySeriesInstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingObjectSelectionStudySeriesInstance(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeriesInstance;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstance.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sopClass') or jsn.has('_sopClass') then
        result.sopClassElement := ParseOid(jsn['sopClass'], jsn.vObj['_sopClass']);{q}
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('frames') then
      iterateArray(jsn.vArr['frames'], result.framesList, parseImagingObjectSelectionStudySeriesInstanceFrames);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingObjectSelectionStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeOidValue(json, 'sopClass', elem.sopClassElement, false);
  ComposeOidProps(json, 'sopClass', elem.sopClassElement, false);
  ComposeOidValue(json, 'uid', elem.uidElement, false);
  ComposeOidProps(json, 'uid', elem.uidElement, false);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if elem.framesList.Count > 0 then
  begin
    json.valueArray('frames');
    for i := 0 to elem.framesList.Count - 1 do
      ComposeImagingObjectSelectionStudySeriesInstanceFrames(json, '',elem.framesList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseImagingObjectSelectionStudySeriesInstanceFrames(element : IXmlDomElement; path : string) : TFhirImagingObjectSelectionStudySeriesInstanceFrames;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceFrames.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'frameNumbers') then
        result.frameNumbersList.Add(ParseUnsignedInt(child, path+'/frameNumbers')){y.2}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelectionStudySeriesInstanceFrames(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.frameNumbersList.Count - 1 do
    ComposeUnsignedInt(xml, 'frameNumbers', elem.frameNumbersList[i]);
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingObjectSelectionStudySeriesInstanceFrames(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingObjectSelectionStudySeriesInstanceFrames(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingObjectSelectionStudySeriesInstanceFrames(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeriesInstanceFrames;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceFrames.create;
  try
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('frameNumbers') or jsn.has('_frameNumbers') then
      iteratePrimitiveArray(jsn.vArr['frameNumbers'], jsn.vArr['_frameNumbers'], result.frameNumbersList, parseUnsignedInt);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingObjectSelectionStudySeriesInstanceFrames(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.frameNumbersList.Count > 0 then
  begin
    json.valueArray('frameNumbers');
    ext := false;
    for i := 0 to elem.frameNumbersList.Count - 1 do
    begin
      ext := ext or ((elem.frameNumbersList[i].id <> '') or (elem.frameNumbersList[i].hasExtensionList));
      ComposeUnsignedIntValue(json, '',elem.frameNumbersList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_frameNumbers');
      for i := 0 to elem.frameNumbersList.Count - 1 do
        ComposeUnsignedIntProps(json, '',elem.frameNumbersList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseImagingObjectSelection(element : IXmlDomElement; path : string) : TFhirImagingObjectSelection;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingObjectSelection.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'uid') then
        result.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'title') then
        result.title := ParseCodeableConcept(child, path+'/title') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'authoringTime') then
        result.authoringTimeElement := ParseDateTime(child, path+'/authoringTime') {b}
      else if (child.baseName = 'study') then
        result.studyList.Add(ParseImagingObjectSelectionStudy(child, path+'/study')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelection(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelection);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeOid(xml, 'uid', elem.uidElement);{x.2}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeCodeableConcept(xml, 'title', elem.title);{x.2}
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeReference{Resource}(xml, 'author', elem.author);{x.2}
  ComposeDateTime(xml, 'authoringTime', elem.authoringTimeElement);{x.2}
  for i := 0 to elem.studyList.Count - 1 do
    ComposeImagingObjectSelectionStudy(xml, 'study', elem.studyList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingObjectSelection(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingObjectSelection(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingObjectSelection(jsn : TJsonObject) : TFhirImagingObjectSelection;
begin
  result := TFhirImagingObjectSelection.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('title') then
        result.title := ParseCodeableConcept(jsn.vObj['title']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('authoringTime') or jsn.has('_authoringTime') then
        result.authoringTimeElement := ParseDateTime(jsn['authoringTime'], jsn.vObj['_authoringTime']);{q}
    if jsn.has('study') then
      iterateArray(jsn.vArr['study'], result.studyList, parseImagingObjectSelectionStudy);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingObjectSelection(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelection; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeOidValue(json, 'uid', elem.uidElement, false);
  ComposeOidProps(json, 'uid', elem.uidElement, false);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeCodeableConcept(json, 'title', elem.title); {a}
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeReference{Resource}(json, 'author', elem.author); {a}
  ComposeDateTimeValue(json, 'authoringTime', elem.authoringTimeElement, false);
  ComposeDateTimeProps(json, 'authoringTime', elem.authoringTimeElement, false);
  if elem.studyList.Count > 0 then
  begin
    json.valueArray('study');
    for i := 0 to elem.studyList.Count - 1 do
      ComposeImagingObjectSelectionStudy(json, '',elem.studyList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseImagingStudySeries(element : IXmlDomElement; path : string) : TFhirImagingStudySeries;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingStudySeries.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'number') then
        result.numberElement := ParseUnsignedInt(child, path+'/number') {b}
      else if (child.baseName = 'modality') then
        result.modalityElement := ParseEnum(CODES_TFhirModality, path+'/modality', child){1a}
      else if (child.baseName = 'uid') then
        result.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'numberOfInstances') then
        result.numberOfInstancesElement := ParseUnsignedInt(child, path+'/numberOfInstances') {b}
      else if (child.baseName = 'availability') then
        result.availabilityElement := ParseEnum(CODES_TFhirInstanceAvailability, path+'/availability', child){1a}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'bodySite') then
        result.bodySite := ParseCoding(child, path+'/bodySite') {b}
      else if (child.baseName = 'laterality') then
        result.laterality := ParseCoding(child, path+'/laterality') {b}
      else if (child.baseName = 'dateTime') then
        result.dateTimeElement := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.baseName = 'instance') then
        result.instanceList.Add(ParseImagingStudySeriesInstance(child, path+'/instance')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeries(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeries);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUnsignedInt(xml, 'number', elem.numberElement);{x.2}
  ComposeEnum(xml, 'modality', elem.ModalityElement, CODES_TFhirModality);
  ComposeOid(xml, 'uid', elem.uidElement);{x.2}
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeUnsignedInt(xml, 'numberOfInstances', elem.numberOfInstancesElement);{x.2}
  ComposeEnum(xml, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailability);
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  ComposeCoding(xml, 'bodySite', elem.bodySite);{x.2}
  ComposeCoding(xml, 'laterality', elem.laterality);{x.2}
  ComposeDateTime(xml, 'dateTime', elem.dateTimeElement);{x.2}
  for i := 0 to elem.instanceList.Count - 1 do
    ComposeImagingStudySeriesInstance(xml, 'instance', elem.instanceList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudySeries(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingStudySeries(jsn : TJsonObject) : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('number') or jsn.has('_number') then
        result.numberElement := ParseUnsignedInt(jsn['number'], jsn.vObj['_number']);{q}
    if jsn.has('modality') or jsn.has('_modality')  then
      result.modalityElement := parseEnum(jsn['modality'], jsn.vObj['_modality'], CODES_TFhirModality);
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('numberOfInstances') or jsn.has('_numberOfInstances') then
        result.numberOfInstancesElement := ParseUnsignedInt(jsn['numberOfInstances'], jsn.vObj['_numberOfInstances']);{q}
    if jsn.has('availability') or jsn.has('_availability')  then
      result.availabilityElement := parseEnum(jsn['availability'], jsn.vObj['_availability'], CODES_TFhirInstanceAvailability);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('bodySite') then
        result.bodySite := ParseCoding(jsn.vObj['bodySite']);{q}
    if jsn.has('laterality') then
        result.laterality := ParseCoding(jsn.vObj['laterality']);{q}
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeElement := ParseDateTime(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('instance') then
      iterateArray(jsn.vArr['instance'], result.instanceList, parseImagingStudySeriesInstance);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingStudySeries; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUnsignedIntValue(json, 'number', elem.numberElement, false);
  ComposeUnsignedIntProps(json, 'number', elem.numberElement, false);
  ComposeEnumValue(json, 'modality', elem.ModalityElement, CODES_TFhirModality, false);
  ComposeEnumProps(json, 'modality', elem.ModalityElement, CODES_TFhirModality, false);
  ComposeOidValue(json, 'uid', elem.uidElement, false);
  ComposeOidProps(json, 'uid', elem.uidElement, false);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeUnsignedIntValue(json, 'numberOfInstances', elem.numberOfInstancesElement, false);
  ComposeUnsignedIntProps(json, 'numberOfInstances', elem.numberOfInstancesElement, false);
  ComposeEnumValue(json, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailability, false);
  ComposeEnumProps(json, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailability, false);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  ComposeCoding(json, 'bodySite', elem.bodySite); {a}
  ComposeCoding(json, 'laterality', elem.laterality); {a}
  ComposeDateTimeValue(json, 'dateTime', elem.dateTimeElement, false);
  ComposeDateTimeProps(json, 'dateTime', elem.dateTimeElement, false);
  if elem.instanceList.Count > 0 then
  begin
    json.valueArray('instance');
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingStudySeriesInstance(json, '',elem.instanceList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseImagingStudySeriesInstance(element : IXmlDomElement; path : string) : TFhirImagingStudySeriesInstance;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'number') then
        result.numberElement := ParseUnsignedInt(child, path+'/number') {b}
      else if (child.baseName = 'uid') then
        result.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'sopclass') then
        result.sopclassElement := ParseOid(child, path+'/sopclass') {b}
      else if (child.baseName = 'type') then
        result.type_Element := ParseString(child, path+'/type') {b}
      else if (child.baseName = 'title') then
        result.titleElement := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'content') then
        result.contentList.Add(ParseAttachment(child, path+'/content')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeriesInstance(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeriesInstance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUnsignedInt(xml, 'number', elem.numberElement);{x.2}
  ComposeOid(xml, 'uid', elem.uidElement);{x.2}
  ComposeOid(xml, 'sopclass', elem.sopclassElement);{x.2}
  ComposeString(xml, 'type', elem.type_Element);{x.2}
  ComposeString(xml, 'title', elem.titleElement);{x.2}
  for i := 0 to elem.contentList.Count - 1 do
    ComposeAttachment(xml, 'content', elem.contentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudySeriesInstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingStudySeriesInstance(jsn : TJsonObject) : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('number') or jsn.has('_number') then
        result.numberElement := ParseUnsignedInt(jsn['number'], jsn.vObj['_number']);{q}
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('sopclass') or jsn.has('_sopclass') then
        result.sopclassElement := ParseOid(jsn['sopclass'], jsn.vObj['_sopclass']);{q}
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := ParseString(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseAttachment);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingStudySeriesInstance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUnsignedIntValue(json, 'number', elem.numberElement, false);
  ComposeUnsignedIntProps(json, 'number', elem.numberElement, false);
  ComposeOidValue(json, 'uid', elem.uidElement, false);
  ComposeOidProps(json, 'uid', elem.uidElement, false);
  ComposeOidValue(json, 'sopclass', elem.sopclassElement, false);
  ComposeOidProps(json, 'sopclass', elem.sopclassElement, false);
  ComposeStringValue(json, 'type', elem.type_Element, false);
  ComposeStringProps(json, 'type', elem.type_Element, false);
  ComposeStringValue(json, 'title', elem.titleElement, false);
  ComposeStringProps(json, 'title', elem.titleElement, false);
  if elem.contentList.Count > 0 then
  begin
    json.valueArray('content');
    for i := 0 to elem.contentList.Count - 1 do
      ComposeAttachment(json, '',elem.contentList[i]); {z - Attachment}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseImagingStudy(element : IXmlDomElement; path : string) : TFhirImagingStudy;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingStudy.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'started') then
        result.startedElement := ParseDateTime(child, path+'/started') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'uid') then
        result.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'accession') then
        result.accession := ParseIdentifier(child, path+'/accession') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'order') then
        result.orderList.Add(ParseReference{TFhirDiagnosticOrder}(child, path+'/order')){y.2}
      else if (child.baseName = 'modalityList') then
        result.modalityList.Add(ParseEnum(CODES_TFhirImagingModality, path+'/modalityList', child)){y.1}
      else if (child.baseName = 'referrer') then
        result.referrer := ParseReference{TFhirPractitioner}(child, path+'/referrer') {b}
      else if (child.baseName = 'availability') then
        result.availabilityElement := ParseEnum(CODES_TFhirInstanceAvailability, path+'/availability', child){1a}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'numberOfSeries') then
        result.numberOfSeriesElement := ParseUnsignedInt(child, path+'/numberOfSeries') {b}
      else if (child.baseName = 'numberOfInstances') then
        result.numberOfInstancesElement := ParseUnsignedInt(child, path+'/numberOfInstances') {b}
      else if (child.baseName = 'clinicalInformation') then
        result.clinicalInformationElement := ParseString(child, path+'/clinicalInformation') {b}
      else if (child.baseName = 'procedure') then
        result.procedure_List.Add(ParseCoding(child, path+'/procedure')){y.2}
      else if (child.baseName = 'interpreter') then
        result.interpreter := ParseReference{TFhirPractitioner}(child, path+'/interpreter') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'series') then
        result.seriesList.Add(ParseImagingStudySeries(child, path+'/series')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingStudy(xml : TXmlBuilder; name : string; elem : TFhirImagingStudy);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeDateTime(xml, 'started', elem.startedElement);{x.2}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeOid(xml, 'uid', elem.uidElement);{x.2}
  ComposeIdentifier(xml, 'accession', elem.accession);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  for i := 0 to elem.orderList.Count - 1 do
    ComposeReference{TFhirDiagnosticOrder}(xml, 'order', elem.orderList[i]);
  for i := 0 to elem.modalityList.Count - 1 do
    ComposeEnum(xml, 'modalityList', elem.modalityList[i], CODES_TFhirImagingModality);
  ComposeReference{TFhirPractitioner}(xml, 'referrer', elem.referrer);{x.2}
  ComposeEnum(xml, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailability);
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  ComposeUnsignedInt(xml, 'numberOfSeries', elem.numberOfSeriesElement);{x.2}
  ComposeUnsignedInt(xml, 'numberOfInstances', elem.numberOfInstancesElement);{x.2}
  ComposeString(xml, 'clinicalInformation', elem.clinicalInformationElement);{x.2}
  for i := 0 to elem.procedure_List.Count - 1 do
    ComposeCoding(xml, 'procedure', elem.procedure_List[i]);
  ComposeReference{TFhirPractitioner}(xml, 'interpreter', elem.interpreter);{x.2}
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  for i := 0 to elem.seriesList.Count - 1 do
    ComposeImagingStudySeries(xml, 'series', elem.seriesList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingStudy(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudy(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingStudy(jsn : TJsonObject) : TFhirImagingStudy;
begin
  result := TFhirImagingStudy.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('started') or jsn.has('_started') then
        result.startedElement := ParseDateTime(jsn['started'], jsn.vObj['_started']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('accession') then
        result.accession := ParseIdentifier(jsn.vObj['accession']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('order') then
      iterateArray(jsn.vArr['order'], result.orderList, parseReference{TFhirDiagnosticOrder});
    if jsn.has('modalityList') or jsn.has('_modalityList') then
      iterateEnumArray(jsn.vArr['modalityList'], jsn.vArr['_modalityList'], result.modalityList, parseEnum, CODES_TFhirImagingModality);
    if jsn.has('referrer') then
        result.referrer := ParseReference{TFhirPractitioner}(jsn.vObj['referrer']);{q}
    if jsn.has('availability') or jsn.has('_availability')  then
      result.availabilityElement := parseEnum(jsn['availability'], jsn.vObj['_availability'], CODES_TFhirInstanceAvailability);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('numberOfSeries') or jsn.has('_numberOfSeries') then
        result.numberOfSeriesElement := ParseUnsignedInt(jsn['numberOfSeries'], jsn.vObj['_numberOfSeries']);{q}
    if jsn.has('numberOfInstances') or jsn.has('_numberOfInstances') then
        result.numberOfInstancesElement := ParseUnsignedInt(jsn['numberOfInstances'], jsn.vObj['_numberOfInstances']);{q}
    if jsn.has('clinicalInformation') or jsn.has('_clinicalInformation') then
        result.clinicalInformationElement := ParseString(jsn['clinicalInformation'], jsn.vObj['_clinicalInformation']);{q}
    if jsn.has('procedure') then
      iterateArray(jsn.vArr['procedure'], result.procedure_List, parseCoding);
    if jsn.has('interpreter') then
        result.interpreter := ParseReference{TFhirPractitioner}(jsn.vObj['interpreter']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('series') then
      iterateArray(jsn.vArr['series'], result.seriesList, parseImagingStudySeries);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingStudy(json : TJSONWriter; name : string; elem : TFhirImagingStudy; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeDateTimeValue(json, 'started', elem.startedElement, false);
  ComposeDateTimeProps(json, 'started', elem.startedElement, false);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeOidValue(json, 'uid', elem.uidElement, false);
  ComposeOidProps(json, 'uid', elem.uidElement, false);
  ComposeIdentifier(json, 'accession', elem.accession); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
end;
  if elem.orderList.Count > 0 then
begin
    json.valueArray('order');
    for i := 0 to elem.orderList.Count - 1 do
      ComposeReference{TFhirDiagnosticOrder}(json, '',elem.orderList[i]); {z - Reference(DiagnosticOrder)}
    json.FinishArray;
    end;
  if elem.modalityList.Count > 0 then
begin
    json.valueArray('modalityList');
    ext := false;
    for i := 0 to elem.modalityList.Count - 1 do
begin
      ext := ext or ((elem.modalityList[i].id <> '') or (elem.modalityList[i].hasExtensionList));
      ComposeEnumValue(json, '', elem.modalityList[i], CODES_TFhirImagingModality, true);
end;
    json.FinishArray;
    if ext then
begin
      json.valueArray('_modalityList');
      for i := 0 to elem.modalityList.Count - 1 do
        ComposeEnumProps(json, '', elem.modalityList[i], CODES_TFhirImagingModality, true);
      json.FinishArray;
  end;
end;
  ComposeReference{TFhirPractitioner}(json, 'referrer', elem.referrer); {a}
  ComposeEnumValue(json, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailability, false);
  ComposeEnumProps(json, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailability, false);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  ComposeUnsignedIntValue(json, 'numberOfSeries', elem.numberOfSeriesElement, false);
  ComposeUnsignedIntProps(json, 'numberOfSeries', elem.numberOfSeriesElement, false);
  ComposeUnsignedIntValue(json, 'numberOfInstances', elem.numberOfInstancesElement, false);
  ComposeUnsignedIntProps(json, 'numberOfInstances', elem.numberOfInstancesElement, false);
  ComposeStringValue(json, 'clinicalInformation', elem.clinicalInformationElement, false);
  ComposeStringProps(json, 'clinicalInformation', elem.clinicalInformationElement, false);
  if elem.procedure_List.Count > 0 then
begin
    json.valueArray('procedure');
    for i := 0 to elem.procedure_List.Count - 1 do
      ComposeCoding(json, '',elem.procedure_List[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeReference{TFhirPractitioner}(json, 'interpreter', elem.interpreter); {a}
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if elem.seriesList.Count > 0 then
  begin
    json.valueArray('series');
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingStudySeries(json, '',elem.seriesList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseImmunizationExplanation(element : IXmlDomElement; path : string) : TFhirImmunizationExplanation;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationExplanation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'reason') then
        result.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.baseName = 'reasonNotGiven') then
        result.reasonNotGivenList.Add(ParseCodeableConcept(child, path+'/reasonNotGiven')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationExplanation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationExplanation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.reasonList.Count - 1 do
    ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  for i := 0 to elem.reasonNotGivenList.Count - 1 do
    ComposeCodeableConcept(xml, 'reasonNotGiven', elem.reasonNotGivenList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationExplanation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationExplanation(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationExplanation(jsn : TJsonObject) : TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('reasonNotGiven') then
      iterateArray(jsn.vArr['reasonNotGiven'], result.reasonNotGivenList, parseCodeableConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationExplanation(json : TJSONWriter; name : string; elem : TFhirImmunizationExplanation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.reasonList.Count > 0 then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.reasonNotGivenList.Count > 0 then
  begin
    json.valueArray('reasonNotGiven');
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.reasonNotGivenList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseImmunizationReaction(element : IXmlDomElement; path : string) : TFhirImmunizationReaction;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationReaction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'detail') then
        result.detail := ParseReference{TFhirObservation}(child, path+'/detail') {b}
      else if (child.baseName = 'reported') then
        result.reportedElement := ParseBoolean(child, path+'/reported') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationReaction(xml : TXmlBuilder; name : string; elem : TFhirImmunizationReaction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeReference{TFhirObservation}(xml, 'detail', elem.detail);{x.2}
  ComposeBoolean(xml, 'reported', elem.reportedElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationReaction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationReaction(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationReaction(jsn : TJsonObject) : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('detail') then
        result.detail := ParseReference{TFhirObservation}(jsn.vObj['detail']);{q}
    if jsn.has('reported') or jsn.has('_reported') then
        result.reportedElement := ParseBoolean(jsn['reported'], jsn.vObj['_reported']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationReaction(json : TJSONWriter; name : string; elem : TFhirImmunizationReaction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeReference{TFhirObservation}(json, 'detail', elem.detail); {a}
  ComposeBooleanValue(json, 'reported', elem.reportedElement, false);
  ComposeBooleanProps(json, 'reported', elem.reportedElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseImmunizationVaccinationProtocol(element : IXmlDomElement; path : string) : TFhirImmunizationVaccinationProtocol;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'doseSequence') then
        result.doseSequenceElement := ParsePositiveInt(child, path+'/doseSequence') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'authority') then
        result.authority := ParseReference{TFhirOrganization}(child, path+'/authority') {b}
      else if (child.baseName = 'series') then
        result.seriesElement := ParseString(child, path+'/series') {b}
      else if (child.baseName = 'seriesDoses') then
        result.seriesDosesElement := ParsePositiveInt(child, path+'/seriesDoses') {b}
      else if (child.baseName = 'doseTarget') then
        result.doseTarget := ParseCodeableConcept(child, path+'/doseTarget') {b}
      else if (child.baseName = 'doseStatus') then
        result.doseStatus := ParseCodeableConcept(child, path+'/doseStatus') {b}
      else if (child.baseName = 'doseStatusReason') then
        result.doseStatusReason := ParseCodeableConcept(child, path+'/doseStatusReason') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationVaccinationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationVaccinationProtocol);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'doseSequence', elem.doseSequenceElement);{x.2}
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'authority', elem.authority);{x.2}
  ComposeString(xml, 'series', elem.seriesElement);{x.2}
  ComposePositiveInt(xml, 'seriesDoses', elem.seriesDosesElement);{x.2}
  ComposeCodeableConcept(xml, 'doseTarget', elem.doseTarget);{x.2}
  ComposeCodeableConcept(xml, 'doseStatus', elem.doseStatus);{x.2}
  ComposeCodeableConcept(xml, 'doseStatusReason', elem.doseStatusReason);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationVaccinationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationVaccinationProtocol(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationVaccinationProtocol(jsn : TJsonObject) : TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('doseSequence') or jsn.has('_doseSequence') then
        result.doseSequenceElement := ParsePositiveInt(jsn['doseSequence'], jsn.vObj['_doseSequence']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('authority') then
        result.authority := ParseReference{TFhirOrganization}(jsn.vObj['authority']);{q}
    if jsn.has('series') or jsn.has('_series') then
        result.seriesElement := ParseString(jsn['series'], jsn.vObj['_series']);{q}
    if jsn.has('seriesDoses') or jsn.has('_seriesDoses') then
        result.seriesDosesElement := ParsePositiveInt(jsn['seriesDoses'], jsn.vObj['_seriesDoses']);{q}
    if jsn.has('doseTarget') then
        result.doseTarget := ParseCodeableConcept(jsn.vObj['doseTarget']);{q}
    if jsn.has('doseStatus') then
        result.doseStatus := ParseCodeableConcept(jsn.vObj['doseStatus']);{q}
    if jsn.has('doseStatusReason') then
        result.doseStatusReason := ParseCodeableConcept(jsn.vObj['doseStatusReason']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationVaccinationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationVaccinationProtocol; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'doseSequence', elem.doseSequenceElement, false);
  ComposePositiveIntProps(json, 'doseSequence', elem.doseSequenceElement, false);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeReference{TFhirOrganization}(json, 'authority', elem.authority); {a}
  ComposeStringValue(json, 'series', elem.seriesElement, false);
  ComposeStringProps(json, 'series', elem.seriesElement, false);
  ComposePositiveIntValue(json, 'seriesDoses', elem.seriesDosesElement, false);
  ComposePositiveIntProps(json, 'seriesDoses', elem.seriesDosesElement, false);
  ComposeCodeableConcept(json, 'doseTarget', elem.doseTarget); {a}
  ComposeCodeableConcept(json, 'doseStatus', elem.doseStatus); {a}
  ComposeCodeableConcept(json, 'doseStatusReason', elem.doseStatusReason); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseImmunization(element : IXmlDomElement; path : string) : TFhirImmunization;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunization.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'vaccineType') then
        result.vaccineType := ParseCodeableConcept(child, path+'/vaccineType') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'wasNotGiven') then
        result.wasNotGivenElement := ParseBoolean(child, path+'/wasNotGiven') {b}
      else if (child.baseName = 'reported') then
        result.reportedElement := ParseBoolean(child, path+'/reported') {b}
      else if (child.baseName = 'performer') then
        result.performer := ParseReference{TFhirPractitioner}(child, path+'/performer') {b}
      else if (child.baseName = 'requester') then
        result.requester := ParseReference{TFhirPractitioner}(child, path+'/requester') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'manufacturer') then
        result.manufacturer := ParseReference{TFhirOrganization}(child, path+'/manufacturer') {b}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'lotNumber') then
        result.lotNumberElement := ParseString(child, path+'/lotNumber') {b}
      else if (child.baseName = 'expirationDate') then
        result.expirationDateElement := ParseDate(child, path+'/expirationDate') {b}
      else if (child.baseName = 'site') then
        result.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'doseQuantity') then
        result.doseQuantity := ParseQuantity(child, path+'/doseQuantity') {b}
      else if (child.baseName = 'explanation') then
        result.explanation := ParseImmunizationExplanation(child, path+'/explanation') {b}
      else if (child.baseName = 'reaction') then
        result.reactionList.Add(ParseImmunizationReaction(child, path+'/reaction')){y.2}
      else if (child.baseName = 'vaccinationProtocol') then
        result.vaccinationProtocolList.Add(ParseImmunizationVaccinationProtocol(child, path+'/vaccinationProtocol')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunization(xml : TXmlBuilder; name : string; elem : TFhirImmunization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeCodeableConcept(xml, 'vaccineType', elem.vaccineType);{x.2}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeBoolean(xml, 'wasNotGiven', elem.wasNotGivenElement);{x.2}
  ComposeBoolean(xml, 'reported', elem.reportedElement);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'performer', elem.performer);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'requester', elem.requester);{x.2}
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'manufacturer', elem.manufacturer);{x.2}
  ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  ComposeString(xml, 'lotNumber', elem.lotNumberElement);{x.2}
  ComposeDate(xml, 'expirationDate', elem.expirationDateElement);{x.2}
  ComposeCodeableConcept(xml, 'site', elem.site);{x.2}
  ComposeCodeableConcept(xml, 'route', elem.route);{x.2}
  ComposeQuantity(xml, 'doseQuantity', elem.doseQuantity);{x.2}
  ComposeImmunizationExplanation(xml, 'explanation', elem.explanation);{x.2}
  for i := 0 to elem.reactionList.Count - 1 do
    ComposeImmunizationReaction(xml, 'reaction', elem.reactionList[i]);
  for i := 0 to elem.vaccinationProtocolList.Count - 1 do
    ComposeImmunizationVaccinationProtocol(xml, 'vaccinationProtocol', elem.vaccinationProtocolList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunization(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunization(jsn : TJsonObject) : TFhirImmunization;
begin
  result := TFhirImmunization.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('vaccineType') then
        result.vaccineType := ParseCodeableConcept(jsn.vObj['vaccineType']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('wasNotGiven') or jsn.has('_wasNotGiven') then
        result.wasNotGivenElement := ParseBoolean(jsn['wasNotGiven'], jsn.vObj['_wasNotGiven']);{q}
    if jsn.has('reported') or jsn.has('_reported') then
        result.reportedElement := ParseBoolean(jsn['reported'], jsn.vObj['_reported']);{q}
    if jsn.has('performer') then
        result.performer := ParseReference{TFhirPractitioner}(jsn.vObj['performer']);{q}
    if jsn.has('requester') then
        result.requester := ParseReference{TFhirPractitioner}(jsn.vObj['requester']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('manufacturer') then
        result.manufacturer := ParseReference{TFhirOrganization}(jsn.vObj['manufacturer']);{q}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('lotNumber') or jsn.has('_lotNumber') then
        result.lotNumberElement := ParseString(jsn['lotNumber'], jsn.vObj['_lotNumber']);{q}
    if jsn.has('expirationDate') or jsn.has('_expirationDate') then
        result.expirationDateElement := ParseDate(jsn['expirationDate'], jsn.vObj['_expirationDate']);{q}
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('doseQuantity') then
        result.doseQuantity := ParseQuantity(jsn.vObj['doseQuantity']);{q}
    if jsn.has('explanation') then
        result.explanation := ParseImmunizationExplanation(jsn.vObj['explanation']);{q}
    if jsn.has('reaction') then
      iterateArray(jsn.vArr['reaction'], result.reactionList, parseImmunizationReaction);
    if jsn.has('vaccinationProtocol') then
      iterateArray(jsn.vArr['vaccinationProtocol'], result.vaccinationProtocolList, parseImmunizationVaccinationProtocol);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunization(json : TJSONWriter; name : string; elem : TFhirImmunization; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeCodeableConcept(json, 'vaccineType', elem.vaccineType); {a}
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeBooleanValue(json, 'wasNotGiven', elem.wasNotGivenElement, false);
  ComposeBooleanProps(json, 'wasNotGiven', elem.wasNotGivenElement, false);
  ComposeBooleanValue(json, 'reported', elem.reportedElement, false);
  ComposeBooleanProps(json, 'reported', elem.reportedElement, false);
  ComposeReference{TFhirPractitioner}(json, 'performer', elem.performer); {a}
  ComposeReference{TFhirPractitioner}(json, 'requester', elem.requester); {a}
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeReference{TFhirOrganization}(json, 'manufacturer', elem.manufacturer); {a}
  ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  ComposeStringValue(json, 'lotNumber', elem.lotNumberElement, false);
  ComposeStringProps(json, 'lotNumber', elem.lotNumberElement, false);
  ComposeDateValue(json, 'expirationDate', elem.expirationDateElement, false);
  ComposeDateProps(json, 'expirationDate', elem.expirationDateElement, false);
  ComposeCodeableConcept(json, 'site', elem.site); {a}
  ComposeCodeableConcept(json, 'route', elem.route); {a}
  ComposeQuantity(json, 'doseQuantity', elem.doseQuantity); {a}
  ComposeImmunizationExplanation(json, 'explanation', elem.explanation); {a}
  if elem.reactionList.Count > 0 then
    begin
    json.valueArray('reaction');
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeImmunizationReaction(json, '',elem.reactionList[i]); {z - }
    json.FinishArray;
    end;
  if elem.vaccinationProtocolList.Count > 0 then
    begin
    json.valueArray('vaccinationProtocol');
    for i := 0 to elem.vaccinationProtocolList.Count - 1 do
      ComposeImmunizationVaccinationProtocol(json, '',elem.vaccinationProtocolList[i]); {z - }
      json.FinishArray;
    end;
  end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendation(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendation;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'vaccineType') then
        result.vaccineType := ParseCodeableConcept(child, path+'/vaccineType') {b}
      else if (child.baseName = 'doseNumber') then
        result.doseNumberElement := ParsePositiveInt(child, path+'/doseNumber') {b}
      else if (child.baseName = 'forecastStatus') then
        result.forecastStatus := ParseCodeableConcept(child, path+'/forecastStatus') {b}
      else if (child.baseName = 'dateCriterion') then
        result.dateCriterionList.Add(ParseImmunizationRecommendationRecommendationDateCriterion(child, path+'/dateCriterion')){y.2}
      else if (child.baseName = 'protocol') then
        result.protocol := ParseImmunizationRecommendationRecommendationProtocol(child, path+'/protocol') {b}
      else if (child.baseName = 'supportingImmunization') then
        result.supportingImmunizationList.Add(ParseReference{TFhirImmunization}(child, path+'/supportingImmunization')){y.2}
      else if (child.baseName = 'supportingPatientInformation') then
        result.supportingPatientInformationList.Add(ParseReference{Resource}(child, path+'/supportingPatientInformation')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeCodeableConcept(xml, 'vaccineType', elem.vaccineType);{x.2}
  ComposePositiveInt(xml, 'doseNumber', elem.doseNumberElement);{x.2}
  ComposeCodeableConcept(xml, 'forecastStatus', elem.forecastStatus);{x.2}
  for i := 0 to elem.dateCriterionList.Count - 1 do
    ComposeImmunizationRecommendationRecommendationDateCriterion(xml, 'dateCriterion', elem.dateCriterionList[i]);
  ComposeImmunizationRecommendationRecommendationProtocol(xml, 'protocol', elem.protocol);{x.2}
  for i := 0 to elem.supportingImmunizationList.Count - 1 do
    ComposeReference{TFhirImmunization}(xml, 'supportingImmunization', elem.supportingImmunizationList[i]);
  for i := 0 to elem.supportingPatientInformationList.Count - 1 do
    ComposeReference{Resource}(xml, 'supportingPatientInformation', elem.supportingPatientInformationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendationRecommendation(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationRecommendationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('vaccineType') then
        result.vaccineType := ParseCodeableConcept(jsn.vObj['vaccineType']);{q}
    if jsn.has('doseNumber') or jsn.has('_doseNumber') then
        result.doseNumberElement := ParsePositiveInt(jsn['doseNumber'], jsn.vObj['_doseNumber']);{q}
    if jsn.has('forecastStatus') then
        result.forecastStatus := ParseCodeableConcept(jsn.vObj['forecastStatus']);{q}
    if jsn.has('dateCriterion') then
      iterateArray(jsn.vArr['dateCriterion'], result.dateCriterionList, parseImmunizationRecommendationRecommendationDateCriterion);
    if jsn.has('protocol') then
        result.protocol := ParseImmunizationRecommendationRecommendationProtocol(jsn.vObj['protocol']);{q}
    if jsn.has('supportingImmunization') then
      iterateArray(jsn.vArr['supportingImmunization'], result.supportingImmunizationList, parseReference{TFhirImmunization});
    if jsn.has('supportingPatientInformation') then
      iterateArray(jsn.vArr['supportingPatientInformation'], result.supportingPatientInformationList, parseReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeCodeableConcept(json, 'vaccineType', elem.vaccineType); {a}
  ComposePositiveIntValue(json, 'doseNumber', elem.doseNumberElement, false);
  ComposePositiveIntProps(json, 'doseNumber', elem.doseNumberElement, false);
  ComposeCodeableConcept(json, 'forecastStatus', elem.forecastStatus); {a}
  if elem.dateCriterionList.Count > 0 then
  begin
    json.valueArray('dateCriterion');
    for i := 0 to elem.dateCriterionList.Count - 1 do
      ComposeImmunizationRecommendationRecommendationDateCriterion(json, '',elem.dateCriterionList[i]); {z - }
      json.FinishArray;
    end;
  ComposeImmunizationRecommendationRecommendationProtocol(json, 'protocol', elem.protocol); {a}
  if elem.supportingImmunizationList.Count > 0 then
  begin
    json.valueArray('supportingImmunization');
    for i := 0 to elem.supportingImmunizationList.Count - 1 do
      ComposeReference{TFhirImmunization}(json, '',elem.supportingImmunizationList[i]); {z - Reference(Immunization)}
    json.FinishArray;
  end;
  if elem.supportingPatientInformationList.Count > 0 then
  begin
    json.valueArray('supportingPatientInformation');
    for i := 0 to elem.supportingPatientInformationList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.supportingPatientInformationList[i]); {z - Reference(Observation|AllergyIntolerance)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationDateCriterion(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendationDateCriterion;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseDateTime(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeDateTime(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendationRecommendationDateCriterion(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDateTime(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeDateTimeValue(json, 'value', elem.valueElement, false);
  ComposeDateTimeProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationProtocol(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendationProtocol;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'doseSequence') then
        result.doseSequenceElement := ParseInteger(child, path+'/doseSequence') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'authority') then
        result.authority := ParseReference{TFhirOrganization}(child, path+'/authority') {b}
      else if (child.baseName = 'series') then
        result.seriesElement := ParseString(child, path+'/series') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeInteger(xml, 'doseSequence', elem.doseSequenceElement);{x.2}
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'authority', elem.authority);{x.2}
  ComposeString(xml, 'series', elem.seriesElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendationRecommendationProtocol(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('doseSequence') or jsn.has('_doseSequence') then
        result.doseSequenceElement := ParseInteger(jsn['doseSequence'], jsn.vObj['_doseSequence']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('authority') then
        result.authority := ParseReference{TFhirOrganization}(jsn.vObj['authority']);{q}
    if jsn.has('series') or jsn.has('_series') then
        result.seriesElement := ParseString(jsn['series'], jsn.vObj['_series']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendationRecommendationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIntegerValue(json, 'doseSequence', elem.doseSequenceElement, false);
  ComposeIntegerProps(json, 'doseSequence', elem.doseSequenceElement, false);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeReference{TFhirOrganization}(json, 'authority', elem.authority); {a}
  ComposeStringValue(json, 'series', elem.seriesElement, false);
  ComposeStringProps(json, 'series', elem.seriesElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseImmunizationRecommendation(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendation;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'recommendation') then
        result.recommendationList.Add(ParseImmunizationRecommendationRecommendation(child, path+'/recommendation')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  for i := 0 to elem.recommendationList.Count - 1 do
    ComposeImmunizationRecommendationRecommendation(xml, 'recommendation', elem.recommendationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendation(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('recommendation') then
      iterateArray(jsn.vArr['recommendation'], result.recommendationList, parseImmunizationRecommendationRecommendation);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if elem.recommendationList.Count > 0 then
  begin
    json.valueArray('recommendation');
    for i := 0 to elem.recommendationList.Count - 1 do
      ComposeImmunizationRecommendationRecommendation(json, '',elem.recommendationList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseListEntry(element : IXmlDomElement; path : string) : TFhirListEntry;
var
  child : IXMLDOMElement;
begin
  result := TFhirListEntry.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'flag') then
        result.flagList.Add(ParseCodeableConcept(child, path+'/flag')){y.2}
      else if (child.baseName = 'deleted') then
        result.deletedElement := ParseBoolean(child, path+'/deleted') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'item') then
        result.item := ParseReference{TFhirReference}(child, path+'/item') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeListEntry(xml : TXmlBuilder; name : string; elem : TFhirListEntry);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.flagList.Count - 1 do
    ComposeCodeableConcept(xml, 'flag', elem.flagList[i]);
  ComposeBoolean(xml, 'deleted', elem.deletedElement);{x.2}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeReference{TFhirReference}(xml, 'item', elem.item);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseListEntry(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseListEntry(jsn)); {2}
end;

function TFHIRJsonParser.ParseListEntry(jsn : TJsonObject) : TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('flag') then
      iterateArray(jsn.vArr['flag'], result.flagList, parseCodeableConcept);
    if jsn.has('deleted') or jsn.has('_deleted') then
        result.deletedElement := ParseBoolean(jsn['deleted'], jsn.vObj['_deleted']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('item') then
        result.item := ParseReference{TFhirReference}(jsn.vObj['item']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeListEntry(json : TJSONWriter; name : string; elem : TFhirListEntry; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.flagList.Count > 0 then
  begin
    json.valueArray('flag');
    for i := 0 to elem.flagList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.flagList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeBooleanValue(json, 'deleted', elem.deletedElement, false);
  ComposeBooleanProps(json, 'deleted', elem.deletedElement, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeReference{TFhirReference}(json, 'item', elem.item); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseList(element : IXmlDomElement; path : string) : TFhirList;
var
  child : IXMLDOMElement;
begin
  result := TFhirList.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'title') then
        result.titleElement := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'source') then
        result.source := ParseReference{Resource}(child, path+'/source') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirListStatus, path+'/status', child){1a}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'orderedBy') then
        result.orderedBy := ParseCodeableConcept(child, path+'/orderedBy') {b}
      else if (child.baseName = 'mode') then
        result.modeElement := ParseEnum(CODES_TFhirListMode, path+'/mode', child){1a}
      else if (child.baseName = 'note') then
        result.noteElement := ParseString(child, path+'/note') {b}
      else if (child.baseName = 'entry') then
        result.entryList.Add(ParseListEntry(child, path+'/entry')){y.2}
      else if (child.baseName = 'emptyReason') then
        result.emptyReason := ParseCodeableConcept(child, path+'/emptyReason') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeList(xml : TXmlBuilder; name : string; elem : TFhirList);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeString(xml, 'title', elem.titleElement);{x.2}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{Resource}(xml, 'source', elem.source);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirListStatus);
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeCodeableConcept(xml, 'orderedBy', elem.orderedBy);{x.2}
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirListMode);
  ComposeString(xml, 'note', elem.noteElement);{x.2}
  for i := 0 to elem.entryList.Count - 1 do
    ComposeListEntry(xml, 'entry', elem.entryList[i]);
  ComposeCodeableConcept(xml, 'emptyReason', elem.emptyReason);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseList(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseList(jsn)); {2}
end;

function TFHIRJsonParser.ParseList(jsn : TJsonObject) : TFhirList;
begin
  result := TFhirList.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('source') then
        result.source := ParseReference{Resource}(jsn.vObj['source']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirListStatus);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('orderedBy') then
        result.orderedBy := ParseCodeableConcept(jsn.vObj['orderedBy']);{q}
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn['mode'], jsn.vObj['_mode'], CODES_TFhirListMode);
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    if jsn.has('entry') then
      iterateArray(jsn.vArr['entry'], result.entryList, parseListEntry);
    if jsn.has('emptyReason') then
        result.emptyReason := ParseCodeableConcept(jsn.vObj['emptyReason']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeList(json : TJSONWriter; name : string; elem : TFhirList; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'title', elem.titleElement, false);
  ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeReference{Resource}(json, 'source', elem.source); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirListStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirListStatus, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeCodeableConcept(json, 'orderedBy', elem.orderedBy); {a}
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirListMode, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirListMode, false);
  ComposeStringValue(json, 'note', elem.noteElement, false);
  ComposeStringProps(json, 'note', elem.noteElement, false);
  if elem.entryList.Count > 0 then
  begin
    json.valueArray('entry');
    for i := 0 to elem.entryList.Count - 1 do
      ComposeListEntry(json, '',elem.entryList[i]); {z - }
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'emptyReason', elem.emptyReason); {a}
end;

function TFHIRXmlParser.ParseLocationPosition(element : IXmlDomElement; path : string) : TFhirLocationPosition;
var
  child : IXMLDOMElement;
begin
  result := TFhirLocationPosition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'longitude') then
        result.longitudeElement := ParseDecimal(child, path+'/longitude') {b}
      else if (child.baseName = 'latitude') then
        result.latitudeElement := ParseDecimal(child, path+'/latitude') {b}
      else if (child.baseName = 'altitude') then
        result.altitudeElement := ParseDecimal(child, path+'/altitude') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeLocationPosition(xml : TXmlBuilder; name : string; elem : TFhirLocationPosition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeDecimal(xml, 'longitude', elem.longitudeElement);{x.2}
  ComposeDecimal(xml, 'latitude', elem.latitudeElement);{x.2}
  ComposeDecimal(xml, 'altitude', elem.altitudeElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseLocationPosition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseLocationPosition(jsn)); {2}
end;

function TFHIRJsonParser.ParseLocationPosition(jsn : TJsonObject) : TFhirLocationPosition;
begin
  result := TFhirLocationPosition.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('longitude') or jsn.has('_longitude') then
        result.longitudeElement := ParseDecimal(jsn['longitude'], jsn.vObj['_longitude']);{q}
    if jsn.has('latitude') or jsn.has('_latitude') then
        result.latitudeElement := ParseDecimal(jsn['latitude'], jsn.vObj['_latitude']);{q}
    if jsn.has('altitude') or jsn.has('_altitude') then
        result.altitudeElement := ParseDecimal(jsn['altitude'], jsn.vObj['_altitude']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeLocationPosition(json : TJSONWriter; name : string; elem : TFhirLocationPosition; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeDecimalValue(json, 'longitude', elem.longitudeElement, false);
  ComposeDecimalProps(json, 'longitude', elem.longitudeElement, false);
  ComposeDecimalValue(json, 'latitude', elem.latitudeElement, false);
  ComposeDecimalProps(json, 'latitude', elem.latitudeElement, false);
  ComposeDecimalValue(json, 'altitude', elem.altitudeElement, false);
  ComposeDecimalProps(json, 'altitude', elem.altitudeElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseLocation(element : IXmlDomElement; path : string) : TFhirLocation;
var
  child : IXMLDOMElement;
begin
  result := TFhirLocation.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'mode') then
        result.modeElement := ParseEnum(CODES_TFhirLocationMode, path+'/mode', child){1a}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'address') then
        result.address := ParseAddress(child, path+'/address') {b}
      else if (child.baseName = 'physicalType') then
        result.physicalType := ParseCodeableConcept(child, path+'/physicalType') {b}
      else if (child.baseName = 'position') then
        result.position := ParseLocationPosition(child, path+'/position') {b}
      else if (child.baseName = 'managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.baseName = 'partOf') then
        result.partOf := ParseReference{TFhirLocation}(child, path+'/partOf') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirLocationStatus, path+'/status', child){1a}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeLocation(xml : TXmlBuilder; name : string; elem : TFhirLocation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirLocationMode);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeAddress(xml, 'address', elem.address);{x.2}
  ComposeCodeableConcept(xml, 'physicalType', elem.physicalType);{x.2}
  ComposeLocationPosition(xml, 'position', elem.position);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2}
  ComposeReference{TFhirLocation}(xml, 'partOf', elem.partOf);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirLocationStatus);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseLocation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseLocation(jsn)); {2}
end;

function TFHIRJsonParser.ParseLocation(jsn : TJsonObject) : TFhirLocation;
begin
  result := TFhirLocation.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn['mode'], jsn.vObj['_mode'], CODES_TFhirLocationMode);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q}
    if jsn.has('physicalType') then
        result.physicalType := ParseCodeableConcept(jsn.vObj['physicalType']);{q}
    if jsn.has('position') then
        result.position := ParseLocationPosition(jsn.vObj['position']);{q}
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q}
    if jsn.has('partOf') then
        result.partOf := ParseReference{TFhirLocation}(jsn.vObj['partOf']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirLocationStatus);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeLocation(json : TJSONWriter; name : string; elem : TFhirLocation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirLocationMode, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirLocationMode, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeAddress(json, 'address', elem.address); {a}
  ComposeCodeableConcept(json, 'physicalType', elem.physicalType); {a}
  ComposeLocationPosition(json, 'position', elem.position); {a}
  ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  ComposeReference{TFhirLocation}(json, 'partOf', elem.partOf); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirLocationStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirLocationStatus, false);
end;

function TFHIRXmlParser.ParseMedia(element : IXmlDomElement; path : string) : TFhirMedia;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedia.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirDigitalMediaType, path+'/type', child){1a}
      else if (child.baseName = 'subtype') then
        result.subtype := ParseCodeableConcept(child, path+'/subtype') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'operator') then
        result.operator := ParseReference{TFhirPractitioner}(child, path+'/operator') {b}
      else if (child.baseName = 'view') then
        result.view := ParseCodeableConcept(child, path+'/view') {b}
      else if (child.baseName = 'deviceName') then
        result.deviceNameElement := ParseString(child, path+'/deviceName') {b}
      else if (child.baseName = 'height') then
        result.heightElement := ParsePositiveInt(child, path+'/height') {b}
      else if (child.baseName = 'width') then
        result.widthElement := ParsePositiveInt(child, path+'/width') {b}
      else if (child.baseName = 'frames') then
        result.framesElement := ParsePositiveInt(child, path+'/frames') {b}
      else if (child.baseName = 'duration') then
        result.durationElement := ParseUnsignedInt(child, path+'/duration') {b}
      else if (child.baseName = 'content') then
        result.content := ParseAttachment(child, path+'/content') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedia(xml : TXmlBuilder; name : string; elem : TFhirMedia);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirDigitalMediaType);
  ComposeCodeableConcept(xml, 'subtype', elem.subtype);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'operator', elem.operator);{x.2}
  ComposeCodeableConcept(xml, 'view', elem.view);{x.2}
  ComposeString(xml, 'deviceName', elem.deviceNameElement);{x.2}
  ComposePositiveInt(xml, 'height', elem.heightElement);{x.2}
  ComposePositiveInt(xml, 'width', elem.widthElement);{x.2}
  ComposePositiveInt(xml, 'frames', elem.framesElement);{x.2}
  ComposeUnsignedInt(xml, 'duration', elem.durationElement);{x.2}
  ComposeAttachment(xml, 'content', elem.content);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedia(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedia(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedia(jsn : TJsonObject) : TFhirMedia;
begin
  result := TFhirMedia.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirDigitalMediaType);
    if jsn.has('subtype') then
        result.subtype := ParseCodeableConcept(jsn.vObj['subtype']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('operator') then
        result.operator := ParseReference{TFhirPractitioner}(jsn.vObj['operator']);{q}
    if jsn.has('view') then
        result.view := ParseCodeableConcept(jsn.vObj['view']);{q}
    if jsn.has('deviceName') or jsn.has('_deviceName') then
        result.deviceNameElement := ParseString(jsn['deviceName'], jsn.vObj['_deviceName']);{q}
    if jsn.has('height') or jsn.has('_height') then
        result.heightElement := ParsePositiveInt(jsn['height'], jsn.vObj['_height']);{q}
    if jsn.has('width') or jsn.has('_width') then
        result.widthElement := ParsePositiveInt(jsn['width'], jsn.vObj['_width']);{q}
    if jsn.has('frames') or jsn.has('_frames') then
        result.framesElement := ParsePositiveInt(jsn['frames'], jsn.vObj['_frames']);{q}
    if jsn.has('duration') or jsn.has('_duration') then
        result.durationElement := ParseUnsignedInt(jsn['duration'], jsn.vObj['_duration']);{q}
    if jsn.has('content') then
        result.content := ParseAttachment(jsn.vObj['content']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedia(json : TJSONWriter; name : string; elem : TFhirMedia; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirDigitalMediaType, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirDigitalMediaType, false);
  ComposeCodeableConcept(json, 'subtype', elem.subtype); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeReference{TFhirPractitioner}(json, 'operator', elem.operator); {a}
  ComposeCodeableConcept(json, 'view', elem.view); {a}
  ComposeStringValue(json, 'deviceName', elem.deviceNameElement, false);
  ComposeStringProps(json, 'deviceName', elem.deviceNameElement, false);
  ComposePositiveIntValue(json, 'height', elem.heightElement, false);
  ComposePositiveIntProps(json, 'height', elem.heightElement, false);
  ComposePositiveIntValue(json, 'width', elem.widthElement, false);
  ComposePositiveIntProps(json, 'width', elem.widthElement, false);
  ComposePositiveIntValue(json, 'frames', elem.framesElement, false);
  ComposePositiveIntProps(json, 'frames', elem.framesElement, false);
  ComposeUnsignedIntValue(json, 'duration', elem.durationElement, false);
  ComposeUnsignedIntProps(json, 'duration', elem.durationElement, false);
  ComposeAttachment(json, 'content', elem.content); {a}
end;

function TFHIRXmlParser.ParseMedicationProduct(element : IXmlDomElement; path : string) : TFhirMedicationProduct;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationProduct.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'form') then
        result.form := ParseCodeableConcept(child, path+'/form') {b}
      else if (child.baseName = 'ingredient') then
        result.ingredientList.Add(ParseMedicationProductIngredient(child, path+'/ingredient')){y.2}
      else if (child.baseName = 'batch') then
        result.batchList.Add(ParseMedicationProductBatch(child, path+'/batch')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationProduct(xml : TXmlBuilder; name : string; elem : TFhirMedicationProduct);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'form', elem.form);{x.2}
  for i := 0 to elem.ingredientList.Count - 1 do
    ComposeMedicationProductIngredient(xml, 'ingredient', elem.ingredientList[i]);
  for i := 0 to elem.batchList.Count - 1 do
    ComposeMedicationProductBatch(xml, 'batch', elem.batchList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationProduct(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationProduct(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationProduct(jsn : TJsonObject) : TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('form') then
        result.form := ParseCodeableConcept(jsn.vObj['form']);{q}
    if jsn.has('ingredient') then
      iterateArray(jsn.vArr['ingredient'], result.ingredientList, parseMedicationProductIngredient);
    if jsn.has('batch') then
      iterateArray(jsn.vArr['batch'], result.batchList, parseMedicationProductBatch);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationProduct(json : TJSONWriter; name : string; elem : TFhirMedicationProduct; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'form', elem.form); {a}
  if elem.ingredientList.Count > 0 then
  begin
    json.valueArray('ingredient');
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeMedicationProductIngredient(json, '',elem.ingredientList[i]); {z - }
    json.FinishArray;
  end;
  if elem.batchList.Count > 0 then
  begin
    json.valueArray('batch');
    for i := 0 to elem.batchList.Count - 1 do
      ComposeMedicationProductBatch(json, '',elem.batchList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationProductIngredient(element : IXmlDomElement; path : string) : TFhirMedicationProductIngredient;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'item') then
        result.item := ParseReference{Resource}(child, path+'/item') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseRatio(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationProductIngredient(xml : TXmlBuilder; name : string; elem : TFhirMedicationProductIngredient);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'item', elem.item);{x.2}
  ComposeRatio(xml, 'amount', elem.amount);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationProductIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationProductIngredient(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationProductIngredient(jsn : TJsonObject) : TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('item') then
        result.item := ParseReference{Resource}(jsn.vObj['item']);{q}
    if jsn.has('amount') then
        result.amount := ParseRatio(jsn.vObj['amount']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationProductIngredient(json : TJSONWriter; name : string; elem : TFhirMedicationProductIngredient; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{Resource}(json, 'item', elem.item); {a}
  ComposeRatio(json, 'amount', elem.amount); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationProductBatch(element : IXmlDomElement; path : string) : TFhirMedicationProductBatch;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationProductBatch.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'lotNumber') then
        result.lotNumberElement := ParseString(child, path+'/lotNumber') {b}
      else if (child.baseName = 'expirationDate') then
        result.expirationDateElement := ParseDateTime(child, path+'/expirationDate') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationProductBatch(xml : TXmlBuilder; name : string; elem : TFhirMedicationProductBatch);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'lotNumber', elem.lotNumberElement);{x.2}
  ComposeDateTime(xml, 'expirationDate', elem.expirationDateElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationProductBatch(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationProductBatch(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationProductBatch(jsn : TJsonObject) : TFhirMedicationProductBatch;
begin
  result := TFhirMedicationProductBatch.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('lotNumber') or jsn.has('_lotNumber') then
        result.lotNumberElement := ParseString(jsn['lotNumber'], jsn.vObj['_lotNumber']);{q}
    if jsn.has('expirationDate') or jsn.has('_expirationDate') then
        result.expirationDateElement := ParseDateTime(jsn['expirationDate'], jsn.vObj['_expirationDate']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationProductBatch(json : TJSONWriter; name : string; elem : TFhirMedicationProductBatch; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'lotNumber', elem.lotNumberElement, false);
  ComposeStringProps(json, 'lotNumber', elem.lotNumberElement, false);
  ComposeDateTimeValue(json, 'expirationDate', elem.expirationDateElement, false);
  ComposeDateTimeProps(json, 'expirationDate', elem.expirationDateElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationPackage(element : IXmlDomElement; path : string) : TFhirMedicationPackage;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPackage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'container') then
        result.container := ParseCodeableConcept(child, path+'/container') {b}
      else if (child.baseName = 'content') then
        result.contentList.Add(ParseMedicationPackageContent(child, path+'/content')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackage(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'container', elem.container);{x.2}
  for i := 0 to elem.contentList.Count - 1 do
    ComposeMedicationPackageContent(xml, 'content', elem.contentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPackage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPackage(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationPackage(jsn : TJsonObject) : TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('container') then
        result.container := ParseCodeableConcept(jsn.vObj['container']);{q}
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseMedicationPackageContent);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPackage(json : TJSONWriter; name : string; elem : TFhirMedicationPackage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'container', elem.container); {a}
  if elem.contentList.Count > 0 then
  begin
    json.valueArray('content');
    for i := 0 to elem.contentList.Count - 1 do
      ComposeMedicationPackageContent(json, '',elem.contentList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationPackageContent(element : IXmlDomElement; path : string) : TFhirMedicationPackageContent;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPackageContent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'item') then
        result.item := ParseReference{TFhirMedication}(child, path+'/item') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackageContent(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackageContent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirMedication}(xml, 'item', elem.item);{x.2}
  ComposeQuantity(xml, 'amount', elem.amount);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPackageContent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPackageContent(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationPackageContent(jsn : TJsonObject) : TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('item') then
        result.item := ParseReference{TFhirMedication}(jsn.vObj['item']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPackageContent(json : TJSONWriter; name : string; elem : TFhirMedicationPackageContent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirMedication}(json, 'item', elem.item); {a}
  ComposeQuantity(json, 'amount', elem.amount); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseMedication(element : IXmlDomElement; path : string) : TFhirMedication;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedication.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'isBrand') then
        result.isBrandElement := ParseBoolean(child, path+'/isBrand') {b}
      else if (child.baseName = 'manufacturer') then
        result.manufacturer := ParseReference{TFhirOrganization}(child, path+'/manufacturer') {b}
      else if (child.baseName = 'kind') then
        result.kindElement := ParseEnum(CODES_TFhirMedicationKind, path+'/kind', child){1a}
      else if (child.baseName = 'product') then
        result.product := ParseMedicationProduct(child, path+'/product') {b}
      else if (child.baseName = 'package') then
        result.package := ParseMedicationPackage(child, path+'/package') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedication(xml : TXmlBuilder; name : string; elem : TFhirMedication);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeBoolean(xml, 'isBrand', elem.isBrandElement);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'manufacturer', elem.manufacturer);{x.2}
  ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirMedicationKind);
  ComposeMedicationProduct(xml, 'product', elem.product);{x.2}
  ComposeMedicationPackage(xml, 'package', elem.package);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedication(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedication(jsn : TJsonObject) : TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('isBrand') or jsn.has('_isBrand') then
        result.isBrandElement := ParseBoolean(jsn['isBrand'], jsn.vObj['_isBrand']);{q}
    if jsn.has('manufacturer') then
        result.manufacturer := ParseReference{TFhirOrganization}(jsn.vObj['manufacturer']);{q}
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn['kind'], jsn.vObj['_kind'], CODES_TFhirMedicationKind);
    if jsn.has('product') then
        result.product := ParseMedicationProduct(jsn.vObj['product']);{q}
    if jsn.has('package') then
        result.package := ParseMedicationPackage(jsn.vObj['package']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedication(json : TJSONWriter; name : string; elem : TFhirMedication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeBooleanValue(json, 'isBrand', elem.isBrandElement, false);
  ComposeBooleanProps(json, 'isBrand', elem.isBrandElement, false);
  ComposeReference{TFhirOrganization}(json, 'manufacturer', elem.manufacturer); {a}
  ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirMedicationKind, false);
  ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirMedicationKind, false);
  ComposeMedicationProduct(json, 'product', elem.product); {a}
  ComposeMedicationPackage(json, 'package', elem.package); {a}
end;

function TFHIRXmlParser.ParseMedicationAdministrationDosage(element : IXmlDomElement; path : string) : TFhirMedicationAdministrationDosage;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'site') then
        result.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'rate') then
        result.rate := ParseRatio(child, path+'/rate') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministrationDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministrationDosage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'text', elem.textElement);{x.2}
  ComposeCodeableConcept(xml, 'site', elem.site);{x.2}
  ComposeCodeableConcept(xml, 'route', elem.route);{x.2}
  ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeRatio(xml, 'rate', elem.rate);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationAdministrationDosage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationAdministrationDosage(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationAdministrationDosage(jsn : TJsonObject) : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('rate') then
        result.rate := ParseRatio(jsn.vObj['rate']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationAdministrationDosage(json : TJSONWriter; name : string; elem : TFhirMedicationAdministrationDosage; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'text', elem.textElement, false);
  ComposeStringProps(json, 'text', elem.textElement, false);
  ComposeCodeableConcept(json, 'site', elem.site); {a}
  ComposeCodeableConcept(json, 'route', elem.route); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeRatio(json, 'rate', elem.rate); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationAdministration(element : IXmlDomElement; path : string) : TFhirMedicationAdministration;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationAdministration.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirMedicationAdminStatus, path+'/status', child){1a}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'practitioner') then
        result.practitioner := ParseReference{TFhirPractitioner}(child, path+'/practitioner') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'prescription') then
        result.prescription := ParseReference{TFhirMedicationPrescription}(child, path+'/prescription') {b}
      else if (child.baseName = 'wasNotGiven') then
        result.wasNotGivenElement := ParseBoolean(child, path+'/wasNotGiven') {b}
      else if (child.baseName = 'reasonNotGiven') then
        result.reasonNotGivenList.Add(ParseCodeableConcept(child, path+'/reasonNotGiven')){y.2}
      else if (child.baseName = 'reasonGiven') then
        result.reasonGivenList.Add(ParseCodeableConcept(child, path+'/reasonGiven')){y.2}
      else if (child.baseName = 'effectiveTimeDateTime') then
        result.effectiveTime := ParseDateTime(child, path+'/effectiveTimeDateTime'){x.3}
      else if (child.baseName = 'effectiveTimePeriod') then
        result.effectiveTime := ParsePeriod(child, path+'/effectiveTimePeriod'){x.3}
      else if (child.baseName = 'medication') then
        result.medication := ParseReference{TFhirMedication}(child, path+'/medication') {b}
      else if (child.baseName = 'device') then
        result.deviceList.Add(ParseReference{TFhirDevice}(child, path+'/device')){y.2}
      else if (child.baseName = 'note') then
        result.noteElement := ParseString(child, path+'/note') {b}
      else if (child.baseName = 'dosage') then
        result.dosage := ParseMedicationAdministrationDosage(child, path+'/dosage') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministration(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministration);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatus);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'practitioner', elem.practitioner);{x.2}
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  ComposeReference{TFhirMedicationPrescription}(xml, 'prescription', elem.prescription);{x.2}
  ComposeBoolean(xml, 'wasNotGiven', elem.wasNotGivenElement);{x.2}
  for i := 0 to elem.reasonNotGivenList.Count - 1 do
    ComposeCodeableConcept(xml, 'reasonNotGiven', elem.reasonNotGivenList[i]);
  for i := 0 to elem.reasonGivenList.Count - 1 do
    ComposeCodeableConcept(xml, 'reasonGiven', elem.reasonGivenList[i]);
  if (elem.effectiveTime is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveTimeDateTime', TFhirDateTime(elem.effectiveTime))
  else if (elem.effectiveTime is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectiveTimePeriod', TFhirPeriod(elem.effectiveTime));
  ComposeReference{TFhirMedication}(xml, 'medication', elem.medication);{x.2}
  for i := 0 to elem.deviceList.Count - 1 do
    ComposeReference{TFhirDevice}(xml, 'device', elem.deviceList[i]);
  ComposeString(xml, 'note', elem.noteElement);{x.2}
  ComposeMedicationAdministrationDosage(xml, 'dosage', elem.dosage);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationAdministration(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationAdministration(jsn : TJsonObject) : TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirMedicationAdminStatus);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('practitioner') then
        result.practitioner := ParseReference{TFhirPractitioner}(jsn.vObj['practitioner']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('prescription') then
        result.prescription := ParseReference{TFhirMedicationPrescription}(jsn.vObj['prescription']);{q}
    if jsn.has('wasNotGiven') or jsn.has('_wasNotGiven') then
        result.wasNotGivenElement := ParseBoolean(jsn['wasNotGiven'], jsn.vObj['_wasNotGiven']);{q}
    if jsn.has('reasonNotGiven') then
      iterateArray(jsn.vArr['reasonNotGiven'], result.reasonNotGivenList, parseCodeableConcept);
    if jsn.has('reasonGiven') then
      iterateArray(jsn.vArr['reasonGiven'], result.reasonGivenList, parseCodeableConcept);
    if jsn.has('effectiveTimeDateTime') or jsn.has('_effectiveTimeDateTime') then
      result.effectiveTime := parseDateTime(jsn['effectiveTimeDateTime'], jsn.vObj['_effectiveTimeDateTime']);
    if jsn.has('effectiveTimePeriod') {a4} then
      result.effectiveTime := ParsePeriod(jsn.vObj['effectiveTimePeriod']);
    if jsn.has('medication') then
        result.medication := ParseReference{TFhirMedication}(jsn.vObj['medication']);{q}
    if jsn.has('device') then
      iterateArray(jsn.vArr['device'], result.deviceList, parseReference{TFhirDevice});
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    if jsn.has('dosage') then
        result.dosage := ParseMedicationAdministrationDosage(jsn.vObj['dosage']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationAdministration(json : TJSONWriter; name : string; elem : TFhirMedicationAdministration; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatus, false);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeReference{TFhirPractitioner}(json, 'practitioner', elem.practitioner); {a}
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeReference{TFhirMedicationPrescription}(json, 'prescription', elem.prescription); {a}
  ComposeBooleanValue(json, 'wasNotGiven', elem.wasNotGivenElement, false);
  ComposeBooleanProps(json, 'wasNotGiven', elem.wasNotGivenElement, false);
  if elem.reasonNotGivenList.Count > 0 then
  begin
    json.valueArray('reasonNotGiven');
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.reasonNotGivenList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.reasonGivenList.Count > 0 then
  begin
    json.valueArray('reasonGiven');
    for i := 0 to elem.reasonGivenList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.reasonGivenList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (elem.effectiveTime is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'effectiveTimeDateTime', TFhirDateTime(elem.effectiveTime), false);
    ComposeDateTimeProps(json, 'effectiveTimeDateTime', TFhirDateTime(elem.effectiveTime), false);
  end
  else if (elem.effectiveTime is TFhirPeriod) then 
    ComposePeriod(json, 'effectiveTimePeriod', TFhirPeriod(elem.effectiveTime)) ;
  ComposeReference{TFhirMedication}(json, 'medication', elem.medication); {a}
  if elem.deviceList.Count > 0 then
  begin
    json.valueArray('device');
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeReference{TFhirDevice}(json, '',elem.deviceList[i]); {z - Reference(Device)}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'note', elem.noteElement, false);
  ComposeStringProps(json, 'note', elem.noteElement, false);
  ComposeMedicationAdministrationDosage(json, 'dosage', elem.dosage); {a}
end;

function TFHIRXmlParser.ParseMedicationDispenseDosageInstruction(element : IXmlDomElement; path : string) : TFhirMedicationDispenseDosageInstruction;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationDispenseDosageInstruction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(child, path+'/additionalInstructions') {b}
      else if (child.baseName = 'scheduleDateTime') then
        result.schedule := ParseDateTime(child, path+'/scheduleDateTime'){x.3}
      else if (child.baseName = 'schedulePeriod') then
        result.schedule := ParsePeriod(child, path+'/schedulePeriod'){x.3}
      else if (child.baseName = 'scheduleTiming') then
        result.schedule := ParseTiming(child, path+'/scheduleTiming'){x.3}
      else if (child.baseName = 'asNeededBoolean') then
        result.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.baseName = 'asNeededCodeableConcept') then
        result.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.baseName = 'site') then
        result.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'doseRange') then
        result.dose := ParseRange(child, path+'/doseRange'){x.3}
      else if (child.baseName = 'doseQuantity') then
        result.dose := ParseQuantity(child, path+'/doseQuantity'){x.3}
      else if (child.baseName = 'rate') then
        result.rate := ParseRatio(child, path+'/rate') {b}
      else if (child.baseName = 'maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseDosageInstruction(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseDosageInstruction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'additionalInstructions', elem.additionalInstructions);{x.2}
  if (elem.schedule is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'scheduleDateTime', TFhirDateTime(elem.schedule))
  else if (elem.schedule is TFhirPeriod) {6} then
    ComposePeriod(xml, 'schedulePeriod', TFhirPeriod(elem.schedule))
  else if (elem.schedule is TFhirTiming) {6} then
    ComposeTiming(xml, 'scheduleTiming', TFhirTiming(elem.schedule));
  if (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded))
  else if (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded));
  ComposeCodeableConcept(xml, 'site', elem.site);{x.2}
  ComposeCodeableConcept(xml, 'route', elem.route);{x.2}
  ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  if (elem.dose is TFhirRange) {6} then
    ComposeRange(xml, 'doseRange', TFhirRange(elem.dose))
  else if (elem.dose is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'doseQuantity', TFhirQuantity(elem.dose));
  ComposeRatio(xml, 'rate', elem.rate);{x.2}
  ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationDispenseDosageInstruction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispenseDosageInstruction(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationDispenseDosageInstruction(jsn : TJsonObject) : TFhirMedicationDispenseDosageInstruction;
begin
  result := TFhirMedicationDispenseDosageInstruction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(jsn.vObj['additionalInstructions']);{q}
    if jsn.has('scheduleDateTime') or jsn.has('_scheduleDateTime') then
      result.schedule := parseDateTime(jsn['scheduleDateTime'], jsn.vObj['_scheduleDateTime']);
    if jsn.has('schedulePeriod') {a4} then
      result.schedule := ParsePeriod(jsn.vObj['schedulePeriod']);
    if jsn.has('scheduleTiming') {a4} then
      result.schedule := ParseTiming(jsn.vObj['scheduleTiming']);
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('doseRange') {a4} then
      result.dose := ParseRange(jsn.vObj['doseRange']);
    if jsn.has('doseQuantity') {a4} then
      result.dose := ParseQuantity(jsn.vObj['doseQuantity']);
    if jsn.has('rate') then
        result.rate := ParseRatio(jsn.vObj['rate']);{q}
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationDispenseDosageInstruction(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseDosageInstruction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'additionalInstructions', elem.additionalInstructions); {a}
  if (elem.schedule is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'scheduleDateTime', TFhirDateTime(elem.schedule), false);
    ComposeDateTimeProps(json, 'scheduleDateTime', TFhirDateTime(elem.schedule), false);
  end
  else if (elem.schedule is TFhirPeriod) then 
    ComposePeriod(json, 'schedulePeriod', TFhirPeriod(elem.schedule)) 
  else if (elem.schedule is TFhirTiming) then 
    ComposeTiming(json, 'scheduleTiming', TFhirTiming(elem.schedule)) ;
  if (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end
  else if (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) ;
  ComposeCodeableConcept(json, 'site', elem.site); {a}
  ComposeCodeableConcept(json, 'route', elem.route); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (elem.dose is TFhirRange) then 
    ComposeRange(json, 'doseRange', TFhirRange(elem.dose)) 
  else if (elem.dose is TFhirQuantity) then 
    ComposeQuantity(json, 'doseQuantity', TFhirQuantity(elem.dose)) ;
  ComposeRatio(json, 'rate', elem.rate); {a}
  ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationDispenseSubstitution(element : IXmlDomElement; path : string) : TFhirMedicationDispenseSubstitution;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'reason') then
        result.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.baseName = 'responsibleParty') then
        result.responsiblePartyList.Add(ParseReference{TFhirPractitioner}(child, path+'/responsibleParty')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseSubstitution);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  for i := 0 to elem.reasonList.Count - 1 do
    ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  for i := 0 to elem.responsiblePartyList.Count - 1 do
    ComposeReference{TFhirPractitioner}(xml, 'responsibleParty', elem.responsiblePartyList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationDispenseSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispenseSubstitution(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationDispenseSubstitution(jsn : TJsonObject) : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('responsibleParty') then
      iterateArray(jsn.vArr['responsibleParty'], result.responsiblePartyList, parseReference{TFhirPractitioner});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationDispenseSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseSubstitution; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.reasonList.Count > 0 then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.responsiblePartyList.Count > 0 then
  begin
    json.valueArray('responsibleParty');
    for i := 0 to elem.responsiblePartyList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '',elem.responsiblePartyList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationDispense(element : IXmlDomElement; path : string) : TFhirMedicationDispense;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationDispense.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirMedicationDispenseStatus, path+'/status', child){1a}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'dispenser') then
        result.dispenser := ParseReference{TFhirPractitioner}(child, path+'/dispenser') {b}
      else if (child.baseName = 'authorizingPrescription') then
        result.authorizingPrescriptionList.Add(ParseReference{TFhirMedicationPrescription}(child, path+'/authorizingPrescription')){y.2}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'daysSupply') then
        result.daysSupply := ParseQuantity(child, path+'/daysSupply') {b}
      else if (child.baseName = 'medication') then
        result.medication := ParseReference{TFhirMedication}(child, path+'/medication') {b}
      else if (child.baseName = 'whenPrepared') then
        result.whenPreparedElement := ParseDateTime(child, path+'/whenPrepared') {b}
      else if (child.baseName = 'whenHandedOver') then
        result.whenHandedOverElement := ParseDateTime(child, path+'/whenHandedOver') {b}
      else if (child.baseName = 'destination') then
        result.destination := ParseReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.baseName = 'receiver') then
        result.receiverList.Add(ParseReference{Resource}(child, path+'/receiver')){y.2}
      else if (child.baseName = 'note') then
        result.noteElement := ParseString(child, path+'/note') {b}
      else if (child.baseName = 'dosageInstruction') then
        result.dosageInstructionList.Add(ParseMedicationDispenseDosageInstruction(child, path+'/dosageInstruction')){y.2}
      else if (child.baseName = 'substitution') then
        result.substitution := ParseMedicationDispenseSubstitution(child, path+'/substitution') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispense);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationDispenseStatus);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'dispenser', elem.dispenser);{x.2}
  for i := 0 to elem.authorizingPrescriptionList.Count - 1 do
    ComposeReference{TFhirMedicationPrescription}(xml, 'authorizingPrescription', elem.authorizingPrescriptionList[i]);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeQuantity(xml, 'daysSupply', elem.daysSupply);{x.2}
  ComposeReference{TFhirMedication}(xml, 'medication', elem.medication);{x.2}
  ComposeDateTime(xml, 'whenPrepared', elem.whenPreparedElement);{x.2}
  ComposeDateTime(xml, 'whenHandedOver', elem.whenHandedOverElement);{x.2}
  ComposeReference{TFhirLocation}(xml, 'destination', elem.destination);{x.2}
  for i := 0 to elem.receiverList.Count - 1 do
    ComposeReference{Resource}(xml, 'receiver', elem.receiverList[i]);
  ComposeString(xml, 'note', elem.noteElement);{x.2}
  for i := 0 to elem.dosageInstructionList.Count - 1 do
    ComposeMedicationDispenseDosageInstruction(xml, 'dosageInstruction', elem.dosageInstructionList[i]);
  ComposeMedicationDispenseSubstitution(xml, 'substitution', elem.substitution);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispense(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationDispense(jsn : TJsonObject) : TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirMedicationDispenseStatus);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('dispenser') then
        result.dispenser := ParseReference{TFhirPractitioner}(jsn.vObj['dispenser']);{q}
    if jsn.has('authorizingPrescription') then
      iterateArray(jsn.vArr['authorizingPrescription'], result.authorizingPrescriptionList, parseReference{TFhirMedicationPrescription});
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('daysSupply') then
        result.daysSupply := ParseQuantity(jsn.vObj['daysSupply']);{q}
    if jsn.has('medication') then
        result.medication := ParseReference{TFhirMedication}(jsn.vObj['medication']);{q}
    if jsn.has('whenPrepared') or jsn.has('_whenPrepared') then
        result.whenPreparedElement := ParseDateTime(jsn['whenPrepared'], jsn.vObj['_whenPrepared']);{q}
    if jsn.has('whenHandedOver') or jsn.has('_whenHandedOver') then
        result.whenHandedOverElement := ParseDateTime(jsn['whenHandedOver'], jsn.vObj['_whenHandedOver']);{q}
    if jsn.has('destination') then
        result.destination := ParseReference{TFhirLocation}(jsn.vObj['destination']);{q}
    if jsn.has('receiver') then
      iterateArray(jsn.vArr['receiver'], result.receiverList, parseReference{Resource});
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    if jsn.has('dosageInstruction') then
      iterateArray(jsn.vArr['dosageInstruction'], result.dosageInstructionList, parseMedicationDispenseDosageInstruction);
    if jsn.has('substitution') then
        result.substitution := ParseMedicationDispenseSubstitution(jsn.vObj['substitution']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationDispense(json : TJSONWriter; name : string; elem : TFhirMedicationDispense; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMedicationDispenseStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMedicationDispenseStatus, false);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeReference{TFhirPractitioner}(json, 'dispenser', elem.dispenser); {a}
  if elem.authorizingPrescriptionList.Count > 0 then
  begin
    json.valueArray('authorizingPrescription');
    for i := 0 to elem.authorizingPrescriptionList.Count - 1 do
      ComposeReference{TFhirMedicationPrescription}(json, '',elem.authorizingPrescriptionList[i]); {z - Reference(MedicationPrescription)}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeQuantity(json, 'daysSupply', elem.daysSupply); {a}
  ComposeReference{TFhirMedication}(json, 'medication', elem.medication); {a}
  ComposeDateTimeValue(json, 'whenPrepared', elem.whenPreparedElement, false);
  ComposeDateTimeProps(json, 'whenPrepared', elem.whenPreparedElement, false);
  ComposeDateTimeValue(json, 'whenHandedOver', elem.whenHandedOverElement, false);
  ComposeDateTimeProps(json, 'whenHandedOver', elem.whenHandedOverElement, false);
  ComposeReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  if elem.receiverList.Count > 0 then
  begin
    json.valueArray('receiver');
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.receiverList[i]); {z - Reference(Patient|Practitioner)}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'note', elem.noteElement, false);
  ComposeStringProps(json, 'note', elem.noteElement, false);
  if elem.dosageInstructionList.Count > 0 then
  begin
    json.valueArray('dosageInstruction');
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeMedicationDispenseDosageInstruction(json, '',elem.dosageInstructionList[i]); {z - }
    json.FinishArray;
  end;
  ComposeMedicationDispenseSubstitution(json, 'substitution', elem.substitution); {a}
end;

function TFHIRXmlParser.ParseMedicationPrescriptionDosageInstruction(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionDosageInstruction;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPrescriptionDosageInstruction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(child, path+'/additionalInstructions') {b}
      else if (child.baseName = 'scheduledDateTime') then
        result.scheduled := ParseDateTime(child, path+'/scheduledDateTime'){x.3}
      else if (child.baseName = 'scheduledPeriod') then
        result.scheduled := ParsePeriod(child, path+'/scheduledPeriod'){x.3}
      else if (child.baseName = 'scheduledTiming') then
        result.scheduled := ParseTiming(child, path+'/scheduledTiming'){x.3}
      else if (child.baseName = 'asNeededBoolean') then
        result.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.baseName = 'asNeededCodeableConcept') then
        result.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.baseName = 'site') then
        result.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'doseRange') then
        result.dose := ParseRange(child, path+'/doseRange'){x.3}
      else if (child.baseName = 'doseQuantity') then
        result.dose := ParseQuantity(child, path+'/doseQuantity'){x.3}
      else if (child.baseName = 'rate') then
        result.rate := ParseRatio(child, path+'/rate') {b}
      else if (child.baseName = 'maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPrescriptionDosageInstruction(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionDosageInstruction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'text', elem.textElement);{x.2}
  ComposeCodeableConcept(xml, 'additionalInstructions', elem.additionalInstructions);{x.2}
  if (elem.scheduled is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'scheduledDateTime', TFhirDateTime(elem.scheduled))
  else if (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(xml, 'scheduledPeriod', TFhirPeriod(elem.scheduled))
  else if (elem.scheduled is TFhirTiming) {6} then
    ComposeTiming(xml, 'scheduledTiming', TFhirTiming(elem.scheduled));
  if (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded))
  else if (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded));
  ComposeCodeableConcept(xml, 'site', elem.site);{x.2}
  ComposeCodeableConcept(xml, 'route', elem.route);{x.2}
  ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  if (elem.dose is TFhirRange) {6} then
    ComposeRange(xml, 'doseRange', TFhirRange(elem.dose))
  else if (elem.dose is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'doseQuantity', TFhirQuantity(elem.dose));
  ComposeRatio(xml, 'rate', elem.rate);{x.2}
  ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPrescriptionDosageInstruction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPrescriptionDosageInstruction(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationPrescriptionDosageInstruction(jsn : TJsonObject) : TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(jsn.vObj['additionalInstructions']);{q}
    if jsn.has('scheduledDateTime') or jsn.has('_scheduledDateTime') then
      result.scheduled := parseDateTime(jsn['scheduledDateTime'], jsn.vObj['_scheduledDateTime']);
    if jsn.has('scheduledPeriod') {a4} then
      result.scheduled := ParsePeriod(jsn.vObj['scheduledPeriod']);
    if jsn.has('scheduledTiming') {a4} then
      result.scheduled := ParseTiming(jsn.vObj['scheduledTiming']);
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('doseRange') {a4} then
      result.dose := ParseRange(jsn.vObj['doseRange']);
    if jsn.has('doseQuantity') {a4} then
      result.dose := ParseQuantity(jsn.vObj['doseQuantity']);
    if jsn.has('rate') then
        result.rate := ParseRatio(jsn.vObj['rate']);{q}
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPrescriptionDosageInstruction(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionDosageInstruction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'text', elem.textElement, false);
  ComposeStringProps(json, 'text', elem.textElement, false);
  ComposeCodeableConcept(json, 'additionalInstructions', elem.additionalInstructions); {a}
  if (elem.scheduled is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'scheduledDateTime', TFhirDateTime(elem.scheduled), false);
    ComposeDateTimeProps(json, 'scheduledDateTime', TFhirDateTime(elem.scheduled), false);
  end
  else if (elem.scheduled is TFhirPeriod) then 
    ComposePeriod(json, 'scheduledPeriod', TFhirPeriod(elem.scheduled)) 
  else if (elem.scheduled is TFhirTiming) then 
    ComposeTiming(json, 'scheduledTiming', TFhirTiming(elem.scheduled)) ;
  if (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end
  else if (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) ;
  ComposeCodeableConcept(json, 'site', elem.site); {a}
  ComposeCodeableConcept(json, 'route', elem.route); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (elem.dose is TFhirRange) then 
    ComposeRange(json, 'doseRange', TFhirRange(elem.dose)) 
  else if (elem.dose is TFhirQuantity) then 
    ComposeQuantity(json, 'doseQuantity', TFhirQuantity(elem.dose)) ;
  ComposeRatio(json, 'rate', elem.rate); {a}
  ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationPrescriptionDispense(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionDispense;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPrescriptionDispense.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'medication') then
        result.medication := ParseReference{TFhirMedication}(child, path+'/medication') {b}
      else if (child.baseName = 'validityPeriod') then
        result.validityPeriod := ParsePeriod(child, path+'/validityPeriod') {b}
      else if (child.baseName = 'numberOfRepeatsAllowed') then
        result.numberOfRepeatsAllowedElement := ParsePositiveInt(child, path+'/numberOfRepeatsAllowed') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'expectedSupplyDuration') then
        result.expectedSupplyDuration := ParseQuantity(child, path+'/expectedSupplyDuration') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPrescriptionDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionDispense);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirMedication}(xml, 'medication', elem.medication);{x.2}
  ComposePeriod(xml, 'validityPeriod', elem.validityPeriod);{x.2}
  ComposePositiveInt(xml, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedElement);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeQuantity(xml, 'expectedSupplyDuration', elem.expectedSupplyDuration);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPrescriptionDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPrescriptionDispense(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationPrescriptionDispense(jsn : TJsonObject) : TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('medication') then
        result.medication := ParseReference{TFhirMedication}(jsn.vObj['medication']);{q}
    if jsn.has('validityPeriod') then
        result.validityPeriod := ParsePeriod(jsn.vObj['validityPeriod']);{q}
    if jsn.has('numberOfRepeatsAllowed') or jsn.has('_numberOfRepeatsAllowed') then
        result.numberOfRepeatsAllowedElement := ParsePositiveInt(jsn['numberOfRepeatsAllowed'], jsn.vObj['_numberOfRepeatsAllowed']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('expectedSupplyDuration') then
        result.expectedSupplyDuration := ParseQuantity(jsn.vObj['expectedSupplyDuration']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPrescriptionDispense(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionDispense; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirMedication}(json, 'medication', elem.medication); {a}
  ComposePeriod(json, 'validityPeriod', elem.validityPeriod); {a}
  ComposePositiveIntValue(json, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedElement, false);
  ComposePositiveIntProps(json, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedElement, false);
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeQuantity(json, 'expectedSupplyDuration', elem.expectedSupplyDuration); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationPrescriptionSubstitution(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionSubstitution;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPrescriptionSubstitution.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPrescriptionSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionSubstitution);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPrescriptionSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPrescriptionSubstitution(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationPrescriptionSubstitution(jsn : TJsonObject) : TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPrescriptionSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionSubstitution; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationPrescription(element : IXmlDomElement; path : string) : TFhirMedicationPrescription;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPrescription.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'dateWritten') then
        result.dateWrittenElement := ParseDateTime(child, path+'/dateWritten') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirMedicationPrescriptionStatus, path+'/status', child){1a}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'prescriber') then
        result.prescriber := ParseReference{TFhirPractitioner}(child, path+'/prescriber') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'reasonCodeableConcept') then
        result.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.baseName = 'reasonReference') then
        result.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.baseName = 'note') then
        result.noteElement := ParseString(child, path+'/note') {b}
      else if (child.baseName = 'medication') then
        result.medication := ParseReference{TFhirMedication}(child, path+'/medication') {b}
      else if (child.baseName = 'dosageInstruction') then
        result.dosageInstructionList.Add(ParseMedicationPrescriptionDosageInstruction(child, path+'/dosageInstruction')){y.2}
      else if (child.baseName = 'dispense') then
        result.dispense := ParseMedicationPrescriptionDispense(child, path+'/dispense') {b}
      else if (child.baseName = 'substitution') then
        result.substitution := ParseMedicationPrescriptionSubstitution(child, path+'/substitution') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPrescription(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescription);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeDateTime(xml, 'dateWritten', elem.dateWrittenElement);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationPrescriptionStatus);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'prescriber', elem.prescriber);{x.2}
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  ComposeString(xml, 'note', elem.noteElement);{x.2}
  ComposeReference{TFhirMedication}(xml, 'medication', elem.medication);{x.2}
  for i := 0 to elem.dosageInstructionList.Count - 1 do
    ComposeMedicationPrescriptionDosageInstruction(xml, 'dosageInstruction', elem.dosageInstructionList[i]);
  ComposeMedicationPrescriptionDispense(xml, 'dispense', elem.dispense);{x.2}
  ComposeMedicationPrescriptionSubstitution(xml, 'substitution', elem.substitution);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPrescription(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPrescription(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationPrescription(jsn : TJsonObject) : TFhirMedicationPrescription;
begin
  result := TFhirMedicationPrescription.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('dateWritten') or jsn.has('_dateWritten') then
        result.dateWrittenElement := ParseDateTime(jsn['dateWritten'], jsn.vObj['_dateWritten']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirMedicationPrescriptionStatus);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('prescriber') then
        result.prescriber := ParseReference{TFhirPractitioner}(jsn.vObj['prescriber']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    if jsn.has('medication') then
        result.medication := ParseReference{TFhirMedication}(jsn.vObj['medication']);{q}
    if jsn.has('dosageInstruction') then
      iterateArray(jsn.vArr['dosageInstruction'], result.dosageInstructionList, parseMedicationPrescriptionDosageInstruction);
    if jsn.has('dispense') then
        result.dispense := ParseMedicationPrescriptionDispense(jsn.vObj['dispense']);{q}
    if jsn.has('substitution') then
        result.substitution := ParseMedicationPrescriptionSubstitution(jsn.vObj['substitution']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPrescription(json : TJSONWriter; name : string; elem : TFhirMedicationPrescription; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'dateWritten', elem.dateWrittenElement, false);
  ComposeDateTimeProps(json, 'dateWritten', elem.dateWrittenElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMedicationPrescriptionStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMedicationPrescriptionStatus, false);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeReference{TFhirPractitioner}(json, 'prescriber', elem.prescriber); {a}
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  ComposeStringValue(json, 'note', elem.noteElement, false);
  ComposeStringProps(json, 'note', elem.noteElement, false);
  ComposeReference{TFhirMedication}(json, 'medication', elem.medication); {a}
  if elem.dosageInstructionList.Count > 0 then
  begin
    json.valueArray('dosageInstruction');
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeMedicationPrescriptionDosageInstruction(json, '',elem.dosageInstructionList[i]); {z - }
    json.FinishArray;
  end;
  ComposeMedicationPrescriptionDispense(json, 'dispense', elem.dispense); {a}
  ComposeMedicationPrescriptionSubstitution(json, 'substitution', elem.substitution); {a}
end;

function TFHIRXmlParser.ParseMedicationStatementDosage(element : IXmlDomElement; path : string) : TFhirMedicationStatementDosage;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'schedule') then
        result.schedule := ParseTiming(child, path+'/schedule') {b}
      else if (child.baseName = 'asNeededBoolean') then
        result.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.baseName = 'asNeededCodeableConcept') then
        result.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.baseName = 'site') then
        result.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'rate') then
        result.rate := ParseRatio(child, path+'/rate') {b}
      else if (child.baseName = 'maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationStatementDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatementDosage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'text', elem.textElement);{x.2}
  ComposeTiming(xml, 'schedule', elem.schedule);{x.2}
  if (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded))
  else if (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded));
  ComposeCodeableConcept(xml, 'site', elem.site);{x.2}
  ComposeCodeableConcept(xml, 'route', elem.route);{x.2}
  ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeRatio(xml, 'rate', elem.rate);{x.2}
  ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationStatementDosage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationStatementDosage(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationStatementDosage(jsn : TJsonObject) : TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('schedule') then
        result.schedule := ParseTiming(jsn.vObj['schedule']);{q}
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('rate') then
        result.rate := ParseRatio(jsn.vObj['rate']);{q}
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationStatementDosage(json : TJSONWriter; name : string; elem : TFhirMedicationStatementDosage; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'text', elem.textElement, false);
  ComposeStringProps(json, 'text', elem.textElement, false);
  ComposeTiming(json, 'schedule', elem.schedule); {a}
  if (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end
  else if (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) ;
  ComposeCodeableConcept(json, 'site', elem.site); {a}
  ComposeCodeableConcept(json, 'route', elem.route); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeRatio(json, 'rate', elem.rate); {a}
  ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationStatement(element : IXmlDomElement; path : string) : TFhirMedicationStatement;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationStatement.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'informationSource') then
        result.informationSource := ParseReference{Resource}(child, path+'/informationSource') {b}
      else if (child.baseName = 'dateAsserted') then
        result.dateAssertedElement := ParseDateTime(child, path+'/dateAsserted') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirMedicationStatementStatus, path+'/status', child){1a}
      else if (child.baseName = 'wasNotGiven') then
        result.wasNotGivenElement := ParseBoolean(child, path+'/wasNotGiven') {b}
      else if (child.baseName = 'reasonNotGiven') then
        result.reasonNotGivenList.Add(ParseCodeableConcept(child, path+'/reasonNotGiven')){y.2}
      else if (child.baseName = 'reasonForUseCodeableConcept') then
        result.reasonForUse := ParseCodeableConcept(child, path+'/reasonForUseCodeableConcept'){x.3}
      else if (child.baseName = 'reasonForUseReference') then
        result.reasonForUse := ParseReference(child, path+'/reasonForUseReference') {a}
      else if (child.baseName = 'effectiveDateTime') then
        result.effective := ParseDateTime(child, path+'/effectiveDateTime'){x.3}
      else if (child.baseName = 'effectivePeriod') then
        result.effective := ParsePeriod(child, path+'/effectivePeriod'){x.3}
      else if (child.baseName = 'note') then
        result.noteElement := ParseString(child, path+'/note') {b}
      else if (child.baseName = 'medication') then
        result.medication := ParseReference{TFhirMedication}(child, path+'/medication') {b}
      else if (child.baseName = 'dosage') then
        result.dosageList.Add(ParseMedicationStatementDosage(child, path+'/dosage')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationStatement(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeReference{Resource}(xml, 'informationSource', elem.informationSource);{x.2}
  ComposeDateTime(xml, 'dateAsserted', elem.dateAssertedElement);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationStatementStatus);
  ComposeBoolean(xml, 'wasNotGiven', elem.wasNotGivenElement);{x.2}
  for i := 0 to elem.reasonNotGivenList.Count - 1 do
    ComposeCodeableConcept(xml, 'reasonNotGiven', elem.reasonNotGivenList[i]);
  if (elem.reasonForUse is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonForUseCodeableConcept', TFhirCodeableConcept(elem.reasonForUse))
  else if (elem.reasonForUse is TFhirReference) {2} then
    ComposeReference(xml, 'reasonForUseReference', TFhirReference(elem.reasonForUse));
  if (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveDateTime', TFhirDateTime(elem.effective))
  else if (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectivePeriod', TFhirPeriod(elem.effective));
  ComposeString(xml, 'note', elem.noteElement);{x.2}
  ComposeReference{TFhirMedication}(xml, 'medication', elem.medication);{x.2}
  for i := 0 to elem.dosageList.Count - 1 do
    ComposeMedicationStatementDosage(xml, 'dosage', elem.dosageList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationStatement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationStatement(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationStatement(jsn : TJsonObject) : TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('informationSource') then
        result.informationSource := ParseReference{Resource}(jsn.vObj['informationSource']);{q}
    if jsn.has('dateAsserted') or jsn.has('_dateAsserted') then
        result.dateAssertedElement := ParseDateTime(jsn['dateAsserted'], jsn.vObj['_dateAsserted']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirMedicationStatementStatus);
    if jsn.has('wasNotGiven') or jsn.has('_wasNotGiven') then
        result.wasNotGivenElement := ParseBoolean(jsn['wasNotGiven'], jsn.vObj['_wasNotGiven']);{q}
    if jsn.has('reasonNotGiven') then
      iterateArray(jsn.vArr['reasonNotGiven'], result.reasonNotGivenList, parseCodeableConcept);
    if jsn.has('reasonForUseCodeableConcept') {a4} then
      result.reasonForUse := ParseCodeableConcept(jsn.vObj['reasonForUseCodeableConcept']);
    if jsn.has('reasonForUseReference') {a3} then
      result.reasonForUse := ParseReference(jsn.vObj['reasonForUseReference']);
    if jsn.has('effectiveDateTime') or jsn.has('_effectiveDateTime') then
      result.effective := parseDateTime(jsn['effectiveDateTime'], jsn.vObj['_effectiveDateTime']);
    if jsn.has('effectivePeriod') {a4} then
      result.effective := ParsePeriod(jsn.vObj['effectivePeriod']);
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    if jsn.has('medication') then
        result.medication := ParseReference{TFhirMedication}(jsn.vObj['medication']);{q}
    if jsn.has('dosage') then
      iterateArray(jsn.vArr['dosage'], result.dosageList, parseMedicationStatementDosage);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationStatement(json : TJSONWriter; name : string; elem : TFhirMedicationStatement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeReference{Resource}(json, 'informationSource', elem.informationSource); {a}
  ComposeDateTimeValue(json, 'dateAsserted', elem.dateAssertedElement, false);
  ComposeDateTimeProps(json, 'dateAsserted', elem.dateAssertedElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMedicationStatementStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMedicationStatementStatus, false);
  ComposeBooleanValue(json, 'wasNotGiven', elem.wasNotGivenElement, false);
  ComposeBooleanProps(json, 'wasNotGiven', elem.wasNotGivenElement, false);
  if elem.reasonNotGivenList.Count > 0 then
  begin
    json.valueArray('reasonNotGiven');
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.reasonNotGivenList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (elem.reasonForUse is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonForUseCodeableConcept', TFhirCodeableConcept(elem.reasonForUse)) 
  else if (elem.reasonForUse is TFhirReference) then
    ComposeReference(json, 'reasonForUseReference', TFhirReference(elem.reasonForUse));
  if (elem.effective is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
    ComposeDateTimeProps(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
  end
  else if (elem.effective is TFhirPeriod) then 
    ComposePeriod(json, 'effectivePeriod', TFhirPeriod(elem.effective)) ;
  ComposeStringValue(json, 'note', elem.noteElement, false);
  ComposeStringProps(json, 'note', elem.noteElement, false);
  ComposeReference{TFhirMedication}(json, 'medication', elem.medication); {a}
  if elem.dosageList.Count > 0 then
  begin
    json.valueArray('dosage');
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeMedicationStatementDosage(json, '',elem.dosageList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseMessageHeaderResponse(element : IXmlDomElement; path : string) : TFhirMessageHeaderResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierElement := ParseId(child, path+'/identifier') {b}
      else if (child.baseName = 'code') then
        result.codeElement := ParseEnum(CODES_TFhirResponseCode, path+'/code', child){1a}
      else if (child.baseName = 'details') then
        result.details := ParseReference{TFhirOperationOutcome}(child, path+'/details') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderResponse(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderResponse);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'identifier', elem.identifierElement);{x.2}
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirResponseCode);
  ComposeReference{TFhirOperationOutcome}(xml, 'details', elem.details);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMessageHeaderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageHeaderResponse(jsn : TJsonObject) : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierElement := ParseId(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn['code'], jsn.vObj['_code'], CODES_TFhirResponseCode);
    if jsn.has('details') then
        result.details := ParseReference{TFhirOperationOutcome}(jsn.vObj['details']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderResponse(json : TJSONWriter; name : string; elem : TFhirMessageHeaderResponse; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'identifier', elem.identifierElement, false);
  ComposeIdProps(json, 'identifier', elem.identifierElement, false);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirResponseCode, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirResponseCode, false);
  ComposeReference{TFhirOperationOutcome}(json, 'details', elem.details); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseMessageHeaderSource(element : IXmlDomElement; path : string) : TFhirMessageHeaderSource;
var
  child : IXMLDOMElement;
begin
  result := TFhirMessageHeaderSource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'software') then
        result.softwareElement := ParseString(child, path+'/software') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'contact') then
        result.contact := ParseContactPoint(child, path+'/contact') {b}
      else if (child.baseName = 'endpoint') then
        result.endpointElement := ParseUri(child, path+'/endpoint') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderSource(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderSource);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeString(xml, 'software', elem.softwareElement);{x.2}
  ComposeString(xml, 'version', elem.versionElement);{x.2}
  ComposeContactPoint(xml, 'contact', elem.contact);{x.2}
  ComposeUri(xml, 'endpoint', elem.endpointElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMessageHeaderSource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderSource(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageHeaderSource(jsn : TJsonObject) : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('software') or jsn.has('_software') then
        result.softwareElement := ParseString(jsn['software'], jsn.vObj['_software']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('contact') then
        result.contact := ParseContactPoint(jsn.vObj['contact']);{q}
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpointElement := ParseUri(jsn['endpoint'], jsn.vObj['_endpoint']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderSource(json : TJSONWriter; name : string; elem : TFhirMessageHeaderSource; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeStringValue(json, 'software', elem.softwareElement, false);
  ComposeStringProps(json, 'software', elem.softwareElement, false);
  ComposeStringValue(json, 'version', elem.versionElement, false);
  ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeContactPoint(json, 'contact', elem.contact); {a}
  ComposeUriValue(json, 'endpoint', elem.endpointElement, false);
  ComposeUriProps(json, 'endpoint', elem.endpointElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseMessageHeaderDestination(element : IXmlDomElement; path : string) : TFhirMessageHeaderDestination;
var
  child : IXMLDOMElement;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirDevice}(child, path+'/target') {b}
      else if (child.baseName = 'endpoint') then
        result.endpointElement := ParseUri(child, path+'/endpoint') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderDestination(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderDestination);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeReference{TFhirDevice}(xml, 'target', elem.target);{x.2}
  ComposeUri(xml, 'endpoint', elem.endpointElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMessageHeaderDestination(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderDestination(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageHeaderDestination(jsn : TJsonObject) : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirDevice}(jsn.vObj['target']);{q}
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpointElement := ParseUri(jsn['endpoint'], jsn.vObj['_endpoint']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderDestination(json : TJSONWriter; name : string; elem : TFhirMessageHeaderDestination; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeReference{TFhirDevice}(json, 'target', elem.target); {a}
  ComposeUriValue(json, 'endpoint', elem.endpointElement, false);
  ComposeUriProps(json, 'endpoint', elem.endpointElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseMessageHeader(element : IXmlDomElement; path : string) : TFhirMessageHeader;
var
  child : IXMLDOMElement;
begin
  result := TFhirMessageHeader.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierElement := ParseId(child, path+'/identifier') {b}
      else if (child.baseName = 'timestamp') then
        result.timestampElement := ParseInstant(child, path+'/timestamp') {b}
      else if (child.baseName = 'event') then
        result.event := ParseCoding(child, path+'/event') {b}
      else if (child.baseName = 'response') then
        result.response := ParseMessageHeaderResponse(child, path+'/response') {b}
      else if (child.baseName = 'source') then
        result.source := ParseMessageHeaderSource(child, path+'/source') {b}
      else if (child.baseName = 'destination') then
        result.destinationList.Add(ParseMessageHeaderDestination(child, path+'/destination')){y.2}
      else if (child.baseName = 'enterer') then
        result.enterer := ParseReference{TFhirPractitioner}(child, path+'/enterer') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{TFhirPractitioner}(child, path+'/author') {b}
      else if (child.baseName = 'receiver') then
        result.receiver := ParseReference{Resource}(child, path+'/receiver') {b}
      else if (child.baseName = 'responsible') then
        result.responsible := ParseReference{Resource}(child, path+'/responsible') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.baseName = 'data') then
        result.dataList.Add(ParseReference{TFhirReference}(child, path+'/data')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMessageHeader(xml : TXmlBuilder; name : string; elem : TFhirMessageHeader);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeId(xml, 'identifier', elem.identifierElement);{x.2}
  ComposeInstant(xml, 'timestamp', elem.timestampElement);{x.2}
  ComposeCoding(xml, 'event', elem.event);{x.2}
  ComposeMessageHeaderResponse(xml, 'response', elem.response);{x.2}
  ComposeMessageHeaderSource(xml, 'source', elem.source);{x.2}
  for i := 0 to elem.destinationList.Count - 1 do
    ComposeMessageHeaderDestination(xml, 'destination', elem.destinationList[i]);
  ComposeReference{TFhirPractitioner}(xml, 'enterer', elem.enterer);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'author', elem.author);{x.2}
  ComposeReference{Resource}(xml, 'receiver', elem.receiver);{x.2}
  ComposeReference{Resource}(xml, 'responsible', elem.responsible);{x.2}
  ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2}
  for i := 0 to elem.dataList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'data', elem.dataList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMessageHeader(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeader(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageHeader(jsn : TJsonObject) : TFhirMessageHeader;
begin
  result := TFhirMessageHeader.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierElement := ParseId(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('timestamp') or jsn.has('_timestamp') then
        result.timestampElement := ParseInstant(jsn['timestamp'], jsn.vObj['_timestamp']);{q}
    if jsn.has('event') then
        result.event := ParseCoding(jsn.vObj['event']);{q}
    if jsn.has('response') then
        result.response := ParseMessageHeaderResponse(jsn.vObj['response']);{q}
    if jsn.has('source') then
        result.source := ParseMessageHeaderSource(jsn.vObj['source']);{q}
    if jsn.has('destination') then
      iterateArray(jsn.vArr['destination'], result.destinationList, parseMessageHeaderDestination);
    if jsn.has('enterer') then
        result.enterer := ParseReference{TFhirPractitioner}(jsn.vObj['enterer']);{q}
    if jsn.has('author') then
        result.author := ParseReference{TFhirPractitioner}(jsn.vObj['author']);{q}
    if jsn.has('receiver') then
        result.receiver := ParseReference{Resource}(jsn.vObj['receiver']);{q}
    if jsn.has('responsible') then
        result.responsible := ParseReference{Resource}(jsn.vObj['responsible']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    if jsn.has('data') then
      iterateArray(jsn.vArr['data'], result.dataList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMessageHeader(json : TJSONWriter; name : string; elem : TFhirMessageHeader; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeIdValue(json, 'identifier', elem.identifierElement, false);
  ComposeIdProps(json, 'identifier', elem.identifierElement, false);
  ComposeInstantValue(json, 'timestamp', elem.timestampElement, false);
  ComposeInstantProps(json, 'timestamp', elem.timestampElement, false);
  ComposeCoding(json, 'event', elem.event); {a}
  ComposeMessageHeaderResponse(json, 'response', elem.response); {a}
  ComposeMessageHeaderSource(json, 'source', elem.source); {a}
  if elem.destinationList.Count > 0 then
  begin
    json.valueArray('destination');
    for i := 0 to elem.destinationList.Count - 1 do
      ComposeMessageHeaderDestination(json, '',elem.destinationList[i]); {z - }
    json.FinishArray;
  end;
  ComposeReference{TFhirPractitioner}(json, 'enterer', elem.enterer); {a}
  ComposeReference{TFhirPractitioner}(json, 'author', elem.author); {a}
  ComposeReference{Resource}(json, 'receiver', elem.receiver); {a}
  ComposeReference{Resource}(json, 'responsible', elem.responsible); {a}
  ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if elem.dataList.Count > 0 then
  begin
    json.valueArray('data');
    for i := 0 to elem.dataList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.dataList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseNamingSystemUniqueId(element : IXmlDomElement; path : string) : TFhirNamingSystemUniqueId;
var
  child : IXMLDOMElement;
begin
  result := TFhirNamingSystemUniqueId.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirNamingsystemIdentifierType, path+'/type', child){1a}
      else if (child.baseName = 'value') then
        result.valueElement := ParseString(child, path+'/value') {b}
      else if (child.baseName = 'preferred') then
        result.preferredElement := ParseBoolean(child, path+'/preferred') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNamingSystemUniqueId(xml : TXmlBuilder; name : string; elem : TFhirNamingSystemUniqueId);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirNamingsystemIdentifierType);
  ComposeString(xml, 'value', elem.valueElement);{x.2}
  ComposeBoolean(xml, 'preferred', elem.preferredElement);{x.2}
  ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNamingSystemUniqueId(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNamingSystemUniqueId(jsn)); {2}
end;

function TFHIRJsonParser.ParseNamingSystemUniqueId(jsn : TJsonObject) : TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirNamingsystemIdentifierType);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    if jsn.has('preferred') or jsn.has('_preferred') then
        result.preferredElement := ParseBoolean(jsn['preferred'], jsn.vObj['_preferred']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNamingSystemUniqueId(json : TJSONWriter; name : string; elem : TFhirNamingSystemUniqueId; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirNamingsystemIdentifierType, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirNamingsystemIdentifierType, false);
  ComposeStringValue(json, 'value', elem.valueElement, false);
  ComposeStringProps(json, 'value', elem.valueElement, false);
  ComposeBooleanValue(json, 'preferred', elem.preferredElement, false);
  ComposeBooleanProps(json, 'preferred', elem.preferredElement, false);
  ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseNamingSystemContact(element : IXmlDomElement; path : string) : TFhirNamingSystemContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirNamingSystemContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNamingSystemContact(xml : TXmlBuilder; name : string; elem : TFhirNamingSystemContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNamingSystemContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNamingSystemContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseNamingSystemContact(jsn : TJsonObject) : TFhirNamingSystemContact;
begin
  result := TFhirNamingSystemContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNamingSystemContact(json : TJSONWriter; name : string; elem : TFhirNamingSystemContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseNamingSystem(element : IXmlDomElement; path : string) : TFhirNamingSystem;
var
  child : IXMLDOMElement;
begin
  result := TFhirNamingSystem.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirNamingsystemType, path+'/type', child){1a}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatus, path+'/status', child){1a}
      else if (child.baseName = 'country') then
        result.countryElement := ParseCode(child, path+'/country') {b}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'responsible') then
        result.responsibleElement := ParseString(child, path+'/responsible') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'usage') then
        result.usageElement := ParseString(child, path+'/usage') {b}
      else if (child.baseName = 'uniqueId') then
        result.uniqueIdList.Add(ParseNamingSystemUniqueId(child, path+'/uniqueId')){y.2}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseNamingSystemContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'replacedBy') then
        result.replacedBy := ParseReference{TFhirNamingSystem}(child, path+'/replacedBy') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNamingSystem(xml : TXmlBuilder; name : string; elem : TFhirNamingSystem);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirNamingsystemType);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus);
  ComposeCode(xml, 'country', elem.countryElement);{x.2}
  ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  ComposeString(xml, 'responsible', elem.responsibleElement);{x.2}
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeString(xml, 'usage', elem.usageElement);{x.2}
  for i := 0 to elem.uniqueIdList.Count - 1 do
    ComposeNamingSystemUniqueId(xml, 'uniqueId', elem.uniqueIdList[i]);
  ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  for i := 0 to elem.contactList.Count - 1 do
    ComposeNamingSystemContact(xml, 'contact', elem.contactList[i]);
  ComposeReference{TFhirNamingSystem}(xml, 'replacedBy', elem.replacedBy);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNamingSystem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNamingSystem(jsn)); {2}
end;

function TFHIRJsonParser.ParseNamingSystem(jsn : TJsonObject) : TFhirNamingSystem;
begin
  result := TFhirNamingSystem.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirNamingsystemType);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatus);
    if jsn.has('country') or jsn.has('_country') then
        result.countryElement := ParseCode(jsn['country'], jsn.vObj['_country']);{q}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('responsible') or jsn.has('_responsible') then
        result.responsibleElement := ParseString(jsn['responsible'], jsn.vObj['_responsible']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('usage') or jsn.has('_usage') then
        result.usageElement := ParseString(jsn['usage'], jsn.vObj['_usage']);{q}
    if jsn.has('uniqueId') then
      iterateArray(jsn.vArr['uniqueId'], result.uniqueIdList, parseNamingSystemUniqueId);
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseNamingSystemContact);
    if jsn.has('replacedBy') then
        result.replacedBy := ParseReference{TFhirNamingSystem}(jsn.vObj['replacedBy']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNamingSystem(json : TJSONWriter; name : string; elem : TFhirNamingSystem; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirNamingsystemType, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirNamingsystemType, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus, false);
  ComposeCodeValue(json, 'country', elem.countryElement, false);
  ComposeCodeProps(json, 'country', elem.countryElement, false);
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeStringValue(json, 'responsible', elem.responsibleElement, false);
  ComposeStringProps(json, 'responsible', elem.responsibleElement, false);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeStringValue(json, 'usage', elem.usageElement, false);
  ComposeStringProps(json, 'usage', elem.usageElement, false);
  if elem.uniqueIdList.Count > 0 then
  begin
    json.valueArray('uniqueId');
    for i := 0 to elem.uniqueIdList.Count - 1 do
      ComposeNamingSystemUniqueId(json, '',elem.uniqueIdList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if elem.contactList.Count > 0 then
begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeNamingSystemContact(json, '',elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  ComposeReference{TFhirNamingSystem}(json, 'replacedBy', elem.replacedBy); {a}
end;

function TFHIRXmlParser.ParseNutritionOrderOralDiet(element : IXmlDomElement; path : string) : TFhirNutritionOrderOralDiet;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrderOralDiet.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.baseName = 'scheduled') then
        result.scheduled := ParseTiming(child, path+'/scheduled') {b}
      else if (child.baseName = 'nutrient') then
        result.nutrientList.Add(ParseNutritionOrderOralDietNutrient(child, path+'/nutrient')){y.2}
      else if (child.baseName = 'texture') then
        result.textureList.Add(ParseNutritionOrderOralDietTexture(child, path+'/texture')){y.2}
      else if (child.baseName = 'fluidConsistencyType') then
        result.fluidConsistencyTypeList.Add(ParseCodeableConcept(child, path+'/fluidConsistencyType')){y.2}
      else if (child.baseName = 'instruction') then
        result.instructionElement := ParseString(child, path+'/instruction') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDiet(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDiet);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  ComposeTiming(xml, 'scheduled', elem.scheduled);{x.2}
  for i := 0 to elem.nutrientList.Count - 1 do
    ComposeNutritionOrderOralDietNutrient(xml, 'nutrient', elem.nutrientList[i]);
  for i := 0 to elem.textureList.Count - 1 do
    ComposeNutritionOrderOralDietTexture(xml, 'texture', elem.textureList[i]);
  for i := 0 to elem.fluidConsistencyTypeList.Count - 1 do
    ComposeCodeableConcept(xml, 'fluidConsistencyType', elem.fluidConsistencyTypeList[i]);
  ComposeString(xml, 'instruction', elem.instructionElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrderOralDiet(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderOralDiet(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderOralDiet(jsn : TJsonObject) : TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('scheduled') then
        result.scheduled := ParseTiming(jsn.vObj['scheduled']);{q}
    if jsn.has('nutrient') then
      iterateArray(jsn.vArr['nutrient'], result.nutrientList, parseNutritionOrderOralDietNutrient);
    if jsn.has('texture') then
      iterateArray(jsn.vArr['texture'], result.textureList, parseNutritionOrderOralDietTexture);
    if jsn.has('fluidConsistencyType') then
      iterateArray(jsn.vArr['fluidConsistencyType'], result.fluidConsistencyTypeList, parseCodeableConcept);
    if jsn.has('instruction') or jsn.has('_instruction') then
        result.instructionElement := ParseString(jsn['instruction'], jsn.vObj['_instruction']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderOralDiet(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDiet; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '',elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeTiming(json, 'scheduled', elem.scheduled); {a}
  if elem.nutrientList.Count > 0 then
  begin
    json.valueArray('nutrient');
    for i := 0 to elem.nutrientList.Count - 1 do
      ComposeNutritionOrderOralDietNutrient(json, '',elem.nutrientList[i]); {z - }
    json.FinishArray;
  end;
  if elem.textureList.Count > 0 then
  begin
    json.valueArray('texture');
    for i := 0 to elem.textureList.Count - 1 do
      ComposeNutritionOrderOralDietTexture(json, '',elem.textureList[i]); {z - }
    json.FinishArray;
  end;
  if elem.fluidConsistencyTypeList.Count > 0 then
  begin
    json.valueArray('fluidConsistencyType');
    for i := 0 to elem.fluidConsistencyTypeList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.fluidConsistencyTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'instruction', elem.instructionElement, false);
  ComposeStringProps(json, 'instruction', elem.instructionElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietNutrient(element : IXmlDomElement; path : string) : TFhirNutritionOrderOralDietNutrient;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'modifier') then
        result.modifier := ParseCodeableConcept(child, path+'/modifier') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietNutrient(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDietNutrient);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'modifier', elem.modifier);{x.2}
  ComposeQuantity(xml, 'amount', elem.amount);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrderOralDietNutrient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderOralDietNutrient(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderOralDietNutrient(jsn : TJsonObject) : TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('modifier') then
        result.modifier := ParseCodeableConcept(jsn.vObj['modifier']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderOralDietNutrient(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDietNutrient; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'modifier', elem.modifier); {a}
  ComposeQuantity(json, 'amount', elem.amount); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietTexture(element : IXmlDomElement; path : string) : TFhirNutritionOrderOralDietTexture;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'modifier') then
        result.modifier := ParseCodeableConcept(child, path+'/modifier') {b}
      else if (child.baseName = 'foodType') then
        result.foodType := ParseCodeableConcept(child, path+'/foodType') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietTexture(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDietTexture);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'modifier', elem.modifier);{x.2}
  ComposeCodeableConcept(xml, 'foodType', elem.foodType);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrderOralDietTexture(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderOralDietTexture(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderOralDietTexture(jsn : TJsonObject) : TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('modifier') then
        result.modifier := ParseCodeableConcept(jsn.vObj['modifier']);{q}
    if jsn.has('foodType') then
        result.foodType := ParseCodeableConcept(jsn.vObj['foodType']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderOralDietTexture(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDietTexture; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'modifier', elem.modifier); {a}
  ComposeCodeableConcept(json, 'foodType', elem.foodType); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseNutritionOrderSupplement(element : IXmlDomElement; path : string) : TFhirNutritionOrderSupplement;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrderSupplement.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'productName') then
        result.productNameElement := ParseString(child, path+'/productName') {b}
      else if (child.baseName = 'scheduled') then
        result.scheduled := ParseTiming(child, path+'/scheduled') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'instruction') then
        result.instructionElement := ParseString(child, path+'/instruction') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderSupplement(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderSupplement);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeString(xml, 'productName', elem.productNameElement);{x.2}
  ComposeTiming(xml, 'scheduled', elem.scheduled);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeString(xml, 'instruction', elem.instructionElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrderSupplement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderSupplement(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderSupplement(jsn : TJsonObject) : TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('productName') or jsn.has('_productName') then
        result.productNameElement := ParseString(jsn['productName'], jsn.vObj['_productName']);{q}
    if jsn.has('scheduled') then
        result.scheduled := ParseTiming(jsn.vObj['scheduled']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('instruction') or jsn.has('_instruction') then
        result.instructionElement := ParseString(jsn['instruction'], jsn.vObj['_instruction']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderSupplement(json : TJSONWriter; name : string; elem : TFhirNutritionOrderSupplement; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeStringValue(json, 'productName', elem.productNameElement, false);
  ComposeStringProps(json, 'productName', elem.productNameElement, false);
  ComposeTiming(json, 'scheduled', elem.scheduled); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeStringValue(json, 'instruction', elem.instructionElement, false);
  ComposeStringProps(json, 'instruction', elem.instructionElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormula(element : IXmlDomElement; path : string) : TFhirNutritionOrderEnteralFormula;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'administrationInstructions') then
        result.administrationInstructionsElement := ParseString(child, path+'/administrationInstructions') {b}
      else if (child.baseName = 'baseFormulaType') then
        result.baseFormulaType := ParseCodeableConcept(child, path+'/baseFormulaType') {b}
      else if (child.baseName = 'baseFormulaProductName') then
        result.baseFormulaProductNameElement := ParseString(child, path+'/baseFormulaProductName') {b}
      else if (child.baseName = 'scheduled') then
        result.scheduled := ParseTiming(child, path+'/scheduled') {b}
      else if (child.baseName = 'additiveType') then
        result.additiveType := ParseCodeableConcept(child, path+'/additiveType') {b}
      else if (child.baseName = 'additiveProductName') then
        result.additiveProductNameElement := ParseString(child, path+'/additiveProductName') {b}
      else if (child.baseName = 'caloricDensity') then
        result.caloricDensity := ParseQuantity(child, path+'/caloricDensity') {b}
      else if (child.baseName = 'routeofAdministration') then
        result.routeofAdministration := ParseCodeableConcept(child, path+'/routeofAdministration') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'rate') then
        result.rate := ParseRatio(child, path+'/rate') {b}
      else if (child.baseName = 'rateAdjustment') then
        result.rateAdjustment := ParseQuantity(child, path+'/rateAdjustment') {b}
      else if (child.baseName = 'maxVolumeToDeliver') then
        result.maxVolumeToDeliver := ParseQuantity(child, path+'/maxVolumeToDeliver') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormula(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderEnteralFormula);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'administrationInstructions', elem.administrationInstructionsElement);{x.2}
  ComposeCodeableConcept(xml, 'baseFormulaType', elem.baseFormulaType);{x.2}
  ComposeString(xml, 'baseFormulaProductName', elem.baseFormulaProductNameElement);{x.2}
  ComposeTiming(xml, 'scheduled', elem.scheduled);{x.2}
  ComposeCodeableConcept(xml, 'additiveType', elem.additiveType);{x.2}
  ComposeString(xml, 'additiveProductName', elem.additiveProductNameElement);{x.2}
  ComposeQuantity(xml, 'caloricDensity', elem.caloricDensity);{x.2}
  ComposeCodeableConcept(xml, 'routeofAdministration', elem.routeofAdministration);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeRatio(xml, 'rate', elem.rate);{x.2}
  ComposeQuantity(xml, 'rateAdjustment', elem.rateAdjustment);{x.2}
  ComposeQuantity(xml, 'maxVolumeToDeliver', elem.maxVolumeToDeliver);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrderEnteralFormula(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderEnteralFormula(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderEnteralFormula(jsn : TJsonObject) : TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('administrationInstructions') or jsn.has('_administrationInstructions') then
        result.administrationInstructionsElement := ParseString(jsn['administrationInstructions'], jsn.vObj['_administrationInstructions']);{q}
    if jsn.has('baseFormulaType') then
        result.baseFormulaType := ParseCodeableConcept(jsn.vObj['baseFormulaType']);{q}
    if jsn.has('baseFormulaProductName') or jsn.has('_baseFormulaProductName') then
        result.baseFormulaProductNameElement := ParseString(jsn['baseFormulaProductName'], jsn.vObj['_baseFormulaProductName']);{q}
    if jsn.has('scheduled') then
        result.scheduled := ParseTiming(jsn.vObj['scheduled']);{q}
    if jsn.has('additiveType') then
        result.additiveType := ParseCodeableConcept(jsn.vObj['additiveType']);{q}
    if jsn.has('additiveProductName') or jsn.has('_additiveProductName') then
        result.additiveProductNameElement := ParseString(jsn['additiveProductName'], jsn.vObj['_additiveProductName']);{q}
    if jsn.has('caloricDensity') then
        result.caloricDensity := ParseQuantity(jsn.vObj['caloricDensity']);{q}
    if jsn.has('routeofAdministration') then
        result.routeofAdministration := ParseCodeableConcept(jsn.vObj['routeofAdministration']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('rate') then
        result.rate := ParseRatio(jsn.vObj['rate']);{q}
    if jsn.has('rateAdjustment') then
        result.rateAdjustment := ParseQuantity(jsn.vObj['rateAdjustment']);{q}
    if jsn.has('maxVolumeToDeliver') then
        result.maxVolumeToDeliver := ParseQuantity(jsn.vObj['maxVolumeToDeliver']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderEnteralFormula(json : TJSONWriter; name : string; elem : TFhirNutritionOrderEnteralFormula; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'administrationInstructions', elem.administrationInstructionsElement, false);
  ComposeStringProps(json, 'administrationInstructions', elem.administrationInstructionsElement, false);
  ComposeCodeableConcept(json, 'baseFormulaType', elem.baseFormulaType); {a}
  ComposeStringValue(json, 'baseFormulaProductName', elem.baseFormulaProductNameElement, false);
  ComposeStringProps(json, 'baseFormulaProductName', elem.baseFormulaProductNameElement, false);
  ComposeTiming(json, 'scheduled', elem.scheduled); {a}
  ComposeCodeableConcept(json, 'additiveType', elem.additiveType); {a}
  ComposeStringValue(json, 'additiveProductName', elem.additiveProductNameElement, false);
  ComposeStringProps(json, 'additiveProductName', elem.additiveProductNameElement, false);
  ComposeQuantity(json, 'caloricDensity', elem.caloricDensity); {a}
  ComposeCodeableConcept(json, 'routeofAdministration', elem.routeofAdministration); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeRatio(json, 'rate', elem.rate); {a}
  ComposeQuantity(json, 'rateAdjustment', elem.rateAdjustment); {a}
  ComposeQuantity(json, 'maxVolumeToDeliver', elem.maxVolumeToDeliver); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseNutritionOrder(element : IXmlDomElement; path : string) : TFhirNutritionOrder;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrder.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'orderer') then
        result.orderer := ParseReference{TFhirPractitioner}(child, path+'/orderer') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'dateTime') then
        result.dateTimeElement := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirNutritionOrderStatus, path+'/status', child){1a}
      else if (child.baseName = 'allergyIntolerance') then
        result.allergyIntoleranceList.Add(ParseReference{TFhirAllergyIntolerance}(child, path+'/allergyIntolerance')){y.2}
      else if (child.baseName = 'foodPreferenceModifier') then
        result.foodPreferenceModifierList.Add(ParseCodeableConcept(child, path+'/foodPreferenceModifier')){y.2}
      else if (child.baseName = 'excludeFoodModifier') then
        result.excludeFoodModifierList.Add(ParseCodeableConcept(child, path+'/excludeFoodModifier')){y.2}
      else if (child.baseName = 'oralDiet') then
        result.oralDiet := ParseNutritionOrderOralDiet(child, path+'/oralDiet') {b}
      else if (child.baseName = 'supplement') then
        result.supplementList.Add(ParseNutritionOrderSupplement(child, path+'/supplement')){y.2}
      else if (child.baseName = 'enteralFormula') then
        result.enteralFormula := ParseNutritionOrderEnteralFormula(child, path+'/enteralFormula') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrder(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrder);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'orderer', elem.orderer);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  ComposeDateTime(xml, 'dateTime', elem.dateTimeElement);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirNutritionOrderStatus);
  for i := 0 to elem.allergyIntoleranceList.Count - 1 do
    ComposeReference{TFhirAllergyIntolerance}(xml, 'allergyIntolerance', elem.allergyIntoleranceList[i]);
  for i := 0 to elem.foodPreferenceModifierList.Count - 1 do
    ComposeCodeableConcept(xml, 'foodPreferenceModifier', elem.foodPreferenceModifierList[i]);
  for i := 0 to elem.excludeFoodModifierList.Count - 1 do
    ComposeCodeableConcept(xml, 'excludeFoodModifier', elem.excludeFoodModifierList[i]);
  ComposeNutritionOrderOralDiet(xml, 'oralDiet', elem.oralDiet);{x.2}
  for i := 0 to elem.supplementList.Count - 1 do
    ComposeNutritionOrderSupplement(xml, 'supplement', elem.supplementList[i]);
  ComposeNutritionOrderEnteralFormula(xml, 'enteralFormula', elem.enteralFormula);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrder(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrder(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrder(jsn : TJsonObject) : TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('orderer') then
        result.orderer := ParseReference{TFhirPractitioner}(jsn.vObj['orderer']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeElement := ParseDateTime(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirNutritionOrderStatus);
    if jsn.has('allergyIntolerance') then
      iterateArray(jsn.vArr['allergyIntolerance'], result.allergyIntoleranceList, parseReference{TFhirAllergyIntolerance});
    if jsn.has('foodPreferenceModifier') then
      iterateArray(jsn.vArr['foodPreferenceModifier'], result.foodPreferenceModifierList, parseCodeableConcept);
    if jsn.has('excludeFoodModifier') then
      iterateArray(jsn.vArr['excludeFoodModifier'], result.excludeFoodModifierList, parseCodeableConcept);
    if jsn.has('oralDiet') then
        result.oralDiet := ParseNutritionOrderOralDiet(jsn.vObj['oralDiet']);{q}
    if jsn.has('supplement') then
      iterateArray(jsn.vArr['supplement'], result.supplementList, parseNutritionOrderSupplement);
    if jsn.has('enteralFormula') then
        result.enteralFormula := ParseNutritionOrderEnteralFormula(jsn.vObj['enteralFormula']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrder(json : TJSONWriter; name : string; elem : TFhirNutritionOrder; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeReference{TFhirPractitioner}(json, 'orderer', elem.orderer); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeDateTimeValue(json, 'dateTime', elem.dateTimeElement, false);
  ComposeDateTimeProps(json, 'dateTime', elem.dateTimeElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirNutritionOrderStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirNutritionOrderStatus, false);
  if elem.allergyIntoleranceList.Count > 0 then
  begin
    json.valueArray('allergyIntolerance');
    for i := 0 to elem.allergyIntoleranceList.Count - 1 do
      ComposeReference{TFhirAllergyIntolerance}(json, '',elem.allergyIntoleranceList[i]); {z - Reference(AllergyIntolerance)}
    json.FinishArray;
  end;
  if elem.foodPreferenceModifierList.Count > 0 then
  begin
    json.valueArray('foodPreferenceModifier');
    for i := 0 to elem.foodPreferenceModifierList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.foodPreferenceModifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.excludeFoodModifierList.Count > 0 then
  begin
    json.valueArray('excludeFoodModifier');
    for i := 0 to elem.excludeFoodModifierList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.excludeFoodModifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeNutritionOrderOralDiet(json, 'oralDiet', elem.oralDiet); {a}
  if elem.supplementList.Count > 0 then
  begin
    json.valueArray('supplement');
    for i := 0 to elem.supplementList.Count - 1 do
      ComposeNutritionOrderSupplement(json, '',elem.supplementList[i]); {z - }
    json.FinishArray;
  end;
  ComposeNutritionOrderEnteralFormula(json, 'enteralFormula', elem.enteralFormula); {a}
end;

function TFHIRXmlParser.ParseObservationReferenceRange(element : IXmlDomElement; path : string) : TFhirObservationReferenceRange;
var
  child : IXMLDOMElement;
begin
  result := TFhirObservationReferenceRange.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'low') then
        result.low := ParseQuantity(child, path+'/low') {b}
      else if (child.baseName = 'high') then
        result.high := ParseQuantity(child, path+'/high') {b}
      else if (child.baseName = 'meaning') then
        result.meaning := ParseCodeableConcept(child, path+'/meaning') {b}
      else if (child.baseName = 'age') then
        result.age := ParseRange(child, path+'/age') {b}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeObservationReferenceRange(xml : TXmlBuilder; name : string; elem : TFhirObservationReferenceRange);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeQuantity(xml, 'low', elem.low);{x.2}
  ComposeQuantity(xml, 'high', elem.high);{x.2}
  ComposeCodeableConcept(xml, 'meaning', elem.meaning);{x.2}
  ComposeRange(xml, 'age', elem.age);{x.2}
  ComposeString(xml, 'text', elem.textElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseObservationReferenceRange(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservationReferenceRange(jsn)); {2}
end;

function TFHIRJsonParser.ParseObservationReferenceRange(jsn : TJsonObject) : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('low') then
        result.low := ParseQuantity(jsn.vObj['low']);{q}
    if jsn.has('high') then
        result.high := ParseQuantity(jsn.vObj['high']);{q}
    if jsn.has('meaning') then
        result.meaning := ParseCodeableConcept(jsn.vObj['meaning']);{q}
    if jsn.has('age') then
        result.age := ParseRange(jsn.vObj['age']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeObservationReferenceRange(json : TJSONWriter; name : string; elem : TFhirObservationReferenceRange; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeQuantity(json, 'low', elem.low); {a}
  ComposeQuantity(json, 'high', elem.high); {a}
  ComposeCodeableConcept(json, 'meaning', elem.meaning); {a}
  ComposeRange(json, 'age', elem.age); {a}
  ComposeStringValue(json, 'text', elem.textElement, false);
  ComposeStringProps(json, 'text', elem.textElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseObservationRelated(element : IXmlDomElement; path : string) : TFhirObservationRelated;
var
  child : IXMLDOMElement;
begin
  result := TFhirObservationRelated.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirObservationRelationshiptypes, path+'/type', child){1a}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirObservation}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeObservationRelated(xml : TXmlBuilder; name : string; elem : TFhirObservationRelated);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirObservationRelationshiptypes);
  ComposeReference{TFhirObservation}(xml, 'target', elem.target);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseObservationRelated(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservationRelated(jsn)); {2}
end;

function TFHIRJsonParser.ParseObservationRelated(jsn : TJsonObject) : TFhirObservationRelated;
begin
  result := TFhirObservationRelated.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirObservationRelationshiptypes);
    if jsn.has('target') then
        result.target := ParseReference{TFhirObservation}(jsn.vObj['target']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeObservationRelated(json : TJSONWriter; name : string; elem : TFhirObservationRelated; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirObservationRelationshiptypes, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirObservationRelationshiptypes, false);
  ComposeReference{TFhirObservation}(json, 'target', elem.target); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseObservation(element : IXmlDomElement; path : string) : TFhirObservation;
var
  child : IXMLDOMElement;
begin
  result := TFhirObservation.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.baseName = 'valueRange') then
        result.value := ParseRange(child, path+'/valueRange'){x.3}
      else if (child.baseName = 'valueRatio') then
        result.value := ParseRatio(child, path+'/valueRatio'){x.3}
      else if (child.baseName = 'valueSampledData') then
        result.value := ParseSampledData(child, path+'/valueSampledData'){x.3}
      else if (child.baseName = 'valueAttachment') then
        result.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.baseName = 'valueTime') then
        result.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.baseName = 'valueDateTime') then
        result.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.baseName = 'valuePeriod') then
        result.value := ParsePeriod(child, path+'/valuePeriod'){x.3}
      else if (child.baseName = 'dataAbsentReason') then
        result.dataAbsentReason := ParseCodeableConcept(child, path+'/dataAbsentReason') {b}
      else if (child.baseName = 'interpretation') then
        result.interpretation := ParseCodeableConcept(child, path+'/interpretation') {b}
      else if (child.baseName = 'comments') then
        result.commentsElement := ParseString(child, path+'/comments') {b}
      else if (child.baseName = 'appliesDateTime') then
        result.applies := ParseDateTime(child, path+'/appliesDateTime'){x.3}
      else if (child.baseName = 'appliesPeriod') then
        result.applies := ParsePeriod(child, path+'/appliesPeriod'){x.3}
      else if (child.baseName = 'issued') then
        result.issuedElement := ParseInstant(child, path+'/issued') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirObservationStatus, path+'/status', child){1a}
      else if (child.baseName = 'reliability') then
        result.reliabilityElement := ParseEnum(CODES_TFhirObservationReliability, path+'/reliability', child){1a}
      else if (child.baseName = 'bodySiteCodeableConcept') then
        result.bodySite := ParseCodeableConcept(child, path+'/bodySiteCodeableConcept'){x.3}
      else if (child.baseName = 'bodySiteReference') then
        result.bodySite := ParseReference(child, path+'/bodySiteReference') {a}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'specimen') then
        result.specimen := ParseReference{TFhirSpecimen}(child, path+'/specimen') {b}
      else if (child.baseName = 'performer') then
        result.performerList.Add(ParseReference{Resource}(child, path+'/performer')){y.2}
      else if (child.baseName = 'device') then
        result.device := ParseReference{Resource}(child, path+'/device') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'referenceRange') then
        result.referenceRangeList.Add(ParseObservationReferenceRange(child, path+'/referenceRange')){y.2}
      else if (child.baseName = 'related') then
        result.relatedList.Add(ParseObservationRelated(child, path+'/related')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeObservation(xml : TXmlBuilder; name : string; elem : TFhirObservation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (elem.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value));
  ComposeCodeableConcept(xml, 'dataAbsentReason', elem.dataAbsentReason);{x.2}
  ComposeCodeableConcept(xml, 'interpretation', elem.interpretation);{x.2}
  ComposeString(xml, 'comments', elem.commentsElement);{x.2}
  if (elem.applies is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'appliesDateTime', TFhirDateTime(elem.applies))
  else if (elem.applies is TFhirPeriod) {6} then
    ComposePeriod(xml, 'appliesPeriod', TFhirPeriod(elem.applies));
  ComposeInstant(xml, 'issued', elem.issuedElement);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirObservationStatus);
  ComposeEnum(xml, 'reliability', elem.ReliabilityElement, CODES_TFhirObservationReliability);
  if (elem.bodySite is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite))
  else if (elem.bodySite is TFhirReference) {2} then
    ComposeReference(xml, 'bodySiteReference', TFhirReference(elem.bodySite));
  ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimen);{x.2}
  for i := 0 to elem.performerList.Count - 1 do
    ComposeReference{Resource}(xml, 'performer', elem.performerList[i]);
  ComposeReference{Resource}(xml, 'device', elem.device);{x.2}
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  for i := 0 to elem.referenceRangeList.Count - 1 do
    ComposeObservationReferenceRange(xml, 'referenceRange', elem.referenceRangeList[i]);
  for i := 0 to elem.relatedList.Count - 1 do
    ComposeObservationRelated(xml, 'related', elem.relatedList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseObservation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservation(jsn)); {2}
end;

function TFHIRJsonParser.ParseObservation(jsn : TJsonObject) : TFhirObservation;
begin
  result := TFhirObservation.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueRatio') {a4} then
      result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueSampledData') {a4} then
      result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valuePeriod') {a4} then
      result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('dataAbsentReason') then
        result.dataAbsentReason := ParseCodeableConcept(jsn.vObj['dataAbsentReason']);{q}
    if jsn.has('interpretation') then
        result.interpretation := ParseCodeableConcept(jsn.vObj['interpretation']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsElement := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    if jsn.has('appliesDateTime') or jsn.has('_appliesDateTime') then
      result.applies := parseDateTime(jsn['appliesDateTime'], jsn.vObj['_appliesDateTime']);
    if jsn.has('appliesPeriod') {a4} then
      result.applies := ParsePeriod(jsn.vObj['appliesPeriod']);
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := ParseInstant(jsn['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirObservationStatus);
    if jsn.has('reliability') or jsn.has('_reliability')  then
      result.reliabilityElement := parseEnum(jsn['reliability'], jsn.vObj['_reliability'], CODES_TFhirObservationReliability);
    if jsn.has('bodySiteCodeableConcept') {a4} then
      result.bodySite := ParseCodeableConcept(jsn.vObj['bodySiteCodeableConcept']);
    if jsn.has('bodySiteReference') {a3} then
      result.bodySite := ParseReference(jsn.vObj['bodySiteReference']);
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('specimen') then
        result.specimen := ParseReference{TFhirSpecimen}(jsn.vObj['specimen']);{q}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseReference{Resource});
    if jsn.has('device') then
        result.device := ParseReference{Resource}(jsn.vObj['device']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('referenceRange') then
      iterateArray(jsn.vArr['referenceRange'], result.referenceRangeList, parseObservationReferenceRange);
    if jsn.has('related') then
      iterateArray(jsn.vArr['related'], result.relatedList, parseObservationRelated);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeObservation(json : TJSONWriter; name : string; elem : TFhirObservation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) 
  else if (elem.value is TFhirRatio) then 
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value)) 
  else if (elem.value is TFhirSampledData) then 
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value)) 
  else if (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end
  else if (elem.value is TFhirPeriod) then 
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value)) ;
  ComposeCodeableConcept(json, 'dataAbsentReason', elem.dataAbsentReason); {a}
  ComposeCodeableConcept(json, 'interpretation', elem.interpretation); {a}
  ComposeStringValue(json, 'comments', elem.commentsElement, false);
  ComposeStringProps(json, 'comments', elem.commentsElement, false);
  if (elem.applies is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'appliesDateTime', TFhirDateTime(elem.applies), false);
    ComposeDateTimeProps(json, 'appliesDateTime', TFhirDateTime(elem.applies), false);
  end
  else if (elem.applies is TFhirPeriod) then 
    ComposePeriod(json, 'appliesPeriod', TFhirPeriod(elem.applies)) ;
  ComposeInstantValue(json, 'issued', elem.issuedElement, false);
  ComposeInstantProps(json, 'issued', elem.issuedElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirObservationStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirObservationStatus, false);
  ComposeEnumValue(json, 'reliability', elem.ReliabilityElement, CODES_TFhirObservationReliability, false);
  ComposeEnumProps(json, 'reliability', elem.ReliabilityElement, CODES_TFhirObservationReliability, false);
  if (elem.bodySite is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite)) 
  else if (elem.bodySite is TFhirReference) then
    ComposeReference(json, 'bodySiteReference', TFhirReference(elem.bodySite));
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeReference{TFhirSpecimen}(json, 'specimen', elem.specimen); {a}
  if elem.performerList.Count > 0 then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.performerList[i]); {z - Reference(Practitioner|Organization|Patient|RelatedPerson)}
    json.FinishArray;
  end;
  ComposeReference{Resource}(json, 'device', elem.device); {a}
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if elem.referenceRangeList.Count > 0 then
  begin
    json.valueArray('referenceRange');
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(json, '',elem.referenceRangeList[i]); {z - }
    json.FinishArray;
  end;
  if elem.relatedList.Count > 0 then
  begin
    json.valueArray('related');
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeObservationRelated(json, '',elem.relatedList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseOperationDefinitionContact(element : IXmlDomElement; path : string) : TFhirOperationDefinitionContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationDefinitionContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionContact(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationDefinitionContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinitionContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationDefinitionContact(jsn : TJsonObject) : TFhirOperationDefinitionContact;
begin
  result := TFhirOperationDefinitionContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationDefinitionContact(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseOperationDefinitionParameter(element : IXmlDomElement; path : string) : TFhirOperationDefinitionParameter;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationDefinitionParameter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseCode(child, path+'/name') {b}
      else if (child.baseName = 'use') then
        result.useElement := ParseEnum(CODES_TFhirOperationParameterUse, path+'/use', child){1a}
      else if (child.baseName = 'min') then
        result.minElement := ParseInteger(child, path+'/min') {b}
      else if (child.baseName = 'max') then
        result.maxElement := ParseString(child, path+'/max') {b}
      else if (child.baseName = 'documentation') then
        result.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'type') then
        result.type_Element := ParseCode(child, path+'/type') {b}
      else if (child.baseName = 'profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if (child.baseName = 'part') then
        result.partList.Add(ParseOperationDefinitionParameterPart(child, path+'/part')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameter(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionParameter);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'name', elem.nameElement);{x.2}
  ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirOperationParameterUse);
  ComposeInteger(xml, 'min', elem.minElement);{x.2}
  ComposeString(xml, 'max', elem.maxElement);{x.2}
  ComposeString(xml, 'documentation', elem.documentationElement);{x.2}
  ComposeCode(xml, 'type', elem.type_Element);{x.2}
  ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2}
  for i := 0 to elem.partList.Count - 1 do
    ComposeOperationDefinitionParameterPart(xml, 'part', elem.partList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationDefinitionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinitionParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationDefinitionParameter(jsn : TJsonObject) : TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseCode(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn['use'], jsn.vObj['_use'], CODES_TFhirOperationParameterUse);
    if jsn.has('min') or jsn.has('_min') then
        result.minElement := ParseInteger(jsn['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxElement := ParseString(jsn['max'], jsn.vObj['_max']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := ParseCode(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(jsn.vObj['profile']);{q}
    if jsn.has('part') then
      iterateArray(jsn.vArr['part'], result.partList, parseOperationDefinitionParameterPart);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationDefinitionParameter(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameter; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'name', elem.nameElement, false);
  ComposeCodeProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirOperationParameterUse, false);
  ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirOperationParameterUse, false);
  ComposeIntegerValue(json, 'min', elem.minElement, false);
  ComposeIntegerProps(json, 'min', elem.minElement, false);
  ComposeStringValue(json, 'max', elem.maxElement, false);
  ComposeStringProps(json, 'max', elem.maxElement, false);
  ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  ComposeCodeValue(json, 'type', elem.type_Element, false);
  ComposeCodeProps(json, 'type', elem.type_Element, false);
  ComposeReference{TFhirStructureDefinition}(json, 'profile', elem.profile); {a}
  if elem.partList.Count > 0 then
  begin
    json.valueArray('part');
    for i := 0 to elem.partList.Count - 1 do
      ComposeOperationDefinitionParameterPart(json, '',elem.partList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseOperationDefinitionParameterPart(element : IXmlDomElement; path : string) : TFhirOperationDefinitionParameterPart;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationDefinitionParameterPart.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseCode(child, path+'/name') {b}
      else if (child.baseName = 'min') then
        result.minElement := ParseUnsignedInt(child, path+'/min') {b}
      else if (child.baseName = 'max') then
        result.maxElement := ParseString(child, path+'/max') {b}
      else if (child.baseName = 'documentation') then
        result.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'type') then
        result.type_Element := ParseCode(child, path+'/type') {b}
      else if (child.baseName = 'profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameterPart(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionParameterPart);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'name', elem.nameElement);{x.2}
  ComposeUnsignedInt(xml, 'min', elem.minElement);{x.2}
  ComposeString(xml, 'max', elem.maxElement);{x.2}
  ComposeString(xml, 'documentation', elem.documentationElement);{x.2}
  ComposeCode(xml, 'type', elem.type_Element);{x.2}
  ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationDefinitionParameterPart(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinitionParameterPart(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationDefinitionParameterPart(jsn : TJsonObject) : TFhirOperationDefinitionParameterPart;
begin
  result := TFhirOperationDefinitionParameterPart.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseCode(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('min') or jsn.has('_min') then
        result.minElement := ParseUnsignedInt(jsn['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxElement := ParseString(jsn['max'], jsn.vObj['_max']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := ParseCode(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(jsn.vObj['profile']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationDefinitionParameterPart(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameterPart; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'name', elem.nameElement, false);
  ComposeCodeProps(json, 'name', elem.nameElement, false);
  ComposeUnsignedIntValue(json, 'min', elem.minElement, false);
  ComposeUnsignedIntProps(json, 'min', elem.minElement, false);
  ComposeStringValue(json, 'max', elem.maxElement, false);
  ComposeStringProps(json, 'max', elem.maxElement, false);
  ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  ComposeCodeValue(json, 'type', elem.type_Element, false);
  ComposeCodeProps(json, 'type', elem.type_Element, false);
  ComposeReference{TFhirStructureDefinition}(json, 'profile', elem.profile); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseOperationDefinition(element : IXmlDomElement; path : string) : TFhirOperationDefinition;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationDefinition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseOperationDefinitionContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'requirements') then
        result.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatus, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'kind') then
        result.kindElement := ParseEnum(CODES_TFhirOperationKind, path+'/kind', child){1a}
      else if (child.baseName = 'idempotent') then
        result.idempotentElement := ParseBoolean(child, path+'/idempotent') {b}
      else if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'notes') then
        result.notesElement := ParseString(child, path+'/notes') {b}
      else if (child.baseName = 'base') then
        result.base := ParseReference{TFhirOperationDefinition}(child, path+'/base') {b}
      else if (child.baseName = 'system') then
        result.systemElement := ParseBoolean(child, path+'/system') {b}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseCode(child, path+'/type')){y.2}
      else if (child.baseName = 'instance') then
        result.instanceElement := ParseBoolean(child, path+'/instance') {b}
      else if (child.baseName = 'parameter') then
        result.parameterList.Add(ParseOperationDefinitionParameter(child, path+'/parameter')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinition(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  ComposeString(xml, 'version', elem.versionElement);{x.2}
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  for i := 0 to elem.contactList.Count - 1 do
    ComposeOperationDefinitionContact(xml, 'contact', elem.contactList[i]);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeString(xml, 'requirements', elem.requirementsElement);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus);
  ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirOperationKind);
  ComposeBoolean(xml, 'idempotent', elem.idempotentElement);{x.2}
  ComposeCode(xml, 'code', elem.codeElement);{x.2}
  ComposeString(xml, 'notes', elem.notesElement);{x.2}
  ComposeReference{TFhirOperationDefinition}(xml, 'base', elem.base);{x.2}
  ComposeBoolean(xml, 'system', elem.systemElement);{x.2}
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCode(xml, 'type', elem.type_List[i]);
  ComposeBoolean(xml, 'instance', elem.instanceElement);{x.2}
  for i := 0 to elem.parameterList.Count - 1 do
    ComposeOperationDefinitionParameter(xml, 'parameter', elem.parameterList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationDefinition(jsn : TJsonObject) : TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseOperationDefinitionContact);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatus);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn['kind'], jsn.vObj['_kind'], CODES_TFhirOperationKind);
    if jsn.has('idempotent') or jsn.has('_idempotent') then
        result.idempotentElement := ParseBoolean(jsn['idempotent'], jsn.vObj['_idempotent']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesElement := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    if jsn.has('base') then
        result.base := ParseReference{TFhirOperationDefinition}(jsn.vObj['base']);{q}
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseBoolean(jsn['system'], jsn.vObj['_system']);{q}
      if jsn.has('type') or jsn.has('_type') then
      iteratePrimitiveArray(jsn.vArr['type'], jsn.vArr['_type'], result.type_List, parseCode);
    if jsn.has('instance') or jsn.has('_instance') then
        result.instanceElement := ParseBoolean(jsn['instance'], jsn.vObj['_instance']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseOperationDefinitionParameter);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationDefinition(json : TJSONWriter; name : string; elem : TFhirOperationDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  ComposeStringValue(json, 'version', elem.versionElement, false);
  ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if elem.contactList.Count > 0 then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOperationDefinitionContact(json, '',elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus, false);
  ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirOperationKind, false);
  ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirOperationKind, false);
  ComposeBooleanValue(json, 'idempotent', elem.idempotentElement, false);
  ComposeBooleanProps(json, 'idempotent', elem.idempotentElement, false);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  ComposeStringValue(json, 'notes', elem.notesElement, false);
  ComposeStringProps(json, 'notes', elem.notesElement, false);
  ComposeReference{TFhirOperationDefinition}(json, 'base', elem.base); {a}
  ComposeBooleanValue(json, 'system', elem.systemElement, false);
  ComposeBooleanProps(json, 'system', elem.systemElement, false);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    ext := false;
    for i := 0 to elem.type_List.Count - 1 do
    begin
      ext := ext or ((elem.type_List[i].id <> '') or (elem.type_List[i].hasExtensionList));
      ComposeCodeValue(json, '',elem.type_List[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_type');
      for i := 0 to elem.type_List.Count - 1 do
        ComposeCodeProps(json, '',elem.type_List[i], true);
      json.FinishArray;
    end;
  end;
  ComposeBooleanValue(json, 'instance', elem.instanceElement, false);
  ComposeBooleanProps(json, 'instance', elem.instanceElement, false);
  if elem.parameterList.Count > 0 then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeOperationDefinitionParameter(json, '',elem.parameterList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseOperationOutcomeIssue(element : IXmlDomElement; path : string) : TFhirOperationOutcomeIssue;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'severity') then
        result.severityElement := ParseEnum(CODES_TFhirIssueSeverity, path+'/severity', child){1a}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'details') then
        result.detailsElement := ParseString(child, path+'/details') {b}
      else if (child.baseName = 'location') then
        result.locationList.Add(ParseString(child, path+'/location')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcomeIssue(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcomeIssue);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'severity', elem.SeverityElement, CODES_TFhirIssueSeverity);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeString(xml, 'details', elem.detailsElement);{x.2}
  for i := 0 to elem.locationList.Count - 1 do
    ComposeString(xml, 'location', elem.locationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationOutcomeIssue(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationOutcomeIssue(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationOutcomeIssue(jsn : TJsonObject) : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityElement := parseEnum(jsn['severity'], jsn.vObj['_severity'], CODES_TFhirIssueSeverity);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('details') or jsn.has('_details') then
        result.detailsElement := ParseString(jsn['details'], jsn.vObj['_details']);{q}
      if jsn.has('location') or jsn.has('_location') then
      iteratePrimitiveArray(jsn.vArr['location'], jsn.vArr['_location'], result.locationList, parseString);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationOutcomeIssue(json : TJSONWriter; name : string; elem : TFhirOperationOutcomeIssue; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'severity', elem.SeverityElement, CODES_TFhirIssueSeverity, false);
  ComposeEnumProps(json, 'severity', elem.SeverityElement, CODES_TFhirIssueSeverity, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeStringValue(json, 'details', elem.detailsElement, false);
  ComposeStringProps(json, 'details', elem.detailsElement, false);
  if elem.locationList.Count > 0 then
  begin
    json.valueArray('location');
    ext := false;
    for i := 0 to elem.locationList.Count - 1 do
    begin
      ext := ext or ((elem.locationList[i].id <> '') or (elem.locationList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.locationList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_location');
      for i := 0 to elem.locationList.Count - 1 do
        ComposeStringProps(json, '',elem.locationList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseOperationOutcome(element : IXmlDomElement; path : string) : TFhirOperationOutcome;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationOutcome.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'issue') then
        result.issueList.Add(ParseOperationOutcomeIssue(child, path+'/issue')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcome(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcome);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.issueList.Count - 1 do
    ComposeOperationOutcomeIssue(xml, 'issue', elem.issueList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationOutcome(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationOutcome(jsn : TJsonObject) : TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('issue') then
      iterateArray(jsn.vArr['issue'], result.issueList, parseOperationOutcomeIssue);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationOutcome(json : TJSONWriter; name : string; elem : TFhirOperationOutcome; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.issueList.Count > 0 then
  begin
    json.valueArray('issue');
    for i := 0 to elem.issueList.Count - 1 do
      ComposeOperationOutcomeIssue(json, '',elem.issueList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseOrderWhen(element : IXmlDomElement; path : string) : TFhirOrderWhen;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrderWhen.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'schedule') then
        result.schedule := ParseTiming(child, path+'/schedule') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrderWhen(xml : TXmlBuilder; name : string; elem : TFhirOrderWhen);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposeTiming(xml, 'schedule', elem.schedule);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrderWhen(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrderWhen(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrderWhen(jsn : TJsonObject) : TFhirOrderWhen;
begin
  result := TFhirOrderWhen.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('schedule') then
        result.schedule := ParseTiming(jsn.vObj['schedule']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrderWhen(json : TJSONWriter; name : string; elem : TFhirOrderWhen; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeTiming(json, 'schedule', elem.schedule); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseOrder(element : IXmlDomElement; path : string) : TFhirOrder;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrder.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'source') then
        result.source := ParseReference{TFhirPractitioner}(child, path+'/source') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{Resource}(child, path+'/target') {b}
      else if (child.baseName = 'reasonCodeableConcept') then
        result.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.baseName = 'reasonReference') then
        result.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.baseName = 'authority') then
        result.authority := ParseReference{TFhirReference}(child, path+'/authority') {b}
      else if (child.baseName = 'when') then
        result.when := ParseOrderWhen(child, path+'/when') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseReference{TFhirReference}(child, path+'/detail')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrder(xml : TXmlBuilder; name : string; elem : TFhirOrder);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'source', elem.source);{x.2}
  ComposeReference{Resource}(xml, 'target', elem.target);{x.2}
  if (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  ComposeReference{TFhirReference}(xml, 'authority', elem.authority);{x.2}
  ComposeOrderWhen(xml, 'when', elem.when);{x.2}
  for i := 0 to elem.detailList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrder(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrder(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrder(jsn : TJsonObject) : TFhirOrder;
begin
  result := TFhirOrder.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('source') then
        result.source := ParseReference{TFhirPractitioner}(jsn.vObj['source']);{q}
    if jsn.has('target') then
        result.target := ParseReference{Resource}(jsn.vObj['target']);{q}
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('authority') then
        result.authority := ParseReference{TFhirReference}(jsn.vObj['authority']);{q}
    if jsn.has('when') then
        result.when := ParseOrderWhen(jsn.vObj['when']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrder(json : TJSONWriter; name : string; elem : TFhirOrder; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeReference{TFhirPractitioner}(json, 'source', elem.source); {a}
  ComposeReference{Resource}(json, 'target', elem.target); {a}
  if (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  ComposeReference{TFhirReference}(json, 'authority', elem.authority); {a}
  ComposeOrderWhen(json, 'when', elem.when); {a}
  if elem.detailList.Count > 0 then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.detailList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseOrderResponse(element : IXmlDomElement; path : string) : TFhirOrderResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrderResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirOrder}(child, path+'/request') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'who') then
        result.who := ParseReference{Resource}(child, path+'/who') {b}
      else if (child.baseName = 'authorityCodeableConcept') then
        result.authority := ParseCodeableConcept(child, path+'/authorityCodeableConcept'){x.3}
      else if (child.baseName = 'authorityReference') then
        result.authority := ParseReference(child, path+'/authorityReference') {a}
      else if (child.baseName = 'orderStatus') then
        result.orderStatusElement := ParseEnum(CODES_TFhirOrderStatus, path+'/orderStatus', child){1a}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'fulfillment') then
        result.fulfillmentList.Add(ParseReference{TFhirReference}(child, path+'/fulfillment')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrderResponse(xml : TXmlBuilder; name : string; elem : TFhirOrderResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirOrder}(xml, 'request', elem.request);{x.2}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeReference{Resource}(xml, 'who', elem.who);{x.2}
  if (elem.authority is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'authorityCodeableConcept', TFhirCodeableConcept(elem.authority))
  else if (elem.authority is TFhirReference) {2} then
    ComposeReference(xml, 'authorityReference', TFhirReference(elem.authority));
  ComposeEnum(xml, 'orderStatus', elem.OrderStatusElement, CODES_TFhirOrderStatus);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  for i := 0 to elem.fulfillmentList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'fulfillment', elem.fulfillmentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrderResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrderResponse(jsn : TJsonObject) : TFhirOrderResponse;
begin
  result := TFhirOrderResponse.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirOrder}(jsn.vObj['request']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('who') then
        result.who := ParseReference{Resource}(jsn.vObj['who']);{q}
    if jsn.has('authorityCodeableConcept') {a4} then
      result.authority := ParseCodeableConcept(jsn.vObj['authorityCodeableConcept']);
    if jsn.has('authorityReference') {a3} then
      result.authority := ParseReference(jsn.vObj['authorityReference']);
    if jsn.has('orderStatus') or jsn.has('_orderStatus')  then
      result.orderStatusElement := parseEnum(jsn['orderStatus'], jsn.vObj['_orderStatus'], CODES_TFhirOrderStatus);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('fulfillment') then
      iterateArray(jsn.vArr['fulfillment'], result.fulfillmentList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrderResponse(json : TJSONWriter; name : string; elem : TFhirOrderResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
    end;
  ComposeReference{TFhirOrder}(json, 'request', elem.request); {a}
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeReference{Resource}(json, 'who', elem.who); {a}
  if (elem.authority is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'authorityCodeableConcept', TFhirCodeableConcept(elem.authority)) 
  else if (elem.authority is TFhirReference) then
    ComposeReference(json, 'authorityReference', TFhirReference(elem.authority));
  ComposeEnumValue(json, 'orderStatus', elem.OrderStatusElement, CODES_TFhirOrderStatus, false);
  ComposeEnumProps(json, 'orderStatus', elem.OrderStatusElement, CODES_TFhirOrderStatus, false);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if elem.fulfillmentList.Count > 0 then
    begin
    json.valueArray('fulfillment');
    for i := 0 to elem.fulfillmentList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.fulfillmentList[i]); {z - Reference(Any)}
      json.FinishArray;
    end;
  end;

function TFHIRXmlParser.ParseOrganizationContact(element : IXmlDomElement; path : string) : TFhirOrganizationContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrganizationContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'purpose') then
        result.purpose := ParseCodeableConcept(child, path+'/purpose') {b}
      else if (child.baseName = 'name') then
        result.name := ParseHumanName(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'address') then
        result.address := ParseAddress(child, path+'/address') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrganizationContact(xml : TXmlBuilder; name : string; elem : TFhirOrganizationContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'purpose', elem.purpose);{x.2}
  ComposeHumanName(xml, 'name', elem.name);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeAddress(xml, 'address', elem.address);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrganizationContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrganizationContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrganizationContact(jsn : TJsonObject) : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('purpose') then
        result.purpose := ParseCodeableConcept(jsn.vObj['purpose']);{q}
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrganizationContact(json : TJSONWriter; name : string; elem : TFhirOrganizationContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'purpose', elem.purpose); {a}
  ComposeHumanName(json, 'name', elem.name); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeAddress(json, 'address', elem.address); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseOrganization(element : IXmlDomElement; path : string) : TFhirOrganization;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrganization.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'address') then
        result.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.baseName = 'partOf') then
        result.partOf := ParseReference{TFhirOrganization}(child, path+'/partOf') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseOrganizationContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'active') then
        result.activeElement := ParseBoolean(child, path+'/active') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrganization(xml : TXmlBuilder; name : string; elem : TFhirOrganization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  for i := 0 to elem.addressList.Count - 1 do
    ComposeAddress(xml, 'address', elem.addressList[i]);
  ComposeReference{TFhirOrganization}(xml, 'partOf', elem.partOf);{x.2}
  for i := 0 to elem.contactList.Count - 1 do
    ComposeOrganizationContact(xml, 'contact', elem.contactList[i]);
  ComposeBoolean(xml, 'active', elem.activeElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrganization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrganization(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrganization(jsn : TJsonObject) : TFhirOrganization;
begin
  result := TFhirOrganization.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('partOf') then
        result.partOf := ParseReference{TFhirOrganization}(jsn.vObj['partOf']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseOrganizationContact);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := ParseBoolean(jsn['active'], jsn.vObj['_active']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrganization(json : TJSONWriter; name : string; elem : TFhirOrganization; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if elem.addressList.Count > 0 then
    begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '',elem.addressList[i]); {z - Address}
    json.FinishArray;
    end;
  ComposeReference{TFhirOrganization}(json, 'partOf', elem.partOf); {a}
  if elem.contactList.Count > 0 then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOrganizationContact(json, '',elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  ComposeBooleanValue(json, 'active', elem.activeElement, false);
  ComposeBooleanProps(json, 'active', elem.activeElement, false);
end;

function TFHIRXmlParser.ParsePatientContact(element : IXmlDomElement; path : string) : TFhirPatientContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatientContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'relationship') then
        result.relationshipList.Add(ParseCodeableConcept(child, path+'/relationship')){y.2}
      else if (child.baseName = 'name') then
        result.name := ParseHumanName(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'address') then
        result.address := ParseAddress(child, path+'/address') {b}
      else if (child.baseName = 'gender') then
        result.genderElement := ParseEnum(CODES_TFhirAdministrativeGender, path+'/gender', child){1a}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatientContact(xml : TXmlBuilder; name : string; elem : TFhirPatientContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.relationshipList.Count - 1 do
    ComposeCodeableConcept(xml, 'relationship', elem.relationshipList[i]);
  ComposeHumanName(xml, 'name', elem.name);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeAddress(xml, 'address', elem.address);{x.2}
  ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender);
  ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatientContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientContact(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatientContact(jsn : TJsonObject) : TFhirPatientContact;
begin
  result := TFhirPatientContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('relationship') then
      iterateArray(jsn.vArr['relationship'], result.relationshipList, parseCodeableConcept);
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q}
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGender);
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatientContact(json : TJSONWriter; name : string; elem : TFhirPatientContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.relationshipList.Count > 0 then
  begin
    json.valueArray('relationship');
    for i := 0 to elem.relationshipList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.relationshipList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeHumanName(json, 'name', elem.name); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeAddress(json, 'address', elem.address); {a}
  ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender, false);
  ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender, false);
  ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParsePatientAnimal(element : IXmlDomElement; path : string) : TFhirPatientAnimal;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatientAnimal.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'species') then
        result.species := ParseCodeableConcept(child, path+'/species') {b}
      else if (child.baseName = 'breed') then
        result.breed := ParseCodeableConcept(child, path+'/breed') {b}
      else if (child.baseName = 'genderStatus') then
        result.genderStatus := ParseCodeableConcept(child, path+'/genderStatus') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatientAnimal(xml : TXmlBuilder; name : string; elem : TFhirPatientAnimal);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'species', elem.species);{x.2}
  ComposeCodeableConcept(xml, 'breed', elem.breed);{x.2}
  ComposeCodeableConcept(xml, 'genderStatus', elem.genderStatus);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatientAnimal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientAnimal(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatientAnimal(jsn : TJsonObject) : TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('species') then
        result.species := ParseCodeableConcept(jsn.vObj['species']);{q}
    if jsn.has('breed') then
        result.breed := ParseCodeableConcept(jsn.vObj['breed']);{q}
    if jsn.has('genderStatus') then
        result.genderStatus := ParseCodeableConcept(jsn.vObj['genderStatus']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatientAnimal(json : TJSONWriter; name : string; elem : TFhirPatientAnimal; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'species', elem.species); {a}
  ComposeCodeableConcept(json, 'breed', elem.breed); {a}
  ComposeCodeableConcept(json, 'genderStatus', elem.genderStatus); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParsePatientCommunication(element : IXmlDomElement; path : string) : TFhirPatientCommunication;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatientCommunication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'language') then
        result.language := ParseCodeableConcept(child, path+'/language') {b}
      else if (child.baseName = 'preferred') then
        result.preferredElement := ParseBoolean(child, path+'/preferred') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatientCommunication(xml : TXmlBuilder; name : string; elem : TFhirPatientCommunication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'language', elem.language);{x.2}
  ComposeBoolean(xml, 'preferred', elem.preferredElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatientCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientCommunication(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatientCommunication(jsn : TJsonObject) : TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('language') then
        result.language := ParseCodeableConcept(jsn.vObj['language']);{q}
    if jsn.has('preferred') or jsn.has('_preferred') then
        result.preferredElement := ParseBoolean(jsn['preferred'], jsn.vObj['_preferred']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatientCommunication(json : TJSONWriter; name : string; elem : TFhirPatientCommunication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'language', elem.language); {a}
  ComposeBooleanValue(json, 'preferred', elem.preferredElement, false);
  ComposeBooleanProps(json, 'preferred', elem.preferredElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParsePatientLink(element : IXmlDomElement; path : string) : TFhirPatientLink;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatientLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'other') then
        result.other := ParseReference{TFhirPatient}(child, path+'/other') {b}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirLinkType, path+'/type', child){1a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatientLink(xml : TXmlBuilder; name : string; elem : TFhirPatientLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirPatient}(xml, 'other', elem.other);{x.2}
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirLinkType);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatientLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientLink(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatientLink(jsn : TJsonObject) : TFhirPatientLink;
begin
  result := TFhirPatientLink.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('other') then
        result.other := ParseReference{TFhirPatient}(jsn.vObj['other']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirLinkType);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatientLink(json : TJSONWriter; name : string; elem : TFhirPatientLink; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirPatient}(json, 'other', elem.other); {a}
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirLinkType, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirLinkType, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParsePatient(element : IXmlDomElement; path : string) : TFhirPatient;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatient.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'name') then
        result.nameList.Add(ParseHumanName(child, path+'/name')){y.2}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'gender') then
        result.genderElement := ParseEnum(CODES_TFhirAdministrativeGender, path+'/gender', child){1a}
      else if (child.baseName = 'birthDate') then
        result.birthDateElement := ParseDate(child, path+'/birthDate') {b}
      else if (child.baseName = 'deceasedBoolean') then
        result.deceased := ParseBoolean(child, path+'/deceasedBoolean'){x.3}
      else if (child.baseName = 'deceasedDateTime') then
        result.deceased := ParseDateTime(child, path+'/deceasedDateTime'){x.3}
      else if (child.baseName = 'address') then
        result.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.baseName = 'maritalStatus') then
        result.maritalStatus := ParseCodeableConcept(child, path+'/maritalStatus') {b}
      else if (child.baseName = 'multipleBirthBoolean') then
        result.multipleBirth := ParseBoolean(child, path+'/multipleBirthBoolean'){x.3}
      else if (child.baseName = 'multipleBirthInteger') then
        result.multipleBirth := ParseInteger(child, path+'/multipleBirthInteger'){x.3}
      else if (child.baseName = 'photo') then
        result.photoList.Add(ParseAttachment(child, path+'/photo')){y.2}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParsePatientContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'animal') then
        result.animal := ParsePatientAnimal(child, path+'/animal') {b}
      else if (child.baseName = 'communication') then
        result.communicationList.Add(ParsePatientCommunication(child, path+'/communication')){y.2}
      else if (child.baseName = 'careProvider') then
        result.careProviderList.Add(ParseReference{Resource}(child, path+'/careProvider')){y.2}
      else if (child.baseName = 'managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.baseName = 'link') then
        result.link_List.Add(ParsePatientLink(child, path+'/link')){y.2}
      else if (child.baseName = 'active') then
        result.activeElement := ParseBoolean(child, path+'/active') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatient(xml : TXmlBuilder; name : string; elem : TFhirPatient);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  for i := 0 to elem.nameList.Count - 1 do
    ComposeHumanName(xml, 'name', elem.nameList[i]);
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender);
  ComposeDate(xml, 'birthDate', elem.birthDateElement);{x.2}
  if (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'deceasedBoolean', TFhirBoolean(elem.deceased))
  else if (elem.deceased is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'deceasedDateTime', TFhirDateTime(elem.deceased));
  for i := 0 to elem.addressList.Count - 1 do
    ComposeAddress(xml, 'address', elem.addressList[i]);
  ComposeCodeableConcept(xml, 'maritalStatus', elem.maritalStatus);{x.2}
  if (elem.multipleBirth is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth))
  else if (elem.multipleBirth is TFhirInteger) {6} then
    ComposeInteger(xml, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth));
  for i := 0 to elem.photoList.Count - 1 do
    ComposeAttachment(xml, 'photo', elem.photoList[i]);
  for i := 0 to elem.contactList.Count - 1 do
    ComposePatientContact(xml, 'contact', elem.contactList[i]);
  ComposePatientAnimal(xml, 'animal', elem.animal);{x.2}
  for i := 0 to elem.communicationList.Count - 1 do
    ComposePatientCommunication(xml, 'communication', elem.communicationList[i]);
  for i := 0 to elem.careProviderList.Count - 1 do
    ComposeReference{Resource}(xml, 'careProvider', elem.careProviderList[i]);
  ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2}
  for i := 0 to elem.link_List.Count - 1 do
    ComposePatientLink(xml, 'link', elem.link_List[i]);
  ComposeBoolean(xml, 'active', elem.activeElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatient(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatient(jsn : TJsonObject) : TFhirPatient;
begin
  result := TFhirPatient.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('name') then
      iterateArray(jsn.vArr['name'], result.nameList, parseHumanName);
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGender);
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDateElement := ParseDate(jsn['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('deceasedBoolean') or jsn.has('_deceasedBoolean') then
      result.deceased := parseBoolean(jsn['deceasedBoolean'], jsn.vObj['_deceasedBoolean']);
    if jsn.has('deceasedDateTime') or jsn.has('_deceasedDateTime') then
      result.deceased := parseDateTime(jsn['deceasedDateTime'], jsn.vObj['_deceasedDateTime']);
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('maritalStatus') then
        result.maritalStatus := ParseCodeableConcept(jsn.vObj['maritalStatus']);{q}
    if jsn.has('multipleBirthBoolean') or jsn.has('_multipleBirthBoolean') then
      result.multipleBirth := parseBoolean(jsn['multipleBirthBoolean'], jsn.vObj['_multipleBirthBoolean']);
    if jsn.has('multipleBirthInteger') or jsn.has('_multipleBirthInteger') then
      result.multipleBirth := parseInteger(jsn['multipleBirthInteger'], jsn.vObj['_multipleBirthInteger']);
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parsePatientContact);
    if jsn.has('animal') then
        result.animal := ParsePatientAnimal(jsn.vObj['animal']);{q}
    if jsn.has('communication') then
      iterateArray(jsn.vArr['communication'], result.communicationList, parsePatientCommunication);
    if jsn.has('careProvider') then
      iterateArray(jsn.vArr['careProvider'], result.careProviderList, parseReference{Resource});
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q}
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parsePatientLink);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := ParseBoolean(jsn['active'], jsn.vObj['_active']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatient(json : TJSONWriter; name : string; elem : TFhirPatient; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if elem.nameList.Count > 0 then
  begin
    json.valueArray('name');
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(json, '',elem.nameList[i]); {z - HumanName}
    json.FinishArray;
  end;
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender, false);
  ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender, false);
  ComposeDateValue(json, 'birthDate', elem.birthDateElement, false);
  ComposeDateProps(json, 'birthDate', elem.birthDateElement, false);
  if (elem.deceased is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
    ComposeBooleanProps(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
  end
  else if (elem.deceased is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'deceasedDateTime', TFhirDateTime(elem.deceased), false);
    ComposeDateTimeProps(json, 'deceasedDateTime', TFhirDateTime(elem.deceased), false);
  end;
  if elem.addressList.Count > 0 then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '',elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'maritalStatus', elem.maritalStatus); {a}
  if (elem.multipleBirth is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth), false);
    ComposeBooleanProps(json, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth), false);
  end
  else if (elem.multipleBirth is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth), false);
    ComposeIntegerProps(json, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth), false);
  end;
  if elem.photoList.Count > 0 then
  begin
    json.valueArray('photo');
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '',elem.photoList[i]); {z - Attachment}
    json.FinishArray;
  end;
  if elem.contactList.Count > 0 then
    begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposePatientContact(json, '',elem.contactList[i]); {z - }
    json.FinishArray;
    end;
  ComposePatientAnimal(json, 'animal', elem.animal); {a}
  if elem.communicationList.Count > 0 then
  begin
    json.valueArray('communication');
    for i := 0 to elem.communicationList.Count - 1 do
      ComposePatientCommunication(json, '',elem.communicationList[i]); {z - }
    json.FinishArray;
  end;
  if elem.careProviderList.Count > 0 then
    begin
    json.valueArray('careProvider');
    for i := 0 to elem.careProviderList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.careProviderList[i]); {z - Reference(Organization|Practitioner)}
      json.FinishArray;
    end;
  ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if elem.link_List.Count > 0 then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposePatientLink(json, '',elem.link_List[i]); {z - }
    json.FinishArray;
  end;
  ComposeBooleanValue(json, 'active', elem.activeElement, false);
  ComposeBooleanProps(json, 'active', elem.activeElement, false);
end;

function TFHIRXmlParser.ParsePaymentNotice(element : IXmlDomElement; path : string) : TFhirPaymentNotice;
var
  child : IXMLDOMElement;
begin
  result := TFhirPaymentNotice.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirOrganization}(child, path+'/target') {b}
      else if (child.baseName = 'provider') then
        result.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirReference}(child, path+'/request') {b}
      else if (child.baseName = 'response') then
        result.response := ParseReference{TFhirReference}(child, path+'/response') {b}
      else if (child.baseName = 'paymentStatus') then
        result.paymentStatus := ParseCoding(child, path+'/paymentStatus') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePaymentNotice(xml : TXmlBuilder; name : string; elem : TFhirPaymentNotice);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'target', elem.target);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  ComposeReference{TFhirReference}(xml, 'request', elem.request);{x.2}
  ComposeReference{TFhirReference}(xml, 'response', elem.response);{x.2}
  ComposeCoding(xml, 'paymentStatus', elem.paymentStatus);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePaymentNotice(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePaymentNotice(jsn)); {2}
end;

function TFHIRJsonParser.ParsePaymentNotice(jsn : TJsonObject) : TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirOrganization}(jsn.vObj['target']);{q}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('request') then
        result.request := ParseReference{TFhirReference}(jsn.vObj['request']);{q}
    if jsn.has('response') then
        result.response := ParseReference{TFhirReference}(jsn.vObj['response']);{q}
    if jsn.has('paymentStatus') then
        result.paymentStatus := ParseCoding(jsn.vObj['paymentStatus']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePaymentNotice(json : TJSONWriter; name : string; elem : TFhirPaymentNotice; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
      json.FinishArray;
    end;
  ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  ComposeReference{TFhirOrganization}(json, 'target', elem.target); {a}
  ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  ComposeReference{TFhirReference}(json, 'request', elem.request); {a}
  ComposeReference{TFhirReference}(json, 'response', elem.response); {a}
  ComposeCoding(json, 'paymentStatus', elem.paymentStatus); {a}
end;

function TFHIRXmlParser.ParsePaymentReconciliationDetail(element : IXmlDomElement; path : string) : TFhirPaymentReconciliationDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirReference}(child, path+'/request') {b}
      else if (child.baseName = 'responce') then
        result.responce := ParseReference{TFhirReference}(child, path+'/responce') {b}
      else if (child.baseName = 'submitter') then
        result.submitter := ParseReference{TFhirOrganization}(child, path+'/submitter') {b}
      else if (child.baseName = 'payee') then
        result.payee := ParseReference{TFhirOrganization}(child, path+'/payee') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDate(child, path+'/date') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationDetail(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliationDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'type', elem.type_);{x.2}
  ComposeReference{TFhirReference}(xml, 'request', elem.request);{x.2}
  ComposeReference{TFhirReference}(xml, 'responce', elem.responce);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'submitter', elem.submitter);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'payee', elem.payee);{x.2}
  ComposeDate(xml, 'date', elem.dateElement);{x.2}
  ComposeQuantity(xml, 'amount', elem.amount);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePaymentReconciliationDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePaymentReconciliationDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParsePaymentReconciliationDetail(jsn : TJsonObject) : TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('request') then
        result.request := ParseReference{TFhirReference}(jsn.vObj['request']);{q}
    if jsn.has('responce') then
        result.responce := ParseReference{TFhirReference}(jsn.vObj['responce']);{q}
    if jsn.has('submitter') then
        result.submitter := ParseReference{TFhirOrganization}(jsn.vObj['submitter']);{q}
    if jsn.has('payee') then
        result.payee := ParseReference{TFhirOrganization}(jsn.vObj['payee']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDate(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePaymentReconciliationDetail(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliationDetail; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeReference{TFhirReference}(json, 'request', elem.request); {a}
  ComposeReference{TFhirReference}(json, 'responce', elem.responce); {a}
  ComposeReference{TFhirOrganization}(json, 'submitter', elem.submitter); {a}
  ComposeReference{TFhirOrganization}(json, 'payee', elem.payee); {a}
  ComposeDateValue(json, 'date', elem.dateElement, false);
  ComposeDateProps(json, 'date', elem.dateElement, false);
  ComposeQuantity(json, 'amount', elem.amount); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParsePaymentReconciliationNote(element : IXmlDomElement; path : string) : TFhirPaymentReconciliationNote;
var
  child : IXMLDOMElement;
begin
  result := TFhirPaymentReconciliationNote.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationNote(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliationNote);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'type', elem.type_);{x.2}
  ComposeString(xml, 'text', elem.textElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePaymentReconciliationNote(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePaymentReconciliationNote(jsn)); {2}
end;

function TFHIRJsonParser.ParsePaymentReconciliationNote(jsn : TJsonObject) : TFhirPaymentReconciliationNote;
begin
  result := TFhirPaymentReconciliationNote.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePaymentReconciliationNote(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliationNote; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeStringValue(json, 'text', elem.textElement, false);
  ComposeStringProps(json, 'text', elem.textElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParsePaymentReconciliation(element : IXmlDomElement; path : string) : TFhirPaymentReconciliation;
var
  child : IXMLDOMElement;
begin
  result := TFhirPaymentReconciliation.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirProcessRequest}(child, path+'/request') {b}
      else if (child.baseName = 'outcome') then
        result.outcomeElement := ParseEnum(CODES_TFhirRSLink, path+'/outcome', child){1a}
      else if (child.baseName = 'disposition') then
        result.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.baseName = 'requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParsePaymentReconciliationDetail(child, path+'/detail')){y.2}
      else if (child.baseName = 'form') then
        result.form := ParseCoding(child, path+'/form') {b}
      else if (child.baseName = 'total') then
        result.total := ParseQuantity(child, path+'/total') {b}
      else if (child.baseName = 'note') then
        result.noteList.Add(ParsePaymentReconciliationNote(child, path+'/note')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliation(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirProcessRequest}(xml, 'request', elem.request);{x.2}
  ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirRSLink);
  ComposeString(xml, 'disposition', elem.dispositionElement);{x.2}
  ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  ComposePeriod(xml, 'period', elem.period);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2}
  for i := 0 to elem.detailList.Count - 1 do
    ComposePaymentReconciliationDetail(xml, 'detail', elem.detailList[i]);
  ComposeCoding(xml, 'form', elem.form);{x.2}
  ComposeQuantity(xml, 'total', elem.total);{x.2}
  for i := 0 to elem.noteList.Count - 1 do
    ComposePaymentReconciliationNote(xml, 'note', elem.noteList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePaymentReconciliation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePaymentReconciliation(jsn)); {2}
end;

function TFHIRJsonParser.ParsePaymentReconciliation(jsn : TJsonObject) : TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirProcessRequest}(jsn.vObj['request']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn['outcome'], jsn.vObj['_outcome'], CODES_TFhirRSLink);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parsePaymentReconciliationDetail);
    if jsn.has('form') then
        result.form := ParseCoding(jsn.vObj['form']);{q}
    if jsn.has('total') then
        result.total := ParseQuantity(jsn.vObj['total']);{q}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parsePaymentReconciliationNote);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePaymentReconciliation(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirProcessRequest}(json, 'request', elem.request); {a}
  ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRSLink, false);
  ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRSLink, false);
  ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
  if elem.detailList.Count > 0 then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposePaymentReconciliationDetail(json, '',elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  ComposeCoding(json, 'form', elem.form); {a}
  ComposeQuantity(json, 'total', elem.total); {a}
  if elem.noteList.Count > 0 then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposePaymentReconciliationNote(json, '',elem.noteList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParsePersonLink(element : IXmlDomElement; path : string) : TFhirPersonLink;
var
  child : IXMLDOMElement;
begin
  result := TFhirPersonLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'target') then
        result.target := ParseReference{Resource}(child, path+'/target') {b}
      else if (child.baseName = 'assurance') then
        result.assuranceElement := ParseEnum(CODES_TFhirIdentityAssuranceLevel, path+'/assurance', child){1a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePersonLink(xml : TXmlBuilder; name : string; elem : TFhirPersonLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'target', elem.target);{x.2}
  ComposeEnum(xml, 'assurance', elem.AssuranceElement, CODES_TFhirIdentityAssuranceLevel);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePersonLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePersonLink(jsn)); {2}
end;

function TFHIRJsonParser.ParsePersonLink(jsn : TJsonObject) : TFhirPersonLink;
begin
  result := TFhirPersonLink.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('target') then
        result.target := ParseReference{Resource}(jsn.vObj['target']);{q}
    if jsn.has('assurance') or jsn.has('_assurance')  then
      result.assuranceElement := parseEnum(jsn['assurance'], jsn.vObj['_assurance'], CODES_TFhirIdentityAssuranceLevel);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePersonLink(json : TJSONWriter; name : string; elem : TFhirPersonLink; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{Resource}(json, 'target', elem.target); {a}
  ComposeEnumValue(json, 'assurance', elem.AssuranceElement, CODES_TFhirIdentityAssuranceLevel, false);
  ComposeEnumProps(json, 'assurance', elem.AssuranceElement, CODES_TFhirIdentityAssuranceLevel, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParsePerson(element : IXmlDomElement; path : string) : TFhirPerson;
var
  child : IXMLDOMElement;
begin
  result := TFhirPerson.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'name') then
        result.nameList.Add(ParseHumanName(child, path+'/name')){y.2}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'gender') then
        result.genderElement := ParseEnum(CODES_TFhirAdministrativeGender, path+'/gender', child){1a}
      else if (child.baseName = 'birthDate') then
        result.birthDateElement := ParseDateTime(child, path+'/birthDate') {b}
      else if (child.baseName = 'address') then
        result.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.baseName = 'photo') then
        result.photo := ParseAttachment(child, path+'/photo') {b}
      else if (child.baseName = 'managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.baseName = 'active') then
        result.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.baseName = 'link') then
        result.link_List.Add(ParsePersonLink(child, path+'/link')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePerson(xml : TXmlBuilder; name : string; elem : TFhirPerson);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  for i := 0 to elem.nameList.Count - 1 do
    ComposeHumanName(xml, 'name', elem.nameList[i]);
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender);
  ComposeDateTime(xml, 'birthDate', elem.birthDateElement);{x.2}
  for i := 0 to elem.addressList.Count - 1 do
    ComposeAddress(xml, 'address', elem.addressList[i]);
  ComposeAttachment(xml, 'photo', elem.photo);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2}
  ComposeBoolean(xml, 'active', elem.activeElement);{x.2}
  for i := 0 to elem.link_List.Count - 1 do
    ComposePersonLink(xml, 'link', elem.link_List[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePerson(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePerson(jsn)); {2}
end;

function TFHIRJsonParser.ParsePerson(jsn : TJsonObject) : TFhirPerson;
begin
  result := TFhirPerson.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('name') then
      iterateArray(jsn.vArr['name'], result.nameList, parseHumanName);
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGender);
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDateElement := ParseDateTime(jsn['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('photo') then
        result.photo := ParseAttachment(jsn.vObj['photo']);{q}
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q}
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := ParseBoolean(jsn['active'], jsn.vObj['_active']);{q}
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parsePersonLink);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePerson(json : TJSONWriter; name : string; elem : TFhirPerson; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
    end;
  if elem.nameList.Count > 0 then
    begin
    json.valueArray('name');
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(json, '',elem.nameList[i]); {z - HumanName}
      json.FinishArray;
    end;
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender, false);
  ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender, false);
  ComposeDateTimeValue(json, 'birthDate', elem.birthDateElement, false);
  ComposeDateTimeProps(json, 'birthDate', elem.birthDateElement, false);
  if elem.addressList.Count > 0 then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '',elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  ComposeAttachment(json, 'photo', elem.photo); {a}
  ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  ComposeBooleanValue(json, 'active', elem.activeElement, false);
  ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if elem.link_List.Count > 0 then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposePersonLink(json, '',elem.link_List[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParsePractitionerPractitionerRole(element : IXmlDomElement; path : string) : TFhirPractitionerPractitionerRole;
var
  child : IXMLDOMElement;
begin
  result := TFhirPractitionerPractitionerRole.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.baseName = 'role') then
        result.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.baseName = 'specialty') then
        result.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'location') then
        result.locationList.Add(ParseReference{TFhirLocation}(child, path+'/location')){y.2}
      else if (child.baseName = 'healthcareService') then
        result.healthcareServiceList.Add(ParseReference{TFhirHealthcareService}(child, path+'/healthcareService')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePractitionerPractitionerRole(xml : TXmlBuilder; name : string; elem : TFhirPractitionerPractitionerRole);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2}
  ComposeCodeableConcept(xml, 'role', elem.role);{x.2}
  for i := 0 to elem.specialtyList.Count - 1 do
    ComposeCodeableConcept(xml, 'specialty', elem.specialtyList[i]);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  for i := 0 to elem.locationList.Count - 1 do
    ComposeReference{TFhirLocation}(xml, 'location', elem.locationList[i]);
  for i := 0 to elem.healthcareServiceList.Count - 1 do
    ComposeReference{TFhirHealthcareService}(xml, 'healthcareService', elem.healthcareServiceList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePractitionerPractitionerRole(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitionerPractitionerRole(jsn)); {2}
end;

function TFHIRJsonParser.ParsePractitionerPractitionerRole(jsn : TJsonObject) : TFhirPractitionerPractitionerRole;
begin
  result := TFhirPractitionerPractitionerRole.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q}
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q}
    if jsn.has('specialty') then
      iterateArray(jsn.vArr['specialty'], result.specialtyList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseReference{TFhirLocation});
    if jsn.has('healthcareService') then
      iterateArray(jsn.vArr['healthcareService'], result.healthcareServiceList, parseReference{TFhirHealthcareService});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePractitionerPractitionerRole(json : TJSONWriter; name : string; elem : TFhirPractitionerPractitionerRole; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  ComposeCodeableConcept(json, 'role', elem.role); {a}
  if elem.specialtyList.Count > 0 then
  begin
    json.valueArray('specialty');
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.specialtyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
  if elem.locationList.Count > 0 then
  begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '',elem.locationList[i]); {z - Reference(Location)}
    json.FinishArray;
  end;
  if elem.healthcareServiceList.Count > 0 then
  begin
    json.valueArray('healthcareService');
    for i := 0 to elem.healthcareServiceList.Count - 1 do
      ComposeReference{TFhirHealthcareService}(json, '',elem.healthcareServiceList[i]); {z - Reference(HealthcareService)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParsePractitionerQualification(element : IXmlDomElement; path : string) : TFhirPractitionerQualification;
var
  child : IXMLDOMElement;
begin
  result := TFhirPractitionerQualification.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'issuer') then
        result.issuer := ParseReference{TFhirOrganization}(child, path+'/issuer') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePractitionerQualification(xml : TXmlBuilder; name : string; elem : TFhirPractitionerQualification);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  ComposePeriod(xml, 'period', elem.period);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'issuer', elem.issuer);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePractitionerQualification(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitionerQualification(jsn)); {2}
end;

function TFHIRJsonParser.ParsePractitionerQualification(jsn : TJsonObject) : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('issuer') then
        result.issuer := ParseReference{TFhirOrganization}(jsn.vObj['issuer']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePractitionerQualification(json : TJSONWriter; name : string; elem : TFhirPractitionerQualification; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeReference{TFhirOrganization}(json, 'issuer', elem.issuer); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParsePractitioner(element : IXmlDomElement; path : string) : TFhirPractitioner;
var
  child : IXMLDOMElement;
begin
  result := TFhirPractitioner.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'name') then
        result.name := ParseHumanName(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'address') then
        result.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.baseName = 'gender') then
        result.genderElement := ParseEnum(CODES_TFhirAdministrativeGender, path+'/gender', child){1a}
      else if (child.baseName = 'birthDate') then
        result.birthDateElement := ParseDate(child, path+'/birthDate') {b}
      else if (child.baseName = 'photo') then
        result.photoList.Add(ParseAttachment(child, path+'/photo')){y.2}
      else if (child.baseName = 'practitionerRole') then
        result.practitionerRoleList.Add(ParsePractitionerPractitionerRole(child, path+'/practitionerRole')){y.2}
      else if (child.baseName = 'qualification') then
        result.qualificationList.Add(ParsePractitionerQualification(child, path+'/qualification')){y.2}
      else if (child.baseName = 'communication') then
        result.communicationList.Add(ParseCodeableConcept(child, path+'/communication')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePractitioner(xml : TXmlBuilder; name : string; elem : TFhirPractitioner);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeHumanName(xml, 'name', elem.name);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  for i := 0 to elem.addressList.Count - 1 do
    ComposeAddress(xml, 'address', elem.addressList[i]);
  ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender);
  ComposeDate(xml, 'birthDate', elem.birthDateElement);{x.2}
  for i := 0 to elem.photoList.Count - 1 do
    ComposeAttachment(xml, 'photo', elem.photoList[i]);
  for i := 0 to elem.practitionerRoleList.Count - 1 do
    ComposePractitionerPractitionerRole(xml, 'practitionerRole', elem.practitionerRoleList[i]);
  for i := 0 to elem.qualificationList.Count - 1 do
    ComposePractitionerQualification(xml, 'qualification', elem.qualificationList[i]);
  for i := 0 to elem.communicationList.Count - 1 do
    ComposeCodeableConcept(xml, 'communication', elem.communicationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePractitioner(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitioner(jsn)); {2}
end;

function TFHIRJsonParser.ParsePractitioner(jsn : TJsonObject) : TFhirPractitioner;
begin
  result := TFhirPractitioner.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGender);
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDateElement := ParseDate(jsn['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    if jsn.has('practitionerRole') then
      iterateArray(jsn.vArr['practitionerRole'], result.practitionerRoleList, parsePractitionerPractitionerRole);
    if jsn.has('qualification') then
      iterateArray(jsn.vArr['qualification'], result.qualificationList, parsePractitionerQualification);
    if jsn.has('communication') then
      iterateArray(jsn.vArr['communication'], result.communicationList, parseCodeableConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePractitioner(json : TJSONWriter; name : string; elem : TFhirPractitioner; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeHumanName(json, 'name', elem.name); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if elem.addressList.Count > 0 then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '',elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender, false);
  ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender, false);
  ComposeDateValue(json, 'birthDate', elem.birthDateElement, false);
  ComposeDateProps(json, 'birthDate', elem.birthDateElement, false);
  if elem.photoList.Count > 0 then
  begin
    json.valueArray('photo');
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '',elem.photoList[i]); {z - Attachment}
    json.FinishArray;
  end;
  if elem.practitionerRoleList.Count > 0 then
  begin
    json.valueArray('practitionerRole');
    for i := 0 to elem.practitionerRoleList.Count - 1 do
      ComposePractitionerPractitionerRole(json, '',elem.practitionerRoleList[i]); {z - }
    json.FinishArray;
  end;
  if elem.qualificationList.Count > 0 then
  begin
    json.valueArray('qualification');
    for i := 0 to elem.qualificationList.Count - 1 do
      ComposePractitionerQualification(json, '',elem.qualificationList[i]); {z - }
    json.FinishArray;
  end;
  if elem.communicationList.Count > 0 then
  begin
    json.valueArray('communication');
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.communicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseProcedureBodySite(element : IXmlDomElement; path : string) : TFhirProcedureBodySite;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcedureBodySite.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'siteCodeableConcept') then
        result.site := ParseCodeableConcept(child, path+'/siteCodeableConcept'){x.3}
      else if (child.baseName = 'siteReference') then
        result.site := ParseReference(child, path+'/siteReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcedureBodySite(xml : TXmlBuilder; name : string; elem : TFhirProcedureBodySite);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'siteCodeableConcept', TFhirCodeableConcept(elem.site))
  else if (elem.site is TFhirReference) {2} then
    ComposeReference(xml, 'siteReference', TFhirReference(elem.site));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcedureBodySite(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedureBodySite(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedureBodySite(jsn : TJsonObject) : TFhirProcedureBodySite;
begin
  result := TFhirProcedureBodySite.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('siteCodeableConcept') {a4} then
      result.site := ParseCodeableConcept(jsn.vObj['siteCodeableConcept']);
    if jsn.has('siteReference') {a3} then
      result.site := ParseReference(jsn.vObj['siteReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcedureBodySite(json : TJSONWriter; name : string; elem : TFhirProcedureBodySite; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.site is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'siteCodeableConcept', TFhirCodeableConcept(elem.site)) 
  else if (elem.site is TFhirReference) then
    ComposeReference(json, 'siteReference', TFhirReference(elem.site));
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseProcedurePerformer(element : IXmlDomElement; path : string) : TFhirProcedurePerformer;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcedurePerformer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'person') then
        result.person := ParseReference{Resource}(child, path+'/person') {b}
      else if (child.baseName = 'role') then
        result.role := ParseCodeableConcept(child, path+'/role') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcedurePerformer(xml : TXmlBuilder; name : string; elem : TFhirProcedurePerformer);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'person', elem.person);{x.2}
  ComposeCodeableConcept(xml, 'role', elem.role);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcedurePerformer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedurePerformer(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedurePerformer(jsn : TJsonObject) : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('person') then
        result.person := ParseReference{Resource}(jsn.vObj['person']);{q}
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcedurePerformer(json : TJSONWriter; name : string; elem : TFhirProcedurePerformer; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{Resource}(json, 'person', elem.person); {a}
  ComposeCodeableConcept(json, 'role', elem.role); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseProcedureRelatedItem(element : IXmlDomElement; path : string) : TFhirProcedureRelatedItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcedureRelatedItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirProcedureRelationshipType, path+'/type', child){1a}
      else if (child.baseName = 'target') then
        result.target := ParseReference{Resource}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcedureRelatedItem(xml : TXmlBuilder; name : string; elem : TFhirProcedureRelatedItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirProcedureRelationshipType);
  ComposeReference{Resource}(xml, 'target', elem.target);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcedureRelatedItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedureRelatedItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedureRelatedItem(jsn : TJsonObject) : TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirProcedureRelationshipType);
    if jsn.has('target') then
        result.target := ParseReference{Resource}(jsn.vObj['target']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcedureRelatedItem(json : TJSONWriter; name : string; elem : TFhirProcedureRelatedItem; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirProcedureRelationshipType, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirProcedureRelationshipType, false);
  ComposeReference{Resource}(json, 'target', elem.target); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseProcedureDevice(element : IXmlDomElement; path : string) : TFhirProcedureDevice;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcedureDevice.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'action') then
        result.action := ParseCodeableConcept(child, path+'/action') {b}
      else if (child.baseName = 'manipulated') then
        result.manipulated := ParseReference{TFhirDevice}(child, path+'/manipulated') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcedureDevice(xml : TXmlBuilder; name : string; elem : TFhirProcedureDevice);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'action', elem.action);{x.2}
  ComposeReference{TFhirDevice}(xml, 'manipulated', elem.manipulated);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcedureDevice(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedureDevice(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedureDevice(jsn : TJsonObject) : TFhirProcedureDevice;
begin
  result := TFhirProcedureDevice.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('action') then
        result.action := ParseCodeableConcept(jsn.vObj['action']);{q}
    if jsn.has('manipulated') then
        result.manipulated := ParseReference{TFhirDevice}(jsn.vObj['manipulated']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcedureDevice(json : TJSONWriter; name : string; elem : TFhirProcedureDevice; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'action', elem.action); {a}
  ComposeReference{TFhirDevice}(json, 'manipulated', elem.manipulated); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseProcedure(element : IXmlDomElement; path : string) : TFhirProcedure;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcedure.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirProcedureStatus, path+'/status', child){1a}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'bodySite') then
        result.bodySiteList.Add(ParseProcedureBodySite(child, path+'/bodySite')){y.2}
      else if (child.baseName = 'indication') then
        result.indicationList.Add(ParseCodeableConcept(child, path+'/indication')){y.2}
      else if (child.baseName = 'performer') then
        result.performerList.Add(ParseProcedurePerformer(child, path+'/performer')){y.2}
      else if (child.baseName = 'performedDateTime') then
        result.performed := ParseDateTime(child, path+'/performedDateTime'){x.3}
      else if (child.baseName = 'performedPeriod') then
        result.performed := ParsePeriod(child, path+'/performedPeriod'){x.3}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'outcome') then
        result.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.baseName = 'report') then
        result.reportList.Add(ParseReference{TFhirDiagnosticReport}(child, path+'/report')){y.2}
      else if (child.baseName = 'complication') then
        result.complicationList.Add(ParseCodeableConcept(child, path+'/complication')){y.2}
      else if (child.baseName = 'followUp') then
        result.followUpList.Add(ParseCodeableConcept(child, path+'/followUp')){y.2}
      else if (child.baseName = 'relatedItem') then
        result.relatedItemList.Add(ParseProcedureRelatedItem(child, path+'/relatedItem')){y.2}
      else if (child.baseName = 'notes') then
        result.notesElement := ParseString(child, path+'/notes') {b}
      else if (child.baseName = 'device') then
        result.deviceList.Add(ParseProcedureDevice(child, path+'/device')){y.2}
      else if (child.baseName = 'used') then
        result.usedList.Add(ParseReference{Resource}(child, path+'/used')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcedure(xml : TXmlBuilder; name : string; elem : TFhirProcedure);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirProcedureStatus);
  ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  for i := 0 to elem.bodySiteList.Count - 1 do
    ComposeProcedureBodySite(xml, 'bodySite', elem.bodySiteList[i]);
  for i := 0 to elem.indicationList.Count - 1 do
    ComposeCodeableConcept(xml, 'indication', elem.indicationList[i]);
  for i := 0 to elem.performerList.Count - 1 do
    ComposeProcedurePerformer(xml, 'performer', elem.performerList[i]);
  if (elem.performed is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'performedDateTime', TFhirDateTime(elem.performed))
  else if (elem.performed is TFhirPeriod) {6} then
    ComposePeriod(xml, 'performedPeriod', TFhirPeriod(elem.performed));
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2}
  for i := 0 to elem.reportList.Count - 1 do
    ComposeReference{TFhirDiagnosticReport}(xml, 'report', elem.reportList[i]);
  for i := 0 to elem.complicationList.Count - 1 do
    ComposeCodeableConcept(xml, 'complication', elem.complicationList[i]);
  for i := 0 to elem.followUpList.Count - 1 do
    ComposeCodeableConcept(xml, 'followUp', elem.followUpList[i]);
  for i := 0 to elem.relatedItemList.Count - 1 do
    ComposeProcedureRelatedItem(xml, 'relatedItem', elem.relatedItemList[i]);
  ComposeString(xml, 'notes', elem.notesElement);{x.2}
  for i := 0 to elem.deviceList.Count - 1 do
    ComposeProcedureDevice(xml, 'device', elem.deviceList[i]);
  for i := 0 to elem.usedList.Count - 1 do
    ComposeReference{Resource}(xml, 'used', elem.usedList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedure(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedure(jsn : TJsonObject) : TFhirProcedure;
begin
  result := TFhirProcedure.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirProcedureStatus);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('bodySite') then
      iterateArray(jsn.vArr['bodySite'], result.bodySiteList, parseProcedureBodySite);
    if jsn.has('indication') then
      iterateArray(jsn.vArr['indication'], result.indicationList, parseCodeableConcept);
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseProcedurePerformer);
    if jsn.has('performedDateTime') or jsn.has('_performedDateTime') then
      result.performed := parseDateTime(jsn['performedDateTime'], jsn.vObj['_performedDateTime']);
    if jsn.has('performedPeriod') {a4} then
      result.performed := ParsePeriod(jsn.vObj['performedPeriod']);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('outcome') then
        result.outcome := ParseCodeableConcept(jsn.vObj['outcome']);{q}
    if jsn.has('report') then
      iterateArray(jsn.vArr['report'], result.reportList, parseReference{TFhirDiagnosticReport});
    if jsn.has('complication') then
      iterateArray(jsn.vArr['complication'], result.complicationList, parseCodeableConcept);
    if jsn.has('followUp') then
      iterateArray(jsn.vArr['followUp'], result.followUpList, parseCodeableConcept);
    if jsn.has('relatedItem') then
      iterateArray(jsn.vArr['relatedItem'], result.relatedItemList, parseProcedureRelatedItem);
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesElement := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    if jsn.has('device') then
      iterateArray(jsn.vArr['device'], result.deviceList, parseProcedureDevice);
    if jsn.has('used') then
      iterateArray(jsn.vArr['used'], result.usedList, parseReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcedure(json : TJSONWriter; name : string; elem : TFhirProcedure; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirProcedureStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirProcedureStatus, false);
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.bodySiteList.Count > 0 then
  begin
    json.valueArray('bodySite');
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeProcedureBodySite(json, '',elem.bodySiteList[i]); {z - }
    json.FinishArray;
  end;
  if elem.indicationList.Count > 0 then
  begin
    json.valueArray('indication');
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.indicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.performerList.Count > 0 then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeProcedurePerformer(json, '',elem.performerList[i]); {z - }
    json.FinishArray;
  end;
  if (elem.performed is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'performedDateTime', TFhirDateTime(elem.performed), false);
    ComposeDateTimeProps(json, 'performedDateTime', TFhirDateTime(elem.performed), false);
  end
  else if (elem.performed is TFhirPeriod) then 
    ComposePeriod(json, 'performedPeriod', TFhirPeriod(elem.performed)) ;
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  ComposeCodeableConcept(json, 'outcome', elem.outcome); {a}
  if elem.reportList.Count > 0 then
  begin
    json.valueArray('report');
    for i := 0 to elem.reportList.Count - 1 do
      ComposeReference{TFhirDiagnosticReport}(json, '',elem.reportList[i]); {z - Reference(DiagnosticReport)}
    json.FinishArray;
  end;
  if elem.complicationList.Count > 0 then
  begin
    json.valueArray('complication');
    for i := 0 to elem.complicationList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.complicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.followUpList.Count > 0 then
  begin
    json.valueArray('followUp');
    for i := 0 to elem.followUpList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.followUpList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.relatedItemList.Count > 0 then
  begin
    json.valueArray('relatedItem');
    for i := 0 to elem.relatedItemList.Count - 1 do
      ComposeProcedureRelatedItem(json, '',elem.relatedItemList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'notes', elem.notesElement, false);
  ComposeStringProps(json, 'notes', elem.notesElement, false);
  if elem.deviceList.Count > 0 then
  begin
    json.valueArray('device');
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeProcedureDevice(json, '',elem.deviceList[i]); {z - }
    json.FinishArray;
  end;
  if elem.usedList.Count > 0 then
  begin
    json.valueArray('used');
    for i := 0 to elem.usedList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.usedList[i]); {z - Reference(Device|Medication|Substance)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseProcedureRequestBodySite(element : IXmlDomElement; path : string) : TFhirProcedureRequestBodySite;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcedureRequestBodySite.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'siteCodeableConcept') then
        result.site := ParseCodeableConcept(child, path+'/siteCodeableConcept'){x.3}
      else if (child.baseName = 'siteReference') then
        result.site := ParseReference(child, path+'/siteReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcedureRequestBodySite(xml : TXmlBuilder; name : string; elem : TFhirProcedureRequestBodySite);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'siteCodeableConcept', TFhirCodeableConcept(elem.site))
  else if (elem.site is TFhirReference) {2} then
    ComposeReference(xml, 'siteReference', TFhirReference(elem.site));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcedureRequestBodySite(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedureRequestBodySite(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedureRequestBodySite(jsn : TJsonObject) : TFhirProcedureRequestBodySite;
begin
  result := TFhirProcedureRequestBodySite.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('siteCodeableConcept') {a4} then
      result.site := ParseCodeableConcept(jsn.vObj['siteCodeableConcept']);
    if jsn.has('siteReference') {a3} then
      result.site := ParseReference(jsn.vObj['siteReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcedureRequestBodySite(json : TJSONWriter; name : string; elem : TFhirProcedureRequestBodySite; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.site is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'siteCodeableConcept', TFhirCodeableConcept(elem.site)) 
  else if (elem.site is TFhirReference) then
    ComposeReference(json, 'siteReference', TFhirReference(elem.site));
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseProcedureRequest(element : IXmlDomElement; path : string) : TFhirProcedureRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcedureRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'bodySite') then
        result.bodySiteList.Add(ParseProcedureRequestBodySite(child, path+'/bodySite')){y.2}
      else if (child.baseName = 'indication') then
        result.indicationList.Add(ParseCodeableConcept(child, path+'/indication')){y.2}
      else if (child.baseName = 'timingDateTime') then
        result.timing := ParseDateTime(child, path+'/timingDateTime'){x.3}
      else if (child.baseName = 'timingPeriod') then
        result.timing := ParsePeriod(child, path+'/timingPeriod'){x.3}
      else if (child.baseName = 'timingTiming') then
        result.timing := ParseTiming(child, path+'/timingTiming'){x.3}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'performer') then
        result.performer := ParseReference{Resource}(child, path+'/performer') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirProcedureRequestStatus, path+'/status', child){1a}
      else if (child.baseName = 'notes') then
        result.notesList.Add(ParseString(child, path+'/notes')){y.2}
      else if (child.baseName = 'asNeededBoolean') then
        result.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.baseName = 'asNeededCodeableConcept') then
        result.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.baseName = 'orderedOn') then
        result.orderedOnElement := ParseDateTime(child, path+'/orderedOn') {b}
      else if (child.baseName = 'orderer') then
        result.orderer := ParseReference{Resource}(child, path+'/orderer') {b}
      else if (child.baseName = 'priority') then
        result.priorityElement := ParseEnum(CODES_TFhirProcedureRequestPriority, path+'/priority', child){1a}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcedureRequest(xml : TXmlBuilder; name : string; elem : TFhirProcedureRequest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  for i := 0 to elem.bodySiteList.Count - 1 do
    ComposeProcedureRequestBodySite(xml, 'bodySite', elem.bodySiteList[i]);
  for i := 0 to elem.indicationList.Count - 1 do
    ComposeCodeableConcept(xml, 'indication', elem.indicationList[i]);
  if (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(elem.timing))
  else if (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing))
  else if (elem.timing is TFhirTiming) {6} then
    ComposeTiming(xml, 'timingTiming', TFhirTiming(elem.timing));
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  ComposeReference{Resource}(xml, 'performer', elem.performer);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirProcedureRequestStatus);
  for i := 0 to elem.notesList.Count - 1 do
    ComposeString(xml, 'notes', elem.notesList[i]);
  if (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded))
  else if (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded));
  ComposeDateTime(xml, 'orderedOn', elem.orderedOnElement);{x.2}
  ComposeReference{Resource}(xml, 'orderer', elem.orderer);{x.2}
  ComposeEnum(xml, 'priority', elem.PriorityElement, CODES_TFhirProcedureRequestPriority);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcedureRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedureRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedureRequest(jsn : TJsonObject) : TFhirProcedureRequest;
begin
  result := TFhirProcedureRequest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('bodySite') then
      iterateArray(jsn.vArr['bodySite'], result.bodySiteList, parseProcedureRequestBodySite);
    if jsn.has('indication') then
      iterateArray(jsn.vArr['indication'], result.indicationList, parseCodeableConcept);
    if jsn.has('timingDateTime') or jsn.has('_timingDateTime') then
      result.timing := parseDateTime(jsn['timingDateTime'], jsn.vObj['_timingDateTime']);
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('timingTiming') {a4} then
      result.timing := ParseTiming(jsn.vObj['timingTiming']);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('performer') then
        result.performer := ParseReference{Resource}(jsn.vObj['performer']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirProcedureRequestStatus);
      if jsn.has('notes') or jsn.has('_notes') then
      iteratePrimitiveArray(jsn.vArr['notes'], jsn.vArr['_notes'], result.notesList, parseString);
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('orderedOn') or jsn.has('_orderedOn') then
        result.orderedOnElement := ParseDateTime(jsn['orderedOn'], jsn.vObj['_orderedOn']);{q}
    if jsn.has('orderer') then
        result.orderer := ParseReference{Resource}(jsn.vObj['orderer']);{q}
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn['priority'], jsn.vObj['_priority'], CODES_TFhirProcedureRequestPriority);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcedureRequest(json : TJSONWriter; name : string; elem : TFhirProcedureRequest; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.bodySiteList.Count > 0 then
  begin
    json.valueArray('bodySite');
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeProcedureRequestBodySite(json, '',elem.bodySiteList[i]); {z - }
    json.FinishArray;
  end;
  if elem.indicationList.Count > 0 then
  begin
    json.valueArray('indication');
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.indicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (elem.timing is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
    ComposeDateTimeProps(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
  end
  else if (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) 
  else if (elem.timing is TFhirTiming) then 
    ComposeTiming(json, 'timingTiming', TFhirTiming(elem.timing)) ;
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeReference{Resource}(json, 'performer', elem.performer); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirProcedureRequestStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirProcedureRequestStatus, false);
  if elem.notesList.Count > 0 then
  begin
    json.valueArray('notes');
    ext := false;
    for i := 0 to elem.notesList.Count - 1 do
    begin
      ext := ext or ((elem.notesList[i].id <> '') or (elem.notesList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.notesList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_notes');
      for i := 0 to elem.notesList.Count - 1 do
        ComposeStringProps(json, '',elem.notesList[i], true);
      json.FinishArray;
    end;
  end;
  if (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end
  else if (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) ;
  ComposeDateTimeValue(json, 'orderedOn', elem.orderedOnElement, false);
  ComposeDateTimeProps(json, 'orderedOn', elem.orderedOnElement, false);
  ComposeReference{Resource}(json, 'orderer', elem.orderer); {a}
  ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirProcedureRequestPriority, false);
  ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirProcedureRequestPriority, false);
end;

function TFHIRXmlParser.ParseProcessRequestItem(element : IXmlDomElement; path : string) : TFhirProcessRequestItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcessRequestItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequenceLinkId') then
        result.sequenceLinkIdElement := ParseInteger(child, path+'/sequenceLinkId') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcessRequestItem(xml : TXmlBuilder; name : string; elem : TFhirProcessRequestItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeInteger(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcessRequestItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcessRequestItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcessRequestItem(jsn : TJsonObject) : TFhirProcessRequestItem;
begin
  result := TFhirProcessRequestItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
        result.sequenceLinkIdElement := ParseInteger(jsn['sequenceLinkId'], jsn.vObj['_sequenceLinkId']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcessRequestItem(json : TJSONWriter; name : string; elem : TFhirProcessRequestItem; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIntegerValue(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  ComposeIntegerProps(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseProcessRequest(element : IXmlDomElement; path : string) : TFhirProcessRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcessRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'action') then
        result.actionElement := ParseEnum(CODES_TFhirActionlist, path+'/action', child){1a}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirOrganization}(child, path+'/target') {b}
      else if (child.baseName = 'provider') then
        result.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirReference}(child, path+'/request') {b}
      else if (child.baseName = 'response') then
        result.response := ParseReference{TFhirReference}(child, path+'/response') {b}
      else if (child.baseName = 'nullify') then
        result.nullifyElement := ParseBoolean(child, path+'/nullify') {b}
      else if (child.baseName = 'reference') then
        result.referenceElement := ParseString(child, path+'/reference') {b}
      else if (child.baseName = 'item') then
        result.itemList.Add(ParseProcessRequestItem(child, path+'/item')){y.2}
      else if (child.baseName = 'include') then
        result.includeList.Add(ParseString(child, path+'/include')){y.2}
      else if (child.baseName = 'exclude') then
        result.excludeList.Add(ParseString(child, path+'/exclude')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcessRequest(xml : TXmlBuilder; name : string; elem : TFhirProcessRequest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeEnum(xml, 'action', elem.ActionElement, CODES_TFhirActionlist);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'target', elem.target);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  ComposeReference{TFhirReference}(xml, 'request', elem.request);{x.2}
  ComposeReference{TFhirReference}(xml, 'response', elem.response);{x.2}
  ComposeBoolean(xml, 'nullify', elem.nullifyElement);{x.2}
  ComposeString(xml, 'reference', elem.referenceElement);{x.2}
  for i := 0 to elem.itemList.Count - 1 do
    ComposeProcessRequestItem(xml, 'item', elem.itemList[i]);
  for i := 0 to elem.includeList.Count - 1 do
    ComposeString(xml, 'include', elem.includeList[i]);
  for i := 0 to elem.excludeList.Count - 1 do
    ComposeString(xml, 'exclude', elem.excludeList[i]);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcessRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcessRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcessRequest(jsn : TJsonObject) : TFhirProcessRequest;
begin
  result := TFhirProcessRequest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('action') or jsn.has('_action')  then
      result.actionElement := parseEnum(jsn['action'], jsn.vObj['_action'], CODES_TFhirActionlist);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirOrganization}(jsn.vObj['target']);{q}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('request') then
        result.request := ParseReference{TFhirReference}(jsn.vObj['request']);{q}
    if jsn.has('response') then
        result.response := ParseReference{TFhirReference}(jsn.vObj['response']);{q}
    if jsn.has('nullify') or jsn.has('_nullify') then
        result.nullifyElement := ParseBoolean(jsn['nullify'], jsn.vObj['_nullify']);{q}
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceElement := ParseString(jsn['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseProcessRequestItem);
      if jsn.has('include') or jsn.has('_include') then
      iteratePrimitiveArray(jsn.vArr['include'], jsn.vArr['_include'], result.includeList, parseString);
      if jsn.has('exclude') or jsn.has('_exclude') then
      iteratePrimitiveArray(jsn.vArr['exclude'], jsn.vArr['_exclude'], result.excludeList, parseString);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcessRequest(json : TJSONWriter; name : string; elem : TFhirProcessRequest; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeEnumValue(json, 'action', elem.ActionElement, CODES_TFhirActionlist, false);
  ComposeEnumProps(json, 'action', elem.ActionElement, CODES_TFhirActionlist, false);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  ComposeReference{TFhirOrganization}(json, 'target', elem.target); {a}
  ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  ComposeReference{TFhirReference}(json, 'request', elem.request); {a}
  ComposeReference{TFhirReference}(json, 'response', elem.response); {a}
  ComposeBooleanValue(json, 'nullify', elem.nullifyElement, false);
  ComposeBooleanProps(json, 'nullify', elem.nullifyElement, false);
  ComposeStringValue(json, 'reference', elem.referenceElement, false);
  ComposeStringProps(json, 'reference', elem.referenceElement, false);
  if elem.itemList.Count > 0 then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeProcessRequestItem(json, '',elem.itemList[i]); {z - }
    json.FinishArray;
  end;
  if elem.includeList.Count > 0 then
begin
    json.valueArray('include');
    ext := false;
    for i := 0 to elem.includeList.Count - 1 do
    begin
      ext := ext or ((elem.includeList[i].id <> '') or (elem.includeList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.includeList[i], true);
  end;
    json.FinishArray;
    if ext then
  begin
      json.valueArray('_include');
      for i := 0 to elem.includeList.Count - 1 do
        ComposeStringProps(json, '',elem.includeList[i], true);
    json.FinishArray;
  end;
end;
  if elem.excludeList.Count > 0 then
begin
    json.valueArray('exclude');
    ext := false;
    for i := 0 to elem.excludeList.Count - 1 do
    begin
      ext := ext or ((elem.excludeList[i].id <> '') or (elem.excludeList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.excludeList[i], true);
end;
    json.FinishArray;
    if ext then
  begin
      json.valueArray('_exclude');
      for i := 0 to elem.excludeList.Count - 1 do
        ComposeStringProps(json, '',elem.excludeList[i], true);
    json.FinishArray;
  end;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
end;

function TFHIRXmlParser.ParseProcessResponseNotes(element : IXmlDomElement; path : string) : TFhirProcessResponseNotes;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcessResponseNotes.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcessResponseNotes(xml : TXmlBuilder; name : string; elem : TFhirProcessResponseNotes);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'type', elem.type_);{x.2}
  ComposeString(xml, 'text', elem.textElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcessResponseNotes(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcessResponseNotes(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcessResponseNotes(jsn : TJsonObject) : TFhirProcessResponseNotes;
begin
  result := TFhirProcessResponseNotes.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcessResponseNotes(json : TJSONWriter; name : string; elem : TFhirProcessResponseNotes; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeStringValue(json, 'text', elem.textElement, false);
  ComposeStringProps(json, 'text', elem.textElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseProcessResponse(element : IXmlDomElement; path : string) : TFhirProcessResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcessResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirReference}(child, path+'/request') {b}
      else if (child.baseName = 'outcome') then
        result.outcome := ParseCoding(child, path+'/outcome') {b}
      else if (child.baseName = 'disposition') then
        result.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.baseName = 'requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if (child.baseName = 'form') then
        result.form := ParseCoding(child, path+'/form') {b}
      else if (child.baseName = 'notes') then
        result.notesList.Add(ParseProcessResponseNotes(child, path+'/notes')){y.2}
      else if (child.baseName = 'error') then
        result.errorList.Add(ParseCoding(child, path+'/error')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcessResponse(xml : TXmlBuilder; name : string; elem : TFhirProcessResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirReference}(xml, 'request', elem.request);{x.2}
  ComposeCoding(xml, 'outcome', elem.outcome);{x.2}
  ComposeString(xml, 'disposition', elem.dispositionElement);{x.2}
  ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2}
  ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2}
  ComposeCoding(xml, 'form', elem.form);{x.2}
  for i := 0 to elem.notesList.Count - 1 do
    ComposeProcessResponseNotes(xml, 'notes', elem.notesList[i]);
  for i := 0 to elem.errorList.Count - 1 do
    ComposeCoding(xml, 'error', elem.errorList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcessResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcessResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcessResponse(jsn : TJsonObject) : TFhirProcessResponse;
begin
  result := TFhirProcessResponse.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirReference}(jsn.vObj['request']);{q}
    if jsn.has('outcome') then
        result.outcome := ParseCoding(jsn.vObj['outcome']);{q}
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q}
    if jsn.has('form') then
        result.form := ParseCoding(jsn.vObj['form']);{q}
    if jsn.has('notes') then
      iterateArray(jsn.vArr['notes'], result.notesList, parseProcessResponseNotes);
    if jsn.has('error') then
      iterateArray(jsn.vArr['error'], result.errorList, parseCoding);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcessResponse(json : TJSONWriter; name : string; elem : TFhirProcessResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirReference}(json, 'request', elem.request); {a}
  ComposeCoding(json, 'outcome', elem.outcome); {a}
  ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
  ComposeCoding(json, 'form', elem.form); {a}
  if elem.notesList.Count > 0 then
  begin
    json.valueArray('notes');
    for i := 0 to elem.notesList.Count - 1 do
      ComposeProcessResponseNotes(json, '',elem.notesList[i]); {z - }
    json.FinishArray;
  end;
  if elem.errorList.Count > 0 then
  begin
    json.valueArray('error');
    for i := 0 to elem.errorList.Count - 1 do
      ComposeCoding(json, '',elem.errorList[i]); {z - Coding}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseProvenanceAgent(element : IXmlDomElement; path : string) : TFhirProvenanceAgent;
var
  child : IXMLDOMElement;
begin
  result := TFhirProvenanceAgent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'role') then
        result.role := ParseCoding(child, path+'/role') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'referenceUri') then
        result.reference := ParseUri(child, path+'/referenceUri'){x.3}
      else if (child.baseName = 'referenceReference') then
        result.reference := ParseReference(child, path+'/referenceReference') {a}
      else if (child.baseName = 'display') then
        result.displayElement := ParseString(child, path+'/display') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProvenanceAgent(xml : TXmlBuilder; name : string; elem : TFhirProvenanceAgent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'role', elem.role);{x.2}
  ComposeCoding(xml, 'type', elem.type_);{x.2}
  if (elem.reference is TFhirUri) {6} then
    ComposeUri(xml, 'referenceUri', TFhirUri(elem.reference))
  else if (elem.reference is TFhirReference) {2} then
    ComposeReference(xml, 'referenceReference', TFhirReference(elem.reference));
  ComposeString(xml, 'display', elem.displayElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProvenanceAgent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenanceAgent(jsn)); {2}
end;

function TFHIRJsonParser.ParseProvenanceAgent(jsn : TJsonObject) : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
        result.role := ParseCoding(jsn.vObj['role']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('referenceUri') or jsn.has('_referenceUri') then
      result.reference := parseUri(jsn['referenceUri'], jsn.vObj['_referenceUri']);
    if jsn.has('referenceReference') {a3} then
      result.reference := ParseReference(jsn.vObj['referenceReference']);
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProvenanceAgent(json : TJSONWriter; name : string; elem : TFhirProvenanceAgent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'role', elem.role); {a}
  ComposeCoding(json, 'type', elem.type_); {a}
  if (elem.reference is TFhirUri) then 
  begin
    ComposeUriValue(json, 'referenceUri', TFhirUri(elem.reference), false);
    ComposeUriProps(json, 'referenceUri', TFhirUri(elem.reference), false);
  end
  else if (elem.reference is TFhirReference) then
    ComposeReference(json, 'referenceReference', TFhirReference(elem.reference));
  ComposeStringValue(json, 'display', elem.displayElement, false);
  ComposeStringProps(json, 'display', elem.displayElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseProvenanceEntity(element : IXmlDomElement; path : string) : TFhirProvenanceEntity;
var
  child : IXMLDOMElement;
begin
  result := TFhirProvenanceEntity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'role') then
        result.roleElement := ParseEnum(CODES_TFhirProvenanceEntityRole, path+'/role', child){1a}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'reference') then
        result.referenceElement := ParseUri(child, path+'/reference') {b}
      else if (child.baseName = 'display') then
        result.displayElement := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'agent') then
        result.agent := ParseProvenanceAgent(child, path+'/agent') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProvenanceEntity(xml : TXmlBuilder; name : string; elem : TFhirProvenanceEntity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'role', elem.RoleElement, CODES_TFhirProvenanceEntityRole);
  ComposeCoding(xml, 'type', elem.type_);{x.2}
  ComposeUri(xml, 'reference', elem.referenceElement);{x.2}
  ComposeString(xml, 'display', elem.displayElement);{x.2}
  ComposeProvenanceAgent(xml, 'agent', elem.agent);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProvenanceEntity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenanceEntity(jsn)); {2}
end;

function TFHIRJsonParser.ParseProvenanceEntity(jsn : TJsonObject) : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') or jsn.has('_role')  then
      result.roleElement := parseEnum(jsn['role'], jsn.vObj['_role'], CODES_TFhirProvenanceEntityRole);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceElement := ParseUri(jsn['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('agent') then
        result.agent := ParseProvenanceAgent(jsn.vObj['agent']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProvenanceEntity(json : TJSONWriter; name : string; elem : TFhirProvenanceEntity; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'role', elem.RoleElement, CODES_TFhirProvenanceEntityRole, false);
  ComposeEnumProps(json, 'role', elem.RoleElement, CODES_TFhirProvenanceEntityRole, false);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeUriValue(json, 'reference', elem.referenceElement, false);
  ComposeUriProps(json, 'reference', elem.referenceElement, false);
  ComposeStringValue(json, 'display', elem.displayElement, false);
  ComposeStringProps(json, 'display', elem.displayElement, false);
  ComposeProvenanceAgent(json, 'agent', elem.agent); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseProvenance(element : IXmlDomElement; path : string) : TFhirProvenance;
var
  child : IXMLDOMElement;
begin
  result := TFhirProvenance.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'target') then
        result.targetList.Add(ParseReference{TFhirReference}(child, path+'/target')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'recorded') then
        result.recordedElement := ParseInstant(child, path+'/recorded') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'policy') then
        result.policyList.Add(ParseUri(child, path+'/policy')){y.2}
      else if (child.baseName = 'agent') then
        result.agentList.Add(ParseProvenanceAgent(child, path+'/agent')){y.2}
      else if (child.baseName = 'entity') then
        result.entityList.Add(ParseProvenanceEntity(child, path+'/entity')){y.2}
      else if (child.baseName = 'signature') then
        result.signatureList.Add(ParseSignature(child, path+'/signature')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProvenance(xml : TXmlBuilder; name : string; elem : TFhirProvenance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.targetList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'target', elem.targetList[i]);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  ComposeInstant(xml, 'recorded', elem.recordedElement);{x.2}
  ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2}
  ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  for i := 0 to elem.policyList.Count - 1 do
    ComposeUri(xml, 'policy', elem.policyList[i]);
  for i := 0 to elem.agentList.Count - 1 do
    ComposeProvenanceAgent(xml, 'agent', elem.agentList[i]);
  for i := 0 to elem.entityList.Count - 1 do
    ComposeProvenanceEntity(xml, 'entity', elem.entityList[i]);
  for i := 0 to elem.signatureList.Count - 1 do
    ComposeSignature(xml, 'signature', elem.signatureList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProvenance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenance(jsn)); {2}
end;

function TFHIRJsonParser.ParseProvenance(jsn : TJsonObject) : TFhirProvenance;
begin
  result := TFhirProvenance.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('target') then
      iterateArray(jsn.vArr['target'], result.targetList, parseReference{TFhirReference});
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('recorded') or jsn.has('_recorded') then
        result.recordedElement := ParseInstant(jsn['recorded'], jsn.vObj['_recorded']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
      if jsn.has('policy') or jsn.has('_policy') then
      iteratePrimitiveArray(jsn.vArr['policy'], jsn.vArr['_policy'], result.policyList, parseUri);
    if jsn.has('agent') then
      iterateArray(jsn.vArr['agent'], result.agentList, parseProvenanceAgent);
    if jsn.has('entity') then
      iterateArray(jsn.vArr['entity'], result.entityList, parseProvenanceEntity);
    if jsn.has('signature') then
      iterateArray(jsn.vArr['signature'], result.signatureList, parseSignature);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProvenance(json : TJSONWriter; name : string; elem : TFhirProvenance; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.targetList.Count > 0 then
  begin
    json.valueArray('target');
    for i := 0 to elem.targetList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.targetList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeInstantValue(json, 'recorded', elem.recordedElement, false);
  ComposeInstantProps(json, 'recorded', elem.recordedElement, false);
  ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if elem.policyList.Count > 0 then
  begin
    json.valueArray('policy');
    ext := false;
    for i := 0 to elem.policyList.Count - 1 do
    begin
      ext := ext or ((elem.policyList[i].id <> '') or (elem.policyList[i].hasExtensionList));
      ComposeUriValue(json, '',elem.policyList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_policy');
      for i := 0 to elem.policyList.Count - 1 do
        ComposeUriProps(json, '',elem.policyList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.agentList.Count > 0 then
  begin
    json.valueArray('agent');
    for i := 0 to elem.agentList.Count - 1 do
      ComposeProvenanceAgent(json, '',elem.agentList[i]); {z - }
    json.FinishArray;
  end;
  if elem.entityList.Count > 0 then
  begin
    json.valueArray('entity');
    for i := 0 to elem.entityList.Count - 1 do
      ComposeProvenanceEntity(json, '',elem.entityList[i]); {z - }
    json.FinishArray;
  end;
  if elem.signatureList.Count > 0 then
  begin
    json.valueArray('signature');
    for i := 0 to elem.signatureList.Count - 1 do
      ComposeSignature(json, '',elem.signatureList[i]); {z - Signature}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireGroup(element : IXmlDomElement; path : string) : TFhirQuestionnaireGroup;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'linkId') then
        result.linkIdElement := ParseString(child, path+'/linkId') {b}
      else if (child.baseName = 'title') then
        result.titleElement := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseCoding(child, path+'/concept')){y.2}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'required') then
        result.requiredElement := ParseBoolean(child, path+'/required') {b}
      else if (child.baseName = 'repeats') then
        result.repeatsElement := ParseBoolean(child, path+'/repeats') {b}
      else if (child.baseName = 'group') then
        result.groupList.Add(ParseQuestionnaireGroup(child, path+'/group')){y.2}
      else if (child.baseName = 'question') then
        result.questionList.Add(ParseQuestionnaireGroupQuestion(child, path+'/question')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireGroup(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroup);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'linkId', elem.linkIdElement);{x.2}
  ComposeString(xml, 'title', elem.titleElement);{x.2}
  for i := 0 to elem.conceptList.Count - 1 do
    ComposeCoding(xml, 'concept', elem.conceptList[i]);
  ComposeString(xml, 'text', elem.textElement);{x.2}
  ComposeBoolean(xml, 'required', elem.requiredElement);{x.2}
  ComposeBoolean(xml, 'repeats', elem.repeatsElement);{x.2}
  for i := 0 to elem.groupList.Count - 1 do
    ComposeQuestionnaireGroup(xml, 'group', elem.groupList[i]);
  for i := 0 to elem.questionList.Count - 1 do
    ComposeQuestionnaireGroupQuestion(xml, 'question', elem.questionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireGroup(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireGroup(jsn : TJsonObject) : TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdElement := ParseString(jsn['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseCoding);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('required') or jsn.has('_required') then
        result.requiredElement := ParseBoolean(jsn['required'], jsn.vObj['_required']);{q}
    if jsn.has('repeats') or jsn.has('_repeats') then
        result.repeatsElement := ParseBoolean(jsn['repeats'], jsn.vObj['_repeats']);{q}
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireGroup);
    if jsn.has('question') then
      iterateArray(jsn.vArr['question'], result.questionList, parseQuestionnaireGroupQuestion);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'linkId', elem.linkIdElement, false);
  ComposeStringProps(json, 'linkId', elem.linkIdElement, false);
  ComposeStringValue(json, 'title', elem.titleElement, false);
  ComposeStringProps(json, 'title', elem.titleElement, false);
  if elem.conceptList.Count > 0 then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCoding(json, '',elem.conceptList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'text', elem.textElement, false);
  ComposeStringProps(json, 'text', elem.textElement, false);
  ComposeBooleanValue(json, 'required', elem.requiredElement, false);
  ComposeBooleanProps(json, 'required', elem.requiredElement, false);
  ComposeBooleanValue(json, 'repeats', elem.repeatsElement, false);
  ComposeBooleanProps(json, 'repeats', elem.repeatsElement, false);
  if elem.groupList.Count > 0 then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(json, '',elem.groupList[i]); {z - @Questionnaire.group}
    json.FinishArray;
  end;
  if elem.questionList.Count > 0 then
  begin
    json.valueArray('question');
    for i := 0 to elem.questionList.Count - 1 do
      ComposeQuestionnaireGroupQuestion(json, '',elem.questionList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseQuestionnaireGroupQuestion(element : IXmlDomElement; path : string) : TFhirQuestionnaireGroupQuestion;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireGroupQuestion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'linkId') then
        result.linkIdElement := ParseString(child, path+'/linkId') {b}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseCoding(child, path+'/concept')){y.2}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirAnswerFormat, path+'/type', child){1a}
      else if (child.baseName = 'required') then
        result.requiredElement := ParseBoolean(child, path+'/required') {b}
      else if (child.baseName = 'repeats') then
        result.repeatsElement := ParseBoolean(child, path+'/repeats') {b}
      else if (child.baseName = 'options') then
        result.options := ParseReference{TFhirValueSet}(child, path+'/options') {b}
      else if (child.baseName = 'group') then
        result.groupList.Add(ParseQuestionnaireGroup(child, path+'/group')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireGroupQuestion(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroupQuestion);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'linkId', elem.linkIdElement);{x.2}
  for i := 0 to elem.conceptList.Count - 1 do
    ComposeCoding(xml, 'concept', elem.conceptList[i]);
  ComposeString(xml, 'text', elem.textElement);{x.2}
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirAnswerFormat);
  ComposeBoolean(xml, 'required', elem.requiredElement);{x.2}
  ComposeBoolean(xml, 'repeats', elem.repeatsElement);{x.2}
  ComposeReference{TFhirValueSet}(xml, 'options', elem.options);{x.2}
  for i := 0 to elem.groupList.Count - 1 do
    ComposeQuestionnaireGroup(xml, 'group', elem.groupList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireGroupQuestion(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdElement := ParseString(jsn['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseCoding);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirAnswerFormat);
    if jsn.has('required') or jsn.has('_required') then
        result.requiredElement := ParseBoolean(jsn['required'], jsn.vObj['_required']);{q}
    if jsn.has('repeats') or jsn.has('_repeats') then
        result.repeatsElement := ParseBoolean(jsn['repeats'], jsn.vObj['_repeats']);{q}
    if jsn.has('options') then
        result.options := ParseReference{TFhirValueSet}(jsn.vObj['options']);{q}
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireGroup);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroupQuestion; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'linkId', elem.linkIdElement, false);
  ComposeStringProps(json, 'linkId', elem.linkIdElement, false);
  if elem.conceptList.Count > 0 then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCoding(json, '',elem.conceptList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'text', elem.textElement, false);
  ComposeStringProps(json, 'text', elem.textElement, false);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirAnswerFormat, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirAnswerFormat, false);
  ComposeBooleanValue(json, 'required', elem.requiredElement, false);
  ComposeBooleanProps(json, 'required', elem.requiredElement, false);
  ComposeBooleanValue(json, 'repeats', elem.repeatsElement, false);
  ComposeBooleanProps(json, 'repeats', elem.repeatsElement, false);
  ComposeReference{TFhirValueSet}(json, 'options', elem.options); {a}
  if elem.groupList.Count > 0 then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(json, '',elem.groupList[i]); {z - @Questionnaire.group}
      json.FinishArray;
    end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseQuestionnaire(element : IXmlDomElement; path : string) : TFhirQuestionnaire;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaire.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirQuestionnaireStatus, path+'/status', child){1a}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'group') then
        result.group := ParseQuestionnaireGroup(child, path+'/group') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaire(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaire);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeString(xml, 'version', elem.versionElement);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirQuestionnaireStatus);
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeQuestionnaireGroup(xml, 'group', elem.group);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaire(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaire(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaire(jsn : TJsonObject) : TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirQuestionnaireStatus);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('group') then
        result.group := ParseQuestionnaireGroup(jsn.vObj['group']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaire(json : TJSONWriter; name : string; elem : TFhirQuestionnaire; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
    end;
  ComposeStringValue(json, 'version', elem.versionElement, false);
  ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirQuestionnaireStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirQuestionnaireStatus, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeQuestionnaireGroup(json, 'group', elem.group); {a}
end;

function TFHIRXmlParser.ParseQuestionnaireAnswersGroup(element : IXmlDomElement; path : string) : TFhirQuestionnaireAnswersGroup;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireAnswersGroup.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'linkId') then
        result.linkIdElement := ParseString(child, path+'/linkId') {b}
      else if (child.baseName = 'title') then
        result.titleElement := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.baseName = 'group') then
        result.groupList.Add(ParseQuestionnaireAnswersGroup(child, path+'/group')){y.2}
      else if (child.baseName = 'question') then
        result.questionList.Add(ParseQuestionnaireAnswersGroupQuestion(child, path+'/question')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireAnswersGroup(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireAnswersGroup);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'linkId', elem.linkIdElement);{x.2}
  ComposeString(xml, 'title', elem.titleElement);{x.2}
  ComposeString(xml, 'text', elem.textElement);{x.2}
  ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2}
  for i := 0 to elem.groupList.Count - 1 do
    ComposeQuestionnaireAnswersGroup(xml, 'group', elem.groupList[i]);
  for i := 0 to elem.questionList.Count - 1 do
    ComposeQuestionnaireAnswersGroupQuestion(xml, 'question', elem.questionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireAnswersGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireAnswersGroup(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireAnswersGroup(jsn : TJsonObject) : TFhirQuestionnaireAnswersGroup;
begin
  result := TFhirQuestionnaireAnswersGroup.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdElement := ParseString(jsn['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q}
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireAnswersGroup);
    if jsn.has('question') then
      iterateArray(jsn.vArr['question'], result.questionList, parseQuestionnaireAnswersGroupQuestion);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireAnswersGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireAnswersGroup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'linkId', elem.linkIdElement, false);
  ComposeStringProps(json, 'linkId', elem.linkIdElement, false);
  ComposeStringValue(json, 'title', elem.titleElement, false);
  ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeStringValue(json, 'text', elem.textElement, false);
  ComposeStringProps(json, 'text', elem.textElement, false);
  ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  if elem.groupList.Count > 0 then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireAnswersGroup(json, '',elem.groupList[i]); {z - @QuestionnaireAnswers.group}
    json.FinishArray;
  end;
  if elem.questionList.Count > 0 then
  begin
    json.valueArray('question');
    for i := 0 to elem.questionList.Count - 1 do
      ComposeQuestionnaireAnswersGroupQuestion(json, '',elem.questionList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseQuestionnaireAnswersGroupQuestion(element : IXmlDomElement; path : string) : TFhirQuestionnaireAnswersGroupQuestion;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireAnswersGroupQuestion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'linkId') then
        result.linkIdElement := ParseString(child, path+'/linkId') {b}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'answer') then
        result.answerList.Add(ParseQuestionnaireAnswersGroupQuestionAnswer(child, path+'/answer')){y.2}
      else if (child.baseName = 'group') then
        result.groupList.Add(ParseQuestionnaireAnswersGroup(child, path+'/group')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireAnswersGroupQuestion(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireAnswersGroupQuestion);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'linkId', elem.linkIdElement);{x.2}
  ComposeString(xml, 'text', elem.textElement);{x.2}
  for i := 0 to elem.answerList.Count - 1 do
    ComposeQuestionnaireAnswersGroupQuestionAnswer(xml, 'answer', elem.answerList[i]);
  for i := 0 to elem.groupList.Count - 1 do
    ComposeQuestionnaireAnswersGroup(xml, 'group', elem.groupList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireAnswersGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireAnswersGroupQuestion(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireAnswersGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireAnswersGroupQuestion;
begin
  result := TFhirQuestionnaireAnswersGroupQuestion.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdElement := ParseString(jsn['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('answer') then
      iterateArray(jsn.vArr['answer'], result.answerList, parseQuestionnaireAnswersGroupQuestionAnswer);
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireAnswersGroup);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireAnswersGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireAnswersGroupQuestion; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'linkId', elem.linkIdElement, false);
  ComposeStringProps(json, 'linkId', elem.linkIdElement, false);
  ComposeStringValue(json, 'text', elem.textElement, false);
  ComposeStringProps(json, 'text', elem.textElement, false);
  if elem.answerList.Count > 0 then
  begin
    json.valueArray('answer');
    for i := 0 to elem.answerList.Count - 1 do
      ComposeQuestionnaireAnswersGroupQuestionAnswer(json, '',elem.answerList[i]); {z - }
    json.FinishArray;
  end;
  if elem.groupList.Count > 0 then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireAnswersGroup(json, '',elem.groupList[i]); {z - @QuestionnaireAnswers.group}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseQuestionnaireAnswersGroupQuestionAnswer(element : IXmlDomElement; path : string) : TFhirQuestionnaireAnswersGroupQuestionAnswer;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireAnswersGroupQuestionAnswer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.baseName = 'valueDecimal') then
        result.value := ParseDecimal(child, path+'/valueDecimal'){x.3}
      else if (child.baseName = 'valueInteger') then
        result.value := ParseInteger(child, path+'/valueInteger'){x.3}
      else if (child.baseName = 'valueDate') then
        result.value := ParseDate(child, path+'/valueDate'){x.3}
      else if (child.baseName = 'valueDateTime') then
        result.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.baseName = 'valueInstant') then
        result.value := ParseInstant(child, path+'/valueInstant'){x.3}
      else if (child.baseName = 'valueTime') then
        result.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.baseName = 'valueUri') then
        result.value := ParseUri(child, path+'/valueUri'){x.3}
      else if (child.baseName = 'valueAttachment') then
        result.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.baseName = 'valueCoding') then
        result.value := ParseCoding(child, path+'/valueCoding'){x.3}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.baseName = 'valueReference') then
        result.value := ParseReference(child, path+'/valueReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireAnswersGroupQuestionAnswer(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireAnswersGroupQuestionAnswer);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (elem.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (elem.value is TFhirInstant) {6} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (elem.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value))
  else if (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirReference) {2} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireAnswersGroupQuestionAnswer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireAnswersGroupQuestionAnswer(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireAnswersGroupQuestionAnswer(jsn : TJsonObject) : TFhirQuestionnaireAnswersGroupQuestionAnswer;
begin
  result := TFhirQuestionnaireAnswersGroupQuestionAnswer.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := parseDecimal(jsn['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
      result.value := parseDate(jsn['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
      result.value := parseInstant(jsn['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
      result.value := parseUri(jsn['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueCoding') {a4} then
      result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueReference') {a3} then
      result.value := ParseReference(jsn.vObj['valueReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireAnswersGroupQuestionAnswer(json : TJSONWriter; name : string; elem : TFhirQuestionnaireAnswersGroupQuestionAnswer; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end
  else if (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (elem.value is TFhirDate) then 
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false);
  end
  else if (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end
  else if (elem.value is TFhirInstant) then 
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false);
  end
  else if (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (elem.value is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false);
  end
  else if (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (elem.value is TFhirCoding) then 
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value)) 
  else if (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value));
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseQuestionnaireAnswers(element : IXmlDomElement; path : string) : TFhirQuestionnaireAnswers;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireAnswers.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'questionnaire') then
        result.questionnaire := ParseReference{TFhirQuestionnaire}(child, path+'/questionnaire') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirQuestionnaireAnswersStatus, path+'/status', child){1a}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'authored') then
        result.authoredElement := ParseDateTime(child, path+'/authored') {b}
      else if (child.baseName = 'source') then
        result.source := ParseReference{Resource}(child, path+'/source') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'group') then
        result.group := ParseQuestionnaireAnswersGroup(child, path+'/group') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireAnswers(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireAnswers);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeReference{TFhirQuestionnaire}(xml, 'questionnaire', elem.questionnaire);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirQuestionnaireAnswersStatus);
  ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2}
  ComposeReference{Resource}(xml, 'author', elem.author);{x.2}
  ComposeDateTime(xml, 'authored', elem.authoredElement);{x.2}
  ComposeReference{Resource}(xml, 'source', elem.source);{x.2}
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  ComposeQuestionnaireAnswersGroup(xml, 'group', elem.group);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireAnswers(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireAnswers(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireAnswers(jsn : TJsonObject) : TFhirQuestionnaireAnswers;
begin
  result := TFhirQuestionnaireAnswers.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('questionnaire') then
        result.questionnaire := ParseReference{TFhirQuestionnaire}(jsn.vObj['questionnaire']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirQuestionnaireAnswersStatus);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('authored') or jsn.has('_authored') then
        result.authoredElement := ParseDateTime(jsn['authored'], jsn.vObj['_authored']);{q}
    if jsn.has('source') then
        result.source := ParseReference{Resource}(jsn.vObj['source']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('group') then
        result.group := ParseQuestionnaireAnswersGroup(jsn.vObj['group']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireAnswers(json : TJSONWriter; name : string; elem : TFhirQuestionnaireAnswers; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeReference{TFhirQuestionnaire}(json, 'questionnaire', elem.questionnaire); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirQuestionnaireAnswersStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirQuestionnaireAnswersStatus, false);
  ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  ComposeReference{Resource}(json, 'author', elem.author); {a}
  ComposeDateTimeValue(json, 'authored', elem.authoredElement, false);
  ComposeDateTimeProps(json, 'authored', elem.authoredElement, false);
  ComposeReference{Resource}(json, 'source', elem.source); {a}
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeQuestionnaireAnswersGroup(json, 'group', elem.group); {a}
end;

function TFHIRXmlParser.ParseReferralRequest(element : IXmlDomElement; path : string) : TFhirReferralRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirReferralRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirReferralstatus, path+'/status', child){1a}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'specialty') then
        result.specialty := ParseCodeableConcept(child, path+'/specialty') {b}
      else if (child.baseName = 'priority') then
        result.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'requester') then
        result.requester := ParseReference{Resource}(child, path+'/requester') {b}
      else if (child.baseName = 'recipient') then
        result.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'dateSent') then
        result.dateSentElement := ParseDateTime(child, path+'/dateSent') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'serviceRequested') then
        result.serviceRequestedList.Add(ParseCodeableConcept(child, path+'/serviceRequested')){y.2}
      else if (child.baseName = 'supportingInformation') then
        result.supportingInformationList.Add(ParseReference{TFhirReference}(child, path+'/supportingInformation')){y.2}
      else if (child.baseName = 'fulfillmentTime') then
        result.fulfillmentTime := ParsePeriod(child, path+'/fulfillmentTime') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeReferralRequest(xml : TXmlBuilder; name : string; elem : TFhirReferralRequest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirReferralstatus);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeCodeableConcept(xml, 'specialty', elem.specialty);{x.2}
  ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeReference{Resource}(xml, 'requester', elem.requester);{x.2}
  for i := 0 to elem.recipientList.Count - 1 do
    ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  ComposeDateTime(xml, 'dateSent', elem.dateSentElement);{x.2}
  ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2}
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  for i := 0 to elem.serviceRequestedList.Count - 1 do
    ComposeCodeableConcept(xml, 'serviceRequested', elem.serviceRequestedList[i]);
  for i := 0 to elem.supportingInformationList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'supportingInformation', elem.supportingInformationList[i]);
  ComposePeriod(xml, 'fulfillmentTime', elem.fulfillmentTime);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseReferralRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseReferralRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseReferralRequest(jsn : TJsonObject) : TFhirReferralRequest;
begin
  result := TFhirReferralRequest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirReferralstatus);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('specialty') then
        result.specialty := ParseCodeableConcept(jsn.vObj['specialty']);{q}
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('requester') then
        result.requester := ParseReference{Resource}(jsn.vObj['requester']);{q}
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{Resource});
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('dateSent') or jsn.has('_dateSent') then
        result.dateSentElement := ParseDateTime(jsn['dateSent'], jsn.vObj['_dateSent']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('serviceRequested') then
      iterateArray(jsn.vArr['serviceRequested'], result.serviceRequestedList, parseCodeableConcept);
    if jsn.has('supportingInformation') then
      iterateArray(jsn.vArr['supportingInformation'], result.supportingInformationList, parseReference{TFhirReference});
    if jsn.has('fulfillmentTime') then
        result.fulfillmentTime := ParsePeriod(jsn.vObj['fulfillmentTime']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeReferralRequest(json : TJSONWriter; name : string; elem : TFhirReferralRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirReferralstatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirReferralstatus, false);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeCodeableConcept(json, 'specialty', elem.specialty); {a}
  ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeReference{Resource}(json, 'requester', elem.requester); {a}
  if elem.recipientList.Count > 0 then
  begin
    json.valueArray('recipient');
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(json, '',elem.recipientList[i]); {z - Reference(Practitioner|Organization)}
    json.FinishArray;
  end;
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeDateTimeValue(json, 'dateSent', elem.dateSentElement, false);
  ComposeDateTimeProps(json, 'dateSent', elem.dateSentElement, false);
  ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if elem.serviceRequestedList.Count > 0 then
  begin
    json.valueArray('serviceRequested');
    for i := 0 to elem.serviceRequestedList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.serviceRequestedList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.supportingInformationList.Count > 0 then
  begin
    json.valueArray('supportingInformation');
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.supportingInformationList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  ComposePeriod(json, 'fulfillmentTime', elem.fulfillmentTime); {a}
end;

function TFHIRXmlParser.ParseRelatedPerson(element : IXmlDomElement; path : string) : TFhirRelatedPerson;
var
  child : IXMLDOMElement;
begin
  result := TFhirRelatedPerson.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'relationship') then
        result.relationship := ParseCodeableConcept(child, path+'/relationship') {b}
      else if (child.baseName = 'name') then
        result.name := ParseHumanName(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'gender') then
        result.genderElement := ParseEnum(CODES_TFhirAdministrativeGender, path+'/gender', child){1a}
      else if (child.baseName = 'address') then
        result.address := ParseAddress(child, path+'/address') {b}
      else if (child.baseName = 'photo') then
        result.photoList.Add(ParseAttachment(child, path+'/photo')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRelatedPerson(xml : TXmlBuilder; name : string; elem : TFhirRelatedPerson);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeCodeableConcept(xml, 'relationship', elem.relationship);{x.2}
  ComposeHumanName(xml, 'name', elem.name);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender);
  ComposeAddress(xml, 'address', elem.address);{x.2}
  for i := 0 to elem.photoList.Count - 1 do
    ComposeAttachment(xml, 'photo', elem.photoList[i]);
  ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRelatedPerson(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRelatedPerson(jsn)); {2}
end;

function TFHIRJsonParser.ParseRelatedPerson(jsn : TJsonObject) : TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCodeableConcept(jsn.vObj['relationship']);{q}
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGender);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q}
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRelatedPerson(json : TJSONWriter; name : string; elem : TFhirRelatedPerson; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeCodeableConcept(json, 'relationship', elem.relationship); {a}
  ComposeHumanName(json, 'name', elem.name); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender, false);
  ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGender, false);
  ComposeAddress(json, 'address', elem.address); {a}
  if elem.photoList.Count > 0 then
  begin
    json.valueArray('photo');
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '',elem.photoList[i]); {z - Attachment}
    json.FinishArray;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
end;

function TFHIRXmlParser.ParseRiskAssessmentPrediction(element : IXmlDomElement; path : string) : TFhirRiskAssessmentPrediction;
var
  child : IXMLDOMElement;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'outcome') then
        result.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.baseName = 'probabilityDecimal') then
        result.probability := ParseDecimal(child, path+'/probabilityDecimal'){x.3}
      else if (child.baseName = 'probabilityRange') then
        result.probability := ParseRange(child, path+'/probabilityRange'){x.3}
      else if (child.baseName = 'probabilityCodeableConcept') then
        result.probability := ParseCodeableConcept(child, path+'/probabilityCodeableConcept'){x.3}
      else if (child.baseName = 'relativeRisk') then
        result.relativeRiskElement := ParseDecimal(child, path+'/relativeRisk') {b}
      else if (child.baseName = 'whenPeriod') then
        result.when := ParsePeriod(child, path+'/whenPeriod'){x.3}
      else if (child.baseName = 'whenRange') then
        result.when := ParseRange(child, path+'/whenRange'){x.3}
      else if (child.baseName = 'rationale') then
        result.rationaleElement := ParseString(child, path+'/rationale') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessmentPrediction(xml : TXmlBuilder; name : string; elem : TFhirRiskAssessmentPrediction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2}
  if (elem.probability is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'probabilityDecimal', TFhirDecimal(elem.probability))
  else if (elem.probability is TFhirRange) {6} then
    ComposeRange(xml, 'probabilityRange', TFhirRange(elem.probability))
  else if (elem.probability is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'probabilityCodeableConcept', TFhirCodeableConcept(elem.probability));
  ComposeDecimal(xml, 'relativeRisk', elem.relativeRiskElement);{x.2}
  if (elem.when is TFhirPeriod) {6} then
    ComposePeriod(xml, 'whenPeriod', TFhirPeriod(elem.when))
  else if (elem.when is TFhirRange) {6} then
    ComposeRange(xml, 'whenRange', TFhirRange(elem.when));
  ComposeString(xml, 'rationale', elem.rationaleElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRiskAssessmentPrediction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRiskAssessmentPrediction(jsn)); {2}
end;

function TFHIRJsonParser.ParseRiskAssessmentPrediction(jsn : TJsonObject) : TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('outcome') then
        result.outcome := ParseCodeableConcept(jsn.vObj['outcome']);{q}
    if jsn.has('probabilityDecimal') or jsn.has('_probabilityDecimal') then
      result.probability := parseDecimal(jsn['probabilityDecimal'], jsn.vObj['_probabilityDecimal']);
    if jsn.has('probabilityRange') {a4} then
      result.probability := ParseRange(jsn.vObj['probabilityRange']);
    if jsn.has('probabilityCodeableConcept') {a4} then
      result.probability := ParseCodeableConcept(jsn.vObj['probabilityCodeableConcept']);
    if jsn.has('relativeRisk') or jsn.has('_relativeRisk') then
        result.relativeRiskElement := ParseDecimal(jsn['relativeRisk'], jsn.vObj['_relativeRisk']);{q}
    if jsn.has('whenPeriod') {a4} then
      result.when := ParsePeriod(jsn.vObj['whenPeriod']);
    if jsn.has('whenRange') {a4} then
      result.when := ParseRange(jsn.vObj['whenRange']);
    if jsn.has('rationale') or jsn.has('_rationale') then
        result.rationaleElement := ParseString(jsn['rationale'], jsn.vObj['_rationale']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRiskAssessmentPrediction(json : TJSONWriter; name : string; elem : TFhirRiskAssessmentPrediction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'outcome', elem.outcome); {a}
  if (elem.probability is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'probabilityDecimal', TFhirDecimal(elem.probability), false);
    ComposeDecimalProps(json, 'probabilityDecimal', TFhirDecimal(elem.probability), false);
  end
  else if (elem.probability is TFhirRange) then 
    ComposeRange(json, 'probabilityRange', TFhirRange(elem.probability)) 
  else if (elem.probability is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'probabilityCodeableConcept', TFhirCodeableConcept(elem.probability)) ;
  ComposeDecimalValue(json, 'relativeRisk', elem.relativeRiskElement, false);
  ComposeDecimalProps(json, 'relativeRisk', elem.relativeRiskElement, false);
  if (elem.when is TFhirPeriod) then 
    ComposePeriod(json, 'whenPeriod', TFhirPeriod(elem.when)) 
  else if (elem.when is TFhirRange) then 
    ComposeRange(json, 'whenRange', TFhirRange(elem.when)) ;
  ComposeStringValue(json, 'rationale', elem.rationaleElement, false);
  ComposeStringProps(json, 'rationale', elem.rationaleElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseRiskAssessment(element : IXmlDomElement; path : string) : TFhirRiskAssessment;
var
  child : IXMLDOMElement;
begin
  result := TFhirRiskAssessment.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'condition') then
        result.condition := ParseReference{TFhirCondition}(child, path+'/condition') {b}
      else if (child.baseName = 'performer') then
        result.performer := ParseReference{Resource}(child, path+'/performer') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'basis') then
        result.basisList.Add(ParseReference{TFhirReference}(child, path+'/basis')){y.2}
      else if (child.baseName = 'prediction') then
        result.predictionList.Add(ParseRiskAssessmentPrediction(child, path+'/prediction')){y.2}
      else if (child.baseName = 'mitigation') then
        result.mitigationElement := ParseString(child, path+'/mitigation') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessment(xml : TXmlBuilder; name : string; elem : TFhirRiskAssessment);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeReference{TFhirCondition}(xml, 'condition', elem.condition);{x.2}
  ComposeReference{Resource}(xml, 'performer', elem.performer);{x.2}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  for i := 0 to elem.basisList.Count - 1 do
    ComposeReference{TFhirReference}(xml, 'basis', elem.basisList[i]);
  for i := 0 to elem.predictionList.Count - 1 do
    ComposeRiskAssessmentPrediction(xml, 'prediction', elem.predictionList[i]);
  ComposeString(xml, 'mitigation', elem.mitigationElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRiskAssessment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRiskAssessment(jsn)); {2}
end;

function TFHIRJsonParser.ParseRiskAssessment(jsn : TJsonObject) : TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('condition') then
        result.condition := ParseReference{TFhirCondition}(jsn.vObj['condition']);{q}
    if jsn.has('performer') then
        result.performer := ParseReference{Resource}(jsn.vObj['performer']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('basis') then
      iterateArray(jsn.vArr['basis'], result.basisList, parseReference{TFhirReference});
    if jsn.has('prediction') then
      iterateArray(jsn.vArr['prediction'], result.predictionList, parseRiskAssessmentPrediction);
    if jsn.has('mitigation') or jsn.has('_mitigation') then
        result.mitigationElement := ParseString(jsn['mitigation'], jsn.vObj['_mitigation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRiskAssessment(json : TJSONWriter; name : string; elem : TFhirRiskAssessment; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeReference{TFhirCondition}(json, 'condition', elem.condition); {a}
  ComposeReference{Resource}(json, 'performer', elem.performer); {a}
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  if elem.basisList.Count > 0 then
  begin
    json.valueArray('basis');
    for i := 0 to elem.basisList.Count - 1 do
      ComposeReference{TFhirReference}(json, '',elem.basisList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if elem.predictionList.Count > 0 then
  begin
    json.valueArray('prediction');
    for i := 0 to elem.predictionList.Count - 1 do
      ComposeRiskAssessmentPrediction(json, '',elem.predictionList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'mitigation', elem.mitigationElement, false);
  ComposeStringProps(json, 'mitigation', elem.mitigationElement, false);
end;

function TFHIRXmlParser.ParseSchedule(element : IXmlDomElement; path : string) : TFhirSchedule;
var
  child : IXMLDOMElement;
begin
  result := TFhirSchedule.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.baseName = 'actor') then
        result.actor := ParseReference{TFhirReference}(child, path+'/actor') {b}
      else if (child.baseName = 'planningHorizon') then
        result.planningHorizon := ParsePeriod(child, path+'/planningHorizon') {b}
      else if (child.baseName = 'comment') then
        result.commentElement := ParseString(child, path+'/comment') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSchedule(xml : TXmlBuilder; name : string; elem : TFhirSchedule);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  ComposeReference{TFhirReference}(xml, 'actor', elem.actor);{x.2}
  ComposePeriod(xml, 'planningHorizon', elem.planningHorizon);{x.2}
  ComposeString(xml, 'comment', elem.commentElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSchedule(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSchedule(jsn)); {2}
end;

function TFHIRJsonParser.ParseSchedule(jsn : TJsonObject) : TFhirSchedule;
begin
  result := TFhirSchedule.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('actor') then
        result.actor := ParseReference{TFhirReference}(jsn.vObj['actor']);{q}
    if jsn.has('planningHorizon') then
        result.planningHorizon := ParsePeriod(jsn.vObj['planningHorizon']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSchedule(json : TJSONWriter; name : string; elem : TFhirSchedule; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '',elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeReference{TFhirReference}(json, 'actor', elem.actor); {a}
  ComposePeriod(json, 'planningHorizon', elem.planningHorizon); {a}
  ComposeStringValue(json, 'comment', elem.commentElement, false);
  ComposeStringProps(json, 'comment', elem.commentElement, false);
end;

function TFHIRXmlParser.ParseSearchParameterContact(element : IXmlDomElement; path : string) : TFhirSearchParameterContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirSearchParameterContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSearchParameterContact(xml : TXmlBuilder; name : string; elem : TFhirSearchParameterContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSearchParameterContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSearchParameterContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseSearchParameterContact(jsn : TJsonObject) : TFhirSearchParameterContact;
begin
  result := TFhirSearchParameterContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSearchParameterContact(json : TJSONWriter; name : string; elem : TFhirSearchParameterContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseSearchParameter(element : IXmlDomElement; path : string) : TFhirSearchParameter;
var
  child : IXMLDOMElement;
begin
  result := TFhirSearchParameter.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseSearchParameterContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'requirements') then
        result.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatus, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'base') then
        result.baseElement := ParseCode(child, path+'/base') {b}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirSearchParamType, path+'/type', child){1a}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'xpath') then
        result.xpathElement := ParseString(child, path+'/xpath') {b}
      else if (child.baseName = 'target') then
        result.targetList.Add(ParseCode(child, path+'/target')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSearchParameter(xml : TXmlBuilder; name : string; elem : TFhirSearchParameter);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  for i := 0 to elem.contactList.Count - 1 do
    ComposeSearchParameterContact(xml, 'contact', elem.contactList[i]);
  ComposeString(xml, 'requirements', elem.requirementsElement);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus);
  ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeCode(xml, 'base', elem.baseElement);{x.2}
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirSearchParamType);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeString(xml, 'xpath', elem.xpathElement);{x.2}
  for i := 0 to elem.targetList.Count - 1 do
    ComposeCode(xml, 'target', elem.targetList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSearchParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSearchParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseSearchParameter(jsn : TJsonObject) : TFhirSearchParameter;
begin
  result := TFhirSearchParameter.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseSearchParameterContact);
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatus);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('base') or jsn.has('_base') then
        result.baseElement := ParseCode(jsn['base'], jsn.vObj['_base']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirSearchParamType);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('xpath') or jsn.has('_xpath') then
        result.xpathElement := ParseString(jsn['xpath'], jsn.vObj['_xpath']);{q}
      if jsn.has('target') or jsn.has('_target') then
      iteratePrimitiveArray(jsn.vArr['target'], jsn.vArr['_target'], result.targetList, parseCode);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSearchParameter(json : TJSONWriter; name : string; elem : TFhirSearchParameter; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if elem.contactList.Count > 0 then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeSearchParameterContact(json, '',elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus, false);
  ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeCodeValue(json, 'base', elem.baseElement, false);
  ComposeCodeProps(json, 'base', elem.baseElement, false);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirSearchParamType, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirSearchParamType, false);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeStringValue(json, 'xpath', elem.xpathElement, false);
  ComposeStringProps(json, 'xpath', elem.xpathElement, false);
  if elem.targetList.Count > 0 then
  begin
    json.valueArray('target');
    ext := false;
    for i := 0 to elem.targetList.Count - 1 do
    begin
      ext := ext or ((elem.targetList[i].id <> '') or (elem.targetList[i].hasExtensionList));
      ComposeCodeValue(json, '',elem.targetList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_target');
      for i := 0 to elem.targetList.Count - 1 do
        ComposeCodeProps(json, '',elem.targetList[i], true);
      json.FinishArray;
    end;
  end;
end;

function TFHIRXmlParser.ParseSlot(element : IXmlDomElement; path : string) : TFhirSlot;
var
  child : IXMLDOMElement;
begin
  result := TFhirSlot.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'schedule') then
        result.schedule := ParseReference{TFhirSchedule}(child, path+'/schedule') {b}
      else if (child.baseName = 'freeBusyType') then
        result.freeBusyTypeElement := ParseEnum(CODES_TFhirSlotstatus, path+'/freeBusyType', child){1a}
      else if (child.baseName = 'start') then
        result.startElement := ParseInstant(child, path+'/start') {b}
      else if (child.baseName = 'end') then
        result.end_Element := ParseInstant(child, path+'/end') {b}
      else if (child.baseName = 'overbooked') then
        result.overbookedElement := ParseBoolean(child, path+'/overbooked') {b}
      else if (child.baseName = 'comment') then
        result.commentElement := ParseString(child, path+'/comment') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSlot(xml : TXmlBuilder; name : string; elem : TFhirSlot);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeReference{TFhirSchedule}(xml, 'schedule', elem.schedule);{x.2}
  ComposeEnum(xml, 'freeBusyType', elem.FreeBusyTypeElement, CODES_TFhirSlotstatus);
  ComposeInstant(xml, 'start', elem.startElement);{x.2}
  ComposeInstant(xml, 'end', elem.end_Element);{x.2}
  ComposeBoolean(xml, 'overbooked', elem.overbookedElement);{x.2}
  ComposeString(xml, 'comment', elem.commentElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSlot(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSlot(jsn)); {2}
end;

function TFHIRJsonParser.ParseSlot(jsn : TJsonObject) : TFhirSlot;
begin
  result := TFhirSlot.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('schedule') then
        result.schedule := ParseReference{TFhirSchedule}(jsn.vObj['schedule']);{q}
    if jsn.has('freeBusyType') or jsn.has('_freeBusyType')  then
      result.freeBusyTypeElement := parseEnum(jsn['freeBusyType'], jsn.vObj['_freeBusyType'], CODES_TFhirSlotstatus);
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := ParseInstant(jsn['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := ParseInstant(jsn['end'], jsn.vObj['_end']);{q}
    if jsn.has('overbooked') or jsn.has('_overbooked') then
        result.overbookedElement := ParseBoolean(jsn['overbooked'], jsn.vObj['_overbooked']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSlot(json : TJSONWriter; name : string; elem : TFhirSlot; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeReference{TFhirSchedule}(json, 'schedule', elem.schedule); {a}
  ComposeEnumValue(json, 'freeBusyType', elem.FreeBusyTypeElement, CODES_TFhirSlotstatus, false);
  ComposeEnumProps(json, 'freeBusyType', elem.FreeBusyTypeElement, CODES_TFhirSlotstatus, false);
  ComposeInstantValue(json, 'start', elem.startElement, false);
  ComposeInstantProps(json, 'start', elem.startElement, false);
  ComposeInstantValue(json, 'end', elem.end_Element, false);
  ComposeInstantProps(json, 'end', elem.end_Element, false);
  ComposeBooleanValue(json, 'overbooked', elem.overbookedElement, false);
  ComposeBooleanProps(json, 'overbooked', elem.overbookedElement, false);
  ComposeStringValue(json, 'comment', elem.commentElement, false);
  ComposeStringProps(json, 'comment', elem.commentElement, false);
end;

function TFHIRXmlParser.ParseSpecimenCollection(element : IXmlDomElement; path : string) : TFhirSpecimenCollection;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimenCollection.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
  begin
      if (child.baseName = 'collector') then
        result.collector := ParseReference{TFhirPractitioner}(child, path+'/collector') {b}
      else if (child.baseName = 'comment') then
        result.commentList.Add(ParseString(child, path+'/comment')){y.2}
      else if (child.baseName = 'collectedDateTime') then
        result.collected := ParseDateTime(child, path+'/collectedDateTime'){x.3}
      else if (child.baseName = 'collectedPeriod') then
        result.collected := ParsePeriod(child, path+'/collectedPeriod'){x.3}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'bodySiteCodeableConcept') then
        result.bodySite := ParseCodeableConcept(child, path+'/bodySiteCodeableConcept'){x.3}
      else if (child.baseName = 'bodySiteReference') then
        result.bodySite := ParseReference(child, path+'/bodySiteReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
  end;

procedure TFHIRXmlComposer.ComposeSpecimenCollection(xml : TXmlBuilder; name : string; elem : TFhirSpecimenCollection);
var
  i : integer;
  begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirPractitioner}(xml, 'collector', elem.collector);{x.2}
  for i := 0 to elem.commentList.Count - 1 do
    ComposeString(xml, 'comment', elem.commentList[i]);
  if (elem.collected is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'collectedDateTime', TFhirDateTime(elem.collected))
  else if (elem.collected is TFhirPeriod) {6} then
    ComposePeriod(xml, 'collectedPeriod', TFhirPeriod(elem.collected));
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  if (elem.bodySite is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite))
  else if (elem.bodySite is TFhirReference) {2} then
    ComposeReference(xml, 'bodySiteReference', TFhirReference(elem.bodySite));
  closeOutElement(xml, elem);
  xml.close(name);
  end;

procedure TFHIRJsonParser.ParseSpecimenCollection(jsn : TJsonObject; ctxt : TFHIRObjectList);
  begin
  ctxt.add(ParseSpecimenCollection(jsn)); {2}
  end;

function TFHIRJsonParser.ParseSpecimenCollection(jsn : TJsonObject) : TFhirSpecimenCollection;
  begin
  result := TFhirSpecimenCollection.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('collector') then
        result.collector := ParseReference{TFhirPractitioner}(jsn.vObj['collector']);{q}
      if jsn.has('comment') or jsn.has('_comment') then
      iteratePrimitiveArray(jsn.vArr['comment'], jsn.vArr['_comment'], result.commentList, parseString);
    if jsn.has('collectedDateTime') or jsn.has('_collectedDateTime') then
      result.collected := parseDateTime(jsn['collectedDateTime'], jsn.vObj['_collectedDateTime']);
    if jsn.has('collectedPeriod') {a4} then
      result.collected := ParsePeriod(jsn.vObj['collectedPeriod']);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('bodySiteCodeableConcept') {a4} then
      result.bodySite := ParseCodeableConcept(jsn.vObj['bodySiteCodeableConcept']);
    if jsn.has('bodySiteReference') {a3} then
      result.bodySite := ParseReference(jsn.vObj['bodySiteReference']);
    result.link;
  finally
    result.free;
  end;
  end;

procedure TFHIRJsonComposer.ComposeSpecimenCollection(json : TJSONWriter; name : string; elem : TFhirSpecimenCollection; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirPractitioner}(json, 'collector', elem.collector); {a}
  if elem.commentList.Count > 0 then
  begin
    json.valueArray('comment');
    ext := false;
    for i := 0 to elem.commentList.Count - 1 do
    begin
      ext := ext or ((elem.commentList[i].id <> '') or (elem.commentList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.commentList[i], true);
    end;
    json.FinishArray;
    if ext then
  begin
      json.valueArray('_comment');
      for i := 0 to elem.commentList.Count - 1 do
        ComposeStringProps(json, '',elem.commentList[i], true);
    json.FinishArray;
  end;
end;
  if (elem.collected is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'collectedDateTime', TFhirDateTime(elem.collected), false);
    ComposeDateTimeProps(json, 'collectedDateTime', TFhirDateTime(elem.collected), false);
  end
  else if (elem.collected is TFhirPeriod) then 
    ComposePeriod(json, 'collectedPeriod', TFhirPeriod(elem.collected)) ;
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (elem.bodySite is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite)) 
  else if (elem.bodySite is TFhirReference) then
    ComposeReference(json, 'bodySiteReference', TFhirReference(elem.bodySite));
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseSpecimenTreatment(element : IXmlDomElement; path : string) : TFhirSpecimenTreatment;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimenTreatment.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'procedure') then
        result.procedure_ := ParseCodeableConcept(child, path+'/procedure') {b}
      else if (child.baseName = 'additive') then
        result.additiveList.Add(ParseReference{TFhirSubstance}(child, path+'/additive')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSpecimenTreatment(xml : TXmlBuilder; name : string; elem : TFhirSpecimenTreatment);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeCodeableConcept(xml, 'procedure', elem.procedure_);{x.2}
  for i := 0 to elem.additiveList.Count - 1 do
    ComposeReference{TFhirSubstance}(xml, 'additive', elem.additiveList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSpecimenTreatment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenTreatment(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimenTreatment(jsn : TJsonObject) : TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('procedure') then
        result.procedure_ := ParseCodeableConcept(jsn.vObj['procedure']);{q}
    if jsn.has('additive') then
      iterateArray(jsn.vArr['additive'], result.additiveList, parseReference{TFhirSubstance});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSpecimenTreatment(json : TJSONWriter; name : string; elem : TFhirSpecimenTreatment; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeCodeableConcept(json, 'procedure', elem.procedure_); {a}
  if elem.additiveList.Count > 0 then
  begin
    json.valueArray('additive');
    for i := 0 to elem.additiveList.Count - 1 do
      ComposeReference{TFhirSubstance}(json, '',elem.additiveList[i]); {z - Reference(Substance)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseSpecimenContainer(element : IXmlDomElement; path : string) : TFhirSpecimenContainer;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimenContainer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'capacity') then
        result.capacity := ParseQuantity(child, path+'/capacity') {b}
      else if (child.baseName = 'specimenQuantity') then
        result.specimenQuantity := ParseQuantity(child, path+'/specimenQuantity') {b}
      else if (child.baseName = 'additiveCodeableConcept') then
        result.additive := ParseCodeableConcept(child, path+'/additiveCodeableConcept'){x.3}
      else if (child.baseName = 'additiveReference') then
        result.additive := ParseReference(child, path+'/additiveReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSpecimenContainer(xml : TXmlBuilder; name : string; elem : TFhirSpecimenContainer);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeQuantity(xml, 'capacity', elem.capacity);{x.2}
  ComposeQuantity(xml, 'specimenQuantity', elem.specimenQuantity);{x.2}
  if (elem.additive is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'additiveCodeableConcept', TFhirCodeableConcept(elem.additive))
  else if (elem.additive is TFhirReference) {2} then
    ComposeReference(xml, 'additiveReference', TFhirReference(elem.additive));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSpecimenContainer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenContainer(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimenContainer(jsn : TJsonObject) : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('capacity') then
        result.capacity := ParseQuantity(jsn.vObj['capacity']);{q}
    if jsn.has('specimenQuantity') then
        result.specimenQuantity := ParseQuantity(jsn.vObj['specimenQuantity']);{q}
    if jsn.has('additiveCodeableConcept') {a4} then
      result.additive := ParseCodeableConcept(jsn.vObj['additiveCodeableConcept']);
    if jsn.has('additiveReference') {a3} then
      result.additive := ParseReference(jsn.vObj['additiveReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSpecimenContainer(json : TJSONWriter; name : string; elem : TFhirSpecimenContainer; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeQuantity(json, 'capacity', elem.capacity); {a}
  ComposeQuantity(json, 'specimenQuantity', elem.specimenQuantity); {a}
  if (elem.additive is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'additiveCodeableConcept', TFhirCodeableConcept(elem.additive)) 
  else if (elem.additive is TFhirReference) then
    ComposeReference(json, 'additiveReference', TFhirReference(elem.additive));
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseSpecimen(element : IXmlDomElement; path : string) : TFhirSpecimen;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimen.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'parent') then
        result.parentList.Add(ParseReference{TFhirSpecimen}(child, path+'/parent')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'accessionIdentifier') then
        result.accessionIdentifier := ParseIdentifier(child, path+'/accessionIdentifier') {b}
      else if (child.baseName = 'receivedTime') then
        result.receivedTimeElement := ParseDateTime(child, path+'/receivedTime') {b}
      else if (child.baseName = 'collection') then
        result.collection := ParseSpecimenCollection(child, path+'/collection') {b}
      else if (child.baseName = 'treatment') then
        result.treatmentList.Add(ParseSpecimenTreatment(child, path+'/treatment')){y.2}
      else if (child.baseName = 'container') then
        result.containerList.Add(ParseSpecimenContainer(child, path+'/container')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSpecimen(xml : TXmlBuilder; name : string; elem : TFhirSpecimen);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  for i := 0 to elem.parentList.Count - 1 do
    ComposeReference{TFhirSpecimen}(xml, 'parent', elem.parentList[i]);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  ComposeIdentifier(xml, 'accessionIdentifier', elem.accessionIdentifier);{x.2}
  ComposeDateTime(xml, 'receivedTime', elem.receivedTimeElement);{x.2}
  ComposeSpecimenCollection(xml, 'collection', elem.collection);{x.2}
  for i := 0 to elem.treatmentList.Count - 1 do
    ComposeSpecimenTreatment(xml, 'treatment', elem.treatmentList[i]);
  for i := 0 to elem.containerList.Count - 1 do
    ComposeSpecimenContainer(xml, 'container', elem.containerList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSpecimen(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimen(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimen(jsn : TJsonObject) : TFhirSpecimen;
begin
  result := TFhirSpecimen.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('parent') then
      iterateArray(jsn.vArr['parent'], result.parentList, parseReference{TFhirSpecimen});
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('accessionIdentifier') then
        result.accessionIdentifier := ParseIdentifier(jsn.vObj['accessionIdentifier']);{q}
    if jsn.has('receivedTime') or jsn.has('_receivedTime') then
        result.receivedTimeElement := ParseDateTime(jsn['receivedTime'], jsn.vObj['_receivedTime']);{q}
    if jsn.has('collection') then
        result.collection := ParseSpecimenCollection(jsn.vObj['collection']);{q}
    if jsn.has('treatment') then
      iterateArray(jsn.vArr['treatment'], result.treatmentList, parseSpecimenTreatment);
    if jsn.has('container') then
      iterateArray(jsn.vArr['container'], result.containerList, parseSpecimenContainer);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSpecimen(json : TJSONWriter; name : string; elem : TFhirSpecimen; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.parentList.Count > 0 then
  begin
    json.valueArray('parent');
    for i := 0 to elem.parentList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '',elem.parentList[i]); {z - Reference(Specimen)}
    json.FinishArray;
  end;
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeIdentifier(json, 'accessionIdentifier', elem.accessionIdentifier); {a}
  ComposeDateTimeValue(json, 'receivedTime', elem.receivedTimeElement, false);
  ComposeDateTimeProps(json, 'receivedTime', elem.receivedTimeElement, false);
  ComposeSpecimenCollection(json, 'collection', elem.collection); {a}
  if elem.treatmentList.Count > 0 then
  begin
    json.valueArray('treatment');
    for i := 0 to elem.treatmentList.Count - 1 do
      ComposeSpecimenTreatment(json, '',elem.treatmentList[i]); {z - }
    json.FinishArray;
  end;
  if elem.containerList.Count > 0 then
  begin
    json.valueArray('container');
    for i := 0 to elem.containerList.Count - 1 do
      ComposeSpecimenContainer(json, '',elem.containerList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseStructureDefinitionContact(element : IXmlDomElement; path : string) : TFhirStructureDefinitionContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirStructureDefinitionContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionContact(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseStructureDefinitionContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinitionContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinitionContact(jsn : TJsonObject) : TFhirStructureDefinitionContact;
begin
  result := TFhirStructureDefinitionContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeStructureDefinitionContact(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseStructureDefinitionMapping(element : IXmlDomElement; path : string) : TFhirStructureDefinitionMapping;
var
  child : IXMLDOMElement;
begin
  result := TFhirStructureDefinitionMapping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identity') then
        result.identityElement := ParseId(child, path+'/identity') {b}
      else if (child.baseName = 'uri') then
        result.uriElement := ParseUri(child, path+'/uri') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'comments') then
        result.commentsElement := ParseString(child, path+'/comments') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionMapping(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionMapping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'identity', elem.identityElement);{x.2}
  ComposeUri(xml, 'uri', elem.uriElement);{x.2}
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  ComposeString(xml, 'comments', elem.commentsElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseStructureDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinitionMapping(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinitionMapping(jsn : TJsonObject) : TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identity') or jsn.has('_identity') then
        result.identityElement := ParseId(jsn['identity'], jsn.vObj['_identity']);{q}
    if jsn.has('uri') or jsn.has('_uri') then
        result.uriElement := ParseUri(jsn['uri'], jsn.vObj['_uri']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsElement := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeStructureDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionMapping; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'identity', elem.identityElement, false);
  ComposeIdProps(json, 'identity', elem.identityElement, false);
  ComposeUriValue(json, 'uri', elem.uriElement, false);
  ComposeUriProps(json, 'uri', elem.uriElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeStringValue(json, 'comments', elem.commentsElement, false);
  ComposeStringProps(json, 'comments', elem.commentsElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseStructureDefinitionSnapshot(element : IXmlDomElement; path : string) : TFhirStructureDefinitionSnapshot;
var
  child : IXMLDOMElement;
begin
  result := TFhirStructureDefinitionSnapshot.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'element') then
        result.elementList.Add(ParseElementDefinition(child, path+'/element')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionSnapshot(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionSnapshot);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.elementList.Count - 1 do
    ComposeElementDefinition(xml, 'element', elem.elementList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseStructureDefinitionSnapshot(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinitionSnapshot(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinitionSnapshot(jsn : TJsonObject) : TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseElementDefinition);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeStructureDefinitionSnapshot(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionSnapshot; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.elementList.Count > 0 then
  begin
    json.valueArray('element');
    for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(json, '',elem.elementList[i]); {z - ElementDefinition}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseStructureDefinitionDifferential(element : IXmlDomElement; path : string) : TFhirStructureDefinitionDifferential;
var
  child : IXMLDOMElement;
begin
  result := TFhirStructureDefinitionDifferential.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'element') then
        result.elementList.Add(ParseElementDefinition(child, path+'/element')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionDifferential(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionDifferential);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.elementList.Count - 1 do
    ComposeElementDefinition(xml, 'element', elem.elementList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseStructureDefinitionDifferential(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinitionDifferential(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinitionDifferential(jsn : TJsonObject) : TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseElementDefinition);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeStructureDefinitionDifferential(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionDifferential; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.elementList.Count > 0 then
  begin
    json.valueArray('element');
    for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(json, '',elem.elementList[i]); {z - ElementDefinition}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseStructureDefinition(element : IXmlDomElement; path : string) : TFhirStructureDefinition;
var
  child : IXMLDOMElement;
begin
  result := TFhirStructureDefinition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'useContext') then
        result.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.baseName = 'display') then
        result.displayElement := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseStructureDefinitionContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'requirements') then
        result.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'copyright') then
        result.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.baseName = 'code') then
        result.codeList.Add(ParseCoding(child, path+'/code')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatus, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'fhirVersion') then
        result.fhirVersionElement := ParseId(child, path+'/fhirVersion') {b}
      else if (child.baseName = 'mapping') then
        result.mappingList.Add(ParseStructureDefinitionMapping(child, path+'/mapping')){y.2}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirStructureDefinitionType, path+'/type', child){1a}
      else if (child.baseName = 'abstract') then
        result.abstractElement := ParseBoolean(child, path+'/abstract') {b}
      else if (child.baseName = 'contextType') then
        result.contextTypeElement := ParseEnum(CODES_TFhirExtensionContext, path+'/contextType', child){1a}
      else if (child.baseName = 'context') then
        result.contextList.Add(ParseString(child, path+'/context')){y.2}
      else if (child.baseName = 'base') then
        result.baseElement := ParseUri(child, path+'/base') {b}
      else if (child.baseName = 'snapshot') then
        result.snapshot := ParseStructureDefinitionSnapshot(child, path+'/snapshot') {b}
      else if (child.baseName = 'differential') then
        result.differential := ParseStructureDefinitionDifferential(child, path+'/differential') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinition(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeString(xml, 'version', elem.versionElement);{x.2}
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  for i := 0 to elem.useContextList.Count - 1 do
    ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  ComposeString(xml, 'display', elem.displayElement);{x.2}
  ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  for i := 0 to elem.contactList.Count - 1 do
    ComposeStructureDefinitionContact(xml, 'contact', elem.contactList[i]);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeString(xml, 'requirements', elem.requirementsElement);{x.2}
  ComposeString(xml, 'copyright', elem.copyrightElement);{x.2}
  for i := 0 to elem.codeList.Count - 1 do
    ComposeCoding(xml, 'code', elem.codeList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus);
  ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeId(xml, 'fhirVersion', elem.fhirVersionElement);{x.2}
  for i := 0 to elem.mappingList.Count - 1 do
    ComposeStructureDefinitionMapping(xml, 'mapping', elem.mappingList[i]);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirStructureDefinitionType);
  ComposeBoolean(xml, 'abstract', elem.abstractElement);{x.2}
  ComposeEnum(xml, 'contextType', elem.ContextTypeElement, CODES_TFhirExtensionContext);
  for i := 0 to elem.contextList.Count - 1 do
    ComposeString(xml, 'context', elem.contextList[i]);
  ComposeUri(xml, 'base', elem.baseElement);{x.2}
  ComposeStructureDefinitionSnapshot(xml, 'snapshot', elem.snapshot);{x.2}
  ComposeStructureDefinitionDifferential(xml, 'differential', elem.differential);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseStructureDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinition(jsn : TJsonObject) : TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseStructureDefinitionContact);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCoding);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatus);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('fhirVersion') or jsn.has('_fhirVersion') then
        result.fhirVersionElement := ParseId(jsn['fhirVersion'], jsn.vObj['_fhirVersion']);{q}
    if jsn.has('mapping') then
      iterateArray(jsn.vArr['mapping'], result.mappingList, parseStructureDefinitionMapping);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirStructureDefinitionType);
    if jsn.has('abstract') or jsn.has('_abstract') then
        result.abstractElement := ParseBoolean(jsn['abstract'], jsn.vObj['_abstract']);{q}
    if jsn.has('contextType') or jsn.has('_contextType')  then
      result.contextTypeElement := parseEnum(jsn['contextType'], jsn.vObj['_contextType'], CODES_TFhirExtensionContext);
      if jsn.has('context') or jsn.has('_context') then
      iteratePrimitiveArray(jsn.vArr['context'], jsn.vArr['_context'], result.contextList, parseString);
    if jsn.has('base') or jsn.has('_base') then
        result.baseElement := ParseUri(jsn['base'], jsn.vObj['_base']);{q}
    if jsn.has('snapshot') then
        result.snapshot := ParseStructureDefinitionSnapshot(jsn.vObj['snapshot']);{q}
    if jsn.has('differential') then
        result.differential := ParseStructureDefinitionDifferential(jsn.vObj['differential']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeStructureDefinition(json : TJSONWriter; name : string; elem : TFhirStructureDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'version', elem.versionElement, false);
  ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if elem.useContextList.Count > 0 then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.useContextList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'display', elem.displayElement, false);
  ComposeStringProps(json, 'display', elem.displayElement, false);
  ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if elem.contactList.Count > 0 then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeStructureDefinitionContact(json, '',elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  if elem.codeList.Count > 0 then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(json, '',elem.codeList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus, false);
  ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeIdValue(json, 'fhirVersion', elem.fhirVersionElement, false);
  ComposeIdProps(json, 'fhirVersion', elem.fhirVersionElement, false);
  if elem.mappingList.Count > 0 then
  begin
    json.valueArray('mapping');
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeStructureDefinitionMapping(json, '',elem.mappingList[i]); {z - }
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirStructureDefinitionType, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirStructureDefinitionType, false);
  ComposeBooleanValue(json, 'abstract', elem.abstractElement, false);
  ComposeBooleanProps(json, 'abstract', elem.abstractElement, false);
  ComposeEnumValue(json, 'contextType', elem.ContextTypeElement, CODES_TFhirExtensionContext, false);
  ComposeEnumProps(json, 'contextType', elem.ContextTypeElement, CODES_TFhirExtensionContext, false);
  if elem.contextList.Count > 0 then
begin
    json.valueArray('context');
    ext := false;
    for i := 0 to elem.contextList.Count - 1 do
begin
      ext := ext or ((elem.contextList[i].id <> '') or (elem.contextList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.contextList[i], true);
  end;
    json.FinishArray;
    if ext then
begin
      json.valueArray('_context');
      for i := 0 to elem.contextList.Count - 1 do
        ComposeStringProps(json, '',elem.contextList[i], true);
    json.FinishArray;
  end;
end;
  ComposeUriValue(json, 'base', elem.baseElement, false);
  ComposeUriProps(json, 'base', elem.baseElement, false);
  ComposeStructureDefinitionSnapshot(json, 'snapshot', elem.snapshot); {a}
  ComposeStructureDefinitionDifferential(json, 'differential', elem.differential); {a}
end;

function TFHIRXmlParser.ParseSubscriptionChannel(element : IXmlDomElement; path : string) : TFhirSubscriptionChannel;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubscriptionChannel.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirSubscriptionChannelType, path+'/type', child){1a}
      else if (child.baseName = 'endpoint') then
        result.endpointElement := ParseUri(child, path+'/endpoint') {b}
      else if (child.baseName = 'payload') then
        result.payloadElement := ParseString(child, path+'/payload') {b}
      else if (child.baseName = 'header') then
        result.headerElement := ParseString(child, path+'/header') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionChannel(xml : TXmlBuilder; name : string; elem : TFhirSubscriptionChannel);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirSubscriptionChannelType);
  ComposeUri(xml, 'endpoint', elem.endpointElement);{x.2}
  ComposeString(xml, 'payload', elem.payloadElement);{x.2}
  ComposeString(xml, 'header', elem.headerElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubscriptionChannel(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubscriptionChannel(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubscriptionChannel(jsn : TJsonObject) : TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirSubscriptionChannelType);
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpointElement := ParseUri(jsn['endpoint'], jsn.vObj['_endpoint']);{q}
    if jsn.has('payload') or jsn.has('_payload') then
        result.payloadElement := ParseString(jsn['payload'], jsn.vObj['_payload']);{q}
    if jsn.has('header') or jsn.has('_header') then
        result.headerElement := ParseString(jsn['header'], jsn.vObj['_header']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubscriptionChannel(json : TJSONWriter; name : string; elem : TFhirSubscriptionChannel; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirSubscriptionChannelType, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirSubscriptionChannelType, false);
  ComposeUriValue(json, 'endpoint', elem.endpointElement, false);
  ComposeUriProps(json, 'endpoint', elem.endpointElement, false);
  ComposeStringValue(json, 'payload', elem.payloadElement, false);
  ComposeStringProps(json, 'payload', elem.payloadElement, false);
  ComposeStringValue(json, 'header', elem.headerElement, false);
  ComposeStringProps(json, 'header', elem.headerElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseSubscription(element : IXmlDomElement; path : string) : TFhirSubscription;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubscription.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'criteria') then
        result.criteriaElement := ParseString(child, path+'/criteria') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseContactPoint(child, path+'/contact')){y.2}
      else if (child.baseName = 'reason') then
        result.reasonElement := ParseString(child, path+'/reason') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirSubscriptionStatus, path+'/status', child){1a}
      else if (child.baseName = 'error') then
        result.errorElement := ParseString(child, path+'/error') {b}
      else if (child.baseName = 'channel') then
        result.channel := ParseSubscriptionChannel(child, path+'/channel') {b}
      else if (child.baseName = 'end') then
        result.end_Element := ParseInstant(child, path+'/end') {b}
      else if (child.baseName = 'tag') then
        result.tagList.Add(ParseCoding(child, path+'/tag')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubscription(xml : TXmlBuilder; name : string; elem : TFhirSubscription);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeString(xml, 'criteria', elem.criteriaElement);{x.2}
  for i := 0 to elem.contactList.Count - 1 do
    ComposeContactPoint(xml, 'contact', elem.contactList[i]);
  ComposeString(xml, 'reason', elem.reasonElement);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirSubscriptionStatus);
  ComposeString(xml, 'error', elem.errorElement);{x.2}
  ComposeSubscriptionChannel(xml, 'channel', elem.channel);{x.2}
  ComposeInstant(xml, 'end', elem.end_Element);{x.2}
  for i := 0 to elem.tagList.Count - 1 do
    ComposeCoding(xml, 'tag', elem.tagList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubscription(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubscription(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubscription(jsn : TJsonObject) : TFhirSubscription;
begin
  result := TFhirSubscription.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('criteria') or jsn.has('_criteria') then
        result.criteriaElement := ParseString(jsn['criteria'], jsn.vObj['_criteria']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactPoint);
    if jsn.has('reason') or jsn.has('_reason') then
        result.reasonElement := ParseString(jsn['reason'], jsn.vObj['_reason']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirSubscriptionStatus);
    if jsn.has('error') or jsn.has('_error') then
        result.errorElement := ParseString(jsn['error'], jsn.vObj['_error']);{q}
    if jsn.has('channel') then
        result.channel := ParseSubscriptionChannel(jsn.vObj['channel']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := ParseInstant(jsn['end'], jsn.vObj['_end']);{q}
    if jsn.has('tag') then
      iterateArray(jsn.vArr['tag'], result.tagList, parseCoding);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubscription(json : TJSONWriter; name : string; elem : TFhirSubscription; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeStringValue(json, 'criteria', elem.criteriaElement, false);
  ComposeStringProps(json, 'criteria', elem.criteriaElement, false);
  if elem.contactList.Count > 0 then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(json, '',elem.contactList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'reason', elem.reasonElement, false);
  ComposeStringProps(json, 'reason', elem.reasonElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirSubscriptionStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirSubscriptionStatus, false);
  ComposeStringValue(json, 'error', elem.errorElement, false);
  ComposeStringProps(json, 'error', elem.errorElement, false);
  ComposeSubscriptionChannel(json, 'channel', elem.channel); {a}
  ComposeInstantValue(json, 'end', elem.end_Element, false);
  ComposeInstantProps(json, 'end', elem.end_Element, false);
  if elem.tagList.Count > 0 then
  begin
    json.valueArray('tag');
    for i := 0 to elem.tagList.Count - 1 do
      ComposeCoding(json, '',elem.tagList[i]); {z - Coding}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseSubstanceInstance(element : IXmlDomElement; path : string) : TFhirSubstanceInstance;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubstanceInstance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'expiry') then
        result.expiryElement := ParseDateTime(child, path+'/expiry') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubstanceInstance(xml : TXmlBuilder; name : string; elem : TFhirSubstanceInstance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeDateTime(xml, 'expiry', elem.expiryElement);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubstanceInstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceInstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceInstance(jsn : TJsonObject) : TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('expiry') or jsn.has('_expiry') then
        result.expiryElement := ParseDateTime(jsn['expiry'], jsn.vObj['_expiry']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubstanceInstance(json : TJSONWriter; name : string; elem : TFhirSubstanceInstance; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeDateTimeValue(json, 'expiry', elem.expiryElement, false);
  ComposeDateTimeProps(json, 'expiry', elem.expiryElement, false);
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseSubstanceIngredient(element : IXmlDomElement; path : string) : TFhirSubstanceIngredient;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubstanceIngredient.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'quantity') then
        result.quantity := ParseRatio(child, path+'/quantity') {b}
      else if (child.baseName = 'substance') then
        result.substance := ParseReference{TFhirSubstance}(child, path+'/substance') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubstanceIngredient(xml : TXmlBuilder; name : string; elem : TFhirSubstanceIngredient);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeRatio(xml, 'quantity', elem.quantity);{x.2}
  ComposeReference{TFhirSubstance}(xml, 'substance', elem.substance);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubstanceIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceIngredient(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceIngredient(jsn : TJsonObject) : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('quantity') then
        result.quantity := ParseRatio(jsn.vObj['quantity']);{q}
    if jsn.has('substance') then
        result.substance := ParseReference{TFhirSubstance}(jsn.vObj['substance']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubstanceIngredient(json : TJSONWriter; name : string; elem : TFhirSubstanceIngredient; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeRatio(json, 'quantity', elem.quantity); {a}
  ComposeReference{TFhirSubstance}(json, 'substance', elem.substance); {a}
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseSubstance(element : IXmlDomElement; path : string) : TFhirSubstance;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubstance.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'instance') then
        result.instance := ParseSubstanceInstance(child, path+'/instance') {b}
      else if (child.baseName = 'ingredient') then
        result.ingredientList.Add(ParseSubstanceIngredient(child, path+'/ingredient')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubstance(xml : TXmlBuilder; name : string; elem : TFhirSubstance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeSubstanceInstance(xml, 'instance', elem.instance);{x.2}
  for i := 0 to elem.ingredientList.Count - 1 do
    ComposeSubstanceIngredient(xml, 'ingredient', elem.ingredientList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstance(jsn : TJsonObject) : TFhirSubstance;
begin
  result := TFhirSubstance.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('instance') then
        result.instance := ParseSubstanceInstance(jsn.vObj['instance']);{q}
    if jsn.has('ingredient') then
      iterateArray(jsn.vArr['ingredient'], result.ingredientList, parseSubstanceIngredient);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubstance(json : TJSONWriter; name : string; elem : TFhirSubstance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeSubstanceInstance(json, 'instance', elem.instance); {a}
  if elem.ingredientList.Count > 0 then
  begin
    json.valueArray('ingredient');
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeSubstanceIngredient(json, '',elem.ingredientList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseSupplyDispense(element : IXmlDomElement; path : string) : TFhirSupplyDispense;
var
  child : IXMLDOMElement;
begin
  result := TFhirSupplyDispense.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirValuesetSupplyDispenseStatus, path+'/status', child){1a}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'suppliedItem') then
        result.suppliedItem := ParseReference{Resource}(child, path+'/suppliedItem') {b}
      else if (child.baseName = 'supplier') then
        result.supplier := ParseReference{TFhirPractitioner}(child, path+'/supplier') {b}
      else if (child.baseName = 'whenPrepared') then
        result.whenPrepared := ParsePeriod(child, path+'/whenPrepared') {b}
      else if (child.baseName = 'whenHandedOver') then
        result.whenHandedOverElement := ParseDateTime(child, path+'/whenHandedOver') {b}
      else if (child.baseName = 'destination') then
        result.destination := ParseReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.baseName = 'receiver') then
        result.receiverList.Add(ParseReference{TFhirPractitioner}(child, path+'/receiver')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSupplyDispense(xml : TXmlBuilder; name : string; elem : TFhirSupplyDispense);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirValuesetSupplyDispenseStatus);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeReference{Resource}(xml, 'suppliedItem', elem.suppliedItem);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'supplier', elem.supplier);{x.2}
  ComposePeriod(xml, 'whenPrepared', elem.whenPrepared);{x.2}
  ComposeDateTime(xml, 'whenHandedOver', elem.whenHandedOverElement);{x.2}
  ComposeReference{TFhirLocation}(xml, 'destination', elem.destination);{x.2}
  for i := 0 to elem.receiverList.Count - 1 do
    ComposeReference{TFhirPractitioner}(xml, 'receiver', elem.receiverList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSupplyDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupplyDispense(jsn)); {2}
end;

function TFHIRJsonParser.ParseSupplyDispense(jsn : TJsonObject) : TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirValuesetSupplyDispenseStatus);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('suppliedItem') then
        result.suppliedItem := ParseReference{Resource}(jsn.vObj['suppliedItem']);{q}
    if jsn.has('supplier') then
        result.supplier := ParseReference{TFhirPractitioner}(jsn.vObj['supplier']);{q}
    if jsn.has('whenPrepared') then
        result.whenPrepared := ParsePeriod(jsn.vObj['whenPrepared']);{q}
    if jsn.has('whenHandedOver') or jsn.has('_whenHandedOver') then
        result.whenHandedOverElement := ParseDateTime(jsn['whenHandedOver'], jsn.vObj['_whenHandedOver']);{q}
    if jsn.has('destination') then
        result.destination := ParseReference{TFhirLocation}(jsn.vObj['destination']);{q}
    if jsn.has('receiver') then
      iterateArray(jsn.vArr['receiver'], result.receiverList, parseReference{TFhirPractitioner});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSupplyDispense(json : TJSONWriter; name : string; elem : TFhirSupplyDispense; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirValuesetSupplyDispenseStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirValuesetSupplyDispenseStatus, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeReference{Resource}(json, 'suppliedItem', elem.suppliedItem); {a}
  ComposeReference{TFhirPractitioner}(json, 'supplier', elem.supplier); {a}
  ComposePeriod(json, 'whenPrepared', elem.whenPrepared); {a}
  ComposeDateTimeValue(json, 'whenHandedOver', elem.whenHandedOverElement, false);
  ComposeDateTimeProps(json, 'whenHandedOver', elem.whenHandedOverElement, false);
  ComposeReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  if elem.receiverList.Count > 0 then
  begin
    json.valueArray('receiver');
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '',elem.receiverList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseSupply(element : IXmlDomElement; path : string) : TFhirSupply;
var
  child : IXMLDOMElement;
begin
  result := TFhirSupply.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'kind') then
        result.kind := ParseCodeableConcept(child, path+'/kind') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirValuesetSupplyStatus, path+'/status', child){1a}
      else if (child.baseName = 'orderedItem') then
        result.orderedItem := ParseReference{Resource}(child, path+'/orderedItem') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'dispense') then
        result.dispenseList.Add(ParseSupplyDispense(child, path+'/dispense')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSupply(xml : TXmlBuilder; name : string; elem : TFhirSupply);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeCodeableConcept(xml, 'kind', elem.kind);{x.2}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirValuesetSupplyStatus);
  ComposeReference{Resource}(xml, 'orderedItem', elem.orderedItem);{x.2}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  for i := 0 to elem.dispenseList.Count - 1 do
    ComposeSupplyDispense(xml, 'dispense', elem.dispenseList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSupply(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupply(jsn)); {2}
end;

function TFHIRJsonParser.ParseSupply(jsn : TJsonObject) : TFhirSupply;
begin
  result := TFhirSupply.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('kind') then
        result.kind := ParseCodeableConcept(jsn.vObj['kind']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirValuesetSupplyStatus);
    if jsn.has('orderedItem') then
        result.orderedItem := ParseReference{Resource}(jsn.vObj['orderedItem']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('dispense') then
      iterateArray(jsn.vArr['dispense'], result.dispenseList, parseSupplyDispense);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSupply(json : TJSONWriter; name : string; elem : TFhirSupply; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeCodeableConcept(json, 'kind', elem.kind); {a}
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirValuesetSupplyStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirValuesetSupplyStatus, false);
  ComposeReference{Resource}(json, 'orderedItem', elem.orderedItem); {a}
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if elem.dispenseList.Count > 0 then
  begin
    json.valueArray('dispense');
    for i := 0 to elem.dispenseList.Count - 1 do
      ComposeSupplyDispense(json, '',elem.dispenseList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseSupplyDelivery(element : IXmlDomElement; path : string) : TFhirSupplyDelivery;
var
  child : IXMLDOMElement;
begin
  result := TFhirSupplyDelivery.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirValuesetSupplydeliveryStatus, path+'/status', child){1a}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'suppliedItem') then
        result.suppliedItem := ParseReference{Resource}(child, path+'/suppliedItem') {b}
      else if (child.baseName = 'supplier') then
        result.supplier := ParseReference{TFhirPractitioner}(child, path+'/supplier') {b}
      else if (child.baseName = 'whenPrepared') then
        result.whenPrepared := ParsePeriod(child, path+'/whenPrepared') {b}
      else if (child.baseName = 'time') then
        result.timeElement := ParseDateTime(child, path+'/time') {b}
      else if (child.baseName = 'destination') then
        result.destination := ParseReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.baseName = 'receiver') then
        result.receiverList.Add(ParseReference{TFhirPractitioner}(child, path+'/receiver')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSupplyDelivery(xml : TXmlBuilder; name : string; elem : TFhirSupplyDelivery);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirValuesetSupplydeliveryStatus);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  ComposeReference{Resource}(xml, 'suppliedItem', elem.suppliedItem);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'supplier', elem.supplier);{x.2}
  ComposePeriod(xml, 'whenPrepared', elem.whenPrepared);{x.2}
  ComposeDateTime(xml, 'time', elem.timeElement);{x.2}
  ComposeReference{TFhirLocation}(xml, 'destination', elem.destination);{x.2}
  for i := 0 to elem.receiverList.Count - 1 do
    ComposeReference{TFhirPractitioner}(xml, 'receiver', elem.receiverList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSupplyDelivery(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupplyDelivery(jsn)); {2}
end;

function TFHIRJsonParser.ParseSupplyDelivery(jsn : TJsonObject) : TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirValuesetSupplydeliveryStatus);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('suppliedItem') then
        result.suppliedItem := ParseReference{Resource}(jsn.vObj['suppliedItem']);{q}
    if jsn.has('supplier') then
        result.supplier := ParseReference{TFhirPractitioner}(jsn.vObj['supplier']);{q}
    if jsn.has('whenPrepared') then
        result.whenPrepared := ParsePeriod(jsn.vObj['whenPrepared']);{q}
    if jsn.has('time') or jsn.has('_time') then
        result.timeElement := ParseDateTime(jsn['time'], jsn.vObj['_time']);{q}
    if jsn.has('destination') then
        result.destination := ParseReference{TFhirLocation}(jsn.vObj['destination']);{q}
    if jsn.has('receiver') then
      iterateArray(jsn.vArr['receiver'], result.receiverList, parseReference{TFhirPractitioner});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSupplyDelivery(json : TJSONWriter; name : string; elem : TFhirSupplyDelivery; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirValuesetSupplydeliveryStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirValuesetSupplydeliveryStatus, false);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeReference{Resource}(json, 'suppliedItem', elem.suppliedItem); {a}
  ComposeReference{TFhirPractitioner}(json, 'supplier', elem.supplier); {a}
  ComposePeriod(json, 'whenPrepared', elem.whenPrepared); {a}
  ComposeDateTimeValue(json, 'time', elem.timeElement, false);
  ComposeDateTimeProps(json, 'time', elem.timeElement, false);
  ComposeReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  if elem.receiverList.Count > 0 then
  begin
    json.valueArray('receiver');
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '',elem.receiverList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseSupplyRequest(element : IXmlDomElement; path : string) : TFhirSupplyRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirSupplyRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'kind') then
        result.kind := ParseCodeableConcept(child, path+'/kind') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirValuesetSupplyrequestStatus, path+'/status', child){1a}
      else if (child.baseName = 'orderedItem') then
        result.orderedItem := ParseReference{Resource}(child, path+'/orderedItem') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSupplyRequest(xml : TXmlBuilder; name : string; elem : TFhirSupplyRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeCodeableConcept(xml, 'kind', elem.kind);{x.2}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirValuesetSupplyrequestStatus);
  ComposeReference{Resource}(xml, 'orderedItem', elem.orderedItem);{x.2}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSupplyRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupplyRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseSupplyRequest(jsn : TJsonObject) : TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('kind') then
        result.kind := ParseCodeableConcept(jsn.vObj['kind']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirValuesetSupplyrequestStatus);
    if jsn.has('orderedItem') then
        result.orderedItem := ParseReference{Resource}(jsn.vObj['orderedItem']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSupplyRequest(json : TJSONWriter; name : string; elem : TFhirSupplyRequest; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeCodeableConcept(json, 'kind', elem.kind); {a}
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirValuesetSupplyrequestStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirValuesetSupplyrequestStatus, false);
  ComposeReference{Resource}(json, 'orderedItem', elem.orderedItem); {a}
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
end;

function TFHIRXmlParser.ParseValueSetContact(element : IXmlDomElement; path : string) : TFhirValueSetContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetContact(xml : TXmlBuilder; name : string; elem : TFhirValueSetContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetContact(jsn : TJsonObject) : TFhirValueSetContact;
begin
  result := TFhirValueSetContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetContact(json : TJSONWriter; name : string; elem : TFhirValueSetContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '',elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetDefine(element : IXmlDomElement; path : string) : TFhirValueSetDefine;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetDefine.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'caseSensitive') then
        result.caseSensitiveElement := ParseBoolean(child, path+'/caseSensitive') {b}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseValueSetDefineConcept(child, path+'/concept')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetDefine(xml : TXmlBuilder; name : string; elem : TFhirValueSetDefine);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.systemElement);{x.2}
  ComposeString(xml, 'version', elem.versionElement);{x.2}
  ComposeBoolean(xml, 'caseSensitive', elem.caseSensitiveElement);{x.2}
  for i := 0 to elem.conceptList.Count - 1 do
    ComposeValueSetDefineConcept(xml, 'concept', elem.conceptList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetDefine(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetDefine(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetDefine(jsn : TJsonObject) : TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('caseSensitive') or jsn.has('_caseSensitive') then
        result.caseSensitiveElement := ParseBoolean(jsn['caseSensitive'], jsn.vObj['_caseSensitive']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseValueSetDefineConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetDefine(json : TJSONWriter; name : string; elem : TFhirValueSetDefine; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'system', elem.systemElement, false);
  ComposeUriProps(json, 'system', elem.systemElement, false);
  ComposeStringValue(json, 'version', elem.versionElement, false);
  ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeBooleanValue(json, 'caseSensitive', elem.caseSensitiveElement, false);
  ComposeBooleanProps(json, 'caseSensitive', elem.caseSensitiveElement, false);
  if elem.conceptList.Count > 0 then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetDefineConcept(json, '',elem.conceptList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetDefineConcept(element : IXmlDomElement; path : string) : TFhirValueSetDefineConcept;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetDefineConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'abstract') then
        result.abstractElement := ParseBoolean(child, path+'/abstract') {b}
      else if (child.baseName = 'display') then
        result.displayElement := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'definition') then
        result.definitionElement := ParseString(child, path+'/definition') {b}
      else if (child.baseName = 'designation') then
        result.designationList.Add(ParseValueSetDefineConceptDesignation(child, path+'/designation')){y.2}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseValueSetDefineConcept(child, path+'/concept')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetDefineConcept(xml : TXmlBuilder; name : string; elem : TFhirValueSetDefineConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.codeElement);{x.2}
  ComposeBoolean(xml, 'abstract', elem.abstractElement);{x.2}
  ComposeString(xml, 'display', elem.displayElement);{x.2}
  ComposeString(xml, 'definition', elem.definitionElement);{x.2}
  for i := 0 to elem.designationList.Count - 1 do
    ComposeValueSetDefineConceptDesignation(xml, 'designation', elem.designationList[i]);
  for i := 0 to elem.conceptList.Count - 1 do
    ComposeValueSetDefineConcept(xml, 'concept', elem.conceptList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetDefineConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetDefineConcept(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetDefineConcept(jsn : TJsonObject) : TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('abstract') or jsn.has('_abstract') then
        result.abstractElement := ParseBoolean(jsn['abstract'], jsn.vObj['_abstract']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := ParseString(jsn['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('designation') then
      iterateArray(jsn.vArr['designation'], result.designationList, parseValueSetDefineConceptDesignation);
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseValueSetDefineConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetDefineConcept(json : TJSONWriter; name : string; elem : TFhirValueSetDefineConcept; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  ComposeBooleanValue(json, 'abstract', elem.abstractElement, false);
  ComposeBooleanProps(json, 'abstract', elem.abstractElement, false);
  ComposeStringValue(json, 'display', elem.displayElement, false);
  ComposeStringProps(json, 'display', elem.displayElement, false);
  ComposeStringValue(json, 'definition', elem.definitionElement, false);
  ComposeStringProps(json, 'definition', elem.definitionElement, false);
  if elem.designationList.Count > 0 then
  begin
    json.valueArray('designation');
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetDefineConceptDesignation(json, '',elem.designationList[i]); {z - }
    json.FinishArray;
  end;
  if elem.conceptList.Count > 0 then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetDefineConcept(json, '',elem.conceptList[i]); {z - @ValueSet.define.concept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetDefineConceptDesignation(element : IXmlDomElement; path : string) : TFhirValueSetDefineConceptDesignation;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetDefineConceptDesignation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'language') then
        result.languageElement := ParseCode(child, path+'/language') {b}
      else if (child.baseName = 'use') then
        result.use := ParseCoding(child, path+'/use') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseString(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetDefineConceptDesignation(xml : TXmlBuilder; name : string; elem : TFhirValueSetDefineConceptDesignation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'language', elem.languageElement);{x.2}
  ComposeCoding(xml, 'use', elem.use);{x.2}
  ComposeString(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetDefineConceptDesignation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetDefineConceptDesignation(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetDefineConceptDesignation(jsn : TJsonObject) : TFhirValueSetDefineConceptDesignation;
begin
  result := TFhirValueSetDefineConceptDesignation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('language') or jsn.has('_language') then
        result.languageElement := ParseCode(jsn['language'], jsn.vObj['_language']);{q}
    if jsn.has('use') then
        result.use := ParseCoding(jsn.vObj['use']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetDefineConceptDesignation(json : TJSONWriter; name : string; elem : TFhirValueSetDefineConceptDesignation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'language', elem.languageElement, false);
  ComposeCodeProps(json, 'language', elem.languageElement, false);
  ComposeCoding(json, 'use', elem.use); {a}
  ComposeStringValue(json, 'value', elem.valueElement, false);
  ComposeStringProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetCompose(element : IXmlDomElement; path : string) : TFhirValueSetCompose;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetCompose.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'import') then
        result.importList.Add(ParseUri(child, path+'/import')){y.2}
      else if (child.baseName = 'include') then
        result.includeList.Add(ParseValueSetComposeInclude(child, path+'/include')){y.2}
      else if (child.baseName = 'exclude') then
        result.excludeList.Add(ParseValueSetComposeInclude(child, path+'/exclude')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetCompose(xml : TXmlBuilder; name : string; elem : TFhirValueSetCompose);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.importList.Count - 1 do
    ComposeUri(xml, 'import', elem.importList[i]);
  for i := 0 to elem.includeList.Count - 1 do
    ComposeValueSetComposeInclude(xml, 'include', elem.includeList[i]);
  for i := 0 to elem.excludeList.Count - 1 do
    ComposeValueSetComposeInclude(xml, 'exclude', elem.excludeList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetCompose(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetCompose(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetCompose(jsn : TJsonObject) : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('import') or jsn.has('_import') then
      iteratePrimitiveArray(jsn.vArr['import'], jsn.vArr['_import'], result.importList, parseUri);
    if jsn.has('include') then
      iterateArray(jsn.vArr['include'], result.includeList, parseValueSetComposeInclude);
    if jsn.has('exclude') then
      iterateArray(jsn.vArr['exclude'], result.excludeList, parseValueSetComposeInclude);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetCompose(json : TJSONWriter; name : string; elem : TFhirValueSetCompose; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.importList.Count > 0 then
  begin
    json.valueArray('import');
    ext := false;
    for i := 0 to elem.importList.Count - 1 do
    begin
      ext := ext or ((elem.importList[i].id <> '') or (elem.importList[i].hasExtensionList));
      ComposeUriValue(json, '',elem.importList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_import');
      for i := 0 to elem.importList.Count - 1 do
        ComposeUriProps(json, '',elem.importList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.includeList.Count > 0 then
  begin
    json.valueArray('include');
    for i := 0 to elem.includeList.Count - 1 do
      ComposeValueSetComposeInclude(json, '',elem.includeList[i]); {z - }
    json.FinishArray;
  end;
  if elem.excludeList.Count > 0 then
  begin
    json.valueArray('exclude');
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeValueSetComposeInclude(json, '',elem.excludeList[i]); {z - @ValueSet.compose.include}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetComposeInclude(element : IXmlDomElement; path : string) : TFhirValueSetComposeInclude;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseValueSetComposeIncludeConcept(child, path+'/concept')){y.2}
      else if (child.baseName = 'filter') then
        result.filterList.Add(ParseValueSetComposeIncludeFilter(child, path+'/filter')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeInclude(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeInclude);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.systemElement);{x.2}
  ComposeString(xml, 'version', elem.versionElement);{x.2}
  for i := 0 to elem.conceptList.Count - 1 do
    ComposeValueSetComposeIncludeConcept(xml, 'concept', elem.conceptList[i]);
  for i := 0 to elem.filterList.Count - 1 do
    ComposeValueSetComposeIncludeFilter(xml, 'filter', elem.filterList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetComposeInclude(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeInclude(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetComposeInclude(jsn : TJsonObject) : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseValueSetComposeIncludeConcept);
    if jsn.has('filter') then
      iterateArray(jsn.vArr['filter'], result.filterList, parseValueSetComposeIncludeFilter);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeInclude(json : TJSONWriter; name : string; elem : TFhirValueSetComposeInclude; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'system', elem.systemElement, false);
  ComposeUriProps(json, 'system', elem.systemElement, false);
  ComposeStringValue(json, 'version', elem.versionElement, false);
  ComposeStringProps(json, 'version', elem.versionElement, false);
  if elem.conceptList.Count > 0 then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetComposeIncludeConcept(json, '',elem.conceptList[i]); {z - }
    json.FinishArray;
  end;
  if elem.filterList.Count > 0 then
  begin
    json.valueArray('filter');
    for i := 0 to elem.filterList.Count - 1 do
      ComposeValueSetComposeIncludeFilter(json, '',elem.filterList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeConcept(element : IXmlDomElement; path : string) : TFhirValueSetComposeIncludeConcept;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'display') then
        result.displayElement := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'designation') then
        result.designationList.Add(ParseValueSetDefineConceptDesignation(child, path+'/designation')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeConcept(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.codeElement);{x.2}
  ComposeString(xml, 'display', elem.displayElement);{x.2}
  for i := 0 to elem.designationList.Count - 1 do
    ComposeValueSetDefineConceptDesignation(xml, 'designation', elem.designationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeIncludeConcept(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetComposeIncludeConcept(jsn : TJsonObject) : TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('designation') then
      iterateArray(jsn.vArr['designation'], result.designationList, parseValueSetDefineConceptDesignation);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeIncludeConcept(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeConcept; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  ComposeStringValue(json, 'display', elem.displayElement, false);
  ComposeStringProps(json, 'display', elem.displayElement, false);
  if elem.designationList.Count > 0 then
  begin
    json.valueArray('designation');
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetDefineConceptDesignation(json, '',elem.designationList[i]); {z - @ValueSet.define.concept.designation}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeFilter(element : IXmlDomElement; path : string) : TFhirValueSetComposeIncludeFilter;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'property') then
        result.property_Element := ParseCode(child, path+'/property') {b}
      else if (child.baseName = 'op') then
        result.opElement := ParseEnum(CODES_TFhirFilterOperator, path+'/op', child){1a}
      else if (child.baseName = 'value') then
        result.valueElement := ParseCode(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeFilter(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeFilter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'property', elem.property_Element);{x.2}
  ComposeEnum(xml, 'op', elem.OpElement, CODES_TFhirFilterOperator);
  ComposeCode(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeFilter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeIncludeFilter(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetComposeIncludeFilter(jsn : TJsonObject) : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('property') or jsn.has('_property') then
        result.property_Element := ParseCode(jsn['property'], jsn.vObj['_property']);{q}
    if jsn.has('op') or jsn.has('_op')  then
      result.opElement := parseEnum(jsn['op'], jsn.vObj['_op'], CODES_TFhirFilterOperator);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseCode(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeIncludeFilter(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeFilter; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'property', elem.property_Element, false);
  ComposeCodeProps(json, 'property', elem.property_Element, false);
  ComposeEnumValue(json, 'op', elem.OpElement, CODES_TFhirFilterOperator, false);
  ComposeEnumProps(json, 'op', elem.OpElement, CODES_TFhirFilterOperator, false);
  ComposeCodeValue(json, 'value', elem.valueElement, false);
  ComposeCodeProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetExpansion(element : IXmlDomElement; path : string) : TFhirValueSetExpansion;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetExpansion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierElement := ParseUri(child, path+'/identifier') {b}
      else if (child.baseName = 'timestamp') then
        result.timestampElement := ParseDateTime(child, path+'/timestamp') {b}
      else if (child.baseName = 'parameter') then
        result.parameterList.Add(ParseValueSetExpansionParameter(child, path+'/parameter')){y.2}
      else if (child.baseName = 'contains') then
        result.containsList.Add(ParseValueSetExpansionContains(child, path+'/contains')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansion(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansion);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'identifier', elem.identifierElement);{x.2}
  ComposeDateTime(xml, 'timestamp', elem.timestampElement);{x.2}
  for i := 0 to elem.parameterList.Count - 1 do
    ComposeValueSetExpansionParameter(xml, 'parameter', elem.parameterList[i]);
  for i := 0 to elem.containsList.Count - 1 do
    ComposeValueSetExpansionContains(xml, 'contains', elem.containsList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetExpansion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetExpansion(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetExpansion(jsn : TJsonObject) : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierElement := ParseUri(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('timestamp') or jsn.has('_timestamp') then
        result.timestampElement := ParseDateTime(jsn['timestamp'], jsn.vObj['_timestamp']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseValueSetExpansionParameter);
    if jsn.has('contains') then
      iterateArray(jsn.vArr['contains'], result.containsList, parseValueSetExpansionContains);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetExpansion(json : TJSONWriter; name : string; elem : TFhirValueSetExpansion; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'identifier', elem.identifierElement, false);
  ComposeUriProps(json, 'identifier', elem.identifierElement, false);
  ComposeDateTimeValue(json, 'timestamp', elem.timestampElement, false);
  ComposeDateTimeProps(json, 'timestamp', elem.timestampElement, false);
  if elem.parameterList.Count > 0 then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeValueSetExpansionParameter(json, '',elem.parameterList[i]); {z - }
      json.FinishArray;
    end;
  if elem.containsList.Count > 0 then
  begin
    json.valueArray('contains');
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(json, '',elem.containsList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetExpansionParameter(element : IXmlDomElement; path : string) : TFhirValueSetExpansionParameter;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetExpansionParameter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.baseName = 'valueInteger') then
        result.value := ParseInteger(child, path+'/valueInteger'){x.3}
      else if (child.baseName = 'valueDecimal') then
        result.value := ParseDecimal(child, path+'/valueDecimal'){x.3}
      else if (child.baseName = 'valueUri') then
        result.value := ParseUri(child, path+'/valueUri'){x.3}
      else if (child.baseName = 'valueCode') then
        result.value := ParseCode(child, path+'/valueCode'){x.3}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionParameter(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansionParameter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (elem.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value))
  else if (elem.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetExpansionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetExpansionParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetExpansionParameter(jsn : TJsonObject) : TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := parseDecimal(jsn['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
      result.value := parseUri(jsn['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('valueCode') or jsn.has('_valueCode') then
      result.value := parseCode(jsn['valueCode'], jsn.vObj['_valueCode']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetExpansionParameter(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionParameter; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end
  else if (elem.value is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false);
  end
  else if (elem.value is TFhirCode) then 
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false);
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetExpansionContains(element : IXmlDomElement; path : string) : TFhirValueSetExpansionContains;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'abstract') then
        result.abstractElement := ParseBoolean(child, path+'/abstract') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'display') then
        result.displayElement := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'contains') then
        result.containsList.Add(ParseValueSetExpansionContains(child, path+'/contains')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionContains(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansionContains);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.systemElement);{x.2}
  ComposeBoolean(xml, 'abstract', elem.abstractElement);{x.2}
  ComposeString(xml, 'version', elem.versionElement);{x.2}
  ComposeCode(xml, 'code', elem.codeElement);{x.2}
  ComposeString(xml, 'display', elem.displayElement);{x.2}
  for i := 0 to elem.containsList.Count - 1 do
    ComposeValueSetExpansionContains(xml, 'contains', elem.containsList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetExpansionContains(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetExpansionContains(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetExpansionContains(jsn : TJsonObject) : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('abstract') or jsn.has('_abstract') then
        result.abstractElement := ParseBoolean(jsn['abstract'], jsn.vObj['_abstract']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('contains') then
      iterateArray(jsn.vArr['contains'], result.containsList, parseValueSetExpansionContains);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetExpansionContains(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionContains; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'system', elem.systemElement, false);
  ComposeUriProps(json, 'system', elem.systemElement, false);
  ComposeBooleanValue(json, 'abstract', elem.abstractElement, false);
  ComposeBooleanProps(json, 'abstract', elem.abstractElement, false);
  ComposeStringValue(json, 'version', elem.versionElement, false);
  ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  ComposeStringValue(json, 'display', elem.displayElement, false);
  ComposeStringProps(json, 'display', elem.displayElement, false);
  if elem.containsList.Count > 0 then
  begin
    json.valueArray('contains');
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(json, '',elem.containsList[i]); {z - @ValueSet.expansion.contains}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseValueSet(element : IXmlDomElement; path : string) : TFhirValueSet;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSet.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'useContext') then
        result.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.baseName = 'immutable') then
        result.immutableElement := ParseBoolean(child, path+'/immutable') {b}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseValueSetContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'requirements') then
        result.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'copyright') then
        result.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatus, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'extensible') then
        result.extensibleElement := ParseBoolean(child, path+'/extensible') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'lockedDate') then
        result.lockedDateElement := ParseDate(child, path+'/lockedDate') {b}
      else if (child.baseName = 'define') then
        result.define := ParseValueSetDefine(child, path+'/define') {b}
      else if (child.baseName = 'compose') then
        result.compose := ParseValueSetCompose(child, path+'/compose') {b}
      else if (child.baseName = 'expansion') then
        result.expansion := ParseValueSetExpansion(child, path+'/expansion') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSet(xml : TXmlBuilder; name : string; elem : TFhirValueSet);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  ComposeString(xml, 'version', elem.versionElement);{x.2}
  ComposeString(xml, 'name', elem.nameElement);{x.2}
  for i := 0 to elem.useContextList.Count - 1 do
    ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  ComposeBoolean(xml, 'immutable', elem.immutableElement);{x.2}
  ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  for i := 0 to elem.contactList.Count - 1 do
    ComposeValueSetContact(xml, 'contact', elem.contactList[i]);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  ComposeString(xml, 'requirements', elem.requirementsElement);{x.2}
  ComposeString(xml, 'copyright', elem.copyrightElement);{x.2}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus);
  ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2}
  ComposeBoolean(xml, 'extensible', elem.extensibleElement);{x.2}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  ComposeDate(xml, 'lockedDate', elem.lockedDateElement);{x.2}
  ComposeValueSetDefine(xml, 'define', elem.define);{x.2}
  ComposeValueSetCompose(xml, 'compose', elem.compose);{x.2}
  ComposeValueSetExpansion(xml, 'expansion', elem.expansion);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSet(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSet(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSet(jsn : TJsonObject) : TFhirValueSet;
begin
  result := TFhirValueSet.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('immutable') or jsn.has('_immutable') then
        result.immutableElement := ParseBoolean(jsn['immutable'], jsn.vObj['_immutable']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseValueSetContact);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatus);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('extensible') or jsn.has('_extensible') then
        result.extensibleElement := ParseBoolean(jsn['extensible'], jsn.vObj['_extensible']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('lockedDate') or jsn.has('_lockedDate') then
        result.lockedDateElement := ParseDate(jsn['lockedDate'], jsn.vObj['_lockedDate']);{q}
    if jsn.has('define') then
        result.define := ParseValueSetDefine(jsn.vObj['define']);{q}
    if jsn.has('compose') then
        result.compose := ParseValueSetCompose(jsn.vObj['compose']);{q}
    if jsn.has('expansion') then
        result.expansion := ParseValueSetExpansion(jsn.vObj['expansion']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSet(json : TJSONWriter; name : string; elem : TFhirValueSet; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeStringValue(json, 'version', elem.versionElement, false);
  ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if elem.useContextList.Count > 0 then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.useContextList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeBooleanValue(json, 'immutable', elem.immutableElement, false);
  ComposeBooleanProps(json, 'immutable', elem.immutableElement, false);
  ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if elem.contactList.Count > 0 then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeValueSetContact(json, '',elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatus, false);
  ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  ComposeBooleanValue(json, 'extensible', elem.extensibleElement, false);
  ComposeBooleanProps(json, 'extensible', elem.extensibleElement, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeDateValue(json, 'lockedDate', elem.lockedDateElement, false);
  ComposeDateProps(json, 'lockedDate', elem.lockedDateElement, false);
  ComposeValueSetDefine(json, 'define', elem.define); {a}
  ComposeValueSetCompose(json, 'compose', elem.compose); {a}
  ComposeValueSetExpansion(json, 'expansion', elem.expansion); {a}
end;

function TFHIRXmlParser.ParseVisionPrescriptionDispense(element : IXmlDomElement; path : string) : TFhirVisionPrescriptionDispense;
var
  child : IXMLDOMElement;
begin
  result := TFhirVisionPrescriptionDispense.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'product') then
        result.product := ParseCoding(child, path+'/product') {b}
      else if (child.baseName = 'eye') then
        result.eyeElement := ParseEnum(CODES_TFhirEyeCodes, path+'/eye', child){1a}
      else if (child.baseName = 'sphere') then
        result.sphereElement := ParseDecimal(child, path+'/sphere') {b}
      else if (child.baseName = 'cylinder') then
        result.cylinderElement := ParseDecimal(child, path+'/cylinder') {b}
      else if (child.baseName = 'axis') then
        result.axisElement := ParseInteger(child, path+'/axis') {b}
      else if (child.baseName = 'prism') then
        result.prismElement := ParseDecimal(child, path+'/prism') {b}
      else if (child.baseName = 'base') then
        result.baseElement := ParseEnum(CODES_TFhirBaseCodes, path+'/base', child){1a}
      else if (child.baseName = 'add') then
        result.addElement := ParseDecimal(child, path+'/add') {b}
      else if (child.baseName = 'power') then
        result.powerElement := ParseDecimal(child, path+'/power') {b}
      else if (child.baseName = 'backCurve') then
        result.backCurveElement := ParseDecimal(child, path+'/backCurve') {b}
      else if (child.baseName = 'diameter') then
        result.diameterElement := ParseDecimal(child, path+'/diameter') {b}
      else if (child.baseName = 'duration') then
        result.duration := ParseQuantity(child, path+'/duration') {b}
      else if (child.baseName = 'color') then
        result.colorElement := ParseString(child, path+'/color') {b}
      else if (child.baseName = 'brand') then
        result.brandElement := ParseString(child, path+'/brand') {b}
      else if (child.baseName = 'notes') then
        result.notesElement := ParseString(child, path+'/notes') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescriptionDispense(xml : TXmlBuilder; name : string; elem : TFhirVisionPrescriptionDispense);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'product', elem.product);{x.2}
  ComposeEnum(xml, 'eye', elem.EyeElement, CODES_TFhirEyeCodes);
  ComposeDecimal(xml, 'sphere', elem.sphereElement);{x.2}
  ComposeDecimal(xml, 'cylinder', elem.cylinderElement);{x.2}
  ComposeInteger(xml, 'axis', elem.axisElement);{x.2}
  ComposeDecimal(xml, 'prism', elem.prismElement);{x.2}
  ComposeEnum(xml, 'base', elem.BaseElement, CODES_TFhirBaseCodes);
  ComposeDecimal(xml, 'add', elem.addElement);{x.2}
  ComposeDecimal(xml, 'power', elem.powerElement);{x.2}
  ComposeDecimal(xml, 'backCurve', elem.backCurveElement);{x.2}
  ComposeDecimal(xml, 'diameter', elem.diameterElement);{x.2}
  ComposeQuantity(xml, 'duration', elem.duration);{x.2}
  ComposeString(xml, 'color', elem.colorElement);{x.2}
  ComposeString(xml, 'brand', elem.brandElement);{x.2}
  ComposeString(xml, 'notes', elem.notesElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseVisionPrescriptionDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseVisionPrescriptionDispense(jsn)); {2}
end;

function TFHIRJsonParser.ParseVisionPrescriptionDispense(jsn : TJsonObject) : TFhirVisionPrescriptionDispense;
begin
  result := TFhirVisionPrescriptionDispense.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('product') then
        result.product := ParseCoding(jsn.vObj['product']);{q}
    if jsn.has('eye') or jsn.has('_eye')  then
      result.eyeElement := parseEnum(jsn['eye'], jsn.vObj['_eye'], CODES_TFhirEyeCodes);
    if jsn.has('sphere') or jsn.has('_sphere') then
        result.sphereElement := ParseDecimal(jsn['sphere'], jsn.vObj['_sphere']);{q}
    if jsn.has('cylinder') or jsn.has('_cylinder') then
        result.cylinderElement := ParseDecimal(jsn['cylinder'], jsn.vObj['_cylinder']);{q}
    if jsn.has('axis') or jsn.has('_axis') then
        result.axisElement := ParseInteger(jsn['axis'], jsn.vObj['_axis']);{q}
    if jsn.has('prism') or jsn.has('_prism') then
        result.prismElement := ParseDecimal(jsn['prism'], jsn.vObj['_prism']);{q}
    if jsn.has('base') or jsn.has('_base')  then
      result.baseElement := parseEnum(jsn['base'], jsn.vObj['_base'], CODES_TFhirBaseCodes);
    if jsn.has('add') or jsn.has('_add') then
        result.addElement := ParseDecimal(jsn['add'], jsn.vObj['_add']);{q}
    if jsn.has('power') or jsn.has('_power') then
        result.powerElement := ParseDecimal(jsn['power'], jsn.vObj['_power']);{q}
    if jsn.has('backCurve') or jsn.has('_backCurve') then
        result.backCurveElement := ParseDecimal(jsn['backCurve'], jsn.vObj['_backCurve']);{q}
    if jsn.has('diameter') or jsn.has('_diameter') then
        result.diameterElement := ParseDecimal(jsn['diameter'], jsn.vObj['_diameter']);{q}
    if jsn.has('duration') then
        result.duration := ParseQuantity(jsn.vObj['duration']);{q}
    if jsn.has('color') or jsn.has('_color') then
        result.colorElement := ParseString(jsn['color'], jsn.vObj['_color']);{q}
    if jsn.has('brand') or jsn.has('_brand') then
        result.brandElement := ParseString(jsn['brand'], jsn.vObj['_brand']);{q}
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesElement := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeVisionPrescriptionDispense(json : TJSONWriter; name : string; elem : TFhirVisionPrescriptionDispense; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'product', elem.product); {a}
  ComposeEnumValue(json, 'eye', elem.EyeElement, CODES_TFhirEyeCodes, false);
  ComposeEnumProps(json, 'eye', elem.EyeElement, CODES_TFhirEyeCodes, false);
  ComposeDecimalValue(json, 'sphere', elem.sphereElement, false);
  ComposeDecimalProps(json, 'sphere', elem.sphereElement, false);
  ComposeDecimalValue(json, 'cylinder', elem.cylinderElement, false);
  ComposeDecimalProps(json, 'cylinder', elem.cylinderElement, false);
  ComposeIntegerValue(json, 'axis', elem.axisElement, false);
  ComposeIntegerProps(json, 'axis', elem.axisElement, false);
  ComposeDecimalValue(json, 'prism', elem.prismElement, false);
  ComposeDecimalProps(json, 'prism', elem.prismElement, false);
  ComposeEnumValue(json, 'base', elem.BaseElement, CODES_TFhirBaseCodes, false);
  ComposeEnumProps(json, 'base', elem.BaseElement, CODES_TFhirBaseCodes, false);
  ComposeDecimalValue(json, 'add', elem.addElement, false);
  ComposeDecimalProps(json, 'add', elem.addElement, false);
  ComposeDecimalValue(json, 'power', elem.powerElement, false);
  ComposeDecimalProps(json, 'power', elem.powerElement, false);
  ComposeDecimalValue(json, 'backCurve', elem.backCurveElement, false);
  ComposeDecimalProps(json, 'backCurve', elem.backCurveElement, false);
  ComposeDecimalValue(json, 'diameter', elem.diameterElement, false);
  ComposeDecimalProps(json, 'diameter', elem.diameterElement, false);
  ComposeQuantity(json, 'duration', elem.duration); {a}
  ComposeStringValue(json, 'color', elem.colorElement, false);
  ComposeStringProps(json, 'color', elem.colorElement, false);
  ComposeStringValue(json, 'brand', elem.brandElement, false);
  ComposeStringProps(json, 'brand', elem.brandElement, false);
  ComposeStringValue(json, 'notes', elem.notesElement, false);
  ComposeStringProps(json, 'notes', elem.notesElement, false);
  if not noObj then json.finishObject;
end;

function TFHIRXmlParser.ParseVisionPrescription(element : IXmlDomElement; path : string) : TFhirVisionPrescription;
var
  child : IXMLDOMElement;
begin
  result := TFhirVisionPrescription.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'dateWritten') then
        result.dateWrittenElement := ParseDateTime(child, path+'/dateWritten') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'prescriber') then
        result.prescriber := ParseReference{TFhirPractitioner}(child, path+'/prescriber') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'reasonCodeableConcept') then
        result.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.baseName = 'reasonReference') then
        result.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.baseName = 'dispense') then
        result.dispenseList.Add(ParseVisionPrescriptionDispense(child, path+'/dispense')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescription(xml : TXmlBuilder; name : string; elem : TFhirVisionPrescription);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeDateTime(xml, 'dateWritten', elem.dateWrittenElement);{x.2}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  ComposeReference{TFhirPractitioner}(xml, 'prescriber', elem.prescriber);{x.2}
  ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  for i := 0 to elem.dispenseList.Count - 1 do
    ComposeVisionPrescriptionDispense(xml, 'dispense', elem.dispenseList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseVisionPrescription(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseVisionPrescription(jsn)); {2}
end;

function TFHIRJsonParser.ParseVisionPrescription(jsn : TJsonObject) : TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('dateWritten') or jsn.has('_dateWritten') then
        result.dateWrittenElement := ParseDateTime(jsn['dateWritten'], jsn.vObj['_dateWritten']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('prescriber') then
        result.prescriber := ParseReference{TFhirPractitioner}(jsn.vObj['prescriber']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('dispense') then
      iterateArray(jsn.vArr['dispense'], result.dispenseList, parseVisionPrescriptionDispense);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeVisionPrescription(json : TJSONWriter; name : string; elem : TFhirVisionPrescription; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'dateWritten', elem.dateWrittenElement, false);
  ComposeDateTimeProps(json, 'dateWritten', elem.dateWrittenElement, false);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeReference{TFhirPractitioner}(json, 'prescriber', elem.prescriber); {a}
  ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  if elem.dispenseList.Count > 0 then
  begin
    json.valueArray('dispense');
    for i := 0 to elem.dispenseList.Count - 1 do
      ComposeVisionPrescriptionDispense(json, '',elem.dispenseList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseResource(element : IXmlDomElement; path : String) : TFhirResource;
begin
  if (element = nil) Then
    Raise Exception.Create('error - element is nil')
  else if element.baseName = 'Parameters' Then
    result := ParseParameters(element, path+'/Parameters')
  else if element.baseName = 'AllergyIntolerance' Then
    result := ParseAllergyIntolerance(element, path+'/AllergyIntolerance')
  else if element.baseName = 'Appointment' Then
    result := ParseAppointment(element, path+'/Appointment')
  else if element.baseName = 'AppointmentResponse' Then
    result := ParseAppointmentResponse(element, path+'/AppointmentResponse')
  else if element.baseName = 'AuditEvent' Then
    result := ParseAuditEvent(element, path+'/AuditEvent')
  else if element.baseName = 'Basic' Then
    result := ParseBasic(element, path+'/Basic')
  else if element.baseName = 'Binary' Then
    result := ParseBinary(element, path+'/Binary')
  else if element.baseName = 'BodySite' Then
    result := ParseBodySite(element, path+'/BodySite')
  else if element.baseName = 'Bundle' Then
    result := ParseBundle(element, path+'/Bundle')
  else if element.baseName = 'CarePlan' Then
    result := ParseCarePlan(element, path+'/CarePlan')
  else if element.baseName = 'Claim' Then
    result := ParseClaim(element, path+'/Claim')
  else if element.baseName = 'ClaimResponse' Then
    result := ParseClaimResponse(element, path+'/ClaimResponse')
  else if element.baseName = 'ClinicalImpression' Then
    result := ParseClinicalImpression(element, path+'/ClinicalImpression')
  else if element.baseName = 'Communication' Then
    result := ParseCommunication(element, path+'/Communication')
  else if element.baseName = 'CommunicationRequest' Then
    result := ParseCommunicationRequest(element, path+'/CommunicationRequest')
  else if element.baseName = 'Composition' Then
    result := ParseComposition(element, path+'/Composition')
  else if element.baseName = 'ConceptMap' Then
    result := ParseConceptMap(element, path+'/ConceptMap')
  else if element.baseName = 'Condition' Then
    result := ParseCondition(element, path+'/Condition')
  else if element.baseName = 'Conformance' Then
    result := ParseConformance(element, path+'/Conformance')
  else if element.baseName = 'Contract' Then
    result := ParseContract(element, path+'/Contract')
  else if element.baseName = 'Contraindication' Then
    result := ParseContraindication(element, path+'/Contraindication')
  else if element.baseName = 'Coverage' Then
    result := ParseCoverage(element, path+'/Coverage')
  else if element.baseName = 'DataElement' Then
    result := ParseDataElement(element, path+'/DataElement')
  else if element.baseName = 'Device' Then
    result := ParseDevice(element, path+'/Device')
  else if element.baseName = 'DeviceComponent' Then
    result := ParseDeviceComponent(element, path+'/DeviceComponent')
  else if element.baseName = 'DeviceMetric' Then
    result := ParseDeviceMetric(element, path+'/DeviceMetric')
  else if element.baseName = 'DeviceUseRequest' Then
    result := ParseDeviceUseRequest(element, path+'/DeviceUseRequest')
  else if element.baseName = 'DeviceUseStatement' Then
    result := ParseDeviceUseStatement(element, path+'/DeviceUseStatement')
  else if element.baseName = 'DiagnosticOrder' Then
    result := ParseDiagnosticOrder(element, path+'/DiagnosticOrder')
  else if element.baseName = 'DiagnosticReport' Then
    result := ParseDiagnosticReport(element, path+'/DiagnosticReport')
  else if element.baseName = 'DocumentManifest' Then
    result := ParseDocumentManifest(element, path+'/DocumentManifest')
  else if element.baseName = 'DocumentReference' Then
    result := ParseDocumentReference(element, path+'/DocumentReference')
  else if element.baseName = 'EligibilityRequest' Then
    result := ParseEligibilityRequest(element, path+'/EligibilityRequest')
  else if element.baseName = 'EligibilityResponse' Then
    result := ParseEligibilityResponse(element, path+'/EligibilityResponse')
  else if element.baseName = 'Encounter' Then
    result := ParseEncounter(element, path+'/Encounter')
  else if element.baseName = 'EnrollmentRequest' Then
    result := ParseEnrollmentRequest(element, path+'/EnrollmentRequest')
  else if element.baseName = 'EnrollmentResponse' Then
    result := ParseEnrollmentResponse(element, path+'/EnrollmentResponse')
  else if element.baseName = 'EpisodeOfCare' Then
    result := ParseEpisodeOfCare(element, path+'/EpisodeOfCare')
  else if element.baseName = 'ExplanationOfBenefit' Then
    result := ParseExplanationOfBenefit(element, path+'/ExplanationOfBenefit')
  else if element.baseName = 'FamilyMemberHistory' Then
    result := ParseFamilyMemberHistory(element, path+'/FamilyMemberHistory')
  else if element.baseName = 'Flag' Then
    result := ParseFlag(element, path+'/Flag')
  else if element.baseName = 'Goal' Then
    result := ParseGoal(element, path+'/Goal')
  else if element.baseName = 'Group' Then
    result := ParseGroup(element, path+'/Group')
  else if element.baseName = 'HealthcareService' Then
    result := ParseHealthcareService(element, path+'/HealthcareService')
  else if element.baseName = 'ImagingObjectSelection' Then
    result := ParseImagingObjectSelection(element, path+'/ImagingObjectSelection')
  else if element.baseName = 'ImagingStudy' Then
    result := ParseImagingStudy(element, path+'/ImagingStudy')
  else if element.baseName = 'Immunization' Then
    result := ParseImmunization(element, path+'/Immunization')
  else if element.baseName = 'ImmunizationRecommendation' Then
    result := ParseImmunizationRecommendation(element, path+'/ImmunizationRecommendation')
  else if element.baseName = 'List' Then
    result := ParseList(element, path+'/List')
  else if element.baseName = 'Location' Then
    result := ParseLocation(element, path+'/Location')
  else if element.baseName = 'Media' Then
    result := ParseMedia(element, path+'/Media')
  else if element.baseName = 'Medication' Then
    result := ParseMedication(element, path+'/Medication')
  else if element.baseName = 'MedicationAdministration' Then
    result := ParseMedicationAdministration(element, path+'/MedicationAdministration')
  else if element.baseName = 'MedicationDispense' Then
    result := ParseMedicationDispense(element, path+'/MedicationDispense')
  else if element.baseName = 'MedicationPrescription' Then
    result := ParseMedicationPrescription(element, path+'/MedicationPrescription')
  else if element.baseName = 'MedicationStatement' Then
    result := ParseMedicationStatement(element, path+'/MedicationStatement')
  else if element.baseName = 'MessageHeader' Then
    result := ParseMessageHeader(element, path+'/MessageHeader')
  else if element.baseName = 'NamingSystem' Then
    result := ParseNamingSystem(element, path+'/NamingSystem')
  else if element.baseName = 'NutritionOrder' Then
    result := ParseNutritionOrder(element, path+'/NutritionOrder')
  else if element.baseName = 'Observation' Then
    result := ParseObservation(element, path+'/Observation')
  else if element.baseName = 'OperationDefinition' Then
    result := ParseOperationDefinition(element, path+'/OperationDefinition')
  else if element.baseName = 'OperationOutcome' Then
    result := ParseOperationOutcome(element, path+'/OperationOutcome')
  else if element.baseName = 'Order' Then
    result := ParseOrder(element, path+'/Order')
  else if element.baseName = 'OrderResponse' Then
    result := ParseOrderResponse(element, path+'/OrderResponse')
  else if element.baseName = 'Organization' Then
    result := ParseOrganization(element, path+'/Organization')
  else if element.baseName = 'Patient' Then
    result := ParsePatient(element, path+'/Patient')
  else if element.baseName = 'PaymentNotice' Then
    result := ParsePaymentNotice(element, path+'/PaymentNotice')
  else if element.baseName = 'PaymentReconciliation' Then
    result := ParsePaymentReconciliation(element, path+'/PaymentReconciliation')
  else if element.baseName = 'Person' Then
    result := ParsePerson(element, path+'/Person')
  else if element.baseName = 'Practitioner' Then
    result := ParsePractitioner(element, path+'/Practitioner')
  else if element.baseName = 'Procedure' Then
    result := ParseProcedure(element, path+'/Procedure')
  else if element.baseName = 'ProcedureRequest' Then
    result := ParseProcedureRequest(element, path+'/ProcedureRequest')
  else if element.baseName = 'ProcessRequest' Then
    result := ParseProcessRequest(element, path+'/ProcessRequest')
  else if element.baseName = 'ProcessResponse' Then
    result := ParseProcessResponse(element, path+'/ProcessResponse')
  else if element.baseName = 'Provenance' Then
    result := ParseProvenance(element, path+'/Provenance')
  else if element.baseName = 'Questionnaire' Then
    result := ParseQuestionnaire(element, path+'/Questionnaire')
  else if element.baseName = 'QuestionnaireAnswers' Then
    result := ParseQuestionnaireAnswers(element, path+'/QuestionnaireAnswers')
  else if element.baseName = 'ReferralRequest' Then
    result := ParseReferralRequest(element, path+'/ReferralRequest')
  else if element.baseName = 'RelatedPerson' Then
    result := ParseRelatedPerson(element, path+'/RelatedPerson')
  else if element.baseName = 'RiskAssessment' Then
    result := ParseRiskAssessment(element, path+'/RiskAssessment')
  else if element.baseName = 'Schedule' Then
    result := ParseSchedule(element, path+'/Schedule')
  else if element.baseName = 'SearchParameter' Then
    result := ParseSearchParameter(element, path+'/SearchParameter')
  else if element.baseName = 'Slot' Then
    result := ParseSlot(element, path+'/Slot')
  else if element.baseName = 'Specimen' Then
    result := ParseSpecimen(element, path+'/Specimen')
  else if element.baseName = 'StructureDefinition' Then
    result := ParseStructureDefinition(element, path+'/StructureDefinition')
  else if element.baseName = 'Subscription' Then
    result := ParseSubscription(element, path+'/Subscription')
  else if element.baseName = 'Substance' Then
    result := ParseSubstance(element, path+'/Substance')
  else if element.baseName = 'Supply' Then
    result := ParseSupply(element, path+'/Supply')
  else if element.baseName = 'SupplyDelivery' Then
    result := ParseSupplyDelivery(element, path+'/SupplyDelivery')
  else if element.baseName = 'SupplyRequest' Then
    result := ParseSupplyRequest(element, path+'/SupplyRequest')
  else if element.baseName = 'ValueSet' Then
    result := ParseValueSet(element, path+'/ValueSet')
  else if element.baseName = 'VisionPrescription' Then
    result := ParseVisionPrescription(element, path+'/VisionPrescription')
  else
    raise Exception.create('Error: the element '+element.baseName+' is not recognised as a valid resource name');
end;

procedure TFHIRXmlComposer.ComposeResource(xml : TXmlBuilder; resource: TFhirResource; links : TFhirBundleLinkList);
begin
  if (resource = nil) Then
    Raise Exception.Create('error - resource is nil');
  Case resource.ResourceType of
    frtParameters: ComposeParameters(xml, 'Parameters', TFhirParameters(resource));
    frtAllergyIntolerance: ComposeAllergyIntolerance(xml, 'AllergyIntolerance', TFhirAllergyIntolerance(resource));
    frtAppointment: ComposeAppointment(xml, 'Appointment', TFhirAppointment(resource));
    frtAppointmentResponse: ComposeAppointmentResponse(xml, 'AppointmentResponse', TFhirAppointmentResponse(resource));
    frtAuditEvent: ComposeAuditEvent(xml, 'AuditEvent', TFhirAuditEvent(resource));
    frtBasic: ComposeBasic(xml, 'Basic', TFhirBasic(resource));
    frtBinary: ComposeBinary(xml, 'Binary', TFhirBinary(resource));
    frtBodySite: ComposeBodySite(xml, 'BodySite', TFhirBodySite(resource));
    frtBundle: ComposeBundle(xml, 'Bundle', TFhirBundle(resource));
    frtCarePlan: ComposeCarePlan(xml, 'CarePlan', TFhirCarePlan(resource));
    frtClaim: ComposeClaim(xml, 'Claim', TFhirClaim(resource));
    frtClaimResponse: ComposeClaimResponse(xml, 'ClaimResponse', TFhirClaimResponse(resource));
    frtClinicalImpression: ComposeClinicalImpression(xml, 'ClinicalImpression', TFhirClinicalImpression(resource));
    frtCommunication: ComposeCommunication(xml, 'Communication', TFhirCommunication(resource));
    frtCommunicationRequest: ComposeCommunicationRequest(xml, 'CommunicationRequest', TFhirCommunicationRequest(resource));
    frtComposition: ComposeComposition(xml, 'Composition', TFhirComposition(resource));
    frtConceptMap: ComposeConceptMap(xml, 'ConceptMap', TFhirConceptMap(resource));
    frtCondition: ComposeCondition(xml, 'Condition', TFhirCondition(resource));
    frtConformance: ComposeConformance(xml, 'Conformance', TFhirConformance(resource));
    frtContract: ComposeContract(xml, 'Contract', TFhirContract(resource));
    frtContraindication: ComposeContraindication(xml, 'Contraindication', TFhirContraindication(resource));
    frtCoverage: ComposeCoverage(xml, 'Coverage', TFhirCoverage(resource));
    frtDataElement: ComposeDataElement(xml, 'DataElement', TFhirDataElement(resource));
    frtDevice: ComposeDevice(xml, 'Device', TFhirDevice(resource));
    frtDeviceComponent: ComposeDeviceComponent(xml, 'DeviceComponent', TFhirDeviceComponent(resource));
    frtDeviceMetric: ComposeDeviceMetric(xml, 'DeviceMetric', TFhirDeviceMetric(resource));
    frtDeviceUseRequest: ComposeDeviceUseRequest(xml, 'DeviceUseRequest', TFhirDeviceUseRequest(resource));
    frtDeviceUseStatement: ComposeDeviceUseStatement(xml, 'DeviceUseStatement', TFhirDeviceUseStatement(resource));
    frtDiagnosticOrder: ComposeDiagnosticOrder(xml, 'DiagnosticOrder', TFhirDiagnosticOrder(resource));
    frtDiagnosticReport: ComposeDiagnosticReport(xml, 'DiagnosticReport', TFhirDiagnosticReport(resource));
    frtDocumentManifest: ComposeDocumentManifest(xml, 'DocumentManifest', TFhirDocumentManifest(resource));
    frtDocumentReference: ComposeDocumentReference(xml, 'DocumentReference', TFhirDocumentReference(resource));
    frtEligibilityRequest: ComposeEligibilityRequest(xml, 'EligibilityRequest', TFhirEligibilityRequest(resource));
    frtEligibilityResponse: ComposeEligibilityResponse(xml, 'EligibilityResponse', TFhirEligibilityResponse(resource));
    frtEncounter: ComposeEncounter(xml, 'Encounter', TFhirEncounter(resource));
    frtEnrollmentRequest: ComposeEnrollmentRequest(xml, 'EnrollmentRequest', TFhirEnrollmentRequest(resource));
    frtEnrollmentResponse: ComposeEnrollmentResponse(xml, 'EnrollmentResponse', TFhirEnrollmentResponse(resource));
    frtEpisodeOfCare: ComposeEpisodeOfCare(xml, 'EpisodeOfCare', TFhirEpisodeOfCare(resource));
    frtExplanationOfBenefit: ComposeExplanationOfBenefit(xml, 'ExplanationOfBenefit', TFhirExplanationOfBenefit(resource));
    frtFamilyMemberHistory: ComposeFamilyMemberHistory(xml, 'FamilyMemberHistory', TFhirFamilyMemberHistory(resource));
    frtFlag: ComposeFlag(xml, 'Flag', TFhirFlag(resource));
    frtGoal: ComposeGoal(xml, 'Goal', TFhirGoal(resource));
    frtGroup: ComposeGroup(xml, 'Group', TFhirGroup(resource));
    frtHealthcareService: ComposeHealthcareService(xml, 'HealthcareService', TFhirHealthcareService(resource));
    frtImagingObjectSelection: ComposeImagingObjectSelection(xml, 'ImagingObjectSelection', TFhirImagingObjectSelection(resource));
    frtImagingStudy: ComposeImagingStudy(xml, 'ImagingStudy', TFhirImagingStudy(resource));
    frtImmunization: ComposeImmunization(xml, 'Immunization', TFhirImmunization(resource));
    frtImmunizationRecommendation: ComposeImmunizationRecommendation(xml, 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource));
    frtList: ComposeList(xml, 'List', TFhirList(resource));
    frtLocation: ComposeLocation(xml, 'Location', TFhirLocation(resource));
    frtMedia: ComposeMedia(xml, 'Media', TFhirMedia(resource));
    frtMedication: ComposeMedication(xml, 'Medication', TFhirMedication(resource));
    frtMedicationAdministration: ComposeMedicationAdministration(xml, 'MedicationAdministration', TFhirMedicationAdministration(resource));
    frtMedicationDispense: ComposeMedicationDispense(xml, 'MedicationDispense', TFhirMedicationDispense(resource));
    frtMedicationPrescription: ComposeMedicationPrescription(xml, 'MedicationPrescription', TFhirMedicationPrescription(resource));
    frtMedicationStatement: ComposeMedicationStatement(xml, 'MedicationStatement', TFhirMedicationStatement(resource));
    frtMessageHeader: ComposeMessageHeader(xml, 'MessageHeader', TFhirMessageHeader(resource));
    frtNamingSystem: ComposeNamingSystem(xml, 'NamingSystem', TFhirNamingSystem(resource));
    frtNutritionOrder: ComposeNutritionOrder(xml, 'NutritionOrder', TFhirNutritionOrder(resource));
    frtObservation: ComposeObservation(xml, 'Observation', TFhirObservation(resource));
    frtOperationDefinition: ComposeOperationDefinition(xml, 'OperationDefinition', TFhirOperationDefinition(resource));
    frtOperationOutcome: ComposeOperationOutcome(xml, 'OperationOutcome', TFhirOperationOutcome(resource));
    frtOrder: ComposeOrder(xml, 'Order', TFhirOrder(resource));
    frtOrderResponse: ComposeOrderResponse(xml, 'OrderResponse', TFhirOrderResponse(resource));
    frtOrganization: ComposeOrganization(xml, 'Organization', TFhirOrganization(resource));
    frtPatient: ComposePatient(xml, 'Patient', TFhirPatient(resource));
    frtPaymentNotice: ComposePaymentNotice(xml, 'PaymentNotice', TFhirPaymentNotice(resource));
    frtPaymentReconciliation: ComposePaymentReconciliation(xml, 'PaymentReconciliation', TFhirPaymentReconciliation(resource));
    frtPerson: ComposePerson(xml, 'Person', TFhirPerson(resource));
    frtPractitioner: ComposePractitioner(xml, 'Practitioner', TFhirPractitioner(resource));
    frtProcedure: ComposeProcedure(xml, 'Procedure', TFhirProcedure(resource));
    frtProcedureRequest: ComposeProcedureRequest(xml, 'ProcedureRequest', TFhirProcedureRequest(resource));
    frtProcessRequest: ComposeProcessRequest(xml, 'ProcessRequest', TFhirProcessRequest(resource));
    frtProcessResponse: ComposeProcessResponse(xml, 'ProcessResponse', TFhirProcessResponse(resource));
    frtProvenance: ComposeProvenance(xml, 'Provenance', TFhirProvenance(resource));
    frtQuestionnaire: ComposeQuestionnaire(xml, 'Questionnaire', TFhirQuestionnaire(resource));
    frtQuestionnaireAnswers: ComposeQuestionnaireAnswers(xml, 'QuestionnaireAnswers', TFhirQuestionnaireAnswers(resource));
    frtReferralRequest: ComposeReferralRequest(xml, 'ReferralRequest', TFhirReferralRequest(resource));
    frtRelatedPerson: ComposeRelatedPerson(xml, 'RelatedPerson', TFhirRelatedPerson(resource));
    frtRiskAssessment: ComposeRiskAssessment(xml, 'RiskAssessment', TFhirRiskAssessment(resource));
    frtSchedule: ComposeSchedule(xml, 'Schedule', TFhirSchedule(resource));
    frtSearchParameter: ComposeSearchParameter(xml, 'SearchParameter', TFhirSearchParameter(resource));
    frtSlot: ComposeSlot(xml, 'Slot', TFhirSlot(resource));
    frtSpecimen: ComposeSpecimen(xml, 'Specimen', TFhirSpecimen(resource));
    frtStructureDefinition: ComposeStructureDefinition(xml, 'StructureDefinition', TFhirStructureDefinition(resource));
    frtSubscription: ComposeSubscription(xml, 'Subscription', TFhirSubscription(resource));
    frtSubstance: ComposeSubstance(xml, 'Substance', TFhirSubstance(resource));
    frtSupply: ComposeSupply(xml, 'Supply', TFhirSupply(resource));
    frtSupplyDelivery: ComposeSupplyDelivery(xml, 'SupplyDelivery', TFhirSupplyDelivery(resource));
    frtSupplyRequest: ComposeSupplyRequest(xml, 'SupplyRequest', TFhirSupplyRequest(resource));
    frtValueSet: ComposeValueSet(xml, 'ValueSet', TFhirValueSet(resource));
    frtVisionPrescription: ComposeVisionPrescription(xml, 'VisionPrescription', TFhirVisionPrescription(resource));
  else
    raise Exception.create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;

function TFHIRJsonParser.ParseResource(jsn : TJsonObject) : TFhirResource;
var
  s : String;
begin
  s := jsn['resourceType'];
  if s = 'Parameters' Then
    result := ParseParameters(jsn)
  else if s = 'AllergyIntolerance' Then
    result := ParseAllergyIntolerance(jsn)
  else if s = 'Appointment' Then
    result := ParseAppointment(jsn)
  else if s = 'AppointmentResponse' Then
    result := ParseAppointmentResponse(jsn)
  else if s = 'AuditEvent' Then
    result := ParseAuditEvent(jsn)
  else if s = 'Basic' Then
    result := ParseBasic(jsn)
  else if s = 'Binary' Then
    result := ParseBinary(jsn)
  else if s = 'BodySite' Then
    result := ParseBodySite(jsn)
  else if s = 'Bundle' Then
    result := ParseBundle(jsn)
  else if s = 'CarePlan' Then
    result := ParseCarePlan(jsn)
  else if s = 'Claim' Then
    result := ParseClaim(jsn)
  else if s = 'ClaimResponse' Then
    result := ParseClaimResponse(jsn)
  else if s = 'ClinicalImpression' Then
    result := ParseClinicalImpression(jsn)
  else if s = 'Communication' Then
    result := ParseCommunication(jsn)
  else if s = 'CommunicationRequest' Then
    result := ParseCommunicationRequest(jsn)
  else if s = 'Composition' Then
    result := ParseComposition(jsn)
  else if s = 'ConceptMap' Then
    result := ParseConceptMap(jsn)
  else if s = 'Condition' Then
    result := ParseCondition(jsn)
  else if s = 'Conformance' Then
    result := ParseConformance(jsn)
  else if s = 'Contract' Then
    result := ParseContract(jsn)
  else if s = 'Contraindication' Then
    result := ParseContraindication(jsn)
  else if s = 'Coverage' Then
    result := ParseCoverage(jsn)
  else if s = 'DataElement' Then
    result := ParseDataElement(jsn)
  else if s = 'Device' Then
    result := ParseDevice(jsn)
  else if s = 'DeviceComponent' Then
    result := ParseDeviceComponent(jsn)
  else if s = 'DeviceMetric' Then
    result := ParseDeviceMetric(jsn)
  else if s = 'DeviceUseRequest' Then
    result := ParseDeviceUseRequest(jsn)
  else if s = 'DeviceUseStatement' Then
    result := ParseDeviceUseStatement(jsn)
  else if s = 'DiagnosticOrder' Then
    result := ParseDiagnosticOrder(jsn)
  else if s = 'DiagnosticReport' Then
    result := ParseDiagnosticReport(jsn)
  else if s = 'DocumentManifest' Then
    result := ParseDocumentManifest(jsn)
  else if s = 'DocumentReference' Then
    result := ParseDocumentReference(jsn)
  else if s = 'EligibilityRequest' Then
    result := ParseEligibilityRequest(jsn)
  else if s = 'EligibilityResponse' Then
    result := ParseEligibilityResponse(jsn)
  else if s = 'Encounter' Then
    result := ParseEncounter(jsn)
  else if s = 'EnrollmentRequest' Then
    result := ParseEnrollmentRequest(jsn)
  else if s = 'EnrollmentResponse' Then
    result := ParseEnrollmentResponse(jsn)
  else if s = 'EpisodeOfCare' Then
    result := ParseEpisodeOfCare(jsn)
  else if s = 'ExplanationOfBenefit' Then
    result := ParseExplanationOfBenefit(jsn)
  else if s = 'FamilyMemberHistory' Then
    result := ParseFamilyMemberHistory(jsn)
  else if s = 'Flag' Then
    result := ParseFlag(jsn)
  else if s = 'Goal' Then
    result := ParseGoal(jsn)
  else if s = 'Group' Then
    result := ParseGroup(jsn)
  else if s = 'HealthcareService' Then
    result := ParseHealthcareService(jsn)
  else if s = 'ImagingObjectSelection' Then
    result := ParseImagingObjectSelection(jsn)
  else if s = 'ImagingStudy' Then
    result := ParseImagingStudy(jsn)
  else if s = 'Immunization' Then
    result := ParseImmunization(jsn)
  else if s = 'ImmunizationRecommendation' Then
    result := ParseImmunizationRecommendation(jsn)
  else if s = 'List' Then
    result := ParseList(jsn)
  else if s = 'Location' Then
    result := ParseLocation(jsn)
  else if s = 'Media' Then
    result := ParseMedia(jsn)
  else if s = 'Medication' Then
    result := ParseMedication(jsn)
  else if s = 'MedicationAdministration' Then
    result := ParseMedicationAdministration(jsn)
  else if s = 'MedicationDispense' Then
    result := ParseMedicationDispense(jsn)
  else if s = 'MedicationPrescription' Then
    result := ParseMedicationPrescription(jsn)
  else if s = 'MedicationStatement' Then
    result := ParseMedicationStatement(jsn)
  else if s = 'MessageHeader' Then
    result := ParseMessageHeader(jsn)
  else if s = 'NamingSystem' Then
    result := ParseNamingSystem(jsn)
  else if s = 'NutritionOrder' Then
    result := ParseNutritionOrder(jsn)
  else if s = 'Observation' Then
    result := ParseObservation(jsn)
  else if s = 'OperationDefinition' Then
    result := ParseOperationDefinition(jsn)
  else if s = 'OperationOutcome' Then
    result := ParseOperationOutcome(jsn)
  else if s = 'Order' Then
    result := ParseOrder(jsn)
  else if s = 'OrderResponse' Then
    result := ParseOrderResponse(jsn)
  else if s = 'Organization' Then
    result := ParseOrganization(jsn)
  else if s = 'Patient' Then
    result := ParsePatient(jsn)
  else if s = 'PaymentNotice' Then
    result := ParsePaymentNotice(jsn)
  else if s = 'PaymentReconciliation' Then
    result := ParsePaymentReconciliation(jsn)
  else if s = 'Person' Then
    result := ParsePerson(jsn)
  else if s = 'Practitioner' Then
    result := ParsePractitioner(jsn)
  else if s = 'Procedure' Then
    result := ParseProcedure(jsn)
  else if s = 'ProcedureRequest' Then
    result := ParseProcedureRequest(jsn)
  else if s = 'ProcessRequest' Then
    result := ParseProcessRequest(jsn)
  else if s = 'ProcessResponse' Then
    result := ParseProcessResponse(jsn)
  else if s = 'Provenance' Then
    result := ParseProvenance(jsn)
  else if s = 'Questionnaire' Then
    result := ParseQuestionnaire(jsn)
  else if s = 'QuestionnaireAnswers' Then
    result := ParseQuestionnaireAnswers(jsn)
  else if s = 'ReferralRequest' Then
    result := ParseReferralRequest(jsn)
  else if s = 'RelatedPerson' Then
    result := ParseRelatedPerson(jsn)
  else if s = 'RiskAssessment' Then
    result := ParseRiskAssessment(jsn)
  else if s = 'Schedule' Then
    result := ParseSchedule(jsn)
  else if s = 'SearchParameter' Then
    result := ParseSearchParameter(jsn)
  else if s = 'Slot' Then
    result := ParseSlot(jsn)
  else if s = 'Specimen' Then
    result := ParseSpecimen(jsn)
  else if s = 'StructureDefinition' Then
    result := ParseStructureDefinition(jsn)
  else if s = 'Subscription' Then
    result := ParseSubscription(jsn)
  else if s = 'Substance' Then
    result := ParseSubstance(jsn)
  else if s = 'Supply' Then
    result := ParseSupply(jsn)
  else if s = 'SupplyDelivery' Then
    result := ParseSupplyDelivery(jsn)
  else if s = 'SupplyRequest' Then
    result := ParseSupplyRequest(jsn)
  else if s = 'ValueSet' Then
    result := ParseValueSet(jsn)
  else if s = 'VisionPrescription' Then
    result := ParseVisionPrescription(jsn)
  else
    raise Exception.create('error: the element '+s+' is not a valid resource name');
end;

function TFHIRJsonParser.ParseFragment(jsn : TJsonObject; type_ : String) : TFhirBase;
begin
   if (type_ = 'TFhirElement') then
    result := parseElement(jsn)
  else if (type_ = 'TFhirBackboneElement') then
    result := parseBackboneElement(jsn)
  else if (type_ = 'TFhirParameters') then
    result := parseParameters(jsn)
  else if (type_ = 'TFhirExtension') then
    result := parseExtension(jsn)
  else if (type_ = 'TFhirNarrative') then
    result := parseNarrative(jsn)
  else if (type_ = 'TFhirPeriod') then
    result := parsePeriod(jsn)
  else if (type_ = 'TFhirCoding') then
    result := parseCoding(jsn)
  else if (type_ = 'TFhirRange') then
    result := parseRange(jsn)
  else if (type_ = 'TFhirQuantity') then
    result := parseQuantity(jsn)
  else if (type_ = 'TFhirAttachment') then
    result := parseAttachment(jsn)
  else if (type_ = 'TFhirRatio') then
    result := parseRatio(jsn)
  else if (type_ = 'TFhirSampledData') then
    result := parseSampledData(jsn)
  else if (type_ = 'TFhirReference') then
    result := parseReference(jsn)
  else if (type_ = 'TFhirCodeableConcept') then
    result := parseCodeableConcept(jsn)
  else if (type_ = 'TFhirIdentifier') then
    result := parseIdentifier(jsn)
  else if (type_ = 'TFhirSignature') then
    result := parseSignature(jsn)
  else if (type_ = 'TFhirElementDefinition') then
    result := parseElementDefinition(jsn)
  else if (type_ = 'TFhirTiming') then
    result := parseTiming(jsn)
  else if (type_ = 'TFhirAddress') then
    result := parseAddress(jsn)
  else if (type_ = 'TFhirHumanName') then
    result := parseHumanName(jsn)
  else if (type_ = 'TFhirMeta') then
    result := parseMeta(jsn)
  else if (type_ = 'TFhirContactPoint') then
    result := parseContactPoint(jsn)
  else if (type_ = 'TFhirAllergyIntolerance') then
    result := parseAllergyIntolerance(jsn)
  else if (type_ = 'TFhirAppointment') then
    result := parseAppointment(jsn)
  else if (type_ = 'TFhirAppointmentResponse') then
    result := parseAppointmentResponse(jsn)
  else if (type_ = 'TFhirAuditEvent') then
    result := parseAuditEvent(jsn)
  else if (type_ = 'TFhirBasic') then
    result := parseBasic(jsn)
  else if (type_ = 'TFhirBinary') then
    result := parseBinary(jsn)
  else if (type_ = 'TFhirBodySite') then
    result := parseBodySite(jsn)
  else if (type_ = 'TFhirBundle') then
    result := parseBundle(jsn)
  else if (type_ = 'TFhirCarePlan') then
    result := parseCarePlan(jsn)
  else if (type_ = 'TFhirClaim') then
    result := parseClaim(jsn)
  else if (type_ = 'TFhirClaimResponse') then
    result := parseClaimResponse(jsn)
  else if (type_ = 'TFhirClinicalImpression') then
    result := parseClinicalImpression(jsn)
  else if (type_ = 'TFhirCommunication') then
    result := parseCommunication(jsn)
  else if (type_ = 'TFhirCommunicationRequest') then
    result := parseCommunicationRequest(jsn)
  else if (type_ = 'TFhirComposition') then
    result := parseComposition(jsn)
  else if (type_ = 'TFhirConceptMap') then
    result := parseConceptMap(jsn)
  else if (type_ = 'TFhirCondition') then
    result := parseCondition(jsn)
  else if (type_ = 'TFhirConformance') then
    result := parseConformance(jsn)
  else if (type_ = 'TFhirContract') then
    result := parseContract(jsn)
  else if (type_ = 'TFhirContraindication') then
    result := parseContraindication(jsn)
  else if (type_ = 'TFhirCoverage') then
    result := parseCoverage(jsn)
  else if (type_ = 'TFhirDataElement') then
    result := parseDataElement(jsn)
  else if (type_ = 'TFhirDevice') then
    result := parseDevice(jsn)
  else if (type_ = 'TFhirDeviceComponent') then
    result := parseDeviceComponent(jsn)
  else if (type_ = 'TFhirDeviceMetric') then
    result := parseDeviceMetric(jsn)
  else if (type_ = 'TFhirDeviceUseRequest') then
    result := parseDeviceUseRequest(jsn)
  else if (type_ = 'TFhirDeviceUseStatement') then
    result := parseDeviceUseStatement(jsn)
  else if (type_ = 'TFhirDiagnosticOrder') then
    result := parseDiagnosticOrder(jsn)
  else if (type_ = 'TFhirDiagnosticReport') then
    result := parseDiagnosticReport(jsn)
  else if (type_ = 'TFhirDocumentManifest') then
    result := parseDocumentManifest(jsn)
  else if (type_ = 'TFhirDocumentReference') then
    result := parseDocumentReference(jsn)
  else if (type_ = 'TFhirEligibilityRequest') then
    result := parseEligibilityRequest(jsn)
  else if (type_ = 'TFhirEligibilityResponse') then
    result := parseEligibilityResponse(jsn)
  else if (type_ = 'TFhirEncounter') then
    result := parseEncounter(jsn)
  else if (type_ = 'TFhirEnrollmentRequest') then
    result := parseEnrollmentRequest(jsn)
  else if (type_ = 'TFhirEnrollmentResponse') then
    result := parseEnrollmentResponse(jsn)
  else if (type_ = 'TFhirEpisodeOfCare') then
    result := parseEpisodeOfCare(jsn)
  else if (type_ = 'TFhirExplanationOfBenefit') then
    result := parseExplanationOfBenefit(jsn)
  else if (type_ = 'TFhirFamilyMemberHistory') then
    result := parseFamilyMemberHistory(jsn)
  else if (type_ = 'TFhirFlag') then
    result := parseFlag(jsn)
  else if (type_ = 'TFhirGoal') then
    result := parseGoal(jsn)
  else if (type_ = 'TFhirGroup') then
    result := parseGroup(jsn)
  else if (type_ = 'TFhirHealthcareService') then
    result := parseHealthcareService(jsn)
  else if (type_ = 'TFhirImagingObjectSelection') then
    result := parseImagingObjectSelection(jsn)
  else if (type_ = 'TFhirImagingStudy') then
    result := parseImagingStudy(jsn)
  else if (type_ = 'TFhirImmunization') then
    result := parseImmunization(jsn)
  else if (type_ = 'TFhirImmunizationRecommendation') then
    result := parseImmunizationRecommendation(jsn)
  else if (type_ = 'TFhirList') then
    result := parseList(jsn)
  else if (type_ = 'TFhirLocation') then
    result := parseLocation(jsn)
  else if (type_ = 'TFhirMedia') then
    result := parseMedia(jsn)
  else if (type_ = 'TFhirMedication') then
    result := parseMedication(jsn)
  else if (type_ = 'TFhirMedicationAdministration') then
    result := parseMedicationAdministration(jsn)
  else if (type_ = 'TFhirMedicationDispense') then
    result := parseMedicationDispense(jsn)
  else if (type_ = 'TFhirMedicationPrescription') then
    result := parseMedicationPrescription(jsn)
  else if (type_ = 'TFhirMedicationStatement') then
    result := parseMedicationStatement(jsn)
  else if (type_ = 'TFhirMessageHeader') then
    result := parseMessageHeader(jsn)
  else if (type_ = 'TFhirNamingSystem') then
    result := parseNamingSystem(jsn)
  else if (type_ = 'TFhirNutritionOrder') then
    result := parseNutritionOrder(jsn)
  else if (type_ = 'TFhirObservation') then
    result := parseObservation(jsn)
  else if (type_ = 'TFhirOperationDefinition') then
    result := parseOperationDefinition(jsn)
  else if (type_ = 'TFhirOperationOutcome') then
    result := parseOperationOutcome(jsn)
  else if (type_ = 'TFhirOrder') then
    result := parseOrder(jsn)
  else if (type_ = 'TFhirOrderResponse') then
    result := parseOrderResponse(jsn)
  else if (type_ = 'TFhirOrganization') then
    result := parseOrganization(jsn)
  else if (type_ = 'TFhirPatient') then
    result := parsePatient(jsn)
  else if (type_ = 'TFhirPaymentNotice') then
    result := parsePaymentNotice(jsn)
  else if (type_ = 'TFhirPaymentReconciliation') then
    result := parsePaymentReconciliation(jsn)
  else if (type_ = 'TFhirPerson') then
    result := parsePerson(jsn)
  else if (type_ = 'TFhirPractitioner') then
    result := parsePractitioner(jsn)
  else if (type_ = 'TFhirProcedure') then
    result := parseProcedure(jsn)
  else if (type_ = 'TFhirProcedureRequest') then
    result := parseProcedureRequest(jsn)
  else if (type_ = 'TFhirProcessRequest') then
    result := parseProcessRequest(jsn)
  else if (type_ = 'TFhirProcessResponse') then
    result := parseProcessResponse(jsn)
  else if (type_ = 'TFhirProvenance') then
    result := parseProvenance(jsn)
  else if (type_ = 'TFhirQuestionnaire') then
    result := parseQuestionnaire(jsn)
  else if (type_ = 'TFhirQuestionnaireAnswers') then
    result := parseQuestionnaireAnswers(jsn)
  else if (type_ = 'TFhirReferralRequest') then
    result := parseReferralRequest(jsn)
  else if (type_ = 'TFhirRelatedPerson') then
    result := parseRelatedPerson(jsn)
  else if (type_ = 'TFhirRiskAssessment') then
    result := parseRiskAssessment(jsn)
  else if (type_ = 'TFhirSchedule') then
    result := parseSchedule(jsn)
  else if (type_ = 'TFhirSearchParameter') then
    result := parseSearchParameter(jsn)
  else if (type_ = 'TFhirSlot') then
    result := parseSlot(jsn)
  else if (type_ = 'TFhirSpecimen') then
    result := parseSpecimen(jsn)
  else if (type_ = 'TFhirStructureDefinition') then
    result := parseStructureDefinition(jsn)
  else if (type_ = 'TFhirSubscription') then
    result := parseSubscription(jsn)
  else if (type_ = 'TFhirSubstance') then
    result := parseSubstance(jsn)
  else if (type_ = 'TFhirSupply') then
    result := parseSupply(jsn)
  else if (type_ = 'TFhirSupplyDelivery') then
    result := parseSupplyDelivery(jsn)
  else if (type_ = 'TFhirSupplyRequest') then
    result := parseSupplyRequest(jsn)
  else if (type_ = 'TFhirValueSet') then
    result := parseValueSet(jsn)
  else if (type_ = 'TFhirVisionPrescription') then
    result := parseVisionPrescription(jsn)
  else
    raise Exception.create('error: the element '+type_+' is not a valid fragment name');
end;

function TFHIRXmlParser.ParseFragment(element : IXMLDOMElement) : TFhirBase;
begin
   if SameText(element.NodeName, 'TFhirElement') then
    result := parseElement(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirBackboneElement') then
    result := parseBackboneElement(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirParameters') then
    result := parseParameters(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirExtension') then
    result := parseExtension(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirNarrative') then
    result := parseNarrative(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirPeriod') then
    result := parsePeriod(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCoding') then
    result := parseCoding(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirRange') then
    result := parseRange(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirQuantity') then
    result := parseQuantity(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAttachment') then
    result := parseAttachment(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirRatio') then
    result := parseRatio(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSampledData') then
    result := parseSampledData(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirReference') then
    result := parseReference(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCodeableConcept') then
    result := parseCodeableConcept(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirIdentifier') then
    result := parseIdentifier(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSignature') then
    result := parseSignature(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirElementDefinition') then
    result := parseElementDefinition(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirTiming') then
    result := parseTiming(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAddress') then
    result := parseAddress(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirHumanName') then
    result := parseHumanName(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirMeta') then
    result := parseMeta(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirContactPoint') then
    result := parseContactPoint(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAllergyIntolerance') then
    result := parseAllergyIntolerance(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAppointment') then
    result := parseAppointment(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAppointmentResponse') then
    result := parseAppointmentResponse(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAuditEvent') then
    result := parseAuditEvent(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirBasic') then
    result := parseBasic(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirBinary') then
    result := parseBinary(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirBodySite') then
    result := parseBodySite(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirBundle') then
    result := parseBundle(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCarePlan') then
    result := parseCarePlan(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirClaim') then
    result := parseClaim(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirClaimResponse') then
    result := parseClaimResponse(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirClinicalImpression') then
    result := parseClinicalImpression(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCommunication') then
    result := parseCommunication(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCommunicationRequest') then
    result := parseCommunicationRequest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirComposition') then
    result := parseComposition(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirConceptMap') then
    result := parseConceptMap(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCondition') then
    result := parseCondition(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirConformance') then
    result := parseConformance(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirContract') then
    result := parseContract(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirContraindication') then
    result := parseContraindication(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCoverage') then
    result := parseCoverage(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDataElement') then
    result := parseDataElement(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDevice') then
    result := parseDevice(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDeviceComponent') then
    result := parseDeviceComponent(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDeviceMetric') then
    result := parseDeviceMetric(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDeviceUseRequest') then
    result := parseDeviceUseRequest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDeviceUseStatement') then
    result := parseDeviceUseStatement(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDiagnosticOrder') then
    result := parseDiagnosticOrder(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDiagnosticReport') then
    result := parseDiagnosticReport(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDocumentManifest') then
    result := parseDocumentManifest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDocumentReference') then
    result := parseDocumentReference(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirEligibilityRequest') then
    result := parseEligibilityRequest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirEligibilityResponse') then
    result := parseEligibilityResponse(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirEncounter') then
    result := parseEncounter(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirEnrollmentRequest') then
    result := parseEnrollmentRequest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirEnrollmentResponse') then
    result := parseEnrollmentResponse(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirEpisodeOfCare') then
    result := parseEpisodeOfCare(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirExplanationOfBenefit') then
    result := parseExplanationOfBenefit(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirFamilyMemberHistory') then
    result := parseFamilyMemberHistory(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirFlag') then
    result := parseFlag(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirGoal') then
    result := parseGoal(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirGroup') then
    result := parseGroup(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirHealthcareService') then
    result := parseHealthcareService(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirImagingObjectSelection') then
    result := parseImagingObjectSelection(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirImagingStudy') then
    result := parseImagingStudy(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirImmunization') then
    result := parseImmunization(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirImmunizationRecommendation') then
    result := parseImmunizationRecommendation(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirList') then
    result := parseList(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirLocation') then
    result := parseLocation(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirMedia') then
    result := parseMedia(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirMedication') then
    result := parseMedication(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirMedicationAdministration') then
    result := parseMedicationAdministration(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirMedicationDispense') then
    result := parseMedicationDispense(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirMedicationPrescription') then
    result := parseMedicationPrescription(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirMedicationStatement') then
    result := parseMedicationStatement(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirMessageHeader') then
    result := parseMessageHeader(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirNamingSystem') then
    result := parseNamingSystem(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirNutritionOrder') then
    result := parseNutritionOrder(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirObservation') then
    result := parseObservation(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirOperationDefinition') then
    result := parseOperationDefinition(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirOperationOutcome') then
    result := parseOperationOutcome(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirOrder') then
    result := parseOrder(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirOrderResponse') then
    result := parseOrderResponse(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirOrganization') then
    result := parseOrganization(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirPatient') then
    result := parsePatient(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirPaymentNotice') then
    result := parsePaymentNotice(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirPaymentReconciliation') then
    result := parsePaymentReconciliation(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirPerson') then
    result := parsePerson(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirPractitioner') then
    result := parsePractitioner(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirProcedure') then
    result := parseProcedure(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirProcedureRequest') then
    result := parseProcedureRequest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirProcessRequest') then
    result := parseProcessRequest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirProcessResponse') then
    result := parseProcessResponse(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirProvenance') then
    result := parseProvenance(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirQuestionnaire') then
    result := parseQuestionnaire(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirQuestionnaireAnswers') then
    result := parseQuestionnaireAnswers(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirReferralRequest') then
    result := parseReferralRequest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirRelatedPerson') then
    result := parseRelatedPerson(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirRiskAssessment') then
    result := parseRiskAssessment(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSchedule') then
    result := parseSchedule(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSearchParameter') then
    result := parseSearchParameter(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSlot') then
    result := parseSlot(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSpecimen') then
    result := parseSpecimen(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirStructureDefinition') then
    result := parseStructureDefinition(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSubscription') then
    result := parseSubscription(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSubstance') then
    result := parseSubstance(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSupply') then
    result := parseSupply(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSupplyDelivery') then
    result := parseSupplyDelivery(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSupplyRequest') then
    result := parseSupplyRequest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirValueSet') then
    result := parseValueSet(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirVisionPrescription') then
    result := parseVisionPrescription(element, element.nodeName)
  else
    raise Exception.create('error: the element '+element.nodeName+' is not a valid fragment name');
end;

function TFHIRJsonParser.ParseDataType(jsn : TJsonObject; name : String; type_ : TFHIRTypeClass) : TFHIRType;
begin
   if (type_ = TFhirExtension) then
    result := parseExtension(jsn)
  else if (type_ = TFhirNarrative) then
    result := parseNarrative(jsn)
  else if (type_ = TFhirPeriod) then
    result := parsePeriod(jsn)
  else if (type_ = TFhirCoding) then
    result := parseCoding(jsn)
  else if (type_ = TFhirRange) then
    result := parseRange(jsn)
  else if (type_ = TFhirQuantity) then
    result := parseQuantity(jsn)
  else if (type_ = TFhirAttachment) then
    result := parseAttachment(jsn)
  else if (type_ = TFhirRatio) then
    result := parseRatio(jsn)
  else if (type_ = TFhirSampledData) then
    result := parseSampledData(jsn)
  else if (type_ = TFhirReference) then
    result := parseReference(jsn)
  else if (type_ = TFhirCodeableConcept) then
    result := parseCodeableConcept(jsn)
  else if (type_ = TFhirIdentifier) then
    result := parseIdentifier(jsn)
  else if (type_ = TFhirSignature) then
    result := parseSignature(jsn)
  else if (type_ = TFhirElementDefinition) then
    result := parseElementDefinition(jsn)
  else if (type_ = TFhirTiming) then
    result := parseTiming(jsn)
  else if (type_ = TFhirAddress) then
    result := parseAddress(jsn)
  else if (type_ = TFhirHumanName) then
    result := parseHumanName(jsn)
  else if (type_ = TFhirMeta) then
    result := parseMeta(jsn)
  else if (type_ = TFhirContactPoint) then
    result := parseContactPoint(jsn)
  else
    raise Exception.create('Unknown Type');
end;

function TFHIRXmlParser.ParseDataType(element : IXMLDOMElement; name : String; type_ : TFHIRTypeClass) : TFhirType;
begin
    if (name <> '') and (name <> element.baseName) then
    raise Exception.Create('Expected Name mismatch : expected "'+name+'"+, but found "'+element.baseName+'"');
 if (type_ = TFhirExtension) then
    result := parseExtension(element, name)
  else if (type_ = TFhirNarrative) then
    result := parseNarrative(element, name)
  else if (type_ = TFhirPeriod) then
    result := parsePeriod(element, name)
  else if (type_ = TFhirCoding) then
    result := parseCoding(element, name)
  else if (type_ = TFhirRange) then
    result := parseRange(element, name)
  else if (type_ = TFhirQuantity) then
    result := parseQuantity(element, name)
  else if (type_ = TFhirAttachment) then
    result := parseAttachment(element, name)
  else if (type_ = TFhirRatio) then
    result := parseRatio(element, name)
  else if (type_ = TFhirSampledData) then
    result := parseSampledData(element, name)
  else if (type_ = TFhirReference) then
    result := parseReference(element, name)
  else if (type_ = TFhirCodeableConcept) then
    result := parseCodeableConcept(element, name)
  else if (type_ = TFhirIdentifier) then
    result := parseIdentifier(element, name)
  else if (type_ = TFhirSignature) then
    result := parseSignature(element, name)
  else if (type_ = TFhirElementDefinition) then
    result := parseElementDefinition(element, name)
  else if (type_ = TFhirTiming) then
    result := parseTiming(element, name)
  else if (type_ = TFhirAddress) then
    result := parseAddress(element, name)
  else if (type_ = TFhirHumanName) then
    result := parseHumanName(element, name)
  else if (type_ = TFhirMeta) then
    result := parseMeta(element, name)
  else if (type_ = TFhirContactPoint) then
    result := parseContactPoint(element, name)
  else
    raise Exception.create('Unknown Type');
end;

procedure TFHIRJsonComposer.ComposeResource(json : TJSONWriter; resource: TFhirResource; links : TFhirBundleLinkList);
begin
  if (resource = nil) Then
    Raise Exception.Create('error - resource is nil');
  json.value('resourceType', CODES_TFhirResourceType[resource.ResourceType]);
  Case resource.ResourceType of
    frtParameters: ComposeParameters(json, 'Parameters', TFhirParameters(resource));
    frtAllergyIntolerance: ComposeAllergyIntolerance(json, 'AllergyIntolerance', TFhirAllergyIntolerance(resource));
    frtAppointment: ComposeAppointment(json, 'Appointment', TFhirAppointment(resource));
    frtAppointmentResponse: ComposeAppointmentResponse(json, 'AppointmentResponse', TFhirAppointmentResponse(resource));
    frtAuditEvent: ComposeAuditEvent(json, 'AuditEvent', TFhirAuditEvent(resource));
    frtBasic: ComposeBasic(json, 'Basic', TFhirBasic(resource));
    frtBinary: ComposeBinary(json, 'Binary', TFhirBinary(resource));
    frtBodySite: ComposeBodySite(json, 'BodySite', TFhirBodySite(resource));
    frtBundle: ComposeBundle(json, 'Bundle', TFhirBundle(resource));
    frtCarePlan: ComposeCarePlan(json, 'CarePlan', TFhirCarePlan(resource));
    frtClaim: ComposeClaim(json, 'Claim', TFhirClaim(resource));
    frtClaimResponse: ComposeClaimResponse(json, 'ClaimResponse', TFhirClaimResponse(resource));
    frtClinicalImpression: ComposeClinicalImpression(json, 'ClinicalImpression', TFhirClinicalImpression(resource));
    frtCommunication: ComposeCommunication(json, 'Communication', TFhirCommunication(resource));
    frtCommunicationRequest: ComposeCommunicationRequest(json, 'CommunicationRequest', TFhirCommunicationRequest(resource));
    frtComposition: ComposeComposition(json, 'Composition', TFhirComposition(resource));
    frtConceptMap: ComposeConceptMap(json, 'ConceptMap', TFhirConceptMap(resource));
    frtCondition: ComposeCondition(json, 'Condition', TFhirCondition(resource));
    frtConformance: ComposeConformance(json, 'Conformance', TFhirConformance(resource));
    frtContract: ComposeContract(json, 'Contract', TFhirContract(resource));
    frtContraindication: ComposeContraindication(json, 'Contraindication', TFhirContraindication(resource));
    frtCoverage: ComposeCoverage(json, 'Coverage', TFhirCoverage(resource));
    frtDataElement: ComposeDataElement(json, 'DataElement', TFhirDataElement(resource));
    frtDevice: ComposeDevice(json, 'Device', TFhirDevice(resource));
    frtDeviceComponent: ComposeDeviceComponent(json, 'DeviceComponent', TFhirDeviceComponent(resource));
    frtDeviceMetric: ComposeDeviceMetric(json, 'DeviceMetric', TFhirDeviceMetric(resource));
    frtDeviceUseRequest: ComposeDeviceUseRequest(json, 'DeviceUseRequest', TFhirDeviceUseRequest(resource));
    frtDeviceUseStatement: ComposeDeviceUseStatement(json, 'DeviceUseStatement', TFhirDeviceUseStatement(resource));
    frtDiagnosticOrder: ComposeDiagnosticOrder(json, 'DiagnosticOrder', TFhirDiagnosticOrder(resource));
    frtDiagnosticReport: ComposeDiagnosticReport(json, 'DiagnosticReport', TFhirDiagnosticReport(resource));
    frtDocumentManifest: ComposeDocumentManifest(json, 'DocumentManifest', TFhirDocumentManifest(resource));
    frtDocumentReference: ComposeDocumentReference(json, 'DocumentReference', TFhirDocumentReference(resource));
    frtEligibilityRequest: ComposeEligibilityRequest(json, 'EligibilityRequest', TFhirEligibilityRequest(resource));
    frtEligibilityResponse: ComposeEligibilityResponse(json, 'EligibilityResponse', TFhirEligibilityResponse(resource));
    frtEncounter: ComposeEncounter(json, 'Encounter', TFhirEncounter(resource));
    frtEnrollmentRequest: ComposeEnrollmentRequest(json, 'EnrollmentRequest', TFhirEnrollmentRequest(resource));
    frtEnrollmentResponse: ComposeEnrollmentResponse(json, 'EnrollmentResponse', TFhirEnrollmentResponse(resource));
    frtEpisodeOfCare: ComposeEpisodeOfCare(json, 'EpisodeOfCare', TFhirEpisodeOfCare(resource));
    frtExplanationOfBenefit: ComposeExplanationOfBenefit(json, 'ExplanationOfBenefit', TFhirExplanationOfBenefit(resource));
    frtFamilyMemberHistory: ComposeFamilyMemberHistory(json, 'FamilyMemberHistory', TFhirFamilyMemberHistory(resource));
    frtFlag: ComposeFlag(json, 'Flag', TFhirFlag(resource));
    frtGoal: ComposeGoal(json, 'Goal', TFhirGoal(resource));
    frtGroup: ComposeGroup(json, 'Group', TFhirGroup(resource));
    frtHealthcareService: ComposeHealthcareService(json, 'HealthcareService', TFhirHealthcareService(resource));
    frtImagingObjectSelection: ComposeImagingObjectSelection(json, 'ImagingObjectSelection', TFhirImagingObjectSelection(resource));
    frtImagingStudy: ComposeImagingStudy(json, 'ImagingStudy', TFhirImagingStudy(resource));
    frtImmunization: ComposeImmunization(json, 'Immunization', TFhirImmunization(resource));
    frtImmunizationRecommendation: ComposeImmunizationRecommendation(json, 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource));
    frtList: ComposeList(json, 'List', TFhirList(resource));
    frtLocation: ComposeLocation(json, 'Location', TFhirLocation(resource));
    frtMedia: ComposeMedia(json, 'Media', TFhirMedia(resource));
    frtMedication: ComposeMedication(json, 'Medication', TFhirMedication(resource));
    frtMedicationAdministration: ComposeMedicationAdministration(json, 'MedicationAdministration', TFhirMedicationAdministration(resource));
    frtMedicationDispense: ComposeMedicationDispense(json, 'MedicationDispense', TFhirMedicationDispense(resource));
    frtMedicationPrescription: ComposeMedicationPrescription(json, 'MedicationPrescription', TFhirMedicationPrescription(resource));
    frtMedicationStatement: ComposeMedicationStatement(json, 'MedicationStatement', TFhirMedicationStatement(resource));
    frtMessageHeader: ComposeMessageHeader(json, 'MessageHeader', TFhirMessageHeader(resource));
    frtNamingSystem: ComposeNamingSystem(json, 'NamingSystem', TFhirNamingSystem(resource));
    frtNutritionOrder: ComposeNutritionOrder(json, 'NutritionOrder', TFhirNutritionOrder(resource));
    frtObservation: ComposeObservation(json, 'Observation', TFhirObservation(resource));
    frtOperationDefinition: ComposeOperationDefinition(json, 'OperationDefinition', TFhirOperationDefinition(resource));
    frtOperationOutcome: ComposeOperationOutcome(json, 'OperationOutcome', TFhirOperationOutcome(resource));
    frtOrder: ComposeOrder(json, 'Order', TFhirOrder(resource));
    frtOrderResponse: ComposeOrderResponse(json, 'OrderResponse', TFhirOrderResponse(resource));
    frtOrganization: ComposeOrganization(json, 'Organization', TFhirOrganization(resource));
    frtPatient: ComposePatient(json, 'Patient', TFhirPatient(resource));
    frtPaymentNotice: ComposePaymentNotice(json, 'PaymentNotice', TFhirPaymentNotice(resource));
    frtPaymentReconciliation: ComposePaymentReconciliation(json, 'PaymentReconciliation', TFhirPaymentReconciliation(resource));
    frtPerson: ComposePerson(json, 'Person', TFhirPerson(resource));
    frtPractitioner: ComposePractitioner(json, 'Practitioner', TFhirPractitioner(resource));
    frtProcedure: ComposeProcedure(json, 'Procedure', TFhirProcedure(resource));
    frtProcedureRequest: ComposeProcedureRequest(json, 'ProcedureRequest', TFhirProcedureRequest(resource));
    frtProcessRequest: ComposeProcessRequest(json, 'ProcessRequest', TFhirProcessRequest(resource));
    frtProcessResponse: ComposeProcessResponse(json, 'ProcessResponse', TFhirProcessResponse(resource));
    frtProvenance: ComposeProvenance(json, 'Provenance', TFhirProvenance(resource));
    frtQuestionnaire: ComposeQuestionnaire(json, 'Questionnaire', TFhirQuestionnaire(resource));
    frtQuestionnaireAnswers: ComposeQuestionnaireAnswers(json, 'QuestionnaireAnswers', TFhirQuestionnaireAnswers(resource));
    frtReferralRequest: ComposeReferralRequest(json, 'ReferralRequest', TFhirReferralRequest(resource));
    frtRelatedPerson: ComposeRelatedPerson(json, 'RelatedPerson', TFhirRelatedPerson(resource));
    frtRiskAssessment: ComposeRiskAssessment(json, 'RiskAssessment', TFhirRiskAssessment(resource));
    frtSchedule: ComposeSchedule(json, 'Schedule', TFhirSchedule(resource));
    frtSearchParameter: ComposeSearchParameter(json, 'SearchParameter', TFhirSearchParameter(resource));
    frtSlot: ComposeSlot(json, 'Slot', TFhirSlot(resource));
    frtSpecimen: ComposeSpecimen(json, 'Specimen', TFhirSpecimen(resource));
    frtStructureDefinition: ComposeStructureDefinition(json, 'StructureDefinition', TFhirStructureDefinition(resource));
    frtSubscription: ComposeSubscription(json, 'Subscription', TFhirSubscription(resource));
    frtSubstance: ComposeSubstance(json, 'Substance', TFhirSubstance(resource));
    frtSupply: ComposeSupply(json, 'Supply', TFhirSupply(resource));
    frtSupplyDelivery: ComposeSupplyDelivery(json, 'SupplyDelivery', TFhirSupplyDelivery(resource));
    frtSupplyRequest: ComposeSupplyRequest(json, 'SupplyRequest', TFhirSupplyRequest(resource));
    frtValueSet: ComposeValueSet(json, 'ValueSet', TFhirValueSet(resource));
    frtVisionPrescription: ComposeVisionPrescription(json, 'VisionPrescription', TFhirVisionPrescription(resource));
  else
    raise Exception.create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;


end.

