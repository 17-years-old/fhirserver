unit FHIRParser;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

{$IFNDEF FHIR_DSTU2}
This is the dstu2 version of the FHIR code
{$ENDIF}


interface

// FHIR v1.0.2 generated 2015-12-22T12:09:07+11:00

uses
  SysUtils, Classes, ActiveX, StringSupport, DateSupport, MsXml, FHIRParserBase, DateAndTime, RDFUtilities, FHIRBase, FHIRResources, FHIRConstants, FHIRTypes, MsXmlParser, XmlBuilder, AdvJSON, AdvStringMatches;

Type

  TFHIRXmlParser = class (TFHIRXmlParserBase)
  protected
    function ParseElement(element : IXmlDomElement; path : string) : TFhirElement;
    function ParseBackboneElement(element : IXmlDomElement; path : string) : TFhirBackboneElement;

    Procedure ParseElementAttributes(value : TFhirElement; path : string; element : IXmlDomElement);
    Function ParseBackboneElementChild(element : TFhirBackboneElement; path : string; child : IXmlDomElement) : boolean;
    Function ParseElementChild(element : TFhirElement; path : string; child : IXmlDomElement) : boolean;
    function ParseEnum(Const aNames, aSystems : Array Of String; path : String; element : IXmlDomElement) : TFhirEnum;
    function ParseInteger(element : IXmlDomElement; path : string) : TFhirInteger;
    function ParseDateTime(element : IXmlDomElement; path : string) : TFhirDateTime;
    function ParseDate(element : IXmlDomElement; path : string) : TFhirDate;
    function ParseDecimal(element : IXmlDomElement; path : string) : TFhirDecimal;
    function ParseUri(element : IXmlDomElement; path : string) : TFhirUri;
    function ParseBase64Binary(element : IXmlDomElement; path : string) : TFhirBase64Binary;
    function ParseTime(element : IXmlDomElement; path : string) : TFhirTime;
    function ParseString(element : IXmlDomElement; path : string) : TFhirString;
    function ParseBoolean(element : IXmlDomElement; path : string) : TFhirBoolean;
    function ParseInstant(element : IXmlDomElement; path : string) : TFhirInstant;
    function ParseMarkdown(element : IXmlDomElement; path : string) : TFhirMarkdown;
    function ParseUnsignedInt(element : IXmlDomElement; path : string) : TFhirUnsignedInt;
    function ParseCode(element : IXmlDomElement; path : string) : TFhirCode;
    function ParseId(element : IXmlDomElement; path : string) : TFhirId;
    function ParseOid(element : IXmlDomElement; path : string) : TFhirOid;
    function ParsePositiveInt(element : IXmlDomElement; path : string) : TFhirPositiveInt;
    function ParseUuid(element : IXmlDomElement; path : string) : TFhirUuid;

    Procedure ParseResourceAttributes(resource : TFhirResource; path : string; element : IXmlDomElement);
    Function ParseResourceChild(resource : TFhirResource; path : string; child : IXmlDomElement) : boolean;
    Procedure ParseDomainResourceAttributes(resource : TFhirDomainResource; path : string; element : IXmlDomElement);
    Function ParseDomainResourceChild(resource : TFhirDomainResource; path : string; child : IXmlDomElement) : boolean;
    function ParseParametersParameter(element : IXmlDomElement; path : string) : TFhirParametersParameter;
    function ParseParameters(element : IXmlDomElement; path : string) : TFhirParameters;

    function ParseExtension(element : IXmlDomElement; path : string) : TFhirExtension;
    function ParseNarrative(element : IXmlDomElement; path : string) : TFhirNarrative;
    function ParsePeriod(element : IXmlDomElement; path : string) : TFhirPeriod;
    function ParseCoding(element : IXmlDomElement; path : string) : TFhirCoding;
    function ParseRange(element : IXmlDomElement; path : string) : TFhirRange;
    function ParseAttachment(element : IXmlDomElement; path : string) : TFhirAttachment;
    function ParseQuantity(element : IXmlDomElement; path : string) : TFhirQuantity;
    function ParseAnnotation(element : IXmlDomElement; path : string) : TFhirAnnotation;
    function ParseRatio(element : IXmlDomElement; path : string) : TFhirRatio;
    function ParseSampledData(element : IXmlDomElement; path : string) : TFhirSampledData;
    function ParseCodeableConcept(element : IXmlDomElement; path : string) : TFhirCodeableConcept;
    function ParseReference(element : IXmlDomElement; path : string) : TFhirReference;
    function ParseIdentifier(element : IXmlDomElement; path : string) : TFhirIdentifier;
    function ParseSignature(element : IXmlDomElement; path : string) : TFhirSignature;
    function ParseTimingRepeat(element : IXmlDomElement; path : string) : TFhirTimingRepeat;
    function ParseTiming(element : IXmlDomElement; path : string) : TFhirTiming;
    function ParseElementDefinitionSlicing(element : IXmlDomElement; path : string) : TFhirElementDefinitionSlicing;
    function ParseElementDefinitionBase(element : IXmlDomElement; path : string) : TFhirElementDefinitionBase;
    function ParseElementDefinitionType(element : IXmlDomElement; path : string) : TFhirElementDefinitionType;
    function ParseElementDefinitionConstraint(element : IXmlDomElement; path : string) : TFhirElementDefinitionConstraint;
    function ParseElementDefinitionBinding(element : IXmlDomElement; path : string) : TFhirElementDefinitionBinding;
    function ParseElementDefinitionMapping(element : IXmlDomElement; path : string) : TFhirElementDefinitionMapping;
    function ParseElementDefinition(element : IXmlDomElement; path : string) : TFhirElementDefinition;
    function ParseHumanName(element : IXmlDomElement; path : string) : TFhirHumanName;
    function ParseAddress(element : IXmlDomElement; path : string) : TFhirAddress;
    function ParseMeta(element : IXmlDomElement; path : string) : TFhirMeta;
    function ParseContactPoint(element : IXmlDomElement; path : string) : TFhirContactPoint;

    function ParseAccount(element : IXmlDomElement; path : string) : TFhirAccount;
    function ParseAllergyIntoleranceReaction(element : IXmlDomElement; path : string) : TFhirAllergyIntoleranceReaction;
    function ParseAllergyIntolerance(element : IXmlDomElement; path : string) : TFhirAllergyIntolerance;
    function ParseAppointmentParticipant(element : IXmlDomElement; path : string) : TFhirAppointmentParticipant;
    function ParseAppointment(element : IXmlDomElement; path : string) : TFhirAppointment;
    function ParseAppointmentResponse(element : IXmlDomElement; path : string) : TFhirAppointmentResponse;
    function ParseAuditEventEvent(element : IXmlDomElement; path : string) : TFhirAuditEventEvent;
    function ParseAuditEventParticipant(element : IXmlDomElement; path : string) : TFhirAuditEventParticipant;
    function ParseAuditEventParticipantNetwork(element : IXmlDomElement; path : string) : TFhirAuditEventParticipantNetwork;
    function ParseAuditEventSource(element : IXmlDomElement; path : string) : TFhirAuditEventSource;
    function ParseAuditEventObject(element : IXmlDomElement; path : string) : TFhirAuditEventObject;
    function ParseAuditEventObjectDetail(element : IXmlDomElement; path : string) : TFhirAuditEventObjectDetail;
    function ParseAuditEvent(element : IXmlDomElement; path : string) : TFhirAuditEvent;
    function ParseBasic(element : IXmlDomElement; path : string) : TFhirBasic;
    function ParseBinary(element : IXmlDomElement; path : string) : TFhirBinary;
    function ParseBodySite(element : IXmlDomElement; path : string) : TFhirBodySite;
    function ParseBundleLink(element : IXmlDomElement; path : string) : TFhirBundleLink;
    function ParseBundleEntry(element : IXmlDomElement; path : string) : TFhirBundleEntry;
    function ParseBundleEntrySearch(element : IXmlDomElement; path : string) : TFhirBundleEntrySearch;
    function ParseBundleEntryRequest(element : IXmlDomElement; path : string) : TFhirBundleEntryRequest;
    function ParseBundleEntryResponse(element : IXmlDomElement; path : string) : TFhirBundleEntryResponse;
    function ParseBundle(element : IXmlDomElement; path : string) : TFhirBundle;
    function ParseCarePlanRelatedPlan(element : IXmlDomElement; path : string) : TFhirCarePlanRelatedPlan;
    function ParseCarePlanParticipant(element : IXmlDomElement; path : string) : TFhirCarePlanParticipant;
    function ParseCarePlanActivity(element : IXmlDomElement; path : string) : TFhirCarePlanActivity;
    function ParseCarePlanActivityDetail(element : IXmlDomElement; path : string) : TFhirCarePlanActivityDetail;
    function ParseCarePlan(element : IXmlDomElement; path : string) : TFhirCarePlan;
    function ParseClaimPayee(element : IXmlDomElement; path : string) : TFhirClaimPayee;
    function ParseClaimDiagnosis(element : IXmlDomElement; path : string) : TFhirClaimDiagnosis;
    function ParseClaimCoverage(element : IXmlDomElement; path : string) : TFhirClaimCoverage;
    function ParseClaimItem(element : IXmlDomElement; path : string) : TFhirClaimItem;
    function ParseClaimItemDetail(element : IXmlDomElement; path : string) : TFhirClaimItemDetail;
    function ParseClaimItemDetailSubDetail(element : IXmlDomElement; path : string) : TFhirClaimItemDetailSubDetail;
    function ParseClaimItemProsthesis(element : IXmlDomElement; path : string) : TFhirClaimItemProsthesis;
    function ParseClaimMissingTeeth(element : IXmlDomElement; path : string) : TFhirClaimMissingTeeth;
    function ParseClaim(element : IXmlDomElement; path : string) : TFhirClaim;
    function ParseClaimResponseItem(element : IXmlDomElement; path : string) : TFhirClaimResponseItem;
    function ParseClaimResponseItemAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseItemAdjudication;
    function ParseClaimResponseItemDetail(element : IXmlDomElement; path : string) : TFhirClaimResponseItemDetail;
    function ParseClaimResponseItemDetailAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseItemDetailAdjudication;
    function ParseClaimResponseItemDetailSubDetail(element : IXmlDomElement; path : string) : TFhirClaimResponseItemDetailSubDetail;
    function ParseClaimResponseItemDetailSubDetailAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseItemDetailSubDetailAdjudication;
    function ParseClaimResponseAddItem(element : IXmlDomElement; path : string) : TFhirClaimResponseAddItem;
    function ParseClaimResponseAddItemAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseAddItemAdjudication;
    function ParseClaimResponseAddItemDetail(element : IXmlDomElement; path : string) : TFhirClaimResponseAddItemDetail;
    function ParseClaimResponseAddItemDetailAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseAddItemDetailAdjudication;
    function ParseClaimResponseError(element : IXmlDomElement; path : string) : TFhirClaimResponseError;
    function ParseClaimResponseNote(element : IXmlDomElement; path : string) : TFhirClaimResponseNote;
    function ParseClaimResponseCoverage(element : IXmlDomElement; path : string) : TFhirClaimResponseCoverage;
    function ParseClaimResponse(element : IXmlDomElement; path : string) : TFhirClaimResponse;
    function ParseClinicalImpressionInvestigations(element : IXmlDomElement; path : string) : TFhirClinicalImpressionInvestigations;
    function ParseClinicalImpressionFinding(element : IXmlDomElement; path : string) : TFhirClinicalImpressionFinding;
    function ParseClinicalImpressionRuledOut(element : IXmlDomElement; path : string) : TFhirClinicalImpressionRuledOut;
    function ParseClinicalImpression(element : IXmlDomElement; path : string) : TFhirClinicalImpression;
    function ParseCommunicationPayload(element : IXmlDomElement; path : string) : TFhirCommunicationPayload;
    function ParseCommunication(element : IXmlDomElement; path : string) : TFhirCommunication;
    function ParseCommunicationRequestPayload(element : IXmlDomElement; path : string) : TFhirCommunicationRequestPayload;
    function ParseCommunicationRequest(element : IXmlDomElement; path : string) : TFhirCommunicationRequest;
    function ParseCompositionAttester(element : IXmlDomElement; path : string) : TFhirCompositionAttester;
    function ParseCompositionEvent(element : IXmlDomElement; path : string) : TFhirCompositionEvent;
    function ParseCompositionSection(element : IXmlDomElement; path : string) : TFhirCompositionSection;
    function ParseComposition(element : IXmlDomElement; path : string) : TFhirComposition;
    function ParseConceptMapContact(element : IXmlDomElement; path : string) : TFhirConceptMapContact;
    function ParseConceptMapElement(element : IXmlDomElement; path : string) : TFhirConceptMapElement;
    function ParseConceptMapElementTarget(element : IXmlDomElement; path : string) : TFhirConceptMapElementTarget;
    function ParseConceptMapElementTargetDependsOn(element : IXmlDomElement; path : string) : TFhirConceptMapElementTargetDependsOn;
    function ParseConceptMap(element : IXmlDomElement; path : string) : TFhirConceptMap;
    function ParseConditionStage(element : IXmlDomElement; path : string) : TFhirConditionStage;
    function ParseConditionEvidence(element : IXmlDomElement; path : string) : TFhirConditionEvidence;
    function ParseCondition(element : IXmlDomElement; path : string) : TFhirCondition;
    function ParseConformanceContact(element : IXmlDomElement; path : string) : TFhirConformanceContact;
    function ParseConformanceSoftware(element : IXmlDomElement; path : string) : TFhirConformanceSoftware;
    function ParseConformanceImplementation(element : IXmlDomElement; path : string) : TFhirConformanceImplementation;
    function ParseConformanceRest(element : IXmlDomElement; path : string) : TFhirConformanceRest;
    function ParseConformanceRestSecurity(element : IXmlDomElement; path : string) : TFhirConformanceRestSecurity;
    function ParseConformanceRestSecurityCertificate(element : IXmlDomElement; path : string) : TFhirConformanceRestSecurityCertificate;
    function ParseConformanceRestResource(element : IXmlDomElement; path : string) : TFhirConformanceRestResource;
    function ParseConformanceRestResourceInteraction(element : IXmlDomElement; path : string) : TFhirConformanceRestResourceInteraction;
    function ParseConformanceRestResourceSearchParam(element : IXmlDomElement; path : string) : TFhirConformanceRestResourceSearchParam;
    function ParseConformanceRestInteraction(element : IXmlDomElement; path : string) : TFhirConformanceRestInteraction;
    function ParseConformanceRestOperation(element : IXmlDomElement; path : string) : TFhirConformanceRestOperation;
    function ParseConformanceMessaging(element : IXmlDomElement; path : string) : TFhirConformanceMessaging;
    function ParseConformanceMessagingEndpoint(element : IXmlDomElement; path : string) : TFhirConformanceMessagingEndpoint;
    function ParseConformanceMessagingEvent(element : IXmlDomElement; path : string) : TFhirConformanceMessagingEvent;
    function ParseConformanceDocument(element : IXmlDomElement; path : string) : TFhirConformanceDocument;
    function ParseConformance(element : IXmlDomElement; path : string) : TFhirConformance;
    function ParseContractActor(element : IXmlDomElement; path : string) : TFhirContractActor;
    function ParseContractValuedItem(element : IXmlDomElement; path : string) : TFhirContractValuedItem;
    function ParseContractSigner(element : IXmlDomElement; path : string) : TFhirContractSigner;
    function ParseContractTerm(element : IXmlDomElement; path : string) : TFhirContractTerm;
    function ParseContractTermActor(element : IXmlDomElement; path : string) : TFhirContractTermActor;
    function ParseContractTermValuedItem(element : IXmlDomElement; path : string) : TFhirContractTermValuedItem;
    function ParseContractFriendly(element : IXmlDomElement; path : string) : TFhirContractFriendly;
    function ParseContractLegal(element : IXmlDomElement; path : string) : TFhirContractLegal;
    function ParseContractRule(element : IXmlDomElement; path : string) : TFhirContractRule;
    function ParseContract(element : IXmlDomElement; path : string) : TFhirContract;
    function ParseCoverage(element : IXmlDomElement; path : string) : TFhirCoverage;
    function ParseDataElementContact(element : IXmlDomElement; path : string) : TFhirDataElementContact;
    function ParseDataElementMapping(element : IXmlDomElement; path : string) : TFhirDataElementMapping;
    function ParseDataElement(element : IXmlDomElement; path : string) : TFhirDataElement;
    function ParseDetectedIssueMitigation(element : IXmlDomElement; path : string) : TFhirDetectedIssueMitigation;
    function ParseDetectedIssue(element : IXmlDomElement; path : string) : TFhirDetectedIssue;
    function ParseDevice(element : IXmlDomElement; path : string) : TFhirDevice;
    function ParseDeviceComponentProductionSpecification(element : IXmlDomElement; path : string) : TFhirDeviceComponentProductionSpecification;
    function ParseDeviceComponent(element : IXmlDomElement; path : string) : TFhirDeviceComponent;
    function ParseDeviceMetricCalibration(element : IXmlDomElement; path : string) : TFhirDeviceMetricCalibration;
    function ParseDeviceMetric(element : IXmlDomElement; path : string) : TFhirDeviceMetric;
    function ParseDeviceUseRequest(element : IXmlDomElement; path : string) : TFhirDeviceUseRequest;
    function ParseDeviceUseStatement(element : IXmlDomElement; path : string) : TFhirDeviceUseStatement;
    function ParseDiagnosticOrderEvent(element : IXmlDomElement; path : string) : TFhirDiagnosticOrderEvent;
    function ParseDiagnosticOrderItem(element : IXmlDomElement; path : string) : TFhirDiagnosticOrderItem;
    function ParseDiagnosticOrder(element : IXmlDomElement; path : string) : TFhirDiagnosticOrder;
    function ParseDiagnosticReportImage(element : IXmlDomElement; path : string) : TFhirDiagnosticReportImage;
    function ParseDiagnosticReport(element : IXmlDomElement; path : string) : TFhirDiagnosticReport;
    function ParseDocumentManifestContent(element : IXmlDomElement; path : string) : TFhirDocumentManifestContent;
    function ParseDocumentManifestRelated(element : IXmlDomElement; path : string) : TFhirDocumentManifestRelated;
    function ParseDocumentManifest(element : IXmlDomElement; path : string) : TFhirDocumentManifest;
    function ParseDocumentReferenceRelatesTo(element : IXmlDomElement; path : string) : TFhirDocumentReferenceRelatesTo;
    function ParseDocumentReferenceContent(element : IXmlDomElement; path : string) : TFhirDocumentReferenceContent;
    function ParseDocumentReferenceContext(element : IXmlDomElement; path : string) : TFhirDocumentReferenceContext;
    function ParseDocumentReferenceContextRelated(element : IXmlDomElement; path : string) : TFhirDocumentReferenceContextRelated;
    function ParseDocumentReference(element : IXmlDomElement; path : string) : TFhirDocumentReference;
    function ParseEligibilityRequest(element : IXmlDomElement; path : string) : TFhirEligibilityRequest;
    function ParseEligibilityResponse(element : IXmlDomElement; path : string) : TFhirEligibilityResponse;
    function ParseEncounterStatusHistory(element : IXmlDomElement; path : string) : TFhirEncounterStatusHistory;
    function ParseEncounterParticipant(element : IXmlDomElement; path : string) : TFhirEncounterParticipant;
    function ParseEncounterHospitalization(element : IXmlDomElement; path : string) : TFhirEncounterHospitalization;
    function ParseEncounterLocation(element : IXmlDomElement; path : string) : TFhirEncounterLocation;
    function ParseEncounter(element : IXmlDomElement; path : string) : TFhirEncounter;
    function ParseEnrollmentRequest(element : IXmlDomElement; path : string) : TFhirEnrollmentRequest;
    function ParseEnrollmentResponse(element : IXmlDomElement; path : string) : TFhirEnrollmentResponse;
    function ParseEpisodeOfCareStatusHistory(element : IXmlDomElement; path : string) : TFhirEpisodeOfCareStatusHistory;
    function ParseEpisodeOfCareCareTeam(element : IXmlDomElement; path : string) : TFhirEpisodeOfCareCareTeam;
    function ParseEpisodeOfCare(element : IXmlDomElement; path : string) : TFhirEpisodeOfCare;
    function ParseExplanationOfBenefit(element : IXmlDomElement; path : string) : TFhirExplanationOfBenefit;
    function ParseFamilyMemberHistoryCondition(element : IXmlDomElement; path : string) : TFhirFamilyMemberHistoryCondition;
    function ParseFamilyMemberHistory(element : IXmlDomElement; path : string) : TFhirFamilyMemberHistory;
    function ParseFlag(element : IXmlDomElement; path : string) : TFhirFlag;
    function ParseGoalOutcome(element : IXmlDomElement; path : string) : TFhirGoalOutcome;
    function ParseGoal(element : IXmlDomElement; path : string) : TFhirGoal;
    function ParseGroupCharacteristic(element : IXmlDomElement; path : string) : TFhirGroupCharacteristic;
    function ParseGroupMember(element : IXmlDomElement; path : string) : TFhirGroupMember;
    function ParseGroup(element : IXmlDomElement; path : string) : TFhirGroup;
    function ParseHealthcareServiceServiceType(element : IXmlDomElement; path : string) : TFhirHealthcareServiceServiceType;
    function ParseHealthcareServiceAvailableTime(element : IXmlDomElement; path : string) : TFhirHealthcareServiceAvailableTime;
    function ParseHealthcareServiceNotAvailable(element : IXmlDomElement; path : string) : TFhirHealthcareServiceNotAvailable;
    function ParseHealthcareService(element : IXmlDomElement; path : string) : TFhirHealthcareService;
    function ParseImagingObjectSelectionStudy(element : IXmlDomElement; path : string) : TFhirImagingObjectSelectionStudy;
    function ParseImagingObjectSelectionStudySeries(element : IXmlDomElement; path : string) : TFhirImagingObjectSelectionStudySeries;
    function ParseImagingObjectSelectionStudySeriesInstance(element : IXmlDomElement; path : string) : TFhirImagingObjectSelectionStudySeriesInstance;
    function ParseImagingObjectSelectionStudySeriesInstanceFrames(element : IXmlDomElement; path : string) : TFhirImagingObjectSelectionStudySeriesInstanceFrames;
    function ParseImagingObjectSelection(element : IXmlDomElement; path : string) : TFhirImagingObjectSelection;
    function ParseImagingStudySeries(element : IXmlDomElement; path : string) : TFhirImagingStudySeries;
    function ParseImagingStudySeriesInstance(element : IXmlDomElement; path : string) : TFhirImagingStudySeriesInstance;
    function ParseImagingStudy(element : IXmlDomElement; path : string) : TFhirImagingStudy;
    function ParseImmunizationExplanation(element : IXmlDomElement; path : string) : TFhirImmunizationExplanation;
    function ParseImmunizationReaction(element : IXmlDomElement; path : string) : TFhirImmunizationReaction;
    function ParseImmunizationVaccinationProtocol(element : IXmlDomElement; path : string) : TFhirImmunizationVaccinationProtocol;
    function ParseImmunization(element : IXmlDomElement; path : string) : TFhirImmunization;
    function ParseImmunizationRecommendationRecommendation(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendation;
    function ParseImmunizationRecommendationRecommendationDateCriterion(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    function ParseImmunizationRecommendationRecommendationProtocol(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendationProtocol;
    function ParseImmunizationRecommendation(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendation;
    function ParseImplementationGuideContact(element : IXmlDomElement; path : string) : TFhirImplementationGuideContact;
    function ParseImplementationGuideDependency(element : IXmlDomElement; path : string) : TFhirImplementationGuideDependency;
    function ParseImplementationGuidePackage(element : IXmlDomElement; path : string) : TFhirImplementationGuidePackage;
    function ParseImplementationGuidePackageResource(element : IXmlDomElement; path : string) : TFhirImplementationGuidePackageResource;
    function ParseImplementationGuideGlobal(element : IXmlDomElement; path : string) : TFhirImplementationGuideGlobal;
    function ParseImplementationGuidePage(element : IXmlDomElement; path : string) : TFhirImplementationGuidePage;
    function ParseImplementationGuide(element : IXmlDomElement; path : string) : TFhirImplementationGuide;
    function ParseListEntry(element : IXmlDomElement; path : string) : TFhirListEntry;
    function ParseList(element : IXmlDomElement; path : string) : TFhirList;
    function ParseLocationPosition(element : IXmlDomElement; path : string) : TFhirLocationPosition;
    function ParseLocation(element : IXmlDomElement; path : string) : TFhirLocation;
    function ParseMedia(element : IXmlDomElement; path : string) : TFhirMedia;
    function ParseMedicationProduct(element : IXmlDomElement; path : string) : TFhirMedicationProduct;
    function ParseMedicationProductIngredient(element : IXmlDomElement; path : string) : TFhirMedicationProductIngredient;
    function ParseMedicationProductBatch(element : IXmlDomElement; path : string) : TFhirMedicationProductBatch;
    function ParseMedicationPackage(element : IXmlDomElement; path : string) : TFhirMedicationPackage;
    function ParseMedicationPackageContent(element : IXmlDomElement; path : string) : TFhirMedicationPackageContent;
    function ParseMedication(element : IXmlDomElement; path : string) : TFhirMedication;
    function ParseMedicationAdministrationDosage(element : IXmlDomElement; path : string) : TFhirMedicationAdministrationDosage;
    function ParseMedicationAdministration(element : IXmlDomElement; path : string) : TFhirMedicationAdministration;
    function ParseMedicationDispenseDosageInstruction(element : IXmlDomElement; path : string) : TFhirMedicationDispenseDosageInstruction;
    function ParseMedicationDispenseSubstitution(element : IXmlDomElement; path : string) : TFhirMedicationDispenseSubstitution;
    function ParseMedicationDispense(element : IXmlDomElement; path : string) : TFhirMedicationDispense;
    function ParseMedicationOrderDosageInstruction(element : IXmlDomElement; path : string) : TFhirMedicationOrderDosageInstruction;
    function ParseMedicationOrderDispenseRequest(element : IXmlDomElement; path : string) : TFhirMedicationOrderDispenseRequest;
    function ParseMedicationOrderSubstitution(element : IXmlDomElement; path : string) : TFhirMedicationOrderSubstitution;
    function ParseMedicationOrder(element : IXmlDomElement; path : string) : TFhirMedicationOrder;
    function ParseMedicationStatementDosage(element : IXmlDomElement; path : string) : TFhirMedicationStatementDosage;
    function ParseMedicationStatement(element : IXmlDomElement; path : string) : TFhirMedicationStatement;
    function ParseMessageHeaderResponse(element : IXmlDomElement; path : string) : TFhirMessageHeaderResponse;
    function ParseMessageHeaderSource(element : IXmlDomElement; path : string) : TFhirMessageHeaderSource;
    function ParseMessageHeaderDestination(element : IXmlDomElement; path : string) : TFhirMessageHeaderDestination;
    function ParseMessageHeader(element : IXmlDomElement; path : string) : TFhirMessageHeader;
    function ParseNamingSystemContact(element : IXmlDomElement; path : string) : TFhirNamingSystemContact;
    function ParseNamingSystemUniqueId(element : IXmlDomElement; path : string) : TFhirNamingSystemUniqueId;
    function ParseNamingSystem(element : IXmlDomElement; path : string) : TFhirNamingSystem;
    function ParseNutritionOrderOralDiet(element : IXmlDomElement; path : string) : TFhirNutritionOrderOralDiet;
    function ParseNutritionOrderOralDietNutrient(element : IXmlDomElement; path : string) : TFhirNutritionOrderOralDietNutrient;
    function ParseNutritionOrderOralDietTexture(element : IXmlDomElement; path : string) : TFhirNutritionOrderOralDietTexture;
    function ParseNutritionOrderSupplement(element : IXmlDomElement; path : string) : TFhirNutritionOrderSupplement;
    function ParseNutritionOrderEnteralFormula(element : IXmlDomElement; path : string) : TFhirNutritionOrderEnteralFormula;
    function ParseNutritionOrderEnteralFormulaAdministration(element : IXmlDomElement; path : string) : TFhirNutritionOrderEnteralFormulaAdministration;
    function ParseNutritionOrder(element : IXmlDomElement; path : string) : TFhirNutritionOrder;
    function ParseObservationReferenceRange(element : IXmlDomElement; path : string) : TFhirObservationReferenceRange;
    function ParseObservationRelated(element : IXmlDomElement; path : string) : TFhirObservationRelated;
    function ParseObservationComponent(element : IXmlDomElement; path : string) : TFhirObservationComponent;
    function ParseObservation(element : IXmlDomElement; path : string) : TFhirObservation;
    function ParseOperationDefinitionContact(element : IXmlDomElement; path : string) : TFhirOperationDefinitionContact;
    function ParseOperationDefinitionParameter(element : IXmlDomElement; path : string) : TFhirOperationDefinitionParameter;
    function ParseOperationDefinitionParameterBinding(element : IXmlDomElement; path : string) : TFhirOperationDefinitionParameterBinding;
    function ParseOperationDefinition(element : IXmlDomElement; path : string) : TFhirOperationDefinition;
    function ParseOperationOutcomeIssue(element : IXmlDomElement; path : string) : TFhirOperationOutcomeIssue;
    function ParseOperationOutcome(element : IXmlDomElement; path : string) : TFhirOperationOutcome;
    function ParseOrderWhen(element : IXmlDomElement; path : string) : TFhirOrderWhen;
    function ParseOrder(element : IXmlDomElement; path : string) : TFhirOrder;
    function ParseOrderResponse(element : IXmlDomElement; path : string) : TFhirOrderResponse;
    function ParseOrganizationContact(element : IXmlDomElement; path : string) : TFhirOrganizationContact;
    function ParseOrganization(element : IXmlDomElement; path : string) : TFhirOrganization;
    function ParsePatientContact(element : IXmlDomElement; path : string) : TFhirPatientContact;
    function ParsePatientAnimal(element : IXmlDomElement; path : string) : TFhirPatientAnimal;
    function ParsePatientCommunication(element : IXmlDomElement; path : string) : TFhirPatientCommunication;
    function ParsePatientLink(element : IXmlDomElement; path : string) : TFhirPatientLink;
    function ParsePatient(element : IXmlDomElement; path : string) : TFhirPatient;
    function ParsePaymentNotice(element : IXmlDomElement; path : string) : TFhirPaymentNotice;
    function ParsePaymentReconciliationDetail(element : IXmlDomElement; path : string) : TFhirPaymentReconciliationDetail;
    function ParsePaymentReconciliationNote(element : IXmlDomElement; path : string) : TFhirPaymentReconciliationNote;
    function ParsePaymentReconciliation(element : IXmlDomElement; path : string) : TFhirPaymentReconciliation;
    function ParsePersonLink(element : IXmlDomElement; path : string) : TFhirPersonLink;
    function ParsePerson(element : IXmlDomElement; path : string) : TFhirPerson;
    function ParsePractitionerPractitionerRole(element : IXmlDomElement; path : string) : TFhirPractitionerPractitionerRole;
    function ParsePractitionerQualification(element : IXmlDomElement; path : string) : TFhirPractitionerQualification;
    function ParsePractitioner(element : IXmlDomElement; path : string) : TFhirPractitioner;
    function ParseProcedurePerformer(element : IXmlDomElement; path : string) : TFhirProcedurePerformer;
    function ParseProcedureFocalDevice(element : IXmlDomElement; path : string) : TFhirProcedureFocalDevice;
    function ParseProcedure(element : IXmlDomElement; path : string) : TFhirProcedure;
    function ParseProcedureRequest(element : IXmlDomElement; path : string) : TFhirProcedureRequest;
    function ParseProcessRequestItem(element : IXmlDomElement; path : string) : TFhirProcessRequestItem;
    function ParseProcessRequest(element : IXmlDomElement; path : string) : TFhirProcessRequest;
    function ParseProcessResponseNotes(element : IXmlDomElement; path : string) : TFhirProcessResponseNotes;
    function ParseProcessResponse(element : IXmlDomElement; path : string) : TFhirProcessResponse;
    function ParseProvenanceAgent(element : IXmlDomElement; path : string) : TFhirProvenanceAgent;
    function ParseProvenanceAgentRelatedAgent(element : IXmlDomElement; path : string) : TFhirProvenanceAgentRelatedAgent;
    function ParseProvenanceEntity(element : IXmlDomElement; path : string) : TFhirProvenanceEntity;
    function ParseProvenance(element : IXmlDomElement; path : string) : TFhirProvenance;
    function ParseQuestionnaireGroup(element : IXmlDomElement; path : string) : TFhirQuestionnaireGroup;
    function ParseQuestionnaireGroupQuestion(element : IXmlDomElement; path : string) : TFhirQuestionnaireGroupQuestion;
    function ParseQuestionnaire(element : IXmlDomElement; path : string) : TFhirQuestionnaire;
    function ParseQuestionnaireResponseGroup(element : IXmlDomElement; path : string) : TFhirQuestionnaireResponseGroup;
    function ParseQuestionnaireResponseGroupQuestion(element : IXmlDomElement; path : string) : TFhirQuestionnaireResponseGroupQuestion;
    function ParseQuestionnaireResponseGroupQuestionAnswer(element : IXmlDomElement; path : string) : TFhirQuestionnaireResponseGroupQuestionAnswer;
    function ParseQuestionnaireResponse(element : IXmlDomElement; path : string) : TFhirQuestionnaireResponse;
    function ParseReferralRequest(element : IXmlDomElement; path : string) : TFhirReferralRequest;
    function ParseRelatedPerson(element : IXmlDomElement; path : string) : TFhirRelatedPerson;
    function ParseRiskAssessmentPrediction(element : IXmlDomElement; path : string) : TFhirRiskAssessmentPrediction;
    function ParseRiskAssessment(element : IXmlDomElement; path : string) : TFhirRiskAssessment;
    function ParseSchedule(element : IXmlDomElement; path : string) : TFhirSchedule;
    function ParseSearchParameterContact(element : IXmlDomElement; path : string) : TFhirSearchParameterContact;
    function ParseSearchParameter(element : IXmlDomElement; path : string) : TFhirSearchParameter;
    function ParseSlot(element : IXmlDomElement; path : string) : TFhirSlot;
    function ParseSpecimenCollection(element : IXmlDomElement; path : string) : TFhirSpecimenCollection;
    function ParseSpecimenTreatment(element : IXmlDomElement; path : string) : TFhirSpecimenTreatment;
    function ParseSpecimenContainer(element : IXmlDomElement; path : string) : TFhirSpecimenContainer;
    function ParseSpecimen(element : IXmlDomElement; path : string) : TFhirSpecimen;
    function ParseStructureDefinitionContact(element : IXmlDomElement; path : string) : TFhirStructureDefinitionContact;
    function ParseStructureDefinitionMapping(element : IXmlDomElement; path : string) : TFhirStructureDefinitionMapping;
    function ParseStructureDefinitionSnapshot(element : IXmlDomElement; path : string) : TFhirStructureDefinitionSnapshot;
    function ParseStructureDefinitionDifferential(element : IXmlDomElement; path : string) : TFhirStructureDefinitionDifferential;
    function ParseStructureDefinition(element : IXmlDomElement; path : string) : TFhirStructureDefinition;
    function ParseSubscriptionChannel(element : IXmlDomElement; path : string) : TFhirSubscriptionChannel;
    function ParseSubscription(element : IXmlDomElement; path : string) : TFhirSubscription;
    function ParseSubstanceInstance(element : IXmlDomElement; path : string) : TFhirSubstanceInstance;
    function ParseSubstanceIngredient(element : IXmlDomElement; path : string) : TFhirSubstanceIngredient;
    function ParseSubstance(element : IXmlDomElement; path : string) : TFhirSubstance;
    function ParseSupplyDelivery(element : IXmlDomElement; path : string) : TFhirSupplyDelivery;
    function ParseSupplyRequestWhen(element : IXmlDomElement; path : string) : TFhirSupplyRequestWhen;
    function ParseSupplyRequest(element : IXmlDomElement; path : string) : TFhirSupplyRequest;
    function ParseTestScriptContact(element : IXmlDomElement; path : string) : TFhirTestScriptContact;
    function ParseTestScriptMetadata(element : IXmlDomElement; path : string) : TFhirTestScriptMetadata;
    function ParseTestScriptMetadataLink(element : IXmlDomElement; path : string) : TFhirTestScriptMetadataLink;
    function ParseTestScriptMetadataCapability(element : IXmlDomElement; path : string) : TFhirTestScriptMetadataCapability;
    function ParseTestScriptFixture(element : IXmlDomElement; path : string) : TFhirTestScriptFixture;
    function ParseTestScriptVariable(element : IXmlDomElement; path : string) : TFhirTestScriptVariable;
    function ParseTestScriptSetup(element : IXmlDomElement; path : string) : TFhirTestScriptSetup;
    function ParseTestScriptSetupAction(element : IXmlDomElement; path : string) : TFhirTestScriptSetupAction;
    function ParseTestScriptSetupActionOperation(element : IXmlDomElement; path : string) : TFhirTestScriptSetupActionOperation;
    function ParseTestScriptSetupActionOperationRequestHeader(element : IXmlDomElement; path : string) : TFhirTestScriptSetupActionOperationRequestHeader;
    function ParseTestScriptSetupActionAssert(element : IXmlDomElement; path : string) : TFhirTestScriptSetupActionAssert;
    function ParseTestScriptTest(element : IXmlDomElement; path : string) : TFhirTestScriptTest;
    function ParseTestScriptTestAction(element : IXmlDomElement; path : string) : TFhirTestScriptTestAction;
    function ParseTestScriptTeardown(element : IXmlDomElement; path : string) : TFhirTestScriptTeardown;
    function ParseTestScriptTeardownAction(element : IXmlDomElement; path : string) : TFhirTestScriptTeardownAction;
    function ParseTestScript(element : IXmlDomElement; path : string) : TFhirTestScript;
    function ParseValueSetContact(element : IXmlDomElement; path : string) : TFhirValueSetContact;
    function ParseValueSetCodeSystem(element : IXmlDomElement; path : string) : TFhirValueSetCodeSystem;
    function ParseValueSetCodeSystemConcept(element : IXmlDomElement; path : string) : TFhirValueSetCodeSystemConcept;
    function ParseValueSetCodeSystemConceptDesignation(element : IXmlDomElement; path : string) : TFhirValueSetCodeSystemConceptDesignation;
    function ParseValueSetCompose(element : IXmlDomElement; path : string) : TFhirValueSetCompose;
    function ParseValueSetComposeInclude(element : IXmlDomElement; path : string) : TFhirValueSetComposeInclude;
    function ParseValueSetComposeIncludeConcept(element : IXmlDomElement; path : string) : TFhirValueSetComposeIncludeConcept;
    function ParseValueSetComposeIncludeFilter(element : IXmlDomElement; path : string) : TFhirValueSetComposeIncludeFilter;
    function ParseValueSetExpansion(element : IXmlDomElement; path : string) : TFhirValueSetExpansion;
    function ParseValueSetExpansionParameter(element : IXmlDomElement; path : string) : TFhirValueSetExpansionParameter;
    function ParseValueSetExpansionContains(element : IXmlDomElement; path : string) : TFhirValueSetExpansionContains;
    function ParseValueSet(element : IXmlDomElement; path : string) : TFhirValueSet;
    function ParseVisionPrescriptionDispense(element : IXmlDomElement; path : string) : TFhirVisionPrescriptionDispense;
    function ParseVisionPrescription(element : IXmlDomElement; path : string) : TFhirVisionPrescription;
    function ParseResource(element : IxmlDomElement; path : String) : TFhirResource; override;
    function ParseDataType(element : IXmlDomElement; name : String; type_ : TFHIRTypeClass) : TFHIRType; override;
  public
    function ParseFragment(element : IxmlDomElement) : TFhirBase; overload;
  end;

  TFHIRXmlComposer = class (TFHIRXmlComposerBase)
  protected
    procedure ComposeElement(xml : TXmlBuilder; name : string; elem : TFhirElement);
    procedure ComposeBackboneElement(xml : TXmlBuilder; name : string; elem : TFhirBackboneElement);

    Procedure ComposeElementAttributes(xml : TXmlBuilder; element : TFhirElement);
    Procedure ComposeElementChildren(xml : TXmlBuilder; element : TFhirElement);
    Procedure ComposeBackboneElementChildren(xml : TXmlBuilder; element : TFhirBackboneElement);
    Procedure ComposeEnum(xml : TXmlBuilder; name : String; value : TFhirEnum; Const aNames : Array Of String);
    Procedure ComposeInteger(xml : TXmlBuilder; name : String; value : TFhirInteger);
    Procedure ComposeDateTime(xml : TXmlBuilder; name : String; value : TFhirDateTime);
    Procedure ComposeDate(xml : TXmlBuilder; name : String; value : TFhirDate);
    Procedure ComposeDecimal(xml : TXmlBuilder; name : String; value : TFhirDecimal);
    Procedure ComposeUri(xml : TXmlBuilder; name : String; value : TFhirUri);
    Procedure ComposeBase64Binary(xml : TXmlBuilder; name : String; value : TFhirBase64Binary);
    Procedure ComposeTime(xml : TXmlBuilder; name : String; value : TFhirTime);
    Procedure ComposeString(xml : TXmlBuilder; name : String; value : TFhirString);
    Procedure ComposeBoolean(xml : TXmlBuilder; name : String; value : TFhirBoolean);
    Procedure ComposeInstant(xml : TXmlBuilder; name : String; value : TFhirInstant);
    Procedure ComposeMarkdown(xml : TXmlBuilder; name : String; value : TFhirMarkdown);
    Procedure ComposeUnsignedInt(xml : TXmlBuilder; name : String; value : TFhirUnsignedInt);
    Procedure ComposeCode(xml : TXmlBuilder; name : String; value : TFhirCode);
    Procedure ComposeId(xml : TXmlBuilder; name : String; value : TFhirId);
    Procedure ComposeOid(xml : TXmlBuilder; name : String; value : TFhirOid);
    Procedure ComposePositiveInt(xml : TXmlBuilder; name : String; value : TFhirPositiveInt);
    Procedure ComposeUuid(xml : TXmlBuilder; name : String; value : TFhirUuid);

    Procedure ComposeResourceAttributes(xml : TXmlBuilder; resource : TFhirResource);
    Procedure ComposeResourceChildren(xml : TXmlBuilder; elem : TFhirResource);
    Procedure ComposeDomainResourceAttributes(xml : TXmlBuilder; resource : TFhirDomainResource);
    Procedure ComposeDomainResourceChildren(xml : TXmlBuilder; elem : TFhirDomainResource);
    procedure ComposeParametersParameter(xml : TXmlBuilder; name : string; elem : TFhirParametersParameter);
    procedure ComposeParameters(xml : TXmlBuilder; name : string; elem : TFhirParameters);

    procedure ComposeExtension(xml : TXmlBuilder; name : string; elem : TFhirExtension);
    procedure ComposeNarrative(xml : TXmlBuilder; name : string; elem : TFhirNarrative);
    procedure ComposePeriod(xml : TXmlBuilder; name : string; elem : TFhirPeriod);
    procedure ComposeCoding(xml : TXmlBuilder; name : string; elem : TFhirCoding);
    procedure ComposeRange(xml : TXmlBuilder; name : string; elem : TFhirRange);
    procedure ComposeAttachment(xml : TXmlBuilder; name : string; elem : TFhirAttachment);
    procedure ComposeQuantity(xml : TXmlBuilder; name : string; elem : TFhirQuantity);
    procedure ComposeAnnotation(xml : TXmlBuilder; name : string; elem : TFhirAnnotation);
    procedure ComposeRatio(xml : TXmlBuilder; name : string; elem : TFhirRatio);
    procedure ComposeSampledData(xml : TXmlBuilder; name : string; elem : TFhirSampledData);
    procedure ComposeCodeableConcept(xml : TXmlBuilder; name : string; elem : TFhirCodeableConcept);
    procedure ComposeReference(xml : TXmlBuilder; name : string; elem : TFhirReference);
    procedure ComposeIdentifier(xml : TXmlBuilder; name : string; elem : TFhirIdentifier);
    procedure ComposeSignature(xml : TXmlBuilder; name : string; elem : TFhirSignature);
    procedure ComposeTimingRepeat(xml : TXmlBuilder; name : string; elem : TFhirTimingRepeat);
    procedure ComposeTiming(xml : TXmlBuilder; name : string; elem : TFhirTiming);
    procedure ComposeElementDefinitionSlicing(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionSlicing);
    procedure ComposeElementDefinitionBase(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionBase);
    procedure ComposeElementDefinitionType(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionType);
    procedure ComposeElementDefinitionConstraint(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionConstraint);
    procedure ComposeElementDefinitionBinding(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionBinding);
    procedure ComposeElementDefinitionMapping(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionMapping);
    procedure ComposeElementDefinition(xml : TXmlBuilder; name : string; elem : TFhirElementDefinition);
    procedure ComposeHumanName(xml : TXmlBuilder; name : string; elem : TFhirHumanName);
    procedure ComposeAddress(xml : TXmlBuilder; name : string; elem : TFhirAddress);
    procedure ComposeMeta(xml : TXmlBuilder; name : string; elem : TFhirMeta);
    procedure ComposeContactPoint(xml : TXmlBuilder; name : string; elem : TFhirContactPoint);

    procedure ComposeAccount(xml : TXmlBuilder; name : string; elem : TFhirAccount);
    procedure ComposeAllergyIntoleranceReaction(xml : TXmlBuilder; name : string; elem : TFhirAllergyIntoleranceReaction);
    procedure ComposeAllergyIntolerance(xml : TXmlBuilder; name : string; elem : TFhirAllergyIntolerance);
    procedure ComposeAppointmentParticipant(xml : TXmlBuilder; name : string; elem : TFhirAppointmentParticipant);
    procedure ComposeAppointment(xml : TXmlBuilder; name : string; elem : TFhirAppointment);
    procedure ComposeAppointmentResponse(xml : TXmlBuilder; name : string; elem : TFhirAppointmentResponse);
    procedure ComposeAuditEventEvent(xml : TXmlBuilder; name : string; elem : TFhirAuditEventEvent);
    procedure ComposeAuditEventParticipant(xml : TXmlBuilder; name : string; elem : TFhirAuditEventParticipant);
    procedure ComposeAuditEventParticipantNetwork(xml : TXmlBuilder; name : string; elem : TFhirAuditEventParticipantNetwork);
    procedure ComposeAuditEventSource(xml : TXmlBuilder; name : string; elem : TFhirAuditEventSource);
    procedure ComposeAuditEventObject(xml : TXmlBuilder; name : string; elem : TFhirAuditEventObject);
    procedure ComposeAuditEventObjectDetail(xml : TXmlBuilder; name : string; elem : TFhirAuditEventObjectDetail);
    procedure ComposeAuditEvent(xml : TXmlBuilder; name : string; elem : TFhirAuditEvent);
    procedure ComposeBasic(xml : TXmlBuilder; name : string; elem : TFhirBasic);
    procedure ComposeBinary(xml : TXmlBuilder; name : string; elem : TFhirBinary);
    procedure ComposeBodySite(xml : TXmlBuilder; name : string; elem : TFhirBodySite);
    procedure ComposeBundleLink(xml : TXmlBuilder; name : string; elem : TFhirBundleLink);
    procedure ComposeBundleEntry(xml : TXmlBuilder; name : string; elem : TFhirBundleEntry);
    procedure ComposeBundleEntrySearch(xml : TXmlBuilder; name : string; elem : TFhirBundleEntrySearch);
    procedure ComposeBundleEntryRequest(xml : TXmlBuilder; name : string; elem : TFhirBundleEntryRequest);
    procedure ComposeBundleEntryResponse(xml : TXmlBuilder; name : string; elem : TFhirBundleEntryResponse);
    procedure ComposeBundle(xml : TXmlBuilder; name : string; elem : TFhirBundle);
    procedure ComposeCarePlanRelatedPlan(xml : TXmlBuilder; name : string; elem : TFhirCarePlanRelatedPlan);
    procedure ComposeCarePlanParticipant(xml : TXmlBuilder; name : string; elem : TFhirCarePlanParticipant);
    procedure ComposeCarePlanActivity(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivity);
    procedure ComposeCarePlanActivityDetail(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivityDetail);
    procedure ComposeCarePlan(xml : TXmlBuilder; name : string; elem : TFhirCarePlan);
    procedure ComposeClaimPayee(xml : TXmlBuilder; name : string; elem : TFhirClaimPayee);
    procedure ComposeClaimDiagnosis(xml : TXmlBuilder; name : string; elem : TFhirClaimDiagnosis);
    procedure ComposeClaimCoverage(xml : TXmlBuilder; name : string; elem : TFhirClaimCoverage);
    procedure ComposeClaimItem(xml : TXmlBuilder; name : string; elem : TFhirClaimItem);
    procedure ComposeClaimItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimItemDetail);
    procedure ComposeClaimItemDetailSubDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimItemDetailSubDetail);
    procedure ComposeClaimItemProsthesis(xml : TXmlBuilder; name : string; elem : TFhirClaimItemProsthesis);
    procedure ComposeClaimMissingTeeth(xml : TXmlBuilder; name : string; elem : TFhirClaimMissingTeeth);
    procedure ComposeClaim(xml : TXmlBuilder; name : string; elem : TFhirClaim);
    procedure ComposeClaimResponseItem(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItem);
    procedure ComposeClaimResponseItemAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemAdjudication);
    procedure ComposeClaimResponseItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetail);
    procedure ComposeClaimResponseItemDetailAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetailAdjudication);
    procedure ComposeClaimResponseItemDetailSubDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetailSubDetail);
    procedure ComposeClaimResponseItemDetailSubDetailAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetailSubDetailAdjudication);
    procedure ComposeClaimResponseAddItem(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItem);
    procedure ComposeClaimResponseAddItemAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItemAdjudication);
    procedure ComposeClaimResponseAddItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItemDetail);
    procedure ComposeClaimResponseAddItemDetailAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItemDetailAdjudication);
    procedure ComposeClaimResponseError(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseError);
    procedure ComposeClaimResponseNote(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseNote);
    procedure ComposeClaimResponseCoverage(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseCoverage);
    procedure ComposeClaimResponse(xml : TXmlBuilder; name : string; elem : TFhirClaimResponse);
    procedure ComposeClinicalImpressionInvestigations(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpressionInvestigations);
    procedure ComposeClinicalImpressionFinding(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpressionFinding);
    procedure ComposeClinicalImpressionRuledOut(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpressionRuledOut);
    procedure ComposeClinicalImpression(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpression);
    procedure ComposeCommunicationPayload(xml : TXmlBuilder; name : string; elem : TFhirCommunicationPayload);
    procedure ComposeCommunication(xml : TXmlBuilder; name : string; elem : TFhirCommunication);
    procedure ComposeCommunicationRequestPayload(xml : TXmlBuilder; name : string; elem : TFhirCommunicationRequestPayload);
    procedure ComposeCommunicationRequest(xml : TXmlBuilder; name : string; elem : TFhirCommunicationRequest);
    procedure ComposeCompositionAttester(xml : TXmlBuilder; name : string; elem : TFhirCompositionAttester);
    procedure ComposeCompositionEvent(xml : TXmlBuilder; name : string; elem : TFhirCompositionEvent);
    procedure ComposeCompositionSection(xml : TXmlBuilder; name : string; elem : TFhirCompositionSection);
    procedure ComposeComposition(xml : TXmlBuilder; name : string; elem : TFhirComposition);
    procedure ComposeConceptMapContact(xml : TXmlBuilder; name : string; elem : TFhirConceptMapContact);
    procedure ComposeConceptMapElement(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElement);
    procedure ComposeConceptMapElementTarget(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElementTarget);
    procedure ComposeConceptMapElementTargetDependsOn(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElementTargetDependsOn);
    procedure ComposeConceptMap(xml : TXmlBuilder; name : string; elem : TFhirConceptMap);
    procedure ComposeConditionStage(xml : TXmlBuilder; name : string; elem : TFhirConditionStage);
    procedure ComposeConditionEvidence(xml : TXmlBuilder; name : string; elem : TFhirConditionEvidence);
    procedure ComposeCondition(xml : TXmlBuilder; name : string; elem : TFhirCondition);
    procedure ComposeConformanceContact(xml : TXmlBuilder; name : string; elem : TFhirConformanceContact);
    procedure ComposeConformanceSoftware(xml : TXmlBuilder; name : string; elem : TFhirConformanceSoftware);
    procedure ComposeConformanceImplementation(xml : TXmlBuilder; name : string; elem : TFhirConformanceImplementation);
    procedure ComposeConformanceRest(xml : TXmlBuilder; name : string; elem : TFhirConformanceRest);
    procedure ComposeConformanceRestSecurity(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurity);
    procedure ComposeConformanceRestSecurityCertificate(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurityCertificate);
    procedure ComposeConformanceRestResource(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResource);
    procedure ComposeConformanceRestResourceInteraction(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceInteraction);
    procedure ComposeConformanceRestResourceSearchParam(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceSearchParam);
    procedure ComposeConformanceRestInteraction(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestInteraction);
    procedure ComposeConformanceRestOperation(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestOperation);
    procedure ComposeConformanceMessaging(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessaging);
    procedure ComposeConformanceMessagingEndpoint(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessagingEndpoint);
    procedure ComposeConformanceMessagingEvent(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessagingEvent);
    procedure ComposeConformanceDocument(xml : TXmlBuilder; name : string; elem : TFhirConformanceDocument);
    procedure ComposeConformance(xml : TXmlBuilder; name : string; elem : TFhirConformance);
    procedure ComposeContractActor(xml : TXmlBuilder; name : string; elem : TFhirContractActor);
    procedure ComposeContractValuedItem(xml : TXmlBuilder; name : string; elem : TFhirContractValuedItem);
    procedure ComposeContractSigner(xml : TXmlBuilder; name : string; elem : TFhirContractSigner);
    procedure ComposeContractTerm(xml : TXmlBuilder; name : string; elem : TFhirContractTerm);
    procedure ComposeContractTermActor(xml : TXmlBuilder; name : string; elem : TFhirContractTermActor);
    procedure ComposeContractTermValuedItem(xml : TXmlBuilder; name : string; elem : TFhirContractTermValuedItem);
    procedure ComposeContractFriendly(xml : TXmlBuilder; name : string; elem : TFhirContractFriendly);
    procedure ComposeContractLegal(xml : TXmlBuilder; name : string; elem : TFhirContractLegal);
    procedure ComposeContractRule(xml : TXmlBuilder; name : string; elem : TFhirContractRule);
    procedure ComposeContract(xml : TXmlBuilder; name : string; elem : TFhirContract);
    procedure ComposeCoverage(xml : TXmlBuilder; name : string; elem : TFhirCoverage);
    procedure ComposeDataElementContact(xml : TXmlBuilder; name : string; elem : TFhirDataElementContact);
    procedure ComposeDataElementMapping(xml : TXmlBuilder; name : string; elem : TFhirDataElementMapping);
    procedure ComposeDataElement(xml : TXmlBuilder; name : string; elem : TFhirDataElement);
    procedure ComposeDetectedIssueMitigation(xml : TXmlBuilder; name : string; elem : TFhirDetectedIssueMitigation);
    procedure ComposeDetectedIssue(xml : TXmlBuilder; name : string; elem : TFhirDetectedIssue);
    procedure ComposeDevice(xml : TXmlBuilder; name : string; elem : TFhirDevice);
    procedure ComposeDeviceComponentProductionSpecification(xml : TXmlBuilder; name : string; elem : TFhirDeviceComponentProductionSpecification);
    procedure ComposeDeviceComponent(xml : TXmlBuilder; name : string; elem : TFhirDeviceComponent);
    procedure ComposeDeviceMetricCalibration(xml : TXmlBuilder; name : string; elem : TFhirDeviceMetricCalibration);
    procedure ComposeDeviceMetric(xml : TXmlBuilder; name : string; elem : TFhirDeviceMetric);
    procedure ComposeDeviceUseRequest(xml : TXmlBuilder; name : string; elem : TFhirDeviceUseRequest);
    procedure ComposeDeviceUseStatement(xml : TXmlBuilder; name : string; elem : TFhirDeviceUseStatement);
    procedure ComposeDiagnosticOrderEvent(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderEvent);
    procedure ComposeDiagnosticOrderItem(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderItem);
    procedure ComposeDiagnosticOrder(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrder);
    procedure ComposeDiagnosticReportImage(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReportImage);
    procedure ComposeDiagnosticReport(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReport);
    procedure ComposeDocumentManifestContent(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifestContent);
    procedure ComposeDocumentManifestRelated(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifestRelated);
    procedure ComposeDocumentManifest(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifest);
    procedure ComposeDocumentReferenceRelatesTo(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceRelatesTo);
    procedure ComposeDocumentReferenceContent(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContent);
    procedure ComposeDocumentReferenceContext(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContext);
    procedure ComposeDocumentReferenceContextRelated(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContextRelated);
    procedure ComposeDocumentReference(xml : TXmlBuilder; name : string; elem : TFhirDocumentReference);
    procedure ComposeEligibilityRequest(xml : TXmlBuilder; name : string; elem : TFhirEligibilityRequest);
    procedure ComposeEligibilityResponse(xml : TXmlBuilder; name : string; elem : TFhirEligibilityResponse);
    procedure ComposeEncounterStatusHistory(xml : TXmlBuilder; name : string; elem : TFhirEncounterStatusHistory);
    procedure ComposeEncounterParticipant(xml : TXmlBuilder; name : string; elem : TFhirEncounterParticipant);
    procedure ComposeEncounterHospitalization(xml : TXmlBuilder; name : string; elem : TFhirEncounterHospitalization);
    procedure ComposeEncounterLocation(xml : TXmlBuilder; name : string; elem : TFhirEncounterLocation);
    procedure ComposeEncounter(xml : TXmlBuilder; name : string; elem : TFhirEncounter);
    procedure ComposeEnrollmentRequest(xml : TXmlBuilder; name : string; elem : TFhirEnrollmentRequest);
    procedure ComposeEnrollmentResponse(xml : TXmlBuilder; name : string; elem : TFhirEnrollmentResponse);
    procedure ComposeEpisodeOfCareStatusHistory(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCareStatusHistory);
    procedure ComposeEpisodeOfCareCareTeam(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCareCareTeam);
    procedure ComposeEpisodeOfCare(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCare);
    procedure ComposeExplanationOfBenefit(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefit);
    procedure ComposeFamilyMemberHistoryCondition(xml : TXmlBuilder; name : string; elem : TFhirFamilyMemberHistoryCondition);
    procedure ComposeFamilyMemberHistory(xml : TXmlBuilder; name : string; elem : TFhirFamilyMemberHistory);
    procedure ComposeFlag(xml : TXmlBuilder; name : string; elem : TFhirFlag);
    procedure ComposeGoalOutcome(xml : TXmlBuilder; name : string; elem : TFhirGoalOutcome);
    procedure ComposeGoal(xml : TXmlBuilder; name : string; elem : TFhirGoal);
    procedure ComposeGroupCharacteristic(xml : TXmlBuilder; name : string; elem : TFhirGroupCharacteristic);
    procedure ComposeGroupMember(xml : TXmlBuilder; name : string; elem : TFhirGroupMember);
    procedure ComposeGroup(xml : TXmlBuilder; name : string; elem : TFhirGroup);
    procedure ComposeHealthcareServiceServiceType(xml : TXmlBuilder; name : string; elem : TFhirHealthcareServiceServiceType);
    procedure ComposeHealthcareServiceAvailableTime(xml : TXmlBuilder; name : string; elem : TFhirHealthcareServiceAvailableTime);
    procedure ComposeHealthcareServiceNotAvailable(xml : TXmlBuilder; name : string; elem : TFhirHealthcareServiceNotAvailable);
    procedure ComposeHealthcareService(xml : TXmlBuilder; name : string; elem : TFhirHealthcareService);
    procedure ComposeImagingObjectSelectionStudy(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudy);
    procedure ComposeImagingObjectSelectionStudySeries(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudySeries);
    procedure ComposeImagingObjectSelectionStudySeriesInstance(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstance);
    procedure ComposeImagingObjectSelectionStudySeriesInstanceFrames(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames);
    procedure ComposeImagingObjectSelection(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelection);
    procedure ComposeImagingStudySeries(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeries);
    procedure ComposeImagingStudySeriesInstance(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeriesInstance);
    procedure ComposeImagingStudy(xml : TXmlBuilder; name : string; elem : TFhirImagingStudy);
    procedure ComposeImmunizationExplanation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationExplanation);
    procedure ComposeImmunizationReaction(xml : TXmlBuilder; name : string; elem : TFhirImmunizationReaction);
    procedure ComposeImmunizationVaccinationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationVaccinationProtocol);
    procedure ComposeImmunization(xml : TXmlBuilder; name : string; elem : TFhirImmunization);
    procedure ComposeImmunizationRecommendationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendation);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
    procedure ComposeImmunizationRecommendationRecommendationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol);
    procedure ComposeImmunizationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendation);
    procedure ComposeImplementationGuideContact(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuideContact);
    procedure ComposeImplementationGuideDependency(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuideDependency);
    procedure ComposeImplementationGuidePackage(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuidePackage);
    procedure ComposeImplementationGuidePackageResource(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuidePackageResource);
    procedure ComposeImplementationGuideGlobal(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuideGlobal);
    procedure ComposeImplementationGuidePage(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuidePage);
    procedure ComposeImplementationGuide(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuide);
    procedure ComposeListEntry(xml : TXmlBuilder; name : string; elem : TFhirListEntry);
    procedure ComposeList(xml : TXmlBuilder; name : string; elem : TFhirList);
    procedure ComposeLocationPosition(xml : TXmlBuilder; name : string; elem : TFhirLocationPosition);
    procedure ComposeLocation(xml : TXmlBuilder; name : string; elem : TFhirLocation);
    procedure ComposeMedia(xml : TXmlBuilder; name : string; elem : TFhirMedia);
    procedure ComposeMedicationProduct(xml : TXmlBuilder; name : string; elem : TFhirMedicationProduct);
    procedure ComposeMedicationProductIngredient(xml : TXmlBuilder; name : string; elem : TFhirMedicationProductIngredient);
    procedure ComposeMedicationProductBatch(xml : TXmlBuilder; name : string; elem : TFhirMedicationProductBatch);
    procedure ComposeMedicationPackage(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackage);
    procedure ComposeMedicationPackageContent(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackageContent);
    procedure ComposeMedication(xml : TXmlBuilder; name : string; elem : TFhirMedication);
    procedure ComposeMedicationAdministrationDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministrationDosage);
    procedure ComposeMedicationAdministration(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministration);
    procedure ComposeMedicationDispenseDosageInstruction(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseDosageInstruction);
    procedure ComposeMedicationDispenseSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseSubstitution);
    procedure ComposeMedicationDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispense);
    procedure ComposeMedicationOrderDosageInstruction(xml : TXmlBuilder; name : string; elem : TFhirMedicationOrderDosageInstruction);
    procedure ComposeMedicationOrderDispenseRequest(xml : TXmlBuilder; name : string; elem : TFhirMedicationOrderDispenseRequest);
    procedure ComposeMedicationOrderSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationOrderSubstitution);
    procedure ComposeMedicationOrder(xml : TXmlBuilder; name : string; elem : TFhirMedicationOrder);
    procedure ComposeMedicationStatementDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatementDosage);
    procedure ComposeMedicationStatement(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatement);
    procedure ComposeMessageHeaderResponse(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderResponse);
    procedure ComposeMessageHeaderSource(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderSource);
    procedure ComposeMessageHeaderDestination(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderDestination);
    procedure ComposeMessageHeader(xml : TXmlBuilder; name : string; elem : TFhirMessageHeader);
    procedure ComposeNamingSystemContact(xml : TXmlBuilder; name : string; elem : TFhirNamingSystemContact);
    procedure ComposeNamingSystemUniqueId(xml : TXmlBuilder; name : string; elem : TFhirNamingSystemUniqueId);
    procedure ComposeNamingSystem(xml : TXmlBuilder; name : string; elem : TFhirNamingSystem);
    procedure ComposeNutritionOrderOralDiet(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDiet);
    procedure ComposeNutritionOrderOralDietNutrient(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDietNutrient);
    procedure ComposeNutritionOrderOralDietTexture(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDietTexture);
    procedure ComposeNutritionOrderSupplement(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderSupplement);
    procedure ComposeNutritionOrderEnteralFormula(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderEnteralFormula);
    procedure ComposeNutritionOrderEnteralFormulaAdministration(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderEnteralFormulaAdministration);
    procedure ComposeNutritionOrder(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrder);
    procedure ComposeObservationReferenceRange(xml : TXmlBuilder; name : string; elem : TFhirObservationReferenceRange);
    procedure ComposeObservationRelated(xml : TXmlBuilder; name : string; elem : TFhirObservationRelated);
    procedure ComposeObservationComponent(xml : TXmlBuilder; name : string; elem : TFhirObservationComponent);
    procedure ComposeObservation(xml : TXmlBuilder; name : string; elem : TFhirObservation);
    procedure ComposeOperationDefinitionContact(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionContact);
    procedure ComposeOperationDefinitionParameter(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionParameter);
    procedure ComposeOperationDefinitionParameterBinding(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionParameterBinding);
    procedure ComposeOperationDefinition(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinition);
    procedure ComposeOperationOutcomeIssue(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcomeIssue);
    procedure ComposeOperationOutcome(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcome);
    procedure ComposeOrderWhen(xml : TXmlBuilder; name : string; elem : TFhirOrderWhen);
    procedure ComposeOrder(xml : TXmlBuilder; name : string; elem : TFhirOrder);
    procedure ComposeOrderResponse(xml : TXmlBuilder; name : string; elem : TFhirOrderResponse);
    procedure ComposeOrganizationContact(xml : TXmlBuilder; name : string; elem : TFhirOrganizationContact);
    procedure ComposeOrganization(xml : TXmlBuilder; name : string; elem : TFhirOrganization);
    procedure ComposePatientContact(xml : TXmlBuilder; name : string; elem : TFhirPatientContact);
    procedure ComposePatientAnimal(xml : TXmlBuilder; name : string; elem : TFhirPatientAnimal);
    procedure ComposePatientCommunication(xml : TXmlBuilder; name : string; elem : TFhirPatientCommunication);
    procedure ComposePatientLink(xml : TXmlBuilder; name : string; elem : TFhirPatientLink);
    procedure ComposePatient(xml : TXmlBuilder; name : string; elem : TFhirPatient);
    procedure ComposePaymentNotice(xml : TXmlBuilder; name : string; elem : TFhirPaymentNotice);
    procedure ComposePaymentReconciliationDetail(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliationDetail);
    procedure ComposePaymentReconciliationNote(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliationNote);
    procedure ComposePaymentReconciliation(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliation);
    procedure ComposePersonLink(xml : TXmlBuilder; name : string; elem : TFhirPersonLink);
    procedure ComposePerson(xml : TXmlBuilder; name : string; elem : TFhirPerson);
    procedure ComposePractitionerPractitionerRole(xml : TXmlBuilder; name : string; elem : TFhirPractitionerPractitionerRole);
    procedure ComposePractitionerQualification(xml : TXmlBuilder; name : string; elem : TFhirPractitionerQualification);
    procedure ComposePractitioner(xml : TXmlBuilder; name : string; elem : TFhirPractitioner);
    procedure ComposeProcedurePerformer(xml : TXmlBuilder; name : string; elem : TFhirProcedurePerformer);
    procedure ComposeProcedureFocalDevice(xml : TXmlBuilder; name : string; elem : TFhirProcedureFocalDevice);
    procedure ComposeProcedure(xml : TXmlBuilder; name : string; elem : TFhirProcedure);
    procedure ComposeProcedureRequest(xml : TXmlBuilder; name : string; elem : TFhirProcedureRequest);
    procedure ComposeProcessRequestItem(xml : TXmlBuilder; name : string; elem : TFhirProcessRequestItem);
    procedure ComposeProcessRequest(xml : TXmlBuilder; name : string; elem : TFhirProcessRequest);
    procedure ComposeProcessResponseNotes(xml : TXmlBuilder; name : string; elem : TFhirProcessResponseNotes);
    procedure ComposeProcessResponse(xml : TXmlBuilder; name : string; elem : TFhirProcessResponse);
    procedure ComposeProvenanceAgent(xml : TXmlBuilder; name : string; elem : TFhirProvenanceAgent);
    procedure ComposeProvenanceAgentRelatedAgent(xml : TXmlBuilder; name : string; elem : TFhirProvenanceAgentRelatedAgent);
    procedure ComposeProvenanceEntity(xml : TXmlBuilder; name : string; elem : TFhirProvenanceEntity);
    procedure ComposeProvenance(xml : TXmlBuilder; name : string; elem : TFhirProvenance);
    procedure ComposeQuestionnaireGroup(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroup);
    procedure ComposeQuestionnaireGroupQuestion(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroupQuestion);
    procedure ComposeQuestionnaire(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaire);
    procedure ComposeQuestionnaireResponseGroup(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireResponseGroup);
    procedure ComposeQuestionnaireResponseGroupQuestion(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireResponseGroupQuestion);
    procedure ComposeQuestionnaireResponseGroupQuestionAnswer(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireResponseGroupQuestionAnswer);
    procedure ComposeQuestionnaireResponse(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireResponse);
    procedure ComposeReferralRequest(xml : TXmlBuilder; name : string; elem : TFhirReferralRequest);
    procedure ComposeRelatedPerson(xml : TXmlBuilder; name : string; elem : TFhirRelatedPerson);
    procedure ComposeRiskAssessmentPrediction(xml : TXmlBuilder; name : string; elem : TFhirRiskAssessmentPrediction);
    procedure ComposeRiskAssessment(xml : TXmlBuilder; name : string; elem : TFhirRiskAssessment);
    procedure ComposeSchedule(xml : TXmlBuilder; name : string; elem : TFhirSchedule);
    procedure ComposeSearchParameterContact(xml : TXmlBuilder; name : string; elem : TFhirSearchParameterContact);
    procedure ComposeSearchParameter(xml : TXmlBuilder; name : string; elem : TFhirSearchParameter);
    procedure ComposeSlot(xml : TXmlBuilder; name : string; elem : TFhirSlot);
    procedure ComposeSpecimenCollection(xml : TXmlBuilder; name : string; elem : TFhirSpecimenCollection);
    procedure ComposeSpecimenTreatment(xml : TXmlBuilder; name : string; elem : TFhirSpecimenTreatment);
    procedure ComposeSpecimenContainer(xml : TXmlBuilder; name : string; elem : TFhirSpecimenContainer);
    procedure ComposeSpecimen(xml : TXmlBuilder; name : string; elem : TFhirSpecimen);
    procedure ComposeStructureDefinitionContact(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionContact);
    procedure ComposeStructureDefinitionMapping(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionMapping);
    procedure ComposeStructureDefinitionSnapshot(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionSnapshot);
    procedure ComposeStructureDefinitionDifferential(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionDifferential);
    procedure ComposeStructureDefinition(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinition);
    procedure ComposeSubscriptionChannel(xml : TXmlBuilder; name : string; elem : TFhirSubscriptionChannel);
    procedure ComposeSubscription(xml : TXmlBuilder; name : string; elem : TFhirSubscription);
    procedure ComposeSubstanceInstance(xml : TXmlBuilder; name : string; elem : TFhirSubstanceInstance);
    procedure ComposeSubstanceIngredient(xml : TXmlBuilder; name : string; elem : TFhirSubstanceIngredient);
    procedure ComposeSubstance(xml : TXmlBuilder; name : string; elem : TFhirSubstance);
    procedure ComposeSupplyDelivery(xml : TXmlBuilder; name : string; elem : TFhirSupplyDelivery);
    procedure ComposeSupplyRequestWhen(xml : TXmlBuilder; name : string; elem : TFhirSupplyRequestWhen);
    procedure ComposeSupplyRequest(xml : TXmlBuilder; name : string; elem : TFhirSupplyRequest);
    procedure ComposeTestScriptContact(xml : TXmlBuilder; name : string; elem : TFhirTestScriptContact);
    procedure ComposeTestScriptMetadata(xml : TXmlBuilder; name : string; elem : TFhirTestScriptMetadata);
    procedure ComposeTestScriptMetadataLink(xml : TXmlBuilder; name : string; elem : TFhirTestScriptMetadataLink);
    procedure ComposeTestScriptMetadataCapability(xml : TXmlBuilder; name : string; elem : TFhirTestScriptMetadataCapability);
    procedure ComposeTestScriptFixture(xml : TXmlBuilder; name : string; elem : TFhirTestScriptFixture);
    procedure ComposeTestScriptVariable(xml : TXmlBuilder; name : string; elem : TFhirTestScriptVariable);
    procedure ComposeTestScriptSetup(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetup);
    procedure ComposeTestScriptSetupAction(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupAction);
    procedure ComposeTestScriptSetupActionOperation(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupActionOperation);
    procedure ComposeTestScriptSetupActionOperationRequestHeader(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupActionOperationRequestHeader);
    procedure ComposeTestScriptSetupActionAssert(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupActionAssert);
    procedure ComposeTestScriptTest(xml : TXmlBuilder; name : string; elem : TFhirTestScriptTest);
    procedure ComposeTestScriptTestAction(xml : TXmlBuilder; name : string; elem : TFhirTestScriptTestAction);
    procedure ComposeTestScriptTeardown(xml : TXmlBuilder; name : string; elem : TFhirTestScriptTeardown);
    procedure ComposeTestScriptTeardownAction(xml : TXmlBuilder; name : string; elem : TFhirTestScriptTeardownAction);
    procedure ComposeTestScript(xml : TXmlBuilder; name : string; elem : TFhirTestScript);
    procedure ComposeValueSetContact(xml : TXmlBuilder; name : string; elem : TFhirValueSetContact);
    procedure ComposeValueSetCodeSystem(xml : TXmlBuilder; name : string; elem : TFhirValueSetCodeSystem);
    procedure ComposeValueSetCodeSystemConcept(xml : TXmlBuilder; name : string; elem : TFhirValueSetCodeSystemConcept);
    procedure ComposeValueSetCodeSystemConceptDesignation(xml : TXmlBuilder; name : string; elem : TFhirValueSetCodeSystemConceptDesignation);
    procedure ComposeValueSetCompose(xml : TXmlBuilder; name : string; elem : TFhirValueSetCompose);
    procedure ComposeValueSetComposeInclude(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeInclude);
    procedure ComposeValueSetComposeIncludeConcept(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeConcept);
    procedure ComposeValueSetComposeIncludeFilter(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeFilter);
    procedure ComposeValueSetExpansion(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansion);
    procedure ComposeValueSetExpansionParameter(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansionParameter);
    procedure ComposeValueSetExpansionContains(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansionContains);
    procedure ComposeValueSet(xml : TXmlBuilder; name : string; elem : TFhirValueSet);
    procedure ComposeVisionPrescriptionDispense(xml : TXmlBuilder; name : string; elem : TFhirVisionPrescriptionDispense);
    procedure ComposeVisionPrescription(xml : TXmlBuilder; name : string; elem : TFhirVisionPrescription);
    procedure ComposeResource(xml : TXmlBuilder; resource : TFhirResource; links : TFhirBundleLinkList); override;
    procedure ComposeBase(xml : TXmlBuilder; name : String; base : TFHIRBase); override;
  end;

  TFHIRJsonParser = class (TFHIRJsonParserBase)
  protected
    function ParseElement(jsn : TJsonObject) : TFhirElement; overload;
    procedure ParseElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBackboneElement(jsn : TJsonObject) : TFhirBackboneElement; overload;
    procedure ParseBackboneElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}

    procedure ParseElementProperties(jsn : TJsonObject; element : TFhirElement);
    procedure ParseBackboneElementProperties(jsn : TJsonObject; element : TFhirBackboneElement);
    procedure ParseEnum(path, value : string; jsn : TJsonObject; ctxt : TFHIRObjectList; Const aNames, aSystems : Array Of String); overload;
    function ParseEnum(path, value : string; jsn : TJsonObject; Const aNames, aSystems : Array Of String) : TFHIREnum; overload;
    procedure ParseInteger(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseInteger(value : string; jsn : TJsonObject) : TFHIRInteger; overload;
    procedure ParseDateTime(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDateTime(value : string; jsn : TJsonObject) : TFHIRDateTime; overload;
    procedure ParseDate(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDate(value : string; jsn : TJsonObject) : TFHIRDate; overload;
    procedure ParseDecimal(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDecimal(value : string; jsn : TJsonObject) : TFHIRDecimal; overload;
    procedure ParseUri(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseUri(value : string; jsn : TJsonObject) : TFHIRUri; overload;
    procedure ParseBase64Binary(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseBase64Binary(value : string; jsn : TJsonObject) : TFHIRBase64Binary; overload;
    procedure ParseTime(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseTime(value : string; jsn : TJsonObject) : TFHIRTime; overload;
    procedure ParseString(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseString(value : string; jsn : TJsonObject) : TFHIRString; overload;
    procedure ParseBoolean(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseBoolean(value : string; jsn : TJsonObject) : TFHIRBoolean; overload;
    procedure ParseInstant(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseInstant(value : string; jsn : TJsonObject) : TFHIRInstant; overload;
    procedure ParseMarkdown(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseMarkdown(value : string; jsn : TJsonObject) : TFHIRMarkdown; overload;
    procedure ParseUnsignedInt(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseUnsignedInt(value : string; jsn : TJsonObject) : TFHIRUnsignedInt; overload;
    procedure ParseCode(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseCode(value : string; jsn : TJsonObject) : TFHIRCode; overload;
    procedure ParseId(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseId(value : string; jsn : TJsonObject) : TFHIRId; overload;
    procedure ParseOid(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseOid(value : string; jsn : TJsonObject) : TFHIROid; overload;
    procedure ParsePositiveInt(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParsePositiveInt(value : string; jsn : TJsonObject) : TFHIRPositiveInt; overload;
    procedure ParseUuid(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseUuid(value : string; jsn : TJsonObject) : TFHIRUuid; overload;

    procedure ParseResourceProperties(jsn : TJsonObject; resource : TFhirResource);
    procedure ParseDomainResourceProperties(jsn : TJsonObject; resource : TFhirDomainResource);
    function ParseParametersParameter(jsn : TJsonObject) : TFhirParametersParameter; overload; {b\}
    procedure ParseParametersParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseParameters(jsn : TJsonObject) : TFhirParameters; overload;
    procedure ParseParameters(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}

    function ParseExtension(jsn : TJsonObject) : TFhirExtension; overload;
    procedure ParseExtension(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNarrative(jsn : TJsonObject) : TFhirNarrative; overload;
    procedure ParseNarrative(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePeriod(jsn : TJsonObject) : TFhirPeriod; overload;
    procedure ParsePeriod(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoding(jsn : TJsonObject) : TFhirCoding; overload;
    procedure ParseCoding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRange(jsn : TJsonObject) : TFhirRange; overload;
    procedure ParseRange(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAttachment(jsn : TJsonObject) : TFhirAttachment; overload;
    procedure ParseAttachment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuantity(jsn : TJsonObject) : TFhirQuantity; overload;
    procedure ParseQuantity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAnnotation(jsn : TJsonObject) : TFhirAnnotation; overload;
    procedure ParseAnnotation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRatio(jsn : TJsonObject) : TFhirRatio; overload;
    procedure ParseRatio(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSampledData(jsn : TJsonObject) : TFhirSampledData; overload;
    procedure ParseSampledData(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCodeableConcept(jsn : TJsonObject) : TFhirCodeableConcept; overload;
    procedure ParseCodeableConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseReference(jsn : TJsonObject) : TFhirReference; overload;
    procedure ParseReference(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseIdentifier(jsn : TJsonObject) : TFhirIdentifier; overload;
    procedure ParseIdentifier(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSignature(jsn : TJsonObject) : TFhirSignature; overload;
    procedure ParseSignature(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTimingRepeat(jsn : TJsonObject) : TFhirTimingRepeat; overload; {b\}
    procedure ParseTimingRepeat(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTiming(jsn : TJsonObject) : TFhirTiming; overload;
    procedure ParseTiming(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionSlicing(jsn : TJsonObject) : TFhirElementDefinitionSlicing; overload; {b\}
    procedure ParseElementDefinitionSlicing(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionBase(jsn : TJsonObject) : TFhirElementDefinitionBase; overload; {b\}
    procedure ParseElementDefinitionBase(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionType(jsn : TJsonObject) : TFhirElementDefinitionType; overload; {b\}
    procedure ParseElementDefinitionType(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionConstraint(jsn : TJsonObject) : TFhirElementDefinitionConstraint; overload; {b\}
    procedure ParseElementDefinitionConstraint(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionBinding(jsn : TJsonObject) : TFhirElementDefinitionBinding; overload; {b\}
    procedure ParseElementDefinitionBinding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionMapping(jsn : TJsonObject) : TFhirElementDefinitionMapping; overload; {b\}
    procedure ParseElementDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinition(jsn : TJsonObject) : TFhirElementDefinition; overload;
    procedure ParseElementDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHumanName(jsn : TJsonObject) : TFhirHumanName; overload;
    procedure ParseHumanName(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAddress(jsn : TJsonObject) : TFhirAddress; overload;
    procedure ParseAddress(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMeta(jsn : TJsonObject) : TFhirMeta; overload;
    procedure ParseMeta(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContactPoint(jsn : TJsonObject) : TFhirContactPoint; overload;
    procedure ParseContactPoint(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}

    function ParseAccount(jsn : TJsonObject) : TFhirAccount; overload;
    procedure ParseAccount(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAllergyIntoleranceReaction(jsn : TJsonObject) : TFhirAllergyIntoleranceReaction; overload; {b\}
    procedure ParseAllergyIntoleranceReaction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAllergyIntolerance(jsn : TJsonObject) : TFhirAllergyIntolerance; overload;
    procedure ParseAllergyIntolerance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAppointmentParticipant(jsn : TJsonObject) : TFhirAppointmentParticipant; overload; {b\}
    procedure ParseAppointmentParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAppointment(jsn : TJsonObject) : TFhirAppointment; overload;
    procedure ParseAppointment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAppointmentResponse(jsn : TJsonObject) : TFhirAppointmentResponse; overload;
    procedure ParseAppointmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventEvent(jsn : TJsonObject) : TFhirAuditEventEvent; overload; {b\}
    procedure ParseAuditEventEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventParticipant(jsn : TJsonObject) : TFhirAuditEventParticipant; overload; {b\}
    procedure ParseAuditEventParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventParticipantNetwork(jsn : TJsonObject) : TFhirAuditEventParticipantNetwork; overload; {b\}
    procedure ParseAuditEventParticipantNetwork(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventSource(jsn : TJsonObject) : TFhirAuditEventSource; overload; {b\}
    procedure ParseAuditEventSource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventObject(jsn : TJsonObject) : TFhirAuditEventObject; overload; {b\}
    procedure ParseAuditEventObject(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventObjectDetail(jsn : TJsonObject) : TFhirAuditEventObjectDetail; overload; {b\}
    procedure ParseAuditEventObjectDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEvent(jsn : TJsonObject) : TFhirAuditEvent; overload;
    procedure ParseAuditEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBasic(jsn : TJsonObject) : TFhirBasic; overload;
    procedure ParseBasic(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBinary(jsn : TJsonObject) : TFhirBinary; overload;
    procedure ParseBinary(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBodySite(jsn : TJsonObject) : TFhirBodySite; overload;
    procedure ParseBodySite(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleLink(jsn : TJsonObject) : TFhirBundleLink; overload; {b\}
    procedure ParseBundleLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleEntry(jsn : TJsonObject) : TFhirBundleEntry; overload; {b\}
    procedure ParseBundleEntry(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleEntrySearch(jsn : TJsonObject) : TFhirBundleEntrySearch; overload; {b\}
    procedure ParseBundleEntrySearch(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleEntryRequest(jsn : TJsonObject) : TFhirBundleEntryRequest; overload; {b\}
    procedure ParseBundleEntryRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleEntryResponse(jsn : TJsonObject) : TFhirBundleEntryResponse; overload; {b\}
    procedure ParseBundleEntryResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundle(jsn : TJsonObject) : TFhirBundle; overload;
    procedure ParseBundle(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanRelatedPlan(jsn : TJsonObject) : TFhirCarePlanRelatedPlan; overload; {b\}
    procedure ParseCarePlanRelatedPlan(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanParticipant(jsn : TJsonObject) : TFhirCarePlanParticipant; overload; {b\}
    procedure ParseCarePlanParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanActivity(jsn : TJsonObject) : TFhirCarePlanActivity; overload; {b\}
    procedure ParseCarePlanActivity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanActivityDetail(jsn : TJsonObject) : TFhirCarePlanActivityDetail; overload; {b\}
    procedure ParseCarePlanActivityDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlan(jsn : TJsonObject) : TFhirCarePlan; overload;
    procedure ParseCarePlan(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimPayee(jsn : TJsonObject) : TFhirClaimPayee; overload; {b\}
    procedure ParseClaimPayee(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimDiagnosis(jsn : TJsonObject) : TFhirClaimDiagnosis; overload; {b\}
    procedure ParseClaimDiagnosis(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimCoverage(jsn : TJsonObject) : TFhirClaimCoverage; overload; {b\}
    procedure ParseClaimCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimItem(jsn : TJsonObject) : TFhirClaimItem; overload; {b\}
    procedure ParseClaimItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimItemDetail(jsn : TJsonObject) : TFhirClaimItemDetail; overload; {b\}
    procedure ParseClaimItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimItemDetailSubDetail; overload; {b\}
    procedure ParseClaimItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimItemProsthesis(jsn : TJsonObject) : TFhirClaimItemProsthesis; overload; {b\}
    procedure ParseClaimItemProsthesis(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimMissingTeeth(jsn : TJsonObject) : TFhirClaimMissingTeeth; overload; {b\}
    procedure ParseClaimMissingTeeth(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaim(jsn : TJsonObject) : TFhirClaim; overload;
    procedure ParseClaim(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItem(jsn : TJsonObject) : TFhirClaimResponseItem; overload; {b\}
    procedure ParseClaimResponseItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemAdjudication; overload; {b\}
    procedure ParseClaimResponseItemAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemDetail(jsn : TJsonObject) : TFhirClaimResponseItemDetail; overload; {b\}
    procedure ParseClaimResponseItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemDetailAdjudication; overload; {b\}
    procedure ParseClaimResponseItemDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimResponseItemDetailSubDetail; overload; {b\}
    procedure ParseClaimResponseItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemDetailSubDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemDetailSubDetailAdjudication; overload; {b\}
    procedure ParseClaimResponseItemDetailSubDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseAddItem(jsn : TJsonObject) : TFhirClaimResponseAddItem; overload; {b\}
    procedure ParseClaimResponseAddItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseAddItemAdjudication(jsn : TJsonObject) : TFhirClaimResponseAddItemAdjudication; overload; {b\}
    procedure ParseClaimResponseAddItemAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseAddItemDetail(jsn : TJsonObject) : TFhirClaimResponseAddItemDetail; overload; {b\}
    procedure ParseClaimResponseAddItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseAddItemDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseAddItemDetailAdjudication; overload; {b\}
    procedure ParseClaimResponseAddItemDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseError(jsn : TJsonObject) : TFhirClaimResponseError; overload; {b\}
    procedure ParseClaimResponseError(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseNote(jsn : TJsonObject) : TFhirClaimResponseNote; overload; {b\}
    procedure ParseClaimResponseNote(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseCoverage(jsn : TJsonObject) : TFhirClaimResponseCoverage; overload; {b\}
    procedure ParseClaimResponseCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponse(jsn : TJsonObject) : TFhirClaimResponse; overload;
    procedure ParseClaimResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClinicalImpressionInvestigations(jsn : TJsonObject) : TFhirClinicalImpressionInvestigations; overload; {b\}
    procedure ParseClinicalImpressionInvestigations(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClinicalImpressionFinding(jsn : TJsonObject) : TFhirClinicalImpressionFinding; overload; {b\}
    procedure ParseClinicalImpressionFinding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClinicalImpressionRuledOut(jsn : TJsonObject) : TFhirClinicalImpressionRuledOut; overload; {b\}
    procedure ParseClinicalImpressionRuledOut(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClinicalImpression(jsn : TJsonObject) : TFhirClinicalImpression; overload;
    procedure ParseClinicalImpression(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCommunicationPayload(jsn : TJsonObject) : TFhirCommunicationPayload; overload; {b\}
    procedure ParseCommunicationPayload(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCommunication(jsn : TJsonObject) : TFhirCommunication; overload;
    procedure ParseCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCommunicationRequestPayload(jsn : TJsonObject) : TFhirCommunicationRequestPayload; overload; {b\}
    procedure ParseCommunicationRequestPayload(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCommunicationRequest(jsn : TJsonObject) : TFhirCommunicationRequest; overload;
    procedure ParseCommunicationRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompositionAttester(jsn : TJsonObject) : TFhirCompositionAttester; overload; {b\}
    procedure ParseCompositionAttester(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompositionEvent(jsn : TJsonObject) : TFhirCompositionEvent; overload; {b\}
    procedure ParseCompositionEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompositionSection(jsn : TJsonObject) : TFhirCompositionSection; overload; {b\}
    procedure ParseCompositionSection(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseComposition(jsn : TJsonObject) : TFhirComposition; overload;
    procedure ParseComposition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapContact(jsn : TJsonObject) : TFhirConceptMapContact; overload; {b\}
    procedure ParseConceptMapContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapElement(jsn : TJsonObject) : TFhirConceptMapElement; overload; {b\}
    procedure ParseConceptMapElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapElementTarget(jsn : TJsonObject) : TFhirConceptMapElementTarget; overload; {b\}
    procedure ParseConceptMapElementTarget(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapElementTargetDependsOn(jsn : TJsonObject) : TFhirConceptMapElementTargetDependsOn; overload; {b\}
    procedure ParseConceptMapElementTargetDependsOn(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMap(jsn : TJsonObject) : TFhirConceptMap; overload;
    procedure ParseConceptMap(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConditionStage(jsn : TJsonObject) : TFhirConditionStage; overload; {b\}
    procedure ParseConditionStage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConditionEvidence(jsn : TJsonObject) : TFhirConditionEvidence; overload; {b\}
    procedure ParseConditionEvidence(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCondition(jsn : TJsonObject) : TFhirCondition; overload;
    procedure ParseCondition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceContact(jsn : TJsonObject) : TFhirConformanceContact; overload; {b\}
    procedure ParseConformanceContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceSoftware(jsn : TJsonObject) : TFhirConformanceSoftware; overload; {b\}
    procedure ParseConformanceSoftware(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceImplementation(jsn : TJsonObject) : TFhirConformanceImplementation; overload; {b\}
    procedure ParseConformanceImplementation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRest(jsn : TJsonObject) : TFhirConformanceRest; overload; {b\}
    procedure ParseConformanceRest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestSecurity(jsn : TJsonObject) : TFhirConformanceRestSecurity; overload; {b\}
    procedure ParseConformanceRestSecurity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestSecurityCertificate(jsn : TJsonObject) : TFhirConformanceRestSecurityCertificate; overload; {b\}
    procedure ParseConformanceRestSecurityCertificate(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestResource(jsn : TJsonObject) : TFhirConformanceRestResource; overload; {b\}
    procedure ParseConformanceRestResource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestResourceInteraction(jsn : TJsonObject) : TFhirConformanceRestResourceInteraction; overload; {b\}
    procedure ParseConformanceRestResourceInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestResourceSearchParam(jsn : TJsonObject) : TFhirConformanceRestResourceSearchParam; overload; {b\}
    procedure ParseConformanceRestResourceSearchParam(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestInteraction(jsn : TJsonObject) : TFhirConformanceRestInteraction; overload; {b\}
    procedure ParseConformanceRestInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestOperation(jsn : TJsonObject) : TFhirConformanceRestOperation; overload; {b\}
    procedure ParseConformanceRestOperation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceMessaging(jsn : TJsonObject) : TFhirConformanceMessaging; overload; {b\}
    procedure ParseConformanceMessaging(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceMessagingEndpoint(jsn : TJsonObject) : TFhirConformanceMessagingEndpoint; overload; {b\}
    procedure ParseConformanceMessagingEndpoint(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceMessagingEvent(jsn : TJsonObject) : TFhirConformanceMessagingEvent; overload; {b\}
    procedure ParseConformanceMessagingEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceDocument(jsn : TJsonObject) : TFhirConformanceDocument; overload; {b\}
    procedure ParseConformanceDocument(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformance(jsn : TJsonObject) : TFhirConformance; overload;
    procedure ParseConformance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractActor(jsn : TJsonObject) : TFhirContractActor; overload; {b\}
    procedure ParseContractActor(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractValuedItem(jsn : TJsonObject) : TFhirContractValuedItem; overload; {b\}
    procedure ParseContractValuedItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractSigner(jsn : TJsonObject) : TFhirContractSigner; overload; {b\}
    procedure ParseContractSigner(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTerm(jsn : TJsonObject) : TFhirContractTerm; overload; {b\}
    procedure ParseContractTerm(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTermActor(jsn : TJsonObject) : TFhirContractTermActor; overload; {b\}
    procedure ParseContractTermActor(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTermValuedItem(jsn : TJsonObject) : TFhirContractTermValuedItem; overload; {b\}
    procedure ParseContractTermValuedItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractFriendly(jsn : TJsonObject) : TFhirContractFriendly; overload; {b\}
    procedure ParseContractFriendly(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractLegal(jsn : TJsonObject) : TFhirContractLegal; overload; {b\}
    procedure ParseContractLegal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractRule(jsn : TJsonObject) : TFhirContractRule; overload; {b\}
    procedure ParseContractRule(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContract(jsn : TJsonObject) : TFhirContract; overload;
    procedure ParseContract(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoverage(jsn : TJsonObject) : TFhirCoverage; overload;
    procedure ParseCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDataElementContact(jsn : TJsonObject) : TFhirDataElementContact; overload; {b\}
    procedure ParseDataElementContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDataElementMapping(jsn : TJsonObject) : TFhirDataElementMapping; overload; {b\}
    procedure ParseDataElementMapping(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDataElement(jsn : TJsonObject) : TFhirDataElement; overload;
    procedure ParseDataElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDetectedIssueMitigation(jsn : TJsonObject) : TFhirDetectedIssueMitigation; overload; {b\}
    procedure ParseDetectedIssueMitigation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDetectedIssue(jsn : TJsonObject) : TFhirDetectedIssue; overload;
    procedure ParseDetectedIssue(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDevice(jsn : TJsonObject) : TFhirDevice; overload;
    procedure ParseDevice(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceComponentProductionSpecification(jsn : TJsonObject) : TFhirDeviceComponentProductionSpecification; overload; {b\}
    procedure ParseDeviceComponentProductionSpecification(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceComponent(jsn : TJsonObject) : TFhirDeviceComponent; overload;
    procedure ParseDeviceComponent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceMetricCalibration(jsn : TJsonObject) : TFhirDeviceMetricCalibration; overload; {b\}
    procedure ParseDeviceMetricCalibration(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceMetric(jsn : TJsonObject) : TFhirDeviceMetric; overload;
    procedure ParseDeviceMetric(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceUseRequest(jsn : TJsonObject) : TFhirDeviceUseRequest; overload;
    procedure ParseDeviceUseRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceUseStatement(jsn : TJsonObject) : TFhirDeviceUseStatement; overload;
    procedure ParseDeviceUseStatement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticOrderEvent(jsn : TJsonObject) : TFhirDiagnosticOrderEvent; overload; {b\}
    procedure ParseDiagnosticOrderEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticOrderItem(jsn : TJsonObject) : TFhirDiagnosticOrderItem; overload; {b\}
    procedure ParseDiagnosticOrderItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticOrder(jsn : TJsonObject) : TFhirDiagnosticOrder; overload;
    procedure ParseDiagnosticOrder(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticReportImage(jsn : TJsonObject) : TFhirDiagnosticReportImage; overload; {b\}
    procedure ParseDiagnosticReportImage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticReport(jsn : TJsonObject) : TFhirDiagnosticReport; overload;
    procedure ParseDiagnosticReport(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentManifestContent(jsn : TJsonObject) : TFhirDocumentManifestContent; overload; {b\}
    procedure ParseDocumentManifestContent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentManifestRelated(jsn : TJsonObject) : TFhirDocumentManifestRelated; overload; {b\}
    procedure ParseDocumentManifestRelated(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentManifest(jsn : TJsonObject) : TFhirDocumentManifest; overload;
    procedure ParseDocumentManifest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceRelatesTo(jsn : TJsonObject) : TFhirDocumentReferenceRelatesTo; overload; {b\}
    procedure ParseDocumentReferenceRelatesTo(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceContent(jsn : TJsonObject) : TFhirDocumentReferenceContent; overload; {b\}
    procedure ParseDocumentReferenceContent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceContext(jsn : TJsonObject) : TFhirDocumentReferenceContext; overload; {b\}
    procedure ParseDocumentReferenceContext(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceContextRelated(jsn : TJsonObject) : TFhirDocumentReferenceContextRelated; overload; {b\}
    procedure ParseDocumentReferenceContextRelated(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReference(jsn : TJsonObject) : TFhirDocumentReference; overload;
    procedure ParseDocumentReference(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEligibilityRequest(jsn : TJsonObject) : TFhirEligibilityRequest; overload;
    procedure ParseEligibilityRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEligibilityResponse(jsn : TJsonObject) : TFhirEligibilityResponse; overload;
    procedure ParseEligibilityResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterStatusHistory(jsn : TJsonObject) : TFhirEncounterStatusHistory; overload; {b\}
    procedure ParseEncounterStatusHistory(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterParticipant(jsn : TJsonObject) : TFhirEncounterParticipant; overload; {b\}
    procedure ParseEncounterParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterHospitalization(jsn : TJsonObject) : TFhirEncounterHospitalization; overload; {b\}
    procedure ParseEncounterHospitalization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterLocation(jsn : TJsonObject) : TFhirEncounterLocation; overload; {b\}
    procedure ParseEncounterLocation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounter(jsn : TJsonObject) : TFhirEncounter; overload;
    procedure ParseEncounter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEnrollmentRequest(jsn : TJsonObject) : TFhirEnrollmentRequest; overload;
    procedure ParseEnrollmentRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEnrollmentResponse(jsn : TJsonObject) : TFhirEnrollmentResponse; overload;
    procedure ParseEnrollmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEpisodeOfCareStatusHistory(jsn : TJsonObject) : TFhirEpisodeOfCareStatusHistory; overload; {b\}
    procedure ParseEpisodeOfCareStatusHistory(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEpisodeOfCareCareTeam(jsn : TJsonObject) : TFhirEpisodeOfCareCareTeam; overload; {b\}
    procedure ParseEpisodeOfCareCareTeam(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEpisodeOfCare(jsn : TJsonObject) : TFhirEpisodeOfCare; overload;
    procedure ParseEpisodeOfCare(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefit(jsn : TJsonObject) : TFhirExplanationOfBenefit; overload;
    procedure ParseExplanationOfBenefit(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseFamilyMemberHistoryCondition(jsn : TJsonObject) : TFhirFamilyMemberHistoryCondition; overload; {b\}
    procedure ParseFamilyMemberHistoryCondition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseFamilyMemberHistory(jsn : TJsonObject) : TFhirFamilyMemberHistory; overload;
    procedure ParseFamilyMemberHistory(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseFlag(jsn : TJsonObject) : TFhirFlag; overload;
    procedure ParseFlag(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGoalOutcome(jsn : TJsonObject) : TFhirGoalOutcome; overload; {b\}
    procedure ParseGoalOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGoal(jsn : TJsonObject) : TFhirGoal; overload;
    procedure ParseGoal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGroupCharacteristic(jsn : TJsonObject) : TFhirGroupCharacteristic; overload; {b\}
    procedure ParseGroupCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGroupMember(jsn : TJsonObject) : TFhirGroupMember; overload; {b\}
    procedure ParseGroupMember(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGroup(jsn : TJsonObject) : TFhirGroup; overload;
    procedure ParseGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHealthcareServiceServiceType(jsn : TJsonObject) : TFhirHealthcareServiceServiceType; overload; {b\}
    procedure ParseHealthcareServiceServiceType(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHealthcareServiceAvailableTime(jsn : TJsonObject) : TFhirHealthcareServiceAvailableTime; overload; {b\}
    procedure ParseHealthcareServiceAvailableTime(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHealthcareServiceNotAvailable(jsn : TJsonObject) : TFhirHealthcareServiceNotAvailable; overload; {b\}
    procedure ParseHealthcareServiceNotAvailable(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHealthcareService(jsn : TJsonObject) : TFhirHealthcareService; overload;
    procedure ParseHealthcareService(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingObjectSelectionStudy(jsn : TJsonObject) : TFhirImagingObjectSelectionStudy; overload; {b\}
    procedure ParseImagingObjectSelectionStudy(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingObjectSelectionStudySeries(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeries; overload; {b\}
    procedure ParseImagingObjectSelectionStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingObjectSelectionStudySeriesInstance(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeriesInstance; overload; {b\}
    procedure ParseImagingObjectSelectionStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingObjectSelectionStudySeriesInstanceFrames(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeriesInstanceFrames; overload; {b\}
    procedure ParseImagingObjectSelectionStudySeriesInstanceFrames(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingObjectSelection(jsn : TJsonObject) : TFhirImagingObjectSelection; overload;
    procedure ParseImagingObjectSelection(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingStudySeries(jsn : TJsonObject) : TFhirImagingStudySeries; overload; {b\}
    procedure ParseImagingStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingStudySeriesInstance(jsn : TJsonObject) : TFhirImagingStudySeriesInstance; overload; {b\}
    procedure ParseImagingStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingStudy(jsn : TJsonObject) : TFhirImagingStudy; overload;
    procedure ParseImagingStudy(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationExplanation(jsn : TJsonObject) : TFhirImmunizationExplanation; overload; {b\}
    procedure ParseImmunizationExplanation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationReaction(jsn : TJsonObject) : TFhirImmunizationReaction; overload; {b\}
    procedure ParseImmunizationReaction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationVaccinationProtocol(jsn : TJsonObject) : TFhirImmunizationVaccinationProtocol; overload; {b\}
    procedure ParseImmunizationVaccinationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunization(jsn : TJsonObject) : TFhirImmunization; overload;
    procedure ParseImmunization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendation; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationDateCriterion; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationProtocol; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendation; overload;
    procedure ParseImmunizationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuideContact(jsn : TJsonObject) : TFhirImplementationGuideContact; overload; {b\}
    procedure ParseImplementationGuideContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuideDependency(jsn : TJsonObject) : TFhirImplementationGuideDependency; overload; {b\}
    procedure ParseImplementationGuideDependency(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuidePackage(jsn : TJsonObject) : TFhirImplementationGuidePackage; overload; {b\}
    procedure ParseImplementationGuidePackage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuidePackageResource(jsn : TJsonObject) : TFhirImplementationGuidePackageResource; overload; {b\}
    procedure ParseImplementationGuidePackageResource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuideGlobal(jsn : TJsonObject) : TFhirImplementationGuideGlobal; overload; {b\}
    procedure ParseImplementationGuideGlobal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuidePage(jsn : TJsonObject) : TFhirImplementationGuidePage; overload; {b\}
    procedure ParseImplementationGuidePage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuide(jsn : TJsonObject) : TFhirImplementationGuide; overload;
    procedure ParseImplementationGuide(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseListEntry(jsn : TJsonObject) : TFhirListEntry; overload; {b\}
    procedure ParseListEntry(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseList(jsn : TJsonObject) : TFhirList; overload;
    procedure ParseList(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseLocationPosition(jsn : TJsonObject) : TFhirLocationPosition; overload; {b\}
    procedure ParseLocationPosition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseLocation(jsn : TJsonObject) : TFhirLocation; overload;
    procedure ParseLocation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedia(jsn : TJsonObject) : TFhirMedia; overload;
    procedure ParseMedia(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationProduct(jsn : TJsonObject) : TFhirMedicationProduct; overload; {b\}
    procedure ParseMedicationProduct(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationProductIngredient(jsn : TJsonObject) : TFhirMedicationProductIngredient; overload; {b\}
    procedure ParseMedicationProductIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationProductBatch(jsn : TJsonObject) : TFhirMedicationProductBatch; overload; {b\}
    procedure ParseMedicationProductBatch(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPackage(jsn : TJsonObject) : TFhirMedicationPackage; overload; {b\}
    procedure ParseMedicationPackage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPackageContent(jsn : TJsonObject) : TFhirMedicationPackageContent; overload; {b\}
    procedure ParseMedicationPackageContent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedication(jsn : TJsonObject) : TFhirMedication; overload;
    procedure ParseMedication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationAdministrationDosage(jsn : TJsonObject) : TFhirMedicationAdministrationDosage; overload; {b\}
    procedure ParseMedicationAdministrationDosage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationAdministration(jsn : TJsonObject) : TFhirMedicationAdministration; overload;
    procedure ParseMedicationAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispenseDosageInstruction(jsn : TJsonObject) : TFhirMedicationDispenseDosageInstruction; overload; {b\}
    procedure ParseMedicationDispenseDosageInstruction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispenseSubstitution(jsn : TJsonObject) : TFhirMedicationDispenseSubstitution; overload; {b\}
    procedure ParseMedicationDispenseSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispense(jsn : TJsonObject) : TFhirMedicationDispense; overload;
    procedure ParseMedicationDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationOrderDosageInstruction(jsn : TJsonObject) : TFhirMedicationOrderDosageInstruction; overload; {b\}
    procedure ParseMedicationOrderDosageInstruction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationOrderDispenseRequest(jsn : TJsonObject) : TFhirMedicationOrderDispenseRequest; overload; {b\}
    procedure ParseMedicationOrderDispenseRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationOrderSubstitution(jsn : TJsonObject) : TFhirMedicationOrderSubstitution; overload; {b\}
    procedure ParseMedicationOrderSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationOrder(jsn : TJsonObject) : TFhirMedicationOrder; overload;
    procedure ParseMedicationOrder(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationStatementDosage(jsn : TJsonObject) : TFhirMedicationStatementDosage; overload; {b\}
    procedure ParseMedicationStatementDosage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationStatement(jsn : TJsonObject) : TFhirMedicationStatement; overload;
    procedure ParseMedicationStatement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeaderResponse(jsn : TJsonObject) : TFhirMessageHeaderResponse; overload; {b\}
    procedure ParseMessageHeaderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeaderSource(jsn : TJsonObject) : TFhirMessageHeaderSource; overload; {b\}
    procedure ParseMessageHeaderSource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeaderDestination(jsn : TJsonObject) : TFhirMessageHeaderDestination; overload; {b\}
    procedure ParseMessageHeaderDestination(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeader(jsn : TJsonObject) : TFhirMessageHeader; overload;
    procedure ParseMessageHeader(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNamingSystemContact(jsn : TJsonObject) : TFhirNamingSystemContact; overload; {b\}
    procedure ParseNamingSystemContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNamingSystemUniqueId(jsn : TJsonObject) : TFhirNamingSystemUniqueId; overload; {b\}
    procedure ParseNamingSystemUniqueId(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNamingSystem(jsn : TJsonObject) : TFhirNamingSystem; overload;
    procedure ParseNamingSystem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderOralDiet(jsn : TJsonObject) : TFhirNutritionOrderOralDiet; overload; {b\}
    procedure ParseNutritionOrderOralDiet(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderOralDietNutrient(jsn : TJsonObject) : TFhirNutritionOrderOralDietNutrient; overload; {b\}
    procedure ParseNutritionOrderOralDietNutrient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderOralDietTexture(jsn : TJsonObject) : TFhirNutritionOrderOralDietTexture; overload; {b\}
    procedure ParseNutritionOrderOralDietTexture(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderSupplement(jsn : TJsonObject) : TFhirNutritionOrderSupplement; overload; {b\}
    procedure ParseNutritionOrderSupplement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderEnteralFormula(jsn : TJsonObject) : TFhirNutritionOrderEnteralFormula; overload; {b\}
    procedure ParseNutritionOrderEnteralFormula(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderEnteralFormulaAdministration(jsn : TJsonObject) : TFhirNutritionOrderEnteralFormulaAdministration; overload; {b\}
    procedure ParseNutritionOrderEnteralFormulaAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrder(jsn : TJsonObject) : TFhirNutritionOrder; overload;
    procedure ParseNutritionOrder(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservationReferenceRange(jsn : TJsonObject) : TFhirObservationReferenceRange; overload; {b\}
    procedure ParseObservationReferenceRange(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservationRelated(jsn : TJsonObject) : TFhirObservationRelated; overload; {b\}
    procedure ParseObservationRelated(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservationComponent(jsn : TJsonObject) : TFhirObservationComponent; overload; {b\}
    procedure ParseObservationComponent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservation(jsn : TJsonObject) : TFhirObservation; overload;
    procedure ParseObservation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationDefinitionContact(jsn : TJsonObject) : TFhirOperationDefinitionContact; overload; {b\}
    procedure ParseOperationDefinitionContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationDefinitionParameter(jsn : TJsonObject) : TFhirOperationDefinitionParameter; overload; {b\}
    procedure ParseOperationDefinitionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationDefinitionParameterBinding(jsn : TJsonObject) : TFhirOperationDefinitionParameterBinding; overload; {b\}
    procedure ParseOperationDefinitionParameterBinding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationDefinition(jsn : TJsonObject) : TFhirOperationDefinition; overload;
    procedure ParseOperationDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationOutcomeIssue(jsn : TJsonObject) : TFhirOperationOutcomeIssue; overload; {b\}
    procedure ParseOperationOutcomeIssue(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationOutcome(jsn : TJsonObject) : TFhirOperationOutcome; overload;
    procedure ParseOperationOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrderWhen(jsn : TJsonObject) : TFhirOrderWhen; overload; {b\}
    procedure ParseOrderWhen(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrder(jsn : TJsonObject) : TFhirOrder; overload;
    procedure ParseOrder(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrderResponse(jsn : TJsonObject) : TFhirOrderResponse; overload;
    procedure ParseOrderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrganizationContact(jsn : TJsonObject) : TFhirOrganizationContact; overload; {b\}
    procedure ParseOrganizationContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrganization(jsn : TJsonObject) : TFhirOrganization; overload;
    procedure ParseOrganization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientContact(jsn : TJsonObject) : TFhirPatientContact; overload; {b\}
    procedure ParsePatientContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientAnimal(jsn : TJsonObject) : TFhirPatientAnimal; overload; {b\}
    procedure ParsePatientAnimal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientCommunication(jsn : TJsonObject) : TFhirPatientCommunication; overload; {b\}
    procedure ParsePatientCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientLink(jsn : TJsonObject) : TFhirPatientLink; overload; {b\}
    procedure ParsePatientLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatient(jsn : TJsonObject) : TFhirPatient; overload;
    procedure ParsePatient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePaymentNotice(jsn : TJsonObject) : TFhirPaymentNotice; overload;
    procedure ParsePaymentNotice(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePaymentReconciliationDetail(jsn : TJsonObject) : TFhirPaymentReconciliationDetail; overload; {b\}
    procedure ParsePaymentReconciliationDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePaymentReconciliationNote(jsn : TJsonObject) : TFhirPaymentReconciliationNote; overload; {b\}
    procedure ParsePaymentReconciliationNote(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePaymentReconciliation(jsn : TJsonObject) : TFhirPaymentReconciliation; overload;
    procedure ParsePaymentReconciliation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePersonLink(jsn : TJsonObject) : TFhirPersonLink; overload; {b\}
    procedure ParsePersonLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePerson(jsn : TJsonObject) : TFhirPerson; overload;
    procedure ParsePerson(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePractitionerPractitionerRole(jsn : TJsonObject) : TFhirPractitionerPractitionerRole; overload; {b\}
    procedure ParsePractitionerPractitionerRole(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePractitionerQualification(jsn : TJsonObject) : TFhirPractitionerQualification; overload; {b\}
    procedure ParsePractitionerQualification(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePractitioner(jsn : TJsonObject) : TFhirPractitioner; overload;
    procedure ParsePractitioner(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedurePerformer(jsn : TJsonObject) : TFhirProcedurePerformer; overload; {b\}
    procedure ParseProcedurePerformer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedureFocalDevice(jsn : TJsonObject) : TFhirProcedureFocalDevice; overload; {b\}
    procedure ParseProcedureFocalDevice(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedure(jsn : TJsonObject) : TFhirProcedure; overload;
    procedure ParseProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedureRequest(jsn : TJsonObject) : TFhirProcedureRequest; overload;
    procedure ParseProcedureRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcessRequestItem(jsn : TJsonObject) : TFhirProcessRequestItem; overload; {b\}
    procedure ParseProcessRequestItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcessRequest(jsn : TJsonObject) : TFhirProcessRequest; overload;
    procedure ParseProcessRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcessResponseNotes(jsn : TJsonObject) : TFhirProcessResponseNotes; overload; {b\}
    procedure ParseProcessResponseNotes(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcessResponse(jsn : TJsonObject) : TFhirProcessResponse; overload;
    procedure ParseProcessResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenanceAgent(jsn : TJsonObject) : TFhirProvenanceAgent; overload; {b\}
    procedure ParseProvenanceAgent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenanceAgentRelatedAgent(jsn : TJsonObject) : TFhirProvenanceAgentRelatedAgent; overload; {b\}
    procedure ParseProvenanceAgentRelatedAgent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenanceEntity(jsn : TJsonObject) : TFhirProvenanceEntity; overload; {b\}
    procedure ParseProvenanceEntity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenance(jsn : TJsonObject) : TFhirProvenance; overload;
    procedure ParseProvenance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireGroup(jsn : TJsonObject) : TFhirQuestionnaireGroup; overload; {b\}
    procedure ParseQuestionnaireGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireGroupQuestion; overload; {b\}
    procedure ParseQuestionnaireGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaire(jsn : TJsonObject) : TFhirQuestionnaire; overload;
    procedure ParseQuestionnaire(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireResponseGroup(jsn : TJsonObject) : TFhirQuestionnaireResponseGroup; overload; {b\}
    procedure ParseQuestionnaireResponseGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireResponseGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireResponseGroupQuestion; overload; {b\}
    procedure ParseQuestionnaireResponseGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireResponseGroupQuestionAnswer(jsn : TJsonObject) : TFhirQuestionnaireResponseGroupQuestionAnswer; overload; {b\}
    procedure ParseQuestionnaireResponseGroupQuestionAnswer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireResponse(jsn : TJsonObject) : TFhirQuestionnaireResponse; overload;
    procedure ParseQuestionnaireResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseReferralRequest(jsn : TJsonObject) : TFhirReferralRequest; overload;
    procedure ParseReferralRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRelatedPerson(jsn : TJsonObject) : TFhirRelatedPerson; overload;
    procedure ParseRelatedPerson(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRiskAssessmentPrediction(jsn : TJsonObject) : TFhirRiskAssessmentPrediction; overload; {b\}
    procedure ParseRiskAssessmentPrediction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRiskAssessment(jsn : TJsonObject) : TFhirRiskAssessment; overload;
    procedure ParseRiskAssessment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSchedule(jsn : TJsonObject) : TFhirSchedule; overload;
    procedure ParseSchedule(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSearchParameterContact(jsn : TJsonObject) : TFhirSearchParameterContact; overload; {b\}
    procedure ParseSearchParameterContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSearchParameter(jsn : TJsonObject) : TFhirSearchParameter; overload;
    procedure ParseSearchParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSlot(jsn : TJsonObject) : TFhirSlot; overload;
    procedure ParseSlot(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenCollection(jsn : TJsonObject) : TFhirSpecimenCollection; overload; {b\}
    procedure ParseSpecimenCollection(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenTreatment(jsn : TJsonObject) : TFhirSpecimenTreatment; overload; {b\}
    procedure ParseSpecimenTreatment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenContainer(jsn : TJsonObject) : TFhirSpecimenContainer; overload; {b\}
    procedure ParseSpecimenContainer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimen(jsn : TJsonObject) : TFhirSpecimen; overload;
    procedure ParseSpecimen(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinitionContact(jsn : TJsonObject) : TFhirStructureDefinitionContact; overload; {b\}
    procedure ParseStructureDefinitionContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinitionMapping(jsn : TJsonObject) : TFhirStructureDefinitionMapping; overload; {b\}
    procedure ParseStructureDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinitionSnapshot(jsn : TJsonObject) : TFhirStructureDefinitionSnapshot; overload; {b\}
    procedure ParseStructureDefinitionSnapshot(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinitionDifferential(jsn : TJsonObject) : TFhirStructureDefinitionDifferential; overload; {b\}
    procedure ParseStructureDefinitionDifferential(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinition(jsn : TJsonObject) : TFhirStructureDefinition; overload;
    procedure ParseStructureDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubscriptionChannel(jsn : TJsonObject) : TFhirSubscriptionChannel; overload; {b\}
    procedure ParseSubscriptionChannel(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubscription(jsn : TJsonObject) : TFhirSubscription; overload;
    procedure ParseSubscription(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceInstance(jsn : TJsonObject) : TFhirSubstanceInstance; overload; {b\}
    procedure ParseSubstanceInstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceIngredient(jsn : TJsonObject) : TFhirSubstanceIngredient; overload; {b\}
    procedure ParseSubstanceIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstance(jsn : TJsonObject) : TFhirSubstance; overload;
    procedure ParseSubstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSupplyDelivery(jsn : TJsonObject) : TFhirSupplyDelivery; overload;
    procedure ParseSupplyDelivery(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSupplyRequestWhen(jsn : TJsonObject) : TFhirSupplyRequestWhen; overload; {b\}
    procedure ParseSupplyRequestWhen(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSupplyRequest(jsn : TJsonObject) : TFhirSupplyRequest; overload;
    procedure ParseSupplyRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptContact(jsn : TJsonObject) : TFhirTestScriptContact; overload; {b\}
    procedure ParseTestScriptContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptMetadata(jsn : TJsonObject) : TFhirTestScriptMetadata; overload; {b\}
    procedure ParseTestScriptMetadata(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptMetadataLink(jsn : TJsonObject) : TFhirTestScriptMetadataLink; overload; {b\}
    procedure ParseTestScriptMetadataLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptMetadataCapability(jsn : TJsonObject) : TFhirTestScriptMetadataCapability; overload; {b\}
    procedure ParseTestScriptMetadataCapability(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptFixture(jsn : TJsonObject) : TFhirTestScriptFixture; overload; {b\}
    procedure ParseTestScriptFixture(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptVariable(jsn : TJsonObject) : TFhirTestScriptVariable; overload; {b\}
    procedure ParseTestScriptVariable(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptSetup(jsn : TJsonObject) : TFhirTestScriptSetup; overload; {b\}
    procedure ParseTestScriptSetup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptSetupAction(jsn : TJsonObject) : TFhirTestScriptSetupAction; overload; {b\}
    procedure ParseTestScriptSetupAction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptSetupActionOperation(jsn : TJsonObject) : TFhirTestScriptSetupActionOperation; overload; {b\}
    procedure ParseTestScriptSetupActionOperation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptSetupActionOperationRequestHeader(jsn : TJsonObject) : TFhirTestScriptSetupActionOperationRequestHeader; overload; {b\}
    procedure ParseTestScriptSetupActionOperationRequestHeader(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptSetupActionAssert(jsn : TJsonObject) : TFhirTestScriptSetupActionAssert; overload; {b\}
    procedure ParseTestScriptSetupActionAssert(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptTest(jsn : TJsonObject) : TFhirTestScriptTest; overload; {b\}
    procedure ParseTestScriptTest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptTestAction(jsn : TJsonObject) : TFhirTestScriptTestAction; overload; {b\}
    procedure ParseTestScriptTestAction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptTeardown(jsn : TJsonObject) : TFhirTestScriptTeardown; overload; {b\}
    procedure ParseTestScriptTeardown(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptTeardownAction(jsn : TJsonObject) : TFhirTestScriptTeardownAction; overload; {b\}
    procedure ParseTestScriptTeardownAction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScript(jsn : TJsonObject) : TFhirTestScript; overload;
    procedure ParseTestScript(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetContact(jsn : TJsonObject) : TFhirValueSetContact; overload; {b\}
    procedure ParseValueSetContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetCodeSystem(jsn : TJsonObject) : TFhirValueSetCodeSystem; overload; {b\}
    procedure ParseValueSetCodeSystem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetCodeSystemConcept(jsn : TJsonObject) : TFhirValueSetCodeSystemConcept; overload; {b\}
    procedure ParseValueSetCodeSystemConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetCodeSystemConceptDesignation(jsn : TJsonObject) : TFhirValueSetCodeSystemConceptDesignation; overload; {b\}
    procedure ParseValueSetCodeSystemConceptDesignation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetCompose(jsn : TJsonObject) : TFhirValueSetCompose; overload; {b\}
    procedure ParseValueSetCompose(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeInclude(jsn : TJsonObject) : TFhirValueSetComposeInclude; overload; {b\}
    procedure ParseValueSetComposeInclude(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeIncludeConcept(jsn : TJsonObject) : TFhirValueSetComposeIncludeConcept; overload; {b\}
    procedure ParseValueSetComposeIncludeConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeIncludeFilter(jsn : TJsonObject) : TFhirValueSetComposeIncludeFilter; overload; {b\}
    procedure ParseValueSetComposeIncludeFilter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetExpansion(jsn : TJsonObject) : TFhirValueSetExpansion; overload; {b\}
    procedure ParseValueSetExpansion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetExpansionParameter(jsn : TJsonObject) : TFhirValueSetExpansionParameter; overload; {b\}
    procedure ParseValueSetExpansionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetExpansionContains(jsn : TJsonObject) : TFhirValueSetExpansionContains; overload; {b\}
    procedure ParseValueSetExpansionContains(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSet(jsn : TJsonObject) : TFhirValueSet; overload;
    procedure ParseValueSet(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseVisionPrescriptionDispense(jsn : TJsonObject) : TFhirVisionPrescriptionDispense; overload; {b\}
    procedure ParseVisionPrescriptionDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseVisionPrescription(jsn : TJsonObject) : TFhirVisionPrescription; overload;
    procedure ParseVisionPrescription(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseResource(jsn : TJsonObject) : TFhirResource; override;
    function ParseDataType(jsn : TJsonObject; name : String; type_ : TFHIRTypeClass) : TFHIRType; override;
  public
    function ParseFragment(jsn : TJsonObject; type_ : String) : TFhirBase;  overload;
  end;

  TFHIRJsonComposer = class (TFHIRJsonComposerBase)
  protected
    procedure ComposeElement(json : TJSONWriter; name : string; elem : TFhirElement; noObj : boolean = false);
    procedure ComposeBackboneElement(json : TJSONWriter; name : string; elem : TFhirBackboneElement; noObj : boolean = false);

    Procedure ComposeElementProperties(json : TJSONWriter; elem : TFhirElement);
    Procedure ComposeBackboneElementProperties(json : TJSONWriter; elem : TFhirBackboneElement);
    Procedure ComposeEnumValue(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
    Procedure ComposeEnumProps(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
    Procedure ComposeIntegerValue(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
    Procedure ComposeIntegerProps(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
    Procedure ComposeDateTimeValue(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
    Procedure ComposeDateTimeProps(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
    Procedure ComposeDateValue(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
    Procedure ComposeDateProps(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
    Procedure ComposeDecimalValue(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
    Procedure ComposeDecimalProps(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
    Procedure ComposeUriValue(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
    Procedure ComposeUriProps(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
    Procedure ComposeBase64BinaryValue(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
    Procedure ComposeBase64BinaryProps(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
    Procedure ComposeTimeValue(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
    Procedure ComposeTimeProps(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
    Procedure ComposeStringValue(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
    Procedure ComposeStringProps(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
    Procedure ComposeBooleanValue(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
    Procedure ComposeBooleanProps(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
    Procedure ComposeInstantValue(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
    Procedure ComposeInstantProps(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
    Procedure ComposeMarkdownValue(json : TJSONWriter; name : String; value : TFhirMarkdown; inArray : boolean);
    Procedure ComposeMarkdownProps(json : TJSONWriter; name : String; value : TFhirMarkdown; inArray : boolean);
    Procedure ComposeUnsignedIntValue(json : TJSONWriter; name : String; value : TFhirUnsignedInt; inArray : boolean);
    Procedure ComposeUnsignedIntProps(json : TJSONWriter; name : String; value : TFhirUnsignedInt; inArray : boolean);
    Procedure ComposeCodeValue(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
    Procedure ComposeCodeProps(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
    Procedure ComposeIdValue(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
    Procedure ComposeIdProps(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
    Procedure ComposeOidValue(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
    Procedure ComposeOidProps(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
    Procedure ComposePositiveIntValue(json : TJSONWriter; name : String; value : TFhirPositiveInt; inArray : boolean);
    Procedure ComposePositiveIntProps(json : TJSONWriter; name : String; value : TFhirPositiveInt; inArray : boolean);
    Procedure ComposeUuidValue(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
    Procedure ComposeUuidProps(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);

    Procedure ComposeResourceProperties(json : TJSONWriter; elem : TFhirResource);
    Procedure ComposeDomainResourceProperties(json : TJSONWriter; elem : TFhirDomainResource);
    procedure ComposeParametersParameter(json : TJSONWriter; name : string; elem : TFhirParametersParameter; noObj : boolean = false);
    procedure ComposeParameters(json : TJSONWriter; name : string; elem : TFhirParameters; noObj : boolean = false);

    procedure ComposeExtension(json : TJSONWriter; name : string; elem : TFhirExtension; noObj : boolean = false);
    procedure ComposeNarrative(json : TJSONWriter; name : string; elem : TFhirNarrative; noObj : boolean = false);
    procedure ComposePeriod(json : TJSONWriter; name : string; elem : TFhirPeriod; noObj : boolean = false);
    procedure ComposeCoding(json : TJSONWriter; name : string; elem : TFhirCoding; noObj : boolean = false);
    procedure ComposeRange(json : TJSONWriter; name : string; elem : TFhirRange; noObj : boolean = false);
    procedure ComposeAttachment(json : TJSONWriter; name : string; elem : TFhirAttachment; noObj : boolean = false);
    procedure ComposeQuantity(json : TJSONWriter; name : string; elem : TFhirQuantity; noObj : boolean = false);
    procedure ComposeAnnotation(json : TJSONWriter; name : string; elem : TFhirAnnotation; noObj : boolean = false);
    procedure ComposeRatio(json : TJSONWriter; name : string; elem : TFhirRatio; noObj : boolean = false);
    procedure ComposeSampledData(json : TJSONWriter; name : string; elem : TFhirSampledData; noObj : boolean = false);
    procedure ComposeCodeableConcept(json : TJSONWriter; name : string; elem : TFhirCodeableConcept; noObj : boolean = false);
    procedure ComposeReference(json : TJSONWriter; name : string; elem : TFhirReference; noObj : boolean = false);
    procedure ComposeIdentifier(json : TJSONWriter; name : string; elem : TFhirIdentifier; noObj : boolean = false);
    procedure ComposeSignature(json : TJSONWriter; name : string; elem : TFhirSignature; noObj : boolean = false);
    procedure ComposeTimingRepeat(json : TJSONWriter; name : string; elem : TFhirTimingRepeat; noObj : boolean = false);
    procedure ComposeTiming(json : TJSONWriter; name : string; elem : TFhirTiming; noObj : boolean = false);
    procedure ComposeElementDefinitionSlicing(json : TJSONWriter; name : string; elem : TFhirElementDefinitionSlicing; noObj : boolean = false);
    procedure ComposeElementDefinitionBase(json : TJSONWriter; name : string; elem : TFhirElementDefinitionBase; noObj : boolean = false);
    procedure ComposeElementDefinitionType(json : TJSONWriter; name : string; elem : TFhirElementDefinitionType; noObj : boolean = false);
    procedure ComposeElementDefinitionConstraint(json : TJSONWriter; name : string; elem : TFhirElementDefinitionConstraint; noObj : boolean = false);
    procedure ComposeElementDefinitionBinding(json : TJSONWriter; name : string; elem : TFhirElementDefinitionBinding; noObj : boolean = false);
    procedure ComposeElementDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirElementDefinitionMapping; noObj : boolean = false);
    procedure ComposeElementDefinition(json : TJSONWriter; name : string; elem : TFhirElementDefinition; noObj : boolean = false);
    procedure ComposeHumanName(json : TJSONWriter; name : string; elem : TFhirHumanName; noObj : boolean = false);
    procedure ComposeAddress(json : TJSONWriter; name : string; elem : TFhirAddress; noObj : boolean = false);
    procedure ComposeMeta(json : TJSONWriter; name : string; elem : TFhirMeta; noObj : boolean = false);
    procedure ComposeContactPoint(json : TJSONWriter; name : string; elem : TFhirContactPoint; noObj : boolean = false);

    procedure ComposeAccount(json : TJSONWriter; name : string; elem : TFhirAccount; noObj : boolean = false);
    procedure ComposeAllergyIntoleranceReaction(json : TJSONWriter; name : string; elem : TFhirAllergyIntoleranceReaction; noObj : boolean = false);
    procedure ComposeAllergyIntolerance(json : TJSONWriter; name : string; elem : TFhirAllergyIntolerance; noObj : boolean = false);
    procedure ComposeAppointmentParticipant(json : TJSONWriter; name : string; elem : TFhirAppointmentParticipant; noObj : boolean = false);
    procedure ComposeAppointment(json : TJSONWriter; name : string; elem : TFhirAppointment; noObj : boolean = false);
    procedure ComposeAppointmentResponse(json : TJSONWriter; name : string; elem : TFhirAppointmentResponse; noObj : boolean = false);
    procedure ComposeAuditEventEvent(json : TJSONWriter; name : string; elem : TFhirAuditEventEvent; noObj : boolean = false);
    procedure ComposeAuditEventParticipant(json : TJSONWriter; name : string; elem : TFhirAuditEventParticipant; noObj : boolean = false);
    procedure ComposeAuditEventParticipantNetwork(json : TJSONWriter; name : string; elem : TFhirAuditEventParticipantNetwork; noObj : boolean = false);
    procedure ComposeAuditEventSource(json : TJSONWriter; name : string; elem : TFhirAuditEventSource; noObj : boolean = false);
    procedure ComposeAuditEventObject(json : TJSONWriter; name : string; elem : TFhirAuditEventObject; noObj : boolean = false);
    procedure ComposeAuditEventObjectDetail(json : TJSONWriter; name : string; elem : TFhirAuditEventObjectDetail; noObj : boolean = false);
    procedure ComposeAuditEvent(json : TJSONWriter; name : string; elem : TFhirAuditEvent; noObj : boolean = false);
    procedure ComposeBasic(json : TJSONWriter; name : string; elem : TFhirBasic; noObj : boolean = false);
    procedure ComposeBinary(json : TJSONWriter; name : string; elem : TFhirBinary; noObj : boolean = false);
    procedure ComposeBodySite(json : TJSONWriter; name : string; elem : TFhirBodySite; noObj : boolean = false);
    procedure ComposeBundleLink(json : TJSONWriter; name : string; elem : TFhirBundleLink; noObj : boolean = false);
    procedure ComposeBundleEntry(json : TJSONWriter; name : string; elem : TFhirBundleEntry; noObj : boolean = false);
    procedure ComposeBundleEntrySearch(json : TJSONWriter; name : string; elem : TFhirBundleEntrySearch; noObj : boolean = false);
    procedure ComposeBundleEntryRequest(json : TJSONWriter; name : string; elem : TFhirBundleEntryRequest; noObj : boolean = false);
    procedure ComposeBundleEntryResponse(json : TJSONWriter; name : string; elem : TFhirBundleEntryResponse; noObj : boolean = false);
    procedure ComposeBundle(json : TJSONWriter; name : string; elem : TFhirBundle; noObj : boolean = false);
    procedure ComposeCarePlanRelatedPlan(json : TJSONWriter; name : string; elem : TFhirCarePlanRelatedPlan; noObj : boolean = false);
    procedure ComposeCarePlanParticipant(json : TJSONWriter; name : string; elem : TFhirCarePlanParticipant; noObj : boolean = false);
    procedure ComposeCarePlanActivity(json : TJSONWriter; name : string; elem : TFhirCarePlanActivity; noObj : boolean = false);
    procedure ComposeCarePlanActivityDetail(json : TJSONWriter; name : string; elem : TFhirCarePlanActivityDetail; noObj : boolean = false);
    procedure ComposeCarePlan(json : TJSONWriter; name : string; elem : TFhirCarePlan; noObj : boolean = false);
    procedure ComposeClaimPayee(json : TJSONWriter; name : string; elem : TFhirClaimPayee; noObj : boolean = false);
    procedure ComposeClaimDiagnosis(json : TJSONWriter; name : string; elem : TFhirClaimDiagnosis; noObj : boolean = false);
    procedure ComposeClaimCoverage(json : TJSONWriter; name : string; elem : TFhirClaimCoverage; noObj : boolean = false);
    procedure ComposeClaimItem(json : TJSONWriter; name : string; elem : TFhirClaimItem; noObj : boolean = false);
    procedure ComposeClaimItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimItemDetail; noObj : boolean = false);
    procedure ComposeClaimItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimItemDetailSubDetail; noObj : boolean = false);
    procedure ComposeClaimItemProsthesis(json : TJSONWriter; name : string; elem : TFhirClaimItemProsthesis; noObj : boolean = false);
    procedure ComposeClaimMissingTeeth(json : TJSONWriter; name : string; elem : TFhirClaimMissingTeeth; noObj : boolean = false);
    procedure ComposeClaim(json : TJSONWriter; name : string; elem : TFhirClaim; noObj : boolean = false);
    procedure ComposeClaimResponseItem(json : TJSONWriter; name : string; elem : TFhirClaimResponseItem; noObj : boolean = false);
    procedure ComposeClaimResponseItemAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemAdjudication; noObj : boolean = false);
    procedure ComposeClaimResponseItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetail; noObj : boolean = false);
    procedure ComposeClaimResponseItemDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailAdjudication; noObj : boolean = false);
    procedure ComposeClaimResponseItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailSubDetail; noObj : boolean = false);
    procedure ComposeClaimResponseItemDetailSubDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailSubDetailAdjudication; noObj : boolean = false);
    procedure ComposeClaimResponseAddItem(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItem; noObj : boolean = false);
    procedure ComposeClaimResponseAddItemAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemAdjudication; noObj : boolean = false);
    procedure ComposeClaimResponseAddItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemDetail; noObj : boolean = false);
    procedure ComposeClaimResponseAddItemDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemDetailAdjudication; noObj : boolean = false);
    procedure ComposeClaimResponseError(json : TJSONWriter; name : string; elem : TFhirClaimResponseError; noObj : boolean = false);
    procedure ComposeClaimResponseNote(json : TJSONWriter; name : string; elem : TFhirClaimResponseNote; noObj : boolean = false);
    procedure ComposeClaimResponseCoverage(json : TJSONWriter; name : string; elem : TFhirClaimResponseCoverage; noObj : boolean = false);
    procedure ComposeClaimResponse(json : TJSONWriter; name : string; elem : TFhirClaimResponse; noObj : boolean = false);
    procedure ComposeClinicalImpressionInvestigations(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionInvestigations; noObj : boolean = false);
    procedure ComposeClinicalImpressionFinding(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionFinding; noObj : boolean = false);
    procedure ComposeClinicalImpressionRuledOut(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionRuledOut; noObj : boolean = false);
    procedure ComposeClinicalImpression(json : TJSONWriter; name : string; elem : TFhirClinicalImpression; noObj : boolean = false);
    procedure ComposeCommunicationPayload(json : TJSONWriter; name : string; elem : TFhirCommunicationPayload; noObj : boolean = false);
    procedure ComposeCommunication(json : TJSONWriter; name : string; elem : TFhirCommunication; noObj : boolean = false);
    procedure ComposeCommunicationRequestPayload(json : TJSONWriter; name : string; elem : TFhirCommunicationRequestPayload; noObj : boolean = false);
    procedure ComposeCommunicationRequest(json : TJSONWriter; name : string; elem : TFhirCommunicationRequest; noObj : boolean = false);
    procedure ComposeCompositionAttester(json : TJSONWriter; name : string; elem : TFhirCompositionAttester; noObj : boolean = false);
    procedure ComposeCompositionEvent(json : TJSONWriter; name : string; elem : TFhirCompositionEvent; noObj : boolean = false);
    procedure ComposeCompositionSection(json : TJSONWriter; name : string; elem : TFhirCompositionSection; noObj : boolean = false);
    procedure ComposeComposition(json : TJSONWriter; name : string; elem : TFhirComposition; noObj : boolean = false);
    procedure ComposeConceptMapContact(json : TJSONWriter; name : string; elem : TFhirConceptMapContact; noObj : boolean = false);
    procedure ComposeConceptMapElement(json : TJSONWriter; name : string; elem : TFhirConceptMapElement; noObj : boolean = false);
    procedure ComposeConceptMapElementTarget(json : TJSONWriter; name : string; elem : TFhirConceptMapElementTarget; noObj : boolean = false);
    procedure ComposeConceptMapElementTargetDependsOn(json : TJSONWriter; name : string; elem : TFhirConceptMapElementTargetDependsOn; noObj : boolean = false);
    procedure ComposeConceptMap(json : TJSONWriter; name : string; elem : TFhirConceptMap; noObj : boolean = false);
    procedure ComposeConditionStage(json : TJSONWriter; name : string; elem : TFhirConditionStage; noObj : boolean = false);
    procedure ComposeConditionEvidence(json : TJSONWriter; name : string; elem : TFhirConditionEvidence; noObj : boolean = false);
    procedure ComposeCondition(json : TJSONWriter; name : string; elem : TFhirCondition; noObj : boolean = false);
    procedure ComposeConformanceContact(json : TJSONWriter; name : string; elem : TFhirConformanceContact; noObj : boolean = false);
    procedure ComposeConformanceSoftware(json : TJSONWriter; name : string; elem : TFhirConformanceSoftware; noObj : boolean = false);
    procedure ComposeConformanceImplementation(json : TJSONWriter; name : string; elem : TFhirConformanceImplementation; noObj : boolean = false);
    procedure ComposeConformanceRest(json : TJSONWriter; name : string; elem : TFhirConformanceRest; noObj : boolean = false);
    procedure ComposeConformanceRestSecurity(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurity; noObj : boolean = false);
    procedure ComposeConformanceRestSecurityCertificate(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurityCertificate; noObj : boolean = false);
    procedure ComposeConformanceRestResource(json : TJSONWriter; name : string; elem : TFhirConformanceRestResource; noObj : boolean = false);
    procedure ComposeConformanceRestResourceInteraction(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceInteraction; noObj : boolean = false);
    procedure ComposeConformanceRestResourceSearchParam(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceSearchParam; noObj : boolean = false);
    procedure ComposeConformanceRestInteraction(json : TJSONWriter; name : string; elem : TFhirConformanceRestInteraction; noObj : boolean = false);
    procedure ComposeConformanceRestOperation(json : TJSONWriter; name : string; elem : TFhirConformanceRestOperation; noObj : boolean = false);
    procedure ComposeConformanceMessaging(json : TJSONWriter; name : string; elem : TFhirConformanceMessaging; noObj : boolean = false);
    procedure ComposeConformanceMessagingEndpoint(json : TJSONWriter; name : string; elem : TFhirConformanceMessagingEndpoint; noObj : boolean = false);
    procedure ComposeConformanceMessagingEvent(json : TJSONWriter; name : string; elem : TFhirConformanceMessagingEvent; noObj : boolean = false);
    procedure ComposeConformanceDocument(json : TJSONWriter; name : string; elem : TFhirConformanceDocument; noObj : boolean = false);
    procedure ComposeConformance(json : TJSONWriter; name : string; elem : TFhirConformance; noObj : boolean = false);
    procedure ComposeContractActor(json : TJSONWriter; name : string; elem : TFhirContractActor; noObj : boolean = false);
    procedure ComposeContractValuedItem(json : TJSONWriter; name : string; elem : TFhirContractValuedItem; noObj : boolean = false);
    procedure ComposeContractSigner(json : TJSONWriter; name : string; elem : TFhirContractSigner; noObj : boolean = false);
    procedure ComposeContractTerm(json : TJSONWriter; name : string; elem : TFhirContractTerm; noObj : boolean = false);
    procedure ComposeContractTermActor(json : TJSONWriter; name : string; elem : TFhirContractTermActor; noObj : boolean = false);
    procedure ComposeContractTermValuedItem(json : TJSONWriter; name : string; elem : TFhirContractTermValuedItem; noObj : boolean = false);
    procedure ComposeContractFriendly(json : TJSONWriter; name : string; elem : TFhirContractFriendly; noObj : boolean = false);
    procedure ComposeContractLegal(json : TJSONWriter; name : string; elem : TFhirContractLegal; noObj : boolean = false);
    procedure ComposeContractRule(json : TJSONWriter; name : string; elem : TFhirContractRule; noObj : boolean = false);
    procedure ComposeContract(json : TJSONWriter; name : string; elem : TFhirContract; noObj : boolean = false);
    procedure ComposeCoverage(json : TJSONWriter; name : string; elem : TFhirCoverage; noObj : boolean = false);
    procedure ComposeDataElementContact(json : TJSONWriter; name : string; elem : TFhirDataElementContact; noObj : boolean = false);
    procedure ComposeDataElementMapping(json : TJSONWriter; name : string; elem : TFhirDataElementMapping; noObj : boolean = false);
    procedure ComposeDataElement(json : TJSONWriter; name : string; elem : TFhirDataElement; noObj : boolean = false);
    procedure ComposeDetectedIssueMitigation(json : TJSONWriter; name : string; elem : TFhirDetectedIssueMitigation; noObj : boolean = false);
    procedure ComposeDetectedIssue(json : TJSONWriter; name : string; elem : TFhirDetectedIssue; noObj : boolean = false);
    procedure ComposeDevice(json : TJSONWriter; name : string; elem : TFhirDevice; noObj : boolean = false);
    procedure ComposeDeviceComponentProductionSpecification(json : TJSONWriter; name : string; elem : TFhirDeviceComponentProductionSpecification; noObj : boolean = false);
    procedure ComposeDeviceComponent(json : TJSONWriter; name : string; elem : TFhirDeviceComponent; noObj : boolean = false);
    procedure ComposeDeviceMetricCalibration(json : TJSONWriter; name : string; elem : TFhirDeviceMetricCalibration; noObj : boolean = false);
    procedure ComposeDeviceMetric(json : TJSONWriter; name : string; elem : TFhirDeviceMetric; noObj : boolean = false);
    procedure ComposeDeviceUseRequest(json : TJSONWriter; name : string; elem : TFhirDeviceUseRequest; noObj : boolean = false);
    procedure ComposeDeviceUseStatement(json : TJSONWriter; name : string; elem : TFhirDeviceUseStatement; noObj : boolean = false);
    procedure ComposeDiagnosticOrderEvent(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderEvent; noObj : boolean = false);
    procedure ComposeDiagnosticOrderItem(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderItem; noObj : boolean = false);
    procedure ComposeDiagnosticOrder(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrder; noObj : boolean = false);
    procedure ComposeDiagnosticReportImage(json : TJSONWriter; name : string; elem : TFhirDiagnosticReportImage; noObj : boolean = false);
    procedure ComposeDiagnosticReport(json : TJSONWriter; name : string; elem : TFhirDiagnosticReport; noObj : boolean = false);
    procedure ComposeDocumentManifestContent(json : TJSONWriter; name : string; elem : TFhirDocumentManifestContent; noObj : boolean = false);
    procedure ComposeDocumentManifestRelated(json : TJSONWriter; name : string; elem : TFhirDocumentManifestRelated; noObj : boolean = false);
    procedure ComposeDocumentManifest(json : TJSONWriter; name : string; elem : TFhirDocumentManifest; noObj : boolean = false);
    procedure ComposeDocumentReferenceRelatesTo(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceRelatesTo; noObj : boolean = false);
    procedure ComposeDocumentReferenceContent(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContent; noObj : boolean = false);
    procedure ComposeDocumentReferenceContext(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContext; noObj : boolean = false);
    procedure ComposeDocumentReferenceContextRelated(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContextRelated; noObj : boolean = false);
    procedure ComposeDocumentReference(json : TJSONWriter; name : string; elem : TFhirDocumentReference; noObj : boolean = false);
    procedure ComposeEligibilityRequest(json : TJSONWriter; name : string; elem : TFhirEligibilityRequest; noObj : boolean = false);
    procedure ComposeEligibilityResponse(json : TJSONWriter; name : string; elem : TFhirEligibilityResponse; noObj : boolean = false);
    procedure ComposeEncounterStatusHistory(json : TJSONWriter; name : string; elem : TFhirEncounterStatusHistory; noObj : boolean = false);
    procedure ComposeEncounterParticipant(json : TJSONWriter; name : string; elem : TFhirEncounterParticipant; noObj : boolean = false);
    procedure ComposeEncounterHospitalization(json : TJSONWriter; name : string; elem : TFhirEncounterHospitalization; noObj : boolean = false);
    procedure ComposeEncounterLocation(json : TJSONWriter; name : string; elem : TFhirEncounterLocation; noObj : boolean = false);
    procedure ComposeEncounter(json : TJSONWriter; name : string; elem : TFhirEncounter; noObj : boolean = false);
    procedure ComposeEnrollmentRequest(json : TJSONWriter; name : string; elem : TFhirEnrollmentRequest; noObj : boolean = false);
    procedure ComposeEnrollmentResponse(json : TJSONWriter; name : string; elem : TFhirEnrollmentResponse; noObj : boolean = false);
    procedure ComposeEpisodeOfCareStatusHistory(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCareStatusHistory; noObj : boolean = false);
    procedure ComposeEpisodeOfCareCareTeam(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCareCareTeam; noObj : boolean = false);
    procedure ComposeEpisodeOfCare(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCare; noObj : boolean = false);
    procedure ComposeExplanationOfBenefit(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefit; noObj : boolean = false);
    procedure ComposeFamilyMemberHistoryCondition(json : TJSONWriter; name : string; elem : TFhirFamilyMemberHistoryCondition; noObj : boolean = false);
    procedure ComposeFamilyMemberHistory(json : TJSONWriter; name : string; elem : TFhirFamilyMemberHistory; noObj : boolean = false);
    procedure ComposeFlag(json : TJSONWriter; name : string; elem : TFhirFlag; noObj : boolean = false);
    procedure ComposeGoalOutcome(json : TJSONWriter; name : string; elem : TFhirGoalOutcome; noObj : boolean = false);
    procedure ComposeGoal(json : TJSONWriter; name : string; elem : TFhirGoal; noObj : boolean = false);
    procedure ComposeGroupCharacteristic(json : TJSONWriter; name : string; elem : TFhirGroupCharacteristic; noObj : boolean = false);
    procedure ComposeGroupMember(json : TJSONWriter; name : string; elem : TFhirGroupMember; noObj : boolean = false);
    procedure ComposeGroup(json : TJSONWriter; name : string; elem : TFhirGroup; noObj : boolean = false);
    procedure ComposeHealthcareServiceServiceType(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceServiceType; noObj : boolean = false);
    procedure ComposeHealthcareServiceAvailableTime(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceAvailableTime; noObj : boolean = false);
    procedure ComposeHealthcareServiceNotAvailable(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceNotAvailable; noObj : boolean = false);
    procedure ComposeHealthcareService(json : TJSONWriter; name : string; elem : TFhirHealthcareService; noObj : boolean = false);
    procedure ComposeImagingObjectSelectionStudy(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudy; noObj : boolean = false);
    procedure ComposeImagingObjectSelectionStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeries; noObj : boolean = false);
    procedure ComposeImagingObjectSelectionStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstance; noObj : boolean = false);
    procedure ComposeImagingObjectSelectionStudySeriesInstanceFrames(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames; noObj : boolean = false);
    procedure ComposeImagingObjectSelection(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelection; noObj : boolean = false);
    procedure ComposeImagingStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingStudySeries; noObj : boolean = false);
    procedure ComposeImagingStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingStudySeriesInstance; noObj : boolean = false);
    procedure ComposeImagingStudy(json : TJSONWriter; name : string; elem : TFhirImagingStudy; noObj : boolean = false);
    procedure ComposeImmunizationExplanation(json : TJSONWriter; name : string; elem : TFhirImmunizationExplanation; noObj : boolean = false);
    procedure ComposeImmunizationReaction(json : TJSONWriter; name : string; elem : TFhirImmunizationReaction; noObj : boolean = false);
    procedure ComposeImmunizationVaccinationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationVaccinationProtocol; noObj : boolean = false);
    procedure ComposeImmunization(json : TJSONWriter; name : string; elem : TFhirImmunization; noObj : boolean = false);
    procedure ComposeImmunizationRecommendationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendation; noObj : boolean = false);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion; noObj : boolean = false);
    procedure ComposeImmunizationRecommendationRecommendationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol; noObj : boolean = false);
    procedure ComposeImmunizationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendation; noObj : boolean = false);
    procedure ComposeImplementationGuideContact(json : TJSONWriter; name : string; elem : TFhirImplementationGuideContact; noObj : boolean = false);
    procedure ComposeImplementationGuideDependency(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDependency; noObj : boolean = false);
    procedure ComposeImplementationGuidePackage(json : TJSONWriter; name : string; elem : TFhirImplementationGuidePackage; noObj : boolean = false);
    procedure ComposeImplementationGuidePackageResource(json : TJSONWriter; name : string; elem : TFhirImplementationGuidePackageResource; noObj : boolean = false);
    procedure ComposeImplementationGuideGlobal(json : TJSONWriter; name : string; elem : TFhirImplementationGuideGlobal; noObj : boolean = false);
    procedure ComposeImplementationGuidePage(json : TJSONWriter; name : string; elem : TFhirImplementationGuidePage; noObj : boolean = false);
    procedure ComposeImplementationGuide(json : TJSONWriter; name : string; elem : TFhirImplementationGuide; noObj : boolean = false);
    procedure ComposeListEntry(json : TJSONWriter; name : string; elem : TFhirListEntry; noObj : boolean = false);
    procedure ComposeList(json : TJSONWriter; name : string; elem : TFhirList; noObj : boolean = false);
    procedure ComposeLocationPosition(json : TJSONWriter; name : string; elem : TFhirLocationPosition; noObj : boolean = false);
    procedure ComposeLocation(json : TJSONWriter; name : string; elem : TFhirLocation; noObj : boolean = false);
    procedure ComposeMedia(json : TJSONWriter; name : string; elem : TFhirMedia; noObj : boolean = false);
    procedure ComposeMedicationProduct(json : TJSONWriter; name : string; elem : TFhirMedicationProduct; noObj : boolean = false);
    procedure ComposeMedicationProductIngredient(json : TJSONWriter; name : string; elem : TFhirMedicationProductIngredient; noObj : boolean = false);
    procedure ComposeMedicationProductBatch(json : TJSONWriter; name : string; elem : TFhirMedicationProductBatch; noObj : boolean = false);
    procedure ComposeMedicationPackage(json : TJSONWriter; name : string; elem : TFhirMedicationPackage; noObj : boolean = false);
    procedure ComposeMedicationPackageContent(json : TJSONWriter; name : string; elem : TFhirMedicationPackageContent; noObj : boolean = false);
    procedure ComposeMedication(json : TJSONWriter; name : string; elem : TFhirMedication; noObj : boolean = false);
    procedure ComposeMedicationAdministrationDosage(json : TJSONWriter; name : string; elem : TFhirMedicationAdministrationDosage; noObj : boolean = false);
    procedure ComposeMedicationAdministration(json : TJSONWriter; name : string; elem : TFhirMedicationAdministration; noObj : boolean = false);
    procedure ComposeMedicationDispenseDosageInstruction(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseDosageInstruction; noObj : boolean = false);
    procedure ComposeMedicationDispenseSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseSubstitution; noObj : boolean = false);
    procedure ComposeMedicationDispense(json : TJSONWriter; name : string; elem : TFhirMedicationDispense; noObj : boolean = false);
    procedure ComposeMedicationOrderDosageInstruction(json : TJSONWriter; name : string; elem : TFhirMedicationOrderDosageInstruction; noObj : boolean = false);
    procedure ComposeMedicationOrderDispenseRequest(json : TJSONWriter; name : string; elem : TFhirMedicationOrderDispenseRequest; noObj : boolean = false);
    procedure ComposeMedicationOrderSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationOrderSubstitution; noObj : boolean = false);
    procedure ComposeMedicationOrder(json : TJSONWriter; name : string; elem : TFhirMedicationOrder; noObj : boolean = false);
    procedure ComposeMedicationStatementDosage(json : TJSONWriter; name : string; elem : TFhirMedicationStatementDosage; noObj : boolean = false);
    procedure ComposeMedicationStatement(json : TJSONWriter; name : string; elem : TFhirMedicationStatement; noObj : boolean = false);
    procedure ComposeMessageHeaderResponse(json : TJSONWriter; name : string; elem : TFhirMessageHeaderResponse; noObj : boolean = false);
    procedure ComposeMessageHeaderSource(json : TJSONWriter; name : string; elem : TFhirMessageHeaderSource; noObj : boolean = false);
    procedure ComposeMessageHeaderDestination(json : TJSONWriter; name : string; elem : TFhirMessageHeaderDestination; noObj : boolean = false);
    procedure ComposeMessageHeader(json : TJSONWriter; name : string; elem : TFhirMessageHeader; noObj : boolean = false);
    procedure ComposeNamingSystemContact(json : TJSONWriter; name : string; elem : TFhirNamingSystemContact; noObj : boolean = false);
    procedure ComposeNamingSystemUniqueId(json : TJSONWriter; name : string; elem : TFhirNamingSystemUniqueId; noObj : boolean = false);
    procedure ComposeNamingSystem(json : TJSONWriter; name : string; elem : TFhirNamingSystem; noObj : boolean = false);
    procedure ComposeNutritionOrderOralDiet(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDiet; noObj : boolean = false);
    procedure ComposeNutritionOrderOralDietNutrient(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDietNutrient; noObj : boolean = false);
    procedure ComposeNutritionOrderOralDietTexture(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDietTexture; noObj : boolean = false);
    procedure ComposeNutritionOrderSupplement(json : TJSONWriter; name : string; elem : TFhirNutritionOrderSupplement; noObj : boolean = false);
    procedure ComposeNutritionOrderEnteralFormula(json : TJSONWriter; name : string; elem : TFhirNutritionOrderEnteralFormula; noObj : boolean = false);
    procedure ComposeNutritionOrderEnteralFormulaAdministration(json : TJSONWriter; name : string; elem : TFhirNutritionOrderEnteralFormulaAdministration; noObj : boolean = false);
    procedure ComposeNutritionOrder(json : TJSONWriter; name : string; elem : TFhirNutritionOrder; noObj : boolean = false);
    procedure ComposeObservationReferenceRange(json : TJSONWriter; name : string; elem : TFhirObservationReferenceRange; noObj : boolean = false);
    procedure ComposeObservationRelated(json : TJSONWriter; name : string; elem : TFhirObservationRelated; noObj : boolean = false);
    procedure ComposeObservationComponent(json : TJSONWriter; name : string; elem : TFhirObservationComponent; noObj : boolean = false);
    procedure ComposeObservation(json : TJSONWriter; name : string; elem : TFhirObservation; noObj : boolean = false);
    procedure ComposeOperationDefinitionContact(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionContact; noObj : boolean = false);
    procedure ComposeOperationDefinitionParameter(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameter; noObj : boolean = false);
    procedure ComposeOperationDefinitionParameterBinding(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameterBinding; noObj : boolean = false);
    procedure ComposeOperationDefinition(json : TJSONWriter; name : string; elem : TFhirOperationDefinition; noObj : boolean = false);
    procedure ComposeOperationOutcomeIssue(json : TJSONWriter; name : string; elem : TFhirOperationOutcomeIssue; noObj : boolean = false);
    procedure ComposeOperationOutcome(json : TJSONWriter; name : string; elem : TFhirOperationOutcome; noObj : boolean = false);
    procedure ComposeOrderWhen(json : TJSONWriter; name : string; elem : TFhirOrderWhen; noObj : boolean = false);
    procedure ComposeOrder(json : TJSONWriter; name : string; elem : TFhirOrder; noObj : boolean = false);
    procedure ComposeOrderResponse(json : TJSONWriter; name : string; elem : TFhirOrderResponse; noObj : boolean = false);
    procedure ComposeOrganizationContact(json : TJSONWriter; name : string; elem : TFhirOrganizationContact; noObj : boolean = false);
    procedure ComposeOrganization(json : TJSONWriter; name : string; elem : TFhirOrganization; noObj : boolean = false);
    procedure ComposePatientContact(json : TJSONWriter; name : string; elem : TFhirPatientContact; noObj : boolean = false);
    procedure ComposePatientAnimal(json : TJSONWriter; name : string; elem : TFhirPatientAnimal; noObj : boolean = false);
    procedure ComposePatientCommunication(json : TJSONWriter; name : string; elem : TFhirPatientCommunication; noObj : boolean = false);
    procedure ComposePatientLink(json : TJSONWriter; name : string; elem : TFhirPatientLink; noObj : boolean = false);
    procedure ComposePatient(json : TJSONWriter; name : string; elem : TFhirPatient; noObj : boolean = false);
    procedure ComposePaymentNotice(json : TJSONWriter; name : string; elem : TFhirPaymentNotice; noObj : boolean = false);
    procedure ComposePaymentReconciliationDetail(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliationDetail; noObj : boolean = false);
    procedure ComposePaymentReconciliationNote(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliationNote; noObj : boolean = false);
    procedure ComposePaymentReconciliation(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliation; noObj : boolean = false);
    procedure ComposePersonLink(json : TJSONWriter; name : string; elem : TFhirPersonLink; noObj : boolean = false);
    procedure ComposePerson(json : TJSONWriter; name : string; elem : TFhirPerson; noObj : boolean = false);
    procedure ComposePractitionerPractitionerRole(json : TJSONWriter; name : string; elem : TFhirPractitionerPractitionerRole; noObj : boolean = false);
    procedure ComposePractitionerQualification(json : TJSONWriter; name : string; elem : TFhirPractitionerQualification; noObj : boolean = false);
    procedure ComposePractitioner(json : TJSONWriter; name : string; elem : TFhirPractitioner; noObj : boolean = false);
    procedure ComposeProcedurePerformer(json : TJSONWriter; name : string; elem : TFhirProcedurePerformer; noObj : boolean = false);
    procedure ComposeProcedureFocalDevice(json : TJSONWriter; name : string; elem : TFhirProcedureFocalDevice; noObj : boolean = false);
    procedure ComposeProcedure(json : TJSONWriter; name : string; elem : TFhirProcedure; noObj : boolean = false);
    procedure ComposeProcedureRequest(json : TJSONWriter; name : string; elem : TFhirProcedureRequest; noObj : boolean = false);
    procedure ComposeProcessRequestItem(json : TJSONWriter; name : string; elem : TFhirProcessRequestItem; noObj : boolean = false);
    procedure ComposeProcessRequest(json : TJSONWriter; name : string; elem : TFhirProcessRequest; noObj : boolean = false);
    procedure ComposeProcessResponseNotes(json : TJSONWriter; name : string; elem : TFhirProcessResponseNotes; noObj : boolean = false);
    procedure ComposeProcessResponse(json : TJSONWriter; name : string; elem : TFhirProcessResponse; noObj : boolean = false);
    procedure ComposeProvenanceAgent(json : TJSONWriter; name : string; elem : TFhirProvenanceAgent; noObj : boolean = false);
    procedure ComposeProvenanceAgentRelatedAgent(json : TJSONWriter; name : string; elem : TFhirProvenanceAgentRelatedAgent; noObj : boolean = false);
    procedure ComposeProvenanceEntity(json : TJSONWriter; name : string; elem : TFhirProvenanceEntity; noObj : boolean = false);
    procedure ComposeProvenance(json : TJSONWriter; name : string; elem : TFhirProvenance; noObj : boolean = false);
    procedure ComposeQuestionnaireGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroup; noObj : boolean = false);
    procedure ComposeQuestionnaireGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroupQuestion; noObj : boolean = false);
    procedure ComposeQuestionnaire(json : TJSONWriter; name : string; elem : TFhirQuestionnaire; noObj : boolean = false);
    procedure ComposeQuestionnaireResponseGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponseGroup; noObj : boolean = false);
    procedure ComposeQuestionnaireResponseGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponseGroupQuestion; noObj : boolean = false);
    procedure ComposeQuestionnaireResponseGroupQuestionAnswer(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponseGroupQuestionAnswer; noObj : boolean = false);
    procedure ComposeQuestionnaireResponse(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponse; noObj : boolean = false);
    procedure ComposeReferralRequest(json : TJSONWriter; name : string; elem : TFhirReferralRequest; noObj : boolean = false);
    procedure ComposeRelatedPerson(json : TJSONWriter; name : string; elem : TFhirRelatedPerson; noObj : boolean = false);
    procedure ComposeRiskAssessmentPrediction(json : TJSONWriter; name : string; elem : TFhirRiskAssessmentPrediction; noObj : boolean = false);
    procedure ComposeRiskAssessment(json : TJSONWriter; name : string; elem : TFhirRiskAssessment; noObj : boolean = false);
    procedure ComposeSchedule(json : TJSONWriter; name : string; elem : TFhirSchedule; noObj : boolean = false);
    procedure ComposeSearchParameterContact(json : TJSONWriter; name : string; elem : TFhirSearchParameterContact; noObj : boolean = false);
    procedure ComposeSearchParameter(json : TJSONWriter; name : string; elem : TFhirSearchParameter; noObj : boolean = false);
    procedure ComposeSlot(json : TJSONWriter; name : string; elem : TFhirSlot; noObj : boolean = false);
    procedure ComposeSpecimenCollection(json : TJSONWriter; name : string; elem : TFhirSpecimenCollection; noObj : boolean = false);
    procedure ComposeSpecimenTreatment(json : TJSONWriter; name : string; elem : TFhirSpecimenTreatment; noObj : boolean = false);
    procedure ComposeSpecimenContainer(json : TJSONWriter; name : string; elem : TFhirSpecimenContainer; noObj : boolean = false);
    procedure ComposeSpecimen(json : TJSONWriter; name : string; elem : TFhirSpecimen; noObj : boolean = false);
    procedure ComposeStructureDefinitionContact(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionContact; noObj : boolean = false);
    procedure ComposeStructureDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionMapping; noObj : boolean = false);
    procedure ComposeStructureDefinitionSnapshot(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionSnapshot; noObj : boolean = false);
    procedure ComposeStructureDefinitionDifferential(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionDifferential; noObj : boolean = false);
    procedure ComposeStructureDefinition(json : TJSONWriter; name : string; elem : TFhirStructureDefinition; noObj : boolean = false);
    procedure ComposeSubscriptionChannel(json : TJSONWriter; name : string; elem : TFhirSubscriptionChannel; noObj : boolean = false);
    procedure ComposeSubscription(json : TJSONWriter; name : string; elem : TFhirSubscription; noObj : boolean = false);
    procedure ComposeSubstanceInstance(json : TJSONWriter; name : string; elem : TFhirSubstanceInstance; noObj : boolean = false);
    procedure ComposeSubstanceIngredient(json : TJSONWriter; name : string; elem : TFhirSubstanceIngredient; noObj : boolean = false);
    procedure ComposeSubstance(json : TJSONWriter; name : string; elem : TFhirSubstance; noObj : boolean = false);
    procedure ComposeSupplyDelivery(json : TJSONWriter; name : string; elem : TFhirSupplyDelivery; noObj : boolean = false);
    procedure ComposeSupplyRequestWhen(json : TJSONWriter; name : string; elem : TFhirSupplyRequestWhen; noObj : boolean = false);
    procedure ComposeSupplyRequest(json : TJSONWriter; name : string; elem : TFhirSupplyRequest; noObj : boolean = false);
    procedure ComposeTestScriptContact(json : TJSONWriter; name : string; elem : TFhirTestScriptContact; noObj : boolean = false);
    procedure ComposeTestScriptMetadata(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadata; noObj : boolean = false);
    procedure ComposeTestScriptMetadataLink(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadataLink; noObj : boolean = false);
    procedure ComposeTestScriptMetadataCapability(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadataCapability; noObj : boolean = false);
    procedure ComposeTestScriptFixture(json : TJSONWriter; name : string; elem : TFhirTestScriptFixture; noObj : boolean = false);
    procedure ComposeTestScriptVariable(json : TJSONWriter; name : string; elem : TFhirTestScriptVariable; noObj : boolean = false);
    procedure ComposeTestScriptSetup(json : TJSONWriter; name : string; elem : TFhirTestScriptSetup; noObj : boolean = false);
    procedure ComposeTestScriptSetupAction(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupAction; noObj : boolean = false);
    procedure ComposeTestScriptSetupActionOperation(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionOperation; noObj : boolean = false);
    procedure ComposeTestScriptSetupActionOperationRequestHeader(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionOperationRequestHeader; noObj : boolean = false);
    procedure ComposeTestScriptSetupActionAssert(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionAssert; noObj : boolean = false);
    procedure ComposeTestScriptTest(json : TJSONWriter; name : string; elem : TFhirTestScriptTest; noObj : boolean = false);
    procedure ComposeTestScriptTestAction(json : TJSONWriter; name : string; elem : TFhirTestScriptTestAction; noObj : boolean = false);
    procedure ComposeTestScriptTeardown(json : TJSONWriter; name : string; elem : TFhirTestScriptTeardown; noObj : boolean = false);
    procedure ComposeTestScriptTeardownAction(json : TJSONWriter; name : string; elem : TFhirTestScriptTeardownAction; noObj : boolean = false);
    procedure ComposeTestScript(json : TJSONWriter; name : string; elem : TFhirTestScript; noObj : boolean = false);
    procedure ComposeValueSetContact(json : TJSONWriter; name : string; elem : TFhirValueSetContact; noObj : boolean = false);
    procedure ComposeValueSetCodeSystem(json : TJSONWriter; name : string; elem : TFhirValueSetCodeSystem; noObj : boolean = false);
    procedure ComposeValueSetCodeSystemConcept(json : TJSONWriter; name : string; elem : TFhirValueSetCodeSystemConcept; noObj : boolean = false);
    procedure ComposeValueSetCodeSystemConceptDesignation(json : TJSONWriter; name : string; elem : TFhirValueSetCodeSystemConceptDesignation; noObj : boolean = false);
    procedure ComposeValueSetCompose(json : TJSONWriter; name : string; elem : TFhirValueSetCompose; noObj : boolean = false);
    procedure ComposeValueSetComposeInclude(json : TJSONWriter; name : string; elem : TFhirValueSetComposeInclude; noObj : boolean = false);
    procedure ComposeValueSetComposeIncludeConcept(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeConcept; noObj : boolean = false);
    procedure ComposeValueSetComposeIncludeFilter(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeFilter; noObj : boolean = false);
    procedure ComposeValueSetExpansion(json : TJSONWriter; name : string; elem : TFhirValueSetExpansion; noObj : boolean = false);
    procedure ComposeValueSetExpansionParameter(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionParameter; noObj : boolean = false);
    procedure ComposeValueSetExpansionContains(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionContains; noObj : boolean = false);
    procedure ComposeValueSet(json : TJSONWriter; name : string; elem : TFhirValueSet; noObj : boolean = false);
    procedure ComposeVisionPrescriptionDispense(json : TJSONWriter; name : string; elem : TFhirVisionPrescriptionDispense; noObj : boolean = false);
    procedure ComposeVisionPrescription(json : TJSONWriter; name : string; elem : TFhirVisionPrescription; noObj : boolean = false);
    procedure ComposeResource(json : TJSONWriter; resource : TFhirResource; links : TFhirBundleLinkList); override;
    procedure ComposeBase(json : TJSONWriter; name : String; base : TFHIRBase); override;
  end;

  TFHIRRDFComposer = class (TFHIRRDFComposerBase)
  protected
    procedure ComposeElement(parent :  TRDFComplex; parentType, name : String; elem : TFhirElement; index : integer);
    procedure ComposeBackboneElement(parent :  TRDFComplex; parentType, name : String; elem : TFhirBackboneElement; index : integer);


    Procedure ComposeEnum(parent :  TRDFComplex; parentType, name : String; value : TFhirEnum; Const aNames, aSystems : Array Of String; index : integer);
    Procedure ComposeInteger(parent :  TRDFComplex; parentType, name : String; value : TFhirInteger; index : integer);
    Procedure ComposeDateTime(parent :  TRDFComplex; parentType, name : String; value : TFhirDateTime; index : integer);
    Procedure ComposeDate(parent :  TRDFComplex; parentType, name : String; value : TFhirDate; index : integer);
    Procedure ComposeDecimal(parent :  TRDFComplex; parentType, name : String; value : TFhirDecimal; index : integer);
    Procedure ComposeUri(parent :  TRDFComplex; parentType, name : String; value : TFhirUri; index : integer);
    Procedure ComposeBase64Binary(parent :  TRDFComplex; parentType, name : String; value : TFhirBase64Binary; index : integer);
    Procedure ComposeTime(parent :  TRDFComplex; parentType, name : String; value : TFhirTime; index : integer);
    Procedure ComposeString(parent :  TRDFComplex; parentType, name : String; value : TFhirString; index : integer);
    Procedure ComposeBoolean(parent :  TRDFComplex; parentType, name : String; value : TFhirBoolean; index : integer);
    Procedure ComposeInstant(parent :  TRDFComplex; parentType, name : String; value : TFhirInstant; index : integer);
    Procedure ComposeMarkdown(parent :  TRDFComplex; parentType, name : String; value : TFhirMarkdown; index : integer);
    Procedure ComposeUnsignedInt(parent :  TRDFComplex; parentType, name : String; value : TFhirUnsignedInt; index : integer);
    Procedure ComposeCode(parent :  TRDFComplex; parentType, name : String; value : TFhirCode; index : integer);
    Procedure ComposeId(parent :  TRDFComplex; parentType, name : String; value : TFhirId; index : integer);
    Procedure ComposeOid(parent :  TRDFComplex; parentType, name : String; value : TFhirOid; index : integer);
    Procedure ComposePositiveInt(parent :  TRDFComplex; parentType, name : String; value : TFhirPositiveInt; index : integer);
    Procedure ComposeUuid(parent :  TRDFComplex; parentType, name : String; value : TFhirUuid; index : integer);


    Procedure ComposeResource(this : TRDFComplex; parentType, name : String; elem : TFhirResource; index : integer); overload;
    Procedure ComposeDomainResource(this : TRDFComplex; parentType, name : String; elem : TFhirDomainResource; index : integer); overload;
    procedure ComposeParametersParameter(parent :  TRDFComplex; parentType, name : String; elem : TFhirParametersParameter; index : integer);
    procedure ComposeParameters(parent :  TRDFComplex; parentType, name : String; elem : TFhirParameters; index : integer);


    procedure ComposeExtension(parent :  TRDFComplex; parentType, name : String; elem : TFhirExtension; index : integer);
    procedure ComposeNarrative(parent :  TRDFComplex; parentType, name : String; elem : TFhirNarrative; index : integer);
    procedure ComposePeriod(parent :  TRDFComplex; parentType, name : String; elem : TFhirPeriod; index : integer);
    procedure ComposeCoding(inCodeable : boolean; parent :  TRDFComplex; parentType, name : String; elem : TFhirCoding; index : integer);
    procedure ComposeRange(parent :  TRDFComplex; parentType, name : String; elem : TFhirRange; index : integer);
    procedure ComposeAttachment(parent :  TRDFComplex; parentType, name : String; elem : TFhirAttachment; index : integer);
    procedure ComposeQuantity(parent :  TRDFComplex; parentType, name : String; elem : TFhirQuantity; index : integer);
    procedure ComposeAnnotation(parent :  TRDFComplex; parentType, name : String; elem : TFhirAnnotation; index : integer);
    procedure ComposeRatio(parent :  TRDFComplex; parentType, name : String; elem : TFhirRatio; index : integer);
    procedure ComposeSampledData(parent :  TRDFComplex; parentType, name : String; elem : TFhirSampledData; index : integer);
    procedure ComposeCodeableConcept(parent :  TRDFComplex; parentType, name : String; elem : TFhirCodeableConcept; index : integer);
    procedure ComposeReference(parent :  TRDFComplex; parentType, name : String; elem : TFhirReference; index : integer);
    procedure ComposeIdentifier(parent :  TRDFComplex; parentType, name : String; elem : TFhirIdentifier; index : integer);
    procedure ComposeSignature(parent :  TRDFComplex; parentType, name : String; elem : TFhirSignature; index : integer);
    procedure ComposeTimingRepeat(parent :  TRDFComplex; parentType, name : String; elem : TFhirTimingRepeat; index : integer);
    procedure ComposeTiming(parent :  TRDFComplex; parentType, name : String; elem : TFhirTiming; index : integer);
    procedure ComposeElementDefinitionSlicing(parent :  TRDFComplex; parentType, name : String; elem : TFhirElementDefinitionSlicing; index : integer);
    procedure ComposeElementDefinitionBase(parent :  TRDFComplex; parentType, name : String; elem : TFhirElementDefinitionBase; index : integer);
    procedure ComposeElementDefinitionType(parent :  TRDFComplex; parentType, name : String; elem : TFhirElementDefinitionType; index : integer);
    procedure ComposeElementDefinitionConstraint(parent :  TRDFComplex; parentType, name : String; elem : TFhirElementDefinitionConstraint; index : integer);
    procedure ComposeElementDefinitionBinding(parent :  TRDFComplex; parentType, name : String; elem : TFhirElementDefinitionBinding; index : integer);
    procedure ComposeElementDefinitionMapping(parent :  TRDFComplex; parentType, name : String; elem : TFhirElementDefinitionMapping; index : integer);
    procedure ComposeElementDefinition(parent :  TRDFComplex; parentType, name : String; elem : TFhirElementDefinition; index : integer);
    procedure ComposeHumanName(parent :  TRDFComplex; parentType, name : String; elem : TFhirHumanName; index : integer);
    procedure ComposeAddress(parent :  TRDFComplex; parentType, name : String; elem : TFhirAddress; index : integer);
    procedure ComposeMeta(parent :  TRDFComplex; parentType, name : String; elem : TFhirMeta; index : integer);
    procedure ComposeContactPoint(parent :  TRDFComplex; parentType, name : String; elem : TFhirContactPoint; index : integer);


    procedure ComposeAccount(parent :  TRDFComplex; parentType, name : String; elem : TFhirAccount; index : integer);
    procedure ComposeAllergyIntoleranceReaction(parent :  TRDFComplex; parentType, name : String; elem : TFhirAllergyIntoleranceReaction; index : integer);
    procedure ComposeAllergyIntolerance(parent :  TRDFComplex; parentType, name : String; elem : TFhirAllergyIntolerance; index : integer);
    procedure ComposeAppointmentParticipant(parent :  TRDFComplex; parentType, name : String; elem : TFhirAppointmentParticipant; index : integer);
    procedure ComposeAppointment(parent :  TRDFComplex; parentType, name : String; elem : TFhirAppointment; index : integer);
    procedure ComposeAppointmentResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirAppointmentResponse; index : integer);
    procedure ComposeAuditEventEvent(parent :  TRDFComplex; parentType, name : String; elem : TFhirAuditEventEvent; index : integer);
    procedure ComposeAuditEventParticipant(parent :  TRDFComplex; parentType, name : String; elem : TFhirAuditEventParticipant; index : integer);
    procedure ComposeAuditEventParticipantNetwork(parent :  TRDFComplex; parentType, name : String; elem : TFhirAuditEventParticipantNetwork; index : integer);
    procedure ComposeAuditEventSource(parent :  TRDFComplex; parentType, name : String; elem : TFhirAuditEventSource; index : integer);
    procedure ComposeAuditEventObject(parent :  TRDFComplex; parentType, name : String; elem : TFhirAuditEventObject; index : integer);
    procedure ComposeAuditEventObjectDetail(parent :  TRDFComplex; parentType, name : String; elem : TFhirAuditEventObjectDetail; index : integer);
    procedure ComposeAuditEvent(parent :  TRDFComplex; parentType, name : String; elem : TFhirAuditEvent; index : integer);
    procedure ComposeBasic(parent :  TRDFComplex; parentType, name : String; elem : TFhirBasic; index : integer);
    procedure ComposeBinary(parent :  TRDFComplex; parentType, name : String; elem : TFhirBinary; index : integer);
    procedure ComposeBodySite(parent :  TRDFComplex; parentType, name : String; elem : TFhirBodySite; index : integer);
    procedure ComposeBundleLink(parent :  TRDFComplex; parentType, name : String; elem : TFhirBundleLink; index : integer);
    procedure ComposeBundleEntry(parent :  TRDFComplex; parentType, name : String; elem : TFhirBundleEntry; index : integer);
    procedure ComposeBundleEntrySearch(parent :  TRDFComplex; parentType, name : String; elem : TFhirBundleEntrySearch; index : integer);
    procedure ComposeBundleEntryRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirBundleEntryRequest; index : integer);
    procedure ComposeBundleEntryResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirBundleEntryResponse; index : integer);
    procedure ComposeBundle(parent :  TRDFComplex; parentType, name : String; elem : TFhirBundle; index : integer);
    procedure ComposeCarePlanRelatedPlan(parent :  TRDFComplex; parentType, name : String; elem : TFhirCarePlanRelatedPlan; index : integer);
    procedure ComposeCarePlanParticipant(parent :  TRDFComplex; parentType, name : String; elem : TFhirCarePlanParticipant; index : integer);
    procedure ComposeCarePlanActivity(parent :  TRDFComplex; parentType, name : String; elem : TFhirCarePlanActivity; index : integer);
    procedure ComposeCarePlanActivityDetail(parent :  TRDFComplex; parentType, name : String; elem : TFhirCarePlanActivityDetail; index : integer);
    procedure ComposeCarePlan(parent :  TRDFComplex; parentType, name : String; elem : TFhirCarePlan; index : integer);
    procedure ComposeClaimPayee(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimPayee; index : integer);
    procedure ComposeClaimDiagnosis(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimDiagnosis; index : integer);
    procedure ComposeClaimCoverage(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimCoverage; index : integer);
    procedure ComposeClaimItem(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimItem; index : integer);
    procedure ComposeClaimItemDetail(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimItemDetail; index : integer);
    procedure ComposeClaimItemDetailSubDetail(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimItemDetailSubDetail; index : integer);
    procedure ComposeClaimItemProsthesis(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimItemProsthesis; index : integer);
    procedure ComposeClaimMissingTeeth(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimMissingTeeth; index : integer);
    procedure ComposeClaim(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaim; index : integer);
    procedure ComposeClaimResponseItem(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseItem; index : integer);
    procedure ComposeClaimResponseItemAdjudication(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseItemAdjudication; index : integer);
    procedure ComposeClaimResponseItemDetail(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseItemDetail; index : integer);
    procedure ComposeClaimResponseItemDetailAdjudication(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseItemDetailAdjudication; index : integer);
    procedure ComposeClaimResponseItemDetailSubDetail(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseItemDetailSubDetail; index : integer);
    procedure ComposeClaimResponseItemDetailSubDetailAdjudication(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseItemDetailSubDetailAdjudication; index : integer);
    procedure ComposeClaimResponseAddItem(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseAddItem; index : integer);
    procedure ComposeClaimResponseAddItemAdjudication(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseAddItemAdjudication; index : integer);
    procedure ComposeClaimResponseAddItemDetail(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseAddItemDetail; index : integer);
    procedure ComposeClaimResponseAddItemDetailAdjudication(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseAddItemDetailAdjudication; index : integer);
    procedure ComposeClaimResponseError(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseError; index : integer);
    procedure ComposeClaimResponseNote(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseNote; index : integer);
    procedure ComposeClaimResponseCoverage(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseCoverage; index : integer);
    procedure ComposeClaimResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponse; index : integer);
    procedure ComposeClinicalImpressionInvestigations(parent :  TRDFComplex; parentType, name : String; elem : TFhirClinicalImpressionInvestigations; index : integer);
    procedure ComposeClinicalImpressionFinding(parent :  TRDFComplex; parentType, name : String; elem : TFhirClinicalImpressionFinding; index : integer);
    procedure ComposeClinicalImpressionRuledOut(parent :  TRDFComplex; parentType, name : String; elem : TFhirClinicalImpressionRuledOut; index : integer);
    procedure ComposeClinicalImpression(parent :  TRDFComplex; parentType, name : String; elem : TFhirClinicalImpression; index : integer);
    procedure ComposeCommunicationPayload(parent :  TRDFComplex; parentType, name : String; elem : TFhirCommunicationPayload; index : integer);
    procedure ComposeCommunication(parent :  TRDFComplex; parentType, name : String; elem : TFhirCommunication; index : integer);
    procedure ComposeCommunicationRequestPayload(parent :  TRDFComplex; parentType, name : String; elem : TFhirCommunicationRequestPayload; index : integer);
    procedure ComposeCommunicationRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirCommunicationRequest; index : integer);
    procedure ComposeCompositionAttester(parent :  TRDFComplex; parentType, name : String; elem : TFhirCompositionAttester; index : integer);
    procedure ComposeCompositionEvent(parent :  TRDFComplex; parentType, name : String; elem : TFhirCompositionEvent; index : integer);
    procedure ComposeCompositionSection(parent :  TRDFComplex; parentType, name : String; elem : TFhirCompositionSection; index : integer);
    procedure ComposeComposition(parent :  TRDFComplex; parentType, name : String; elem : TFhirComposition; index : integer);
    procedure ComposeConceptMapContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirConceptMapContact; index : integer);
    procedure ComposeConceptMapElement(parent :  TRDFComplex; parentType, name : String; elem : TFhirConceptMapElement; index : integer);
    procedure ComposeConceptMapElementTarget(parent :  TRDFComplex; parentType, name : String; elem : TFhirConceptMapElementTarget; index : integer);
    procedure ComposeConceptMapElementTargetDependsOn(parent :  TRDFComplex; parentType, name : String; elem : TFhirConceptMapElementTargetDependsOn; index : integer);
    procedure ComposeConceptMap(parent :  TRDFComplex; parentType, name : String; elem : TFhirConceptMap; index : integer);
    procedure ComposeConditionStage(parent :  TRDFComplex; parentType, name : String; elem : TFhirConditionStage; index : integer);
    procedure ComposeConditionEvidence(parent :  TRDFComplex; parentType, name : String; elem : TFhirConditionEvidence; index : integer);
    procedure ComposeCondition(parent :  TRDFComplex; parentType, name : String; elem : TFhirCondition; index : integer);
    procedure ComposeConformanceContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceContact; index : integer);
    procedure ComposeConformanceSoftware(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceSoftware; index : integer);
    procedure ComposeConformanceImplementation(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceImplementation; index : integer);
    procedure ComposeConformanceRest(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceRest; index : integer);
    procedure ComposeConformanceRestSecurity(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceRestSecurity; index : integer);
    procedure ComposeConformanceRestSecurityCertificate(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceRestSecurityCertificate; index : integer);
    procedure ComposeConformanceRestResource(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceRestResource; index : integer);
    procedure ComposeConformanceRestResourceInteraction(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceRestResourceInteraction; index : integer);
    procedure ComposeConformanceRestResourceSearchParam(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceRestResourceSearchParam; index : integer);
    procedure ComposeConformanceRestInteraction(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceRestInteraction; index : integer);
    procedure ComposeConformanceRestOperation(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceRestOperation; index : integer);
    procedure ComposeConformanceMessaging(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceMessaging; index : integer);
    procedure ComposeConformanceMessagingEndpoint(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceMessagingEndpoint; index : integer);
    procedure ComposeConformanceMessagingEvent(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceMessagingEvent; index : integer);
    procedure ComposeConformanceDocument(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceDocument; index : integer);
    procedure ComposeConformance(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformance; index : integer);
    procedure ComposeContractActor(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractActor; index : integer);
    procedure ComposeContractValuedItem(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractValuedItem; index : integer);
    procedure ComposeContractSigner(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractSigner; index : integer);
    procedure ComposeContractTerm(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractTerm; index : integer);
    procedure ComposeContractTermActor(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractTermActor; index : integer);
    procedure ComposeContractTermValuedItem(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractTermValuedItem; index : integer);
    procedure ComposeContractFriendly(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractFriendly; index : integer);
    procedure ComposeContractLegal(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractLegal; index : integer);
    procedure ComposeContractRule(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractRule; index : integer);
    procedure ComposeContract(parent :  TRDFComplex; parentType, name : String; elem : TFhirContract; index : integer);
    procedure ComposeCoverage(parent :  TRDFComplex; parentType, name : String; elem : TFhirCoverage; index : integer);
    procedure ComposeDataElementContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirDataElementContact; index : integer);
    procedure ComposeDataElementMapping(parent :  TRDFComplex; parentType, name : String; elem : TFhirDataElementMapping; index : integer);
    procedure ComposeDataElement(parent :  TRDFComplex; parentType, name : String; elem : TFhirDataElement; index : integer);
    procedure ComposeDetectedIssueMitigation(parent :  TRDFComplex; parentType, name : String; elem : TFhirDetectedIssueMitigation; index : integer);
    procedure ComposeDetectedIssue(parent :  TRDFComplex; parentType, name : String; elem : TFhirDetectedIssue; index : integer);
    procedure ComposeDevice(parent :  TRDFComplex; parentType, name : String; elem : TFhirDevice; index : integer);
    procedure ComposeDeviceComponentProductionSpecification(parent :  TRDFComplex; parentType, name : String; elem : TFhirDeviceComponentProductionSpecification; index : integer);
    procedure ComposeDeviceComponent(parent :  TRDFComplex; parentType, name : String; elem : TFhirDeviceComponent; index : integer);
    procedure ComposeDeviceMetricCalibration(parent :  TRDFComplex; parentType, name : String; elem : TFhirDeviceMetricCalibration; index : integer);
    procedure ComposeDeviceMetric(parent :  TRDFComplex; parentType, name : String; elem : TFhirDeviceMetric; index : integer);
    procedure ComposeDeviceUseRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirDeviceUseRequest; index : integer);
    procedure ComposeDeviceUseStatement(parent :  TRDFComplex; parentType, name : String; elem : TFhirDeviceUseStatement; index : integer);
    procedure ComposeDiagnosticOrderEvent(parent :  TRDFComplex; parentType, name : String; elem : TFhirDiagnosticOrderEvent; index : integer);
    procedure ComposeDiagnosticOrderItem(parent :  TRDFComplex; parentType, name : String; elem : TFhirDiagnosticOrderItem; index : integer);
    procedure ComposeDiagnosticOrder(parent :  TRDFComplex; parentType, name : String; elem : TFhirDiagnosticOrder; index : integer);
    procedure ComposeDiagnosticReportImage(parent :  TRDFComplex; parentType, name : String; elem : TFhirDiagnosticReportImage; index : integer);
    procedure ComposeDiagnosticReport(parent :  TRDFComplex; parentType, name : String; elem : TFhirDiagnosticReport; index : integer);
    procedure ComposeDocumentManifestContent(parent :  TRDFComplex; parentType, name : String; elem : TFhirDocumentManifestContent; index : integer);
    procedure ComposeDocumentManifestRelated(parent :  TRDFComplex; parentType, name : String; elem : TFhirDocumentManifestRelated; index : integer);
    procedure ComposeDocumentManifest(parent :  TRDFComplex; parentType, name : String; elem : TFhirDocumentManifest; index : integer);
    procedure ComposeDocumentReferenceRelatesTo(parent :  TRDFComplex; parentType, name : String; elem : TFhirDocumentReferenceRelatesTo; index : integer);
    procedure ComposeDocumentReferenceContent(parent :  TRDFComplex; parentType, name : String; elem : TFhirDocumentReferenceContent; index : integer);
    procedure ComposeDocumentReferenceContext(parent :  TRDFComplex; parentType, name : String; elem : TFhirDocumentReferenceContext; index : integer);
    procedure ComposeDocumentReferenceContextRelated(parent :  TRDFComplex; parentType, name : String; elem : TFhirDocumentReferenceContextRelated; index : integer);
    procedure ComposeDocumentReference(parent :  TRDFComplex; parentType, name : String; elem : TFhirDocumentReference; index : integer);
    procedure ComposeEligibilityRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirEligibilityRequest; index : integer);
    procedure ComposeEligibilityResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirEligibilityResponse; index : integer);
    procedure ComposeEncounterStatusHistory(parent :  TRDFComplex; parentType, name : String; elem : TFhirEncounterStatusHistory; index : integer);
    procedure ComposeEncounterParticipant(parent :  TRDFComplex; parentType, name : String; elem : TFhirEncounterParticipant; index : integer);
    procedure ComposeEncounterHospitalization(parent :  TRDFComplex; parentType, name : String; elem : TFhirEncounterHospitalization; index : integer);
    procedure ComposeEncounterLocation(parent :  TRDFComplex; parentType, name : String; elem : TFhirEncounterLocation; index : integer);
    procedure ComposeEncounter(parent :  TRDFComplex; parentType, name : String; elem : TFhirEncounter; index : integer);
    procedure ComposeEnrollmentRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirEnrollmentRequest; index : integer);
    procedure ComposeEnrollmentResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirEnrollmentResponse; index : integer);
    procedure ComposeEpisodeOfCareStatusHistory(parent :  TRDFComplex; parentType, name : String; elem : TFhirEpisodeOfCareStatusHistory; index : integer);
    procedure ComposeEpisodeOfCareCareTeam(parent :  TRDFComplex; parentType, name : String; elem : TFhirEpisodeOfCareCareTeam; index : integer);
    procedure ComposeEpisodeOfCare(parent :  TRDFComplex; parentType, name : String; elem : TFhirEpisodeOfCare; index : integer);
    procedure ComposeExplanationOfBenefit(parent :  TRDFComplex; parentType, name : String; elem : TFhirExplanationOfBenefit; index : integer);
    procedure ComposeFamilyMemberHistoryCondition(parent :  TRDFComplex; parentType, name : String; elem : TFhirFamilyMemberHistoryCondition; index : integer);
    procedure ComposeFamilyMemberHistory(parent :  TRDFComplex; parentType, name : String; elem : TFhirFamilyMemberHistory; index : integer);
    procedure ComposeFlag(parent :  TRDFComplex; parentType, name : String; elem : TFhirFlag; index : integer);
    procedure ComposeGoalOutcome(parent :  TRDFComplex; parentType, name : String; elem : TFhirGoalOutcome; index : integer);
    procedure ComposeGoal(parent :  TRDFComplex; parentType, name : String; elem : TFhirGoal; index : integer);
    procedure ComposeGroupCharacteristic(parent :  TRDFComplex; parentType, name : String; elem : TFhirGroupCharacteristic; index : integer);
    procedure ComposeGroupMember(parent :  TRDFComplex; parentType, name : String; elem : TFhirGroupMember; index : integer);
    procedure ComposeGroup(parent :  TRDFComplex; parentType, name : String; elem : TFhirGroup; index : integer);
    procedure ComposeHealthcareServiceServiceType(parent :  TRDFComplex; parentType, name : String; elem : TFhirHealthcareServiceServiceType; index : integer);
    procedure ComposeHealthcareServiceAvailableTime(parent :  TRDFComplex; parentType, name : String; elem : TFhirHealthcareServiceAvailableTime; index : integer);
    procedure ComposeHealthcareServiceNotAvailable(parent :  TRDFComplex; parentType, name : String; elem : TFhirHealthcareServiceNotAvailable; index : integer);
    procedure ComposeHealthcareService(parent :  TRDFComplex; parentType, name : String; elem : TFhirHealthcareService; index : integer);
    procedure ComposeImagingObjectSelectionStudy(parent :  TRDFComplex; parentType, name : String; elem : TFhirImagingObjectSelectionStudy; index : integer);
    procedure ComposeImagingObjectSelectionStudySeries(parent :  TRDFComplex; parentType, name : String; elem : TFhirImagingObjectSelectionStudySeries; index : integer);
    procedure ComposeImagingObjectSelectionStudySeriesInstance(parent :  TRDFComplex; parentType, name : String; elem : TFhirImagingObjectSelectionStudySeriesInstance; index : integer);
    procedure ComposeImagingObjectSelectionStudySeriesInstanceFrames(parent :  TRDFComplex; parentType, name : String; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames; index : integer);
    procedure ComposeImagingObjectSelection(parent :  TRDFComplex; parentType, name : String; elem : TFhirImagingObjectSelection; index : integer);
    procedure ComposeImagingStudySeries(parent :  TRDFComplex; parentType, name : String; elem : TFhirImagingStudySeries; index : integer);
    procedure ComposeImagingStudySeriesInstance(parent :  TRDFComplex; parentType, name : String; elem : TFhirImagingStudySeriesInstance; index : integer);
    procedure ComposeImagingStudy(parent :  TRDFComplex; parentType, name : String; elem : TFhirImagingStudy; index : integer);
    procedure ComposeImmunizationExplanation(parent :  TRDFComplex; parentType, name : String; elem : TFhirImmunizationExplanation; index : integer);
    procedure ComposeImmunizationReaction(parent :  TRDFComplex; parentType, name : String; elem : TFhirImmunizationReaction; index : integer);
    procedure ComposeImmunizationVaccinationProtocol(parent :  TRDFComplex; parentType, name : String; elem : TFhirImmunizationVaccinationProtocol; index : integer);
    procedure ComposeImmunization(parent :  TRDFComplex; parentType, name : String; elem : TFhirImmunization; index : integer);
    procedure ComposeImmunizationRecommendationRecommendation(parent :  TRDFComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendation; index : integer);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(parent :  TRDFComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendationDateCriterion; index : integer);
    procedure ComposeImmunizationRecommendationRecommendationProtocol(parent :  TRDFComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendationProtocol; index : integer);
    procedure ComposeImmunizationRecommendation(parent :  TRDFComplex; parentType, name : String; elem : TFhirImmunizationRecommendation; index : integer);
    procedure ComposeImplementationGuideContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirImplementationGuideContact; index : integer);
    procedure ComposeImplementationGuideDependency(parent :  TRDFComplex; parentType, name : String; elem : TFhirImplementationGuideDependency; index : integer);
    procedure ComposeImplementationGuidePackage(parent :  TRDFComplex; parentType, name : String; elem : TFhirImplementationGuidePackage; index : integer);
    procedure ComposeImplementationGuidePackageResource(parent :  TRDFComplex; parentType, name : String; elem : TFhirImplementationGuidePackageResource; index : integer);
    procedure ComposeImplementationGuideGlobal(parent :  TRDFComplex; parentType, name : String; elem : TFhirImplementationGuideGlobal; index : integer);
    procedure ComposeImplementationGuidePage(parent :  TRDFComplex; parentType, name : String; elem : TFhirImplementationGuidePage; index : integer);
    procedure ComposeImplementationGuide(parent :  TRDFComplex; parentType, name : String; elem : TFhirImplementationGuide; index : integer);
    procedure ComposeListEntry(parent :  TRDFComplex; parentType, name : String; elem : TFhirListEntry; index : integer);
    procedure ComposeList(parent :  TRDFComplex; parentType, name : String; elem : TFhirList; index : integer);
    procedure ComposeLocationPosition(parent :  TRDFComplex; parentType, name : String; elem : TFhirLocationPosition; index : integer);
    procedure ComposeLocation(parent :  TRDFComplex; parentType, name : String; elem : TFhirLocation; index : integer);
    procedure ComposeMedia(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedia; index : integer);
    procedure ComposeMedicationProduct(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationProduct; index : integer);
    procedure ComposeMedicationProductIngredient(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationProductIngredient; index : integer);
    procedure ComposeMedicationProductBatch(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationProductBatch; index : integer);
    procedure ComposeMedicationPackage(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationPackage; index : integer);
    procedure ComposeMedicationPackageContent(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationPackageContent; index : integer);
    procedure ComposeMedication(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedication; index : integer);
    procedure ComposeMedicationAdministrationDosage(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationAdministrationDosage; index : integer);
    procedure ComposeMedicationAdministration(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationAdministration; index : integer);
    procedure ComposeMedicationDispenseDosageInstruction(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationDispenseDosageInstruction; index : integer);
    procedure ComposeMedicationDispenseSubstitution(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationDispenseSubstitution; index : integer);
    procedure ComposeMedicationDispense(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationDispense; index : integer);
    procedure ComposeMedicationOrderDosageInstruction(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationOrderDosageInstruction; index : integer);
    procedure ComposeMedicationOrderDispenseRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationOrderDispenseRequest; index : integer);
    procedure ComposeMedicationOrderSubstitution(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationOrderSubstitution; index : integer);
    procedure ComposeMedicationOrder(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationOrder; index : integer);
    procedure ComposeMedicationStatementDosage(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationStatementDosage; index : integer);
    procedure ComposeMedicationStatement(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationStatement; index : integer);
    procedure ComposeMessageHeaderResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirMessageHeaderResponse; index : integer);
    procedure ComposeMessageHeaderSource(parent :  TRDFComplex; parentType, name : String; elem : TFhirMessageHeaderSource; index : integer);
    procedure ComposeMessageHeaderDestination(parent :  TRDFComplex; parentType, name : String; elem : TFhirMessageHeaderDestination; index : integer);
    procedure ComposeMessageHeader(parent :  TRDFComplex; parentType, name : String; elem : TFhirMessageHeader; index : integer);
    procedure ComposeNamingSystemContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirNamingSystemContact; index : integer);
    procedure ComposeNamingSystemUniqueId(parent :  TRDFComplex; parentType, name : String; elem : TFhirNamingSystemUniqueId; index : integer);
    procedure ComposeNamingSystem(parent :  TRDFComplex; parentType, name : String; elem : TFhirNamingSystem; index : integer);
    procedure ComposeNutritionOrderOralDiet(parent :  TRDFComplex; parentType, name : String; elem : TFhirNutritionOrderOralDiet; index : integer);
    procedure ComposeNutritionOrderOralDietNutrient(parent :  TRDFComplex; parentType, name : String; elem : TFhirNutritionOrderOralDietNutrient; index : integer);
    procedure ComposeNutritionOrderOralDietTexture(parent :  TRDFComplex; parentType, name : String; elem : TFhirNutritionOrderOralDietTexture; index : integer);
    procedure ComposeNutritionOrderSupplement(parent :  TRDFComplex; parentType, name : String; elem : TFhirNutritionOrderSupplement; index : integer);
    procedure ComposeNutritionOrderEnteralFormula(parent :  TRDFComplex; parentType, name : String; elem : TFhirNutritionOrderEnteralFormula; index : integer);
    procedure ComposeNutritionOrderEnteralFormulaAdministration(parent :  TRDFComplex; parentType, name : String; elem : TFhirNutritionOrderEnteralFormulaAdministration; index : integer);
    procedure ComposeNutritionOrder(parent :  TRDFComplex; parentType, name : String; elem : TFhirNutritionOrder; index : integer);
    procedure ComposeObservationReferenceRange(parent :  TRDFComplex; parentType, name : String; elem : TFhirObservationReferenceRange; index : integer);
    procedure ComposeObservationRelated(parent :  TRDFComplex; parentType, name : String; elem : TFhirObservationRelated; index : integer);
    procedure ComposeObservationComponent(parent :  TRDFComplex; parentType, name : String; elem : TFhirObservationComponent; index : integer);
    procedure ComposeObservation(parent :  TRDFComplex; parentType, name : String; elem : TFhirObservation; index : integer);
    procedure ComposeOperationDefinitionContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirOperationDefinitionContact; index : integer);
    procedure ComposeOperationDefinitionParameter(parent :  TRDFComplex; parentType, name : String; elem : TFhirOperationDefinitionParameter; index : integer);
    procedure ComposeOperationDefinitionParameterBinding(parent :  TRDFComplex; parentType, name : String; elem : TFhirOperationDefinitionParameterBinding; index : integer);
    procedure ComposeOperationDefinition(parent :  TRDFComplex; parentType, name : String; elem : TFhirOperationDefinition; index : integer);
    procedure ComposeOperationOutcomeIssue(parent :  TRDFComplex; parentType, name : String; elem : TFhirOperationOutcomeIssue; index : integer);
    procedure ComposeOperationOutcome(parent :  TRDFComplex; parentType, name : String; elem : TFhirOperationOutcome; index : integer);
    procedure ComposeOrderWhen(parent :  TRDFComplex; parentType, name : String; elem : TFhirOrderWhen; index : integer);
    procedure ComposeOrder(parent :  TRDFComplex; parentType, name : String; elem : TFhirOrder; index : integer);
    procedure ComposeOrderResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirOrderResponse; index : integer);
    procedure ComposeOrganizationContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirOrganizationContact; index : integer);
    procedure ComposeOrganization(parent :  TRDFComplex; parentType, name : String; elem : TFhirOrganization; index : integer);
    procedure ComposePatientContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirPatientContact; index : integer);
    procedure ComposePatientAnimal(parent :  TRDFComplex; parentType, name : String; elem : TFhirPatientAnimal; index : integer);
    procedure ComposePatientCommunication(parent :  TRDFComplex; parentType, name : String; elem : TFhirPatientCommunication; index : integer);
    procedure ComposePatientLink(parent :  TRDFComplex; parentType, name : String; elem : TFhirPatientLink; index : integer);
    procedure ComposePatient(parent :  TRDFComplex; parentType, name : String; elem : TFhirPatient; index : integer);
    procedure ComposePaymentNotice(parent :  TRDFComplex; parentType, name : String; elem : TFhirPaymentNotice; index : integer);
    procedure ComposePaymentReconciliationDetail(parent :  TRDFComplex; parentType, name : String; elem : TFhirPaymentReconciliationDetail; index : integer);
    procedure ComposePaymentReconciliationNote(parent :  TRDFComplex; parentType, name : String; elem : TFhirPaymentReconciliationNote; index : integer);
    procedure ComposePaymentReconciliation(parent :  TRDFComplex; parentType, name : String; elem : TFhirPaymentReconciliation; index : integer);
    procedure ComposePersonLink(parent :  TRDFComplex; parentType, name : String; elem : TFhirPersonLink; index : integer);
    procedure ComposePerson(parent :  TRDFComplex; parentType, name : String; elem : TFhirPerson; index : integer);
    procedure ComposePractitionerPractitionerRole(parent :  TRDFComplex; parentType, name : String; elem : TFhirPractitionerPractitionerRole; index : integer);
    procedure ComposePractitionerQualification(parent :  TRDFComplex; parentType, name : String; elem : TFhirPractitionerQualification; index : integer);
    procedure ComposePractitioner(parent :  TRDFComplex; parentType, name : String; elem : TFhirPractitioner; index : integer);
    procedure ComposeProcedurePerformer(parent :  TRDFComplex; parentType, name : String; elem : TFhirProcedurePerformer; index : integer);
    procedure ComposeProcedureFocalDevice(parent :  TRDFComplex; parentType, name : String; elem : TFhirProcedureFocalDevice; index : integer);
    procedure ComposeProcedure(parent :  TRDFComplex; parentType, name : String; elem : TFhirProcedure; index : integer);
    procedure ComposeProcedureRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirProcedureRequest; index : integer);
    procedure ComposeProcessRequestItem(parent :  TRDFComplex; parentType, name : String; elem : TFhirProcessRequestItem; index : integer);
    procedure ComposeProcessRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirProcessRequest; index : integer);
    procedure ComposeProcessResponseNotes(parent :  TRDFComplex; parentType, name : String; elem : TFhirProcessResponseNotes; index : integer);
    procedure ComposeProcessResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirProcessResponse; index : integer);
    procedure ComposeProvenanceAgent(parent :  TRDFComplex; parentType, name : String; elem : TFhirProvenanceAgent; index : integer);
    procedure ComposeProvenanceAgentRelatedAgent(parent :  TRDFComplex; parentType, name : String; elem : TFhirProvenanceAgentRelatedAgent; index : integer);
    procedure ComposeProvenanceEntity(parent :  TRDFComplex; parentType, name : String; elem : TFhirProvenanceEntity; index : integer);
    procedure ComposeProvenance(parent :  TRDFComplex; parentType, name : String; elem : TFhirProvenance; index : integer);
    procedure ComposeQuestionnaireGroup(parent :  TRDFComplex; parentType, name : String; elem : TFhirQuestionnaireGroup; index : integer);
    procedure ComposeQuestionnaireGroupQuestion(parent :  TRDFComplex; parentType, name : String; elem : TFhirQuestionnaireGroupQuestion; index : integer);
    procedure ComposeQuestionnaire(parent :  TRDFComplex; parentType, name : String; elem : TFhirQuestionnaire; index : integer);
    procedure ComposeQuestionnaireResponseGroup(parent :  TRDFComplex; parentType, name : String; elem : TFhirQuestionnaireResponseGroup; index : integer);
    procedure ComposeQuestionnaireResponseGroupQuestion(parent :  TRDFComplex; parentType, name : String; elem : TFhirQuestionnaireResponseGroupQuestion; index : integer);
    procedure ComposeQuestionnaireResponseGroupQuestionAnswer(parent :  TRDFComplex; parentType, name : String; elem : TFhirQuestionnaireResponseGroupQuestionAnswer; index : integer);
    procedure ComposeQuestionnaireResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirQuestionnaireResponse; index : integer);
    procedure ComposeReferralRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirReferralRequest; index : integer);
    procedure ComposeRelatedPerson(parent :  TRDFComplex; parentType, name : String; elem : TFhirRelatedPerson; index : integer);
    procedure ComposeRiskAssessmentPrediction(parent :  TRDFComplex; parentType, name : String; elem : TFhirRiskAssessmentPrediction; index : integer);
    procedure ComposeRiskAssessment(parent :  TRDFComplex; parentType, name : String; elem : TFhirRiskAssessment; index : integer);
    procedure ComposeSchedule(parent :  TRDFComplex; parentType, name : String; elem : TFhirSchedule; index : integer);
    procedure ComposeSearchParameterContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirSearchParameterContact; index : integer);
    procedure ComposeSearchParameter(parent :  TRDFComplex; parentType, name : String; elem : TFhirSearchParameter; index : integer);
    procedure ComposeSlot(parent :  TRDFComplex; parentType, name : String; elem : TFhirSlot; index : integer);
    procedure ComposeSpecimenCollection(parent :  TRDFComplex; parentType, name : String; elem : TFhirSpecimenCollection; index : integer);
    procedure ComposeSpecimenTreatment(parent :  TRDFComplex; parentType, name : String; elem : TFhirSpecimenTreatment; index : integer);
    procedure ComposeSpecimenContainer(parent :  TRDFComplex; parentType, name : String; elem : TFhirSpecimenContainer; index : integer);
    procedure ComposeSpecimen(parent :  TRDFComplex; parentType, name : String; elem : TFhirSpecimen; index : integer);
    procedure ComposeStructureDefinitionContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirStructureDefinitionContact; index : integer);
    procedure ComposeStructureDefinitionMapping(parent :  TRDFComplex; parentType, name : String; elem : TFhirStructureDefinitionMapping; index : integer);
    procedure ComposeStructureDefinitionSnapshot(parent :  TRDFComplex; parentType, name : String; elem : TFhirStructureDefinitionSnapshot; index : integer);
    procedure ComposeStructureDefinitionDifferential(parent :  TRDFComplex; parentType, name : String; elem : TFhirStructureDefinitionDifferential; index : integer);
    procedure ComposeStructureDefinition(parent :  TRDFComplex; parentType, name : String; elem : TFhirStructureDefinition; index : integer);
    procedure ComposeSubscriptionChannel(parent :  TRDFComplex; parentType, name : String; elem : TFhirSubscriptionChannel; index : integer);
    procedure ComposeSubscription(parent :  TRDFComplex; parentType, name : String; elem : TFhirSubscription; index : integer);
    procedure ComposeSubstanceInstance(parent :  TRDFComplex; parentType, name : String; elem : TFhirSubstanceInstance; index : integer);
    procedure ComposeSubstanceIngredient(parent :  TRDFComplex; parentType, name : String; elem : TFhirSubstanceIngredient; index : integer);
    procedure ComposeSubstance(parent :  TRDFComplex; parentType, name : String; elem : TFhirSubstance; index : integer);
    procedure ComposeSupplyDelivery(parent :  TRDFComplex; parentType, name : String; elem : TFhirSupplyDelivery; index : integer);
    procedure ComposeSupplyRequestWhen(parent :  TRDFComplex; parentType, name : String; elem : TFhirSupplyRequestWhen; index : integer);
    procedure ComposeSupplyRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirSupplyRequest; index : integer);
    procedure ComposeTestScriptContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptContact; index : integer);
    procedure ComposeTestScriptMetadata(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptMetadata; index : integer);
    procedure ComposeTestScriptMetadataLink(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptMetadataLink; index : integer);
    procedure ComposeTestScriptMetadataCapability(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptMetadataCapability; index : integer);
    procedure ComposeTestScriptFixture(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptFixture; index : integer);
    procedure ComposeTestScriptVariable(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptVariable; index : integer);
    procedure ComposeTestScriptSetup(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptSetup; index : integer);
    procedure ComposeTestScriptSetupAction(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptSetupAction; index : integer);
    procedure ComposeTestScriptSetupActionOperation(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptSetupActionOperation; index : integer);
    procedure ComposeTestScriptSetupActionOperationRequestHeader(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptSetupActionOperationRequestHeader; index : integer);
    procedure ComposeTestScriptSetupActionAssert(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssert; index : integer);
    procedure ComposeTestScriptTest(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptTest; index : integer);
    procedure ComposeTestScriptTestAction(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptTestAction; index : integer);
    procedure ComposeTestScriptTeardown(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptTeardown; index : integer);
    procedure ComposeTestScriptTeardownAction(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptTeardownAction; index : integer);
    procedure ComposeTestScript(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScript; index : integer);
    procedure ComposeValueSetContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetContact; index : integer);
    procedure ComposeValueSetCodeSystem(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetCodeSystem; index : integer);
    procedure ComposeValueSetCodeSystemConcept(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetCodeSystemConcept; index : integer);
    procedure ComposeValueSetCodeSystemConceptDesignation(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetCodeSystemConceptDesignation; index : integer);
    procedure ComposeValueSetCompose(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetCompose; index : integer);
    procedure ComposeValueSetComposeInclude(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetComposeInclude; index : integer);
    procedure ComposeValueSetComposeIncludeConcept(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeConcept; index : integer);
    procedure ComposeValueSetComposeIncludeFilter(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeFilter; index : integer);
    procedure ComposeValueSetExpansion(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetExpansion; index : integer);
    procedure ComposeValueSetExpansionParameter(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetExpansionParameter; index : integer);
    procedure ComposeValueSetExpansionContains(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetExpansionContains; index : integer);
    procedure ComposeValueSet(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSet; index : integer);
    procedure ComposeVisionPrescriptionDispense(parent :  TRDFComplex; parentType, name : String; elem : TFhirVisionPrescriptionDispense; index : integer);
    procedure ComposeVisionPrescription(parent :  TRDFComplex; parentType, name : String; elem : TFhirVisionPrescription; index : integer);
  
    procedure ComposeResource(parent :  TRDFComplex; resource : TFhirResource); overload; override;
  end;


implementation

{ TFHIRXmlParser }

function TFHIRXmlParser.ParseElement(element : IXmlDomElement; path : string) : TFhirElement;
var
  child : IXMLDOMElement;
begin
  result := TFhirElement.create;
  try
    parseElementAttributes(result, path, element);
    result.id := GetAttribute(element, 'id');{x.4}
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'extension') then
        result.extensionList.Add(ParseExtension(child, path+'/extension')){y.2}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeElement(xml : TXmlBuilder; name : string; elem : TFhirElement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  Attribute(xml, 'id', elem.id  );
  xml.open(name);
  composeElementChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(xml, 'extension', elem.extensionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElement(jsn)); {2}
end;

function TFHIRJsonParser.ParseElement(jsn : TJsonObject) : TFhirElement;
begin
  result := TFhirElement.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('id') or jsn.has('_id') then
        result.idElement := ParseId(jsn['id'], jsn.vObj['_id']);{q}
    if jsn.has('extension') then
      iterateArray(jsn.vArr['extension'], result.extensionList, parseExtension);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeElement(json : TJSONWriter; name : string; elem : TFhirElement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdValue(json, 'id', elem.idElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdProps(json, 'id', elem.idElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.extensionList.Count > 0) then
  begin
    json.valueArray('extension');
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(json, '', elem.extensionList[i]); {z - Extension}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeElement(parent :  TRDFComplex; parentType, name : String; elem : TFhirElement; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
    this := parent;
  if (index > -1)  then
    this.predicate('fhir:index', inttostr(index));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(this, 'Element', 'id', elem.idElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(this, 'Element', 'extension', elem.extensionList[i], i);
end;

function TFHIRXmlParser.ParseBackboneElement(element : IXmlDomElement; path : string) : TFhirBackboneElement;
var
  child : IXMLDOMElement;
begin
  result := TFhirBackboneElement.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'modifierExtension') then
        result.modifierExtensionList.Add(ParseExtension(child, path+'/modifierExtension')){y.2}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBackboneElement(xml : TXmlBuilder; name : string; elem : TFhirBackboneElement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(xml, 'modifierExtension', elem.modifierExtensionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBackboneElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBackboneElement(jsn)); {2}
end;

function TFHIRJsonParser.ParseBackboneElement(jsn : TJsonObject) : TFhirBackboneElement;
begin
  result := TFhirBackboneElement.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('modifierExtension') then
      iterateArray(jsn.vArr['modifierExtension'], result.modifierExtensionList, parseExtension);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBackboneElement(json : TJSONWriter; name : string; elem : TFhirBackboneElement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.modifierExtensionList.Count > 0) then
  begin
    json.valueArray('modifierExtension');
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(json, '', elem.modifierExtensionList[i]); {z - Extension}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeBackboneElement(parent :  TRDFComplex; parentType, name : String; elem : TFhirBackboneElement; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:BackboneElement');
  end;
  composeElement(this, 'BackboneElement', name, elem, index);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(this, 'BackboneElement', 'modifierExtension', elem.modifierExtensionList[i], i);
end;

Procedure TFHIRXmlParser.ParseElementAttributes(value : TFhirElement; path : string; element : IXmlDomElement);
begin
  TakeCommentsStart(value);
  GetObjectLocation(value, element);
  value.Id := GetAttribute(element, 'id');
end;

Function TFHIRXmlParser.ParseBackboneElementChild(element : TFhirBackboneElement; path : string; child : IXmlDomElement) : boolean;
begin
  result := true;
  if (child.baseName = 'modifierExtension') then
    element.ModifierExtensionList.add(ParseExtension(child, path+'/modifierExtension'))
  else
    result := ParseElementChild(element, path, child);
end;

Function TFHIRXmlParser.ParseElementChild(element : TFhirElement; path : string; child : IXmlDomElement) : boolean;
begin
  result := true;
  if (child.baseName = 'extension') then
    element.ExtensionList.add(ParseExtension(child, path+'/extension'))
  else
    result := false;
end;

procedure TFHIRJsonParser.ParseElementProperties(jsn : TJsonObject; element : TFhirElement);
begin
  parseComments(element, jsn);

  element.LocationStart := jsn.LocationStart;
  element.LocationEnd := jsn.LocationEnd;
  if jsn.has('id') then
    element.Id := jsn['id']
  else if jsn.has('_id') then
    element.Id := jsn['_id'];
  if jsn.has('extension') then
    iterateArray(jsn.vArr['extension'], element.extensionList, parseExtension);
end;

procedure TFHIRJsonParser.ParseBackboneElementProperties(jsn : TJsonObject; element : TFhirBackboneElement);
begin
  parseElementProperties(jsn, element);

  if jsn.has('modifierExtension') then
    iterateArray(jsn.vArr['modifierExtension'], element.modifierExtensionList, parseExtension);
end;

Procedure TFHIRXmlComposer.ComposeElementAttributes(xml : TXmlBuilder; element : TFhirElement);
begin
  CommentsStart(xml, element);
  Attribute(xml, 'id', element.Id);
end;

Procedure TFHIRXmlComposer.ComposeElementChildren(xml : TXmlBuilder; element : TFhirElement);
var
  i : integer;
begin
  if element.hasExtensionList then
    for i := 0 to element.extensionList.count - 1 do
      ComposeExtension(xml, 'extension', element.extensionList[i]);
end;

Procedure TFHIRXmlComposer.ComposeBackboneElementChildren(xml : TXmlBuilder; element : TFhirBackboneElement);
var
  i : integer;
begin
  ComposeElementChildren(xml, element);
  if element.hasModifierExtensionList then
    for i := 0 to element.modifierExtensionList.count - 1 do
      ComposeExtension(xml, 'modifierExtension', element.modifierExtensionList[i]);
end;

Procedure TFHIRJsonComposer.ComposeElementProperties(json : TJSONWriter; elem : TFhirElement);
var
  i : integer;
begin
  composeComments(json, elem);
  Prop(json, 'id', elem.Id);
  if elem.hasExtensionList then
  begin
    json.valueArray('extension');
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(json, '',elem.extensionList[i]);
    json.FinishArray;
  end;
end;

Procedure TFHIRJsonComposer.ComposeBackboneElementProperties(json : TJSONWriter; elem : TFhirBackboneElement);
var
  i : integer;
begin
  ComposeElementProperties(json, elem);
  if elem.hasModifierExtensionList then
  begin
    json.valueArray('modifierExtension');
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(json, '', elem.modifierExtensionList[i]);
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseEnum(Const aNames, aSystems : Array Of String; path : String; element : IXmlDomElement) : TFhirEnum;
var
  child : IXMLDOMElement;
  i : integer;
begin
  result := TFhirEnum.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    i := StringArrayIndexOfSensitive(aNames, result.value);
    if i < 0 then
      raise Exception.create('unknown code: '+result.value+' from a set of choices of '+StringArrayToCommaString(aNames)+' for "'+path+'"');
    result.system := aSystems[i];
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEnum(path, value : string; jsn : TJsonObject; ctxt : TFHIRObjectList; Const aNames, aSystems : Array Of String);
begin
  ctxt.add(ParseEnum(path, value, jsn, aNames, aSystems));
end;

function TFHIRJsonParser.ParseEnum(path, value : string; jsn : TJsonObject; Const aNames, aSystems : Array Of String) : TFHIREnum;
var
  i : integer;
begin
  i := StringArrayIndexOfSensitive(aNames, value);
  if (value <> '') and (i < 0) then
    raise Exception.create('unknown code: '+value+' from a set of choices of '+StringArrayToCommaString(aNames)+' for "'+path+'"');
  result := TFHIREnum.create;
  try
    result.value := value;
    result.system := aSystems[i];
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeEnum(xml : TXmlBuilder; name : String; value : TFhirEnum; Const aNames : Array Of String);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeEnumValue(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
begin
  if (value = nil) or (value.Value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeEnumProps(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposeEnum(parent :  TRDFComplex; parentType, name : String; value : TFhirEnum; Const aNames, aSystems : Array Of String; index : integer);
var
  this, c, cc, cs : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:code');
  this.predicate('a', 'fhir:ConceptBase');
  c := this.predicate('fhir:ConceptBase.coding');
  c.predicate('a', 'fhir:CodingBase');
  cc := c.predicate('fhir:CodingBase.code');
  cc.predicate('a', 'fhir:codeBase');
  cc.predicate('fhir:value', ttlLiteral(value.value));
  cs := c.predicate('fhir:CodingBase.system');
  cs.predicate('a', 'fhir:string');
  cs.predicate('fhir:value', ttlLiteral(aSystems[StringArrayIndexOf(aNames, value.value)]));
  composeElement(this, parentType, name, value, index);
end;

function TFHIRXmlParser.ParseInteger(element : IXmlDomElement; path : string) : TFhirInteger;
var
  child : IXMLDOMElement;
begin
  result := TFhirInteger.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInteger(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInteger(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseInteger(value : string; jsn : TJsonObject) : TFHIRInteger;
begin
  result := TFhirInteger.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeInteger(xml : TXmlBuilder; name : String; value : TFhirInteger);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeIntegerValue(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    propNumber(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeIntegerProps(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposeInteger(parent :  TRDFComplex; parentType, name : String; value : TFhirInteger; index : integer);
var
  this : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:integer');
  this.predicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, index);
end;

function TFHIRXmlParser.ParseDateTime(element : IXmlDomElement; path : string) : TFhirDateTime;
var
  child : IXMLDOMElement;
begin
  result := TFhirDateTime.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTDateAndTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDateTime(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDateTime(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseDateTime(value : string; jsn : TJsonObject) : TFHIRDateTime;
begin
  result := TFhirDateTime.Create;
  try
     result.value := toTDateAndTime(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDateTime(xml : TXmlBuilder; name : String; value : TFhirDateTime);
begin
  if (value = nil) or (value.value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', asString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeDateTimeValue(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
begin
  if (value = nil) or (value.value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeDateTimeProps(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposeDateTime(parent :  TRDFComplex; parentType, name : String; value : TFhirDateTime; index : integer);
var
  this : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:dateTime');
  this.predicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, index);
end;

function TFHIRXmlParser.ParseDate(element : IXmlDomElement; path : string) : TFhirDate;
var
  child : IXMLDOMElement;
begin
  result := TFhirDate.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTDateAndTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDate(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDate(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseDate(value : string; jsn : TJsonObject) : TFHIRDate;
begin
  result := TFhirDate.Create;
  try
     result.value := toTDateAndTime(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDate(xml : TXmlBuilder; name : String; value : TFhirDate);
begin
  if (value = nil) or (value.value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', asString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeDateValue(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
begin
  if (value = nil) or (value.value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeDateProps(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposeDate(parent :  TRDFComplex; parentType, name : String; value : TFhirDate; index : integer);
var
  this : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:date');
  this.predicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, index);
end;

function TFHIRXmlParser.ParseDecimal(element : IXmlDomElement; path : string) : TFhirDecimal;
var
  child : IXMLDOMElement;
begin
  result := TFhirDecimal.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDecimal(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDecimal(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseDecimal(value : string; jsn : TJsonObject) : TFHIRDecimal;
begin
  result := TFhirDecimal.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDecimal(xml : TXmlBuilder; name : String; value : TFhirDecimal);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeDecimalValue(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    propNumber(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeDecimalProps(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposeDecimal(parent :  TRDFComplex; parentType, name : String; value : TFhirDecimal; index : integer);
var
  this : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:decimal');
  this.predicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, index);
end;

function TFHIRXmlParser.ParseUri(element : IXmlDomElement; path : string) : TFhirUri;
var
  child : IXMLDOMElement;
begin
  result := TFhirUri.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseUri(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUri(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseUri(value : string; jsn : TJsonObject) : TFHIRUri;
begin
  result := TFhirUri.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUri(xml : TXmlBuilder; name : String; value : TFhirUri);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeUriValue(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeUriProps(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposeUri(parent :  TRDFComplex; parentType, name : String; value : TFhirUri; index : integer);
var
  this : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:uri');
  this.predicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, index);
end;

function TFHIRXmlParser.ParseBase64Binary(element : IXmlDomElement; path : string) : TFhirBase64Binary;
var
  child : IXMLDOMElement;
begin
  result := TFhirBase64Binary.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTBytes(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBase64Binary(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBase64Binary(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseBase64Binary(value : string; jsn : TJsonObject) : TFHIRBase64Binary;
begin
  result := TFhirBase64Binary.Create;
  try
     result.value := toTBytes(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeBase64Binary(xml : TXmlBuilder; name : String; value : TFhirBase64Binary);
begin
  if (value = nil) or (value.value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', asString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeBase64BinaryValue(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
begin
  if (value = nil) or (value.value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeBase64BinaryProps(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposeBase64Binary(parent :  TRDFComplex; parentType, name : String; value : TFhirBase64Binary; index : integer);
var
  this : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:base64Binary');
  this.predicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, index);
end;

function TFHIRXmlParser.ParseTime(element : IXmlDomElement; path : string) : TFhirTime;
var
  child : IXMLDOMElement;
begin
  result := TFhirTime.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTime(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTime(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseTime(value : string; jsn : TJsonObject) : TFHIRTime;
begin
  result := TFhirTime.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeTime(xml : TXmlBuilder; name : String; value : TFhirTime);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeTimeValue(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeTimeProps(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposeTime(parent :  TRDFComplex; parentType, name : String; value : TFhirTime; index : integer);
var
  this : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:time');
  this.predicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, index);
end;

function TFHIRXmlParser.ParseString(element : IXmlDomElement; path : string) : TFhirString;
var
  child : IXMLDOMElement;
begin
  result := TFhirString.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseString(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseString(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseString(value : string; jsn : TJsonObject) : TFHIRString;
begin
  result := TFhirString.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeString(xml : TXmlBuilder; name : String; value : TFhirString);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeStringValue(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeStringProps(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposeString(parent :  TRDFComplex; parentType, name : String; value : TFhirString; index : integer);
var
  this : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:string');
  this.predicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, index);
end;

function TFHIRXmlParser.ParseBoolean(element : IXmlDomElement; path : string) : TFhirBoolean;
var
  child : IXMLDOMElement;
begin
  result := TFhirBoolean.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := StringToBoolean(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBoolean(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBoolean(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseBoolean(value : string; jsn : TJsonObject) : TFHIRBoolean;
begin
  result := TFhirBoolean.Create;
  try
    result.value := StringToBoolean(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeBoolean(xml : TXmlBuilder; name : String; value : TFhirBoolean);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', LCBooleanToString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeBooleanValue(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
begin
  if (value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeBooleanProps(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposeBoolean(parent :  TRDFComplex; parentType, name : String; value : TFhirBoolean; index : integer);
var
  this : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:boolean');
  this.predicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, index);
end;

function TFHIRXmlParser.ParseInstant(element : IXmlDomElement; path : string) : TFhirInstant;
var
  child : IXMLDOMElement;
begin
  result := TFhirInstant.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTDateAndTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInstant(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInstant(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseInstant(value : string; jsn : TJsonObject) : TFHIRInstant;
begin
  result := TFhirInstant.Create;
  try
     result.value := toTDateAndTime(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeInstant(xml : TXmlBuilder; name : String; value : TFhirInstant);
begin
  if (value = nil) or (value.value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', asString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeInstantValue(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
begin
  if (value = nil) or (value.value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeInstantProps(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposeInstant(parent :  TRDFComplex; parentType, name : String; value : TFhirInstant; index : integer);
var
  this : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:instant');
  this.predicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, index);
end;

function TFHIRXmlParser.ParseMarkdown(element : IXmlDomElement; path : string) : TFhirMarkdown;
var
  child : IXMLDOMElement;
begin
  result := TFhirMarkdown.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMarkdown(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMarkdown(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseMarkdown(value : string; jsn : TJsonObject) : TFHIRMarkdown;
begin
  result := TFhirMarkdown.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeMarkdown(xml : TXmlBuilder; name : String; value : TFhirMarkdown);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeMarkdownValue(json : TJSONWriter; name : String; value : TFhirMarkdown; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeMarkdownProps(json : TJSONWriter; name : String; value : TFhirMarkdown; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposeMarkdown(parent :  TRDFComplex; parentType, name : String; value : TFhirMarkdown; index : integer);
var
  this : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:markdown');
  this.predicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, index);
end;

function TFHIRXmlParser.ParseUnsignedInt(element : IXmlDomElement; path : string) : TFhirUnsignedInt;
var
  child : IXMLDOMElement;
begin
  result := TFhirUnsignedInt.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseUnsignedInt(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUnsignedInt(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseUnsignedInt(value : string; jsn : TJsonObject) : TFHIRUnsignedInt;
begin
  result := TFhirUnsignedInt.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUnsignedInt(xml : TXmlBuilder; name : String; value : TFhirUnsignedInt);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeUnsignedIntValue(json : TJSONWriter; name : String; value : TFhirUnsignedInt; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    propNumber(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeUnsignedIntProps(json : TJSONWriter; name : String; value : TFhirUnsignedInt; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposeUnsignedInt(parent :  TRDFComplex; parentType, name : String; value : TFhirUnsignedInt; index : integer);
var
  this : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:unsignedInt');
  this.predicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, index);
end;

function TFHIRXmlParser.ParseCode(element : IXmlDomElement; path : string) : TFhirCode;
var
  child : IXMLDOMElement;
begin
  result := TFhirCode.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCode(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCode(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseCode(value : string; jsn : TJsonObject) : TFHIRCode;
begin
  result := TFhirCode.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeCode(xml : TXmlBuilder; name : String; value : TFhirCode);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeCodeValue(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeCodeProps(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposeCode(parent :  TRDFComplex; parentType, name : String; value : TFhirCode; index : integer);
var
  this : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:code');
  this.predicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, index);
end;

function TFHIRXmlParser.ParseId(element : IXmlDomElement; path : string) : TFhirId;
var
  child : IXMLDOMElement;
begin
  result := TFhirId.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseId(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseId(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseId(value : string; jsn : TJsonObject) : TFHIRId;
begin
  result := TFhirId.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeId(xml : TXmlBuilder; name : String; value : TFhirId);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeIdValue(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeIdProps(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposeId(parent :  TRDFComplex; parentType, name : String; value : TFhirId; index : integer);
var
  this : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:id');
  this.predicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, index);
end;

function TFHIRXmlParser.ParseOid(element : IXmlDomElement; path : string) : TFhirOid;
var
  child : IXMLDOMElement;
begin
  result := TFhirOid.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOid(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOid(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseOid(value : string; jsn : TJsonObject) : TFHIROid;
begin
  result := TFhirOid.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeOid(xml : TXmlBuilder; name : String; value : TFhirOid);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeOidValue(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeOidProps(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposeOid(parent :  TRDFComplex; parentType, name : String; value : TFhirOid; index : integer);
var
  this : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:oid');
  this.predicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, index);
end;

function TFHIRXmlParser.ParsePositiveInt(element : IXmlDomElement; path : string) : TFhirPositiveInt;
var
  child : IXMLDOMElement;
begin
  result := TFhirPositiveInt.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePositiveInt(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePositiveInt(value, jsn)) {1};
end;

function TFHIRJsonParser.ParsePositiveInt(value : string; jsn : TJsonObject) : TFHIRPositiveInt;
begin
  result := TFhirPositiveInt.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposePositiveInt(xml : TXmlBuilder; name : String; value : TFhirPositiveInt);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposePositiveIntValue(json : TJSONWriter; name : String; value : TFhirPositiveInt; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    propNumber(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposePositiveIntProps(json : TJSONWriter; name : String; value : TFhirPositiveInt; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposePositiveInt(parent :  TRDFComplex; parentType, name : String; value : TFhirPositiveInt; index : integer);
var
  this : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:positiveInt');
  this.predicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, index);
end;

function TFHIRXmlParser.ParseUuid(element : IXmlDomElement; path : string) : TFhirUuid;
var
  child : IXMLDOMElement;
begin
  result := TFhirUuid.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseUuid(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUuid(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseUuid(value : string; jsn : TJsonObject) : TFHIRUuid;
begin
  result := TFhirUuid.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUuid(xml : TXmlBuilder; name : String; value : TFhirUuid);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeUuidValue(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeUuidProps(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRRDFComposer.ComposeUuid(parent :  TRDFComplex; parentType, name : String; value : TFhirUuid; index : integer);
var
  this : TRDFComplex;
begin
  if (value = nil) then
    exit;
  this := parent.predicate('fhir:'+parentType+'.'+name);
  this.predicate('a', 'fhir:uuid');
  this.predicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, index);
end;

Procedure TFHIRXmlParser.ParseResourceAttributes(resource : TFhirResource; path : string; element : IXmlDomElement);
begin
  GetObjectLocation(resource, element);
end;

Function TFHIRXmlParser.ParseResourceChild(resource : TFhirResource; path : string; child : IXmlDomElement) : boolean;
begin
  result := true;
  if (child.baseName = 'id') then
    resource.idElement := ParseId(child, path+'/id') {b}
  else if (child.baseName = 'meta') then
    resource.meta := ParseMeta(child, path+'/meta') {b}
  else if (child.baseName = 'implicitRules') then
    resource.implicitRulesElement := ParseUri(child, path+'/implicitRules') {b}
  else if (child.baseName = 'language') then
    resource.languageElement := ParseCode(child, path+'/language') {b}
  else
    result := false;
end;

procedure TFHIRJsonParser.ParseResourceProperties(jsn : TJsonObject; resource : TFhirResource);
begin
  resource.LocationStart := jsn.LocationStart;
  resource.LocationEnd := jsn.LocationEnd;
  if jsn.has('id') or jsn.has('_id') then
    resource.idElement := ParseId(jsn['id'], jsn.vObj['_id']);{q}
  if jsn.has('meta') then
    resource.meta := ParseMeta(jsn.vObj['meta']);{q}
  if jsn.has('implicitRules') or jsn.has('_implicitRules') then
    resource.implicitRulesElement := ParseUri(jsn['implicitRules'], jsn.vObj['_implicitRules']);{q}
  if jsn.has('language') or jsn.has('_language') then
    resource.languageElement := ParseCode(jsn['language'], jsn.vObj['_language']);{q}
end;

Procedure TFHIRXmlComposer.ComposeResourceAttributes(xml : TXmlBuilder; resource : TFhirResource);
begin
end;

Procedure TFHIRXmlComposer.ComposeResourceChildren(xml : TXmlBuilder; elem : TFhirResource);
var
  i : integer;
begin
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(xml, 'id', elem.idElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMeta(xml, 'meta', elem.meta);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'implicitRules', elem.implicitRulesElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'language', elem.languageElement);{x.2}
end;

Procedure TFHIRJsonComposer.ComposeResourceProperties(json : TJSONWriter; elem : TFhirResource);
var
  i : integer;
begin
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdValue(json, 'id', elem.idElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdProps(json, 'id', elem.idElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMeta(json, 'meta', elem.meta); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'implicitRules', elem.implicitRulesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'implicitRules', elem.implicitRulesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'language', elem.languageElement, false);
end;

Procedure TFHIRRDFComposer.ComposeResource(this : TRDFComplex; parentType, name : String; elem : TFhirResource; index : integer);
var
  i : integer;
begin
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(this, 'Resource', 'id', elem.idElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMeta(this, 'Resource', 'meta', elem.metaElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Resource', 'implicitRules', elem.implicitRulesElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'Resource', 'language', elem.languageElement, -1);{x.2}
end;

Procedure TFHIRXmlParser.ParseDomainResourceAttributes(resource : TFhirDomainResource; path : string; element : IXmlDomElement);
begin
  ParseResourceAttributes(resource, path, element);
end;

Function TFHIRXmlParser.ParseDomainResourceChild(resource : TFhirDomainResource; path : string; child : IXmlDomElement) : boolean;
begin
  result := true;
  if (child.baseName = 'text') then
    resource.text := ParseNarrative(child, path+'/text') {b}
  else if (child.baseName = 'contained') then
    resource.containedList.Add(ParseInnerResource(child, path+'/contained')){y.2}
  else if (child.baseName = 'extension') then
    resource.extensionList.Add(ParseExtension(child, path+'/extension')){y.2}
  else if (child.baseName = 'modifierExtension') then
    resource.modifierExtensionList.Add(ParseExtension(child, path+'/modifierExtension')){y.2}
  else if not parseResourceChild(resource, path, child) then
    result := false;
end;

procedure TFHIRJsonParser.ParseDomainResourceProperties(jsn : TJsonObject; resource : TFhirDomainResource);
begin
  ParseResourceProperties(jsn, resource);
  if jsn.has('text') then
    resource.text := ParseNarrative(jsn.vObj['text']);{q}
  if jsn.has('contained') then
    iterateArray(jsn.vArr['contained'], resource.containedList, parseInnerResource);
  if jsn.has('extension') then
    iterateArray(jsn.vArr['extension'], resource.extensionList, parseExtension);
  if jsn.has('modifierExtension') then
    iterateArray(jsn.vArr['modifierExtension'], resource.modifierExtensionList, parseExtension);
end;

Procedure TFHIRXmlComposer.ComposeDomainResourceAttributes(xml : TXmlBuilder; resource : TFhirDomainResource);
begin
  ComposeResourceAttributes(xml, resource);
end;

Procedure TFHIRXmlComposer.ComposeDomainResourceChildren(xml : TXmlBuilder; elem : TFhirDomainResource);
var
  i : integer;
begin
  composeResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soText]) then
    ComposeNarrative(xml, 'text', elem.text);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.containedList.Count - 1 do
      ComposeInnerResource(xml, 'contained', elem, elem.containedList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(xml, 'extension', elem.extensionList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(xml, 'modifierExtension', elem.modifierExtensionList[i]);
end;

Procedure TFHIRJsonComposer.ComposeDomainResourceProperties(json : TJSONWriter; elem : TFhirDomainResource);
var
  i : integer;
begin
  ComposeResourceProperties(json, elem);
  if (SummaryOption in [soFull, soText]) then
    ComposeNarrative(json, 'text', elem.text); {a}
  if (SummaryOption in [soFull, soData]) and (elem.containedList.Count > 0) then
  begin
    json.valueArray('contained');
    for i := 0 to elem.containedList.Count - 1 do
      ComposeInnerResource(json, '', elem, elem.containedList[i]); {z - Resource}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.extensionList.Count > 0) then
  begin
    json.valueArray('extension');
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(json, '', elem.extensionList[i]); {z - Extension}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.modifierExtensionList.Count > 0) then
  begin
    json.valueArray('modifierExtension');
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(json, '', elem.modifierExtensionList[i]); {z - Extension}
    json.FinishArray;
  end;
end;

Procedure TFHIRRDFComposer.ComposeDomainResource(this : TRDFComplex; parentType, name : String; elem : TFhirDomainResource; index : integer);
var
  i : integer;
begin
  ComposeResource(this, 'DomainResource', name, elem, index);
  if (SummaryOption in [soFull, soText]) then
    ComposeNarrative(this, 'DomainResource', 'text', elem.textElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.containedList.Count - 1 do
      ComposeResource(this, 'DomainResource', 'contained', elem.containedList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(this, 'DomainResource', 'extension', elem.extensionList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(this, 'DomainResource', 'modifierExtension', elem.modifierExtensionList[i], i);
end;

function TFHIRXmlParser.ParseParametersParameter(element : IXmlDomElement; path : string) : TFhirParametersParameter;
var
  child : IXMLDOMElement;
begin
  result := TFhirParametersParameter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'valueMarkdown') then
        result.value := ParseMarkdown(child, path+'.valueMarkdown') {c}
      else if (child.baseName = 'valueInteger') then
        result.value := ParseInteger(child, path+'.valueInteger') {c}
      else if (child.baseName = 'valueDateTime') then
        result.value := ParseDateTime(child, path+'.valueDateTime') {c}
      else if (child.baseName = 'valueUnsignedInt') then
        result.value := ParseUnsignedInt(child, path+'.valueUnsignedInt') {c}
      else if (child.baseName = 'valueCode') then
        result.value := ParseCode(child, path+'.valueCode') {c}
      else if (child.baseName = 'valueDate') then
        result.value := ParseDate(child, path+'.valueDate') {c}
      else if (child.baseName = 'valueDecimal') then
        result.value := ParseDecimal(child, path+'.valueDecimal') {c}
      else if (child.baseName = 'valueUri') then
        result.value := ParseUri(child, path+'.valueUri') {c}
      else if (child.baseName = 'valueId') then
        result.value := ParseId(child, path+'.valueId') {c}
      else if (child.baseName = 'valueBase64Binary') then
        result.value := ParseBase64Binary(child, path+'.valueBase64Binary') {c}
      else if (child.baseName = 'valueTime') then
        result.value := ParseTime(child, path+'.valueTime') {c}
      else if (child.baseName = 'valueOid') then
        result.value := ParseOid(child, path+'.valueOid') {c}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'.valueString') {c}
      else if (child.baseName = 'valuePositiveInt') then
        result.value := ParsePositiveInt(child, path+'.valuePositiveInt') {c}
      else if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'.valueBoolean') {c}
      else if (child.baseName = 'valueUuid') then
        result.value := ParseUuid(child, path+'.valueUuid') {c}
      else if (child.baseName = 'valueInstant') then
        result.value := ParseInstant(child, path+'.valueInstant') {c}
      else if (child.baseName = 'valuePeriod') then
        result.value := ParsePeriod(child, path+'.valuePeriod') {ePeriod}
      else if (child.baseName = 'valueCoding') then
        result.value := ParseCoding(child, path+'.valueCoding') {eCoding}
      else if (child.baseName = 'valueRange') then
        result.value := ParseRange(child, path+'.valueRange') {eRange}
      else if (child.baseName = 'valueAttachment') then
        result.value := ParseAttachment(child, path+'.valueAttachment') {eAttachment}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'.valueQuantity') {eQuantity}
      else if (child.baseName = 'valueAnnotation') then
        result.value := ParseAnnotation(child, path+'.valueAnnotation') {eAnnotation}
      else if (child.baseName = 'valueRatio') then
        result.value := ParseRatio(child, path+'.valueRatio') {eRatio}
      else if (child.baseName = 'valueSampledData') then
        result.value := ParseSampledData(child, path+'.valueSampledData') {eSampledData}
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'.valueCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'valueReference') then
        result.value := ParseReference(child, path+'.valueReference') {eReference}
      else if (child.baseName = 'valueIdentifier') then
        result.value := ParseIdentifier(child, path+'.valueIdentifier') {eIdentifier}
      else if (child.baseName = 'valueSignature') then
        result.value := ParseSignature(child, path+'.valueSignature') {eSignature}
      else if (child.baseName = 'valueTiming') then
        result.value := ParseTiming(child, path+'/valueTiming') {f}
      else if (child.baseName = 'valueElementDefinition') then
        result.value := ParseElementDefinition(child, path+'/valueElementDefinition') {f}
      else if (child.baseName = 'valueHumanName') then
        result.value := ParseHumanName(child, path+'/valueHumanName') {f}
      else if (child.baseName = 'valueAddress') then
        result.value := ParseAddress(child, path+'/valueAddress') {f}
      else if (child.baseName = 'valueMeta') then
        result.value := ParseMeta(child, path+'/valueMeta') {f}
      else if (child.baseName = 'valueContactPoint') then
        result.value := ParseContactPoint(child, path+'/valueContactPoint') {f}
      else if (child.baseName = 'resource') then
        result.resource := ParseInnerResource(child, path+'/resource') {b}
      else if (child.baseName = 'part') then
        result.partList.Add(ParseParametersParameter(child, path+'/part')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeParametersParameter(xml : TXmlBuilder; name : string; elem : TFhirParametersParameter);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) {1} then
    ComposeMarkdown(xml, 'valueMarkdown', TFhirMarkdown(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) {1} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) {1} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) {1} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) {1} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) {1} then
    ComposeId(xml, 'valueId', TFhirId(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) {1} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) {1} then
    ComposeOid(xml, 'valueOid', TFhirOid(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) {1} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUuid) {1} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) {1} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPeriod) {8} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCoding) {8} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRange) {8} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAnnotation) {8} then
    ComposeAnnotation(xml, 'valueAnnotation', TFhirAnnotation(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRatio) {8} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirReference) {8} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSignature) {8} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTiming) {9} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'valueElementDefinition', TFhirElementDefinition(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAddress) {9} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMeta) {9} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(elem.value));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(xml, 'resource', elem, elem.resource);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.partList.Count - 1 do
      ComposeParametersParameter(xml, 'part', elem.partList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseParametersParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseParametersParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseParametersParameter(jsn : TJsonObject) : TFhirParametersParameter;
begin
  result := TFhirParametersParameter.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('valueMarkdown') or jsn.has('_valueMarkdown') then
        result.value := ParseMarkdown(jsn['valueMarkdown'], jsn.vObj['_valueMarkdown']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
        result.value := ParseInteger(jsn['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
        result.value := ParseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueUnsignedInt') or jsn.has('_valueUnsignedInt') then
        result.value := ParseUnsignedInt(jsn['valueUnsignedInt'], jsn.vObj['_valueUnsignedInt']);
    if jsn.has('valueCode') or jsn.has('_valueCode') then
        result.value := ParseCode(jsn['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
        result.value := ParseDate(jsn['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
        result.value := ParseDecimal(jsn['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
        result.value := ParseUri(jsn['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('valueId') or jsn.has('_valueId') then
        result.value := ParseId(jsn['valueId'], jsn.vObj['_valueId']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
        result.value := ParseBase64Binary(jsn['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
        result.value := ParseTime(jsn['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueOid') or jsn.has('_valueOid') then
        result.value := ParseOid(jsn['valueOid'], jsn.vObj['_valueOid']);
    if jsn.has('valueString') or jsn.has('_valueString') then
        result.value := ParseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valuePositiveInt') or jsn.has('_valuePositiveInt') then
        result.value := ParsePositiveInt(jsn['valuePositiveInt'], jsn.vObj['_valuePositiveInt']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
        result.value := ParseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
        result.value := ParseUuid(jsn['valueUuid'], jsn.vObj['_valueUuid']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
        result.value := ParseInstant(jsn['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valuePeriod') {a7} then
        result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueCoding') {a7} then
        result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueRange') {a7} then
        result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueAttachment') {a7} then
        result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueQuantity') {a7} then
        result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueAnnotation') {a7} then
        result.value := ParseAnnotation(jsn.vObj['valueAnnotation']);
    if jsn.has('valueRatio') {a7} then
        result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueSampledData') {a7} then
        result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueCodeableConcept') {a7} then
        result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueReference') {a7} then
        result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueIdentifier') {a7} then
        result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if jsn.has('valueSignature') {a7} then
        result.value := ParseSignature(jsn.vObj['valueSignature']);
    if jsn.has('valueTiming') {a9} then
        result.value := ParseTiming(jsn.vObj['valueTiming']);
    if jsn.has('valueElementDefinition') {a9} then
        result.value := ParseElementDefinition(jsn.vObj['valueElementDefinition']);
    if jsn.has('valueHumanName') {a9} then
        result.value := ParseHumanName(jsn.vObj['valueHumanName']);
    if jsn.has('valueAddress') {a9} then
        result.value := ParseAddress(jsn.vObj['valueAddress']);
    if jsn.has('valueMeta') {a9} then
        result.value := ParseMeta(jsn.vObj['valueMeta']);
    if jsn.has('valueContactPoint') {a9} then
        result.value := ParseContactPoint(jsn.vObj['valueContactPoint']);
    if jsn.has('resource') then
        result.resource := ParseInnerResource(jsn.vObj['resource']);{q}
    if jsn.has('part') then
      iterateArray(jsn.vArr['part'], result.partList, parseParametersParameter);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeParametersParameter(json : TJSONWriter; name : string; elem : TFhirParametersParameter; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) then
  begin
    ComposeMarkdownValue(json, 'valueMarkdown', TFhirMarkdown(elem.value), false);
    ComposeMarkdownProps(json, 'valueMarkdown', TFhirMarkdown(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false);
    ComposeUnsignedIntProps(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) then
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) then
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) then
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) then
  begin
    ComposeIdValue(json, 'valueId', TFhirId(elem.value), false);
    ComposeIdProps(json, 'valueId', TFhirId(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) then
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) then
  begin
    ComposeOidValue(json, 'valueOid', TFhirOid(elem.value), false);
    ComposeOidProps(json, 'valueOid', TFhirOid(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) then
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false);
    ComposePositiveIntProps(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'valueUuid', TFhirUuid(elem.value), false);
    ComposeUuidProps(json, 'valueUuid', TFhirUuid(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPeriod) then
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCoding) then
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRange) then
    ComposeRange(json, 'valueRange', TFhirRange(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAttachment) then
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirQuantity) then
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAnnotation) then
    ComposeAnnotation(json, 'valueAnnotation', TFhirAnnotation(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRatio) then
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSampledData) then
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirIdentifier) then
    ComposeIdentifier(json, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSignature) then
    ComposeSignature(json, 'valueSignature', TFhirSignature(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTiming) then
    ComposeTiming(json, 'valueTiming', TFhirTiming(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'valueElementDefinition', TFhirElementDefinition(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirHumanName) then
    ComposeHumanName(json, 'valueHumanName', TFhirHumanName(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAddress) then
    ComposeAddress(json, 'valueAddress', TFhirAddress(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMeta) then
    ComposeMeta(json, 'valueMeta', TFhirMeta(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactPoint) then
    ComposeContactPoint(json, 'valueContactPoint', TFhirContactPoint(elem.value));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(json, 'resource', elem, elem.resource); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.partList.Count > 0) then
  begin
    json.valueArray('part');
    for i := 0 to elem.partList.Count - 1 do
      ComposeParametersParameter(json, '', elem.partList[i]); {z - @Parameters.parameter}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeParametersParameter(parent :  TRDFComplex; parentType, name : String; elem : TFhirParametersParameter; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ParametersParameter');
  end;
  composeBackboneElement(this, 'ParametersParameter', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ParametersParameter', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) {1} then
    ComposeMarkdown(this, 'ParametersParameter', 'valueMarkdown', TFhirMarkdown(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) {1} then
    ComposeInteger(this, 'ParametersParameter', 'valueInteger', TFhirInteger(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) {1} then
    ComposeDateTime(this, 'ParametersParameter', 'valueDateTime', TFhirDateTime(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(this, 'ParametersParameter', 'valueUnsignedInt', TFhirUnsignedInt(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) {1} then
    ComposeCode(this, 'ParametersParameter', 'valueCode', TFhirCode(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) {1} then
    ComposeDate(this, 'ParametersParameter', 'valueDate', TFhirDate(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) {1} then
    ComposeDecimal(this, 'ParametersParameter', 'valueDecimal', TFhirDecimal(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) {1} then
    ComposeUri(this, 'ParametersParameter', 'valueUri', TFhirUri(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) {1} then
    ComposeId(this, 'ParametersParameter', 'valueId', TFhirId(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) {1} then
    ComposeBase64Binary(this, 'ParametersParameter', 'valueBase64Binary', TFhirBase64Binary(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) {1} then
    ComposeTime(this, 'ParametersParameter', 'valueTime', TFhirTime(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) {1} then
    ComposeOid(this, 'ParametersParameter', 'valueOid', TFhirOid(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) {1} then
    ComposeString(this, 'ParametersParameter', 'valueString', TFhirString(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) {1} then
    ComposePositiveInt(this, 'ParametersParameter', 'valuePositiveInt', TFhirPositiveInt(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) {1} then
    ComposeBoolean(this, 'ParametersParameter', 'valueBoolean', TFhirBoolean(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUuid) {1} then
    ComposeUuid(this, 'ParametersParameter', 'valueUuid', TFhirUuid(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) {1} then
    ComposeInstant(this, 'ParametersParameter', 'valueInstant', TFhirInstant(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPeriod) {8} then
    ComposePeriod(this, 'ParametersParameter', 'valuePeriod', TFhirPeriod(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCoding) {8} then
    ComposeCoding(false, this, 'ParametersParameter', 'valueCoding', TFhirCoding(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRange) {8} then
    ComposeRange(this, 'ParametersParameter', 'valueRange', TFhirRange(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAttachment) {8} then
    ComposeAttachment(this, 'ParametersParameter', 'valueAttachment', TFhirAttachment(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirQuantity) {8} then
    ComposeQuantity(this, 'ParametersParameter', 'valueQuantity', TFhirQuantity(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAnnotation) {8} then
    ComposeAnnotation(this, 'ParametersParameter', 'valueAnnotation', TFhirAnnotation(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRatio) {8} then
    ComposeRatio(this, 'ParametersParameter', 'valueRatio', TFhirRatio(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSampledData) {8} then
    ComposeSampledData(this, 'ParametersParameter', 'valueSampledData', TFhirSampledData(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(this, 'ParametersParameter', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirReference) {8} then
    ComposeReference(this, 'ParametersParameter', 'valueReference', TFhirReference(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirIdentifier) {8} then
    ComposeIdentifier(this, 'ParametersParameter', 'valueIdentifier', TFhirIdentifier(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSignature) {8} then
    ComposeSignature(this, 'ParametersParameter', 'valueSignature', TFhirSignature(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTiming) {9} then
    ComposeTiming(this, 'ParametersParameter', 'valueTiming', TFhirTiming(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirElementDefinition) {9} then
    ComposeElementDefinition(this, 'ParametersParameter', 'valueElementDefinition', TFhirElementDefinition(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirHumanName) {9} then
    ComposeHumanName(this, 'ParametersParameter', 'valueHumanName', TFhirHumanName(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAddress) {9} then
    ComposeAddress(this, 'ParametersParameter', 'valueAddress', TFhirAddress(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMeta) {9} then
    ComposeMeta(this, 'ParametersParameter', 'valueMeta', TFhirMeta(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactPoint) {9} then
    ComposeContactPoint(this, 'ParametersParameter', 'valueContactPoint', TFhirContactPoint(elem.value), -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeResource(this, 'ParametersParameter', 'resource', elem.resourceElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.partList.Count - 1 do
      ComposeParametersParameter(this, 'ParametersParameter', 'part', elem.partList[i], i);
end;

function TFHIRXmlParser.ParseParameters(element : IXmlDomElement; path : string) : TFhirParameters;
var
  child : IXMLDOMElement;
begin
  result := TFhirParameters.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'parameter') then
        result.parameterList.Add(ParseParametersParameter(child, path+'/parameter')){y.2}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeParameters(xml : TXmlBuilder; name : string; elem : TFhirParameters);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeParametersParameter(xml, 'parameter', elem.parameterList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseParameters(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseParameters(jsn)); {2}
end;

function TFHIRJsonParser.ParseParameters(jsn : TJsonObject) : TFhirParameters;
begin
  result := TFhirParameters.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseParametersParameter);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeParameters(json : TJSONWriter; name : string; elem : TFhirParameters; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.parameterList.Count > 0) then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeParametersParameter(json, '', elem.parameterList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeParameters(parent :  TRDFComplex; parentType, name : String; elem : TFhirParameters; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Parameters');
  end;
  composeResource(this, 'Parameters', name, elem, index);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeParametersParameter(this, 'Parameters', 'parameter', elem.parameterList[i], i);
end;

function TFHIRXmlParser.ParseExtension(element : IXmlDomElement; path : string) : TFhirExtension;
var
  child : IXMLDOMElement;
begin
  result := TFhirExtension.create;
  try
    parseElementAttributes(result, path, element);
    result.url := GetAttribute(element, 'url');{x.4}
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'valueMarkdown') then
        result.value := ParseMarkdown(child, path+'.valueMarkdown') {c}
      else if (child.baseName = 'valueInteger') then
        result.value := ParseInteger(child, path+'.valueInteger') {c}
      else if (child.baseName = 'valueDateTime') then
        result.value := ParseDateTime(child, path+'.valueDateTime') {c}
      else if (child.baseName = 'valueUnsignedInt') then
        result.value := ParseUnsignedInt(child, path+'.valueUnsignedInt') {c}
      else if (child.baseName = 'valueCode') then
        result.value := ParseCode(child, path+'.valueCode') {c}
      else if (child.baseName = 'valueDate') then
        result.value := ParseDate(child, path+'.valueDate') {c}
      else if (child.baseName = 'valueDecimal') then
        result.value := ParseDecimal(child, path+'.valueDecimal') {c}
      else if (child.baseName = 'valueUri') then
        result.value := ParseUri(child, path+'.valueUri') {c}
      else if (child.baseName = 'valueId') then
        result.value := ParseId(child, path+'.valueId') {c}
      else if (child.baseName = 'valueBase64Binary') then
        result.value := ParseBase64Binary(child, path+'.valueBase64Binary') {c}
      else if (child.baseName = 'valueTime') then
        result.value := ParseTime(child, path+'.valueTime') {c}
      else if (child.baseName = 'valueOid') then
        result.value := ParseOid(child, path+'.valueOid') {c}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'.valueString') {c}
      else if (child.baseName = 'valuePositiveInt') then
        result.value := ParsePositiveInt(child, path+'.valuePositiveInt') {c}
      else if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'.valueBoolean') {c}
      else if (child.baseName = 'valueUuid') then
        result.value := ParseUuid(child, path+'.valueUuid') {c}
      else if (child.baseName = 'valueInstant') then
        result.value := ParseInstant(child, path+'.valueInstant') {c}
      else if (child.baseName = 'valuePeriod') then
        result.value := ParsePeriod(child, path+'.valuePeriod') {ePeriod}
      else if (child.baseName = 'valueCoding') then
        result.value := ParseCoding(child, path+'.valueCoding') {eCoding}
      else if (child.baseName = 'valueRange') then
        result.value := ParseRange(child, path+'.valueRange') {eRange}
      else if (child.baseName = 'valueAttachment') then
        result.value := ParseAttachment(child, path+'.valueAttachment') {eAttachment}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'.valueQuantity') {eQuantity}
      else if (child.baseName = 'valueAnnotation') then
        result.value := ParseAnnotation(child, path+'.valueAnnotation') {eAnnotation}
      else if (child.baseName = 'valueRatio') then
        result.value := ParseRatio(child, path+'.valueRatio') {eRatio}
      else if (child.baseName = 'valueSampledData') then
        result.value := ParseSampledData(child, path+'.valueSampledData') {eSampledData}
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'.valueCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'valueReference') then
        result.value := ParseReference(child, path+'.valueReference') {eReference}
      else if (child.baseName = 'valueIdentifier') then
        result.value := ParseIdentifier(child, path+'.valueIdentifier') {eIdentifier}
      else if (child.baseName = 'valueSignature') then
        result.value := ParseSignature(child, path+'.valueSignature') {eSignature}
      else if (child.baseName = 'valueTiming') then
        result.value := ParseTiming(child, path+'/valueTiming') {f}
      else if (child.baseName = 'valueElementDefinition') then
        result.value := ParseElementDefinition(child, path+'/valueElementDefinition') {f}
      else if (child.baseName = 'valueHumanName') then
        result.value := ParseHumanName(child, path+'/valueHumanName') {f}
      else if (child.baseName = 'valueAddress') then
        result.value := ParseAddress(child, path+'/valueAddress') {f}
      else if (child.baseName = 'valueMeta') then
        result.value := ParseMeta(child, path+'/valueMeta') {f}
      else if (child.baseName = 'valueContactPoint') then
        result.value := ParseContactPoint(child, path+'/valueContactPoint') {f}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeExtension(xml : TXmlBuilder; name : string; elem : TFhirExtension);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  Attribute(xml, 'url', elem.url  );
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) {1} then
    ComposeMarkdown(xml, 'valueMarkdown', TFhirMarkdown(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) {1} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) {1} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) {1} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) {1} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) {1} then
    ComposeId(xml, 'valueId', TFhirId(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) {1} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) {1} then
    ComposeOid(xml, 'valueOid', TFhirOid(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) {1} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUuid) {1} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) {1} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPeriod) {8} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCoding) {8} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRange) {8} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAnnotation) {8} then
    ComposeAnnotation(xml, 'valueAnnotation', TFhirAnnotation(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRatio) {8} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirReference) {8} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSignature) {8} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTiming) {9} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'valueElementDefinition', TFhirElementDefinition(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAddress) {9} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMeta) {9} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(elem.value));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseExtension(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExtension(jsn)); {2}
end;

function TFHIRJsonParser.ParseExtension(jsn : TJsonObject) : TFhirExtension;
begin
  result := TFhirExtension.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('valueMarkdown') or jsn.has('_valueMarkdown') then
        result.value := ParseMarkdown(jsn['valueMarkdown'], jsn.vObj['_valueMarkdown']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
        result.value := ParseInteger(jsn['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
        result.value := ParseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueUnsignedInt') or jsn.has('_valueUnsignedInt') then
        result.value := ParseUnsignedInt(jsn['valueUnsignedInt'], jsn.vObj['_valueUnsignedInt']);
    if jsn.has('valueCode') or jsn.has('_valueCode') then
        result.value := ParseCode(jsn['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
        result.value := ParseDate(jsn['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
        result.value := ParseDecimal(jsn['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
        result.value := ParseUri(jsn['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('valueId') or jsn.has('_valueId') then
        result.value := ParseId(jsn['valueId'], jsn.vObj['_valueId']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
        result.value := ParseBase64Binary(jsn['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
        result.value := ParseTime(jsn['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueOid') or jsn.has('_valueOid') then
        result.value := ParseOid(jsn['valueOid'], jsn.vObj['_valueOid']);
    if jsn.has('valueString') or jsn.has('_valueString') then
        result.value := ParseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valuePositiveInt') or jsn.has('_valuePositiveInt') then
        result.value := ParsePositiveInt(jsn['valuePositiveInt'], jsn.vObj['_valuePositiveInt']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
        result.value := ParseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
        result.value := ParseUuid(jsn['valueUuid'], jsn.vObj['_valueUuid']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
        result.value := ParseInstant(jsn['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valuePeriod') {a7} then
        result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueCoding') {a7} then
        result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueRange') {a7} then
        result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueAttachment') {a7} then
        result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueQuantity') {a7} then
        result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueAnnotation') {a7} then
        result.value := ParseAnnotation(jsn.vObj['valueAnnotation']);
    if jsn.has('valueRatio') {a7} then
        result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueSampledData') {a7} then
        result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueCodeableConcept') {a7} then
        result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueReference') {a7} then
        result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueIdentifier') {a7} then
        result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if jsn.has('valueSignature') {a7} then
        result.value := ParseSignature(jsn.vObj['valueSignature']);
    if jsn.has('valueTiming') {a9} then
        result.value := ParseTiming(jsn.vObj['valueTiming']);
    if jsn.has('valueElementDefinition') {a9} then
        result.value := ParseElementDefinition(jsn.vObj['valueElementDefinition']);
    if jsn.has('valueHumanName') {a9} then
        result.value := ParseHumanName(jsn.vObj['valueHumanName']);
    if jsn.has('valueAddress') {a9} then
        result.value := ParseAddress(jsn.vObj['valueAddress']);
    if jsn.has('valueMeta') {a9} then
        result.value := ParseMeta(jsn.vObj['valueMeta']);
    if jsn.has('valueContactPoint') {a9} then
        result.value := ParseContactPoint(jsn.vObj['valueContactPoint']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeExtension(json : TJSONWriter; name : string; elem : TFhirExtension; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) then
  begin
    ComposeMarkdownValue(json, 'valueMarkdown', TFhirMarkdown(elem.value), false);
    ComposeMarkdownProps(json, 'valueMarkdown', TFhirMarkdown(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false);
    ComposeUnsignedIntProps(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) then
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) then
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) then
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) then
  begin
    ComposeIdValue(json, 'valueId', TFhirId(elem.value), false);
    ComposeIdProps(json, 'valueId', TFhirId(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) then
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) then
  begin
    ComposeOidValue(json, 'valueOid', TFhirOid(elem.value), false);
    ComposeOidProps(json, 'valueOid', TFhirOid(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) then
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false);
    ComposePositiveIntProps(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'valueUuid', TFhirUuid(elem.value), false);
    ComposeUuidProps(json, 'valueUuid', TFhirUuid(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPeriod) then
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCoding) then
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRange) then
    ComposeRange(json, 'valueRange', TFhirRange(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAttachment) then
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirQuantity) then
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAnnotation) then
    ComposeAnnotation(json, 'valueAnnotation', TFhirAnnotation(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRatio) then
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSampledData) then
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirIdentifier) then
    ComposeIdentifier(json, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSignature) then
    ComposeSignature(json, 'valueSignature', TFhirSignature(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTiming) then
    ComposeTiming(json, 'valueTiming', TFhirTiming(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'valueElementDefinition', TFhirElementDefinition(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirHumanName) then
    ComposeHumanName(json, 'valueHumanName', TFhirHumanName(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAddress) then
    ComposeAddress(json, 'valueAddress', TFhirAddress(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMeta) then
    ComposeMeta(json, 'valueMeta', TFhirMeta(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactPoint) then
    ComposeContactPoint(json, 'valueContactPoint', TFhirContactPoint(elem.value));
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeExtension(parent :  TRDFComplex; parentType, name : String; elem : TFhirExtension; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Extension');
  end;
  composeElement(this, 'Extension', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Extension', 'url', elem.urlElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) {1} then
    ComposeMarkdown(this, 'Extension', 'valueMarkdown', TFhirMarkdown(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) {1} then
    ComposeInteger(this, 'Extension', 'valueInteger', TFhirInteger(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) {1} then
    ComposeDateTime(this, 'Extension', 'valueDateTime', TFhirDateTime(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(this, 'Extension', 'valueUnsignedInt', TFhirUnsignedInt(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) {1} then
    ComposeCode(this, 'Extension', 'valueCode', TFhirCode(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) {1} then
    ComposeDate(this, 'Extension', 'valueDate', TFhirDate(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) {1} then
    ComposeDecimal(this, 'Extension', 'valueDecimal', TFhirDecimal(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) {1} then
    ComposeUri(this, 'Extension', 'valueUri', TFhirUri(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) {1} then
    ComposeId(this, 'Extension', 'valueId', TFhirId(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) {1} then
    ComposeBase64Binary(this, 'Extension', 'valueBase64Binary', TFhirBase64Binary(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) {1} then
    ComposeTime(this, 'Extension', 'valueTime', TFhirTime(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) {1} then
    ComposeOid(this, 'Extension', 'valueOid', TFhirOid(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) {1} then
    ComposeString(this, 'Extension', 'valueString', TFhirString(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) {1} then
    ComposePositiveInt(this, 'Extension', 'valuePositiveInt', TFhirPositiveInt(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) {1} then
    ComposeBoolean(this, 'Extension', 'valueBoolean', TFhirBoolean(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUuid) {1} then
    ComposeUuid(this, 'Extension', 'valueUuid', TFhirUuid(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) {1} then
    ComposeInstant(this, 'Extension', 'valueInstant', TFhirInstant(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPeriod) {8} then
    ComposePeriod(this, 'Extension', 'valuePeriod', TFhirPeriod(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCoding) {8} then
    ComposeCoding(false, this, 'Extension', 'valueCoding', TFhirCoding(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRange) {8} then
    ComposeRange(this, 'Extension', 'valueRange', TFhirRange(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAttachment) {8} then
    ComposeAttachment(this, 'Extension', 'valueAttachment', TFhirAttachment(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirQuantity) {8} then
    ComposeQuantity(this, 'Extension', 'valueQuantity', TFhirQuantity(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAnnotation) {8} then
    ComposeAnnotation(this, 'Extension', 'valueAnnotation', TFhirAnnotation(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRatio) {8} then
    ComposeRatio(this, 'Extension', 'valueRatio', TFhirRatio(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSampledData) {8} then
    ComposeSampledData(this, 'Extension', 'valueSampledData', TFhirSampledData(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(this, 'Extension', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirReference) {8} then
    ComposeReference(this, 'Extension', 'valueReference', TFhirReference(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirIdentifier) {8} then
    ComposeIdentifier(this, 'Extension', 'valueIdentifier', TFhirIdentifier(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSignature) {8} then
    ComposeSignature(this, 'Extension', 'valueSignature', TFhirSignature(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTiming) {9} then
    ComposeTiming(this, 'Extension', 'valueTiming', TFhirTiming(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirElementDefinition) {9} then
    ComposeElementDefinition(this, 'Extension', 'valueElementDefinition', TFhirElementDefinition(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirHumanName) {9} then
    ComposeHumanName(this, 'Extension', 'valueHumanName', TFhirHumanName(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAddress) {9} then
    ComposeAddress(this, 'Extension', 'valueAddress', TFhirAddress(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMeta) {9} then
    ComposeMeta(this, 'Extension', 'valueMeta', TFhirMeta(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactPoint) {9} then
    ComposeContactPoint(this, 'Extension', 'valueContactPoint', TFhirContactPoint(elem.value), -1);
end;

function TFHIRXmlParser.ParseNarrative(element : IXmlDomElement; path : string) : TFhirNarrative;
var
  child : IXMLDOMElement;
begin
  result := TFhirNarrative.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirNarrativeStatusEnum, SYSTEMS_TFhirNarrativeStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'div') then
        result.div_ := ParseXHtmlNode(child, path+'/div') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNarrative(xml : TXmlBuilder; name : string; elem : TFhirNarrative);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirNarrativeStatusEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeXHtmlNode(xml, 'div', elem.div_);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNarrative(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNarrative(jsn)); {2}
end;

function TFHIRJsonParser.ParseNarrative(jsn : TJsonObject) : TFhirNarrative;
begin
  result := TFhirNarrative.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirNarrativeStatusEnum, SYSTEMS_TFhirNarrativeStatusEnum);
    if jsn.has('div') then
        result.div_ := ParseXHtmlNode(jsn.path+'.div', jsn['div']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNarrative(json : TJSONWriter; name : string; elem : TFhirNarrative; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirNarrativeStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirNarrativeStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeXHtmlNode(json, 'div', elem.div_); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeNarrative(parent :  TRDFComplex; parentType, name : String; elem : TFhirNarrative; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Narrative');
  end;
  composeElement(this, 'Narrative', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(this, 'Narrative', 'status', elem.StatusElement, CODES_TFhirNarrativeStatusEnum, SYSTEMS_TFhirNarrativeStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeXHtmlNode(this, 'Narrative', 'div', elem.div_Element, -1);{x.2}
end;

function TFHIRXmlParser.ParsePeriod(element : IXmlDomElement; path : string) : TFhirPeriod;
var
  child : IXMLDOMElement;
begin
  result := TFhirPeriod.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'start') then
        result.startElement := ParseDateTime(child, path+'/start') {b}
      else if (child.baseName = 'end') then
        result.end_Element := ParseDateTime(child, path+'/end') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePeriod(xml : TXmlBuilder; name : string; elem : TFhirPeriod);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(xml, 'start', elem.startElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(xml, 'end', elem.end_Element);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePeriod(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePeriod(jsn)); {2}
end;

function TFHIRJsonParser.ParsePeriod(jsn : TJsonObject) : TFhirPeriod;
begin
  result := TFhirPeriod.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := ParseDateTime(jsn['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := ParseDateTime(jsn['end'], jsn.vObj['_end']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePeriod(json : TJSONWriter; name : string; elem : TFhirPeriod; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeValue(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeProps(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeValue(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeProps(json, 'end', elem.end_Element, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposePeriod(parent :  TRDFComplex; parentType, name : String; elem : TFhirPeriod; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Period');
  end;
  composeElement(this, 'Period', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(this, 'Period', 'start', elem.startElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(this, 'Period', 'end', elem.end_Element, -1);{x.2}
end;

function TFHIRXmlParser.ParseCoding(element : IXmlDomElement; path : string) : TFhirCoding;
var
  child : IXMLDOMElement;
begin
  result := TFhirCoding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'display') then
        result.displayElement := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'userSelected') then
        result.userSelectedElement := ParseBoolean(child, path+'/userSelected') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCoding(xml : TXmlBuilder; name : string; elem : TFhirCoding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'system', elem.systemElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBoolean(xml, 'userSelected', elem.userSelectedElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCoding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoding(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoding(jsn : TJsonObject) : TFhirCoding;
begin
  result := TFhirCoding.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('userSelected') or jsn.has('_userSelected') then
        result.userSelectedElement := ParseBoolean(jsn['userSelected'], jsn.vObj['_userSelected']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCoding(json : TJSONWriter; name : string; elem : TFhirCoding; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanValue(json, 'userSelected', elem.userSelectedElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanProps(json, 'userSelected', elem.userSelectedElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeCoding(inCodeable : boolean; parent :  TRDFComplex; parentType, name : String; elem : TFhirCoding; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    if inCodeable then
      this.predicate('a', 'fhir:CodingBase')
    else
      this.predicate('a', 'fhir:Coding');
  end;
  if not inCodeable then
  begin
    this.predicate('a', 'fhir:ConceptBase');
    this := this.predicate('fhir:ConceptBase.coding');
    this.predicate('a', 'fhir:CodingBase');
  end;
  composeElement(this, 'CodingBase', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'CodingBase', 'system', elem.systemElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'CodingBase', 'version', elem.versionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'CodingBase', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'CodingBase', 'display', elem.displayElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBoolean(this, 'CodingBase', 'userSelected', elem.userSelectedElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseRange(element : IXmlDomElement; path : string) : TFhirRange;
var
  child : IXMLDOMElement;
begin
  result := TFhirRange.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'low') then
        result.low := ParseQuantity(child, path+'/low') {b}
      else if (child.baseName = 'high') then
        result.high := ParseQuantity(child, path+'/high') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRange(xml : TXmlBuilder; name : string; elem : TFhirRange);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(xml, 'low', elem.low);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(xml, 'high', elem.high);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRange(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRange(jsn)); {2}
end;

function TFHIRJsonParser.ParseRange(jsn : TJsonObject) : TFhirRange;
begin
  result := TFhirRange.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('low') then
        result.low := ParseQuantity(jsn.vObj['low']);{q}
    if jsn.has('high') then
        result.high := ParseQuantity(jsn.vObj['high']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRange(json : TJSONWriter; name : string; elem : TFhirRange; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'low', elem.low); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'high', elem.high); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeRange(parent :  TRDFComplex; parentType, name : String; elem : TFhirRange; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Range');
  end;
  composeElement(this, 'Range', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Range', 'low', elem.lowElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Range', 'high', elem.highElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseAttachment(element : IXmlDomElement; path : string) : TFhirAttachment;
var
  child : IXMLDOMElement;
begin
  result := TFhirAttachment.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'contentType') then
        result.contentTypeElement := ParseCode(child, path+'/contentType') {b}
      else if (child.baseName = 'language') then
        result.languageElement := ParseCode(child, path+'/language') {b}
      else if (child.baseName = 'data') then
        result.dataElement := ParseBase64Binary(child, path+'/data') {b}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'size') then
        result.sizeElement := ParseUnsignedInt(child, path+'/size') {b}
      else if (child.baseName = 'hash') then
        result.hashElement := ParseBase64Binary(child, path+'/hash') {b}
      else if (child.baseName = 'title') then
        result.titleElement := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'creation') then
        result.creationElement := ParseDateTime(child, path+'/creation') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAttachment(xml : TXmlBuilder; name : string; elem : TFhirAttachment);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(xml, 'contentType', elem.contentTypeElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(xml, 'language', elem.languageElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(xml, 'data', elem.dataElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedInt(xml, 'size', elem.sizeElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(xml, 'hash', elem.hashElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'title', elem.titleElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(xml, 'creation', elem.creationElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAttachment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAttachment(jsn)); {2}
end;

function TFHIRJsonParser.ParseAttachment(jsn : TJsonObject) : TFhirAttachment;
begin
  result := TFhirAttachment.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('contentType') or jsn.has('_contentType') then
        result.contentTypeElement := ParseCode(jsn['contentType'], jsn.vObj['_contentType']);{q}
    if jsn.has('language') or jsn.has('_language') then
        result.languageElement := ParseCode(jsn['language'], jsn.vObj['_language']);{q}
    if jsn.has('data') or jsn.has('_data') then
        result.dataElement := ParseBase64Binary(jsn['data'], jsn.vObj['_data']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('size') or jsn.has('_size') then
        result.sizeElement := ParseUnsignedInt(jsn['size'], jsn.vObj['_size']);{q}
    if jsn.has('hash') or jsn.has('_hash') then
        result.hashElement := ParseBase64Binary(jsn['hash'], jsn.vObj['_hash']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('creation') or jsn.has('_creation') then
        result.creationElement := ParseDateTime(jsn['creation'], jsn.vObj['_creation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAttachment(json : TJSONWriter; name : string; elem : TFhirAttachment; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeValue(json, 'contentType', elem.contentTypeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeProps(json, 'contentType', elem.contentTypeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeValue(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeProps(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64BinaryValue(json, 'data', elem.dataElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64BinaryProps(json, 'data', elem.dataElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedIntValue(json, 'size', elem.sizeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedIntProps(json, 'size', elem.sizeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64BinaryValue(json, 'hash', elem.hashElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64BinaryProps(json, 'hash', elem.hashElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeValue(json, 'creation', elem.creationElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeProps(json, 'creation', elem.creationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeAttachment(parent :  TRDFComplex; parentType, name : String; elem : TFhirAttachment; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Attachment');
  end;
  composeElement(this, 'Attachment', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Attachment', 'contentType', elem.contentTypeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Attachment', 'language', elem.languageElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(this, 'Attachment', 'data', elem.dataElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Attachment', 'url', elem.urlElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedInt(this, 'Attachment', 'size', elem.sizeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(this, 'Attachment', 'hash', elem.hashElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Attachment', 'title', elem.titleElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(this, 'Attachment', 'creation', elem.creationElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseQuantity(element : IXmlDomElement; path : string) : TFhirQuantity;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuantity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'value') then
        result.valueElement := ParseDecimal(child, path+'/value') {b}
      else if (child.baseName = 'comparator') then
        result.comparatorElement := ParseEnum(CODES_TFhirQuantityComparatorEnum, SYSTEMS_TFhirQuantityComparatorEnum, path+'/comparator', child){1a}
      else if (child.baseName = 'unit') then
        result.unit_Element := ParseString(child, path+'/unit') {b}
      else if (child.baseName = 'system') then
        result.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuantity(xml : TXmlBuilder; name : string; elem : TFhirQuantity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(xml, 'value', elem.valueElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(xml, 'comparator', elem.ComparatorElement, CODES_TFhirQuantityComparatorEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'unit', elem.unit_Element);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'system', elem.systemElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuantity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuantity(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuantity(jsn : TJsonObject) : TFhirQuantity;
begin
  result := TFhirQuantity.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn['value'], jsn.vObj['_value']);{q}
    if jsn.has('comparator') or jsn.has('_comparator')  then
      result.comparatorElement := parseEnum(jsn.path+'/comparator', jsn['comparator'], jsn.vObj['_comparator'], CODES_TFhirQuantityComparatorEnum, SYSTEMS_TFhirQuantityComparatorEnum);
    if jsn.has('unit') or jsn.has('_unit') then
        result.unit_Element := ParseString(jsn['unit'], jsn.vObj['_unit']);{q}
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuantity(json : TJSONWriter; name : string; elem : TFhirQuantity; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumValue(json, 'comparator', elem.ComparatorElement, CODES_TFhirQuantityComparatorEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumProps(json, 'comparator', elem.ComparatorElement, CODES_TFhirQuantityComparatorEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'unit', elem.unit_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'unit', elem.unit_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeQuantity(parent :  TRDFComplex; parentType, name : String; elem : TFhirQuantity; index : integer);
var
  this : TRDFComplex;
var
  cb, c : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Quantity');
  end;
  composeElement(this, 'Quantity', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'Quantity', 'value', elem.valueElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(this, 'Quantity', 'comparator', elem.ComparatorElement, CODES_TFhirQuantityComparatorEnum, SYSTEMS_TFhirQuantityComparatorEnum, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Quantity', 'unit', elem.unit_Element, -1);{x.2}
  // special case. system and code are simplified Coding, so we use the generic Coding approach
  if (SummaryOption in [soFull, soSummary, soText, soData]) and ((elem.systemElement <> nil) or (elem.codeElement <> nil)) then
  begin
    cb := this.predicate('fhir:Quantity.code');
    cb.predicate('a', 'fhir:ConceptBase');
    c := cb.predicate('fhir:ConceptBase.coding');
    ComposeUri(c, 'CodingBase', 'system', elem.systemElement, -1);
    ComposeCode(c, 'CodingBase', 'code', elem.codeElement, -1);
    if elem.unit_Element <> nil then
      ComposeString(cb, 'ConceptBase', 'text', elem.unit_Element, -1);
  end;
end;

function TFHIRXmlParser.ParseAnnotation(element : IXmlDomElement; path : string) : TFhirAnnotation;
var
  child : IXMLDOMElement;
begin
  result := TFhirAnnotation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'authorReference') then
        result.author := ParseReference(child, path+'/authorReference') {a}
      else if (child.baseName = 'authorString') then
        result.author := ParseString(child, path+'/authorString'){x.3}
      else if (child.baseName = 'time') then
        result.timeElement := ParseDateTime(child, path+'/time') {b}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAnnotation(xml : TXmlBuilder; name : string; elem : TFhirAnnotation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirReference) {2} then
    ComposeReference(xml, 'authorReference', TFhirReference(elem.author))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirString) {6} then
    ComposeString(xml, 'authorString', TFhirString(elem.author));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(xml, 'time', elem.timeElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAnnotation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAnnotation(jsn)); {2}
end;

function TFHIRJsonParser.ParseAnnotation(jsn : TJsonObject) : TFhirAnnotation;
begin
  result := TFhirAnnotation.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('authorReference') {a3} then
      result.author := ParseReference(jsn.vObj['authorReference']);
    if jsn.has('authorString') or jsn.has('_authorString') then
      result.author := parseString(jsn['authorString'], jsn.vObj['_authorString']);
    if jsn.has('time') or jsn.has('_time') then
        result.timeElement := ParseDateTime(jsn['time'], jsn.vObj['_time']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAnnotation(json : TJSONWriter; name : string; elem : TFhirAnnotation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirReference) then
    ComposeReference(json, 'authorReference', TFhirReference(elem.author))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirString) then 
  begin
    ComposeStringValue(json, 'authorString', TFhirString(elem.author), false);
    ComposeStringProps(json, 'authorString', TFhirString(elem.author), false);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeValue(json, 'time', elem.timeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeProps(json, 'time', elem.timeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeAnnotation(parent :  TRDFComplex; parentType, name : String; elem : TFhirAnnotation; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Annotation');
  end;
  composeElement(this, 'Annotation', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirReference) {2} then
    ComposeReference(this, 'Annotation', 'authorReference', TFhirReference(elem.author), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirString) {6} then
    ComposeString(this, 'Annotation', 'authorString', TFhirString(elem.author), -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(this, 'Annotation', 'time', elem.timeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Annotation', 'text', elem.textElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseRatio(element : IXmlDomElement; path : string) : TFhirRatio;
var
  child : IXMLDOMElement;
begin
  result := TFhirRatio.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'numerator') then
        result.numerator := ParseQuantity(child, path+'/numerator') {b}
      else if (child.baseName = 'denominator') then
        result.denominator := ParseQuantity(child, path+'/denominator') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRatio(xml : TXmlBuilder; name : string; elem : TFhirRatio);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(xml, 'numerator', elem.numerator);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(xml, 'denominator', elem.denominator);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRatio(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRatio(jsn)); {2}
end;

function TFHIRJsonParser.ParseRatio(jsn : TJsonObject) : TFhirRatio;
begin
  result := TFhirRatio.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('numerator') then
        result.numerator := ParseQuantity(jsn.vObj['numerator']);{q}
    if jsn.has('denominator') then
        result.denominator := ParseQuantity(jsn.vObj['denominator']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRatio(json : TJSONWriter; name : string; elem : TFhirRatio; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'numerator', elem.numerator); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'denominator', elem.denominator); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeRatio(parent :  TRDFComplex; parentType, name : String; elem : TFhirRatio; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Ratio');
  end;
  composeElement(this, 'Ratio', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Ratio', 'numerator', elem.numeratorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Ratio', 'denominator', elem.denominatorElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseSampledData(element : IXmlDomElement; path : string) : TFhirSampledData;
var
  child : IXMLDOMElement;
begin
  result := TFhirSampledData.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'origin') then
        result.origin := ParseQuantity(child, path+'/origin') {b}
      else if (child.baseName = 'period') then
        result.periodElement := ParseDecimal(child, path+'/period') {b}
      else if (child.baseName = 'factor') then
        result.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.baseName = 'lowerLimit') then
        result.lowerLimitElement := ParseDecimal(child, path+'/lowerLimit') {b}
      else if (child.baseName = 'upperLimit') then
        result.upperLimitElement := ParseDecimal(child, path+'/upperLimit') {b}
      else if (child.baseName = 'dimensions') then
        result.dimensionsElement := ParsePositiveInt(child, path+'/dimensions') {b}
      else if (child.baseName = 'data') then
        result.dataElement := ParseString(child, path+'/data') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSampledData(xml : TXmlBuilder; name : string; elem : TFhirSampledData);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(xml, 'origin', elem.origin);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(xml, 'period', elem.periodElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(xml, 'lowerLimit', elem.lowerLimitElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(xml, 'upperLimit', elem.upperLimitElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveInt(xml, 'dimensions', elem.dimensionsElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'data', elem.dataElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSampledData(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSampledData(jsn)); {2}
end;

function TFHIRJsonParser.ParseSampledData(jsn : TJsonObject) : TFhirSampledData;
begin
  result := TFhirSampledData.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('origin') then
        result.origin := ParseQuantity(jsn.vObj['origin']);{q}
    if jsn.has('period') or jsn.has('_period') then
        result.periodElement := ParseDecimal(jsn['period'], jsn.vObj['_period']);{q}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('lowerLimit') or jsn.has('_lowerLimit') then
        result.lowerLimitElement := ParseDecimal(jsn['lowerLimit'], jsn.vObj['_lowerLimit']);{q}
    if jsn.has('upperLimit') or jsn.has('_upperLimit') then
        result.upperLimitElement := ParseDecimal(jsn['upperLimit'], jsn.vObj['_upperLimit']);{q}
    if jsn.has('dimensions') or jsn.has('_dimensions') then
        result.dimensionsElement := ParsePositiveInt(jsn['dimensions'], jsn.vObj['_dimensions']);{q}
    if jsn.has('data') or jsn.has('_data') then
        result.dataElement := ParseString(jsn['data'], jsn.vObj['_data']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSampledData(json : TJSONWriter; name : string; elem : TFhirSampledData; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'origin', elem.origin); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalValue(json, 'period', elem.periodElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalProps(json, 'period', elem.periodElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalValue(json, 'lowerLimit', elem.lowerLimitElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalProps(json, 'lowerLimit', elem.lowerLimitElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalValue(json, 'upperLimit', elem.upperLimitElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalProps(json, 'upperLimit', elem.upperLimitElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveIntValue(json, 'dimensions', elem.dimensionsElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveIntProps(json, 'dimensions', elem.dimensionsElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'data', elem.dataElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'data', elem.dataElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeSampledData(parent :  TRDFComplex; parentType, name : String; elem : TFhirSampledData; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:SampledData');
  end;
  composeElement(this, 'SampledData', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'SampledData', 'origin', elem.originElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'SampledData', 'period', elem.periodElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'SampledData', 'factor', elem.factorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'SampledData', 'lowerLimit', elem.lowerLimitElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'SampledData', 'upperLimit', elem.upperLimitElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveInt(this, 'SampledData', 'dimensions', elem.dimensionsElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'SampledData', 'data', elem.dataElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseCodeableConcept(element : IXmlDomElement; path : string) : TFhirCodeableConcept;
var
  child : IXMLDOMElement;
begin
  result := TFhirCodeableConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'coding') then
        result.codingList.Add(ParseCoding(child, path+'/coding')){y.2}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCodeableConcept(xml : TXmlBuilder; name : string; elem : TFhirCodeableConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.codingList.Count - 1 do
      ComposeCoding(xml, 'coding', elem.codingList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCodeableConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCodeableConcept(jsn)); {2}
end;

function TFHIRJsonParser.ParseCodeableConcept(jsn : TJsonObject) : TFhirCodeableConcept;
begin
  result := TFhirCodeableConcept.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('coding') then
      iterateArray(jsn.vArr['coding'], result.codingList, parseCoding);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCodeableConcept(json : TJSONWriter; name : string; elem : TFhirCodeableConcept; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.codingList.Count > 0) then
  begin
    json.valueArray('coding');
    for i := 0 to elem.codingList.Count - 1 do
      ComposeCoding(json, '', elem.codingList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeCodeableConcept(parent :  TRDFComplex; parentType, name : String; elem : TFhirCodeableConcept; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:CodeableConcept');
    this.predicate('a', 'fhir:ConceptBase');
  end;
  composeElement(this, 'ConceptBase', name, elem, index);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.codingList.Count - 1 do
      ComposeCoding(true, this, 'ConceptBase', 'coding', elem.codingList[i], i);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ConceptBase', 'text', elem.textElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseReference(element : IXmlDomElement; path : string) : TFhirReference;
var
  child : IXMLDOMElement;
begin
  result := TFhirReference.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'reference') then
        result.referenceElement := ParseString(child, path+'/reference') {b}
      else if (child.baseName = 'display') then
        result.displayElement := ParseString(child, path+'/display') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeReference(xml : TXmlBuilder; name : string; elem : TFhirReference);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'reference', elem.referenceElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseReference(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseReference(jsn)); {2}
end;

function TFHIRJsonParser.ParseReference(jsn : TJsonObject) : TFhirReference;
begin
  result := TFhirReference.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceElement := ParseString(jsn['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeReference(json : TJSONWriter; name : string; elem : TFhirReference; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeReference(parent :  TRDFComplex; parentType, name : String; elem : TFhirReference; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Reference');
  end;
  composeElement(this, 'Reference', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Reference', 'reference', elem.referenceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Reference', 'display', elem.displayElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseIdentifier(element : IXmlDomElement; path : string) : TFhirIdentifier;
var
  child : IXMLDOMElement;
begin
  result := TFhirIdentifier.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'use') then
        result.useElement := ParseEnum(CODES_TFhirIdentifierUseEnum, SYSTEMS_TFhirIdentifierUseEnum, path+'/use', child){1a}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'system') then
        result.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseString(child, path+'/value') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'assigner') then
        result.assigner := ParseReference{TFhirOrganization}(child, path+'/assigner') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeIdentifier(xml : TXmlBuilder; name : string; elem : TFhirIdentifier);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirIdentifierUseEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'system', elem.systemElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'value', elem.valueElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'assigner', elem.assigner);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseIdentifier(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseIdentifier(jsn)); {2}
end;

function TFHIRJsonParser.ParseIdentifier(jsn : TJsonObject) : TFhirIdentifier;
begin
  result := TFhirIdentifier.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn['use'], jsn.vObj['_use'], CODES_TFhirIdentifierUseEnum, SYSTEMS_TFhirIdentifierUseEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('assigner') then
        result.assigner := ParseReference{TFhirOrganization}(jsn.vObj['assigner']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeIdentifier(json : TJSONWriter; name : string; elem : TFhirIdentifier; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirIdentifierUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirIdentifierUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeReference{TFhirOrganization}(json, 'assigner', elem.assigner); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeIdentifier(parent :  TRDFComplex; parentType, name : String; elem : TFhirIdentifier; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Identifier');
  end;
  composeElement(this, 'Identifier', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(this, 'Identifier', 'use', elem.UseElement, CODES_TFhirIdentifierUseEnum, SYSTEMS_TFhirIdentifierUseEnum, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'Identifier', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Identifier', 'system', elem.systemElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Identifier', 'value', elem.valueElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(this, 'Identifier', 'period', elem.periodElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Identifier', 'assigner', elem.assignerElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseSignature(element : IXmlDomElement; path : string) : TFhirSignature;
var
  child : IXMLDOMElement;
begin
  result := TFhirSignature.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_List.Add(ParseCoding(child, path+'/type')){y.2}
      else if (child.baseName = 'when') then
        result.whenElement := ParseInstant(child, path+'/when') {b}
      else if (child.baseName = 'whoUri') then
        result.who := ParseUri(child, path+'/whoUri'){x.3}
      else if (child.baseName = 'whoReference') then
        result.who := ParseReference(child, path+'/whoReference') {a}
      else if (child.baseName = 'contentType') then
        result.contentTypeElement := ParseCode(child, path+'/contentType') {b}
      else if (child.baseName = 'blob') then
        result.blobElement := ParseBase64Binary(child, path+'/blob') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSignature(xml : TXmlBuilder; name : string; elem : TFhirSignature);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(xml, 'when', elem.whenElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.who is TFhirUri) {6} then
    ComposeUri(xml, 'whoUri', TFhirUri(elem.who))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.who is TFhirReference) {2} then
    ComposeReference(xml, 'whoReference', TFhirReference(elem.who));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(xml, 'contentType', elem.contentTypeElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(xml, 'blob', elem.blobElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSignature(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSignature(jsn)); {2}
end;

function TFHIRJsonParser.ParseSignature(jsn : TJsonObject) : TFhirSignature;
begin
  result := TFhirSignature.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCoding);
    if jsn.has('when') or jsn.has('_when') then
        result.whenElement := ParseInstant(jsn['when'], jsn.vObj['_when']);{q}
    if jsn.has('whoUri') or jsn.has('_whoUri') then
      result.who := parseUri(jsn['whoUri'], jsn.vObj['_whoUri']);
    if jsn.has('whoReference') {a3} then
      result.who := ParseReference(jsn.vObj['whoReference']);
    if jsn.has('contentType') or jsn.has('_contentType') then
        result.contentTypeElement := ParseCode(jsn['contentType'], jsn.vObj['_contentType']);{q}
    if jsn.has('blob') or jsn.has('_blob') then
        result.blobElement := ParseBase64Binary(jsn['blob'], jsn.vObj['_blob']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSignature(json : TJSONWriter; name : string; elem : TFhirSignature; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(json, '', elem.type_List[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantValue(json, 'when', elem.whenElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantProps(json, 'when', elem.whenElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.who is TFhirUri) then 
  begin
    ComposeUriValue(json, 'whoUri', TFhirUri(elem.who), false);
    ComposeUriProps(json, 'whoUri', TFhirUri(elem.who), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.who is TFhirReference) then
    ComposeReference(json, 'whoReference', TFhirReference(elem.who));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeValue(json, 'contentType', elem.contentTypeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeProps(json, 'contentType', elem.contentTypeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64BinaryValue(json, 'blob', elem.blobElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64BinaryProps(json, 'blob', elem.blobElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeSignature(parent :  TRDFComplex; parentType, name : String; elem : TFhirSignature; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Signature');
  end;
  composeElement(this, 'Signature', name, elem, index);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(false, this, 'Signature', 'type', elem.type_List[i], i);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(this, 'Signature', 'when', elem.whenElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.who is TFhirUri) {6} then
    ComposeUri(this, 'Signature', 'whoUri', TFhirUri(elem.who), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.who is TFhirReference) {2} then
    ComposeReference(this, 'Signature', 'whoReference', TFhirReference(elem.who), -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Signature', 'contentType', elem.contentTypeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(this, 'Signature', 'blob', elem.blobElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseTimingRepeat(element : IXmlDomElement; path : string) : TFhirTimingRepeat;
var
  child : IXMLDOMElement;
begin
  result := TFhirTimingRepeat.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'boundsQuantity') then
        result.bounds := ParseQuantity(child, path+'/boundsQuantity'){x.3}
      else if (child.baseName = 'boundsRange') then
        result.bounds := ParseRange(child, path+'/boundsRange'){x.3}
      else if (child.baseName = 'boundsPeriod') then
        result.bounds := ParsePeriod(child, path+'/boundsPeriod'){x.3}
      else if (child.baseName = 'count') then
        result.countElement := ParseInteger(child, path+'/count') {b}
      else if (child.baseName = 'duration') then
        result.durationElement := ParseDecimal(child, path+'/duration') {b}
      else if (child.baseName = 'durationMax') then
        result.durationMaxElement := ParseDecimal(child, path+'/durationMax') {b}
      else if (child.baseName = 'durationUnits') then
        result.durationUnitsElement := ParseEnum(CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, path+'/durationUnits', child){1a}
      else if (child.baseName = 'frequency') then
        result.frequencyElement := ParseInteger(child, path+'/frequency') {b}
      else if (child.baseName = 'frequencyMax') then
        result.frequencyMaxElement := ParseInteger(child, path+'/frequencyMax') {b}
      else if (child.baseName = 'period') then
        result.periodElement := ParseDecimal(child, path+'/period') {b}
      else if (child.baseName = 'periodMax') then
        result.periodMaxElement := ParseDecimal(child, path+'/periodMax') {b}
      else if (child.baseName = 'periodUnits') then
        result.periodUnitsElement := ParseEnum(CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, path+'/periodUnits', child){1a}
      else if (child.baseName = 'when') then
        result.whenElement := ParseEnum(CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum, path+'/when', child){1a}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTimingRepeat(xml : TXmlBuilder; name : string; elem : TFhirTimingRepeat);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'boundsQuantity', TFhirQuantity(elem.bounds))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirRange) {6} then
    ComposeRange(xml, 'boundsRange', TFhirRange(elem.bounds))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirPeriod) {6} then
    ComposePeriod(xml, 'boundsPeriod', TFhirPeriod(elem.bounds));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'count', elem.countElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'duration', elem.durationElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'durationMax', elem.durationMaxElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'durationUnits', elem.DurationUnitsElement, CODES_TFhirUnitsOfTimeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'frequency', elem.frequencyElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'frequencyMax', elem.frequencyMaxElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'period', elem.periodElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'periodMax', elem.periodMaxElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'periodUnits', elem.PeriodUnitsElement, CODES_TFhirUnitsOfTimeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'when', elem.WhenElement, CODES_TFhirEventTimingEnum);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTimingRepeat(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTimingRepeat(jsn)); {2}
end;

function TFHIRJsonParser.ParseTimingRepeat(jsn : TJsonObject) : TFhirTimingRepeat;
begin
  result := TFhirTimingRepeat.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('boundsQuantity') {a4} then
      result.bounds := ParseQuantity(jsn.vObj['boundsQuantity']);
    if jsn.has('boundsRange') {a4} then
      result.bounds := ParseRange(jsn.vObj['boundsRange']);
    if jsn.has('boundsPeriod') {a4} then
      result.bounds := ParsePeriod(jsn.vObj['boundsPeriod']);
    if jsn.has('count') or jsn.has('_count') then
        result.countElement := ParseInteger(jsn['count'], jsn.vObj['_count']);{q}
    if jsn.has('duration') or jsn.has('_duration') then
        result.durationElement := ParseDecimal(jsn['duration'], jsn.vObj['_duration']);{q}
    if jsn.has('durationMax') or jsn.has('_durationMax') then
        result.durationMaxElement := ParseDecimal(jsn['durationMax'], jsn.vObj['_durationMax']);{q}
    if jsn.has('durationUnits') or jsn.has('_durationUnits')  then
      result.durationUnitsElement := parseEnum(jsn.path+'/durationUnits', jsn['durationUnits'], jsn.vObj['_durationUnits'], CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum);
    if jsn.has('frequency') or jsn.has('_frequency') then
        result.frequencyElement := ParseInteger(jsn['frequency'], jsn.vObj['_frequency']);{q}
    if jsn.has('frequencyMax') or jsn.has('_frequencyMax') then
        result.frequencyMaxElement := ParseInteger(jsn['frequencyMax'], jsn.vObj['_frequencyMax']);{q}
    if jsn.has('period') or jsn.has('_period') then
        result.periodElement := ParseDecimal(jsn['period'], jsn.vObj['_period']);{q}
    if jsn.has('periodMax') or jsn.has('_periodMax') then
        result.periodMaxElement := ParseDecimal(jsn['periodMax'], jsn.vObj['_periodMax']);{q}
    if jsn.has('periodUnits') or jsn.has('_periodUnits')  then
      result.periodUnitsElement := parseEnum(jsn.path+'/periodUnits', jsn['periodUnits'], jsn.vObj['_periodUnits'], CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum);
    if jsn.has('when') or jsn.has('_when')  then
      result.whenElement := parseEnum(jsn.path+'/when', jsn['when'], jsn.vObj['_when'], CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTimingRepeat(json : TJSONWriter; name : string; elem : TFhirTimingRepeat; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirQuantity) then 
    ComposeQuantity(json, 'boundsQuantity', TFhirQuantity(elem.bounds)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirRange) then 
    ComposeRange(json, 'boundsRange', TFhirRange(elem.bounds)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirPeriod) then 
    ComposePeriod(json, 'boundsPeriod', TFhirPeriod(elem.bounds)) ;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'count', elem.countElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'count', elem.countElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'duration', elem.durationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'duration', elem.durationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'durationMax', elem.durationMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'durationMax', elem.durationMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'durationUnits', elem.DurationUnitsElement, CODES_TFhirUnitsOfTimeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'durationUnits', elem.DurationUnitsElement, CODES_TFhirUnitsOfTimeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'frequency', elem.frequencyElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'frequency', elem.frequencyElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'frequencyMax', elem.frequencyMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'frequencyMax', elem.frequencyMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'period', elem.periodElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'period', elem.periodElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'periodMax', elem.periodMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'periodMax', elem.periodMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'periodUnits', elem.PeriodUnitsElement, CODES_TFhirUnitsOfTimeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'periodUnits', elem.PeriodUnitsElement, CODES_TFhirUnitsOfTimeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'when', elem.WhenElement, CODES_TFhirEventTimingEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'when', elem.WhenElement, CODES_TFhirEventTimingEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeTimingRepeat(parent :  TRDFComplex; parentType, name : String; elem : TFhirTimingRepeat; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:TimingRepeat');
  end;
  composeElement(this, 'TimingRepeat', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirQuantity) {6} then
    ComposeQuantity(this, 'TimingRepeat', 'boundsQuantity', TFhirQuantity(elem.bounds), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirRange) {6} then
    ComposeRange(this, 'TimingRepeat', 'boundsRange', TFhirRange(elem.bounds), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirPeriod) {6} then
    ComposePeriod(this, 'TimingRepeat', 'boundsPeriod', TFhirPeriod(elem.bounds), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'TimingRepeat', 'count', elem.countElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'TimingRepeat', 'duration', elem.durationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'TimingRepeat', 'durationMax', elem.durationMaxElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'TimingRepeat', 'durationUnits', elem.DurationUnitsElement, CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'TimingRepeat', 'frequency', elem.frequencyElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'TimingRepeat', 'frequencyMax', elem.frequencyMaxElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'TimingRepeat', 'period', elem.periodElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'TimingRepeat', 'periodMax', elem.periodMaxElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'TimingRepeat', 'periodUnits', elem.PeriodUnitsElement, CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'TimingRepeat', 'when', elem.WhenElement, CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum, -1);
end;

function TFHIRXmlParser.ParseTiming(element : IXmlDomElement; path : string) : TFhirTiming;
var
  child : IXMLDOMElement;
begin
  result := TFhirTiming.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'event') then
        result.eventList.Add(ParseDateTime(child, path+'/event')){y.2}
      else if (child.baseName = 'repeat') then
        result.repeat_ := ParseTimingRepeat(child, path+'/repeat') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTiming(xml : TXmlBuilder; name : string; elem : TFhirTiming);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDateTime(xml, 'event', elem.eventList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeTimingRepeat(xml, 'repeat', elem.repeat_);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTiming(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTiming(jsn)); {2}
end;

function TFHIRJsonParser.ParseTiming(jsn : TJsonObject) : TFhirTiming;
begin
  result := TFhirTiming.create;
  try
    ParseElementProperties(jsn, result);
      if jsn.has('event') or jsn.has('_event') then
      iteratePrimitiveArray(jsn.vArr['event'], jsn.vArr['_event'], result.eventList, parseDateTime);
    if jsn.has('repeat') then
        result.repeat_ := ParseTimingRepeat(jsn.vObj['repeat']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTiming(json : TJSONWriter; name : string; elem : TFhirTiming; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.eventList.Count > 0) then
  begin
    json.valueArray('event');
    ext := false;
    for i := 0 to elem.eventList.Count - 1 do
    begin
      ext := ext or ((elem.eventList[i].id <> '') or (elem.eventList[i].hasExtensionList));
      ComposeDateTimeValue(json, '',elem.eventList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_event');
      for i := 0 to elem.eventList.Count - 1 do
        ComposeDateTimeProps(json, '',elem.eventList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeTimingRepeat(json, 'repeat', elem.repeat_); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeTiming(parent :  TRDFComplex; parentType, name : String; elem : TFhirTiming; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Timing');
  end;
  composeElement(this, 'Timing', name, elem, index);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDateTime(this, 'Timing', 'event', elem.eventList[i], i);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeTimingRepeat(this, 'Timing', 'repeat', elem.repeat_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'Timing', 'code', elem.codeElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseElementDefinitionSlicing(element : IXmlDomElement; path : string) : TFhirElementDefinitionSlicing;
var
  child : IXMLDOMElement;
begin
  result := TFhirElementDefinitionSlicing.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'discriminator') then
        result.discriminatorList.Add(ParseString(child, path+'/discriminator')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'ordered') then
        result.orderedElement := ParseBoolean(child, path+'/ordered') {b}
      else if (child.baseName = 'rules') then
        result.rulesElement := ParseEnum(CODES_TFhirResourceSlicingRulesEnum, SYSTEMS_TFhirResourceSlicingRulesEnum, path+'/rules', child){1a}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionSlicing(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionSlicing);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.discriminatorList.Count - 1 do
      ComposeString(xml, 'discriminator', elem.discriminatorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'ordered', elem.orderedElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'rules', elem.RulesElement, CODES_TFhirResourceSlicingRulesEnum);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseElementDefinitionSlicing(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionSlicing(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionSlicing(jsn : TJsonObject) : TFhirElementDefinitionSlicing;
begin
  result := TFhirElementDefinitionSlicing.create;
  try
    ParseElementProperties(jsn, result);
      if jsn.has('discriminator') or jsn.has('_discriminator') then
      iteratePrimitiveArray(jsn.vArr['discriminator'], jsn.vArr['_discriminator'], result.discriminatorList, parseString);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('ordered') or jsn.has('_ordered') then
        result.orderedElement := ParseBoolean(jsn['ordered'], jsn.vObj['_ordered']);{q}
    if jsn.has('rules') or jsn.has('_rules')  then
      result.rulesElement := parseEnum(jsn.path+'/rules', jsn['rules'], jsn.vObj['_rules'], CODES_TFhirResourceSlicingRulesEnum, SYSTEMS_TFhirResourceSlicingRulesEnum);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionSlicing(json : TJSONWriter; name : string; elem : TFhirElementDefinitionSlicing; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.discriminatorList.Count > 0) then
  begin
    json.valueArray('discriminator');
    ext := false;
    for i := 0 to elem.discriminatorList.Count - 1 do
    begin
      ext := ext or ((elem.discriminatorList[i].id <> '') or (elem.discriminatorList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.discriminatorList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_discriminator');
      for i := 0 to elem.discriminatorList.Count - 1 do
        ComposeStringProps(json, '',elem.discriminatorList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'ordered', elem.orderedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'ordered', elem.orderedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'rules', elem.RulesElement, CODES_TFhirResourceSlicingRulesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'rules', elem.RulesElement, CODES_TFhirResourceSlicingRulesEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeElementDefinitionSlicing(parent :  TRDFComplex; parentType, name : String; elem : TFhirElementDefinitionSlicing; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ElementDefinitionSlicing');
  end;
  composeElement(this, 'ElementDefinitionSlicing', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.discriminatorList.Count - 1 do
      ComposeString(this, 'ElementDefinitionSlicing', 'discriminator', elem.discriminatorList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinitionSlicing', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ElementDefinitionSlicing', 'ordered', elem.orderedElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ElementDefinitionSlicing', 'rules', elem.RulesElement, CODES_TFhirResourceSlicingRulesEnum, SYSTEMS_TFhirResourceSlicingRulesEnum, -1);
end;

function TFHIRXmlParser.ParseElementDefinitionBase(element : IXmlDomElement; path : string) : TFhirElementDefinitionBase;
var
  child : IXMLDOMElement;
begin
  result := TFhirElementDefinitionBase.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'path') then
        result.pathElement := ParseString(child, path+'/path') {b}
      else if (child.baseName = 'min') then
        result.minElement := ParseInteger(child, path+'/min') {b}
      else if (child.baseName = 'max') then
        result.maxElement := ParseString(child, path+'/max') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionBase(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionBase);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'path', elem.pathElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'min', elem.minElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'max', elem.maxElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseElementDefinitionBase(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionBase(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionBase(jsn : TJsonObject) : TFhirElementDefinitionBase;
begin
  result := TFhirElementDefinitionBase.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := ParseString(jsn['path'], jsn.vObj['_path']);{q}
    if jsn.has('min') or jsn.has('_min') then
        result.minElement := ParseInteger(jsn['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxElement := ParseString(jsn['max'], jsn.vObj['_max']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionBase(json : TJSONWriter; name : string; elem : TFhirElementDefinitionBase; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'min', elem.minElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'min', elem.minElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'max', elem.maxElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeElementDefinitionBase(parent :  TRDFComplex; parentType, name : String; elem : TFhirElementDefinitionBase; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ElementDefinitionBase');
  end;
  composeElement(this, 'ElementDefinitionBase', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinitionBase', 'path', elem.pathElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'ElementDefinitionBase', 'min', elem.minElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinitionBase', 'max', elem.maxElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseElementDefinitionType(element : IXmlDomElement; path : string) : TFhirElementDefinitionType;
var
  child : IXMLDOMElement;
begin
  result := TFhirElementDefinitionType.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeElement := ParseEnum(CODES_TFhirDefinedTypesEnum, SYSTEMS_TFhirDefinedTypesEnum, path+'/code', child){1a}
      else if (child.baseName = 'profile') then
        result.profileList.Add(ParseUri(child, path+'/profile')){y.2}
      else if (child.baseName = 'aggregation') then
        result.aggregationList.Add(ParseEnum(CODES_TFhirResourceAggregationModeEnum, SYSTEMS_TFhirResourceAggregationModeEnum, path+'/aggregation', child)){y.1}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionType(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionType);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirDefinedTypesEnum);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeUri(xml, 'profile', elem.profileList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.aggregationList.Count - 1 do
      ComposeEnum(xml, 'aggregation', elem.aggregationList[i], CODES_TFhirResourceAggregationModeEnum);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseElementDefinitionType(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionType(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionType(jsn : TJsonObject) : TFhirElementDefinitionType;
begin
  result := TFhirElementDefinitionType.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn['code'], jsn.vObj['_code'], CODES_TFhirDefinedTypesEnum, SYSTEMS_TFhirDefinedTypesEnum);
      if jsn.has('profile') or jsn.has('_profile') then
      iteratePrimitiveArray(jsn.vArr['profile'], jsn.vArr['_profile'], result.profileList, parseUri);
    if jsn.has('aggregation') or jsn.has('_aggregation') then
      iterateEnumArray(jsn.vArr['aggregation'], jsn.vArr['_aggregation'], jsn.path+'/aggregation', result.aggregationList, parseEnum, CODES_TFhirResourceAggregationModeEnum, SYSTEMS_TFhirResourceAggregationModeEnum);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionType(json : TJSONWriter; name : string; elem : TFhirElementDefinitionType; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirDefinedTypesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirDefinedTypesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.profileList.Count > 0) then
  begin
    json.valueArray('profile');
    ext := false;
    for i := 0 to elem.profileList.Count - 1 do
    begin
      ext := ext or ((elem.profileList[i].id <> '') or (elem.profileList[i].hasExtensionList));
      ComposeUriValue(json, '',elem.profileList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_profile');
      for i := 0 to elem.profileList.Count - 1 do
        ComposeUriProps(json, '',elem.profileList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.aggregationList.Count > 0) then
  begin
    json.valueArray('aggregation');
    ext := false;
    for i := 0 to elem.aggregationList.Count - 1 do
    begin
      ext := ext or ((elem.aggregationList[i].id <> '') or (elem.aggregationList[i].hasExtensionList));
      ComposeEnumValue(json, '', elem.aggregationList[i], CODES_TFhirResourceAggregationModeEnum, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_aggregation');
      for i := 0 to elem.aggregationList.Count - 1 do
        ComposeEnumProps(json, '', elem.aggregationList[i], CODES_TFhirResourceAggregationModeEnum, true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeElementDefinitionType(parent :  TRDFComplex; parentType, name : String; elem : TFhirElementDefinitionType; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ElementDefinitionType');
  end;
  composeElement(this, 'ElementDefinitionType', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ElementDefinitionType', 'code', elem.CodeElement, CODES_TFhirDefinedTypesEnum, SYSTEMS_TFhirDefinedTypesEnum, -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeUri(this, 'ElementDefinitionType', 'profile', elem.profileList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.aggregationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinitionType', 'aggregation', elem.aggregationList[i], CODES_TFhirResourceAggregationModeEnum, SYSTEMS_TFhirResourceAggregationModeEnum, i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.aggregationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinitionType', 'aggregation', elem.aggregationList[i], CODES_TFhirResourceAggregationModeEnum, SYSTEMS_TFhirResourceAggregationModeEnum, i);
end;

function TFHIRXmlParser.ParseElementDefinitionConstraint(element : IXmlDomElement; path : string) : TFhirElementDefinitionConstraint;
var
  child : IXMLDOMElement;
begin
  result := TFhirElementDefinitionConstraint.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'key') then
        result.keyElement := ParseId(child, path+'/key') {b}
      else if (child.baseName = 'requirements') then
        result.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'severity') then
        result.severityElement := ParseEnum(CODES_TFhirConstraintSeverityEnum, SYSTEMS_TFhirConstraintSeverityEnum, path+'/severity', child){1a}
      else if (child.baseName = 'human') then
        result.humanElement := ParseString(child, path+'/human') {b}
      else if (child.baseName = 'xpath') then
        result.xpathElement := ParseString(child, path+'/xpath') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionConstraint(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionConstraint);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'key', elem.keyElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'severity', elem.SeverityElement, CODES_TFhirConstraintSeverityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'human', elem.humanElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'xpath', elem.xpathElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseElementDefinitionConstraint(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionConstraint(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionConstraint(jsn : TJsonObject) : TFhirElementDefinitionConstraint;
begin
  result := TFhirElementDefinitionConstraint.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('key') or jsn.has('_key') then
        result.keyElement := ParseId(jsn['key'], jsn.vObj['_key']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityElement := parseEnum(jsn.path+'/severity', jsn['severity'], jsn.vObj['_severity'], CODES_TFhirConstraintSeverityEnum, SYSTEMS_TFhirConstraintSeverityEnum);
    if jsn.has('human') or jsn.has('_human') then
        result.humanElement := ParseString(jsn['human'], jsn.vObj['_human']);{q}
    if jsn.has('xpath') or jsn.has('_xpath') then
        result.xpathElement := ParseString(jsn['xpath'], jsn.vObj['_xpath']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionConstraint(json : TJSONWriter; name : string; elem : TFhirElementDefinitionConstraint; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdValue(json, 'key', elem.keyElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdProps(json, 'key', elem.keyElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'severity', elem.SeverityElement, CODES_TFhirConstraintSeverityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'severity', elem.SeverityElement, CODES_TFhirConstraintSeverityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'human', elem.humanElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'human', elem.humanElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'xpath', elem.xpathElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'xpath', elem.xpathElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeElementDefinitionConstraint(parent :  TRDFComplex; parentType, name : String; elem : TFhirElementDefinitionConstraint; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ElementDefinitionConstraint');
  end;
  composeElement(this, 'ElementDefinitionConstraint', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'ElementDefinitionConstraint', 'key', elem.keyElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinitionConstraint', 'requirements', elem.requirementsElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ElementDefinitionConstraint', 'severity', elem.SeverityElement, CODES_TFhirConstraintSeverityEnum, SYSTEMS_TFhirConstraintSeverityEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinitionConstraint', 'human', elem.humanElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinitionConstraint', 'xpath', elem.xpathElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseElementDefinitionBinding(element : IXmlDomElement; path : string) : TFhirElementDefinitionBinding;
var
  child : IXMLDOMElement;
begin
  result := TFhirElementDefinitionBinding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'strength') then
        result.strengthElement := ParseEnum(CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, path+'/strength', child){1a}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'valueSetUri') then
        result.valueSet := ParseUri(child, path+'/valueSetUri'){x.3}
      else if (child.baseName = 'valueSetReference') then
        result.valueSet := ParseReference(child, path+'/valueSetReference') {a}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionBinding(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionBinding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirUri) {6} then
    ComposeUri(xml, 'valueSetUri', TFhirUri(elem.valueSet))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirReference) {2} then
    ComposeReference(xml, 'valueSetReference', TFhirReference(elem.valueSet));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseElementDefinitionBinding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionBinding(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionBinding(jsn : TJsonObject) : TFhirElementDefinitionBinding;
begin
  result := TFhirElementDefinitionBinding.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('strength') or jsn.has('_strength')  then
      result.strengthElement := parseEnum(jsn.path+'/strength', jsn['strength'], jsn.vObj['_strength'], CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('valueSetUri') or jsn.has('_valueSetUri') then
      result.valueSet := parseUri(jsn['valueSetUri'], jsn.vObj['_valueSetUri']);
    if jsn.has('valueSetReference') {a3} then
      result.valueSet := ParseReference(jsn.vObj['valueSetReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionBinding(json : TJSONWriter; name : string; elem : TFhirElementDefinitionBinding; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueSetUri', TFhirUri(elem.valueSet), false);
    ComposeUriProps(json, 'valueSetUri', TFhirUri(elem.valueSet), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirReference) then
    ComposeReference(json, 'valueSetReference', TFhirReference(elem.valueSet));
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeElementDefinitionBinding(parent :  TRDFComplex; parentType, name : String; elem : TFhirElementDefinitionBinding; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ElementDefinitionBinding');
  end;
  composeElement(this, 'ElementDefinitionBinding', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ElementDefinitionBinding', 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinitionBinding', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirUri) {6} then
    ComposeUri(this, 'ElementDefinitionBinding', 'valueSetUri', TFhirUri(elem.valueSet), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirReference) {2} then
    ComposeReference(this, 'ElementDefinitionBinding', 'valueSetReference', TFhirReference(elem.valueSet), -1);
end;

function TFHIRXmlParser.ParseElementDefinitionMapping(element : IXmlDomElement; path : string) : TFhirElementDefinitionMapping;
var
  child : IXMLDOMElement;
begin
  result := TFhirElementDefinitionMapping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identity') then
        result.identityElement := ParseId(child, path+'/identity') {b}
      else if (child.baseName = 'language') then
        result.languageElement := ParseCode(child, path+'/language') {b}
      else if (child.baseName = 'map') then
        result.mapElement := ParseString(child, path+'/map') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionMapping(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionMapping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'identity', elem.identityElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'language', elem.languageElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'map', elem.mapElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseElementDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionMapping(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionMapping(jsn : TJsonObject) : TFhirElementDefinitionMapping;
begin
  result := TFhirElementDefinitionMapping.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('identity') or jsn.has('_identity') then
        result.identityElement := ParseId(jsn['identity'], jsn.vObj['_identity']);{q}
    if jsn.has('language') or jsn.has('_language') then
        result.languageElement := ParseCode(jsn['language'], jsn.vObj['_language']);{q}
    if jsn.has('map') or jsn.has('_map') then
        result.mapElement := ParseString(jsn['map'], jsn.vObj['_map']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirElementDefinitionMapping; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdValue(json, 'identity', elem.identityElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdProps(json, 'identity', elem.identityElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeValue(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeProps(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'map', elem.mapElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'map', elem.mapElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeElementDefinitionMapping(parent :  TRDFComplex; parentType, name : String; elem : TFhirElementDefinitionMapping; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ElementDefinitionMapping');
  end;
  composeElement(this, 'ElementDefinitionMapping', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'ElementDefinitionMapping', 'identity', elem.identityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'ElementDefinitionMapping', 'language', elem.languageElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinitionMapping', 'map', elem.mapElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseElementDefinition(element : IXmlDomElement; path : string) : TFhirElementDefinition;
var
  child : IXMLDOMElement;
begin
  result := TFhirElementDefinition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'path') then
        result.pathElement := ParseString(child, path+'/path') {b}
      else if (child.baseName = 'representation') then
        result.representationList.Add(ParseEnum(CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum, path+'/representation', child)){y.1}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'label') then
        result.label_Element := ParseString(child, path+'/label') {b}
      else if (child.baseName = 'code') then
        result.codeList.Add(ParseCoding(child, path+'/code')){y.2}
      else if (child.baseName = 'slicing') then
        result.slicing := ParseElementDefinitionSlicing(child, path+'/slicing') {b}
      else if (child.baseName = 'short') then
        result.shortElement := ParseString(child, path+'/short') {b}
      else if (child.baseName = 'definition') then
        result.definitionElement := ParseString(child, path+'/definition') {b}
      else if (child.baseName = 'comments') then
        result.commentsElement := ParseString(child, path+'/comments') {b}
      else if (child.baseName = 'requirements') then
        result.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'alias') then
        result.aliasList.Add(ParseString(child, path+'/alias')){y.2}
      else if (child.baseName = 'min') then
        result.minElement := ParseInteger(child, path+'/min') {b}
      else if (child.baseName = 'max') then
        result.maxElement := ParseString(child, path+'/max') {b}
      else if (child.baseName = 'base') then
        result.base := ParseElementDefinitionBase(child, path+'/base') {b}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseElementDefinitionType(child, path+'/type')){y.2}
      else if (child.baseName = 'nameReference') then
        result.nameReferenceElement := ParseString(child, path+'/nameReference') {b}
      else if (child.baseName = 'defaultValueMarkdown') then
        result.defaultValue := ParseMarkdown(child, path+'.defaultValueMarkdown') {c}
      else if (child.baseName = 'defaultValueInteger') then
        result.defaultValue := ParseInteger(child, path+'.defaultValueInteger') {c}
      else if (child.baseName = 'defaultValueDateTime') then
        result.defaultValue := ParseDateTime(child, path+'.defaultValueDateTime') {c}
      else if (child.baseName = 'defaultValueUnsignedInt') then
        result.defaultValue := ParseUnsignedInt(child, path+'.defaultValueUnsignedInt') {c}
      else if (child.baseName = 'defaultValueCode') then
        result.defaultValue := ParseCode(child, path+'.defaultValueCode') {c}
      else if (child.baseName = 'defaultValueDate') then
        result.defaultValue := ParseDate(child, path+'.defaultValueDate') {c}
      else if (child.baseName = 'defaultValueDecimal') then
        result.defaultValue := ParseDecimal(child, path+'.defaultValueDecimal') {c}
      else if (child.baseName = 'defaultValueUri') then
        result.defaultValue := ParseUri(child, path+'.defaultValueUri') {c}
      else if (child.baseName = 'defaultValueId') then
        result.defaultValue := ParseId(child, path+'.defaultValueId') {c}
      else if (child.baseName = 'defaultValueBase64Binary') then
        result.defaultValue := ParseBase64Binary(child, path+'.defaultValueBase64Binary') {c}
      else if (child.baseName = 'defaultValueTime') then
        result.defaultValue := ParseTime(child, path+'.defaultValueTime') {c}
      else if (child.baseName = 'defaultValueOid') then
        result.defaultValue := ParseOid(child, path+'.defaultValueOid') {c}
      else if (child.baseName = 'defaultValueString') then
        result.defaultValue := ParseString(child, path+'.defaultValueString') {c}
      else if (child.baseName = 'defaultValuePositiveInt') then
        result.defaultValue := ParsePositiveInt(child, path+'.defaultValuePositiveInt') {c}
      else if (child.baseName = 'defaultValueBoolean') then
        result.defaultValue := ParseBoolean(child, path+'.defaultValueBoolean') {c}
      else if (child.baseName = 'defaultValueUuid') then
        result.defaultValue := ParseUuid(child, path+'.defaultValueUuid') {c}
      else if (child.baseName = 'defaultValueInstant') then
        result.defaultValue := ParseInstant(child, path+'.defaultValueInstant') {c}
      else if (child.baseName = 'defaultValuePeriod') then
        result.defaultValue := ParsePeriod(child, path+'.defaultValuePeriod') {ePeriod}
      else if (child.baseName = 'defaultValueCoding') then
        result.defaultValue := ParseCoding(child, path+'.defaultValueCoding') {eCoding}
      else if (child.baseName = 'defaultValueRange') then
        result.defaultValue := ParseRange(child, path+'.defaultValueRange') {eRange}
      else if (child.baseName = 'defaultValueAttachment') then
        result.defaultValue := ParseAttachment(child, path+'.defaultValueAttachment') {eAttachment}
      else if (child.baseName = 'defaultValueQuantity') then
        result.defaultValue := ParseQuantity(child, path+'.defaultValueQuantity') {eQuantity}
      else if (child.baseName = 'defaultValueAnnotation') then
        result.defaultValue := ParseAnnotation(child, path+'.defaultValueAnnotation') {eAnnotation}
      else if (child.baseName = 'defaultValueRatio') then
        result.defaultValue := ParseRatio(child, path+'.defaultValueRatio') {eRatio}
      else if (child.baseName = 'defaultValueSampledData') then
        result.defaultValue := ParseSampledData(child, path+'.defaultValueSampledData') {eSampledData}
      else if (child.baseName = 'defaultValueCodeableConcept') then
        result.defaultValue := ParseCodeableConcept(child, path+'.defaultValueCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'defaultValueReference') then
        result.defaultValue := ParseReference(child, path+'.defaultValueReference') {eReference}
      else if (child.baseName = 'defaultValueIdentifier') then
        result.defaultValue := ParseIdentifier(child, path+'.defaultValueIdentifier') {eIdentifier}
      else if (child.baseName = 'defaultValueSignature') then
        result.defaultValue := ParseSignature(child, path+'.defaultValueSignature') {eSignature}
      else if (child.baseName = 'defaultValueTiming') then
        result.defaultValue := ParseTiming(child, path+'/defaultValueTiming') {f}
      else if (child.baseName = 'defaultValueElementDefinition') then
        result.defaultValue := ParseElementDefinition(child, path+'/defaultValueElementDefinition') {f}
      else if (child.baseName = 'defaultValueHumanName') then
        result.defaultValue := ParseHumanName(child, path+'/defaultValueHumanName') {f}
      else if (child.baseName = 'defaultValueAddress') then
        result.defaultValue := ParseAddress(child, path+'/defaultValueAddress') {f}
      else if (child.baseName = 'defaultValueMeta') then
        result.defaultValue := ParseMeta(child, path+'/defaultValueMeta') {f}
      else if (child.baseName = 'defaultValueContactPoint') then
        result.defaultValue := ParseContactPoint(child, path+'/defaultValueContactPoint') {f}
      else if (child.baseName = 'meaningWhenMissing') then
        result.meaningWhenMissingElement := ParseString(child, path+'/meaningWhenMissing') {b}
      else if (child.baseName = 'fixedMarkdown') then
        result.fixed := ParseMarkdown(child, path+'.fixedMarkdown') {c}
      else if (child.baseName = 'fixedInteger') then
        result.fixed := ParseInteger(child, path+'.fixedInteger') {c}
      else if (child.baseName = 'fixedDateTime') then
        result.fixed := ParseDateTime(child, path+'.fixedDateTime') {c}
      else if (child.baseName = 'fixedUnsignedInt') then
        result.fixed := ParseUnsignedInt(child, path+'.fixedUnsignedInt') {c}
      else if (child.baseName = 'fixedCode') then
        result.fixed := ParseCode(child, path+'.fixedCode') {c}
      else if (child.baseName = 'fixedDate') then
        result.fixed := ParseDate(child, path+'.fixedDate') {c}
      else if (child.baseName = 'fixedDecimal') then
        result.fixed := ParseDecimal(child, path+'.fixedDecimal') {c}
      else if (child.baseName = 'fixedUri') then
        result.fixed := ParseUri(child, path+'.fixedUri') {c}
      else if (child.baseName = 'fixedId') then
        result.fixed := ParseId(child, path+'.fixedId') {c}
      else if (child.baseName = 'fixedBase64Binary') then
        result.fixed := ParseBase64Binary(child, path+'.fixedBase64Binary') {c}
      else if (child.baseName = 'fixedTime') then
        result.fixed := ParseTime(child, path+'.fixedTime') {c}
      else if (child.baseName = 'fixedOid') then
        result.fixed := ParseOid(child, path+'.fixedOid') {c}
      else if (child.baseName = 'fixedString') then
        result.fixed := ParseString(child, path+'.fixedString') {c}
      else if (child.baseName = 'fixedPositiveInt') then
        result.fixed := ParsePositiveInt(child, path+'.fixedPositiveInt') {c}
      else if (child.baseName = 'fixedBoolean') then
        result.fixed := ParseBoolean(child, path+'.fixedBoolean') {c}
      else if (child.baseName = 'fixedUuid') then
        result.fixed := ParseUuid(child, path+'.fixedUuid') {c}
      else if (child.baseName = 'fixedInstant') then
        result.fixed := ParseInstant(child, path+'.fixedInstant') {c}
      else if (child.baseName = 'fixedPeriod') then
        result.fixed := ParsePeriod(child, path+'.fixedPeriod') {ePeriod}
      else if (child.baseName = 'fixedCoding') then
        result.fixed := ParseCoding(child, path+'.fixedCoding') {eCoding}
      else if (child.baseName = 'fixedRange') then
        result.fixed := ParseRange(child, path+'.fixedRange') {eRange}
      else if (child.baseName = 'fixedAttachment') then
        result.fixed := ParseAttachment(child, path+'.fixedAttachment') {eAttachment}
      else if (child.baseName = 'fixedQuantity') then
        result.fixed := ParseQuantity(child, path+'.fixedQuantity') {eQuantity}
      else if (child.baseName = 'fixedAnnotation') then
        result.fixed := ParseAnnotation(child, path+'.fixedAnnotation') {eAnnotation}
      else if (child.baseName = 'fixedRatio') then
        result.fixed := ParseRatio(child, path+'.fixedRatio') {eRatio}
      else if (child.baseName = 'fixedSampledData') then
        result.fixed := ParseSampledData(child, path+'.fixedSampledData') {eSampledData}
      else if (child.baseName = 'fixedCodeableConcept') then
        result.fixed := ParseCodeableConcept(child, path+'.fixedCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'fixedReference') then
        result.fixed := ParseReference(child, path+'.fixedReference') {eReference}
      else if (child.baseName = 'fixedIdentifier') then
        result.fixed := ParseIdentifier(child, path+'.fixedIdentifier') {eIdentifier}
      else if (child.baseName = 'fixedSignature') then
        result.fixed := ParseSignature(child, path+'.fixedSignature') {eSignature}
      else if (child.baseName = 'fixedTiming') then
        result.fixed := ParseTiming(child, path+'/fixedTiming') {f}
      else if (child.baseName = 'fixedElementDefinition') then
        result.fixed := ParseElementDefinition(child, path+'/fixedElementDefinition') {f}
      else if (child.baseName = 'fixedHumanName') then
        result.fixed := ParseHumanName(child, path+'/fixedHumanName') {f}
      else if (child.baseName = 'fixedAddress') then
        result.fixed := ParseAddress(child, path+'/fixedAddress') {f}
      else if (child.baseName = 'fixedMeta') then
        result.fixed := ParseMeta(child, path+'/fixedMeta') {f}
      else if (child.baseName = 'fixedContactPoint') then
        result.fixed := ParseContactPoint(child, path+'/fixedContactPoint') {f}
      else if (child.baseName = 'patternMarkdown') then
        result.pattern := ParseMarkdown(child, path+'.patternMarkdown') {c}
      else if (child.baseName = 'patternInteger') then
        result.pattern := ParseInteger(child, path+'.patternInteger') {c}
      else if (child.baseName = 'patternDateTime') then
        result.pattern := ParseDateTime(child, path+'.patternDateTime') {c}
      else if (child.baseName = 'patternUnsignedInt') then
        result.pattern := ParseUnsignedInt(child, path+'.patternUnsignedInt') {c}
      else if (child.baseName = 'patternCode') then
        result.pattern := ParseCode(child, path+'.patternCode') {c}
      else if (child.baseName = 'patternDate') then
        result.pattern := ParseDate(child, path+'.patternDate') {c}
      else if (child.baseName = 'patternDecimal') then
        result.pattern := ParseDecimal(child, path+'.patternDecimal') {c}
      else if (child.baseName = 'patternUri') then
        result.pattern := ParseUri(child, path+'.patternUri') {c}
      else if (child.baseName = 'patternId') then
        result.pattern := ParseId(child, path+'.patternId') {c}
      else if (child.baseName = 'patternBase64Binary') then
        result.pattern := ParseBase64Binary(child, path+'.patternBase64Binary') {c}
      else if (child.baseName = 'patternTime') then
        result.pattern := ParseTime(child, path+'.patternTime') {c}
      else if (child.baseName = 'patternOid') then
        result.pattern := ParseOid(child, path+'.patternOid') {c}
      else if (child.baseName = 'patternString') then
        result.pattern := ParseString(child, path+'.patternString') {c}
      else if (child.baseName = 'patternPositiveInt') then
        result.pattern := ParsePositiveInt(child, path+'.patternPositiveInt') {c}
      else if (child.baseName = 'patternBoolean') then
        result.pattern := ParseBoolean(child, path+'.patternBoolean') {c}
      else if (child.baseName = 'patternUuid') then
        result.pattern := ParseUuid(child, path+'.patternUuid') {c}
      else if (child.baseName = 'patternInstant') then
        result.pattern := ParseInstant(child, path+'.patternInstant') {c}
      else if (child.baseName = 'patternPeriod') then
        result.pattern := ParsePeriod(child, path+'.patternPeriod') {ePeriod}
      else if (child.baseName = 'patternCoding') then
        result.pattern := ParseCoding(child, path+'.patternCoding') {eCoding}
      else if (child.baseName = 'patternRange') then
        result.pattern := ParseRange(child, path+'.patternRange') {eRange}
      else if (child.baseName = 'patternAttachment') then
        result.pattern := ParseAttachment(child, path+'.patternAttachment') {eAttachment}
      else if (child.baseName = 'patternQuantity') then
        result.pattern := ParseQuantity(child, path+'.patternQuantity') {eQuantity}
      else if (child.baseName = 'patternAnnotation') then
        result.pattern := ParseAnnotation(child, path+'.patternAnnotation') {eAnnotation}
      else if (child.baseName = 'patternRatio') then
        result.pattern := ParseRatio(child, path+'.patternRatio') {eRatio}
      else if (child.baseName = 'patternSampledData') then
        result.pattern := ParseSampledData(child, path+'.patternSampledData') {eSampledData}
      else if (child.baseName = 'patternCodeableConcept') then
        result.pattern := ParseCodeableConcept(child, path+'.patternCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'patternReference') then
        result.pattern := ParseReference(child, path+'.patternReference') {eReference}
      else if (child.baseName = 'patternIdentifier') then
        result.pattern := ParseIdentifier(child, path+'.patternIdentifier') {eIdentifier}
      else if (child.baseName = 'patternSignature') then
        result.pattern := ParseSignature(child, path+'.patternSignature') {eSignature}
      else if (child.baseName = 'patternTiming') then
        result.pattern := ParseTiming(child, path+'/patternTiming') {f}
      else if (child.baseName = 'patternElementDefinition') then
        result.pattern := ParseElementDefinition(child, path+'/patternElementDefinition') {f}
      else if (child.baseName = 'patternHumanName') then
        result.pattern := ParseHumanName(child, path+'/patternHumanName') {f}
      else if (child.baseName = 'patternAddress') then
        result.pattern := ParseAddress(child, path+'/patternAddress') {f}
      else if (child.baseName = 'patternMeta') then
        result.pattern := ParseMeta(child, path+'/patternMeta') {f}
      else if (child.baseName = 'patternContactPoint') then
        result.pattern := ParseContactPoint(child, path+'/patternContactPoint') {f}
      else if (child.baseName = 'exampleMarkdown') then
        result.example := ParseMarkdown(child, path+'.exampleMarkdown') {c}
      else if (child.baseName = 'exampleInteger') then
        result.example := ParseInteger(child, path+'.exampleInteger') {c}
      else if (child.baseName = 'exampleDateTime') then
        result.example := ParseDateTime(child, path+'.exampleDateTime') {c}
      else if (child.baseName = 'exampleUnsignedInt') then
        result.example := ParseUnsignedInt(child, path+'.exampleUnsignedInt') {c}
      else if (child.baseName = 'exampleCode') then
        result.example := ParseCode(child, path+'.exampleCode') {c}
      else if (child.baseName = 'exampleDate') then
        result.example := ParseDate(child, path+'.exampleDate') {c}
      else if (child.baseName = 'exampleDecimal') then
        result.example := ParseDecimal(child, path+'.exampleDecimal') {c}
      else if (child.baseName = 'exampleUri') then
        result.example := ParseUri(child, path+'.exampleUri') {c}
      else if (child.baseName = 'exampleId') then
        result.example := ParseId(child, path+'.exampleId') {c}
      else if (child.baseName = 'exampleBase64Binary') then
        result.example := ParseBase64Binary(child, path+'.exampleBase64Binary') {c}
      else if (child.baseName = 'exampleTime') then
        result.example := ParseTime(child, path+'.exampleTime') {c}
      else if (child.baseName = 'exampleOid') then
        result.example := ParseOid(child, path+'.exampleOid') {c}
      else if (child.baseName = 'exampleString') then
        result.example := ParseString(child, path+'.exampleString') {c}
      else if (child.baseName = 'examplePositiveInt') then
        result.example := ParsePositiveInt(child, path+'.examplePositiveInt') {c}
      else if (child.baseName = 'exampleBoolean') then
        result.example := ParseBoolean(child, path+'.exampleBoolean') {c}
      else if (child.baseName = 'exampleUuid') then
        result.example := ParseUuid(child, path+'.exampleUuid') {c}
      else if (child.baseName = 'exampleInstant') then
        result.example := ParseInstant(child, path+'.exampleInstant') {c}
      else if (child.baseName = 'examplePeriod') then
        result.example := ParsePeriod(child, path+'.examplePeriod') {ePeriod}
      else if (child.baseName = 'exampleCoding') then
        result.example := ParseCoding(child, path+'.exampleCoding') {eCoding}
      else if (child.baseName = 'exampleRange') then
        result.example := ParseRange(child, path+'.exampleRange') {eRange}
      else if (child.baseName = 'exampleAttachment') then
        result.example := ParseAttachment(child, path+'.exampleAttachment') {eAttachment}
      else if (child.baseName = 'exampleQuantity') then
        result.example := ParseQuantity(child, path+'.exampleQuantity') {eQuantity}
      else if (child.baseName = 'exampleAnnotation') then
        result.example := ParseAnnotation(child, path+'.exampleAnnotation') {eAnnotation}
      else if (child.baseName = 'exampleRatio') then
        result.example := ParseRatio(child, path+'.exampleRatio') {eRatio}
      else if (child.baseName = 'exampleSampledData') then
        result.example := ParseSampledData(child, path+'.exampleSampledData') {eSampledData}
      else if (child.baseName = 'exampleCodeableConcept') then
        result.example := ParseCodeableConcept(child, path+'.exampleCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'exampleReference') then
        result.example := ParseReference(child, path+'.exampleReference') {eReference}
      else if (child.baseName = 'exampleIdentifier') then
        result.example := ParseIdentifier(child, path+'.exampleIdentifier') {eIdentifier}
      else if (child.baseName = 'exampleSignature') then
        result.example := ParseSignature(child, path+'.exampleSignature') {eSignature}
      else if (child.baseName = 'exampleTiming') then
        result.example := ParseTiming(child, path+'/exampleTiming') {f}
      else if (child.baseName = 'exampleElementDefinition') then
        result.example := ParseElementDefinition(child, path+'/exampleElementDefinition') {f}
      else if (child.baseName = 'exampleHumanName') then
        result.example := ParseHumanName(child, path+'/exampleHumanName') {f}
      else if (child.baseName = 'exampleAddress') then
        result.example := ParseAddress(child, path+'/exampleAddress') {f}
      else if (child.baseName = 'exampleMeta') then
        result.example := ParseMeta(child, path+'/exampleMeta') {f}
      else if (child.baseName = 'exampleContactPoint') then
        result.example := ParseContactPoint(child, path+'/exampleContactPoint') {f}
      else if (child.baseName = 'minValueMarkdown') then
        result.minValue := ParseMarkdown(child, path+'.minValueMarkdown') {c}
      else if (child.baseName = 'minValueInteger') then
        result.minValue := ParseInteger(child, path+'.minValueInteger') {c}
      else if (child.baseName = 'minValueDateTime') then
        result.minValue := ParseDateTime(child, path+'.minValueDateTime') {c}
      else if (child.baseName = 'minValueUnsignedInt') then
        result.minValue := ParseUnsignedInt(child, path+'.minValueUnsignedInt') {c}
      else if (child.baseName = 'minValueCode') then
        result.minValue := ParseCode(child, path+'.minValueCode') {c}
      else if (child.baseName = 'minValueDate') then
        result.minValue := ParseDate(child, path+'.minValueDate') {c}
      else if (child.baseName = 'minValueDecimal') then
        result.minValue := ParseDecimal(child, path+'.minValueDecimal') {c}
      else if (child.baseName = 'minValueUri') then
        result.minValue := ParseUri(child, path+'.minValueUri') {c}
      else if (child.baseName = 'minValueId') then
        result.minValue := ParseId(child, path+'.minValueId') {c}
      else if (child.baseName = 'minValueBase64Binary') then
        result.minValue := ParseBase64Binary(child, path+'.minValueBase64Binary') {c}
      else if (child.baseName = 'minValueTime') then
        result.minValue := ParseTime(child, path+'.minValueTime') {c}
      else if (child.baseName = 'minValueOid') then
        result.minValue := ParseOid(child, path+'.minValueOid') {c}
      else if (child.baseName = 'minValueString') then
        result.minValue := ParseString(child, path+'.minValueString') {c}
      else if (child.baseName = 'minValuePositiveInt') then
        result.minValue := ParsePositiveInt(child, path+'.minValuePositiveInt') {c}
      else if (child.baseName = 'minValueBoolean') then
        result.minValue := ParseBoolean(child, path+'.minValueBoolean') {c}
      else if (child.baseName = 'minValueUuid') then
        result.minValue := ParseUuid(child, path+'.minValueUuid') {c}
      else if (child.baseName = 'minValueInstant') then
        result.minValue := ParseInstant(child, path+'.minValueInstant') {c}
      else if (child.baseName = 'minValuePeriod') then
        result.minValue := ParsePeriod(child, path+'.minValuePeriod') {ePeriod}
      else if (child.baseName = 'minValueCoding') then
        result.minValue := ParseCoding(child, path+'.minValueCoding') {eCoding}
      else if (child.baseName = 'minValueRange') then
        result.minValue := ParseRange(child, path+'.minValueRange') {eRange}
      else if (child.baseName = 'minValueAttachment') then
        result.minValue := ParseAttachment(child, path+'.minValueAttachment') {eAttachment}
      else if (child.baseName = 'minValueQuantity') then
        result.minValue := ParseQuantity(child, path+'.minValueQuantity') {eQuantity}
      else if (child.baseName = 'minValueAnnotation') then
        result.minValue := ParseAnnotation(child, path+'.minValueAnnotation') {eAnnotation}
      else if (child.baseName = 'minValueRatio') then
        result.minValue := ParseRatio(child, path+'.minValueRatio') {eRatio}
      else if (child.baseName = 'minValueSampledData') then
        result.minValue := ParseSampledData(child, path+'.minValueSampledData') {eSampledData}
      else if (child.baseName = 'minValueCodeableConcept') then
        result.minValue := ParseCodeableConcept(child, path+'.minValueCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'minValueReference') then
        result.minValue := ParseReference(child, path+'.minValueReference') {eReference}
      else if (child.baseName = 'minValueIdentifier') then
        result.minValue := ParseIdentifier(child, path+'.minValueIdentifier') {eIdentifier}
      else if (child.baseName = 'minValueSignature') then
        result.minValue := ParseSignature(child, path+'.minValueSignature') {eSignature}
      else if (child.baseName = 'minValueTiming') then
        result.minValue := ParseTiming(child, path+'/minValueTiming') {f}
      else if (child.baseName = 'minValueElementDefinition') then
        result.minValue := ParseElementDefinition(child, path+'/minValueElementDefinition') {f}
      else if (child.baseName = 'minValueHumanName') then
        result.minValue := ParseHumanName(child, path+'/minValueHumanName') {f}
      else if (child.baseName = 'minValueAddress') then
        result.minValue := ParseAddress(child, path+'/minValueAddress') {f}
      else if (child.baseName = 'minValueMeta') then
        result.minValue := ParseMeta(child, path+'/minValueMeta') {f}
      else if (child.baseName = 'minValueContactPoint') then
        result.minValue := ParseContactPoint(child, path+'/minValueContactPoint') {f}
      else if (child.baseName = 'maxValueMarkdown') then
        result.maxValue := ParseMarkdown(child, path+'.maxValueMarkdown') {c}
      else if (child.baseName = 'maxValueInteger') then
        result.maxValue := ParseInteger(child, path+'.maxValueInteger') {c}
      else if (child.baseName = 'maxValueDateTime') then
        result.maxValue := ParseDateTime(child, path+'.maxValueDateTime') {c}
      else if (child.baseName = 'maxValueUnsignedInt') then
        result.maxValue := ParseUnsignedInt(child, path+'.maxValueUnsignedInt') {c}
      else if (child.baseName = 'maxValueCode') then
        result.maxValue := ParseCode(child, path+'.maxValueCode') {c}
      else if (child.baseName = 'maxValueDate') then
        result.maxValue := ParseDate(child, path+'.maxValueDate') {c}
      else if (child.baseName = 'maxValueDecimal') then
        result.maxValue := ParseDecimal(child, path+'.maxValueDecimal') {c}
      else if (child.baseName = 'maxValueUri') then
        result.maxValue := ParseUri(child, path+'.maxValueUri') {c}
      else if (child.baseName = 'maxValueId') then
        result.maxValue := ParseId(child, path+'.maxValueId') {c}
      else if (child.baseName = 'maxValueBase64Binary') then
        result.maxValue := ParseBase64Binary(child, path+'.maxValueBase64Binary') {c}
      else if (child.baseName = 'maxValueTime') then
        result.maxValue := ParseTime(child, path+'.maxValueTime') {c}
      else if (child.baseName = 'maxValueOid') then
        result.maxValue := ParseOid(child, path+'.maxValueOid') {c}
      else if (child.baseName = 'maxValueString') then
        result.maxValue := ParseString(child, path+'.maxValueString') {c}
      else if (child.baseName = 'maxValuePositiveInt') then
        result.maxValue := ParsePositiveInt(child, path+'.maxValuePositiveInt') {c}
      else if (child.baseName = 'maxValueBoolean') then
        result.maxValue := ParseBoolean(child, path+'.maxValueBoolean') {c}
      else if (child.baseName = 'maxValueUuid') then
        result.maxValue := ParseUuid(child, path+'.maxValueUuid') {c}
      else if (child.baseName = 'maxValueInstant') then
        result.maxValue := ParseInstant(child, path+'.maxValueInstant') {c}
      else if (child.baseName = 'maxValuePeriod') then
        result.maxValue := ParsePeriod(child, path+'.maxValuePeriod') {ePeriod}
      else if (child.baseName = 'maxValueCoding') then
        result.maxValue := ParseCoding(child, path+'.maxValueCoding') {eCoding}
      else if (child.baseName = 'maxValueRange') then
        result.maxValue := ParseRange(child, path+'.maxValueRange') {eRange}
      else if (child.baseName = 'maxValueAttachment') then
        result.maxValue := ParseAttachment(child, path+'.maxValueAttachment') {eAttachment}
      else if (child.baseName = 'maxValueQuantity') then
        result.maxValue := ParseQuantity(child, path+'.maxValueQuantity') {eQuantity}
      else if (child.baseName = 'maxValueAnnotation') then
        result.maxValue := ParseAnnotation(child, path+'.maxValueAnnotation') {eAnnotation}
      else if (child.baseName = 'maxValueRatio') then
        result.maxValue := ParseRatio(child, path+'.maxValueRatio') {eRatio}
      else if (child.baseName = 'maxValueSampledData') then
        result.maxValue := ParseSampledData(child, path+'.maxValueSampledData') {eSampledData}
      else if (child.baseName = 'maxValueCodeableConcept') then
        result.maxValue := ParseCodeableConcept(child, path+'.maxValueCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'maxValueReference') then
        result.maxValue := ParseReference(child, path+'.maxValueReference') {eReference}
      else if (child.baseName = 'maxValueIdentifier') then
        result.maxValue := ParseIdentifier(child, path+'.maxValueIdentifier') {eIdentifier}
      else if (child.baseName = 'maxValueSignature') then
        result.maxValue := ParseSignature(child, path+'.maxValueSignature') {eSignature}
      else if (child.baseName = 'maxValueTiming') then
        result.maxValue := ParseTiming(child, path+'/maxValueTiming') {f}
      else if (child.baseName = 'maxValueElementDefinition') then
        result.maxValue := ParseElementDefinition(child, path+'/maxValueElementDefinition') {f}
      else if (child.baseName = 'maxValueHumanName') then
        result.maxValue := ParseHumanName(child, path+'/maxValueHumanName') {f}
      else if (child.baseName = 'maxValueAddress') then
        result.maxValue := ParseAddress(child, path+'/maxValueAddress') {f}
      else if (child.baseName = 'maxValueMeta') then
        result.maxValue := ParseMeta(child, path+'/maxValueMeta') {f}
      else if (child.baseName = 'maxValueContactPoint') then
        result.maxValue := ParseContactPoint(child, path+'/maxValueContactPoint') {f}
      else if (child.baseName = 'maxLength') then
        result.maxLengthElement := ParseInteger(child, path+'/maxLength') {b}
      else if (child.baseName = 'condition') then
        result.conditionList.Add(ParseId(child, path+'/condition')){y.2}
      else if (child.baseName = 'constraint') then
        result.constraintList.Add(ParseElementDefinitionConstraint(child, path+'/constraint')){y.2}
      else if (child.baseName = 'mustSupport') then
        result.mustSupportElement := ParseBoolean(child, path+'/mustSupport') {b}
      else if (child.baseName = 'isModifier') then
        result.isModifierElement := ParseBoolean(child, path+'/isModifier') {b}
      else if (child.baseName = 'isSummary') then
        result.isSummaryElement := ParseBoolean(child, path+'/isSummary') {b}
      else if (child.baseName = 'binding') then
        result.binding := ParseElementDefinitionBinding(child, path+'/binding') {b}
      else if (child.baseName = 'mapping') then
        result.mappingList.Add(ParseElementDefinitionMapping(child, path+'/mapping')){y.2}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeElementDefinition(xml : TXmlBuilder; name : string; elem : TFhirElementDefinition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'path', elem.pathElement);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.representationList.Count - 1 do
      ComposeEnum(xml, 'representation', elem.representationList[i], CODES_TFhirPropertyRepresentationEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'label', elem.label_Element);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(xml, 'code', elem.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionSlicing(xml, 'slicing', elem.slicing);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'short', elem.shortElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'definition', elem.definitionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'comments', elem.commentsElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.aliasList.Count - 1 do
      ComposeString(xml, 'alias', elem.aliasList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInteger(xml, 'min', elem.minElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'max', elem.maxElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBase(xml, 'base', elem.base);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeElementDefinitionType(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'nameReference', elem.nameReferenceElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMarkdown) {1} then
    ComposeMarkdown(xml, 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInteger) {1} then
    ComposeInteger(xml, 'defaultValueInteger', TFhirInteger(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'defaultValueDateTime', TFhirDateTime(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCode) {1} then
    ComposeCode(xml, 'defaultValueCode', TFhirCode(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDate) {1} then
    ComposeDate(xml, 'defaultValueDate', TFhirDate(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'defaultValueDecimal', TFhirDecimal(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUri) {1} then
    ComposeUri(xml, 'defaultValueUri', TFhirUri(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirId) {1} then
    ComposeId(xml, 'defaultValueId', TFhirId(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTime) {1} then
    ComposeTime(xml, 'defaultValueTime', TFhirTime(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirOid) {1} then
    ComposeOid(xml, 'defaultValueOid', TFhirOid(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirString) {1} then
    ComposeString(xml, 'defaultValueString', TFhirString(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'defaultValueBoolean', TFhirBoolean(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUuid) {1} then
    ComposeUuid(xml, 'defaultValueUuid', TFhirUuid(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInstant) {1} then
    ComposeInstant(xml, 'defaultValueInstant', TFhirInstant(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirPeriod) {8} then
    ComposePeriod(xml, 'defaultValuePeriod', TFhirPeriod(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCoding) {8} then
    ComposeCoding(xml, 'defaultValueCoding', TFhirCoding(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirRange) {8} then
    ComposeRange(xml, 'defaultValueRange', TFhirRange(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'defaultValueAttachment', TFhirAttachment(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'defaultValueQuantity', TFhirQuantity(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAnnotation) {8} then
    ComposeAnnotation(xml, 'defaultValueAnnotation', TFhirAnnotation(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirRatio) {8} then
    ComposeRatio(xml, 'defaultValueRatio', TFhirRatio(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'defaultValueSampledData', TFhirSampledData(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'defaultValueCodeableConcept', TFhirCodeableConcept(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirReference) {8} then
    ComposeReference(xml, 'defaultValueReference', TFhirReference(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'defaultValueIdentifier', TFhirIdentifier(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirSignature) {8} then
    ComposeSignature(xml, 'defaultValueSignature', TFhirSignature(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTiming) {9} then
    ComposeTiming(xml, 'defaultValueTiming', TFhirTiming(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'defaultValueElementDefinition', TFhirElementDefinition(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'defaultValueHumanName', TFhirHumanName(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAddress) {9} then
    ComposeAddress(xml, 'defaultValueAddress', TFhirAddress(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMeta) {9} then
    ComposeMeta(xml, 'defaultValueMeta', TFhirMeta(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'defaultValueContactPoint', TFhirContactPoint(elem.defaultValue));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'meaningWhenMissing', elem.meaningWhenMissingElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMarkdown) {1} then
    ComposeMarkdown(xml, 'fixedMarkdown', TFhirMarkdown(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInteger) {1} then
    ComposeInteger(xml, 'fixedInteger', TFhirInteger(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'fixedDateTime', TFhirDateTime(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'fixedUnsignedInt', TFhirUnsignedInt(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCode) {1} then
    ComposeCode(xml, 'fixedCode', TFhirCode(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDate) {1} then
    ComposeDate(xml, 'fixedDate', TFhirDate(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'fixedDecimal', TFhirDecimal(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUri) {1} then
    ComposeUri(xml, 'fixedUri', TFhirUri(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirId) {1} then
    ComposeId(xml, 'fixedId', TFhirId(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'fixedBase64Binary', TFhirBase64Binary(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTime) {1} then
    ComposeTime(xml, 'fixedTime', TFhirTime(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirOid) {1} then
    ComposeOid(xml, 'fixedOid', TFhirOid(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirString) {1} then
    ComposeString(xml, 'fixedString', TFhirString(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'fixedPositiveInt', TFhirPositiveInt(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'fixedBoolean', TFhirBoolean(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUuid) {1} then
    ComposeUuid(xml, 'fixedUuid', TFhirUuid(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInstant) {1} then
    ComposeInstant(xml, 'fixedInstant', TFhirInstant(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirPeriod) {8} then
    ComposePeriod(xml, 'fixedPeriod', TFhirPeriod(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCoding) {8} then
    ComposeCoding(xml, 'fixedCoding', TFhirCoding(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirRange) {8} then
    ComposeRange(xml, 'fixedRange', TFhirRange(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'fixedAttachment', TFhirAttachment(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'fixedQuantity', TFhirQuantity(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAnnotation) {8} then
    ComposeAnnotation(xml, 'fixedAnnotation', TFhirAnnotation(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirRatio) {8} then
    ComposeRatio(xml, 'fixedRatio', TFhirRatio(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'fixedSampledData', TFhirSampledData(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'fixedCodeableConcept', TFhirCodeableConcept(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirReference) {8} then
    ComposeReference(xml, 'fixedReference', TFhirReference(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'fixedIdentifier', TFhirIdentifier(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirSignature) {8} then
    ComposeSignature(xml, 'fixedSignature', TFhirSignature(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTiming) {9} then
    ComposeTiming(xml, 'fixedTiming', TFhirTiming(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'fixedElementDefinition', TFhirElementDefinition(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'fixedHumanName', TFhirHumanName(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAddress) {9} then
    ComposeAddress(xml, 'fixedAddress', TFhirAddress(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMeta) {9} then
    ComposeMeta(xml, 'fixedMeta', TFhirMeta(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'fixedContactPoint', TFhirContactPoint(elem.fixed));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMarkdown) {1} then
    ComposeMarkdown(xml, 'patternMarkdown', TFhirMarkdown(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInteger) {1} then
    ComposeInteger(xml, 'patternInteger', TFhirInteger(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'patternDateTime', TFhirDateTime(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'patternUnsignedInt', TFhirUnsignedInt(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCode) {1} then
    ComposeCode(xml, 'patternCode', TFhirCode(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDate) {1} then
    ComposeDate(xml, 'patternDate', TFhirDate(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'patternDecimal', TFhirDecimal(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUri) {1} then
    ComposeUri(xml, 'patternUri', TFhirUri(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirId) {1} then
    ComposeId(xml, 'patternId', TFhirId(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'patternBase64Binary', TFhirBase64Binary(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTime) {1} then
    ComposeTime(xml, 'patternTime', TFhirTime(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirOid) {1} then
    ComposeOid(xml, 'patternOid', TFhirOid(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirString) {1} then
    ComposeString(xml, 'patternString', TFhirString(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'patternPositiveInt', TFhirPositiveInt(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'patternBoolean', TFhirBoolean(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUuid) {1} then
    ComposeUuid(xml, 'patternUuid', TFhirUuid(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInstant) {1} then
    ComposeInstant(xml, 'patternInstant', TFhirInstant(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirPeriod) {8} then
    ComposePeriod(xml, 'patternPeriod', TFhirPeriod(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCoding) {8} then
    ComposeCoding(xml, 'patternCoding', TFhirCoding(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirRange) {8} then
    ComposeRange(xml, 'patternRange', TFhirRange(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'patternAttachment', TFhirAttachment(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'patternQuantity', TFhirQuantity(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAnnotation) {8} then
    ComposeAnnotation(xml, 'patternAnnotation', TFhirAnnotation(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirRatio) {8} then
    ComposeRatio(xml, 'patternRatio', TFhirRatio(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'patternSampledData', TFhirSampledData(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'patternCodeableConcept', TFhirCodeableConcept(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirReference) {8} then
    ComposeReference(xml, 'patternReference', TFhirReference(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'patternIdentifier', TFhirIdentifier(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirSignature) {8} then
    ComposeSignature(xml, 'patternSignature', TFhirSignature(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTiming) {9} then
    ComposeTiming(xml, 'patternTiming', TFhirTiming(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'patternElementDefinition', TFhirElementDefinition(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'patternHumanName', TFhirHumanName(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAddress) {9} then
    ComposeAddress(xml, 'patternAddress', TFhirAddress(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMeta) {9} then
    ComposeMeta(xml, 'patternMeta', TFhirMeta(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'patternContactPoint', TFhirContactPoint(elem.pattern));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirMarkdown) {1} then
    ComposeMarkdown(xml, 'exampleMarkdown', TFhirMarkdown(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirInteger) {1} then
    ComposeInteger(xml, 'exampleInteger', TFhirInteger(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'exampleDateTime', TFhirDateTime(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'exampleUnsignedInt', TFhirUnsignedInt(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirCode) {1} then
    ComposeCode(xml, 'exampleCode', TFhirCode(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDate) {1} then
    ComposeDate(xml, 'exampleDate', TFhirDate(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'exampleDecimal', TFhirDecimal(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUri) {1} then
    ComposeUri(xml, 'exampleUri', TFhirUri(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirId) {1} then
    ComposeId(xml, 'exampleId', TFhirId(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'exampleBase64Binary', TFhirBase64Binary(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirTime) {1} then
    ComposeTime(xml, 'exampleTime', TFhirTime(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirOid) {1} then
    ComposeOid(xml, 'exampleOid', TFhirOid(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirString) {1} then
    ComposeString(xml, 'exampleString', TFhirString(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'examplePositiveInt', TFhirPositiveInt(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'exampleBoolean', TFhirBoolean(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUuid) {1} then
    ComposeUuid(xml, 'exampleUuid', TFhirUuid(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirInstant) {1} then
    ComposeInstant(xml, 'exampleInstant', TFhirInstant(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirPeriod) {8} then
    ComposePeriod(xml, 'examplePeriod', TFhirPeriod(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirCoding) {8} then
    ComposeCoding(xml, 'exampleCoding', TFhirCoding(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirRange) {8} then
    ComposeRange(xml, 'exampleRange', TFhirRange(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'exampleAttachment', TFhirAttachment(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'exampleQuantity', TFhirQuantity(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirAnnotation) {8} then
    ComposeAnnotation(xml, 'exampleAnnotation', TFhirAnnotation(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirRatio) {8} then
    ComposeRatio(xml, 'exampleRatio', TFhirRatio(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'exampleSampledData', TFhirSampledData(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'exampleCodeableConcept', TFhirCodeableConcept(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirReference) {8} then
    ComposeReference(xml, 'exampleReference', TFhirReference(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'exampleIdentifier', TFhirIdentifier(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirSignature) {8} then
    ComposeSignature(xml, 'exampleSignature', TFhirSignature(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirTiming) {9} then
    ComposeTiming(xml, 'exampleTiming', TFhirTiming(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'exampleElementDefinition', TFhirElementDefinition(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'exampleHumanName', TFhirHumanName(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirAddress) {9} then
    ComposeAddress(xml, 'exampleAddress', TFhirAddress(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirMeta) {9} then
    ComposeMeta(xml, 'exampleMeta', TFhirMeta(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'exampleContactPoint', TFhirContactPoint(elem.example));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirMarkdown) {1} then
    ComposeMarkdown(xml, 'minValueMarkdown', TFhirMarkdown(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInteger) {1} then
    ComposeInteger(xml, 'minValueInteger', TFhirInteger(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'minValueDateTime', TFhirDateTime(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'minValueUnsignedInt', TFhirUnsignedInt(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirCode) {1} then
    ComposeCode(xml, 'minValueCode', TFhirCode(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDate) {1} then
    ComposeDate(xml, 'minValueDate', TFhirDate(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'minValueDecimal', TFhirDecimal(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUri) {1} then
    ComposeUri(xml, 'minValueUri', TFhirUri(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirId) {1} then
    ComposeId(xml, 'minValueId', TFhirId(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'minValueBase64Binary', TFhirBase64Binary(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirTime) {1} then
    ComposeTime(xml, 'minValueTime', TFhirTime(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirOid) {1} then
    ComposeOid(xml, 'minValueOid', TFhirOid(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirString) {1} then
    ComposeString(xml, 'minValueString', TFhirString(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'minValuePositiveInt', TFhirPositiveInt(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'minValueBoolean', TFhirBoolean(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUuid) {1} then
    ComposeUuid(xml, 'minValueUuid', TFhirUuid(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInstant) {1} then
    ComposeInstant(xml, 'minValueInstant', TFhirInstant(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirPeriod) {8} then
    ComposePeriod(xml, 'minValuePeriod', TFhirPeriod(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirCoding) {8} then
    ComposeCoding(xml, 'minValueCoding', TFhirCoding(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirRange) {8} then
    ComposeRange(xml, 'minValueRange', TFhirRange(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'minValueAttachment', TFhirAttachment(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'minValueQuantity', TFhirQuantity(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirAnnotation) {8} then
    ComposeAnnotation(xml, 'minValueAnnotation', TFhirAnnotation(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirRatio) {8} then
    ComposeRatio(xml, 'minValueRatio', TFhirRatio(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'minValueSampledData', TFhirSampledData(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'minValueCodeableConcept', TFhirCodeableConcept(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirReference) {8} then
    ComposeReference(xml, 'minValueReference', TFhirReference(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'minValueIdentifier', TFhirIdentifier(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirSignature) {8} then
    ComposeSignature(xml, 'minValueSignature', TFhirSignature(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirTiming) {9} then
    ComposeTiming(xml, 'minValueTiming', TFhirTiming(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'minValueElementDefinition', TFhirElementDefinition(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'minValueHumanName', TFhirHumanName(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirAddress) {9} then
    ComposeAddress(xml, 'minValueAddress', TFhirAddress(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirMeta) {9} then
    ComposeMeta(xml, 'minValueMeta', TFhirMeta(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'minValueContactPoint', TFhirContactPoint(elem.minValue));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirMarkdown) {1} then
    ComposeMarkdown(xml, 'maxValueMarkdown', TFhirMarkdown(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInteger) {1} then
    ComposeInteger(xml, 'maxValueInteger', TFhirInteger(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'maxValueDateTime', TFhirDateTime(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'maxValueUnsignedInt', TFhirUnsignedInt(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirCode) {1} then
    ComposeCode(xml, 'maxValueCode', TFhirCode(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDate) {1} then
    ComposeDate(xml, 'maxValueDate', TFhirDate(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'maxValueDecimal', TFhirDecimal(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUri) {1} then
    ComposeUri(xml, 'maxValueUri', TFhirUri(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirId) {1} then
    ComposeId(xml, 'maxValueId', TFhirId(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'maxValueBase64Binary', TFhirBase64Binary(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirTime) {1} then
    ComposeTime(xml, 'maxValueTime', TFhirTime(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirOid) {1} then
    ComposeOid(xml, 'maxValueOid', TFhirOid(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirString) {1} then
    ComposeString(xml, 'maxValueString', TFhirString(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'maxValuePositiveInt', TFhirPositiveInt(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'maxValueBoolean', TFhirBoolean(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUuid) {1} then
    ComposeUuid(xml, 'maxValueUuid', TFhirUuid(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInstant) {1} then
    ComposeInstant(xml, 'maxValueInstant', TFhirInstant(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirPeriod) {8} then
    ComposePeriod(xml, 'maxValuePeriod', TFhirPeriod(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirCoding) {8} then
    ComposeCoding(xml, 'maxValueCoding', TFhirCoding(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirRange) {8} then
    ComposeRange(xml, 'maxValueRange', TFhirRange(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'maxValueAttachment', TFhirAttachment(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'maxValueQuantity', TFhirQuantity(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirAnnotation) {8} then
    ComposeAnnotation(xml, 'maxValueAnnotation', TFhirAnnotation(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirRatio) {8} then
    ComposeRatio(xml, 'maxValueRatio', TFhirRatio(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'maxValueSampledData', TFhirSampledData(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'maxValueCodeableConcept', TFhirCodeableConcept(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirReference) {8} then
    ComposeReference(xml, 'maxValueReference', TFhirReference(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'maxValueIdentifier', TFhirIdentifier(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirSignature) {8} then
    ComposeSignature(xml, 'maxValueSignature', TFhirSignature(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirTiming) {9} then
    ComposeTiming(xml, 'maxValueTiming', TFhirTiming(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'maxValueElementDefinition', TFhirElementDefinition(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'maxValueHumanName', TFhirHumanName(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirAddress) {9} then
    ComposeAddress(xml, 'maxValueAddress', TFhirAddress(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirMeta) {9} then
    ComposeMeta(xml, 'maxValueMeta', TFhirMeta(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'maxValueContactPoint', TFhirContactPoint(elem.maxValue));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInteger(xml, 'maxLength', elem.maxLengthElement);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeId(xml, 'condition', elem.conditionList[i]);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.constraintList.Count - 1 do
      ComposeElementDefinitionConstraint(xml, 'constraint', elem.constraintList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBoolean(xml, 'mustSupport', elem.mustSupportElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBoolean(xml, 'isModifier', elem.isModifierElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBoolean(xml, 'isSummary', elem.isSummaryElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBinding(xml, 'binding', elem.binding);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeElementDefinitionMapping(xml, 'mapping', elem.mappingList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseElementDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinition(jsn : TJsonObject) : TFhirElementDefinition;
begin
  result := TFhirElementDefinition.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := ParseString(jsn['path'], jsn.vObj['_path']);{q}
    if jsn.has('representation') or jsn.has('_representation') then
      iterateEnumArray(jsn.vArr['representation'], jsn.vArr['_representation'], jsn.path+'/representation', result.representationList, parseEnum, CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('label') or jsn.has('_label') then
        result.label_Element := ParseString(jsn['label'], jsn.vObj['_label']);{q}
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCoding);
    if jsn.has('slicing') then
        result.slicing := ParseElementDefinitionSlicing(jsn.vObj['slicing']);{q}
    if jsn.has('short') or jsn.has('_short') then
        result.shortElement := ParseString(jsn['short'], jsn.vObj['_short']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := ParseString(jsn['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsElement := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
      if jsn.has('alias') or jsn.has('_alias') then
      iteratePrimitiveArray(jsn.vArr['alias'], jsn.vArr['_alias'], result.aliasList, parseString);
    if jsn.has('min') or jsn.has('_min') then
        result.minElement := ParseInteger(jsn['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxElement := ParseString(jsn['max'], jsn.vObj['_max']);{q}
    if jsn.has('base') then
        result.base := ParseElementDefinitionBase(jsn.vObj['base']);{q}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseElementDefinitionType);
    if jsn.has('nameReference') or jsn.has('_nameReference') then
        result.nameReferenceElement := ParseString(jsn['nameReference'], jsn.vObj['_nameReference']);{q}
    if jsn.has('defaultValueMarkdown') or jsn.has('_defaultValueMarkdown') then
        result.defaultValue := ParseMarkdown(jsn['defaultValueMarkdown'], jsn.vObj['_defaultValueMarkdown']);
    if jsn.has('defaultValueInteger') or jsn.has('_defaultValueInteger') then
        result.defaultValue := ParseInteger(jsn['defaultValueInteger'], jsn.vObj['_defaultValueInteger']);
    if jsn.has('defaultValueDateTime') or jsn.has('_defaultValueDateTime') then
        result.defaultValue := ParseDateTime(jsn['defaultValueDateTime'], jsn.vObj['_defaultValueDateTime']);
    if jsn.has('defaultValueUnsignedInt') or jsn.has('_defaultValueUnsignedInt') then
        result.defaultValue := ParseUnsignedInt(jsn['defaultValueUnsignedInt'], jsn.vObj['_defaultValueUnsignedInt']);
    if jsn.has('defaultValueCode') or jsn.has('_defaultValueCode') then
        result.defaultValue := ParseCode(jsn['defaultValueCode'], jsn.vObj['_defaultValueCode']);
    if jsn.has('defaultValueDate') or jsn.has('_defaultValueDate') then
        result.defaultValue := ParseDate(jsn['defaultValueDate'], jsn.vObj['_defaultValueDate']);
    if jsn.has('defaultValueDecimal') or jsn.has('_defaultValueDecimal') then
        result.defaultValue := ParseDecimal(jsn['defaultValueDecimal'], jsn.vObj['_defaultValueDecimal']);
    if jsn.has('defaultValueUri') or jsn.has('_defaultValueUri') then
        result.defaultValue := ParseUri(jsn['defaultValueUri'], jsn.vObj['_defaultValueUri']);
    if jsn.has('defaultValueId') or jsn.has('_defaultValueId') then
        result.defaultValue := ParseId(jsn['defaultValueId'], jsn.vObj['_defaultValueId']);
    if jsn.has('defaultValueBase64Binary') or jsn.has('_defaultValueBase64Binary') then
        result.defaultValue := ParseBase64Binary(jsn['defaultValueBase64Binary'], jsn.vObj['_defaultValueBase64Binary']);
    if jsn.has('defaultValueTime') or jsn.has('_defaultValueTime') then
        result.defaultValue := ParseTime(jsn['defaultValueTime'], jsn.vObj['_defaultValueTime']);
    if jsn.has('defaultValueOid') or jsn.has('_defaultValueOid') then
        result.defaultValue := ParseOid(jsn['defaultValueOid'], jsn.vObj['_defaultValueOid']);
    if jsn.has('defaultValueString') or jsn.has('_defaultValueString') then
        result.defaultValue := ParseString(jsn['defaultValueString'], jsn.vObj['_defaultValueString']);
    if jsn.has('defaultValuePositiveInt') or jsn.has('_defaultValuePositiveInt') then
        result.defaultValue := ParsePositiveInt(jsn['defaultValuePositiveInt'], jsn.vObj['_defaultValuePositiveInt']);
    if jsn.has('defaultValueBoolean') or jsn.has('_defaultValueBoolean') then
        result.defaultValue := ParseBoolean(jsn['defaultValueBoolean'], jsn.vObj['_defaultValueBoolean']);
    if jsn.has('defaultValueUuid') or jsn.has('_defaultValueUuid') then
        result.defaultValue := ParseUuid(jsn['defaultValueUuid'], jsn.vObj['_defaultValueUuid']);
    if jsn.has('defaultValueInstant') or jsn.has('_defaultValueInstant') then
        result.defaultValue := ParseInstant(jsn['defaultValueInstant'], jsn.vObj['_defaultValueInstant']);
    if jsn.has('defaultValuePeriod') {a7} then
        result.defaultValue := ParsePeriod(jsn.vObj['defaultValuePeriod']);
    if jsn.has('defaultValueCoding') {a7} then
        result.defaultValue := ParseCoding(jsn.vObj['defaultValueCoding']);
    if jsn.has('defaultValueRange') {a7} then
        result.defaultValue := ParseRange(jsn.vObj['defaultValueRange']);
    if jsn.has('defaultValueAttachment') {a7} then
        result.defaultValue := ParseAttachment(jsn.vObj['defaultValueAttachment']);
    if jsn.has('defaultValueQuantity') {a7} then
        result.defaultValue := ParseQuantity(jsn.vObj['defaultValueQuantity']);
    if jsn.has('defaultValueAnnotation') {a7} then
        result.defaultValue := ParseAnnotation(jsn.vObj['defaultValueAnnotation']);
    if jsn.has('defaultValueRatio') {a7} then
        result.defaultValue := ParseRatio(jsn.vObj['defaultValueRatio']);
    if jsn.has('defaultValueSampledData') {a7} then
        result.defaultValue := ParseSampledData(jsn.vObj['defaultValueSampledData']);
    if jsn.has('defaultValueCodeableConcept') {a7} then
        result.defaultValue := ParseCodeableConcept(jsn.vObj['defaultValueCodeableConcept']);
    if jsn.has('defaultValueReference') {a7} then
        result.defaultValue := ParseReference(jsn.vObj['defaultValueReference']);
    if jsn.has('defaultValueIdentifier') {a7} then
        result.defaultValue := ParseIdentifier(jsn.vObj['defaultValueIdentifier']);
    if jsn.has('defaultValueSignature') {a7} then
        result.defaultValue := ParseSignature(jsn.vObj['defaultValueSignature']);
    if jsn.has('defaultValueTiming') {a9} then
        result.defaultValue := ParseTiming(jsn.vObj['defaultValueTiming']);
    if jsn.has('defaultValueElementDefinition') {a9} then
        result.defaultValue := ParseElementDefinition(jsn.vObj['defaultValueElementDefinition']);
    if jsn.has('defaultValueHumanName') {a9} then
        result.defaultValue := ParseHumanName(jsn.vObj['defaultValueHumanName']);
    if jsn.has('defaultValueAddress') {a9} then
        result.defaultValue := ParseAddress(jsn.vObj['defaultValueAddress']);
    if jsn.has('defaultValueMeta') {a9} then
        result.defaultValue := ParseMeta(jsn.vObj['defaultValueMeta']);
    if jsn.has('defaultValueContactPoint') {a9} then
        result.defaultValue := ParseContactPoint(jsn.vObj['defaultValueContactPoint']);
    if jsn.has('meaningWhenMissing') or jsn.has('_meaningWhenMissing') then
        result.meaningWhenMissingElement := ParseString(jsn['meaningWhenMissing'], jsn.vObj['_meaningWhenMissing']);{q}
    if jsn.has('fixedMarkdown') or jsn.has('_fixedMarkdown') then
        result.fixed := ParseMarkdown(jsn['fixedMarkdown'], jsn.vObj['_fixedMarkdown']);
    if jsn.has('fixedInteger') or jsn.has('_fixedInteger') then
        result.fixed := ParseInteger(jsn['fixedInteger'], jsn.vObj['_fixedInteger']);
    if jsn.has('fixedDateTime') or jsn.has('_fixedDateTime') then
        result.fixed := ParseDateTime(jsn['fixedDateTime'], jsn.vObj['_fixedDateTime']);
    if jsn.has('fixedUnsignedInt') or jsn.has('_fixedUnsignedInt') then
        result.fixed := ParseUnsignedInt(jsn['fixedUnsignedInt'], jsn.vObj['_fixedUnsignedInt']);
    if jsn.has('fixedCode') or jsn.has('_fixedCode') then
        result.fixed := ParseCode(jsn['fixedCode'], jsn.vObj['_fixedCode']);
    if jsn.has('fixedDate') or jsn.has('_fixedDate') then
        result.fixed := ParseDate(jsn['fixedDate'], jsn.vObj['_fixedDate']);
    if jsn.has('fixedDecimal') or jsn.has('_fixedDecimal') then
        result.fixed := ParseDecimal(jsn['fixedDecimal'], jsn.vObj['_fixedDecimal']);
    if jsn.has('fixedUri') or jsn.has('_fixedUri') then
        result.fixed := ParseUri(jsn['fixedUri'], jsn.vObj['_fixedUri']);
    if jsn.has('fixedId') or jsn.has('_fixedId') then
        result.fixed := ParseId(jsn['fixedId'], jsn.vObj['_fixedId']);
    if jsn.has('fixedBase64Binary') or jsn.has('_fixedBase64Binary') then
        result.fixed := ParseBase64Binary(jsn['fixedBase64Binary'], jsn.vObj['_fixedBase64Binary']);
    if jsn.has('fixedTime') or jsn.has('_fixedTime') then
        result.fixed := ParseTime(jsn['fixedTime'], jsn.vObj['_fixedTime']);
    if jsn.has('fixedOid') or jsn.has('_fixedOid') then
        result.fixed := ParseOid(jsn['fixedOid'], jsn.vObj['_fixedOid']);
    if jsn.has('fixedString') or jsn.has('_fixedString') then
        result.fixed := ParseString(jsn['fixedString'], jsn.vObj['_fixedString']);
    if jsn.has('fixedPositiveInt') or jsn.has('_fixedPositiveInt') then
        result.fixed := ParsePositiveInt(jsn['fixedPositiveInt'], jsn.vObj['_fixedPositiveInt']);
    if jsn.has('fixedBoolean') or jsn.has('_fixedBoolean') then
        result.fixed := ParseBoolean(jsn['fixedBoolean'], jsn.vObj['_fixedBoolean']);
    if jsn.has('fixedUuid') or jsn.has('_fixedUuid') then
        result.fixed := ParseUuid(jsn['fixedUuid'], jsn.vObj['_fixedUuid']);
    if jsn.has('fixedInstant') or jsn.has('_fixedInstant') then
        result.fixed := ParseInstant(jsn['fixedInstant'], jsn.vObj['_fixedInstant']);
    if jsn.has('fixedPeriod') {a7} then
        result.fixed := ParsePeriod(jsn.vObj['fixedPeriod']);
    if jsn.has('fixedCoding') {a7} then
        result.fixed := ParseCoding(jsn.vObj['fixedCoding']);
    if jsn.has('fixedRange') {a7} then
        result.fixed := ParseRange(jsn.vObj['fixedRange']);
    if jsn.has('fixedAttachment') {a7} then
        result.fixed := ParseAttachment(jsn.vObj['fixedAttachment']);
    if jsn.has('fixedQuantity') {a7} then
        result.fixed := ParseQuantity(jsn.vObj['fixedQuantity']);
    if jsn.has('fixedAnnotation') {a7} then
        result.fixed := ParseAnnotation(jsn.vObj['fixedAnnotation']);
    if jsn.has('fixedRatio') {a7} then
        result.fixed := ParseRatio(jsn.vObj['fixedRatio']);
    if jsn.has('fixedSampledData') {a7} then
        result.fixed := ParseSampledData(jsn.vObj['fixedSampledData']);
    if jsn.has('fixedCodeableConcept') {a7} then
        result.fixed := ParseCodeableConcept(jsn.vObj['fixedCodeableConcept']);
    if jsn.has('fixedReference') {a7} then
        result.fixed := ParseReference(jsn.vObj['fixedReference']);
    if jsn.has('fixedIdentifier') {a7} then
        result.fixed := ParseIdentifier(jsn.vObj['fixedIdentifier']);
    if jsn.has('fixedSignature') {a7} then
        result.fixed := ParseSignature(jsn.vObj['fixedSignature']);
    if jsn.has('fixedTiming') {a9} then
        result.fixed := ParseTiming(jsn.vObj['fixedTiming']);
    if jsn.has('fixedElementDefinition') {a9} then
        result.fixed := ParseElementDefinition(jsn.vObj['fixedElementDefinition']);
    if jsn.has('fixedHumanName') {a9} then
        result.fixed := ParseHumanName(jsn.vObj['fixedHumanName']);
    if jsn.has('fixedAddress') {a9} then
        result.fixed := ParseAddress(jsn.vObj['fixedAddress']);
    if jsn.has('fixedMeta') {a9} then
        result.fixed := ParseMeta(jsn.vObj['fixedMeta']);
    if jsn.has('fixedContactPoint') {a9} then
        result.fixed := ParseContactPoint(jsn.vObj['fixedContactPoint']);
    if jsn.has('patternMarkdown') or jsn.has('_patternMarkdown') then
        result.pattern := ParseMarkdown(jsn['patternMarkdown'], jsn.vObj['_patternMarkdown']);
    if jsn.has('patternInteger') or jsn.has('_patternInteger') then
        result.pattern := ParseInteger(jsn['patternInteger'], jsn.vObj['_patternInteger']);
    if jsn.has('patternDateTime') or jsn.has('_patternDateTime') then
        result.pattern := ParseDateTime(jsn['patternDateTime'], jsn.vObj['_patternDateTime']);
    if jsn.has('patternUnsignedInt') or jsn.has('_patternUnsignedInt') then
        result.pattern := ParseUnsignedInt(jsn['patternUnsignedInt'], jsn.vObj['_patternUnsignedInt']);
    if jsn.has('patternCode') or jsn.has('_patternCode') then
        result.pattern := ParseCode(jsn['patternCode'], jsn.vObj['_patternCode']);
    if jsn.has('patternDate') or jsn.has('_patternDate') then
        result.pattern := ParseDate(jsn['patternDate'], jsn.vObj['_patternDate']);
    if jsn.has('patternDecimal') or jsn.has('_patternDecimal') then
        result.pattern := ParseDecimal(jsn['patternDecimal'], jsn.vObj['_patternDecimal']);
    if jsn.has('patternUri') or jsn.has('_patternUri') then
        result.pattern := ParseUri(jsn['patternUri'], jsn.vObj['_patternUri']);
    if jsn.has('patternId') or jsn.has('_patternId') then
        result.pattern := ParseId(jsn['patternId'], jsn.vObj['_patternId']);
    if jsn.has('patternBase64Binary') or jsn.has('_patternBase64Binary') then
        result.pattern := ParseBase64Binary(jsn['patternBase64Binary'], jsn.vObj['_patternBase64Binary']);
    if jsn.has('patternTime') or jsn.has('_patternTime') then
        result.pattern := ParseTime(jsn['patternTime'], jsn.vObj['_patternTime']);
    if jsn.has('patternOid') or jsn.has('_patternOid') then
        result.pattern := ParseOid(jsn['patternOid'], jsn.vObj['_patternOid']);
    if jsn.has('patternString') or jsn.has('_patternString') then
        result.pattern := ParseString(jsn['patternString'], jsn.vObj['_patternString']);
    if jsn.has('patternPositiveInt') or jsn.has('_patternPositiveInt') then
        result.pattern := ParsePositiveInt(jsn['patternPositiveInt'], jsn.vObj['_patternPositiveInt']);
    if jsn.has('patternBoolean') or jsn.has('_patternBoolean') then
        result.pattern := ParseBoolean(jsn['patternBoolean'], jsn.vObj['_patternBoolean']);
    if jsn.has('patternUuid') or jsn.has('_patternUuid') then
        result.pattern := ParseUuid(jsn['patternUuid'], jsn.vObj['_patternUuid']);
    if jsn.has('patternInstant') or jsn.has('_patternInstant') then
        result.pattern := ParseInstant(jsn['patternInstant'], jsn.vObj['_patternInstant']);
    if jsn.has('patternPeriod') {a7} then
        result.pattern := ParsePeriod(jsn.vObj['patternPeriod']);
    if jsn.has('patternCoding') {a7} then
        result.pattern := ParseCoding(jsn.vObj['patternCoding']);
    if jsn.has('patternRange') {a7} then
        result.pattern := ParseRange(jsn.vObj['patternRange']);
    if jsn.has('patternAttachment') {a7} then
        result.pattern := ParseAttachment(jsn.vObj['patternAttachment']);
    if jsn.has('patternQuantity') {a7} then
        result.pattern := ParseQuantity(jsn.vObj['patternQuantity']);
    if jsn.has('patternAnnotation') {a7} then
        result.pattern := ParseAnnotation(jsn.vObj['patternAnnotation']);
    if jsn.has('patternRatio') {a7} then
        result.pattern := ParseRatio(jsn.vObj['patternRatio']);
    if jsn.has('patternSampledData') {a7} then
        result.pattern := ParseSampledData(jsn.vObj['patternSampledData']);
    if jsn.has('patternCodeableConcept') {a7} then
        result.pattern := ParseCodeableConcept(jsn.vObj['patternCodeableConcept']);
    if jsn.has('patternReference') {a7} then
        result.pattern := ParseReference(jsn.vObj['patternReference']);
    if jsn.has('patternIdentifier') {a7} then
        result.pattern := ParseIdentifier(jsn.vObj['patternIdentifier']);
    if jsn.has('patternSignature') {a7} then
        result.pattern := ParseSignature(jsn.vObj['patternSignature']);
    if jsn.has('patternTiming') {a9} then
        result.pattern := ParseTiming(jsn.vObj['patternTiming']);
    if jsn.has('patternElementDefinition') {a9} then
        result.pattern := ParseElementDefinition(jsn.vObj['patternElementDefinition']);
    if jsn.has('patternHumanName') {a9} then
        result.pattern := ParseHumanName(jsn.vObj['patternHumanName']);
    if jsn.has('patternAddress') {a9} then
        result.pattern := ParseAddress(jsn.vObj['patternAddress']);
    if jsn.has('patternMeta') {a9} then
        result.pattern := ParseMeta(jsn.vObj['patternMeta']);
    if jsn.has('patternContactPoint') {a9} then
        result.pattern := ParseContactPoint(jsn.vObj['patternContactPoint']);
    if jsn.has('exampleMarkdown') or jsn.has('_exampleMarkdown') then
        result.example := ParseMarkdown(jsn['exampleMarkdown'], jsn.vObj['_exampleMarkdown']);
    if jsn.has('exampleInteger') or jsn.has('_exampleInteger') then
        result.example := ParseInteger(jsn['exampleInteger'], jsn.vObj['_exampleInteger']);
    if jsn.has('exampleDateTime') or jsn.has('_exampleDateTime') then
        result.example := ParseDateTime(jsn['exampleDateTime'], jsn.vObj['_exampleDateTime']);
    if jsn.has('exampleUnsignedInt') or jsn.has('_exampleUnsignedInt') then
        result.example := ParseUnsignedInt(jsn['exampleUnsignedInt'], jsn.vObj['_exampleUnsignedInt']);
    if jsn.has('exampleCode') or jsn.has('_exampleCode') then
        result.example := ParseCode(jsn['exampleCode'], jsn.vObj['_exampleCode']);
    if jsn.has('exampleDate') or jsn.has('_exampleDate') then
        result.example := ParseDate(jsn['exampleDate'], jsn.vObj['_exampleDate']);
    if jsn.has('exampleDecimal') or jsn.has('_exampleDecimal') then
        result.example := ParseDecimal(jsn['exampleDecimal'], jsn.vObj['_exampleDecimal']);
    if jsn.has('exampleUri') or jsn.has('_exampleUri') then
        result.example := ParseUri(jsn['exampleUri'], jsn.vObj['_exampleUri']);
    if jsn.has('exampleId') or jsn.has('_exampleId') then
        result.example := ParseId(jsn['exampleId'], jsn.vObj['_exampleId']);
    if jsn.has('exampleBase64Binary') or jsn.has('_exampleBase64Binary') then
        result.example := ParseBase64Binary(jsn['exampleBase64Binary'], jsn.vObj['_exampleBase64Binary']);
    if jsn.has('exampleTime') or jsn.has('_exampleTime') then
        result.example := ParseTime(jsn['exampleTime'], jsn.vObj['_exampleTime']);
    if jsn.has('exampleOid') or jsn.has('_exampleOid') then
        result.example := ParseOid(jsn['exampleOid'], jsn.vObj['_exampleOid']);
    if jsn.has('exampleString') or jsn.has('_exampleString') then
        result.example := ParseString(jsn['exampleString'], jsn.vObj['_exampleString']);
    if jsn.has('examplePositiveInt') or jsn.has('_examplePositiveInt') then
        result.example := ParsePositiveInt(jsn['examplePositiveInt'], jsn.vObj['_examplePositiveInt']);
    if jsn.has('exampleBoolean') or jsn.has('_exampleBoolean') then
        result.example := ParseBoolean(jsn['exampleBoolean'], jsn.vObj['_exampleBoolean']);
    if jsn.has('exampleUuid') or jsn.has('_exampleUuid') then
        result.example := ParseUuid(jsn['exampleUuid'], jsn.vObj['_exampleUuid']);
    if jsn.has('exampleInstant') or jsn.has('_exampleInstant') then
        result.example := ParseInstant(jsn['exampleInstant'], jsn.vObj['_exampleInstant']);
    if jsn.has('examplePeriod') {a7} then
        result.example := ParsePeriod(jsn.vObj['examplePeriod']);
    if jsn.has('exampleCoding') {a7} then
        result.example := ParseCoding(jsn.vObj['exampleCoding']);
    if jsn.has('exampleRange') {a7} then
        result.example := ParseRange(jsn.vObj['exampleRange']);
    if jsn.has('exampleAttachment') {a7} then
        result.example := ParseAttachment(jsn.vObj['exampleAttachment']);
    if jsn.has('exampleQuantity') {a7} then
        result.example := ParseQuantity(jsn.vObj['exampleQuantity']);
    if jsn.has('exampleAnnotation') {a7} then
        result.example := ParseAnnotation(jsn.vObj['exampleAnnotation']);
    if jsn.has('exampleRatio') {a7} then
        result.example := ParseRatio(jsn.vObj['exampleRatio']);
    if jsn.has('exampleSampledData') {a7} then
        result.example := ParseSampledData(jsn.vObj['exampleSampledData']);
    if jsn.has('exampleCodeableConcept') {a7} then
        result.example := ParseCodeableConcept(jsn.vObj['exampleCodeableConcept']);
    if jsn.has('exampleReference') {a7} then
        result.example := ParseReference(jsn.vObj['exampleReference']);
    if jsn.has('exampleIdentifier') {a7} then
        result.example := ParseIdentifier(jsn.vObj['exampleIdentifier']);
    if jsn.has('exampleSignature') {a7} then
        result.example := ParseSignature(jsn.vObj['exampleSignature']);
    if jsn.has('exampleTiming') {a9} then
        result.example := ParseTiming(jsn.vObj['exampleTiming']);
    if jsn.has('exampleElementDefinition') {a9} then
        result.example := ParseElementDefinition(jsn.vObj['exampleElementDefinition']);
    if jsn.has('exampleHumanName') {a9} then
        result.example := ParseHumanName(jsn.vObj['exampleHumanName']);
    if jsn.has('exampleAddress') {a9} then
        result.example := ParseAddress(jsn.vObj['exampleAddress']);
    if jsn.has('exampleMeta') {a9} then
        result.example := ParseMeta(jsn.vObj['exampleMeta']);
    if jsn.has('exampleContactPoint') {a9} then
        result.example := ParseContactPoint(jsn.vObj['exampleContactPoint']);
    if jsn.has('minValueMarkdown') or jsn.has('_minValueMarkdown') then
        result.minValue := ParseMarkdown(jsn['minValueMarkdown'], jsn.vObj['_minValueMarkdown']);
    if jsn.has('minValueInteger') or jsn.has('_minValueInteger') then
        result.minValue := ParseInteger(jsn['minValueInteger'], jsn.vObj['_minValueInteger']);
    if jsn.has('minValueDateTime') or jsn.has('_minValueDateTime') then
        result.minValue := ParseDateTime(jsn['minValueDateTime'], jsn.vObj['_minValueDateTime']);
    if jsn.has('minValueUnsignedInt') or jsn.has('_minValueUnsignedInt') then
        result.minValue := ParseUnsignedInt(jsn['minValueUnsignedInt'], jsn.vObj['_minValueUnsignedInt']);
    if jsn.has('minValueCode') or jsn.has('_minValueCode') then
        result.minValue := ParseCode(jsn['minValueCode'], jsn.vObj['_minValueCode']);
    if jsn.has('minValueDate') or jsn.has('_minValueDate') then
        result.minValue := ParseDate(jsn['minValueDate'], jsn.vObj['_minValueDate']);
    if jsn.has('minValueDecimal') or jsn.has('_minValueDecimal') then
        result.minValue := ParseDecimal(jsn['minValueDecimal'], jsn.vObj['_minValueDecimal']);
    if jsn.has('minValueUri') or jsn.has('_minValueUri') then
        result.minValue := ParseUri(jsn['minValueUri'], jsn.vObj['_minValueUri']);
    if jsn.has('minValueId') or jsn.has('_minValueId') then
        result.minValue := ParseId(jsn['minValueId'], jsn.vObj['_minValueId']);
    if jsn.has('minValueBase64Binary') or jsn.has('_minValueBase64Binary') then
        result.minValue := ParseBase64Binary(jsn['minValueBase64Binary'], jsn.vObj['_minValueBase64Binary']);
    if jsn.has('minValueTime') or jsn.has('_minValueTime') then
        result.minValue := ParseTime(jsn['minValueTime'], jsn.vObj['_minValueTime']);
    if jsn.has('minValueOid') or jsn.has('_minValueOid') then
        result.minValue := ParseOid(jsn['minValueOid'], jsn.vObj['_minValueOid']);
    if jsn.has('minValueString') or jsn.has('_minValueString') then
        result.minValue := ParseString(jsn['minValueString'], jsn.vObj['_minValueString']);
    if jsn.has('minValuePositiveInt') or jsn.has('_minValuePositiveInt') then
        result.minValue := ParsePositiveInt(jsn['minValuePositiveInt'], jsn.vObj['_minValuePositiveInt']);
    if jsn.has('minValueBoolean') or jsn.has('_minValueBoolean') then
        result.minValue := ParseBoolean(jsn['minValueBoolean'], jsn.vObj['_minValueBoolean']);
    if jsn.has('minValueUuid') or jsn.has('_minValueUuid') then
        result.minValue := ParseUuid(jsn['minValueUuid'], jsn.vObj['_minValueUuid']);
    if jsn.has('minValueInstant') or jsn.has('_minValueInstant') then
        result.minValue := ParseInstant(jsn['minValueInstant'], jsn.vObj['_minValueInstant']);
    if jsn.has('minValuePeriod') {a7} then
        result.minValue := ParsePeriod(jsn.vObj['minValuePeriod']);
    if jsn.has('minValueCoding') {a7} then
        result.minValue := ParseCoding(jsn.vObj['minValueCoding']);
    if jsn.has('minValueRange') {a7} then
        result.minValue := ParseRange(jsn.vObj['minValueRange']);
    if jsn.has('minValueAttachment') {a7} then
        result.minValue := ParseAttachment(jsn.vObj['minValueAttachment']);
    if jsn.has('minValueQuantity') {a7} then
        result.minValue := ParseQuantity(jsn.vObj['minValueQuantity']);
    if jsn.has('minValueAnnotation') {a7} then
        result.minValue := ParseAnnotation(jsn.vObj['minValueAnnotation']);
    if jsn.has('minValueRatio') {a7} then
        result.minValue := ParseRatio(jsn.vObj['minValueRatio']);
    if jsn.has('minValueSampledData') {a7} then
        result.minValue := ParseSampledData(jsn.vObj['minValueSampledData']);
    if jsn.has('minValueCodeableConcept') {a7} then
        result.minValue := ParseCodeableConcept(jsn.vObj['minValueCodeableConcept']);
    if jsn.has('minValueReference') {a7} then
        result.minValue := ParseReference(jsn.vObj['minValueReference']);
    if jsn.has('minValueIdentifier') {a7} then
        result.minValue := ParseIdentifier(jsn.vObj['minValueIdentifier']);
    if jsn.has('minValueSignature') {a7} then
        result.minValue := ParseSignature(jsn.vObj['minValueSignature']);
    if jsn.has('minValueTiming') {a9} then
        result.minValue := ParseTiming(jsn.vObj['minValueTiming']);
    if jsn.has('minValueElementDefinition') {a9} then
        result.minValue := ParseElementDefinition(jsn.vObj['minValueElementDefinition']);
    if jsn.has('minValueHumanName') {a9} then
        result.minValue := ParseHumanName(jsn.vObj['minValueHumanName']);
    if jsn.has('minValueAddress') {a9} then
        result.minValue := ParseAddress(jsn.vObj['minValueAddress']);
    if jsn.has('minValueMeta') {a9} then
        result.minValue := ParseMeta(jsn.vObj['minValueMeta']);
    if jsn.has('minValueContactPoint') {a9} then
        result.minValue := ParseContactPoint(jsn.vObj['minValueContactPoint']);
    if jsn.has('maxValueMarkdown') or jsn.has('_maxValueMarkdown') then
        result.maxValue := ParseMarkdown(jsn['maxValueMarkdown'], jsn.vObj['_maxValueMarkdown']);
    if jsn.has('maxValueInteger') or jsn.has('_maxValueInteger') then
        result.maxValue := ParseInteger(jsn['maxValueInteger'], jsn.vObj['_maxValueInteger']);
    if jsn.has('maxValueDateTime') or jsn.has('_maxValueDateTime') then
        result.maxValue := ParseDateTime(jsn['maxValueDateTime'], jsn.vObj['_maxValueDateTime']);
    if jsn.has('maxValueUnsignedInt') or jsn.has('_maxValueUnsignedInt') then
        result.maxValue := ParseUnsignedInt(jsn['maxValueUnsignedInt'], jsn.vObj['_maxValueUnsignedInt']);
    if jsn.has('maxValueCode') or jsn.has('_maxValueCode') then
        result.maxValue := ParseCode(jsn['maxValueCode'], jsn.vObj['_maxValueCode']);
    if jsn.has('maxValueDate') or jsn.has('_maxValueDate') then
        result.maxValue := ParseDate(jsn['maxValueDate'], jsn.vObj['_maxValueDate']);
    if jsn.has('maxValueDecimal') or jsn.has('_maxValueDecimal') then
        result.maxValue := ParseDecimal(jsn['maxValueDecimal'], jsn.vObj['_maxValueDecimal']);
    if jsn.has('maxValueUri') or jsn.has('_maxValueUri') then
        result.maxValue := ParseUri(jsn['maxValueUri'], jsn.vObj['_maxValueUri']);
    if jsn.has('maxValueId') or jsn.has('_maxValueId') then
        result.maxValue := ParseId(jsn['maxValueId'], jsn.vObj['_maxValueId']);
    if jsn.has('maxValueBase64Binary') or jsn.has('_maxValueBase64Binary') then
        result.maxValue := ParseBase64Binary(jsn['maxValueBase64Binary'], jsn.vObj['_maxValueBase64Binary']);
    if jsn.has('maxValueTime') or jsn.has('_maxValueTime') then
        result.maxValue := ParseTime(jsn['maxValueTime'], jsn.vObj['_maxValueTime']);
    if jsn.has('maxValueOid') or jsn.has('_maxValueOid') then
        result.maxValue := ParseOid(jsn['maxValueOid'], jsn.vObj['_maxValueOid']);
    if jsn.has('maxValueString') or jsn.has('_maxValueString') then
        result.maxValue := ParseString(jsn['maxValueString'], jsn.vObj['_maxValueString']);
    if jsn.has('maxValuePositiveInt') or jsn.has('_maxValuePositiveInt') then
        result.maxValue := ParsePositiveInt(jsn['maxValuePositiveInt'], jsn.vObj['_maxValuePositiveInt']);
    if jsn.has('maxValueBoolean') or jsn.has('_maxValueBoolean') then
        result.maxValue := ParseBoolean(jsn['maxValueBoolean'], jsn.vObj['_maxValueBoolean']);
    if jsn.has('maxValueUuid') or jsn.has('_maxValueUuid') then
        result.maxValue := ParseUuid(jsn['maxValueUuid'], jsn.vObj['_maxValueUuid']);
    if jsn.has('maxValueInstant') or jsn.has('_maxValueInstant') then
        result.maxValue := ParseInstant(jsn['maxValueInstant'], jsn.vObj['_maxValueInstant']);
    if jsn.has('maxValuePeriod') {a7} then
        result.maxValue := ParsePeriod(jsn.vObj['maxValuePeriod']);
    if jsn.has('maxValueCoding') {a7} then
        result.maxValue := ParseCoding(jsn.vObj['maxValueCoding']);
    if jsn.has('maxValueRange') {a7} then
        result.maxValue := ParseRange(jsn.vObj['maxValueRange']);
    if jsn.has('maxValueAttachment') {a7} then
        result.maxValue := ParseAttachment(jsn.vObj['maxValueAttachment']);
    if jsn.has('maxValueQuantity') {a7} then
        result.maxValue := ParseQuantity(jsn.vObj['maxValueQuantity']);
    if jsn.has('maxValueAnnotation') {a7} then
        result.maxValue := ParseAnnotation(jsn.vObj['maxValueAnnotation']);
    if jsn.has('maxValueRatio') {a7} then
        result.maxValue := ParseRatio(jsn.vObj['maxValueRatio']);
    if jsn.has('maxValueSampledData') {a7} then
        result.maxValue := ParseSampledData(jsn.vObj['maxValueSampledData']);
    if jsn.has('maxValueCodeableConcept') {a7} then
        result.maxValue := ParseCodeableConcept(jsn.vObj['maxValueCodeableConcept']);
    if jsn.has('maxValueReference') {a7} then
        result.maxValue := ParseReference(jsn.vObj['maxValueReference']);
    if jsn.has('maxValueIdentifier') {a7} then
        result.maxValue := ParseIdentifier(jsn.vObj['maxValueIdentifier']);
    if jsn.has('maxValueSignature') {a7} then
        result.maxValue := ParseSignature(jsn.vObj['maxValueSignature']);
    if jsn.has('maxValueTiming') {a9} then
        result.maxValue := ParseTiming(jsn.vObj['maxValueTiming']);
    if jsn.has('maxValueElementDefinition') {a9} then
        result.maxValue := ParseElementDefinition(jsn.vObj['maxValueElementDefinition']);
    if jsn.has('maxValueHumanName') {a9} then
        result.maxValue := ParseHumanName(jsn.vObj['maxValueHumanName']);
    if jsn.has('maxValueAddress') {a9} then
        result.maxValue := ParseAddress(jsn.vObj['maxValueAddress']);
    if jsn.has('maxValueMeta') {a9} then
        result.maxValue := ParseMeta(jsn.vObj['maxValueMeta']);
    if jsn.has('maxValueContactPoint') {a9} then
        result.maxValue := ParseContactPoint(jsn.vObj['maxValueContactPoint']);
    if jsn.has('maxLength') or jsn.has('_maxLength') then
        result.maxLengthElement := ParseInteger(jsn['maxLength'], jsn.vObj['_maxLength']);{q}
      if jsn.has('condition') or jsn.has('_condition') then
      iteratePrimitiveArray(jsn.vArr['condition'], jsn.vArr['_condition'], result.conditionList, parseId);
    if jsn.has('constraint') then
      iterateArray(jsn.vArr['constraint'], result.constraintList, parseElementDefinitionConstraint);
    if jsn.has('mustSupport') or jsn.has('_mustSupport') then
        result.mustSupportElement := ParseBoolean(jsn['mustSupport'], jsn.vObj['_mustSupport']);{q}
    if jsn.has('isModifier') or jsn.has('_isModifier') then
        result.isModifierElement := ParseBoolean(jsn['isModifier'], jsn.vObj['_isModifier']);{q}
    if jsn.has('isSummary') or jsn.has('_isSummary') then
        result.isSummaryElement := ParseBoolean(jsn['isSummary'], jsn.vObj['_isSummary']);{q}
    if jsn.has('binding') then
        result.binding := ParseElementDefinitionBinding(jsn.vObj['binding']);{q}
    if jsn.has('mapping') then
      iterateArray(jsn.vArr['mapping'], result.mappingList, parseElementDefinitionMapping);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeElementDefinition(json : TJSONWriter; name : string; elem : TFhirElementDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.representationList.Count > 0) then
  begin
    json.valueArray('representation');
    ext := false;
    for i := 0 to elem.representationList.Count - 1 do
    begin
      ext := ext or ((elem.representationList[i].id <> '') or (elem.representationList[i].hasExtensionList));
      ComposeEnumValue(json, '', elem.representationList[i], CODES_TFhirPropertyRepresentationEnum, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_representation');
      for i := 0 to elem.representationList.Count - 1 do
        ComposeEnumProps(json, '', elem.representationList[i], CODES_TFhirPropertyRepresentationEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(json, '', elem.codeList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionSlicing(json, 'slicing', elem.slicing); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'short', elem.shortElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'short', elem.shortElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'comments', elem.commentsElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'comments', elem.commentsElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.aliasList.Count > 0) then
  begin
    json.valueArray('alias');
    ext := false;
    for i := 0 to elem.aliasList.Count - 1 do
    begin
      ext := ext or ((elem.aliasList[i].id <> '') or (elem.aliasList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.aliasList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_alias');
      for i := 0 to elem.aliasList.Count - 1 do
        ComposeStringProps(json, '',elem.aliasList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIntegerValue(json, 'min', elem.minElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIntegerProps(json, 'min', elem.minElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBase(json, 'base', elem.base); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeElementDefinitionType(json, '', elem.type_List[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'nameReference', elem.nameReferenceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'nameReference', elem.nameReferenceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMarkdown) then
  begin
    ComposeMarkdownValue(json, 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue), false);
    ComposeMarkdownProps(json, 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'defaultValueInteger', TFhirInteger(elem.defaultValue), false);
    ComposeIntegerProps(json, 'defaultValueInteger', TFhirInteger(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'defaultValueDateTime', TFhirDateTime(elem.defaultValue), false);
    ComposeDateTimeProps(json, 'defaultValueDateTime', TFhirDateTime(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue), false);
    ComposeUnsignedIntProps(json, 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCode) then
  begin
    ComposeCodeValue(json, 'defaultValueCode', TFhirCode(elem.defaultValue), false);
    ComposeCodeProps(json, 'defaultValueCode', TFhirCode(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDate) then
  begin
    ComposeDateValue(json, 'defaultValueDate', TFhirDate(elem.defaultValue), false);
    ComposeDateProps(json, 'defaultValueDate', TFhirDate(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'defaultValueDecimal', TFhirDecimal(elem.defaultValue), false);
    ComposeDecimalProps(json, 'defaultValueDecimal', TFhirDecimal(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUri) then
  begin
    ComposeUriValue(json, 'defaultValueUri', TFhirUri(elem.defaultValue), false);
    ComposeUriProps(json, 'defaultValueUri', TFhirUri(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirId) then
  begin
    ComposeIdValue(json, 'defaultValueId', TFhirId(elem.defaultValue), false);
    ComposeIdProps(json, 'defaultValueId', TFhirId(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue), false);
    ComposeBase64BinaryProps(json, 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTime) then
  begin
    ComposeTimeValue(json, 'defaultValueTime', TFhirTime(elem.defaultValue), false);
    ComposeTimeProps(json, 'defaultValueTime', TFhirTime(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirOid) then
  begin
    ComposeOidValue(json, 'defaultValueOid', TFhirOid(elem.defaultValue), false);
    ComposeOidProps(json, 'defaultValueOid', TFhirOid(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirString) then
  begin
    ComposeStringValue(json, 'defaultValueString', TFhirString(elem.defaultValue), false);
    ComposeStringProps(json, 'defaultValueString', TFhirString(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue), false);
    ComposePositiveIntProps(json, 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'defaultValueBoolean', TFhirBoolean(elem.defaultValue), false);
    ComposeBooleanProps(json, 'defaultValueBoolean', TFhirBoolean(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'defaultValueUuid', TFhirUuid(elem.defaultValue), false);
    ComposeUuidProps(json, 'defaultValueUuid', TFhirUuid(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'defaultValueInstant', TFhirInstant(elem.defaultValue), false);
    ComposeInstantProps(json, 'defaultValueInstant', TFhirInstant(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirPeriod) then
    ComposePeriod(json, 'defaultValuePeriod', TFhirPeriod(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCoding) then
    ComposeCoding(json, 'defaultValueCoding', TFhirCoding(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirRange) then
    ComposeRange(json, 'defaultValueRange', TFhirRange(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAttachment) then
    ComposeAttachment(json, 'defaultValueAttachment', TFhirAttachment(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirQuantity) then
    ComposeQuantity(json, 'defaultValueQuantity', TFhirQuantity(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAnnotation) then
    ComposeAnnotation(json, 'defaultValueAnnotation', TFhirAnnotation(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirRatio) then
    ComposeRatio(json, 'defaultValueRatio', TFhirRatio(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirSampledData) then
    ComposeSampledData(json, 'defaultValueSampledData', TFhirSampledData(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'defaultValueCodeableConcept', TFhirCodeableConcept(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirReference) then
    ComposeReference(json, 'defaultValueReference', TFhirReference(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirIdentifier) then
    ComposeIdentifier(json, 'defaultValueIdentifier', TFhirIdentifier(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirSignature) then
    ComposeSignature(json, 'defaultValueSignature', TFhirSignature(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTiming) then
    ComposeTiming(json, 'defaultValueTiming', TFhirTiming(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'defaultValueElementDefinition', TFhirElementDefinition(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirHumanName) then
    ComposeHumanName(json, 'defaultValueHumanName', TFhirHumanName(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAddress) then
    ComposeAddress(json, 'defaultValueAddress', TFhirAddress(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMeta) then
    ComposeMeta(json, 'defaultValueMeta', TFhirMeta(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirContactPoint) then
    ComposeContactPoint(json, 'defaultValueContactPoint', TFhirContactPoint(elem.defaultValue));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'meaningWhenMissing', elem.meaningWhenMissingElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'meaningWhenMissing', elem.meaningWhenMissingElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMarkdown) then
  begin
    ComposeMarkdownValue(json, 'fixedMarkdown', TFhirMarkdown(elem.fixed), false);
    ComposeMarkdownProps(json, 'fixedMarkdown', TFhirMarkdown(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'fixedInteger', TFhirInteger(elem.fixed), false);
    ComposeIntegerProps(json, 'fixedInteger', TFhirInteger(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'fixedDateTime', TFhirDateTime(elem.fixed), false);
    ComposeDateTimeProps(json, 'fixedDateTime', TFhirDateTime(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'fixedUnsignedInt', TFhirUnsignedInt(elem.fixed), false);
    ComposeUnsignedIntProps(json, 'fixedUnsignedInt', TFhirUnsignedInt(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCode) then
  begin
    ComposeCodeValue(json, 'fixedCode', TFhirCode(elem.fixed), false);
    ComposeCodeProps(json, 'fixedCode', TFhirCode(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDate) then
  begin
    ComposeDateValue(json, 'fixedDate', TFhirDate(elem.fixed), false);
    ComposeDateProps(json, 'fixedDate', TFhirDate(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'fixedDecimal', TFhirDecimal(elem.fixed), false);
    ComposeDecimalProps(json, 'fixedDecimal', TFhirDecimal(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUri) then
  begin
    ComposeUriValue(json, 'fixedUri', TFhirUri(elem.fixed), false);
    ComposeUriProps(json, 'fixedUri', TFhirUri(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirId) then
  begin
    ComposeIdValue(json, 'fixedId', TFhirId(elem.fixed), false);
    ComposeIdProps(json, 'fixedId', TFhirId(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'fixedBase64Binary', TFhirBase64Binary(elem.fixed), false);
    ComposeBase64BinaryProps(json, 'fixedBase64Binary', TFhirBase64Binary(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTime) then
  begin
    ComposeTimeValue(json, 'fixedTime', TFhirTime(elem.fixed), false);
    ComposeTimeProps(json, 'fixedTime', TFhirTime(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirOid) then
  begin
    ComposeOidValue(json, 'fixedOid', TFhirOid(elem.fixed), false);
    ComposeOidProps(json, 'fixedOid', TFhirOid(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirString) then
  begin
    ComposeStringValue(json, 'fixedString', TFhirString(elem.fixed), false);
    ComposeStringProps(json, 'fixedString', TFhirString(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'fixedPositiveInt', TFhirPositiveInt(elem.fixed), false);
    ComposePositiveIntProps(json, 'fixedPositiveInt', TFhirPositiveInt(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'fixedBoolean', TFhirBoolean(elem.fixed), false);
    ComposeBooleanProps(json, 'fixedBoolean', TFhirBoolean(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'fixedUuid', TFhirUuid(elem.fixed), false);
    ComposeUuidProps(json, 'fixedUuid', TFhirUuid(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'fixedInstant', TFhirInstant(elem.fixed), false);
    ComposeInstantProps(json, 'fixedInstant', TFhirInstant(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirPeriod) then
    ComposePeriod(json, 'fixedPeriod', TFhirPeriod(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCoding) then
    ComposeCoding(json, 'fixedCoding', TFhirCoding(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirRange) then
    ComposeRange(json, 'fixedRange', TFhirRange(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAttachment) then
    ComposeAttachment(json, 'fixedAttachment', TFhirAttachment(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirQuantity) then
    ComposeQuantity(json, 'fixedQuantity', TFhirQuantity(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAnnotation) then
    ComposeAnnotation(json, 'fixedAnnotation', TFhirAnnotation(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirRatio) then
    ComposeRatio(json, 'fixedRatio', TFhirRatio(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirSampledData) then
    ComposeSampledData(json, 'fixedSampledData', TFhirSampledData(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'fixedCodeableConcept', TFhirCodeableConcept(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirReference) then
    ComposeReference(json, 'fixedReference', TFhirReference(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirIdentifier) then
    ComposeIdentifier(json, 'fixedIdentifier', TFhirIdentifier(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirSignature) then
    ComposeSignature(json, 'fixedSignature', TFhirSignature(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTiming) then
    ComposeTiming(json, 'fixedTiming', TFhirTiming(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'fixedElementDefinition', TFhirElementDefinition(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirHumanName) then
    ComposeHumanName(json, 'fixedHumanName', TFhirHumanName(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAddress) then
    ComposeAddress(json, 'fixedAddress', TFhirAddress(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMeta) then
    ComposeMeta(json, 'fixedMeta', TFhirMeta(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirContactPoint) then
    ComposeContactPoint(json, 'fixedContactPoint', TFhirContactPoint(elem.fixed));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMarkdown) then
  begin
    ComposeMarkdownValue(json, 'patternMarkdown', TFhirMarkdown(elem.pattern), false);
    ComposeMarkdownProps(json, 'patternMarkdown', TFhirMarkdown(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'patternInteger', TFhirInteger(elem.pattern), false);
    ComposeIntegerProps(json, 'patternInteger', TFhirInteger(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'patternDateTime', TFhirDateTime(elem.pattern), false);
    ComposeDateTimeProps(json, 'patternDateTime', TFhirDateTime(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'patternUnsignedInt', TFhirUnsignedInt(elem.pattern), false);
    ComposeUnsignedIntProps(json, 'patternUnsignedInt', TFhirUnsignedInt(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCode) then
  begin
    ComposeCodeValue(json, 'patternCode', TFhirCode(elem.pattern), false);
    ComposeCodeProps(json, 'patternCode', TFhirCode(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDate) then
  begin
    ComposeDateValue(json, 'patternDate', TFhirDate(elem.pattern), false);
    ComposeDateProps(json, 'patternDate', TFhirDate(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'patternDecimal', TFhirDecimal(elem.pattern), false);
    ComposeDecimalProps(json, 'patternDecimal', TFhirDecimal(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUri) then
  begin
    ComposeUriValue(json, 'patternUri', TFhirUri(elem.pattern), false);
    ComposeUriProps(json, 'patternUri', TFhirUri(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirId) then
  begin
    ComposeIdValue(json, 'patternId', TFhirId(elem.pattern), false);
    ComposeIdProps(json, 'patternId', TFhirId(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'patternBase64Binary', TFhirBase64Binary(elem.pattern), false);
    ComposeBase64BinaryProps(json, 'patternBase64Binary', TFhirBase64Binary(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTime) then
  begin
    ComposeTimeValue(json, 'patternTime', TFhirTime(elem.pattern), false);
    ComposeTimeProps(json, 'patternTime', TFhirTime(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirOid) then
  begin
    ComposeOidValue(json, 'patternOid', TFhirOid(elem.pattern), false);
    ComposeOidProps(json, 'patternOid', TFhirOid(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirString) then
  begin
    ComposeStringValue(json, 'patternString', TFhirString(elem.pattern), false);
    ComposeStringProps(json, 'patternString', TFhirString(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'patternPositiveInt', TFhirPositiveInt(elem.pattern), false);
    ComposePositiveIntProps(json, 'patternPositiveInt', TFhirPositiveInt(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'patternBoolean', TFhirBoolean(elem.pattern), false);
    ComposeBooleanProps(json, 'patternBoolean', TFhirBoolean(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'patternUuid', TFhirUuid(elem.pattern), false);
    ComposeUuidProps(json, 'patternUuid', TFhirUuid(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'patternInstant', TFhirInstant(elem.pattern), false);
    ComposeInstantProps(json, 'patternInstant', TFhirInstant(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirPeriod) then
    ComposePeriod(json, 'patternPeriod', TFhirPeriod(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCoding) then
    ComposeCoding(json, 'patternCoding', TFhirCoding(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirRange) then
    ComposeRange(json, 'patternRange', TFhirRange(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAttachment) then
    ComposeAttachment(json, 'patternAttachment', TFhirAttachment(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirQuantity) then
    ComposeQuantity(json, 'patternQuantity', TFhirQuantity(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAnnotation) then
    ComposeAnnotation(json, 'patternAnnotation', TFhirAnnotation(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirRatio) then
    ComposeRatio(json, 'patternRatio', TFhirRatio(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirSampledData) then
    ComposeSampledData(json, 'patternSampledData', TFhirSampledData(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'patternCodeableConcept', TFhirCodeableConcept(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirReference) then
    ComposeReference(json, 'patternReference', TFhirReference(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirIdentifier) then
    ComposeIdentifier(json, 'patternIdentifier', TFhirIdentifier(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirSignature) then
    ComposeSignature(json, 'patternSignature', TFhirSignature(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTiming) then
    ComposeTiming(json, 'patternTiming', TFhirTiming(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'patternElementDefinition', TFhirElementDefinition(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirHumanName) then
    ComposeHumanName(json, 'patternHumanName', TFhirHumanName(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAddress) then
    ComposeAddress(json, 'patternAddress', TFhirAddress(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMeta) then
    ComposeMeta(json, 'patternMeta', TFhirMeta(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirContactPoint) then
    ComposeContactPoint(json, 'patternContactPoint', TFhirContactPoint(elem.pattern));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirMarkdown) then
  begin
    ComposeMarkdownValue(json, 'exampleMarkdown', TFhirMarkdown(elem.example), false);
    ComposeMarkdownProps(json, 'exampleMarkdown', TFhirMarkdown(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'exampleInteger', TFhirInteger(elem.example), false);
    ComposeIntegerProps(json, 'exampleInteger', TFhirInteger(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'exampleDateTime', TFhirDateTime(elem.example), false);
    ComposeDateTimeProps(json, 'exampleDateTime', TFhirDateTime(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'exampleUnsignedInt', TFhirUnsignedInt(elem.example), false);
    ComposeUnsignedIntProps(json, 'exampleUnsignedInt', TFhirUnsignedInt(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirCode) then
  begin
    ComposeCodeValue(json, 'exampleCode', TFhirCode(elem.example), false);
    ComposeCodeProps(json, 'exampleCode', TFhirCode(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDate) then
  begin
    ComposeDateValue(json, 'exampleDate', TFhirDate(elem.example), false);
    ComposeDateProps(json, 'exampleDate', TFhirDate(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'exampleDecimal', TFhirDecimal(elem.example), false);
    ComposeDecimalProps(json, 'exampleDecimal', TFhirDecimal(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUri) then
  begin
    ComposeUriValue(json, 'exampleUri', TFhirUri(elem.example), false);
    ComposeUriProps(json, 'exampleUri', TFhirUri(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirId) then
  begin
    ComposeIdValue(json, 'exampleId', TFhirId(elem.example), false);
    ComposeIdProps(json, 'exampleId', TFhirId(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'exampleBase64Binary', TFhirBase64Binary(elem.example), false);
    ComposeBase64BinaryProps(json, 'exampleBase64Binary', TFhirBase64Binary(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirTime) then
  begin
    ComposeTimeValue(json, 'exampleTime', TFhirTime(elem.example), false);
    ComposeTimeProps(json, 'exampleTime', TFhirTime(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirOid) then
  begin
    ComposeOidValue(json, 'exampleOid', TFhirOid(elem.example), false);
    ComposeOidProps(json, 'exampleOid', TFhirOid(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirString) then
  begin
    ComposeStringValue(json, 'exampleString', TFhirString(elem.example), false);
    ComposeStringProps(json, 'exampleString', TFhirString(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'examplePositiveInt', TFhirPositiveInt(elem.example), false);
    ComposePositiveIntProps(json, 'examplePositiveInt', TFhirPositiveInt(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'exampleBoolean', TFhirBoolean(elem.example), false);
    ComposeBooleanProps(json, 'exampleBoolean', TFhirBoolean(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'exampleUuid', TFhirUuid(elem.example), false);
    ComposeUuidProps(json, 'exampleUuid', TFhirUuid(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'exampleInstant', TFhirInstant(elem.example), false);
    ComposeInstantProps(json, 'exampleInstant', TFhirInstant(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirPeriod) then
    ComposePeriod(json, 'examplePeriod', TFhirPeriod(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirCoding) then
    ComposeCoding(json, 'exampleCoding', TFhirCoding(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirRange) then
    ComposeRange(json, 'exampleRange', TFhirRange(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirAttachment) then
    ComposeAttachment(json, 'exampleAttachment', TFhirAttachment(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirQuantity) then
    ComposeQuantity(json, 'exampleQuantity', TFhirQuantity(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirAnnotation) then
    ComposeAnnotation(json, 'exampleAnnotation', TFhirAnnotation(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirRatio) then
    ComposeRatio(json, 'exampleRatio', TFhirRatio(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirSampledData) then
    ComposeSampledData(json, 'exampleSampledData', TFhirSampledData(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'exampleCodeableConcept', TFhirCodeableConcept(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirReference) then
    ComposeReference(json, 'exampleReference', TFhirReference(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirIdentifier) then
    ComposeIdentifier(json, 'exampleIdentifier', TFhirIdentifier(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirSignature) then
    ComposeSignature(json, 'exampleSignature', TFhirSignature(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirTiming) then
    ComposeTiming(json, 'exampleTiming', TFhirTiming(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'exampleElementDefinition', TFhirElementDefinition(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirHumanName) then
    ComposeHumanName(json, 'exampleHumanName', TFhirHumanName(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirAddress) then
    ComposeAddress(json, 'exampleAddress', TFhirAddress(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirMeta) then
    ComposeMeta(json, 'exampleMeta', TFhirMeta(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirContactPoint) then
    ComposeContactPoint(json, 'exampleContactPoint', TFhirContactPoint(elem.example));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirMarkdown) then
  begin
    ComposeMarkdownValue(json, 'minValueMarkdown', TFhirMarkdown(elem.minValue), false);
    ComposeMarkdownProps(json, 'minValueMarkdown', TFhirMarkdown(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'minValueInteger', TFhirInteger(elem.minValue), false);
    ComposeIntegerProps(json, 'minValueInteger', TFhirInteger(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'minValueDateTime', TFhirDateTime(elem.minValue), false);
    ComposeDateTimeProps(json, 'minValueDateTime', TFhirDateTime(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'minValueUnsignedInt', TFhirUnsignedInt(elem.minValue), false);
    ComposeUnsignedIntProps(json, 'minValueUnsignedInt', TFhirUnsignedInt(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirCode) then
  begin
    ComposeCodeValue(json, 'minValueCode', TFhirCode(elem.minValue), false);
    ComposeCodeProps(json, 'minValueCode', TFhirCode(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDate) then
  begin
    ComposeDateValue(json, 'minValueDate', TFhirDate(elem.minValue), false);
    ComposeDateProps(json, 'minValueDate', TFhirDate(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'minValueDecimal', TFhirDecimal(elem.minValue), false);
    ComposeDecimalProps(json, 'minValueDecimal', TFhirDecimal(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUri) then
  begin
    ComposeUriValue(json, 'minValueUri', TFhirUri(elem.minValue), false);
    ComposeUriProps(json, 'minValueUri', TFhirUri(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirId) then
  begin
    ComposeIdValue(json, 'minValueId', TFhirId(elem.minValue), false);
    ComposeIdProps(json, 'minValueId', TFhirId(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'minValueBase64Binary', TFhirBase64Binary(elem.minValue), false);
    ComposeBase64BinaryProps(json, 'minValueBase64Binary', TFhirBase64Binary(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirTime) then
  begin
    ComposeTimeValue(json, 'minValueTime', TFhirTime(elem.minValue), false);
    ComposeTimeProps(json, 'minValueTime', TFhirTime(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirOid) then
  begin
    ComposeOidValue(json, 'minValueOid', TFhirOid(elem.minValue), false);
    ComposeOidProps(json, 'minValueOid', TFhirOid(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirString) then
  begin
    ComposeStringValue(json, 'minValueString', TFhirString(elem.minValue), false);
    ComposeStringProps(json, 'minValueString', TFhirString(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'minValuePositiveInt', TFhirPositiveInt(elem.minValue), false);
    ComposePositiveIntProps(json, 'minValuePositiveInt', TFhirPositiveInt(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'minValueBoolean', TFhirBoolean(elem.minValue), false);
    ComposeBooleanProps(json, 'minValueBoolean', TFhirBoolean(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'minValueUuid', TFhirUuid(elem.minValue), false);
    ComposeUuidProps(json, 'minValueUuid', TFhirUuid(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'minValueInstant', TFhirInstant(elem.minValue), false);
    ComposeInstantProps(json, 'minValueInstant', TFhirInstant(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirPeriod) then
    ComposePeriod(json, 'minValuePeriod', TFhirPeriod(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirCoding) then
    ComposeCoding(json, 'minValueCoding', TFhirCoding(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirRange) then
    ComposeRange(json, 'minValueRange', TFhirRange(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirAttachment) then
    ComposeAttachment(json, 'minValueAttachment', TFhirAttachment(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirQuantity) then
    ComposeQuantity(json, 'minValueQuantity', TFhirQuantity(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirAnnotation) then
    ComposeAnnotation(json, 'minValueAnnotation', TFhirAnnotation(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirRatio) then
    ComposeRatio(json, 'minValueRatio', TFhirRatio(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirSampledData) then
    ComposeSampledData(json, 'minValueSampledData', TFhirSampledData(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'minValueCodeableConcept', TFhirCodeableConcept(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirReference) then
    ComposeReference(json, 'minValueReference', TFhirReference(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirIdentifier) then
    ComposeIdentifier(json, 'minValueIdentifier', TFhirIdentifier(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirSignature) then
    ComposeSignature(json, 'minValueSignature', TFhirSignature(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirTiming) then
    ComposeTiming(json, 'minValueTiming', TFhirTiming(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'minValueElementDefinition', TFhirElementDefinition(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirHumanName) then
    ComposeHumanName(json, 'minValueHumanName', TFhirHumanName(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirAddress) then
    ComposeAddress(json, 'minValueAddress', TFhirAddress(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirMeta) then
    ComposeMeta(json, 'minValueMeta', TFhirMeta(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirContactPoint) then
    ComposeContactPoint(json, 'minValueContactPoint', TFhirContactPoint(elem.minValue));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirMarkdown) then
  begin
    ComposeMarkdownValue(json, 'maxValueMarkdown', TFhirMarkdown(elem.maxValue), false);
    ComposeMarkdownProps(json, 'maxValueMarkdown', TFhirMarkdown(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'maxValueInteger', TFhirInteger(elem.maxValue), false);
    ComposeIntegerProps(json, 'maxValueInteger', TFhirInteger(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'maxValueDateTime', TFhirDateTime(elem.maxValue), false);
    ComposeDateTimeProps(json, 'maxValueDateTime', TFhirDateTime(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'maxValueUnsignedInt', TFhirUnsignedInt(elem.maxValue), false);
    ComposeUnsignedIntProps(json, 'maxValueUnsignedInt', TFhirUnsignedInt(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirCode) then
  begin
    ComposeCodeValue(json, 'maxValueCode', TFhirCode(elem.maxValue), false);
    ComposeCodeProps(json, 'maxValueCode', TFhirCode(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDate) then
  begin
    ComposeDateValue(json, 'maxValueDate', TFhirDate(elem.maxValue), false);
    ComposeDateProps(json, 'maxValueDate', TFhirDate(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'maxValueDecimal', TFhirDecimal(elem.maxValue), false);
    ComposeDecimalProps(json, 'maxValueDecimal', TFhirDecimal(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUri) then
  begin
    ComposeUriValue(json, 'maxValueUri', TFhirUri(elem.maxValue), false);
    ComposeUriProps(json, 'maxValueUri', TFhirUri(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirId) then
  begin
    ComposeIdValue(json, 'maxValueId', TFhirId(elem.maxValue), false);
    ComposeIdProps(json, 'maxValueId', TFhirId(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'maxValueBase64Binary', TFhirBase64Binary(elem.maxValue), false);
    ComposeBase64BinaryProps(json, 'maxValueBase64Binary', TFhirBase64Binary(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirTime) then
  begin
    ComposeTimeValue(json, 'maxValueTime', TFhirTime(elem.maxValue), false);
    ComposeTimeProps(json, 'maxValueTime', TFhirTime(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirOid) then
  begin
    ComposeOidValue(json, 'maxValueOid', TFhirOid(elem.maxValue), false);
    ComposeOidProps(json, 'maxValueOid', TFhirOid(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirString) then
  begin
    ComposeStringValue(json, 'maxValueString', TFhirString(elem.maxValue), false);
    ComposeStringProps(json, 'maxValueString', TFhirString(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'maxValuePositiveInt', TFhirPositiveInt(elem.maxValue), false);
    ComposePositiveIntProps(json, 'maxValuePositiveInt', TFhirPositiveInt(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'maxValueBoolean', TFhirBoolean(elem.maxValue), false);
    ComposeBooleanProps(json, 'maxValueBoolean', TFhirBoolean(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'maxValueUuid', TFhirUuid(elem.maxValue), false);
    ComposeUuidProps(json, 'maxValueUuid', TFhirUuid(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'maxValueInstant', TFhirInstant(elem.maxValue), false);
    ComposeInstantProps(json, 'maxValueInstant', TFhirInstant(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirPeriod) then
    ComposePeriod(json, 'maxValuePeriod', TFhirPeriod(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirCoding) then
    ComposeCoding(json, 'maxValueCoding', TFhirCoding(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirRange) then
    ComposeRange(json, 'maxValueRange', TFhirRange(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirAttachment) then
    ComposeAttachment(json, 'maxValueAttachment', TFhirAttachment(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirQuantity) then
    ComposeQuantity(json, 'maxValueQuantity', TFhirQuantity(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirAnnotation) then
    ComposeAnnotation(json, 'maxValueAnnotation', TFhirAnnotation(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirRatio) then
    ComposeRatio(json, 'maxValueRatio', TFhirRatio(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirSampledData) then
    ComposeSampledData(json, 'maxValueSampledData', TFhirSampledData(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'maxValueCodeableConcept', TFhirCodeableConcept(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirReference) then
    ComposeReference(json, 'maxValueReference', TFhirReference(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirIdentifier) then
    ComposeIdentifier(json, 'maxValueIdentifier', TFhirIdentifier(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirSignature) then
    ComposeSignature(json, 'maxValueSignature', TFhirSignature(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirTiming) then
    ComposeTiming(json, 'maxValueTiming', TFhirTiming(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'maxValueElementDefinition', TFhirElementDefinition(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirHumanName) then
    ComposeHumanName(json, 'maxValueHumanName', TFhirHumanName(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirAddress) then
    ComposeAddress(json, 'maxValueAddress', TFhirAddress(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirMeta) then
    ComposeMeta(json, 'maxValueMeta', TFhirMeta(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirContactPoint) then
    ComposeContactPoint(json, 'maxValueContactPoint', TFhirContactPoint(elem.maxValue));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIntegerValue(json, 'maxLength', elem.maxLengthElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIntegerProps(json, 'maxLength', elem.maxLengthElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.conditionList.Count > 0) then
  begin
    json.valueArray('condition');
    ext := false;
    for i := 0 to elem.conditionList.Count - 1 do
    begin
      ext := ext or ((elem.conditionList[i].id <> '') or (elem.conditionList[i].hasExtensionList));
      ComposeIdValue(json, '',elem.conditionList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_condition');
      for i := 0 to elem.conditionList.Count - 1 do
        ComposeIdProps(json, '',elem.conditionList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.constraintList.Count > 0) then
  begin
    json.valueArray('constraint');
    for i := 0 to elem.constraintList.Count - 1 do
      ComposeElementDefinitionConstraint(json, '', elem.constraintList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanValue(json, 'mustSupport', elem.mustSupportElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanProps(json, 'mustSupport', elem.mustSupportElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanValue(json, 'isModifier', elem.isModifierElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanProps(json, 'isModifier', elem.isModifierElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanValue(json, 'isSummary', elem.isSummaryElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanProps(json, 'isSummary', elem.isSummaryElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBinding(json, 'binding', elem.binding); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.mappingList.Count > 0) then
  begin
    json.valueArray('mapping');
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeElementDefinitionMapping(json, '', elem.mappingList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeElementDefinition(parent :  TRDFComplex; parentType, name : String; elem : TFhirElementDefinition; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ElementDefinition');
  end;
  composeElement(this, 'ElementDefinition', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'path', elem.pathElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.representationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition', 'representation', elem.representationList[i], CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum, i);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.representationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition', 'representation', elem.representationList[i], CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum, i);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'label', elem.label_Element, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(false, this, 'ElementDefinition', 'code', elem.codeList[i], i);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionSlicing(this, 'ElementDefinition', 'slicing', elem.slicingElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'short', elem.shortElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'definition', elem.definitionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'comments', elem.commentsElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'requirements', elem.requirementsElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.aliasList.Count - 1 do
      ComposeString(this, 'ElementDefinition', 'alias', elem.aliasList[i], i);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInteger(this, 'ElementDefinition', 'min', elem.minElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'max', elem.maxElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBase(this, 'ElementDefinition', 'base', elem.baseElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeElementDefinitionType(this, 'ElementDefinition', 'type', elem.type_List[i], i);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'nameReference', elem.nameReferenceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMarkdown) {1} then
    ComposeMarkdown(this, 'ElementDefinition', 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInteger) {1} then
    ComposeInteger(this, 'ElementDefinition', 'defaultValueInteger', TFhirInteger(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDateTime) {1} then
    ComposeDateTime(this, 'ElementDefinition', 'defaultValueDateTime', TFhirDateTime(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCode) {1} then
    ComposeCode(this, 'ElementDefinition', 'defaultValueCode', TFhirCode(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDate) {1} then
    ComposeDate(this, 'ElementDefinition', 'defaultValueDate', TFhirDate(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDecimal) {1} then
    ComposeDecimal(this, 'ElementDefinition', 'defaultValueDecimal', TFhirDecimal(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUri) {1} then
    ComposeUri(this, 'ElementDefinition', 'defaultValueUri', TFhirUri(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirId) {1} then
    ComposeId(this, 'ElementDefinition', 'defaultValueId', TFhirId(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBase64Binary) {1} then
    ComposeBase64Binary(this, 'ElementDefinition', 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTime) {1} then
    ComposeTime(this, 'ElementDefinition', 'defaultValueTime', TFhirTime(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirOid) {1} then
    ComposeOid(this, 'ElementDefinition', 'defaultValueOid', TFhirOid(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirString) {1} then
    ComposeString(this, 'ElementDefinition', 'defaultValueString', TFhirString(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirPositiveInt) {1} then
    ComposePositiveInt(this, 'ElementDefinition', 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBoolean) {1} then
    ComposeBoolean(this, 'ElementDefinition', 'defaultValueBoolean', TFhirBoolean(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUuid) {1} then
    ComposeUuid(this, 'ElementDefinition', 'defaultValueUuid', TFhirUuid(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInstant) {1} then
    ComposeInstant(this, 'ElementDefinition', 'defaultValueInstant', TFhirInstant(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirPeriod) {8} then
    ComposePeriod(this, 'ElementDefinition', 'defaultValuePeriod', TFhirPeriod(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCoding) {8} then
    ComposeCoding(false, this, 'ElementDefinition', 'defaultValueCoding', TFhirCoding(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirRange) {8} then
    ComposeRange(this, 'ElementDefinition', 'defaultValueRange', TFhirRange(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAttachment) {8} then
    ComposeAttachment(this, 'ElementDefinition', 'defaultValueAttachment', TFhirAttachment(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirQuantity) {8} then
    ComposeQuantity(this, 'ElementDefinition', 'defaultValueQuantity', TFhirQuantity(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAnnotation) {8} then
    ComposeAnnotation(this, 'ElementDefinition', 'defaultValueAnnotation', TFhirAnnotation(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirRatio) {8} then
    ComposeRatio(this, 'ElementDefinition', 'defaultValueRatio', TFhirRatio(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirSampledData) {8} then
    ComposeSampledData(this, 'ElementDefinition', 'defaultValueSampledData', TFhirSampledData(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'defaultValueCodeableConcept', TFhirCodeableConcept(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirReference) {8} then
    ComposeReference(this, 'ElementDefinition', 'defaultValueReference', TFhirReference(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirIdentifier) {8} then
    ComposeIdentifier(this, 'ElementDefinition', 'defaultValueIdentifier', TFhirIdentifier(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirSignature) {8} then
    ComposeSignature(this, 'ElementDefinition', 'defaultValueSignature', TFhirSignature(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTiming) {9} then
    ComposeTiming(this, 'ElementDefinition', 'defaultValueTiming', TFhirTiming(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirElementDefinition) {9} then
    ComposeElementDefinition(this, 'ElementDefinition', 'defaultValueElementDefinition', TFhirElementDefinition(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirHumanName) {9} then
    ComposeHumanName(this, 'ElementDefinition', 'defaultValueHumanName', TFhirHumanName(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAddress) {9} then
    ComposeAddress(this, 'ElementDefinition', 'defaultValueAddress', TFhirAddress(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMeta) {9} then
    ComposeMeta(this, 'ElementDefinition', 'defaultValueMeta', TFhirMeta(elem.defaultValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirContactPoint) {9} then
    ComposeContactPoint(this, 'ElementDefinition', 'defaultValueContactPoint', TFhirContactPoint(elem.defaultValue), -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'meaningWhenMissing', elem.meaningWhenMissingElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMarkdown) {1} then
    ComposeMarkdown(this, 'ElementDefinition', 'fixedMarkdown', TFhirMarkdown(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInteger) {1} then
    ComposeInteger(this, 'ElementDefinition', 'fixedInteger', TFhirInteger(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDateTime) {1} then
    ComposeDateTime(this, 'ElementDefinition', 'fixedDateTime', TFhirDateTime(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'fixedUnsignedInt', TFhirUnsignedInt(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCode) {1} then
    ComposeCode(this, 'ElementDefinition', 'fixedCode', TFhirCode(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDate) {1} then
    ComposeDate(this, 'ElementDefinition', 'fixedDate', TFhirDate(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDecimal) {1} then
    ComposeDecimal(this, 'ElementDefinition', 'fixedDecimal', TFhirDecimal(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUri) {1} then
    ComposeUri(this, 'ElementDefinition', 'fixedUri', TFhirUri(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirId) {1} then
    ComposeId(this, 'ElementDefinition', 'fixedId', TFhirId(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBase64Binary) {1} then
    ComposeBase64Binary(this, 'ElementDefinition', 'fixedBase64Binary', TFhirBase64Binary(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTime) {1} then
    ComposeTime(this, 'ElementDefinition', 'fixedTime', TFhirTime(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirOid) {1} then
    ComposeOid(this, 'ElementDefinition', 'fixedOid', TFhirOid(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirString) {1} then
    ComposeString(this, 'ElementDefinition', 'fixedString', TFhirString(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirPositiveInt) {1} then
    ComposePositiveInt(this, 'ElementDefinition', 'fixedPositiveInt', TFhirPositiveInt(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBoolean) {1} then
    ComposeBoolean(this, 'ElementDefinition', 'fixedBoolean', TFhirBoolean(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUuid) {1} then
    ComposeUuid(this, 'ElementDefinition', 'fixedUuid', TFhirUuid(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInstant) {1} then
    ComposeInstant(this, 'ElementDefinition', 'fixedInstant', TFhirInstant(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirPeriod) {8} then
    ComposePeriod(this, 'ElementDefinition', 'fixedPeriod', TFhirPeriod(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCoding) {8} then
    ComposeCoding(false, this, 'ElementDefinition', 'fixedCoding', TFhirCoding(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirRange) {8} then
    ComposeRange(this, 'ElementDefinition', 'fixedRange', TFhirRange(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAttachment) {8} then
    ComposeAttachment(this, 'ElementDefinition', 'fixedAttachment', TFhirAttachment(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirQuantity) {8} then
    ComposeQuantity(this, 'ElementDefinition', 'fixedQuantity', TFhirQuantity(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAnnotation) {8} then
    ComposeAnnotation(this, 'ElementDefinition', 'fixedAnnotation', TFhirAnnotation(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirRatio) {8} then
    ComposeRatio(this, 'ElementDefinition', 'fixedRatio', TFhirRatio(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirSampledData) {8} then
    ComposeSampledData(this, 'ElementDefinition', 'fixedSampledData', TFhirSampledData(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'fixedCodeableConcept', TFhirCodeableConcept(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirReference) {8} then
    ComposeReference(this, 'ElementDefinition', 'fixedReference', TFhirReference(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirIdentifier) {8} then
    ComposeIdentifier(this, 'ElementDefinition', 'fixedIdentifier', TFhirIdentifier(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirSignature) {8} then
    ComposeSignature(this, 'ElementDefinition', 'fixedSignature', TFhirSignature(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTiming) {9} then
    ComposeTiming(this, 'ElementDefinition', 'fixedTiming', TFhirTiming(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirElementDefinition) {9} then
    ComposeElementDefinition(this, 'ElementDefinition', 'fixedElementDefinition', TFhirElementDefinition(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirHumanName) {9} then
    ComposeHumanName(this, 'ElementDefinition', 'fixedHumanName', TFhirHumanName(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAddress) {9} then
    ComposeAddress(this, 'ElementDefinition', 'fixedAddress', TFhirAddress(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMeta) {9} then
    ComposeMeta(this, 'ElementDefinition', 'fixedMeta', TFhirMeta(elem.fixed), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirContactPoint) {9} then
    ComposeContactPoint(this, 'ElementDefinition', 'fixedContactPoint', TFhirContactPoint(elem.fixed), -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMarkdown) {1} then
    ComposeMarkdown(this, 'ElementDefinition', 'patternMarkdown', TFhirMarkdown(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInteger) {1} then
    ComposeInteger(this, 'ElementDefinition', 'patternInteger', TFhirInteger(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDateTime) {1} then
    ComposeDateTime(this, 'ElementDefinition', 'patternDateTime', TFhirDateTime(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'patternUnsignedInt', TFhirUnsignedInt(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCode) {1} then
    ComposeCode(this, 'ElementDefinition', 'patternCode', TFhirCode(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDate) {1} then
    ComposeDate(this, 'ElementDefinition', 'patternDate', TFhirDate(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDecimal) {1} then
    ComposeDecimal(this, 'ElementDefinition', 'patternDecimal', TFhirDecimal(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUri) {1} then
    ComposeUri(this, 'ElementDefinition', 'patternUri', TFhirUri(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirId) {1} then
    ComposeId(this, 'ElementDefinition', 'patternId', TFhirId(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBase64Binary) {1} then
    ComposeBase64Binary(this, 'ElementDefinition', 'patternBase64Binary', TFhirBase64Binary(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTime) {1} then
    ComposeTime(this, 'ElementDefinition', 'patternTime', TFhirTime(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirOid) {1} then
    ComposeOid(this, 'ElementDefinition', 'patternOid', TFhirOid(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirString) {1} then
    ComposeString(this, 'ElementDefinition', 'patternString', TFhirString(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirPositiveInt) {1} then
    ComposePositiveInt(this, 'ElementDefinition', 'patternPositiveInt', TFhirPositiveInt(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBoolean) {1} then
    ComposeBoolean(this, 'ElementDefinition', 'patternBoolean', TFhirBoolean(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUuid) {1} then
    ComposeUuid(this, 'ElementDefinition', 'patternUuid', TFhirUuid(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInstant) {1} then
    ComposeInstant(this, 'ElementDefinition', 'patternInstant', TFhirInstant(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirPeriod) {8} then
    ComposePeriod(this, 'ElementDefinition', 'patternPeriod', TFhirPeriod(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCoding) {8} then
    ComposeCoding(false, this, 'ElementDefinition', 'patternCoding', TFhirCoding(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirRange) {8} then
    ComposeRange(this, 'ElementDefinition', 'patternRange', TFhirRange(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAttachment) {8} then
    ComposeAttachment(this, 'ElementDefinition', 'patternAttachment', TFhirAttachment(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirQuantity) {8} then
    ComposeQuantity(this, 'ElementDefinition', 'patternQuantity', TFhirQuantity(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAnnotation) {8} then
    ComposeAnnotation(this, 'ElementDefinition', 'patternAnnotation', TFhirAnnotation(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirRatio) {8} then
    ComposeRatio(this, 'ElementDefinition', 'patternRatio', TFhirRatio(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirSampledData) {8} then
    ComposeSampledData(this, 'ElementDefinition', 'patternSampledData', TFhirSampledData(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'patternCodeableConcept', TFhirCodeableConcept(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirReference) {8} then
    ComposeReference(this, 'ElementDefinition', 'patternReference', TFhirReference(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirIdentifier) {8} then
    ComposeIdentifier(this, 'ElementDefinition', 'patternIdentifier', TFhirIdentifier(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirSignature) {8} then
    ComposeSignature(this, 'ElementDefinition', 'patternSignature', TFhirSignature(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTiming) {9} then
    ComposeTiming(this, 'ElementDefinition', 'patternTiming', TFhirTiming(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirElementDefinition) {9} then
    ComposeElementDefinition(this, 'ElementDefinition', 'patternElementDefinition', TFhirElementDefinition(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirHumanName) {9} then
    ComposeHumanName(this, 'ElementDefinition', 'patternHumanName', TFhirHumanName(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAddress) {9} then
    ComposeAddress(this, 'ElementDefinition', 'patternAddress', TFhirAddress(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMeta) {9} then
    ComposeMeta(this, 'ElementDefinition', 'patternMeta', TFhirMeta(elem.pattern), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirContactPoint) {9} then
    ComposeContactPoint(this, 'ElementDefinition', 'patternContactPoint', TFhirContactPoint(elem.pattern), -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirMarkdown) {1} then
    ComposeMarkdown(this, 'ElementDefinition', 'exampleMarkdown', TFhirMarkdown(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirInteger) {1} then
    ComposeInteger(this, 'ElementDefinition', 'exampleInteger', TFhirInteger(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDateTime) {1} then
    ComposeDateTime(this, 'ElementDefinition', 'exampleDateTime', TFhirDateTime(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'exampleUnsignedInt', TFhirUnsignedInt(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirCode) {1} then
    ComposeCode(this, 'ElementDefinition', 'exampleCode', TFhirCode(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDate) {1} then
    ComposeDate(this, 'ElementDefinition', 'exampleDate', TFhirDate(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDecimal) {1} then
    ComposeDecimal(this, 'ElementDefinition', 'exampleDecimal', TFhirDecimal(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUri) {1} then
    ComposeUri(this, 'ElementDefinition', 'exampleUri', TFhirUri(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirId) {1} then
    ComposeId(this, 'ElementDefinition', 'exampleId', TFhirId(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirBase64Binary) {1} then
    ComposeBase64Binary(this, 'ElementDefinition', 'exampleBase64Binary', TFhirBase64Binary(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirTime) {1} then
    ComposeTime(this, 'ElementDefinition', 'exampleTime', TFhirTime(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirOid) {1} then
    ComposeOid(this, 'ElementDefinition', 'exampleOid', TFhirOid(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirString) {1} then
    ComposeString(this, 'ElementDefinition', 'exampleString', TFhirString(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirPositiveInt) {1} then
    ComposePositiveInt(this, 'ElementDefinition', 'examplePositiveInt', TFhirPositiveInt(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirBoolean) {1} then
    ComposeBoolean(this, 'ElementDefinition', 'exampleBoolean', TFhirBoolean(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUuid) {1} then
    ComposeUuid(this, 'ElementDefinition', 'exampleUuid', TFhirUuid(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirInstant) {1} then
    ComposeInstant(this, 'ElementDefinition', 'exampleInstant', TFhirInstant(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirPeriod) {8} then
    ComposePeriod(this, 'ElementDefinition', 'examplePeriod', TFhirPeriod(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirCoding) {8} then
    ComposeCoding(false, this, 'ElementDefinition', 'exampleCoding', TFhirCoding(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirRange) {8} then
    ComposeRange(this, 'ElementDefinition', 'exampleRange', TFhirRange(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirAttachment) {8} then
    ComposeAttachment(this, 'ElementDefinition', 'exampleAttachment', TFhirAttachment(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirQuantity) {8} then
    ComposeQuantity(this, 'ElementDefinition', 'exampleQuantity', TFhirQuantity(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirAnnotation) {8} then
    ComposeAnnotation(this, 'ElementDefinition', 'exampleAnnotation', TFhirAnnotation(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirRatio) {8} then
    ComposeRatio(this, 'ElementDefinition', 'exampleRatio', TFhirRatio(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirSampledData) {8} then
    ComposeSampledData(this, 'ElementDefinition', 'exampleSampledData', TFhirSampledData(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'exampleCodeableConcept', TFhirCodeableConcept(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirReference) {8} then
    ComposeReference(this, 'ElementDefinition', 'exampleReference', TFhirReference(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirIdentifier) {8} then
    ComposeIdentifier(this, 'ElementDefinition', 'exampleIdentifier', TFhirIdentifier(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirSignature) {8} then
    ComposeSignature(this, 'ElementDefinition', 'exampleSignature', TFhirSignature(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirTiming) {9} then
    ComposeTiming(this, 'ElementDefinition', 'exampleTiming', TFhirTiming(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirElementDefinition) {9} then
    ComposeElementDefinition(this, 'ElementDefinition', 'exampleElementDefinition', TFhirElementDefinition(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirHumanName) {9} then
    ComposeHumanName(this, 'ElementDefinition', 'exampleHumanName', TFhirHumanName(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirAddress) {9} then
    ComposeAddress(this, 'ElementDefinition', 'exampleAddress', TFhirAddress(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirMeta) {9} then
    ComposeMeta(this, 'ElementDefinition', 'exampleMeta', TFhirMeta(elem.example), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirContactPoint) {9} then
    ComposeContactPoint(this, 'ElementDefinition', 'exampleContactPoint', TFhirContactPoint(elem.example), -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirMarkdown) {1} then
    ComposeMarkdown(this, 'ElementDefinition', 'minValueMarkdown', TFhirMarkdown(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInteger) {1} then
    ComposeInteger(this, 'ElementDefinition', 'minValueInteger', TFhirInteger(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDateTime) {1} then
    ComposeDateTime(this, 'ElementDefinition', 'minValueDateTime', TFhirDateTime(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'minValueUnsignedInt', TFhirUnsignedInt(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirCode) {1} then
    ComposeCode(this, 'ElementDefinition', 'minValueCode', TFhirCode(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDate) {1} then
    ComposeDate(this, 'ElementDefinition', 'minValueDate', TFhirDate(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDecimal) {1} then
    ComposeDecimal(this, 'ElementDefinition', 'minValueDecimal', TFhirDecimal(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUri) {1} then
    ComposeUri(this, 'ElementDefinition', 'minValueUri', TFhirUri(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirId) {1} then
    ComposeId(this, 'ElementDefinition', 'minValueId', TFhirId(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirBase64Binary) {1} then
    ComposeBase64Binary(this, 'ElementDefinition', 'minValueBase64Binary', TFhirBase64Binary(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirTime) {1} then
    ComposeTime(this, 'ElementDefinition', 'minValueTime', TFhirTime(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirOid) {1} then
    ComposeOid(this, 'ElementDefinition', 'minValueOid', TFhirOid(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirString) {1} then
    ComposeString(this, 'ElementDefinition', 'minValueString', TFhirString(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirPositiveInt) {1} then
    ComposePositiveInt(this, 'ElementDefinition', 'minValuePositiveInt', TFhirPositiveInt(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirBoolean) {1} then
    ComposeBoolean(this, 'ElementDefinition', 'minValueBoolean', TFhirBoolean(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUuid) {1} then
    ComposeUuid(this, 'ElementDefinition', 'minValueUuid', TFhirUuid(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInstant) {1} then
    ComposeInstant(this, 'ElementDefinition', 'minValueInstant', TFhirInstant(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirPeriod) {8} then
    ComposePeriod(this, 'ElementDefinition', 'minValuePeriod', TFhirPeriod(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirCoding) {8} then
    ComposeCoding(false, this, 'ElementDefinition', 'minValueCoding', TFhirCoding(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirRange) {8} then
    ComposeRange(this, 'ElementDefinition', 'minValueRange', TFhirRange(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirAttachment) {8} then
    ComposeAttachment(this, 'ElementDefinition', 'minValueAttachment', TFhirAttachment(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirQuantity) {8} then
    ComposeQuantity(this, 'ElementDefinition', 'minValueQuantity', TFhirQuantity(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirAnnotation) {8} then
    ComposeAnnotation(this, 'ElementDefinition', 'minValueAnnotation', TFhirAnnotation(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirRatio) {8} then
    ComposeRatio(this, 'ElementDefinition', 'minValueRatio', TFhirRatio(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirSampledData) {8} then
    ComposeSampledData(this, 'ElementDefinition', 'minValueSampledData', TFhirSampledData(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'minValueCodeableConcept', TFhirCodeableConcept(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirReference) {8} then
    ComposeReference(this, 'ElementDefinition', 'minValueReference', TFhirReference(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirIdentifier) {8} then
    ComposeIdentifier(this, 'ElementDefinition', 'minValueIdentifier', TFhirIdentifier(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirSignature) {8} then
    ComposeSignature(this, 'ElementDefinition', 'minValueSignature', TFhirSignature(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirTiming) {9} then
    ComposeTiming(this, 'ElementDefinition', 'minValueTiming', TFhirTiming(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirElementDefinition) {9} then
    ComposeElementDefinition(this, 'ElementDefinition', 'minValueElementDefinition', TFhirElementDefinition(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirHumanName) {9} then
    ComposeHumanName(this, 'ElementDefinition', 'minValueHumanName', TFhirHumanName(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirAddress) {9} then
    ComposeAddress(this, 'ElementDefinition', 'minValueAddress', TFhirAddress(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirMeta) {9} then
    ComposeMeta(this, 'ElementDefinition', 'minValueMeta', TFhirMeta(elem.minValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirContactPoint) {9} then
    ComposeContactPoint(this, 'ElementDefinition', 'minValueContactPoint', TFhirContactPoint(elem.minValue), -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirMarkdown) {1} then
    ComposeMarkdown(this, 'ElementDefinition', 'maxValueMarkdown', TFhirMarkdown(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInteger) {1} then
    ComposeInteger(this, 'ElementDefinition', 'maxValueInteger', TFhirInteger(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDateTime) {1} then
    ComposeDateTime(this, 'ElementDefinition', 'maxValueDateTime', TFhirDateTime(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'maxValueUnsignedInt', TFhirUnsignedInt(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirCode) {1} then
    ComposeCode(this, 'ElementDefinition', 'maxValueCode', TFhirCode(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDate) {1} then
    ComposeDate(this, 'ElementDefinition', 'maxValueDate', TFhirDate(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDecimal) {1} then
    ComposeDecimal(this, 'ElementDefinition', 'maxValueDecimal', TFhirDecimal(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUri) {1} then
    ComposeUri(this, 'ElementDefinition', 'maxValueUri', TFhirUri(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirId) {1} then
    ComposeId(this, 'ElementDefinition', 'maxValueId', TFhirId(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirBase64Binary) {1} then
    ComposeBase64Binary(this, 'ElementDefinition', 'maxValueBase64Binary', TFhirBase64Binary(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirTime) {1} then
    ComposeTime(this, 'ElementDefinition', 'maxValueTime', TFhirTime(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirOid) {1} then
    ComposeOid(this, 'ElementDefinition', 'maxValueOid', TFhirOid(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirString) {1} then
    ComposeString(this, 'ElementDefinition', 'maxValueString', TFhirString(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirPositiveInt) {1} then
    ComposePositiveInt(this, 'ElementDefinition', 'maxValuePositiveInt', TFhirPositiveInt(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirBoolean) {1} then
    ComposeBoolean(this, 'ElementDefinition', 'maxValueBoolean', TFhirBoolean(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUuid) {1} then
    ComposeUuid(this, 'ElementDefinition', 'maxValueUuid', TFhirUuid(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInstant) {1} then
    ComposeInstant(this, 'ElementDefinition', 'maxValueInstant', TFhirInstant(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirPeriod) {8} then
    ComposePeriod(this, 'ElementDefinition', 'maxValuePeriod', TFhirPeriod(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirCoding) {8} then
    ComposeCoding(false, this, 'ElementDefinition', 'maxValueCoding', TFhirCoding(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirRange) {8} then
    ComposeRange(this, 'ElementDefinition', 'maxValueRange', TFhirRange(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirAttachment) {8} then
    ComposeAttachment(this, 'ElementDefinition', 'maxValueAttachment', TFhirAttachment(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirQuantity) {8} then
    ComposeQuantity(this, 'ElementDefinition', 'maxValueQuantity', TFhirQuantity(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirAnnotation) {8} then
    ComposeAnnotation(this, 'ElementDefinition', 'maxValueAnnotation', TFhirAnnotation(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirRatio) {8} then
    ComposeRatio(this, 'ElementDefinition', 'maxValueRatio', TFhirRatio(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirSampledData) {8} then
    ComposeSampledData(this, 'ElementDefinition', 'maxValueSampledData', TFhirSampledData(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'maxValueCodeableConcept', TFhirCodeableConcept(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirReference) {8} then
    ComposeReference(this, 'ElementDefinition', 'maxValueReference', TFhirReference(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirIdentifier) {8} then
    ComposeIdentifier(this, 'ElementDefinition', 'maxValueIdentifier', TFhirIdentifier(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirSignature) {8} then
    ComposeSignature(this, 'ElementDefinition', 'maxValueSignature', TFhirSignature(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirTiming) {9} then
    ComposeTiming(this, 'ElementDefinition', 'maxValueTiming', TFhirTiming(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirElementDefinition) {9} then
    ComposeElementDefinition(this, 'ElementDefinition', 'maxValueElementDefinition', TFhirElementDefinition(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirHumanName) {9} then
    ComposeHumanName(this, 'ElementDefinition', 'maxValueHumanName', TFhirHumanName(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirAddress) {9} then
    ComposeAddress(this, 'ElementDefinition', 'maxValueAddress', TFhirAddress(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirMeta) {9} then
    ComposeMeta(this, 'ElementDefinition', 'maxValueMeta', TFhirMeta(elem.maxValue), -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirContactPoint) {9} then
    ComposeContactPoint(this, 'ElementDefinition', 'maxValueContactPoint', TFhirContactPoint(elem.maxValue), -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInteger(this, 'ElementDefinition', 'maxLength', elem.maxLengthElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeId(this, 'ElementDefinition', 'condition', elem.conditionList[i], i);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.constraintList.Count - 1 do
      ComposeElementDefinitionConstraint(this, 'ElementDefinition', 'constraint', elem.constraintList[i], i);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBoolean(this, 'ElementDefinition', 'mustSupport', elem.mustSupportElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBoolean(this, 'ElementDefinition', 'isModifier', elem.isModifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBoolean(this, 'ElementDefinition', 'isSummary', elem.isSummaryElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBinding(this, 'ElementDefinition', 'binding', elem.bindingElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeElementDefinitionMapping(this, 'ElementDefinition', 'mapping', elem.mappingList[i], i);
end;

function TFHIRXmlParser.ParseHumanName(element : IXmlDomElement; path : string) : TFhirHumanName;
var
  child : IXMLDOMElement;
begin
  result := TFhirHumanName.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'use') then
        result.useElement := ParseEnum(CODES_TFhirNameUseEnum, SYSTEMS_TFhirNameUseEnum, path+'/use', child){1a}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'family') then
        result.familyList.Add(ParseString(child, path+'/family')){y.2}
      else if (child.baseName = 'given') then
        result.givenList.Add(ParseString(child, path+'/given')){y.2}
      else if (child.baseName = 'prefix') then
        result.prefixList.Add(ParseString(child, path+'/prefix')){y.2}
      else if (child.baseName = 'suffix') then
        result.suffixList.Add(ParseString(child, path+'/suffix')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeHumanName(xml : TXmlBuilder; name : string; elem : TFhirHumanName);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirNameUseEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.familyList.Count - 1 do
      ComposeString(xml, 'family', elem.familyList[i]);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.givenList.Count - 1 do
      ComposeString(xml, 'given', elem.givenList[i]);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.prefixList.Count - 1 do
      ComposeString(xml, 'prefix', elem.prefixList[i]);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.suffixList.Count - 1 do
      ComposeString(xml, 'suffix', elem.suffixList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseHumanName(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHumanName(jsn)); {2}
end;

function TFHIRJsonParser.ParseHumanName(jsn : TJsonObject) : TFhirHumanName;
begin
  result := TFhirHumanName.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn['use'], jsn.vObj['_use'], CODES_TFhirNameUseEnum, SYSTEMS_TFhirNameUseEnum);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
      if jsn.has('family') or jsn.has('_family') then
      iteratePrimitiveArray(jsn.vArr['family'], jsn.vArr['_family'], result.familyList, parseString);
      if jsn.has('given') or jsn.has('_given') then
      iteratePrimitiveArray(jsn.vArr['given'], jsn.vArr['_given'], result.givenList, parseString);
      if jsn.has('prefix') or jsn.has('_prefix') then
      iteratePrimitiveArray(jsn.vArr['prefix'], jsn.vArr['_prefix'], result.prefixList, parseString);
      if jsn.has('suffix') or jsn.has('_suffix') then
      iteratePrimitiveArray(jsn.vArr['suffix'], jsn.vArr['_suffix'], result.suffixList, parseString);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeHumanName(json : TJSONWriter; name : string; elem : TFhirHumanName; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirNameUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirNameUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.familyList.Count > 0) then
  begin
    json.valueArray('family');
    ext := false;
    for i := 0 to elem.familyList.Count - 1 do
    begin
      ext := ext or ((elem.familyList[i].id <> '') or (elem.familyList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.familyList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_family');
      for i := 0 to elem.familyList.Count - 1 do
        ComposeStringProps(json, '',elem.familyList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.givenList.Count > 0) then
  begin
    json.valueArray('given');
    ext := false;
    for i := 0 to elem.givenList.Count - 1 do
    begin
      ext := ext or ((elem.givenList[i].id <> '') or (elem.givenList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.givenList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_given');
      for i := 0 to elem.givenList.Count - 1 do
        ComposeStringProps(json, '',elem.givenList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.prefixList.Count > 0) then
  begin
    json.valueArray('prefix');
    ext := false;
    for i := 0 to elem.prefixList.Count - 1 do
    begin
      ext := ext or ((elem.prefixList[i].id <> '') or (elem.prefixList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.prefixList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_prefix');
      for i := 0 to elem.prefixList.Count - 1 do
        ComposeStringProps(json, '',elem.prefixList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.suffixList.Count > 0) then
  begin
    json.valueArray('suffix');
    ext := false;
    for i := 0 to elem.suffixList.Count - 1 do
    begin
      ext := ext or ((elem.suffixList[i].id <> '') or (elem.suffixList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.suffixList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_suffix');
      for i := 0 to elem.suffixList.Count - 1 do
        ComposeStringProps(json, '',elem.suffixList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeHumanName(parent :  TRDFComplex; parentType, name : String; elem : TFhirHumanName; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:HumanName');
  end;
  composeElement(this, 'HumanName', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(this, 'HumanName', 'use', elem.UseElement, CODES_TFhirNameUseEnum, SYSTEMS_TFhirNameUseEnum, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'HumanName', 'text', elem.textElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.familyList.Count - 1 do
      ComposeString(this, 'HumanName', 'family', elem.familyList[i], i);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.givenList.Count - 1 do
      ComposeString(this, 'HumanName', 'given', elem.givenList[i], i);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.prefixList.Count - 1 do
      ComposeString(this, 'HumanName', 'prefix', elem.prefixList[i], i);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.suffixList.Count - 1 do
      ComposeString(this, 'HumanName', 'suffix', elem.suffixList[i], i);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(this, 'HumanName', 'period', elem.periodElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseAddress(element : IXmlDomElement; path : string) : TFhirAddress;
var
  child : IXMLDOMElement;
begin
  result := TFhirAddress.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'use') then
        result.useElement := ParseEnum(CODES_TFhirAddressUseEnum, SYSTEMS_TFhirAddressUseEnum, path+'/use', child){1a}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirAddressTypeEnum, SYSTEMS_TFhirAddressTypeEnum, path+'/type', child){1a}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'line') then
        result.lineList.Add(ParseString(child, path+'/line')){y.2}
      else if (child.baseName = 'city') then
        result.cityElement := ParseString(child, path+'/city') {b}
      else if (child.baseName = 'district') then
        result.districtElement := ParseString(child, path+'/district') {b}
      else if (child.baseName = 'state') then
        result.stateElement := ParseString(child, path+'/state') {b}
      else if (child.baseName = 'postalCode') then
        result.postalCodeElement := ParseString(child, path+'/postalCode') {b}
      else if (child.baseName = 'country') then
        result.countryElement := ParseString(child, path+'/country') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAddress(xml : TXmlBuilder; name : string; elem : TFhirAddress);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirAddressUseEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirAddressTypeEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.lineList.Count - 1 do
      ComposeString(xml, 'line', elem.lineList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'city', elem.cityElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'district', elem.districtElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'state', elem.stateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'postalCode', elem.postalCodeElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'country', elem.countryElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAddress(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAddress(jsn)); {2}
end;

function TFHIRJsonParser.ParseAddress(jsn : TJsonObject) : TFhirAddress;
begin
  result := TFhirAddress.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn['use'], jsn.vObj['_use'], CODES_TFhirAddressUseEnum, SYSTEMS_TFhirAddressUseEnum);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirAddressTypeEnum, SYSTEMS_TFhirAddressTypeEnum);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
      if jsn.has('line') or jsn.has('_line') then
      iteratePrimitiveArray(jsn.vArr['line'], jsn.vArr['_line'], result.lineList, parseString);
    if jsn.has('city') or jsn.has('_city') then
        result.cityElement := ParseString(jsn['city'], jsn.vObj['_city']);{q}
    if jsn.has('district') or jsn.has('_district') then
        result.districtElement := ParseString(jsn['district'], jsn.vObj['_district']);{q}
    if jsn.has('state') or jsn.has('_state') then
        result.stateElement := ParseString(jsn['state'], jsn.vObj['_state']);{q}
    if jsn.has('postalCode') or jsn.has('_postalCode') then
        result.postalCodeElement := ParseString(jsn['postalCode'], jsn.vObj['_postalCode']);{q}
    if jsn.has('country') or jsn.has('_country') then
        result.countryElement := ParseString(jsn['country'], jsn.vObj['_country']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAddress(json : TJSONWriter; name : string; elem : TFhirAddress; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirAddressUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirAddressUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirAddressTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirAddressTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.lineList.Count > 0) then
  begin
    json.valueArray('line');
    ext := false;
    for i := 0 to elem.lineList.Count - 1 do
    begin
      ext := ext or ((elem.lineList[i].id <> '') or (elem.lineList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.lineList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_line');
      for i := 0 to elem.lineList.Count - 1 do
        ComposeStringProps(json, '',elem.lineList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'city', elem.cityElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'city', elem.cityElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'district', elem.districtElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'district', elem.districtElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'state', elem.stateElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'state', elem.stateElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'postalCode', elem.postalCodeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'postalCode', elem.postalCodeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'country', elem.countryElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'country', elem.countryElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeAddress(parent :  TRDFComplex; parentType, name : String; elem : TFhirAddress; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Address');
  end;
  composeElement(this, 'Address', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(this, 'Address', 'use', elem.UseElement, CODES_TFhirAddressUseEnum, SYSTEMS_TFhirAddressUseEnum, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(this, 'Address', 'type', elem.Type_Element, CODES_TFhirAddressTypeEnum, SYSTEMS_TFhirAddressTypeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'text', elem.textElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.lineList.Count - 1 do
      ComposeString(this, 'Address', 'line', elem.lineList[i], i);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'city', elem.cityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'district', elem.districtElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'state', elem.stateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'postalCode', elem.postalCodeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'country', elem.countryElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(this, 'Address', 'period', elem.periodElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMeta(element : IXmlDomElement; path : string) : TFhirMeta;
var
  child : IXMLDOMElement;
begin
  result := TFhirMeta.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'versionId') then
        result.versionIdElement := ParseId(child, path+'/versionId') {b}
      else if (child.baseName = 'lastUpdated') then
        result.lastUpdatedElement := ParseInstant(child, path+'/lastUpdated') {b}
      else if (child.baseName = 'profile') then
        result.profileList.Add(ParseUri(child, path+'/profile')){y.2}
      else if (child.baseName = 'security') then
        result.securityList.Add(ParseCoding(child, path+'/security')){y.2}
      else if (child.baseName = 'tag') then
        result.tagList.Add(ParseCoding(child, path+'/tag')){y.2}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMeta(xml : TXmlBuilder; name : string; elem : TFhirMeta);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(xml, 'versionId', elem.versionIdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(xml, 'lastUpdated', elem.lastUpdatedElement);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeUri(xml, 'profile', elem.profileList[i]);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.securityList.Count - 1 do
      ComposeCoding(xml, 'security', elem.securityList[i]);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.tagList.Count - 1 do
      ComposeCoding(xml, 'tag', elem.tagList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMeta(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMeta(jsn)); {2}
end;

function TFHIRJsonParser.ParseMeta(jsn : TJsonObject) : TFhirMeta;
begin
  result := TFhirMeta.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('versionId') or jsn.has('_versionId') then
        result.versionIdElement := ParseId(jsn['versionId'], jsn.vObj['_versionId']);{q}
    if jsn.has('lastUpdated') or jsn.has('_lastUpdated') then
        result.lastUpdatedElement := ParseInstant(jsn['lastUpdated'], jsn.vObj['_lastUpdated']);{q}
      if jsn.has('profile') or jsn.has('_profile') then
      iteratePrimitiveArray(jsn.vArr['profile'], jsn.vArr['_profile'], result.profileList, parseUri);
    if jsn.has('security') then
      iterateArray(jsn.vArr['security'], result.securityList, parseCoding);
    if jsn.has('tag') then
      iterateArray(jsn.vArr['tag'], result.tagList, parseCoding);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMeta(json : TJSONWriter; name : string; elem : TFhirMeta; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdValue(json, 'versionId', elem.versionIdElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdProps(json, 'versionId', elem.versionIdElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantValue(json, 'lastUpdated', elem.lastUpdatedElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantProps(json, 'lastUpdated', elem.lastUpdatedElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.profileList.Count > 0) then
  begin
    json.valueArray('profile');
    ext := false;
    for i := 0 to elem.profileList.Count - 1 do
    begin
      ext := ext or ((elem.profileList[i].id <> '') or (elem.profileList[i].hasExtensionList));
      ComposeUriValue(json, '',elem.profileList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_profile');
      for i := 0 to elem.profileList.Count - 1 do
        ComposeUriProps(json, '',elem.profileList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.securityList.Count > 0) then
  begin
    json.valueArray('security');
    for i := 0 to elem.securityList.Count - 1 do
      ComposeCoding(json, '', elem.securityList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.tagList.Count > 0) then
  begin
    json.valueArray('tag');
    for i := 0 to elem.tagList.Count - 1 do
      ComposeCoding(json, '', elem.tagList[i]); {z - Coding}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeMeta(parent :  TRDFComplex; parentType, name : String; elem : TFhirMeta; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Meta');
  end;
  composeElement(this, 'Meta', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(this, 'Meta', 'versionId', elem.versionIdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(this, 'Meta', 'lastUpdated', elem.lastUpdatedElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeUri(this, 'Meta', 'profile', elem.profileList[i], i);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.securityList.Count - 1 do
      ComposeCoding(false, this, 'Meta', 'security', elem.securityList[i], i);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.tagList.Count - 1 do
      ComposeCoding(false, this, 'Meta', 'tag', elem.tagList[i], i);
end;

function TFHIRXmlParser.ParseContactPoint(element : IXmlDomElement; path : string) : TFhirContactPoint;
var
  child : IXMLDOMElement;
begin
  result := TFhirContactPoint.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.systemElement := ParseEnum(CODES_TFhirContactPointSystemEnum, SYSTEMS_TFhirContactPointSystemEnum, path+'/system', child){1a}
      else if (child.baseName = 'value') then
        result.valueElement := ParseString(child, path+'/value') {b}
      else if (child.baseName = 'use') then
        result.useElement := ParseEnum(CODES_TFhirContactPointUseEnum, SYSTEMS_TFhirContactPointUseEnum, path+'/use', child){1a}
      else if (child.baseName = 'rank') then
        result.rankElement := ParsePositiveInt(child, path+'/rank') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContactPoint(xml : TXmlBuilder; name : string; elem : TFhirContactPoint);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(xml, 'system', elem.SystemElement, CODES_TFhirContactPointSystemEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'value', elem.valueElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirContactPointUseEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveInt(xml, 'rank', elem.rankElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContactPoint(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContactPoint(jsn)); {2}
end;

function TFHIRJsonParser.ParseContactPoint(jsn : TJsonObject) : TFhirContactPoint;
begin
  result := TFhirContactPoint.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system')  then
      result.systemElement := parseEnum(jsn.path+'/system', jsn['system'], jsn.vObj['_system'], CODES_TFhirContactPointSystemEnum, SYSTEMS_TFhirContactPointSystemEnum);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn['use'], jsn.vObj['_use'], CODES_TFhirContactPointUseEnum, SYSTEMS_TFhirContactPointUseEnum);
    if jsn.has('rank') or jsn.has('_rank') then
        result.rankElement := ParsePositiveInt(jsn['rank'], jsn.vObj['_rank']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContactPoint(json : TJSONWriter; name : string; elem : TFhirContactPoint; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumValue(json, 'system', elem.SystemElement, CODES_TFhirContactPointSystemEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumProps(json, 'system', elem.SystemElement, CODES_TFhirContactPointSystemEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirContactPointUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirContactPointUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveIntValue(json, 'rank', elem.rankElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveIntProps(json, 'rank', elem.rankElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeContactPoint(parent :  TRDFComplex; parentType, name : String; elem : TFhirContactPoint; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ContactPoint');
  end;
  composeElement(this, 'ContactPoint', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(this, 'ContactPoint', 'system', elem.SystemElement, CODES_TFhirContactPointSystemEnum, SYSTEMS_TFhirContactPointSystemEnum, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ContactPoint', 'value', elem.valueElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(this, 'ContactPoint', 'use', elem.UseElement, CODES_TFhirContactPointUseEnum, SYSTEMS_TFhirContactPointUseEnum, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveInt(this, 'ContactPoint', 'rank', elem.rankElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(this, 'ContactPoint', 'period', elem.periodElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseAccount(element : IXmlDomElement; path : string) : TFhirAccount;
var
  child : IXMLDOMElement;
begin
  result := TFhirAccount.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseCode(child, path+'/status') {b}
      else if (child.baseName = 'activePeriod') then
        result.activePeriod := ParsePeriod(child, path+'/activePeriod') {b}
      else if (child.baseName = 'currency') then
        result.currency := ParseCoding(child, path+'/currency') {b}
      else if (child.baseName = 'balance') then
        result.balance := ParseQuantity(child, path+'/balance') {b}
      else if (child.baseName = 'coveragePeriod') then
        result.coveragePeriod := ParsePeriod(child, path+'/coveragePeriod') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'owner') then
        result.owner := ParseReference{TFhirOrganization}(child, path+'/owner') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAccount(xml : TXmlBuilder; name : string; elem : TFhirAccount);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'status', elem.statusElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'activePeriod', elem.activePeriod);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'currency', elem.currency);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'balance', elem.balance);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'coveragePeriod', elem.coveragePeriod);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'owner', elem.owner);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAccount(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAccount(jsn)); {2}
end;

function TFHIRJsonParser.ParseAccount(jsn : TJsonObject) : TFhirAccount;
begin
  result := TFhirAccount.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('status') or jsn.has('_status') then
        result.statusElement := ParseCode(jsn['status'], jsn.vObj['_status']);{q}
    if jsn.has('activePeriod') then
        result.activePeriod := ParsePeriod(jsn.vObj['activePeriod']);{q}
    if jsn.has('currency') then
        result.currency := ParseCoding(jsn.vObj['currency']);{q}
    if jsn.has('balance') then
        result.balance := ParseQuantity(jsn.vObj['balance']);{q}
    if jsn.has('coveragePeriod') then
        result.coveragePeriod := ParsePeriod(jsn.vObj['coveragePeriod']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('owner') then
        result.owner := ParseReference{TFhirOrganization}(jsn.vObj['owner']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAccount(json : TJSONWriter; name : string; elem : TFhirAccount; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeValue(json, 'status', elem.statusElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeProps(json, 'status', elem.statusElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'activePeriod', elem.activePeriod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'currency', elem.currency); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'balance', elem.balance); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'coveragePeriod', elem.coveragePeriod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'owner', elem.owner); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
end;

procedure TFHIRRDFComposer.ComposeAccount(parent :  TRDFComplex; parentType, name : String; elem : TFhirAccount; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Account');
  end;
  composeDomainResource(this, 'Account', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Account', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Account', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Account', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'Account', 'status', elem.statusElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Account', 'activePeriod', elem.activePeriodElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'Account', 'currency', elem.currencyElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Account', 'balance', elem.balanceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Account', 'coveragePeriod', elem.coveragePeriodElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Account', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Account', 'owner', elem.ownerElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Account', 'description', elem.descriptionElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseAllergyIntoleranceReaction(element : IXmlDomElement; path : string) : TFhirAllergyIntoleranceReaction;
var
  child : IXMLDOMElement;
begin
  result := TFhirAllergyIntoleranceReaction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'substance') then
        result.substance := ParseCodeableConcept(child, path+'/substance') {b}
      else if (child.baseName = 'certainty') then
        result.certaintyElement := ParseEnum(CODES_TFhirReactionEventCertaintyEnum, SYSTEMS_TFhirReactionEventCertaintyEnum, path+'/certainty', child){1a}
      else if (child.baseName = 'manifestation') then
        result.manifestationList.Add(ParseCodeableConcept(child, path+'/manifestation')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'onset') then
        result.onsetElement := ParseDateTime(child, path+'/onset') {b}
      else if (child.baseName = 'severity') then
        result.severityElement := ParseEnum(CODES_TFhirReactionEventSeverityEnum, SYSTEMS_TFhirReactionEventSeverityEnum, path+'/severity', child){1a}
      else if (child.baseName = 'exposureRoute') then
        result.exposureRoute := ParseCodeableConcept(child, path+'/exposureRoute') {b}
      else if (child.baseName = 'note') then
        result.note := ParseAnnotation(child, path+'/note') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntoleranceReaction(xml : TXmlBuilder; name : string; elem : TFhirAllergyIntoleranceReaction);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'substance', elem.substance);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'certainty', elem.CertaintyElement, CODES_TFhirReactionEventCertaintyEnum);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.manifestationList.Count - 1 do
      ComposeCodeableConcept(xml, 'manifestation', elem.manifestationList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'onset', elem.onsetElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'severity', elem.SeverityElement, CODES_TFhirReactionEventSeverityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'exposureRoute', elem.exposureRoute);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(xml, 'note', elem.note);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAllergyIntoleranceReaction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAllergyIntoleranceReaction(jsn)); {2}
end;

function TFHIRJsonParser.ParseAllergyIntoleranceReaction(jsn : TJsonObject) : TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('substance') then
        result.substance := ParseCodeableConcept(jsn.vObj['substance']);{q}
    if jsn.has('certainty') or jsn.has('_certainty')  then
      result.certaintyElement := parseEnum(jsn.path+'/certainty', jsn['certainty'], jsn.vObj['_certainty'], CODES_TFhirReactionEventCertaintyEnum, SYSTEMS_TFhirReactionEventCertaintyEnum);
    if jsn.has('manifestation') then
      iterateArray(jsn.vArr['manifestation'], result.manifestationList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('onset') or jsn.has('_onset') then
        result.onsetElement := ParseDateTime(jsn['onset'], jsn.vObj['_onset']);{q}
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityElement := parseEnum(jsn.path+'/severity', jsn['severity'], jsn.vObj['_severity'], CODES_TFhirReactionEventSeverityEnum, SYSTEMS_TFhirReactionEventSeverityEnum);
    if jsn.has('exposureRoute') then
        result.exposureRoute := ParseCodeableConcept(jsn.vObj['exposureRoute']);{q}
    if jsn.has('note') then
        result.note := ParseAnnotation(jsn.vObj['note']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAllergyIntoleranceReaction(json : TJSONWriter; name : string; elem : TFhirAllergyIntoleranceReaction; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'substance', elem.substance); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'certainty', elem.CertaintyElement, CODES_TFhirReactionEventCertaintyEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'certainty', elem.CertaintyElement, CODES_TFhirReactionEventCertaintyEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.manifestationList.Count > 0) then
  begin
    json.valueArray('manifestation');
    for i := 0 to elem.manifestationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.manifestationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'onset', elem.onsetElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'onset', elem.onsetElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'severity', elem.SeverityElement, CODES_TFhirReactionEventSeverityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'severity', elem.SeverityElement, CODES_TFhirReactionEventSeverityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'exposureRoute', elem.exposureRoute); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(json, 'note', elem.note); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeAllergyIntoleranceReaction(parent :  TRDFComplex; parentType, name : String; elem : TFhirAllergyIntoleranceReaction; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:AllergyIntoleranceReaction');
  end;
  composeBackboneElement(this, 'AllergyIntoleranceReaction', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AllergyIntoleranceReaction', 'substance', elem.substanceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'AllergyIntoleranceReaction', 'certainty', elem.CertaintyElement, CODES_TFhirReactionEventCertaintyEnum, SYSTEMS_TFhirReactionEventCertaintyEnum, -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.manifestationList.Count - 1 do
      ComposeCodeableConcept(this, 'AllergyIntoleranceReaction', 'manifestation', elem.manifestationList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AllergyIntoleranceReaction', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'AllergyIntoleranceReaction', 'onset', elem.onsetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'AllergyIntoleranceReaction', 'severity', elem.SeverityElement, CODES_TFhirReactionEventSeverityEnum, SYSTEMS_TFhirReactionEventSeverityEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AllergyIntoleranceReaction', 'exposureRoute', elem.exposureRouteElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(this, 'AllergyIntoleranceReaction', 'note', elem.noteElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseAllergyIntolerance(element : IXmlDomElement; path : string) : TFhirAllergyIntolerance;
var
  child : IXMLDOMElement;
begin
  result := TFhirAllergyIntolerance.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'onset') then
        result.onsetElement := ParseDateTime(child, path+'/onset') {b}
      else if (child.baseName = 'recordedDate') then
        result.recordedDateElement := ParseDateTime(child, path+'/recordedDate') {b}
      else if (child.baseName = 'recorder') then
        result.recorder := ParseReference{Resource}(child, path+'/recorder') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'reporter') then
        result.reporter := ParseReference{Resource}(child, path+'/reporter') {b}
      else if (child.baseName = 'substance') then
        result.substance := ParseCodeableConcept(child, path+'/substance') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirAllergyIntoleranceStatusEnum, SYSTEMS_TFhirAllergyIntoleranceStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'criticality') then
        result.criticalityElement := ParseEnum(CODES_TFhirAllergyIntoleranceCriticalityEnum, SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum, path+'/criticality', child){1a}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirAllergyIntoleranceTypeEnum, SYSTEMS_TFhirAllergyIntoleranceTypeEnum, path+'/type', child){1a}
      else if (child.baseName = 'category') then
        result.categoryElement := ParseEnum(CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, path+'/category', child){1a}
      else if (child.baseName = 'lastOccurence') then
        result.lastOccurenceElement := ParseDateTime(child, path+'/lastOccurence') {b}
      else if (child.baseName = 'note') then
        result.note := ParseAnnotation(child, path+'/note') {b}
      else if (child.baseName = 'reaction') then
        result.reactionList.Add(ParseAllergyIntoleranceReaction(child, path+'/reaction')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntolerance(xml : TXmlBuilder; name : string; elem : TFhirAllergyIntolerance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'onset', elem.onsetElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'recordedDate', elem.recordedDateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'recorder', elem.recorder);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'reporter', elem.reporter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'substance', elem.substance);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirAllergyIntoleranceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'criticality', elem.CriticalityElement, CODES_TFhirAllergyIntoleranceCriticalityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirAllergyIntoleranceTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'category', elem.CategoryElement, CODES_TFhirAllergyIntoleranceCategoryEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'lastOccurence', elem.lastOccurenceElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(xml, 'note', elem.note);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeAllergyIntoleranceReaction(xml, 'reaction', elem.reactionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAllergyIntolerance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAllergyIntolerance(jsn)); {2}
end;

function TFHIRJsonParser.ParseAllergyIntolerance(jsn : TJsonObject) : TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('onset') or jsn.has('_onset') then
        result.onsetElement := ParseDateTime(jsn['onset'], jsn.vObj['_onset']);{q}
    if jsn.has('recordedDate') or jsn.has('_recordedDate') then
        result.recordedDateElement := ParseDateTime(jsn['recordedDate'], jsn.vObj['_recordedDate']);{q}
    if jsn.has('recorder') then
        result.recorder := ParseReference{Resource}(jsn.vObj['recorder']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('reporter') then
        result.reporter := ParseReference{Resource}(jsn.vObj['reporter']);{q}
    if jsn.has('substance') then
        result.substance := ParseCodeableConcept(jsn.vObj['substance']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirAllergyIntoleranceStatusEnum, SYSTEMS_TFhirAllergyIntoleranceStatusEnum);
    if jsn.has('criticality') or jsn.has('_criticality')  then
      result.criticalityElement := parseEnum(jsn.path+'/criticality', jsn['criticality'], jsn.vObj['_criticality'], CODES_TFhirAllergyIntoleranceCriticalityEnum, SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirAllergyIntoleranceTypeEnum, SYSTEMS_TFhirAllergyIntoleranceTypeEnum);
    if jsn.has('category') or jsn.has('_category')  then
      result.categoryElement := parseEnum(jsn.path+'/category', jsn['category'], jsn.vObj['_category'], CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum);
    if jsn.has('lastOccurence') or jsn.has('_lastOccurence') then
        result.lastOccurenceElement := ParseDateTime(jsn['lastOccurence'], jsn.vObj['_lastOccurence']);{q}
    if jsn.has('note') then
        result.note := ParseAnnotation(jsn.vObj['note']);{q}
    if jsn.has('reaction') then
      iterateArray(jsn.vArr['reaction'], result.reactionList, parseAllergyIntoleranceReaction);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAllergyIntolerance(json : TJSONWriter; name : string; elem : TFhirAllergyIntolerance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'onset', elem.onsetElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'onset', elem.onsetElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'recordedDate', elem.recordedDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'recordedDate', elem.recordedDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'recorder', elem.recorder); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'reporter', elem.reporter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'substance', elem.substance); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirAllergyIntoleranceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirAllergyIntoleranceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'criticality', elem.CriticalityElement, CODES_TFhirAllergyIntoleranceCriticalityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'criticality', elem.CriticalityElement, CODES_TFhirAllergyIntoleranceCriticalityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirAllergyIntoleranceTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirAllergyIntoleranceTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'category', elem.CategoryElement, CODES_TFhirAllergyIntoleranceCategoryEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'category', elem.CategoryElement, CODES_TFhirAllergyIntoleranceCategoryEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'lastOccurence', elem.lastOccurenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'lastOccurence', elem.lastOccurenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(json, 'note', elem.note); {a}
  if (SummaryOption in [soFull, soData]) and (elem.reactionList.Count > 0) then
  begin
    json.valueArray('reaction');
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeAllergyIntoleranceReaction(json, '', elem.reactionList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeAllergyIntolerance(parent :  TRDFComplex; parentType, name : String; elem : TFhirAllergyIntolerance; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:AllergyIntolerance');
  end;
  composeDomainResource(this, 'AllergyIntolerance', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'AllergyIntolerance', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'AllergyIntolerance', 'onset', elem.onsetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'AllergyIntolerance', 'recordedDate', elem.recordedDateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'AllergyIntolerance', 'recorder', elem.recorderElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'AllergyIntolerance', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'AllergyIntolerance', 'reporter', elem.reporterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AllergyIntolerance', 'substance', elem.substanceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'AllergyIntolerance', 'status', elem.StatusElement, CODES_TFhirAllergyIntoleranceStatusEnum, SYSTEMS_TFhirAllergyIntoleranceStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'AllergyIntolerance', 'criticality', elem.CriticalityElement, CODES_TFhirAllergyIntoleranceCriticalityEnum, SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'AllergyIntolerance', 'type', elem.Type_Element, CODES_TFhirAllergyIntoleranceTypeEnum, SYSTEMS_TFhirAllergyIntoleranceTypeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'AllergyIntolerance', 'category', elem.CategoryElement, CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'AllergyIntolerance', 'lastOccurence', elem.lastOccurenceElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(this, 'AllergyIntolerance', 'note', elem.noteElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeAllergyIntoleranceReaction(this, 'AllergyIntolerance', 'reaction', elem.reactionList[i], i);
end;

function TFHIRXmlParser.ParseAppointmentParticipant(element : IXmlDomElement; path : string) : TFhirAppointmentParticipant;
var
  child : IXMLDOMElement;
begin
  result := TFhirAppointmentParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.baseName = 'actor') then
        result.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.baseName = 'required') then
        result.requiredElement := ParseEnum(CODES_TFhirParticipantrequiredEnum, SYSTEMS_TFhirParticipantrequiredEnum, path+'/required', child){1a}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum, path+'/status', child){1a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAppointmentParticipant(xml : TXmlBuilder; name : string; elem : TFhirAppointmentParticipant);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'required', elem.RequiredElement, CODES_TFhirParticipantrequiredEnum);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirParticipationstatusEnum);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAppointmentParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAppointmentParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseAppointmentParticipant(jsn : TJsonObject) : TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('actor') then
        result.actor := ParseReference{Resource}(jsn.vObj['actor']);{q}
    if jsn.has('required') or jsn.has('_required')  then
      result.requiredElement := parseEnum(jsn.path+'/required', jsn['required'], jsn.vObj['_required'], CODES_TFhirParticipantrequiredEnum, SYSTEMS_TFhirParticipantrequiredEnum);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAppointmentParticipant(json : TJSONWriter; name : string; elem : TFhirAppointmentParticipant; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'actor', elem.actor); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'required', elem.RequiredElement, CODES_TFhirParticipantrequiredEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'required', elem.RequiredElement, CODES_TFhirParticipantrequiredEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirParticipationstatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirParticipationstatusEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeAppointmentParticipant(parent :  TRDFComplex; parentType, name : String; elem : TFhirAppointmentParticipant; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:AppointmentParticipant');
  end;
  composeBackboneElement(this, 'AppointmentParticipant', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'AppointmentParticipant', 'type', elem.type_List[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'AppointmentParticipant', 'actor', elem.actorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'AppointmentParticipant', 'required', elem.RequiredElement, CODES_TFhirParticipantrequiredEnum, SYSTEMS_TFhirParticipantrequiredEnum, -1);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'AppointmentParticipant', 'status', elem.StatusElement, CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum, -1);
end;

function TFHIRXmlParser.ParseAppointment(element : IXmlDomElement; path : string) : TFhirAppointment;
var
  child : IXMLDOMElement;
begin
  result := TFhirAppointment.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirAppointmentstatusEnum, SYSTEMS_TFhirAppointmentstatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.baseName = 'priority') then
        result.priorityElement := ParseUnsignedInt(child, path+'/priority') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'start') then
        result.startElement := ParseInstant(child, path+'/start') {b}
      else if (child.baseName = 'end') then
        result.end_Element := ParseInstant(child, path+'/end') {b}
      else if (child.baseName = 'minutesDuration') then
        result.minutesDurationElement := ParsePositiveInt(child, path+'/minutesDuration') {b}
      else if (child.baseName = 'slot') then
        result.slotList.Add(ParseReference{TFhirSlot}(child, path+'/slot')){y.2}
      else if (child.baseName = 'comment') then
        result.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.baseName = 'participant') then
        result.participantList.Add(ParseAppointmentParticipant(child, path+'/participant')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAppointment(xml : TXmlBuilder; name : string; elem : TFhirAppointment);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirAppointmentstatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(xml, 'priority', elem.priorityElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'start', elem.startElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'end', elem.end_Element);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'minutesDuration', elem.minutesDurationElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.slotList.Count - 1 do
      ComposeReference{TFhirSlot}(xml, 'slot', elem.slotList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', elem.commentElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeAppointmentParticipant(xml, 'participant', elem.participantList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAppointment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAppointment(jsn)); {2}
end;

function TFHIRJsonParser.ParseAppointment(jsn : TJsonObject) : TFhirAppointment;
begin
  result := TFhirAppointment.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirAppointmentstatusEnum, SYSTEMS_TFhirAppointmentstatusEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    if jsn.has('priority') or jsn.has('_priority') then
        result.priorityElement := ParseUnsignedInt(jsn['priority'], jsn.vObj['_priority']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := ParseInstant(jsn['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := ParseInstant(jsn['end'], jsn.vObj['_end']);{q}
    if jsn.has('minutesDuration') or jsn.has('_minutesDuration') then
        result.minutesDurationElement := ParsePositiveInt(jsn['minutesDuration'], jsn.vObj['_minutesDuration']);{q}
    if jsn.has('slot') then
      iterateArray(jsn.vArr['slot'], result.slotList, parseReference{TFhirSlot});
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseAppointmentParticipant);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAppointment(json : TJSONWriter; name : string; elem : TFhirAppointment; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirAppointmentstatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirAppointmentstatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedIntValue(json, 'priority', elem.priorityElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedIntProps(json, 'priority', elem.priorityElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantValue(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantProps(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantValue(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantProps(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntValue(json, 'minutesDuration', elem.minutesDurationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntProps(json, 'minutesDuration', elem.minutesDurationElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.slotList.Count > 0) then
  begin
    json.valueArray('slot');
    for i := 0 to elem.slotList.Count - 1 do
      ComposeReference{TFhirSlot}(json, '', elem.slotList[i]); {z - Reference(Slot)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.participantList.Count > 0) then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeAppointmentParticipant(json, '', elem.participantList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeAppointment(parent :  TRDFComplex; parentType, name : String; elem : TFhirAppointment; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Appointment');
  end;
  composeDomainResource(this, 'Appointment', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Appointment', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Appointment', 'status', elem.StatusElement, CODES_TFhirAppointmentstatusEnum, SYSTEMS_TFhirAppointmentstatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Appointment', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Appointment', 'reason', elem.reasonElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'Appointment', 'priority', elem.priorityElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Appointment', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'Appointment', 'start', elem.startElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'Appointment', 'end', elem.end_Element, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Appointment', 'minutesDuration', elem.minutesDurationElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.slotList.Count - 1 do
      ComposeReference{TFhirSlot}(this, 'Appointment', 'slot', elem.slotList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Appointment', 'comment', elem.commentElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeAppointmentParticipant(this, 'Appointment', 'participant', elem.participantList[i], i);
end;

function TFHIRXmlParser.ParseAppointmentResponse(element : IXmlDomElement; path : string) : TFhirAppointmentResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirAppointmentResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'appointment') then
        result.appointment := ParseReference{TFhirAppointment}(child, path+'/appointment') {b}
      else if (child.baseName = 'start') then
        result.startElement := ParseInstant(child, path+'/start') {b}
      else if (child.baseName = 'end') then
        result.end_Element := ParseInstant(child, path+'/end') {b}
      else if (child.baseName = 'participantType') then
        result.participantTypeList.Add(ParseCodeableConcept(child, path+'/participantType')){y.2}
      else if (child.baseName = 'actor') then
        result.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.baseName = 'participantStatus') then
        result.participantStatusElement := ParseEnum(CODES_TFhirParticipantstatusEnum, SYSTEMS_TFhirParticipantstatusEnum, path+'/participantStatus', child){1a}
      else if (child.baseName = 'comment') then
        result.commentElement := ParseString(child, path+'/comment') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAppointmentResponse(xml : TXmlBuilder; name : string; elem : TFhirAppointmentResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirAppointment}(xml, 'appointment', elem.appointment);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeInstant(xml, 'start', elem.startElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeInstant(xml, 'end', elem.end_Element);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.participantTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'participantType', elem.participantTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'participantStatus', elem.ParticipantStatusElement, CODES_TFhirParticipantstatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', elem.commentElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAppointmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAppointmentResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseAppointmentResponse(jsn : TJsonObject) : TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('appointment') then
        result.appointment := ParseReference{TFhirAppointment}(jsn.vObj['appointment']);{q}
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := ParseInstant(jsn['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := ParseInstant(jsn['end'], jsn.vObj['_end']);{q}
    if jsn.has('participantType') then
      iterateArray(jsn.vArr['participantType'], result.participantTypeList, parseCodeableConcept);
    if jsn.has('actor') then
        result.actor := ParseReference{Resource}(jsn.vObj['actor']);{q}
    if jsn.has('participantStatus') or jsn.has('_participantStatus')  then
      result.participantStatusElement := parseEnum(jsn.path+'/participantStatus', jsn['participantStatus'], jsn.vObj['_participantStatus'], CODES_TFhirParticipantstatusEnum, SYSTEMS_TFhirParticipantstatusEnum);
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAppointmentResponse(json : TJSONWriter; name : string; elem : TFhirAppointmentResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirAppointment}(json, 'appointment', elem.appointment); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeInstantValue(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeInstantProps(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeInstantValue(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeInstantProps(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.participantTypeList.Count > 0) then
  begin
    json.valueArray('participantType');
    for i := 0 to elem.participantTypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.participantTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'actor', elem.actor); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'participantStatus', elem.ParticipantStatusElement, CODES_TFhirParticipantstatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'participantStatus', elem.ParticipantStatusElement, CODES_TFhirParticipantstatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
end;

procedure TFHIRRDFComposer.ComposeAppointmentResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirAppointmentResponse; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:AppointmentResponse');
  end;
  composeDomainResource(this, 'AppointmentResponse', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'AppointmentResponse', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirAppointment}(this, 'AppointmentResponse', 'appointment', elem.appointmentElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeInstant(this, 'AppointmentResponse', 'start', elem.startElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeInstant(this, 'AppointmentResponse', 'end', elem.end_Element, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.participantTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'AppointmentResponse', 'participantType', elem.participantTypeList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'AppointmentResponse', 'actor', elem.actorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'AppointmentResponse', 'participantStatus', elem.ParticipantStatusElement, CODES_TFhirParticipantstatusEnum, SYSTEMS_TFhirParticipantstatusEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AppointmentResponse', 'comment', elem.commentElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseAuditEventEvent(element : IXmlDomElement; path : string) : TFhirAuditEventEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirAuditEventEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'subtype') then
        result.subtypeList.Add(ParseCoding(child, path+'/subtype')){y.2}
      else if (child.baseName = 'action') then
        result.actionElement := ParseEnum(CODES_TFhirAuditEventActionEnum, SYSTEMS_TFhirAuditEventActionEnum, path+'/action', child){1a}
      else if (child.baseName = 'dateTime') then
        result.dateTimeElement := ParseInstant(child, path+'/dateTime') {b}
      else if (child.baseName = 'outcome') then
        result.outcomeElement := ParseEnum(CODES_TFhirAuditEventOutcomeEnum, SYSTEMS_TFhirAuditEventOutcomeEnum, path+'/outcome', child){1a}
      else if (child.baseName = 'outcomeDesc') then
        result.outcomeDescElement := ParseString(child, path+'/outcomeDesc') {b}
      else if (child.baseName = 'purposeOfEvent') then
        result.purposeOfEventList.Add(ParseCoding(child, path+'/purposeOfEvent')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAuditEventEvent(xml : TXmlBuilder; name : string; elem : TFhirAuditEventEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.subtypeList.Count - 1 do
      ComposeCoding(xml, 'subtype', elem.subtypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'action', elem.ActionElement, CODES_TFhirAuditEventActionEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'dateTime', elem.dateTimeElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirAuditEventOutcomeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'outcomeDesc', elem.outcomeDescElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.purposeOfEventList.Count - 1 do
      ComposeCoding(xml, 'purposeOfEvent', elem.purposeOfEventList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAuditEventEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventEvent(jsn : TJsonObject) : TFhirAuditEventEvent;
begin
  result := TFhirAuditEventEvent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('subtype') then
      iterateArray(jsn.vArr['subtype'], result.subtypeList, parseCoding);
    if jsn.has('action') or jsn.has('_action')  then
      result.actionElement := parseEnum(jsn.path+'/action', jsn['action'], jsn.vObj['_action'], CODES_TFhirAuditEventActionEnum, SYSTEMS_TFhirAuditEventActionEnum);
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeElement := ParseInstant(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn['outcome'], jsn.vObj['_outcome'], CODES_TFhirAuditEventOutcomeEnum, SYSTEMS_TFhirAuditEventOutcomeEnum);
    if jsn.has('outcomeDesc') or jsn.has('_outcomeDesc') then
        result.outcomeDescElement := ParseString(jsn['outcomeDesc'], jsn.vObj['_outcomeDesc']);{q}
    if jsn.has('purposeOfEvent') then
      iterateArray(jsn.vArr['purposeOfEvent'], result.purposeOfEventList, parseCoding);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAuditEventEvent(json : TJSONWriter; name : string; elem : TFhirAuditEventEvent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.subtypeList.Count > 0) then
  begin
    json.valueArray('subtype');
    for i := 0 to elem.subtypeList.Count - 1 do
      ComposeCoding(json, '', elem.subtypeList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'action', elem.ActionElement, CODES_TFhirAuditEventActionEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'action', elem.ActionElement, CODES_TFhirAuditEventActionEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantValue(json, 'dateTime', elem.dateTimeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantProps(json, 'dateTime', elem.dateTimeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirAuditEventOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirAuditEventOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'outcomeDesc', elem.outcomeDescElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'outcomeDesc', elem.outcomeDescElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.purposeOfEventList.Count > 0) then
  begin
    json.valueArray('purposeOfEvent');
    for i := 0 to elem.purposeOfEventList.Count - 1 do
      ComposeCoding(json, '', elem.purposeOfEventList[i]); {z - Coding}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeAuditEventEvent(parent :  TRDFComplex; parentType, name : String; elem : TFhirAuditEventEvent; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:AuditEventEvent');
  end;
  composeBackboneElement(this, 'AuditEventEvent', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'AuditEventEvent', 'type', elem.type_Element, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.subtypeList.Count - 1 do
      ComposeCoding(false, this, 'AuditEventEvent', 'subtype', elem.subtypeList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'AuditEventEvent', 'action', elem.ActionElement, CODES_TFhirAuditEventActionEnum, SYSTEMS_TFhirAuditEventActionEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'AuditEventEvent', 'dateTime', elem.dateTimeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'AuditEventEvent', 'outcome', elem.OutcomeElement, CODES_TFhirAuditEventOutcomeEnum, SYSTEMS_TFhirAuditEventOutcomeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'AuditEventEvent', 'outcomeDesc', elem.outcomeDescElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.purposeOfEventList.Count - 1 do
      ComposeCoding(false, this, 'AuditEventEvent', 'purposeOfEvent', elem.purposeOfEventList[i], i);
end;

function TFHIRXmlParser.ParseAuditEventParticipant(element : IXmlDomElement; path : string) : TFhirAuditEventParticipant;
var
  child : IXMLDOMElement;
begin
  result := TFhirAuditEventParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'role') then
        result.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if (child.baseName = 'reference') then
        result.reference := ParseReference{Resource}(child, path+'/reference') {b}
      else if (child.baseName = 'userId') then
        result.userId := ParseIdentifier(child, path+'/userId') {b}
      else if (child.baseName = 'altId') then
        result.altIdElement := ParseString(child, path+'/altId') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'requestor') then
        result.requestorElement := ParseBoolean(child, path+'/requestor') {b}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'policy') then
        result.policyList.Add(ParseUri(child, path+'/policy')){y.2}
      else if (child.baseName = 'media') then
        result.media := ParseCoding(child, path+'/media') {b}
      else if (child.baseName = 'network') then
        result.network := ParseAuditEventParticipantNetwork(child, path+'/network') {b}
      else if (child.baseName = 'purposeOfUse') then
        result.purposeOfUseList.Add(ParseCoding(child, path+'/purposeOfUse')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAuditEventParticipant(xml : TXmlBuilder; name : string; elem : TFhirAuditEventParticipant);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'reference', elem.reference);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'userId', elem.userId);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'altId', elem.altIdElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'requestor', elem.requestorElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.policyList.Count - 1 do
      ComposeUri(xml, 'policy', elem.policyList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'media', elem.media);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeAuditEventParticipantNetwork(xml, 'network', elem.network);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.purposeOfUseList.Count - 1 do
      ComposeCoding(xml, 'purposeOfUse', elem.purposeOfUseList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAuditEventParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventParticipant(jsn : TJsonObject) : TFhirAuditEventParticipant;
begin
  result := TFhirAuditEventParticipant.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
    if jsn.has('reference') then
        result.reference := ParseReference{Resource}(jsn.vObj['reference']);{q}
    if jsn.has('userId') then
        result.userId := ParseIdentifier(jsn.vObj['userId']);{q}
    if jsn.has('altId') or jsn.has('_altId') then
        result.altIdElement := ParseString(jsn['altId'], jsn.vObj['_altId']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('requestor') or jsn.has('_requestor') then
        result.requestorElement := ParseBoolean(jsn['requestor'], jsn.vObj['_requestor']);{q}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
      if jsn.has('policy') or jsn.has('_policy') then
      iteratePrimitiveArray(jsn.vArr['policy'], jsn.vArr['_policy'], result.policyList, parseUri);
    if jsn.has('media') then
        result.media := ParseCoding(jsn.vObj['media']);{q}
    if jsn.has('network') then
        result.network := ParseAuditEventParticipantNetwork(jsn.vObj['network']);{q}
    if jsn.has('purposeOfUse') then
      iterateArray(jsn.vArr['purposeOfUse'], result.purposeOfUseList, parseCoding);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAuditEventParticipant(json : TJSONWriter; name : string; elem : TFhirAuditEventParticipant; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.roleList.Count > 0) then
  begin
    json.valueArray('role');
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.roleList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'reference', elem.reference); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'userId', elem.userId); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'altId', elem.altIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'altId', elem.altIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'requestor', elem.requestorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'requestor', elem.requestorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) and (elem.policyList.Count > 0) then
  begin
    json.valueArray('policy');
    ext := false;
    for i := 0 to elem.policyList.Count - 1 do
    begin
      ext := ext or ((elem.policyList[i].id <> '') or (elem.policyList[i].hasExtensionList));
      ComposeUriValue(json, '',elem.policyList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_policy');
      for i := 0 to elem.policyList.Count - 1 do
        ComposeUriProps(json, '',elem.policyList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'media', elem.media); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeAuditEventParticipantNetwork(json, 'network', elem.network); {a}
  if (SummaryOption in [soFull, soData]) and (elem.purposeOfUseList.Count > 0) then
  begin
    json.valueArray('purposeOfUse');
    for i := 0 to elem.purposeOfUseList.Count - 1 do
      ComposeCoding(json, '', elem.purposeOfUseList[i]); {z - Coding}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeAuditEventParticipant(parent :  TRDFComplex; parentType, name : String; elem : TFhirAuditEventParticipant; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:AuditEventParticipant');
  end;
  composeBackboneElement(this, 'AuditEventParticipant', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'AuditEventParticipant', 'role', elem.roleList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'AuditEventParticipant', 'reference', elem.referenceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'AuditEventParticipant', 'userId', elem.userIdElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEventParticipant', 'altId', elem.altIdElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEventParticipant', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'AuditEventParticipant', 'requestor', elem.requestorElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'AuditEventParticipant', 'location', elem.locationElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.policyList.Count - 1 do
      ComposeUri(this, 'AuditEventParticipant', 'policy', elem.policyList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(false, this, 'AuditEventParticipant', 'media', elem.mediaElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeAuditEventParticipantNetwork(this, 'AuditEventParticipant', 'network', elem.networkElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.purposeOfUseList.Count - 1 do
      ComposeCoding(false, this, 'AuditEventParticipant', 'purposeOfUse', elem.purposeOfUseList[i], i);
end;

function TFHIRXmlParser.ParseAuditEventParticipantNetwork(element : IXmlDomElement; path : string) : TFhirAuditEventParticipantNetwork;
var
  child : IXMLDOMElement;
begin
  result := TFhirAuditEventParticipantNetwork.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'address') then
        result.addressElement := ParseString(child, path+'/address') {b}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirNetworkTypeEnum, SYSTEMS_TFhirNetworkTypeEnum, path+'/type', child){1a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAuditEventParticipantNetwork(xml : TXmlBuilder; name : string; elem : TFhirAuditEventParticipantNetwork);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'address', elem.addressElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirNetworkTypeEnum);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAuditEventParticipantNetwork(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventParticipantNetwork(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventParticipantNetwork(jsn : TJsonObject) : TFhirAuditEventParticipantNetwork;
begin
  result := TFhirAuditEventParticipantNetwork.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('address') or jsn.has('_address') then
        result.addressElement := ParseString(jsn['address'], jsn.vObj['_address']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirNetworkTypeEnum, SYSTEMS_TFhirNetworkTypeEnum);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAuditEventParticipantNetwork(json : TJSONWriter; name : string; elem : TFhirAuditEventParticipantNetwork; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'address', elem.addressElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'address', elem.addressElement, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirNetworkTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirNetworkTypeEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeAuditEventParticipantNetwork(parent :  TRDFComplex; parentType, name : String; elem : TFhirAuditEventParticipantNetwork; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:AuditEventParticipantNetwork');
  end;
  composeBackboneElement(this, 'AuditEventParticipantNetwork', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEventParticipantNetwork', 'address', elem.addressElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'AuditEventParticipantNetwork', 'type', elem.Type_Element, CODES_TFhirNetworkTypeEnum, SYSTEMS_TFhirNetworkTypeEnum, -1);
end;

function TFHIRXmlParser.ParseAuditEventSource(element : IXmlDomElement; path : string) : TFhirAuditEventSource;
var
  child : IXMLDOMElement;
begin
  result := TFhirAuditEventSource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'site') then
        result.siteElement := ParseString(child, path+'/site') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseCoding(child, path+'/type')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAuditEventSource(xml : TXmlBuilder; name : string; elem : TFhirAuditEventSource);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'site', elem.siteElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(xml, 'type', elem.type_List[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAuditEventSource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventSource(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventSource(jsn : TJsonObject) : TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('site') or jsn.has('_site') then
        result.siteElement := ParseString(jsn['site'], jsn.vObj['_site']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCoding);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAuditEventSource(json : TJSONWriter; name : string; elem : TFhirAuditEventSource; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'site', elem.siteElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'site', elem.siteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(json, '', elem.type_List[i]); {z - Coding}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeAuditEventSource(parent :  TRDFComplex; parentType, name : String; elem : TFhirAuditEventSource; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:AuditEventSource');
  end;
  composeBackboneElement(this, 'AuditEventSource', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEventSource', 'site', elem.siteElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'AuditEventSource', 'identifier', elem.identifierElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(false, this, 'AuditEventSource', 'type', elem.type_List[i], i);
end;

function TFHIRXmlParser.ParseAuditEventObject(element : IXmlDomElement; path : string) : TFhirAuditEventObject;
var
  child : IXMLDOMElement;
begin
  result := TFhirAuditEventObject.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'reference') then
        result.reference := ParseReference{TFhirReference}(child, path+'/reference') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'role') then
        result.role := ParseCoding(child, path+'/role') {b}
      else if (child.baseName = 'lifecycle') then
        result.lifecycle := ParseCoding(child, path+'/lifecycle') {b}
      else if (child.baseName = 'securityLabel') then
        result.securityLabelList.Add(ParseCoding(child, path+'/securityLabel')){y.2}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'query') then
        result.queryElement := ParseBase64Binary(child, path+'/query') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseAuditEventObjectDetail(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAuditEventObject(xml : TXmlBuilder; name : string; elem : TFhirAuditEventObject);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'reference', elem.reference);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'role', elem.role);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'lifecycle', elem.lifecycle);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(xml, 'securityLabel', elem.securityLabelList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(xml, 'query', elem.queryElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeAuditEventObjectDetail(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAuditEventObject(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventObject(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventObject(jsn : TJsonObject) : TFhirAuditEventObject;
begin
  result := TFhirAuditEventObject.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('reference') then
        result.reference := ParseReference{TFhirReference}(jsn.vObj['reference']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('role') then
        result.role := ParseCoding(jsn.vObj['role']);{q}
    if jsn.has('lifecycle') then
        result.lifecycle := ParseCoding(jsn.vObj['lifecycle']);{q}
    if jsn.has('securityLabel') then
      iterateArray(jsn.vArr['securityLabel'], result.securityLabelList, parseCoding);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('query') or jsn.has('_query') then
        result.queryElement := ParseBase64Binary(jsn['query'], jsn.vObj['_query']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseAuditEventObjectDetail);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAuditEventObject(json : TJSONWriter; name : string; elem : TFhirAuditEventObject; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'reference', elem.reference); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'role', elem.role); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'lifecycle', elem.lifecycle); {a}
  if (SummaryOption in [soFull, soData]) and (elem.securityLabelList.Count > 0) then
  begin
    json.valueArray('securityLabel');
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(json, '', elem.securityLabelList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64BinaryValue(json, 'query', elem.queryElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64BinaryProps(json, 'query', elem.queryElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeAuditEventObjectDetail(json, '', elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeAuditEventObject(parent :  TRDFComplex; parentType, name : String; elem : TFhirAuditEventObject; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:AuditEventObject');
  end;
  composeBackboneElement(this, 'AuditEventObject', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'AuditEventObject', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'AuditEventObject', 'reference', elem.referenceElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(false, this, 'AuditEventObject', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(false, this, 'AuditEventObject', 'role', elem.roleElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(false, this, 'AuditEventObject', 'lifecycle', elem.lifecycleElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(false, this, 'AuditEventObject', 'securityLabel', elem.securityLabelList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'AuditEventObject', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEventObject', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(this, 'AuditEventObject', 'query', elem.queryElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeAuditEventObjectDetail(this, 'AuditEventObject', 'detail', elem.detailList[i], i);
end;

function TFHIRXmlParser.ParseAuditEventObjectDetail(element : IXmlDomElement; path : string) : TFhirAuditEventObjectDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirAuditEventObjectDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseString(child, path+'/type') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseBase64Binary(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAuditEventObjectDetail(xml : TXmlBuilder; name : string; elem : TFhirAuditEventObjectDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'type', elem.type_Element);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64Binary(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAuditEventObjectDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventObjectDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventObjectDetail(jsn : TJsonObject) : TFhirAuditEventObjectDetail;
begin
  result := TFhirAuditEventObjectDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := ParseString(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseBase64Binary(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAuditEventObjectDetail(json : TJSONWriter; name : string; elem : TFhirAuditEventObjectDetail; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64BinaryValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64BinaryProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeAuditEventObjectDetail(parent :  TRDFComplex; parentType, name : String; elem : TFhirAuditEventObjectDetail; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:AuditEventObjectDetail');
  end;
  composeBackboneElement(this, 'AuditEventObjectDetail', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEventObjectDetail', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64Binary(this, 'AuditEventObjectDetail', 'value', elem.valueElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseAuditEvent(element : IXmlDomElement; path : string) : TFhirAuditEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirAuditEvent.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'event') then
        result.event := ParseAuditEventEvent(child, path+'/event') {b}
      else if (child.baseName = 'participant') then
        result.participantList.Add(ParseAuditEventParticipant(child, path+'/participant')){y.2}
      else if (child.baseName = 'source') then
        result.source := ParseAuditEventSource(child, path+'/source') {b}
      else if (child.baseName = 'object') then
        result.object_List.Add(ParseAuditEventObject(child, path+'/object')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAuditEvent(xml : TXmlBuilder; name : string; elem : TFhirAuditEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeAuditEventEvent(xml, 'event', elem.event);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeAuditEventParticipant(xml, 'participant', elem.participantList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeAuditEventSource(xml, 'source', elem.source);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.object_List.Count - 1 do
      ComposeAuditEventObject(xml, 'object', elem.object_List[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAuditEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEvent(jsn : TJsonObject) : TFhirAuditEvent;
begin
  result := TFhirAuditEvent.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('event') then
        result.event := ParseAuditEventEvent(jsn.vObj['event']);{q}
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseAuditEventParticipant);
    if jsn.has('source') then
        result.source := ParseAuditEventSource(jsn.vObj['source']);{q}
    if jsn.has('object') then
      iterateArray(jsn.vArr['object'], result.object_List, parseAuditEventObject);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAuditEvent(json : TJSONWriter; name : string; elem : TFhirAuditEvent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeAuditEventEvent(json, 'event', elem.event); {a}
  if (SummaryOption in [soFull, soData]) and (elem.participantList.Count > 0) then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeAuditEventParticipant(json, '', elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeAuditEventSource(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soData]) and (elem.object_List.Count > 0) then
  begin
    json.valueArray('object');
    for i := 0 to elem.object_List.Count - 1 do
      ComposeAuditEventObject(json, '', elem.object_List[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeAuditEvent(parent :  TRDFComplex; parentType, name : String; elem : TFhirAuditEvent; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:AuditEvent');
  end;
  composeDomainResource(this, 'AuditEvent', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeAuditEventEvent(this, 'AuditEvent', 'event', elem.eventElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeAuditEventParticipant(this, 'AuditEvent', 'participant', elem.participantList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeAuditEventSource(this, 'AuditEvent', 'source', elem.sourceElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.object_List.Count - 1 do
      ComposeAuditEventObject(this, 'AuditEvent', 'object', elem.object_List[i], i);
end;

function TFHIRXmlParser.ParseBasic(element : IXmlDomElement; path : string) : TFhirBasic;
var
  child : IXMLDOMElement;
begin
  result := TFhirBasic.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDate(child, path+'/created') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBasic(xml : TXmlBuilder; name : string; elem : TFhirBasic);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'created', elem.createdElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBasic(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBasic(jsn)); {2}
end;

function TFHIRJsonParser.ParseBasic(jsn : TJsonObject) : TFhirBasic;
begin
  result := TFhirBasic.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDate(jsn['created'], jsn.vObj['_created']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBasic(json : TJSONWriter; name : string; elem : TFhirBasic; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'created', elem.createdElement, false);
end;

procedure TFHIRRDFComposer.ComposeBasic(parent :  TRDFComplex; parentType, name : String; elem : TFhirBasic; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Basic');
  end;
  composeDomainResource(this, 'Basic', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Basic', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Basic', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'Basic', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Basic', 'author', elem.authorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'Basic', 'created', elem.createdElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseBinary(element : IXmlDomElement; path : string) : TFhirBinary;
var
  child : IXMLDOMElement;
begin
  result := TFhirBinary.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'contentType') then
        result.contentTypeElement := ParseCode(child, path+'/contentType') {b}
      else if (child.baseName = 'content') then
        result.contentElement := ParseBase64Binary(child, path+'/content') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBinary(xml : TXmlBuilder; name : string; elem : TFhirBinary);
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'contentType', elem.contentTypeElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(xml, 'content', elem.contentElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBinary(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBinary(jsn)); {2}
end;

function TFHIRJsonParser.ParseBinary(jsn : TJsonObject) : TFhirBinary;
begin
  result := TFhirBinary.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('contentType') or jsn.has('_contentType') then
        result.contentTypeElement := ParseCode(jsn['contentType'], jsn.vObj['_contentType']);{q}
    if jsn.has('content') or jsn.has('_content') then
        result.contentElement := ParseBase64Binary(jsn['content'], jsn.vObj['_content']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBinary(json : TJSONWriter; name : string; elem : TFhirBinary; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeValue(json, 'contentType', elem.contentTypeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeProps(json, 'contentType', elem.contentTypeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64BinaryValue(json, 'content', elem.contentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64BinaryProps(json, 'content', elem.contentElement, false);
end;

procedure TFHIRRDFComposer.ComposeBinary(parent :  TRDFComplex; parentType, name : String; elem : TFhirBinary; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Binary');
  end;
  composeResource(this, 'Binary', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'Binary', 'contentType', elem.contentTypeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(this, 'Binary', 'content', elem.contentElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseBodySite(element : IXmlDomElement; path : string) : TFhirBodySite;
var
  child : IXMLDOMElement;
begin
  result := TFhirBodySite.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'modifier') then
        result.modifierList.Add(ParseCodeableConcept(child, path+'/modifier')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'image') then
        result.imageList.Add(ParseAttachment(child, path+'/image')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBodySite(xml : TXmlBuilder; name : string; elem : TFhirBodySite);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', elem.modifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.imageList.Count - 1 do
      ComposeAttachment(xml, 'image', elem.imageList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBodySite(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBodySite(jsn)); {2}
end;

function TFHIRJsonParser.ParseBodySite(jsn : TJsonObject) : TFhirBodySite;
begin
  result := TFhirBodySite.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('image') then
      iterateArray(jsn.vArr['image'], result.imageList, parseAttachment);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBodySite(json : TJSONWriter; name : string; elem : TFhirBodySite; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (elem.modifierList.Count > 0) then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.modifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.imageList.Count > 0) then
  begin
    json.valueArray('image');
    for i := 0 to elem.imageList.Count - 1 do
      ComposeAttachment(json, '', elem.imageList[i]); {z - Attachment}
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeBodySite(parent :  TRDFComplex; parentType, name : String; elem : TFhirBodySite; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:BodySite');
  end;
  composeDomainResource(this, 'BodySite', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'BodySite', 'patient', elem.patientElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'BodySite', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'BodySite', 'code', elem.codeElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'BodySite', 'modifier', elem.modifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'BodySite', 'description', elem.descriptionElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.imageList.Count - 1 do
      ComposeAttachment(this, 'BodySite', 'image', elem.imageList[i], i);
end;

function TFHIRXmlParser.ParseBundleLink(element : IXmlDomElement; path : string) : TFhirBundleLink;
var
  child : IXMLDOMElement;
begin
  result := TFhirBundleLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'relation') then
        result.relationElement := ParseString(child, path+'/relation') {b}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBundleLink(xml : TXmlBuilder; name : string; elem : TFhirBundleLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'relation', elem.relationElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBundleLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleLink(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleLink(jsn : TJsonObject) : TFhirBundleLink;
begin
  result := TFhirBundleLink.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('relation') or jsn.has('_relation') then
        result.relationElement := ParseString(jsn['relation'], jsn.vObj['_relation']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBundleLink(json : TJSONWriter; name : string; elem : TFhirBundleLink; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'relation', elem.relationElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'relation', elem.relationElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeBundleLink(parent :  TRDFComplex; parentType, name : String; elem : TFhirBundleLink; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:BundleLink');
  end;
  composeBackboneElement(this, 'BundleLink', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'BundleLink', 'relation', elem.relationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'BundleLink', 'url', elem.urlElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseBundleEntry(element : IXmlDomElement; path : string) : TFhirBundleEntry;
var
  child : IXMLDOMElement;
begin
  result := TFhirBundleEntry.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'link') then
        result.link_List.Add(ParseBundleLink(child, path+'/link')){y.2}
      else if (child.baseName = 'fullUrl') then
        result.fullUrlElement := ParseUri(child, path+'/fullUrl') {b}
      else if (child.baseName = 'resource') then
        result.resource := ParseInnerResource(child, path+'/resource') {b}
      else if (child.baseName = 'search') then
        result.search := ParseBundleEntrySearch(child, path+'/search') {b}
      else if (child.baseName = 'request') then
        result.request := ParseBundleEntryRequest(child, path+'/request') {b}
      else if (child.baseName = 'response') then
        result.response := ParseBundleEntryResponse(child, path+'/response') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBundleEntry(xml : TXmlBuilder; name : string; elem : TFhirBundleEntry);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(xml, 'link', elem.link_List[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'fullUrl', elem.fullUrlElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(xml, 'resource', elem, elem.resource);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntrySearch(xml, 'search', elem.search);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryRequest(xml, 'request', elem.request);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryResponse(xml, 'response', elem.response);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBundleEntry(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleEntry(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleEntry(jsn : TJsonObject) : TFhirBundleEntry;
begin
  result := TFhirBundleEntry.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parseBundleLink);
    if jsn.has('fullUrl') or jsn.has('_fullUrl') then
        result.fullUrlElement := ParseUri(jsn['fullUrl'], jsn.vObj['_fullUrl']);{q}
    if jsn.has('resource') then
        result.resource := ParseInnerResource(jsn.vObj['resource']);{q}
    if jsn.has('search') then
        result.search := ParseBundleEntrySearch(jsn.vObj['search']);{q}
    if jsn.has('request') then
        result.request := ParseBundleEntryRequest(jsn.vObj['request']);{q}
    if jsn.has('response') then
        result.response := ParseBundleEntryResponse(jsn.vObj['response']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBundleEntry(json : TJSONWriter; name : string; elem : TFhirBundleEntry; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.link_List.Count > 0) then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(json, '', elem.link_List[i]); {z - @Bundle.link}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'fullUrl', elem.fullUrlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'fullUrl', elem.fullUrlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(json, 'resource', elem, elem.resource); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntrySearch(json, 'search', elem.search); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryRequest(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryResponse(json, 'response', elem.response); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeBundleEntry(parent :  TRDFComplex; parentType, name : String; elem : TFhirBundleEntry; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:BundleEntry');
  end;
  composeBackboneElement(this, 'BundleEntry', name, elem, index);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(this, 'BundleEntry', 'link', elem.link_List[i], i);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'BundleEntry', 'fullUrl', elem.fullUrlElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeResource(this, 'BundleEntry', 'resource', elem.resourceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntrySearch(this, 'BundleEntry', 'search', elem.searchElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryRequest(this, 'BundleEntry', 'request', elem.requestElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryResponse(this, 'BundleEntry', 'response', elem.responseElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseBundleEntrySearch(element : IXmlDomElement; path : string) : TFhirBundleEntrySearch;
var
  child : IXMLDOMElement;
begin
  result := TFhirBundleEntrySearch.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'mode') then
        result.modeElement := ParseEnum(CODES_TFhirSearchEntryModeEnum, SYSTEMS_TFhirSearchEntryModeEnum, path+'/mode', child){1a}
      else if (child.baseName = 'score') then
        result.scoreElement := ParseDecimal(child, path+'/score') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBundleEntrySearch(xml : TXmlBuilder; name : string; elem : TFhirBundleEntrySearch);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirSearchEntryModeEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(xml, 'score', elem.scoreElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBundleEntrySearch(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleEntrySearch(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleEntrySearch(jsn : TJsonObject) : TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn['mode'], jsn.vObj['_mode'], CODES_TFhirSearchEntryModeEnum, SYSTEMS_TFhirSearchEntryModeEnum);
    if jsn.has('score') or jsn.has('_score') then
        result.scoreElement := ParseDecimal(jsn['score'], jsn.vObj['_score']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBundleEntrySearch(json : TJSONWriter; name : string; elem : TFhirBundleEntrySearch; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirSearchEntryModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirSearchEntryModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalValue(json, 'score', elem.scoreElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalProps(json, 'score', elem.scoreElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeBundleEntrySearch(parent :  TRDFComplex; parentType, name : String; elem : TFhirBundleEntrySearch; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:BundleEntrySearch');
  end;
  composeBackboneElement(this, 'BundleEntrySearch', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(this, 'BundleEntrySearch', 'mode', elem.ModeElement, CODES_TFhirSearchEntryModeEnum, SYSTEMS_TFhirSearchEntryModeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'BundleEntrySearch', 'score', elem.scoreElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseBundleEntryRequest(element : IXmlDomElement; path : string) : TFhirBundleEntryRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirBundleEntryRequest.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'method') then
        result.methodElement := ParseEnum(CODES_TFhirHttpVerbEnum, SYSTEMS_TFhirHttpVerbEnum, path+'/method', child){1a}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'ifNoneMatch') then
        result.ifNoneMatchElement := ParseString(child, path+'/ifNoneMatch') {b}
      else if (child.baseName = 'ifModifiedSince') then
        result.ifModifiedSinceElement := ParseInstant(child, path+'/ifModifiedSince') {b}
      else if (child.baseName = 'ifMatch') then
        result.ifMatchElement := ParseString(child, path+'/ifMatch') {b}
      else if (child.baseName = 'ifNoneExist') then
        result.ifNoneExistElement := ParseString(child, path+'/ifNoneExist') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryRequest(xml : TXmlBuilder; name : string; elem : TFhirBundleEntryRequest);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(xml, 'method', elem.MethodElement, CODES_TFhirHttpVerbEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'ifNoneMatch', elem.ifNoneMatchElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(xml, 'ifModifiedSince', elem.ifModifiedSinceElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'ifMatch', elem.ifMatchElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'ifNoneExist', elem.ifNoneExistElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBundleEntryRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleEntryRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleEntryRequest(jsn : TJsonObject) : TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('method') or jsn.has('_method')  then
      result.methodElement := parseEnum(jsn.path+'/method', jsn['method'], jsn.vObj['_method'], CODES_TFhirHttpVerbEnum, SYSTEMS_TFhirHttpVerbEnum);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('ifNoneMatch') or jsn.has('_ifNoneMatch') then
        result.ifNoneMatchElement := ParseString(jsn['ifNoneMatch'], jsn.vObj['_ifNoneMatch']);{q}
    if jsn.has('ifModifiedSince') or jsn.has('_ifModifiedSince') then
        result.ifModifiedSinceElement := ParseInstant(jsn['ifModifiedSince'], jsn.vObj['_ifModifiedSince']);{q}
    if jsn.has('ifMatch') or jsn.has('_ifMatch') then
        result.ifMatchElement := ParseString(jsn['ifMatch'], jsn.vObj['_ifMatch']);{q}
    if jsn.has('ifNoneExist') or jsn.has('_ifNoneExist') then
        result.ifNoneExistElement := ParseString(jsn['ifNoneExist'], jsn.vObj['_ifNoneExist']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBundleEntryRequest(json : TJSONWriter; name : string; elem : TFhirBundleEntryRequest; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumValue(json, 'method', elem.MethodElement, CODES_TFhirHttpVerbEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumProps(json, 'method', elem.MethodElement, CODES_TFhirHttpVerbEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'ifNoneMatch', elem.ifNoneMatchElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'ifNoneMatch', elem.ifNoneMatchElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantValue(json, 'ifModifiedSince', elem.ifModifiedSinceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantProps(json, 'ifModifiedSince', elem.ifModifiedSinceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'ifMatch', elem.ifMatchElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'ifMatch', elem.ifMatchElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'ifNoneExist', elem.ifNoneExistElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'ifNoneExist', elem.ifNoneExistElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeBundleEntryRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirBundleEntryRequest; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:BundleEntryRequest');
  end;
  composeBackboneElement(this, 'BundleEntryRequest', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(this, 'BundleEntryRequest', 'method', elem.MethodElement, CODES_TFhirHttpVerbEnum, SYSTEMS_TFhirHttpVerbEnum, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'BundleEntryRequest', 'url', elem.urlElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'BundleEntryRequest', 'ifNoneMatch', elem.ifNoneMatchElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(this, 'BundleEntryRequest', 'ifModifiedSince', elem.ifModifiedSinceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'BundleEntryRequest', 'ifMatch', elem.ifMatchElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'BundleEntryRequest', 'ifNoneExist', elem.ifNoneExistElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseBundleEntryResponse(element : IXmlDomElement; path : string) : TFhirBundleEntryResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirBundleEntryResponse.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.statusElement := ParseString(child, path+'/status') {b}
      else if (child.baseName = 'location') then
        result.locationElement := ParseUri(child, path+'/location') {b}
      else if (child.baseName = 'etag') then
        result.etagElement := ParseString(child, path+'/etag') {b}
      else if (child.baseName = 'lastModified') then
        result.lastModifiedElement := ParseInstant(child, path+'/lastModified') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryResponse(xml : TXmlBuilder; name : string; elem : TFhirBundleEntryResponse);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'status', elem.statusElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'location', elem.locationElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'etag', elem.etagElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(xml, 'lastModified', elem.lastModifiedElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBundleEntryResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleEntryResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleEntryResponse(jsn : TJsonObject) : TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status') then
        result.statusElement := ParseString(jsn['status'], jsn.vObj['_status']);{q}
    if jsn.has('location') or jsn.has('_location') then
        result.locationElement := ParseUri(jsn['location'], jsn.vObj['_location']);{q}
    if jsn.has('etag') or jsn.has('_etag') then
        result.etagElement := ParseString(jsn['etag'], jsn.vObj['_etag']);{q}
    if jsn.has('lastModified') or jsn.has('_lastModified') then
        result.lastModifiedElement := ParseInstant(jsn['lastModified'], jsn.vObj['_lastModified']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBundleEntryResponse(json : TJSONWriter; name : string; elem : TFhirBundleEntryResponse; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'status', elem.statusElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'status', elem.statusElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'location', elem.locationElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'location', elem.locationElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'etag', elem.etagElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'etag', elem.etagElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantValue(json, 'lastModified', elem.lastModifiedElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantProps(json, 'lastModified', elem.lastModifiedElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeBundleEntryResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirBundleEntryResponse; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:BundleEntryResponse');
  end;
  composeBackboneElement(this, 'BundleEntryResponse', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'BundleEntryResponse', 'status', elem.statusElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'BundleEntryResponse', 'location', elem.locationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'BundleEntryResponse', 'etag', elem.etagElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(this, 'BundleEntryResponse', 'lastModified', elem.lastModifiedElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseBundle(element : IXmlDomElement; path : string) : TFhirBundle;
var
  child : IXMLDOMElement;
begin
  result := TFhirBundle.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirBundleTypeEnum, SYSTEMS_TFhirBundleTypeEnum, path+'/type', child){1a}
      else if (child.baseName = 'total') then
        result.totalElement := ParseUnsignedInt(child, path+'/total') {b}
      else if (child.baseName = 'link') then
        result.link_List.Add(ParseBundleLink(child, path+'/link')){y.2}
      else if (child.baseName = 'entry') then
        result.entryList.Add(ParseBundleEntry(child, path+'/entry')){y.2}
      else if (child.baseName = 'signature') then
        result.signature := ParseSignature(child, path+'/signature') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBundle(xml : TXmlBuilder; name : string; elem : TFhirBundle);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirBundleTypeEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedInt(xml, 'total', elem.totalElement);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(xml, 'link', elem.link_List[i]);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeBundleEntry(xml, 'entry', elem.entryList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeSignature(xml, 'signature', elem.signature);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseBundle(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundle(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundle(jsn : TJsonObject) : TFhirBundle;
begin
  result := TFhirBundle.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirBundleTypeEnum, SYSTEMS_TFhirBundleTypeEnum);
    if jsn.has('total') or jsn.has('_total') then
        result.totalElement := ParseUnsignedInt(jsn['total'], jsn.vObj['_total']);{q}
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parseBundleLink);
    if jsn.has('entry') then
      iterateArray(jsn.vArr['entry'], result.entryList, parseBundleEntry);
    if jsn.has('signature') then
        result.signature := ParseSignature(jsn.vObj['signature']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBundle(json : TJSONWriter; name : string; elem : TFhirBundle; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirBundleTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirBundleTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedIntValue(json, 'total', elem.totalElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedIntProps(json, 'total', elem.totalElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.link_List.Count > 0) then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(json, '', elem.link_List[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.entryList.Count > 0) then
  begin
    json.valueArray('entry');
    for i := 0 to elem.entryList.Count - 1 do
      ComposeBundleEntry(json, '', elem.entryList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeSignature(json, 'signature', elem.signature); {a}
end;

procedure TFHIRRDFComposer.ComposeBundle(parent :  TRDFComplex; parentType, name : String; elem : TFhirBundle; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Bundle');
  end;
  composeResource(this, 'Bundle', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
     ComposeEnum(this, 'Bundle', 'type', elem.Type_Element, CODES_TFhirBundleTypeEnum, SYSTEMS_TFhirBundleTypeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedInt(this, 'Bundle', 'total', elem.totalElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(this, 'Bundle', 'link', elem.link_List[i], i);
  if SummaryOption in [soFull, soSummary, soText, soData] then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeBundleEntry(this, 'Bundle', 'entry', elem.entryList[i], i);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeSignature(this, 'Bundle', 'signature', elem.signatureElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseCarePlanRelatedPlan(element : IXmlDomElement; path : string) : TFhirCarePlanRelatedPlan;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlanRelatedPlan.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeElement := ParseEnum(CODES_TFhirCarePlanRelationshipEnum, SYSTEMS_TFhirCarePlanRelationshipEnum, path+'/code', child){1a}
      else if (child.baseName = 'plan') then
        result.plan := ParseReference{TFhirCarePlan}(child, path+'/plan') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlanRelatedPlan(xml : TXmlBuilder; name : string; elem : TFhirCarePlanRelatedPlan);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirCarePlanRelationshipEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirCarePlan}(xml, 'plan', elem.plan);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlanRelatedPlan(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanRelatedPlan(jsn)); {2}
end;

function TFHIRJsonParser.ParseCarePlanRelatedPlan(jsn : TJsonObject) : TFhirCarePlanRelatedPlan;
begin
  result := TFhirCarePlanRelatedPlan.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn['code'], jsn.vObj['_code'], CODES_TFhirCarePlanRelationshipEnum, SYSTEMS_TFhirCarePlanRelationshipEnum);
    if jsn.has('plan') then
        result.plan := ParseReference{TFhirCarePlan}(jsn.vObj['plan']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlanRelatedPlan(json : TJSONWriter; name : string; elem : TFhirCarePlanRelatedPlan; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirCarePlanRelationshipEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirCarePlanRelationshipEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirCarePlan}(json, 'plan', elem.plan); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeCarePlanRelatedPlan(parent :  TRDFComplex; parentType, name : String; elem : TFhirCarePlanRelatedPlan; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:CarePlanRelatedPlan');
  end;
  composeBackboneElement(this, 'CarePlanRelatedPlan', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'CarePlanRelatedPlan', 'code', elem.CodeElement, CODES_TFhirCarePlanRelationshipEnum, SYSTEMS_TFhirCarePlanRelationshipEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirCarePlan}(this, 'CarePlanRelatedPlan', 'plan', elem.planElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseCarePlanParticipant(element : IXmlDomElement; path : string) : TFhirCarePlanParticipant;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlanParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'role') then
        result.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.baseName = 'member') then
        result.member := ParseReference{Resource}(child, path+'/member') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlanParticipant(xml : TXmlBuilder; name : string; elem : TFhirCarePlanParticipant);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', elem.role);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'member', elem.member);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlanParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseCarePlanParticipant(jsn : TJsonObject) : TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q}
    if jsn.has('member') then
        result.member := ParseReference{Resource}(jsn.vObj['member']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlanParticipant(json : TJSONWriter; name : string; elem : TFhirCarePlanParticipant; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'role', elem.role); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(json, 'member', elem.member); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeCarePlanParticipant(parent :  TRDFComplex; parentType, name : String; elem : TFhirCarePlanParticipant; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:CarePlanParticipant');
  end;
  composeBackboneElement(this, 'CarePlanParticipant', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CarePlanParticipant', 'role', elem.roleElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'CarePlanParticipant', 'member', elem.memberElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseCarePlanActivity(element : IXmlDomElement; path : string) : TFhirCarePlanActivity;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlanActivity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'actionResulting') then
        result.actionResultingList.Add(ParseReference{TFhirReference}(child, path+'/actionResulting')){y.2}
      else if (child.baseName = 'progress') then
        result.progressList.Add(ParseAnnotation(child, path+'/progress')){y.2}
      else if (child.baseName = 'reference') then
        result.reference := ParseReference{Resource}(child, path+'/reference') {b}
      else if (child.baseName = 'detail') then
        result.detail := ParseCarePlanActivityDetail(child, path+'/detail') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivity(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivity);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionResultingList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'actionResulting', elem.actionResultingList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.progressList.Count - 1 do
      ComposeAnnotation(xml, 'progress', elem.progressList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'reference', elem.reference);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCarePlanActivityDetail(xml, 'detail', elem.detail);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlanActivity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanActivity(jsn)); {2}
end;

function TFHIRJsonParser.ParseCarePlanActivity(jsn : TJsonObject) : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('actionResulting') then
      iterateArray(jsn.vArr['actionResulting'], result.actionResultingList, parseReference{TFhirReference});
    if jsn.has('progress') then
      iterateArray(jsn.vArr['progress'], result.progressList, parseAnnotation);
    if jsn.has('reference') then
        result.reference := ParseReference{Resource}(jsn.vObj['reference']);{q}
    if jsn.has('detail') then
        result.detail := ParseCarePlanActivityDetail(jsn.vObj['detail']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlanActivity(json : TJSONWriter; name : string; elem : TFhirCarePlanActivity; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.actionResultingList.Count > 0) then
  begin
    json.valueArray('actionResulting');
    for i := 0 to elem.actionResultingList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.actionResultingList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.progressList.Count > 0) then
  begin
    json.valueArray('progress');
    for i := 0 to elem.progressList.Count - 1 do
      ComposeAnnotation(json, '', elem.progressList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(json, 'reference', elem.reference); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCarePlanActivityDetail(json, 'detail', elem.detail); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeCarePlanActivity(parent :  TRDFComplex; parentType, name : String; elem : TFhirCarePlanActivity; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:CarePlanActivity');
  end;
  composeBackboneElement(this, 'CarePlanActivity', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionResultingList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'CarePlanActivity', 'actionResulting', elem.actionResultingList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.progressList.Count - 1 do
      ComposeAnnotation(this, 'CarePlanActivity', 'progress', elem.progressList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'CarePlanActivity', 'reference', elem.referenceElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCarePlanActivityDetail(this, 'CarePlanActivity', 'detail', elem.detailElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseCarePlanActivityDetail(element : IXmlDomElement; path : string) : TFhirCarePlanActivityDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlanActivityDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'reasonCode') then
        result.reasonCodeList.Add(ParseCodeableConcept(child, path+'/reasonCode')){y.2}
      else if (child.baseName = 'reasonReference') then
        result.reasonReferenceList.Add(ParseReference{TFhirCondition}(child, path+'/reasonReference')){y.2}
      else if (child.baseName = 'goal') then
        result.goalList.Add(ParseReference{TFhirGoal}(child, path+'/goal')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirCarePlanActivityStatusEnum, SYSTEMS_TFhirCarePlanActivityStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'statusReason') then
        result.statusReason := ParseCodeableConcept(child, path+'/statusReason') {b}
      else if (child.baseName = 'prohibited') then
        result.prohibitedElement := ParseBoolean(child, path+'/prohibited') {b}
      else if (child.baseName = 'scheduledTiming') then
        result.scheduled := ParseTiming(child, path+'/scheduledTiming'){x.3}
      else if (child.baseName = 'scheduledPeriod') then
        result.scheduled := ParsePeriod(child, path+'/scheduledPeriod'){x.3}
      else if (child.baseName = 'scheduledString') then
        result.scheduled := ParseString(child, path+'/scheduledString'){x.3}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'performer') then
        result.performerList.Add(ParseReference{Resource}(child, path+'/performer')){y.2}
      else if (child.baseName = 'productCodeableConcept') then
        result.product := ParseCodeableConcept(child, path+'/productCodeableConcept'){x.3}
      else if (child.baseName = 'productReference') then
        result.product := ParseReference(child, path+'/productReference') {a}
      else if (child.baseName = 'dailyAmount') then
        result.dailyAmount := ParseQuantity(child, path+'/dailyAmount') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivityDetail(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivityDetail);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonCode', elem.reasonCodeList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(xml, 'reasonReference', elem.reasonReferenceList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(xml, 'goal', elem.goalList[i]);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCarePlanActivityStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'statusReason', elem.statusReason);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'prohibited', elem.prohibitedElement);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirTiming) {6} then
    ComposeTiming(xml, 'scheduledTiming', TFhirTiming(elem.scheduled))
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(xml, 'scheduledPeriod', TFhirPeriod(elem.scheduled))
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirString) {6} then
    ComposeString(xml, 'scheduledString', TFhirString(elem.scheduled));
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(xml, 'performer', elem.performerList[i]);
  if (SummaryOption in [soFull, soData]) and (elem.product is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'productCodeableConcept', TFhirCodeableConcept(elem.product))
  else if (SummaryOption in [soFull, soData]) and (elem.product is TFhirReference) {2} then
    ComposeReference(xml, 'productReference', TFhirReference(elem.product));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'dailyAmount', elem.dailyAmount);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlanActivityDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanActivityDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseCarePlanActivityDetail(jsn : TJsonObject) : TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('goal') then
      iterateArray(jsn.vArr['goal'], result.goalList, parseReference{TFhirGoal});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirCarePlanActivityStatusEnum, SYSTEMS_TFhirCarePlanActivityStatusEnum);
    if jsn.has('statusReason') then
        result.statusReason := ParseCodeableConcept(jsn.vObj['statusReason']);{q}
    if jsn.has('prohibited') or jsn.has('_prohibited') then
        result.prohibitedElement := ParseBoolean(jsn['prohibited'], jsn.vObj['_prohibited']);{q}
    if jsn.has('scheduledTiming') {a4} then
      result.scheduled := ParseTiming(jsn.vObj['scheduledTiming']);
    if jsn.has('scheduledPeriod') {a4} then
      result.scheduled := ParsePeriod(jsn.vObj['scheduledPeriod']);
    if jsn.has('scheduledString') or jsn.has('_scheduledString') then
      result.scheduled := parseString(jsn['scheduledString'], jsn.vObj['_scheduledString']);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseReference{Resource});
    if jsn.has('productCodeableConcept') {a4} then
      result.product := ParseCodeableConcept(jsn.vObj['productCodeableConcept']);
    if jsn.has('productReference') {a3} then
      result.product := ParseReference(jsn.vObj['productReference']);
    if jsn.has('dailyAmount') then
        result.dailyAmount := ParseQuantity(jsn.vObj['dailyAmount']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlanActivityDetail(json : TJSONWriter; name : string; elem : TFhirCarePlanActivityDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.goalList.Count > 0) then
  begin
    json.valueArray('goal');
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(json, '', elem.goalList[i]); {z - Reference(Goal)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCarePlanActivityStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCarePlanActivityStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'statusReason', elem.statusReason); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'prohibited', elem.prohibitedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'prohibited', elem.prohibitedElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirTiming) then 
    ComposeTiming(json, 'scheduledTiming', TFhirTiming(elem.scheduled)) 
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirPeriod) then 
    ComposePeriod(json, 'scheduledPeriod', TFhirPeriod(elem.scheduled)) 
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirString) then 
  begin
    ComposeStringValue(json, 'scheduledString', TFhirString(elem.scheduled), false);
    ComposeStringProps(json, 'scheduledString', TFhirString(elem.scheduled), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) and (elem.performerList.Count > 0) then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.performerList[i]); {z - Reference(Practitioner|Organization|RelatedPerson|Patient)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.product is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'productCodeableConcept', TFhirCodeableConcept(elem.product)) 
  else if (SummaryOption in [soFull, soData]) and (elem.product is TFhirReference) then
    ComposeReference(json, 'productReference', TFhirReference(elem.product));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'dailyAmount', elem.dailyAmount); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeCarePlanActivityDetail(parent :  TRDFComplex; parentType, name : String; elem : TFhirCarePlanActivityDetail; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:CarePlanActivityDetail');
  end;
  composeBackboneElement(this, 'CarePlanActivityDetail', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CarePlanActivityDetail', 'category', elem.categoryElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CarePlanActivityDetail', 'code', elem.codeElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'CarePlanActivityDetail', 'reasonCode', elem.reasonCodeList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'CarePlanActivityDetail', 'reasonReference', elem.reasonReferenceList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(this, 'CarePlanActivityDetail', 'goal', elem.goalList[i], i);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'CarePlanActivityDetail', 'status', elem.StatusElement, CODES_TFhirCarePlanActivityStatusEnum, SYSTEMS_TFhirCarePlanActivityStatusEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CarePlanActivityDetail', 'statusReason', elem.statusReasonElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CarePlanActivityDetail', 'prohibited', elem.prohibitedElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirTiming) {6} then
    ComposeTiming(this, 'CarePlanActivityDetail', 'scheduledTiming', TFhirTiming(elem.scheduled), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(this, 'CarePlanActivityDetail', 'scheduledPeriod', TFhirPeriod(elem.scheduled), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirString) {6} then
    ComposeString(this, 'CarePlanActivityDetail', 'scheduledString', TFhirString(elem.scheduled), -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'CarePlanActivityDetail', 'location', elem.locationElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(this, 'CarePlanActivityDetail', 'performer', elem.performerList[i], i);
  if (SummaryOption in [soFull, soData]) and (elem.product is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'CarePlanActivityDetail', 'productCodeableConcept', TFhirCodeableConcept(elem.product), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.product is TFhirReference) {2} then
    ComposeReference(this, 'CarePlanActivityDetail', 'productReference', TFhirReference(elem.product), -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'CarePlanActivityDetail', 'dailyAmount', elem.dailyAmountElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'CarePlanActivityDetail', 'quantity', elem.quantityElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CarePlanActivityDetail', 'description', elem.descriptionElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseCarePlan(element : IXmlDomElement; path : string) : TFhirCarePlan;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlan.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirCarePlanStatusEnum, SYSTEMS_TFhirCarePlanStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'context') then
        result.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'author') then
        result.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.baseName = 'modified') then
        result.modifiedElement := ParseDateTime(child, path+'/modified') {b}
      else if (child.baseName = 'category') then
        result.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'addresses') then
        result.addressesList.Add(ParseReference{TFhirCondition}(child, path+'/addresses')){y.2}
      else if (child.baseName = 'support') then
        result.supportList.Add(ParseReference{TFhirReference}(child, path+'/support')){y.2}
      else if (child.baseName = 'relatedPlan') then
        result.relatedPlanList.Add(ParseCarePlanRelatedPlan(child, path+'/relatedPlan')){y.2}
      else if (child.baseName = 'participant') then
        result.participantList.Add(ParseCarePlanParticipant(child, path+'/participant')){y.2}
      else if (child.baseName = 'goal') then
        result.goalList.Add(ParseReference{TFhirGoal}(child, path+'/goal')){y.2}
      else if (child.baseName = 'activity') then
        result.activityList.Add(ParseCarePlanActivity(child, path+'/activity')){y.2}
      else if (child.baseName = 'note') then
        result.note := ParseAnnotation(child, path+'/note') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlan(xml : TXmlBuilder; name : string; elem : TFhirCarePlan);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCarePlanStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'modified', elem.modifiedElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{TFhirCondition}(xml, 'addresses', elem.addressesList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.supportList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'support', elem.supportList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.relatedPlanList.Count - 1 do
      ComposeCarePlanRelatedPlan(xml, 'relatedPlan', elem.relatedPlanList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeCarePlanParticipant(xml, 'participant', elem.participantList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(xml, 'goal', elem.goalList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.activityList.Count - 1 do
      ComposeCarePlanActivity(xml, 'activity', elem.activityList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(xml, 'note', elem.note);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlan(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlan(jsn)); {2}
end;

function TFHIRJsonParser.ParseCarePlan(jsn : TJsonObject) : TFhirCarePlan;
begin
  result := TFhirCarePlan.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirCarePlanStatusEnum, SYSTEMS_TFhirCarePlanStatusEnum);
    if jsn.has('context') then
        result.context := ParseReference{Resource}(jsn.vObj['context']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{Resource});
    if jsn.has('modified') or jsn.has('_modified') then
        result.modifiedElement := ParseDateTime(jsn['modified'], jsn.vObj['_modified']);{q}
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('addresses') then
      iterateArray(jsn.vArr['addresses'], result.addressesList, parseReference{TFhirCondition});
    if jsn.has('support') then
      iterateArray(jsn.vArr['support'], result.supportList, parseReference{TFhirReference});
    if jsn.has('relatedPlan') then
      iterateArray(jsn.vArr['relatedPlan'], result.relatedPlanList, parseCarePlanRelatedPlan);
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseCarePlanParticipant);
    if jsn.has('goal') then
      iterateArray(jsn.vArr['goal'], result.goalList, parseReference{TFhirGoal});
    if jsn.has('activity') then
      iterateArray(jsn.vArr['activity'], result.activityList, parseCarePlanActivity);
    if jsn.has('note') then
        result.note := ParseAnnotation(jsn.vObj['note']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlan(json : TJSONWriter; name : string; elem : TFhirCarePlan; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCarePlanStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCarePlanStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'context', elem.context); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.authorList[i]); {z - Reference(Patient|Practitioner|RelatedPerson|Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'modified', elem.modifiedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'modified', elem.modifiedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.addressesList.Count > 0) then
  begin
    json.valueArray('addresses');
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.addressesList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.supportList.Count > 0) then
  begin
    json.valueArray('support');
    for i := 0 to elem.supportList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.supportList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.relatedPlanList.Count > 0) then
  begin
    json.valueArray('relatedPlan');
    for i := 0 to elem.relatedPlanList.Count - 1 do
      ComposeCarePlanRelatedPlan(json, '', elem.relatedPlanList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.participantList.Count > 0) then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeCarePlanParticipant(json, '', elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.goalList.Count > 0) then
  begin
    json.valueArray('goal');
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(json, '', elem.goalList[i]); {z - Reference(Goal)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.activityList.Count > 0) then
  begin
    json.valueArray('activity');
    for i := 0 to elem.activityList.Count - 1 do
      ComposeCarePlanActivity(json, '', elem.activityList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(json, 'note', elem.note); {a}
end;

procedure TFHIRRDFComposer.ComposeCarePlan(parent :  TRDFComplex; parentType, name : String; elem : TFhirCarePlan; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:CarePlan');
  end;
  composeDomainResource(this, 'CarePlan', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CarePlan', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'CarePlan', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'CarePlan', 'status', elem.StatusElement, CODES_TFhirCarePlanStatusEnum, SYSTEMS_TFhirCarePlanStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'CarePlan', 'context', elem.contextElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'CarePlan', 'period', elem.periodElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(this, 'CarePlan', 'author', elem.authorList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'CarePlan', 'modified', elem.modifiedElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'CarePlan', 'category', elem.categoryList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CarePlan', 'description', elem.descriptionElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'CarePlan', 'addresses', elem.addressesList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.supportList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'CarePlan', 'support', elem.supportList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.relatedPlanList.Count - 1 do
      ComposeCarePlanRelatedPlan(this, 'CarePlan', 'relatedPlan', elem.relatedPlanList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeCarePlanParticipant(this, 'CarePlan', 'participant', elem.participantList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(this, 'CarePlan', 'goal', elem.goalList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.activityList.Count - 1 do
      ComposeCarePlanActivity(this, 'CarePlan', 'activity', elem.activityList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(this, 'CarePlan', 'note', elem.noteElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClaimPayee(element : IXmlDomElement; path : string) : TFhirClaimPayee;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimPayee.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'provider') then
        result.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'person') then
        result.person := ParseReference{TFhirPatient}(child, path+'/person') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimPayee(xml : TXmlBuilder; name : string; elem : TFhirClaimPayee);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'person', elem.person);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimPayee(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimPayee(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimPayee(jsn : TJsonObject) : TFhirClaimPayee;
begin
  result := TFhirClaimPayee.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('person') then
        result.person := ParseReference{TFhirPatient}(jsn.vObj['person']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimPayee(json : TJSONWriter; name : string; elem : TFhirClaimPayee; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'person', elem.person); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimPayee(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimPayee; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimPayee');
  end;
  composeBackboneElement(this, 'ClaimPayee', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimPayee', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'ClaimPayee', 'provider', elem.providerElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'ClaimPayee', 'organization', elem.organizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'ClaimPayee', 'person', elem.personElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClaimDiagnosis(element : IXmlDomElement; path : string) : TFhirClaimDiagnosis;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimDiagnosis.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequence') then
        result.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.baseName = 'diagnosis') then
        result.diagnosis := ParseCoding(child, path+'/diagnosis') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimDiagnosis(xml : TXmlBuilder; name : string; elem : TFhirClaimDiagnosis);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'diagnosis', elem.diagnosis);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimDiagnosis(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimDiagnosis(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimDiagnosis(jsn : TJsonObject) : TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('diagnosis') then
        result.diagnosis := ParseCoding(jsn.vObj['diagnosis']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimDiagnosis(json : TJSONWriter; name : string; elem : TFhirClaimDiagnosis; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'diagnosis', elem.diagnosis); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimDiagnosis(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimDiagnosis; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimDiagnosis');
  end;
  composeBackboneElement(this, 'ClaimDiagnosis', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ClaimDiagnosis', 'sequence', elem.sequenceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimDiagnosis', 'diagnosis', elem.diagnosisElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClaimCoverage(element : IXmlDomElement; path : string) : TFhirClaimCoverage;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimCoverage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequence') then
        result.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.baseName = 'focal') then
        result.focalElement := ParseBoolean(child, path+'/focal') {b}
      else if (child.baseName = 'coverage') then
        result.coverage := ParseReference{TFhirCoverage}(child, path+'/coverage') {b}
      else if (child.baseName = 'businessArrangement') then
        result.businessArrangementElement := ParseString(child, path+'/businessArrangement') {b}
      else if (child.baseName = 'relationship') then
        result.relationship := ParseCoding(child, path+'/relationship') {b}
      else if (child.baseName = 'preAuthRef') then
        result.preAuthRefList.Add(ParseString(child, path+'/preAuthRef')){y.2}
      else if (child.baseName = 'claimResponse') then
        result.claimResponse := ParseReference{TFhirClaimResponse}(child, path+'/claimResponse') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimCoverage(xml : TXmlBuilder; name : string; elem : TFhirClaimCoverage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'focal', elem.focalElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirCoverage}(xml, 'coverage', elem.coverage);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'businessArrangement', elem.businessArrangementElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'relationship', elem.relationship);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.preAuthRefList.Count - 1 do
      ComposeString(xml, 'preAuthRef', elem.preAuthRefList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaimResponse}(xml, 'claimResponse', elem.claimResponse);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimCoverage(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimCoverage(jsn : TJsonObject) : TFhirClaimCoverage;
begin
  result := TFhirClaimCoverage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('focal') or jsn.has('_focal') then
        result.focalElement := ParseBoolean(jsn['focal'], jsn.vObj['_focal']);{q}
    if jsn.has('coverage') then
        result.coverage := ParseReference{TFhirCoverage}(jsn.vObj['coverage']);{q}
    if jsn.has('businessArrangement') or jsn.has('_businessArrangement') then
        result.businessArrangementElement := ParseString(jsn['businessArrangement'], jsn.vObj['_businessArrangement']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCoding(jsn.vObj['relationship']);{q}
      if jsn.has('preAuthRef') or jsn.has('_preAuthRef') then
      iteratePrimitiveArray(jsn.vArr['preAuthRef'], jsn.vArr['_preAuthRef'], result.preAuthRefList, parseString);
    if jsn.has('claimResponse') then
        result.claimResponse := ParseReference{TFhirClaimResponse}(jsn.vObj['claimResponse']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimCoverage(json : TJSONWriter; name : string; elem : TFhirClaimCoverage; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'focal', elem.focalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'focal', elem.focalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirCoverage}(json, 'coverage', elem.coverage); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'businessArrangement', elem.businessArrangementElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'businessArrangement', elem.businessArrangementElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'relationship', elem.relationship); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.preAuthRefList.Count > 0) then
  begin
    json.valueArray('preAuthRef');
    ext := false;
    for i := 0 to elem.preAuthRefList.Count - 1 do
    begin
      ext := ext or ((elem.preAuthRefList[i].id <> '') or (elem.preAuthRefList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.preAuthRefList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_preAuthRef');
      for i := 0 to elem.preAuthRefList.Count - 1 do
        ComposeStringProps(json, '',elem.preAuthRefList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaimResponse}(json, 'claimResponse', elem.claimResponse); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimCoverage(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimCoverage; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimCoverage');
  end;
  composeBackboneElement(this, 'ClaimCoverage', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ClaimCoverage', 'sequence', elem.sequenceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ClaimCoverage', 'focal', elem.focalElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirCoverage}(this, 'ClaimCoverage', 'coverage', elem.coverageElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ClaimCoverage', 'businessArrangement', elem.businessArrangementElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimCoverage', 'relationship', elem.relationshipElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.preAuthRefList.Count - 1 do
      ComposeString(this, 'ClaimCoverage', 'preAuthRef', elem.preAuthRefList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaimResponse}(this, 'ClaimCoverage', 'claimResponse', elem.claimResponseElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimCoverage', 'originalRuleset', elem.originalRulesetElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClaimItem(element : IXmlDomElement; path : string) : TFhirClaimItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequence') then
        result.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'provider') then
        result.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.baseName = 'diagnosisLinkId') then
        result.diagnosisLinkIdList.Add(ParsePositiveInt(child, path+'/diagnosisLinkId')){y.2}
      else if (child.baseName = 'service') then
        result.service := ParseCoding(child, path+'/service') {b}
      else if (child.baseName = 'serviceDate') then
        result.serviceDateElement := ParseDate(child, path+'/serviceDate') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'unitPrice') then
        result.unitPrice := ParseQuantity(child, path+'/unitPrice') {b}
      else if (child.baseName = 'factor') then
        result.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.baseName = 'points') then
        result.pointsElement := ParseDecimal(child, path+'/points') {b}
      else if (child.baseName = 'net') then
        result.net := ParseQuantity(child, path+'/net') {b}
      else if (child.baseName = 'udi') then
        result.udi := ParseCoding(child, path+'/udi') {b}
      else if (child.baseName = 'bodySite') then
        result.bodySite := ParseCoding(child, path+'/bodySite') {b}
      else if (child.baseName = 'subSite') then
        result.subSiteList.Add(ParseCoding(child, path+'/subSite')){y.2}
      else if (child.baseName = 'modifier') then
        result.modifierList.Add(ParseCoding(child, path+'/modifier')){y.2}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseClaimItemDetail(child, path+'/detail')){y.2}
      else if (child.baseName = 'prosthesis') then
        result.prosthesis := ParseClaimItemProsthesis(child, path+'/prosthesis') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimItem(xml : TXmlBuilder; name : string; elem : TFhirClaimItem);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.diagnosisLinkIdList.Count - 1 do
      ComposePositiveInt(xml, 'diagnosisLinkId', elem.diagnosisLinkIdList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'service', elem.service);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'serviceDate', elem.serviceDateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'unitPrice', elem.unitPrice);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'points', elem.pointsElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'net', elem.net);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'udi', elem.udi);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'bodySite', elem.bodySite);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCoding(xml, 'subSite', elem.subSiteList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCoding(xml, 'modifier', elem.modifierList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimItemDetail(xml, 'detail', elem.detailList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClaimItemProsthesis(xml, 'prosthesis', elem.prosthesis);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimItem(jsn : TJsonObject) : TFhirClaimItem;
begin
  result := TFhirClaimItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q}
      if jsn.has('diagnosisLinkId') or jsn.has('_diagnosisLinkId') then
      iteratePrimitiveArray(jsn.vArr['diagnosisLinkId'], jsn.vArr['_diagnosisLinkId'], result.diagnosisLinkIdList, parsePositiveInt);
    if jsn.has('service') then
        result.service := ParseCoding(jsn.vObj['service']);{q}
    if jsn.has('serviceDate') or jsn.has('_serviceDate') then
        result.serviceDateElement := ParseDate(jsn['serviceDate'], jsn.vObj['_serviceDate']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseQuantity(jsn.vObj['unitPrice']);{q}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('points') or jsn.has('_points') then
        result.pointsElement := ParseDecimal(jsn['points'], jsn.vObj['_points']);{q}
    if jsn.has('net') then
        result.net := ParseQuantity(jsn.vObj['net']);{q}
    if jsn.has('udi') then
        result.udi := ParseCoding(jsn.vObj['udi']);{q}
    if jsn.has('bodySite') then
        result.bodySite := ParseCoding(jsn.vObj['bodySite']);{q}
    if jsn.has('subSite') then
      iterateArray(jsn.vArr['subSite'], result.subSiteList, parseCoding);
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCoding);
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseClaimItemDetail);
    if jsn.has('prosthesis') then
        result.prosthesis := ParseClaimItemProsthesis(jsn.vObj['prosthesis']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimItem(json : TJSONWriter; name : string; elem : TFhirClaimItem; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.diagnosisLinkIdList.Count > 0) then
  begin
    json.valueArray('diagnosisLinkId');
    ext := false;
    for i := 0 to elem.diagnosisLinkIdList.Count - 1 do
    begin
      ext := ext or ((elem.diagnosisLinkIdList[i].id <> '') or (elem.diagnosisLinkIdList[i].hasExtensionList));
      ComposePositiveIntValue(json, '',elem.diagnosisLinkIdList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_diagnosisLinkId');
      for i := 0 to elem.diagnosisLinkIdList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.diagnosisLinkIdList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'service', elem.service); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'serviceDate', elem.serviceDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'serviceDate', elem.serviceDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'udi', elem.udi); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'bodySite', elem.bodySite); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.subSiteList.Count > 0) then
  begin
    json.valueArray('subSite');
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCoding(json, '', elem.subSiteList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.modifierList.Count > 0) then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCoding(json, '', elem.modifierList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimItemDetail(json, '', elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClaimItemProsthesis(json, 'prosthesis', elem.prosthesis); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimItem(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimItem; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimItem');
  end;
  composeBackboneElement(this, 'ClaimItem', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ClaimItem', 'sequence', elem.sequenceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimItem', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'ClaimItem', 'provider', elem.providerElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.diagnosisLinkIdList.Count - 1 do
      ComposePositiveInt(this, 'ClaimItem', 'diagnosisLinkId', elem.diagnosisLinkIdList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimItem', 'service', elem.serviceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'ClaimItem', 'serviceDate', elem.serviceDateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimItem', 'quantity', elem.quantityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimItem', 'unitPrice', elem.unitPriceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'ClaimItem', 'factor', elem.factorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'ClaimItem', 'points', elem.pointsElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimItem', 'net', elem.netElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimItem', 'udi', elem.udiElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimItem', 'bodySite', elem.bodySiteElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCoding(false, this, 'ClaimItem', 'subSite', elem.subSiteList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCoding(false, this, 'ClaimItem', 'modifier', elem.modifierList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimItemDetail(this, 'ClaimItem', 'detail', elem.detailList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClaimItemProsthesis(this, 'ClaimItem', 'prosthesis', elem.prosthesisElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClaimItemDetail(element : IXmlDomElement; path : string) : TFhirClaimItemDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimItemDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequence') then
        result.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'service') then
        result.service := ParseCoding(child, path+'/service') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'unitPrice') then
        result.unitPrice := ParseQuantity(child, path+'/unitPrice') {b}
      else if (child.baseName = 'factor') then
        result.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.baseName = 'points') then
        result.pointsElement := ParseDecimal(child, path+'/points') {b}
      else if (child.baseName = 'net') then
        result.net := ParseQuantity(child, path+'/net') {b}
      else if (child.baseName = 'udi') then
        result.udi := ParseCoding(child, path+'/udi') {b}
      else if (child.baseName = 'subDetail') then
        result.subDetailList.Add(ParseClaimItemDetailSubDetail(child, path+'/subDetail')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimItemDetail);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'service', elem.service);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'unitPrice', elem.unitPrice);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'points', elem.pointsElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'net', elem.net);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'udi', elem.udi);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimItemDetailSubDetail(xml, 'subDetail', elem.subDetailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimItemDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimItemDetail(jsn : TJsonObject) : TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('service') then
        result.service := ParseCoding(jsn.vObj['service']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseQuantity(jsn.vObj['unitPrice']);{q}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('points') or jsn.has('_points') then
        result.pointsElement := ParseDecimal(jsn['points'], jsn.vObj['_points']);{q}
    if jsn.has('net') then
        result.net := ParseQuantity(jsn.vObj['net']);{q}
    if jsn.has('udi') then
        result.udi := ParseCoding(jsn.vObj['udi']);{q}
    if jsn.has('subDetail') then
      iterateArray(jsn.vArr['subDetail'], result.subDetailList, parseClaimItemDetailSubDetail);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimItemDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'service', elem.service); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'udi', elem.udi); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.subDetailList.Count > 0) then
  begin
    json.valueArray('subDetail');
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimItemDetailSubDetail(json, '', elem.subDetailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimItemDetail(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimItemDetail; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimItemDetail');
  end;
  composeBackboneElement(this, 'ClaimItemDetail', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ClaimItemDetail', 'sequence', elem.sequenceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimItemDetail', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimItemDetail', 'service', elem.serviceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimItemDetail', 'quantity', elem.quantityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimItemDetail', 'unitPrice', elem.unitPriceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'ClaimItemDetail', 'factor', elem.factorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'ClaimItemDetail', 'points', elem.pointsElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimItemDetail', 'net', elem.netElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimItemDetail', 'udi', elem.udiElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimItemDetailSubDetail(this, 'ClaimItemDetail', 'subDetail', elem.subDetailList[i], i);
end;

function TFHIRXmlParser.ParseClaimItemDetailSubDetail(element : IXmlDomElement; path : string) : TFhirClaimItemDetailSubDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequence') then
        result.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'service') then
        result.service := ParseCoding(child, path+'/service') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'unitPrice') then
        result.unitPrice := ParseQuantity(child, path+'/unitPrice') {b}
      else if (child.baseName = 'factor') then
        result.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.baseName = 'points') then
        result.pointsElement := ParseDecimal(child, path+'/points') {b}
      else if (child.baseName = 'net') then
        result.net := ParseQuantity(child, path+'/net') {b}
      else if (child.baseName = 'udi') then
        result.udi := ParseCoding(child, path+'/udi') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimItemDetailSubDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimItemDetailSubDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'service', elem.service);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'unitPrice', elem.unitPrice);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'points', elem.pointsElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'net', elem.net);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'udi', elem.udi);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimItemDetailSubDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('service') then
        result.service := ParseCoding(jsn.vObj['service']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseQuantity(jsn.vObj['unitPrice']);{q}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('points') or jsn.has('_points') then
        result.pointsElement := ParseDecimal(jsn['points'], jsn.vObj['_points']);{q}
    if jsn.has('net') then
        result.net := ParseQuantity(jsn.vObj['net']);{q}
    if jsn.has('udi') then
        result.udi := ParseCoding(jsn.vObj['udi']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimItemDetailSubDetail; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'service', elem.service); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'udi', elem.udi); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimItemDetailSubDetail(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimItemDetailSubDetail; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimItemDetailSubDetail');
  end;
  composeBackboneElement(this, 'ClaimItemDetailSubDetail', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ClaimItemDetailSubDetail', 'sequence', elem.sequenceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimItemDetailSubDetail', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimItemDetailSubDetail', 'service', elem.serviceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimItemDetailSubDetail', 'quantity', elem.quantityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimItemDetailSubDetail', 'unitPrice', elem.unitPriceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'ClaimItemDetailSubDetail', 'factor', elem.factorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'ClaimItemDetailSubDetail', 'points', elem.pointsElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimItemDetailSubDetail', 'net', elem.netElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimItemDetailSubDetail', 'udi', elem.udiElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClaimItemProsthesis(element : IXmlDomElement; path : string) : TFhirClaimItemProsthesis;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimItemProsthesis.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'initial') then
        result.initialElement := ParseBoolean(child, path+'/initial') {b}
      else if (child.baseName = 'priorDate') then
        result.priorDateElement := ParseDate(child, path+'/priorDate') {b}
      else if (child.baseName = 'priorMaterial') then
        result.priorMaterial := ParseCoding(child, path+'/priorMaterial') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimItemProsthesis(xml : TXmlBuilder; name : string; elem : TFhirClaimItemProsthesis);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'initial', elem.initialElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'priorDate', elem.priorDateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'priorMaterial', elem.priorMaterial);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimItemProsthesis(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimItemProsthesis(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimItemProsthesis(jsn : TJsonObject) : TFhirClaimItemProsthesis;
begin
  result := TFhirClaimItemProsthesis.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('initial') or jsn.has('_initial') then
        result.initialElement := ParseBoolean(jsn['initial'], jsn.vObj['_initial']);{q}
    if jsn.has('priorDate') or jsn.has('_priorDate') then
        result.priorDateElement := ParseDate(jsn['priorDate'], jsn.vObj['_priorDate']);{q}
    if jsn.has('priorMaterial') then
        result.priorMaterial := ParseCoding(jsn.vObj['priorMaterial']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimItemProsthesis(json : TJSONWriter; name : string; elem : TFhirClaimItemProsthesis; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'initial', elem.initialElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'initial', elem.initialElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'priorDate', elem.priorDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'priorDate', elem.priorDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'priorMaterial', elem.priorMaterial); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimItemProsthesis(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimItemProsthesis; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimItemProsthesis');
  end;
  composeBackboneElement(this, 'ClaimItemProsthesis', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ClaimItemProsthesis', 'initial', elem.initialElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'ClaimItemProsthesis', 'priorDate', elem.priorDateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimItemProsthesis', 'priorMaterial', elem.priorMaterialElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClaimMissingTeeth(element : IXmlDomElement; path : string) : TFhirClaimMissingTeeth;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimMissingTeeth.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'tooth') then
        result.tooth := ParseCoding(child, path+'/tooth') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCoding(child, path+'/reason') {b}
      else if (child.baseName = 'extractionDate') then
        result.extractionDateElement := ParseDate(child, path+'/extractionDate') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimMissingTeeth(xml : TXmlBuilder; name : string; elem : TFhirClaimMissingTeeth);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'tooth', elem.tooth);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'reason', elem.reason);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'extractionDate', elem.extractionDateElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimMissingTeeth(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimMissingTeeth(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimMissingTeeth(jsn : TJsonObject) : TFhirClaimMissingTeeth;
begin
  result := TFhirClaimMissingTeeth.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('tooth') then
        result.tooth := ParseCoding(jsn.vObj['tooth']);{q}
    if jsn.has('reason') then
        result.reason := ParseCoding(jsn.vObj['reason']);{q}
    if jsn.has('extractionDate') or jsn.has('_extractionDate') then
        result.extractionDateElement := ParseDate(jsn['extractionDate'], jsn.vObj['_extractionDate']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimMissingTeeth(json : TJSONWriter; name : string; elem : TFhirClaimMissingTeeth; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'tooth', elem.tooth); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'reason', elem.reason); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'extractionDate', elem.extractionDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'extractionDate', elem.extractionDateElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimMissingTeeth(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimMissingTeeth; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimMissingTeeth');
  end;
  composeBackboneElement(this, 'ClaimMissingTeeth', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimMissingTeeth', 'tooth', elem.toothElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimMissingTeeth', 'reason', elem.reasonElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'ClaimMissingTeeth', 'extractionDate', elem.extractionDateElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClaim(element : IXmlDomElement; path : string) : TFhirClaim;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaim.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirClaimTypeLinkEnum, SYSTEMS_TFhirClaimTypeLinkEnum, path+'/type', child){1a}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirOrganization}(child, path+'/target') {b}
      else if (child.baseName = 'provider') then
        result.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'use') then
        result.useElement := ParseEnum(CODES_TFhirClaimUseLinkEnum, SYSTEMS_TFhirClaimUseLinkEnum, path+'/use', child){1a}
      else if (child.baseName = 'priority') then
        result.priority := ParseCoding(child, path+'/priority') {b}
      else if (child.baseName = 'fundsReserve') then
        result.fundsReserve := ParseCoding(child, path+'/fundsReserve') {b}
      else if (child.baseName = 'enterer') then
        result.enterer := ParseReference{TFhirPractitioner}(child, path+'/enterer') {b}
      else if (child.baseName = 'facility') then
        result.facility := ParseReference{TFhirLocation}(child, path+'/facility') {b}
      else if (child.baseName = 'prescription') then
        result.prescription := ParseReference{Resource}(child, path+'/prescription') {b}
      else if (child.baseName = 'originalPrescription') then
        result.originalPrescription := ParseReference{TFhirMedicationOrder}(child, path+'/originalPrescription') {b}
      else if (child.baseName = 'payee') then
        result.payee := ParseClaimPayee(child, path+'/payee') {b}
      else if (child.baseName = 'referral') then
        result.referral := ParseReference{TFhirReferralRequest}(child, path+'/referral') {b}
      else if (child.baseName = 'diagnosis') then
        result.diagnosisList.Add(ParseClaimDiagnosis(child, path+'/diagnosis')){y.2}
      else if (child.baseName = 'condition') then
        result.conditionList.Add(ParseCoding(child, path+'/condition')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'coverage') then
        result.coverageList.Add(ParseClaimCoverage(child, path+'/coverage')){y.2}
      else if (child.baseName = 'exception') then
        result.exceptionList.Add(ParseCoding(child, path+'/exception')){y.2}
      else if (child.baseName = 'school') then
        result.schoolElement := ParseString(child, path+'/school') {b}
      else if (child.baseName = 'accident') then
        result.accidentElement := ParseDate(child, path+'/accident') {b}
      else if (child.baseName = 'accidentType') then
        result.accidentType := ParseCoding(child, path+'/accidentType') {b}
      else if (child.baseName = 'interventionException') then
        result.interventionExceptionList.Add(ParseCoding(child, path+'/interventionException')){y.2}
      else if (child.baseName = 'item') then
        result.itemList.Add(ParseClaimItem(child, path+'/item')){y.2}
      else if (child.baseName = 'additionalMaterials') then
        result.additionalMaterialsList.Add(ParseCoding(child, path+'/additionalMaterials')){y.2}
      else if (child.baseName = 'missingTeeth') then
        result.missingTeethList.Add(ParseClaimMissingTeeth(child, path+'/missingTeeth')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaim(xml : TXmlBuilder; name : string; elem : TFhirClaim);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirClaimTypeLinkEnum);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'target', elem.target);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirClaimUseLinkEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'priority', elem.priority);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'fundsReserve', elem.fundsReserve);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'enterer', elem.enterer);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(xml, 'facility', elem.facility);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'prescription', elem.prescription);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirMedicationOrder}(xml, 'originalPrescription', elem.originalPrescription);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClaimPayee(xml, 'payee', elem.payee);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReferralRequest}(xml, 'referral', elem.referral);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeClaimDiagnosis(xml, 'diagnosis', elem.diagnosisList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeCoding(xml, 'condition', elem.conditionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeClaimCoverage(xml, 'coverage', elem.coverageList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.exceptionList.Count - 1 do
      ComposeCoding(xml, 'exception', elem.exceptionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'school', elem.schoolElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'accident', elem.accidentElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'accidentType', elem.accidentType);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.interventionExceptionList.Count - 1 do
      ComposeCoding(xml, 'interventionException', elem.interventionExceptionList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimItem(xml, 'item', elem.itemList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.additionalMaterialsList.Count - 1 do
      ComposeCoding(xml, 'additionalMaterials', elem.additionalMaterialsList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.missingTeethList.Count - 1 do
      ComposeClaimMissingTeeth(xml, 'missingTeeth', elem.missingTeethList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaim(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaim(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaim(jsn : TJsonObject) : TFhirClaim;
begin
  result := TFhirClaim.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirClaimTypeLinkEnum, SYSTEMS_TFhirClaimTypeLinkEnum);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirOrganization}(jsn.vObj['target']);{q}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn['use'], jsn.vObj['_use'], CODES_TFhirClaimUseLinkEnum, SYSTEMS_TFhirClaimUseLinkEnum);
    if jsn.has('priority') then
        result.priority := ParseCoding(jsn.vObj['priority']);{q}
    if jsn.has('fundsReserve') then
        result.fundsReserve := ParseCoding(jsn.vObj['fundsReserve']);{q}
    if jsn.has('enterer') then
        result.enterer := ParseReference{TFhirPractitioner}(jsn.vObj['enterer']);{q}
    if jsn.has('facility') then
        result.facility := ParseReference{TFhirLocation}(jsn.vObj['facility']);{q}
    if jsn.has('prescription') then
        result.prescription := ParseReference{Resource}(jsn.vObj['prescription']);{q}
    if jsn.has('originalPrescription') then
        result.originalPrescription := ParseReference{TFhirMedicationOrder}(jsn.vObj['originalPrescription']);{q}
    if jsn.has('payee') then
        result.payee := ParseClaimPayee(jsn.vObj['payee']);{q}
    if jsn.has('referral') then
        result.referral := ParseReference{TFhirReferralRequest}(jsn.vObj['referral']);{q}
    if jsn.has('diagnosis') then
      iterateArray(jsn.vArr['diagnosis'], result.diagnosisList, parseClaimDiagnosis);
    if jsn.has('condition') then
      iterateArray(jsn.vArr['condition'], result.conditionList, parseCoding);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('coverage') then
      iterateArray(jsn.vArr['coverage'], result.coverageList, parseClaimCoverage);
    if jsn.has('exception') then
      iterateArray(jsn.vArr['exception'], result.exceptionList, parseCoding);
    if jsn.has('school') or jsn.has('_school') then
        result.schoolElement := ParseString(jsn['school'], jsn.vObj['_school']);{q}
    if jsn.has('accident') or jsn.has('_accident') then
        result.accidentElement := ParseDate(jsn['accident'], jsn.vObj['_accident']);{q}
    if jsn.has('accidentType') then
        result.accidentType := ParseCoding(jsn.vObj['accidentType']);{q}
    if jsn.has('interventionException') then
      iterateArray(jsn.vArr['interventionException'], result.interventionExceptionList, parseCoding);
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseClaimItem);
    if jsn.has('additionalMaterials') then
      iterateArray(jsn.vArr['additionalMaterials'], result.additionalMaterialsList, parseCoding);
    if jsn.has('missingTeeth') then
      iterateArray(jsn.vArr['missingTeeth'], result.missingTeethList, parseClaimMissingTeeth);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaim(json : TJSONWriter; name : string; elem : TFhirClaim; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirClaimTypeLinkEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirClaimTypeLinkEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'target', elem.target); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirClaimUseLinkEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirClaimUseLinkEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'priority', elem.priority); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'fundsReserve', elem.fundsReserve); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'enterer', elem.enterer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(json, 'facility', elem.facility); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'prescription', elem.prescription); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirMedicationOrder}(json, 'originalPrescription', elem.originalPrescription); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClaimPayee(json, 'payee', elem.payee); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReferralRequest}(json, 'referral', elem.referral); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.diagnosisList.Count > 0) then
  begin
    json.valueArray('diagnosis');
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeClaimDiagnosis(json, '', elem.diagnosisList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.conditionList.Count > 0) then
  begin
    json.valueArray('condition');
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeCoding(json, '', elem.conditionList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.coverageList.Count > 0) then
  begin
    json.valueArray('coverage');
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeClaimCoverage(json, '', elem.coverageList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.exceptionList.Count > 0) then
  begin
    json.valueArray('exception');
    for i := 0 to elem.exceptionList.Count - 1 do
      ComposeCoding(json, '', elem.exceptionList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'school', elem.schoolElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'school', elem.schoolElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'accident', elem.accidentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'accident', elem.accidentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'accidentType', elem.accidentType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.interventionExceptionList.Count > 0) then
  begin
    json.valueArray('interventionException');
    for i := 0 to elem.interventionExceptionList.Count - 1 do
      ComposeCoding(json, '', elem.interventionExceptionList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.itemList.Count > 0) then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimItem(json, '', elem.itemList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.additionalMaterialsList.Count > 0) then
  begin
    json.valueArray('additionalMaterials');
    for i := 0 to elem.additionalMaterialsList.Count - 1 do
      ComposeCoding(json, '', elem.additionalMaterialsList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.missingTeethList.Count > 0) then
  begin
    json.valueArray('missingTeeth');
    for i := 0 to elem.missingTeethList.Count - 1 do
      ComposeClaimMissingTeeth(json, '', elem.missingTeethList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeClaim(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaim; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Claim');
  end;
  composeDomainResource(this, 'Claim', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Claim', 'type', elem.Type_Element, CODES_TFhirClaimTypeLinkEnum, SYSTEMS_TFhirClaimTypeLinkEnum, -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Claim', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'Claim', 'ruleset', elem.rulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'Claim', 'originalRuleset', elem.originalRulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Claim', 'created', elem.createdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Claim', 'target', elem.targetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'Claim', 'provider', elem.providerElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Claim', 'organization', elem.organizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Claim', 'use', elem.UseElement, CODES_TFhirClaimUseLinkEnum, SYSTEMS_TFhirClaimUseLinkEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'Claim', 'priority', elem.priorityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'Claim', 'fundsReserve', elem.fundsReserveElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'Claim', 'enterer', elem.entererElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(this, 'Claim', 'facility', elem.facilityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Claim', 'prescription', elem.prescriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirMedicationOrder}(this, 'Claim', 'originalPrescription', elem.originalPrescriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClaimPayee(this, 'Claim', 'payee', elem.payeeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReferralRequest}(this, 'Claim', 'referral', elem.referralElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeClaimDiagnosis(this, 'Claim', 'diagnosis', elem.diagnosisList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeCoding(false, this, 'Claim', 'condition', elem.conditionList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'Claim', 'patient', elem.patientElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeClaimCoverage(this, 'Claim', 'coverage', elem.coverageList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.exceptionList.Count - 1 do
      ComposeCoding(false, this, 'Claim', 'exception', elem.exceptionList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Claim', 'school', elem.schoolElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'Claim', 'accident', elem.accidentElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'Claim', 'accidentType', elem.accidentTypeElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.interventionExceptionList.Count - 1 do
      ComposeCoding(false, this, 'Claim', 'interventionException', elem.interventionExceptionList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimItem(this, 'Claim', 'item', elem.itemList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.additionalMaterialsList.Count - 1 do
      ComposeCoding(false, this, 'Claim', 'additionalMaterials', elem.additionalMaterialsList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.missingTeethList.Count - 1 do
      ComposeClaimMissingTeeth(this, 'Claim', 'missingTeeth', elem.missingTeethList[i], i);
end;

function TFHIRXmlParser.ParseClaimResponseItem(element : IXmlDomElement; path : string) : TFhirClaimResponseItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(child, path+'/sequenceLinkId') {b}
      else if (child.baseName = 'noteNumber') then
        result.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber')){y.2}
      else if (child.baseName = 'adjudication') then
        result.adjudicationList.Add(ParseClaimResponseItemAdjudication(child, path+'/adjudication')){y.2}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseClaimResponseItemDetail(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItem(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItem);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', elem.noteNumberList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseItemDetail(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItem(jsn : TJsonObject) : TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(jsn['sequenceLinkId'], jsn.vObj['_sequenceLinkId']);{q}
      if jsn.has('noteNumber') or jsn.has('_noteNumber') then
      iteratePrimitiveArray(jsn.vArr['noteNumber'], jsn.vArr['_noteNumber'], result.noteNumberList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseItemAdjudication);
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseClaimResponseItemDetail);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItem(json : TJSONWriter; name : string; elem : TFhirClaimResponseItem; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.noteNumberList.Count > 0) then
  begin
    json.valueArray('noteNumber');
    ext := false;
    for i := 0 to elem.noteNumberList.Count - 1 do
    begin
      ext := ext or ((elem.noteNumberList[i].id <> '') or (elem.noteNumberList[i].hasExtensionList));
      ComposePositiveIntValue(json, '',elem.noteNumberList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(json, '', elem.adjudicationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseItemDetail(json, '', elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimResponseItem(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseItem; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimResponseItem');
  end;
  composeBackboneElement(this, 'ClaimResponseItem', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ClaimResponseItem', 'sequenceLinkId', elem.sequenceLinkIdElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponseItem', 'noteNumber', elem.noteNumberList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponseItem', 'adjudication', elem.adjudicationList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseItemDetail(this, 'ClaimResponseItem', 'detail', elem.detailList[i], i);
end;

function TFHIRXmlParser.ParseClaimResponseItemAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseItemAdjudication;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCoding(child, path+'/code') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseDecimal(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemAdjudication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseItemAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemAdjudication(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemAdjudication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimResponseItemAdjudication(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseItemAdjudication; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimResponseItemAdjudication');
  end;
  composeBackboneElement(this, 'ClaimResponseItemAdjudication', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimResponseItemAdjudication', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponseItemAdjudication', 'amount', elem.amountElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'ClaimResponseItemAdjudication', 'value', elem.valueElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClaimResponseItemDetail(element : IXmlDomElement; path : string) : TFhirClaimResponseItemDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(child, path+'/sequenceLinkId') {b}
      else if (child.baseName = 'adjudication') then
        result.adjudicationList.Add(ParseClaimResponseItemDetailAdjudication(child, path+'/adjudication')){y.2}
      else if (child.baseName = 'subDetail') then
        result.subDetailList.Add(ParseClaimResponseItemDetailSubDetail(child, path+'/subDetail')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetail);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemDetailAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetail(xml, 'subDetail', elem.subDetailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemDetail(jsn : TJsonObject) : TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(jsn['sequenceLinkId'], jsn.vObj['_sequenceLinkId']);{q}
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseItemDetailAdjudication);
    if jsn.has('subDetail') then
      iterateArray(jsn.vArr['subDetail'], result.subDetailList, parseClaimResponseItemDetailSubDetail);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemDetailAdjudication(json, '', elem.adjudicationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.subDetailList.Count > 0) then
  begin
    json.valueArray('subDetail');
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetail(json, '', elem.subDetailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimResponseItemDetail(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseItemDetail; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimResponseItemDetail');
  end;
  composeBackboneElement(this, 'ClaimResponseItemDetail', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ClaimResponseItemDetail', 'sequenceLinkId', elem.sequenceLinkIdElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemDetailAdjudication(this, 'ClaimResponseItemDetail', 'adjudication', elem.adjudicationList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetail(this, 'ClaimResponseItemDetail', 'subDetail', elem.subDetailList[i], i);
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseItemDetailAdjudication;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseItemDetailAdjudication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCoding(child, path+'/code') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseDecimal(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetailAdjudication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemDetailAdjudication(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailAdjudication.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailAdjudication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimResponseItemDetailAdjudication(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseItemDetailAdjudication; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimResponseItemDetailAdjudication');
  end;
  composeBackboneElement(this, 'ClaimResponseItemDetailAdjudication', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimResponseItemDetailAdjudication', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponseItemDetailAdjudication', 'amount', elem.amountElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'ClaimResponseItemDetailAdjudication', 'value', elem.valueElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailSubDetail(element : IXmlDomElement; path : string) : TFhirClaimResponseItemDetailSubDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(child, path+'/sequenceLinkId') {b}
      else if (child.baseName = 'adjudication') then
        result.adjudicationList.Add(ParseClaimResponseItemDetailSubDetailAdjudication(child, path+'/adjudication')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailSubDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetailSubDetail);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetailAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemDetailSubDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(jsn['sequenceLinkId'], jsn.vObj['_sequenceLinkId']);{q}
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseItemDetailSubDetailAdjudication);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailSubDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetailAdjudication(json, '', elem.adjudicationList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimResponseItemDetailSubDetail(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseItemDetailSubDetail; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimResponseItemDetailSubDetail');
  end;
  composeBackboneElement(this, 'ClaimResponseItemDetailSubDetail', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ClaimResponseItemDetailSubDetail', 'sequenceLinkId', elem.sequenceLinkIdElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetailAdjudication(this, 'ClaimResponseItemDetailSubDetail', 'adjudication', elem.adjudicationList[i], i);
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailSubDetailAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseItemDetailSubDetailAdjudication;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseItemDetailSubDetailAdjudication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCoding(child, path+'/code') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseDecimal(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailSubDetailAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetailSubDetailAdjudication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetailSubDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemDetailSubDetailAdjudication(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemDetailSubDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemDetailSubDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailSubDetailAdjudication.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemDetailSubDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailSubDetailAdjudication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimResponseItemDetailSubDetailAdjudication(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseItemDetailSubDetailAdjudication; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimResponseItemDetailSubDetailAdjudication');
  end;
  composeBackboneElement(this, 'ClaimResponseItemDetailSubDetailAdjudication', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimResponseItemDetailSubDetailAdjudication', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponseItemDetailSubDetailAdjudication', 'amount', elem.amountElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'ClaimResponseItemDetailSubDetailAdjudication', 'value', elem.valueElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClaimResponseAddItem(element : IXmlDomElement; path : string) : TFhirClaimResponseAddItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequenceLinkId') then
        result.sequenceLinkIdList.Add(ParsePositiveInt(child, path+'/sequenceLinkId')){y.2}
      else if (child.baseName = 'service') then
        result.service := ParseCoding(child, path+'/service') {b}
      else if (child.baseName = 'fee') then
        result.fee := ParseQuantity(child, path+'/fee') {b}
      else if (child.baseName = 'noteNumberLinkId') then
        result.noteNumberLinkIdList.Add(ParsePositiveInt(child, path+'/noteNumberLinkId')){y.2}
      else if (child.baseName = 'adjudication') then
        result.adjudicationList.Add(ParseClaimResponseAddItemAdjudication(child, path+'/adjudication')){y.2}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseClaimResponseAddItemDetail(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItem(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItem);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.sequenceLinkIdList.Count - 1 do
      ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'service', elem.service);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'fee', elem.fee);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.noteNumberLinkIdList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumberLinkId', elem.noteNumberLinkIdList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseAddItemAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseAddItemDetail(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseAddItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseAddItem(jsn : TJsonObject) : TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
      iteratePrimitiveArray(jsn.vArr['sequenceLinkId'], jsn.vArr['_sequenceLinkId'], result.sequenceLinkIdList, parsePositiveInt);
    if jsn.has('service') then
        result.service := ParseCoding(jsn.vObj['service']);{q}
    if jsn.has('fee') then
        result.fee := ParseQuantity(jsn.vObj['fee']);{q}
      if jsn.has('noteNumberLinkId') or jsn.has('_noteNumberLinkId') then
      iteratePrimitiveArray(jsn.vArr['noteNumberLinkId'], jsn.vArr['_noteNumberLinkId'], result.noteNumberLinkIdList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseAddItemAdjudication);
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseClaimResponseAddItemDetail);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseAddItem(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItem; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.sequenceLinkIdList.Count > 0) then
  begin
    json.valueArray('sequenceLinkId');
    ext := false;
    for i := 0 to elem.sequenceLinkIdList.Count - 1 do
    begin
      ext := ext or ((elem.sequenceLinkIdList[i].id <> '') or (elem.sequenceLinkIdList[i].hasExtensionList));
      ComposePositiveIntValue(json, '',elem.sequenceLinkIdList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_sequenceLinkId');
      for i := 0 to elem.sequenceLinkIdList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.sequenceLinkIdList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'service', elem.service); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'fee', elem.fee); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.noteNumberLinkIdList.Count > 0) then
  begin
    json.valueArray('noteNumberLinkId');
    ext := false;
    for i := 0 to elem.noteNumberLinkIdList.Count - 1 do
    begin
      ext := ext or ((elem.noteNumberLinkIdList[i].id <> '') or (elem.noteNumberLinkIdList[i].hasExtensionList));
      ComposePositiveIntValue(json, '',elem.noteNumberLinkIdList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_noteNumberLinkId');
      for i := 0 to elem.noteNumberLinkIdList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberLinkIdList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseAddItemAdjudication(json, '', elem.adjudicationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseAddItemDetail(json, '', elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimResponseAddItem(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseAddItem; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimResponseAddItem');
  end;
  composeBackboneElement(this, 'ClaimResponseAddItem', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.sequenceLinkIdList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponseAddItem', 'sequenceLinkId', elem.sequenceLinkIdList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimResponseAddItem', 'service', elem.serviceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponseAddItem', 'fee', elem.feeElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.noteNumberLinkIdList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponseAddItem', 'noteNumberLinkId', elem.noteNumberLinkIdList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseAddItemAdjudication(this, 'ClaimResponseAddItem', 'adjudication', elem.adjudicationList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseAddItemDetail(this, 'ClaimResponseAddItem', 'detail', elem.detailList[i], i);
end;

function TFHIRXmlParser.ParseClaimResponseAddItemAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseAddItemAdjudication;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseAddItemAdjudication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCoding(child, path+'/code') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseDecimal(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItemAdjudication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseAddItemAdjudication(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseAddItemAdjudication(jsn : TJsonObject) : TFhirClaimResponseAddItemAdjudication;
begin
  result := TFhirClaimResponseAddItemAdjudication.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseAddItemAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemAdjudication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimResponseAddItemAdjudication(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseAddItemAdjudication; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimResponseAddItemAdjudication');
  end;
  composeBackboneElement(this, 'ClaimResponseAddItemAdjudication', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimResponseAddItemAdjudication', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponseAddItemAdjudication', 'amount', elem.amountElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'ClaimResponseAddItemAdjudication', 'value', elem.valueElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClaimResponseAddItemDetail(element : IXmlDomElement; path : string) : TFhirClaimResponseAddItemDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'service') then
        result.service := ParseCoding(child, path+'/service') {b}
      else if (child.baseName = 'fee') then
        result.fee := ParseQuantity(child, path+'/fee') {b}
      else if (child.baseName = 'adjudication') then
        result.adjudicationList.Add(ParseClaimResponseAddItemDetailAdjudication(child, path+'/adjudication')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItemDetail);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'service', elem.service);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'fee', elem.fee);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseAddItemDetailAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseAddItemDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseAddItemDetail(jsn : TJsonObject) : TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('service') then
        result.service := ParseCoding(jsn.vObj['service']);{q}
    if jsn.has('fee') then
        result.fee := ParseQuantity(jsn.vObj['fee']);{q}
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseAddItemDetailAdjudication);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseAddItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'service', elem.service); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'fee', elem.fee); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseAddItemDetailAdjudication(json, '', elem.adjudicationList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimResponseAddItemDetail(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseAddItemDetail; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimResponseAddItemDetail');
  end;
  composeBackboneElement(this, 'ClaimResponseAddItemDetail', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimResponseAddItemDetail', 'service', elem.serviceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponseAddItemDetail', 'fee', elem.feeElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseAddItemDetailAdjudication(this, 'ClaimResponseAddItemDetail', 'adjudication', elem.adjudicationList[i], i);
end;

function TFHIRXmlParser.ParseClaimResponseAddItemDetailAdjudication(element : IXmlDomElement; path : string) : TFhirClaimResponseAddItemDetailAdjudication;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseAddItemDetailAdjudication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCoding(child, path+'/code') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseDecimal(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemDetailAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItemDetailAdjudication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseAddItemDetailAdjudication(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseAddItemDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseAddItemDetailAdjudication;
begin
  result := TFhirClaimResponseAddItemDetailAdjudication.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseAddItemDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemDetailAdjudication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimResponseAddItemDetailAdjudication(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseAddItemDetailAdjudication; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimResponseAddItemDetailAdjudication');
  end;
  composeBackboneElement(this, 'ClaimResponseAddItemDetailAdjudication', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimResponseAddItemDetailAdjudication', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponseAddItemDetailAdjudication', 'amount', elem.amountElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'ClaimResponseAddItemDetailAdjudication', 'value', elem.valueElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClaimResponseError(element : IXmlDomElement; path : string) : TFhirClaimResponseError;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseError.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(child, path+'/sequenceLinkId') {b}
      else if (child.baseName = 'detailSequenceLinkId') then
        result.detailSequenceLinkIdElement := ParsePositiveInt(child, path+'/detailSequenceLinkId') {b}
      else if (child.baseName = 'subdetailSequenceLinkId') then
        result.subdetailSequenceLinkIdElement := ParsePositiveInt(child, path+'/subdetailSequenceLinkId') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCoding(child, path+'/code') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseError(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseError);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'detailSequenceLinkId', elem.detailSequenceLinkIdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'subdetailSequenceLinkId', elem.subdetailSequenceLinkIdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'code', elem.code);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseError(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseError(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseError(jsn : TJsonObject) : TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(jsn['sequenceLinkId'], jsn.vObj['_sequenceLinkId']);{q}
    if jsn.has('detailSequenceLinkId') or jsn.has('_detailSequenceLinkId') then
        result.detailSequenceLinkIdElement := ParsePositiveInt(jsn['detailSequenceLinkId'], jsn.vObj['_detailSequenceLinkId']);{q}
    if jsn.has('subdetailSequenceLinkId') or jsn.has('_subdetailSequenceLinkId') then
        result.subdetailSequenceLinkIdElement := ParsePositiveInt(jsn['subdetailSequenceLinkId'], jsn.vObj['_subdetailSequenceLinkId']);{q}
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseError(json : TJSONWriter; name : string; elem : TFhirClaimResponseError; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'detailSequenceLinkId', elem.detailSequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'detailSequenceLinkId', elem.detailSequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'subdetailSequenceLinkId', elem.subdetailSequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'subdetailSequenceLinkId', elem.subdetailSequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'code', elem.code); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimResponseError(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseError; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimResponseError');
  end;
  composeBackboneElement(this, 'ClaimResponseError', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ClaimResponseError', 'sequenceLinkId', elem.sequenceLinkIdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ClaimResponseError', 'detailSequenceLinkId', elem.detailSequenceLinkIdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ClaimResponseError', 'subdetailSequenceLinkId', elem.subdetailSequenceLinkIdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimResponseError', 'code', elem.codeElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClaimResponseNote(element : IXmlDomElement; path : string) : TFhirClaimResponseNote;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseNote.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'number') then
        result.numberElement := ParsePositiveInt(child, path+'/number') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseNote(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseNote);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'number', elem.numberElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseNote(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseNote(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseNote(jsn : TJsonObject) : TFhirClaimResponseNote;
begin
  result := TFhirClaimResponseNote.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('number') or jsn.has('_number') then
        result.numberElement := ParsePositiveInt(jsn['number'], jsn.vObj['_number']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseNote(json : TJSONWriter; name : string; elem : TFhirClaimResponseNote; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimResponseNote(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseNote; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimResponseNote');
  end;
  composeBackboneElement(this, 'ClaimResponseNote', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ClaimResponseNote', 'number', elem.numberElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimResponseNote', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ClaimResponseNote', 'text', elem.textElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClaimResponseCoverage(element : IXmlDomElement; path : string) : TFhirClaimResponseCoverage;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponseCoverage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequence') then
        result.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.baseName = 'focal') then
        result.focalElement := ParseBoolean(child, path+'/focal') {b}
      else if (child.baseName = 'coverage') then
        result.coverage := ParseReference{TFhirCoverage}(child, path+'/coverage') {b}
      else if (child.baseName = 'businessArrangement') then
        result.businessArrangementElement := ParseString(child, path+'/businessArrangement') {b}
      else if (child.baseName = 'relationship') then
        result.relationship := ParseCoding(child, path+'/relationship') {b}
      else if (child.baseName = 'preAuthRef') then
        result.preAuthRefList.Add(ParseString(child, path+'/preAuthRef')){y.2}
      else if (child.baseName = 'claimResponse') then
        result.claimResponse := ParseReference{TFhirClaimResponse}(child, path+'/claimResponse') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseCoverage(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseCoverage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'focal', elem.focalElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirCoverage}(xml, 'coverage', elem.coverage);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'businessArrangement', elem.businessArrangementElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'relationship', elem.relationship);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.preAuthRefList.Count - 1 do
      ComposeString(xml, 'preAuthRef', elem.preAuthRefList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaimResponse}(xml, 'claimResponse', elem.claimResponse);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponseCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseCoverage(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseCoverage(jsn : TJsonObject) : TFhirClaimResponseCoverage;
begin
  result := TFhirClaimResponseCoverage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('focal') or jsn.has('_focal') then
        result.focalElement := ParseBoolean(jsn['focal'], jsn.vObj['_focal']);{q}
    if jsn.has('coverage') then
        result.coverage := ParseReference{TFhirCoverage}(jsn.vObj['coverage']);{q}
    if jsn.has('businessArrangement') or jsn.has('_businessArrangement') then
        result.businessArrangementElement := ParseString(jsn['businessArrangement'], jsn.vObj['_businessArrangement']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCoding(jsn.vObj['relationship']);{q}
      if jsn.has('preAuthRef') or jsn.has('_preAuthRef') then
      iteratePrimitiveArray(jsn.vArr['preAuthRef'], jsn.vArr['_preAuthRef'], result.preAuthRefList, parseString);
    if jsn.has('claimResponse') then
        result.claimResponse := ParseReference{TFhirClaimResponse}(jsn.vObj['claimResponse']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponseCoverage(json : TJSONWriter; name : string; elem : TFhirClaimResponseCoverage; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'focal', elem.focalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'focal', elem.focalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirCoverage}(json, 'coverage', elem.coverage); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'businessArrangement', elem.businessArrangementElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'businessArrangement', elem.businessArrangementElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'relationship', elem.relationship); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.preAuthRefList.Count > 0) then
  begin
    json.valueArray('preAuthRef');
    ext := false;
    for i := 0 to elem.preAuthRefList.Count - 1 do
    begin
      ext := ext or ((elem.preAuthRefList[i].id <> '') or (elem.preAuthRefList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.preAuthRefList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_preAuthRef');
      for i := 0 to elem.preAuthRefList.Count - 1 do
        ComposeStringProps(json, '',elem.preAuthRefList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaimResponse}(json, 'claimResponse', elem.claimResponse); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClaimResponseCoverage(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponseCoverage; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimResponseCoverage');
  end;
  composeBackboneElement(this, 'ClaimResponseCoverage', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ClaimResponseCoverage', 'sequence', elem.sequenceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ClaimResponseCoverage', 'focal', elem.focalElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirCoverage}(this, 'ClaimResponseCoverage', 'coverage', elem.coverageElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ClaimResponseCoverage', 'businessArrangement', elem.businessArrangementElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimResponseCoverage', 'relationship', elem.relationshipElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.preAuthRefList.Count - 1 do
      ComposeString(this, 'ClaimResponseCoverage', 'preAuthRef', elem.preAuthRefList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaimResponse}(this, 'ClaimResponseCoverage', 'claimResponse', elem.claimResponseElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimResponseCoverage', 'originalRuleset', elem.originalRulesetElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClaimResponse(element : IXmlDomElement; path : string) : TFhirClaimResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirClaimResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirClaim}(child, path+'/request') {b}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.baseName = 'requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if (child.baseName = 'outcome') then
        result.outcomeElement := ParseEnum(CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, path+'/outcome', child){1a}
      else if (child.baseName = 'disposition') then
        result.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.baseName = 'payeeType') then
        result.payeeType := ParseCoding(child, path+'/payeeType') {b}
      else if (child.baseName = 'item') then
        result.itemList.Add(ParseClaimResponseItem(child, path+'/item')){y.2}
      else if (child.baseName = 'addItem') then
        result.addItemList.Add(ParseClaimResponseAddItem(child, path+'/addItem')){y.2}
      else if (child.baseName = 'error') then
        result.errorList.Add(ParseClaimResponseError(child, path+'/error')){y.2}
      else if (child.baseName = 'totalCost') then
        result.totalCost := ParseQuantity(child, path+'/totalCost') {b}
      else if (child.baseName = 'unallocDeductable') then
        result.unallocDeductable := ParseQuantity(child, path+'/unallocDeductable') {b}
      else if (child.baseName = 'totalBenefit') then
        result.totalBenefit := ParseQuantity(child, path+'/totalBenefit') {b}
      else if (child.baseName = 'paymentAdjustment') then
        result.paymentAdjustment := ParseQuantity(child, path+'/paymentAdjustment') {b}
      else if (child.baseName = 'paymentAdjustmentReason') then
        result.paymentAdjustmentReason := ParseCoding(child, path+'/paymentAdjustmentReason') {b}
      else if (child.baseName = 'paymentDate') then
        result.paymentDateElement := ParseDate(child, path+'/paymentDate') {b}
      else if (child.baseName = 'paymentAmount') then
        result.paymentAmount := ParseQuantity(child, path+'/paymentAmount') {b}
      else if (child.baseName = 'paymentRef') then
        result.paymentRef := ParseIdentifier(child, path+'/paymentRef') {b}
      else if (child.baseName = 'reserved') then
        result.reserved := ParseCoding(child, path+'/reserved') {b}
      else if (child.baseName = 'form') then
        result.form := ParseCoding(child, path+'/form') {b}
      else if (child.baseName = 'note') then
        result.noteList.Add(ParseClaimResponseNote(child, path+'/note')){y.2}
      else if (child.baseName = 'coverage') then
        result.coverageList.Add(ParseClaimResponseCoverage(child, path+'/coverage')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClaimResponse(xml : TXmlBuilder; name : string; elem : TFhirClaimResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaim}(xml, 'request', elem.request);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'payeeType', elem.payeeType);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimResponseItem(xml, 'item', elem.itemList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.addItemList.Count - 1 do
      ComposeClaimResponseAddItem(xml, 'addItem', elem.addItemList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.errorList.Count - 1 do
      ComposeClaimResponseError(xml, 'error', elem.errorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'totalCost', elem.totalCost);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'unallocDeductable', elem.unallocDeductable);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'totalBenefit', elem.totalBenefit);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'paymentAdjustment', elem.paymentAdjustment);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'paymentAdjustmentReason', elem.paymentAdjustmentReason);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'paymentDate', elem.paymentDateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'paymentAmount', elem.paymentAmount);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'paymentRef', elem.paymentRef);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'reserved', elem.reserved);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'form', elem.form);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeClaimResponseNote(xml, 'note', elem.noteList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeClaimResponseCoverage(xml, 'coverage', elem.coverageList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClaimResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponse(jsn : TJsonObject) : TFhirClaimResponse;
begin
  result := TFhirClaimResponse.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirClaim}(jsn.vObj['request']);{q}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn['outcome'], jsn.vObj['_outcome'], CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('payeeType') then
        result.payeeType := ParseCoding(jsn.vObj['payeeType']);{q}
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseClaimResponseItem);
    if jsn.has('addItem') then
      iterateArray(jsn.vArr['addItem'], result.addItemList, parseClaimResponseAddItem);
    if jsn.has('error') then
      iterateArray(jsn.vArr['error'], result.errorList, parseClaimResponseError);
    if jsn.has('totalCost') then
        result.totalCost := ParseQuantity(jsn.vObj['totalCost']);{q}
    if jsn.has('unallocDeductable') then
        result.unallocDeductable := ParseQuantity(jsn.vObj['unallocDeductable']);{q}
    if jsn.has('totalBenefit') then
        result.totalBenefit := ParseQuantity(jsn.vObj['totalBenefit']);{q}
    if jsn.has('paymentAdjustment') then
        result.paymentAdjustment := ParseQuantity(jsn.vObj['paymentAdjustment']);{q}
    if jsn.has('paymentAdjustmentReason') then
        result.paymentAdjustmentReason := ParseCoding(jsn.vObj['paymentAdjustmentReason']);{q}
    if jsn.has('paymentDate') or jsn.has('_paymentDate') then
        result.paymentDateElement := ParseDate(jsn['paymentDate'], jsn.vObj['_paymentDate']);{q}
    if jsn.has('paymentAmount') then
        result.paymentAmount := ParseQuantity(jsn.vObj['paymentAmount']);{q}
    if jsn.has('paymentRef') then
        result.paymentRef := ParseIdentifier(jsn.vObj['paymentRef']);{q}
    if jsn.has('reserved') then
        result.reserved := ParseCoding(jsn.vObj['reserved']);{q}
    if jsn.has('form') then
        result.form := ParseCoding(jsn.vObj['form']);{q}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseClaimResponseNote);
    if jsn.has('coverage') then
      iterateArray(jsn.vArr['coverage'], result.coverageList, parseClaimResponseCoverage);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClaimResponse(json : TJSONWriter; name : string; elem : TFhirClaimResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaim}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'payeeType', elem.payeeType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.itemList.Count > 0) then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimResponseItem(json, '', elem.itemList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.addItemList.Count > 0) then
  begin
    json.valueArray('addItem');
    for i := 0 to elem.addItemList.Count - 1 do
      ComposeClaimResponseAddItem(json, '', elem.addItemList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.errorList.Count > 0) then
  begin
    json.valueArray('error');
    for i := 0 to elem.errorList.Count - 1 do
      ComposeClaimResponseError(json, '', elem.errorList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'totalCost', elem.totalCost); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'unallocDeductable', elem.unallocDeductable); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'totalBenefit', elem.totalBenefit); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'paymentAdjustment', elem.paymentAdjustment); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'paymentAdjustmentReason', elem.paymentAdjustmentReason); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'paymentDate', elem.paymentDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'paymentDate', elem.paymentDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'paymentAmount', elem.paymentAmount); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'paymentRef', elem.paymentRef); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'reserved', elem.reserved); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'form', elem.form); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeClaimResponseNote(json, '', elem.noteList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.coverageList.Count > 0) then
  begin
    json.valueArray('coverage');
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeClaimResponseCoverage(json, '', elem.coverageList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeClaimResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirClaimResponse; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClaimResponse');
  end;
  composeDomainResource(this, 'ClaimResponse', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ClaimResponse', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaim}(this, 'ClaimResponse', 'request', elem.requestElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimResponse', 'ruleset', elem.rulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimResponse', 'originalRuleset', elem.originalRulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ClaimResponse', 'created', elem.createdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'ClaimResponse', 'organization', elem.organizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'ClaimResponse', 'requestProvider', elem.requestProviderElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'ClaimResponse', 'requestOrganization', elem.requestOrganizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ClaimResponse', 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ClaimResponse', 'disposition', elem.dispositionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimResponse', 'payeeType', elem.payeeTypeElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimResponseItem(this, 'ClaimResponse', 'item', elem.itemList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.addItemList.Count - 1 do
      ComposeClaimResponseAddItem(this, 'ClaimResponse', 'addItem', elem.addItemList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.errorList.Count - 1 do
      ComposeClaimResponseError(this, 'ClaimResponse', 'error', elem.errorList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponse', 'totalCost', elem.totalCostElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponse', 'unallocDeductable', elem.unallocDeductableElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponse', 'totalBenefit', elem.totalBenefitElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponse', 'paymentAdjustment', elem.paymentAdjustmentElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimResponse', 'paymentAdjustmentReason', elem.paymentAdjustmentReasonElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'ClaimResponse', 'paymentDate', elem.paymentDateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponse', 'paymentAmount', elem.paymentAmountElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'ClaimResponse', 'paymentRef', elem.paymentRefElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimResponse', 'reserved', elem.reservedElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ClaimResponse', 'form', elem.formElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeClaimResponseNote(this, 'ClaimResponse', 'note', elem.noteList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeClaimResponseCoverage(this, 'ClaimResponse', 'coverage', elem.coverageList[i], i);
end;

function TFHIRXmlParser.ParseClinicalImpressionInvestigations(element : IXmlDomElement; path : string) : TFhirClinicalImpressionInvestigations;
var
  child : IXMLDOMElement;
begin
  result := TFhirClinicalImpressionInvestigations.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'item') then
        result.itemList.Add(ParseReference{Resource}(child, path+'/item')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionInvestigations(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpressionInvestigations);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeReference{Resource}(xml, 'item', elem.itemList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClinicalImpressionInvestigations(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClinicalImpressionInvestigations(jsn)); {2}
end;

function TFHIRJsonParser.ParseClinicalImpressionInvestigations(jsn : TJsonObject) : TFhirClinicalImpressionInvestigations;
begin
  result := TFhirClinicalImpressionInvestigations.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClinicalImpressionInvestigations(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionInvestigations; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (elem.itemList.Count > 0) then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.itemList[i]); {z - Reference(Observation|QuestionnaireResponse|FamilyMemberHistory|DiagnosticReport)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClinicalImpressionInvestigations(parent :  TRDFComplex; parentType, name : String; elem : TFhirClinicalImpressionInvestigations; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClinicalImpressionInvestigations');
  end;
  composeBackboneElement(this, 'ClinicalImpressionInvestigations', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClinicalImpressionInvestigations', 'code', elem.codeElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeReference{Resource}(this, 'ClinicalImpressionInvestigations', 'item', elem.itemList[i], i);
end;

function TFHIRXmlParser.ParseClinicalImpressionFinding(element : IXmlDomElement; path : string) : TFhirClinicalImpressionFinding;
var
  child : IXMLDOMElement;
begin
  result := TFhirClinicalImpressionFinding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'item') then
        result.item := ParseCodeableConcept(child, path+'/item') {b}
      else if (child.baseName = 'cause') then
        result.causeElement := ParseString(child, path+'/cause') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionFinding(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpressionFinding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'item', elem.item);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'cause', elem.causeElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClinicalImpressionFinding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClinicalImpressionFinding(jsn)); {2}
end;

function TFHIRJsonParser.ParseClinicalImpressionFinding(jsn : TJsonObject) : TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('item') then
        result.item := ParseCodeableConcept(jsn.vObj['item']);{q}
    if jsn.has('cause') or jsn.has('_cause') then
        result.causeElement := ParseString(jsn['cause'], jsn.vObj['_cause']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClinicalImpressionFinding(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionFinding; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'item', elem.item); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'cause', elem.causeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'cause', elem.causeElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClinicalImpressionFinding(parent :  TRDFComplex; parentType, name : String; elem : TFhirClinicalImpressionFinding; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClinicalImpressionFinding');
  end;
  composeBackboneElement(this, 'ClinicalImpressionFinding', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClinicalImpressionFinding', 'item', elem.itemElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ClinicalImpressionFinding', 'cause', elem.causeElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClinicalImpressionRuledOut(element : IXmlDomElement; path : string) : TFhirClinicalImpressionRuledOut;
var
  child : IXMLDOMElement;
begin
  result := TFhirClinicalImpressionRuledOut.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'item') then
        result.item := ParseCodeableConcept(child, path+'/item') {b}
      else if (child.baseName = 'reason') then
        result.reasonElement := ParseString(child, path+'/reason') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionRuledOut(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpressionRuledOut);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'item', elem.item);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'reason', elem.reasonElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClinicalImpressionRuledOut(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClinicalImpressionRuledOut(jsn)); {2}
end;

function TFHIRJsonParser.ParseClinicalImpressionRuledOut(jsn : TJsonObject) : TFhirClinicalImpressionRuledOut;
begin
  result := TFhirClinicalImpressionRuledOut.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('item') then
        result.item := ParseCodeableConcept(jsn.vObj['item']);{q}
    if jsn.has('reason') or jsn.has('_reason') then
        result.reasonElement := ParseString(jsn['reason'], jsn.vObj['_reason']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClinicalImpressionRuledOut(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionRuledOut; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'item', elem.item); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'reason', elem.reasonElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'reason', elem.reasonElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeClinicalImpressionRuledOut(parent :  TRDFComplex; parentType, name : String; elem : TFhirClinicalImpressionRuledOut; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClinicalImpressionRuledOut');
  end;
  composeBackboneElement(this, 'ClinicalImpressionRuledOut', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClinicalImpressionRuledOut', 'item', elem.itemElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ClinicalImpressionRuledOut', 'reason', elem.reasonElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseClinicalImpression(element : IXmlDomElement; path : string) : TFhirClinicalImpression;
var
  child : IXMLDOMElement;
begin
  result := TFhirClinicalImpression.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'assessor') then
        result.assessor := ParseReference{TFhirPractitioner}(child, path+'/assessor') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirClinicalImpressionStatusEnum, SYSTEMS_TFhirClinicalImpressionStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'previous') then
        result.previous := ParseReference{TFhirClinicalImpression}(child, path+'/previous') {b}
      else if (child.baseName = 'problem') then
        result.problemList.Add(ParseReference{Resource}(child, path+'/problem')){y.2}
      else if (child.baseName = 'triggerCodeableConcept') then
        result.trigger := ParseCodeableConcept(child, path+'/triggerCodeableConcept'){x.3}
      else if (child.baseName = 'triggerReference') then
        result.trigger := ParseReference(child, path+'/triggerReference') {a}
      else if (child.baseName = 'investigations') then
        result.investigationsList.Add(ParseClinicalImpressionInvestigations(child, path+'/investigations')){y.2}
      else if (child.baseName = 'protocol') then
        result.protocolElement := ParseUri(child, path+'/protocol') {b}
      else if (child.baseName = 'summary') then
        result.summaryElement := ParseString(child, path+'/summary') {b}
      else if (child.baseName = 'finding') then
        result.findingList.Add(ParseClinicalImpressionFinding(child, path+'/finding')){y.2}
      else if (child.baseName = 'resolved') then
        result.resolvedList.Add(ParseCodeableConcept(child, path+'/resolved')){y.2}
      else if (child.baseName = 'ruledOut') then
        result.ruledOutList.Add(ParseClinicalImpressionRuledOut(child, path+'/ruledOut')){y.2}
      else if (child.baseName = 'prognosis') then
        result.prognosisElement := ParseString(child, path+'/prognosis') {b}
      else if (child.baseName = 'plan') then
        result.planList.Add(ParseReference{Resource}(child, path+'/plan')){y.2}
      else if (child.baseName = 'action') then
        result.actionList.Add(ParseReference{Resource}(child, path+'/action')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpression(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpression);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'assessor', elem.assessor);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirClinicalImpressionStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClinicalImpression}(xml, 'previous', elem.previous);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.problemList.Count - 1 do
      ComposeReference{Resource}(xml, 'problem', elem.problemList[i]);
  if (SummaryOption in [soFull, soData]) and (elem.trigger is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'triggerCodeableConcept', TFhirCodeableConcept(elem.trigger))
  else if (SummaryOption in [soFull, soData]) and (elem.trigger is TFhirReference) {2} then
    ComposeReference(xml, 'triggerReference', TFhirReference(elem.trigger));
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.investigationsList.Count - 1 do
      ComposeClinicalImpressionInvestigations(xml, 'investigations', elem.investigationsList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'protocol', elem.protocolElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'summary', elem.summaryElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.findingList.Count - 1 do
      ComposeClinicalImpressionFinding(xml, 'finding', elem.findingList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.resolvedList.Count - 1 do
      ComposeCodeableConcept(xml, 'resolved', elem.resolvedList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.ruledOutList.Count - 1 do
      ComposeClinicalImpressionRuledOut(xml, 'ruledOut', elem.ruledOutList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'prognosis', elem.prognosisElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.planList.Count - 1 do
      ComposeReference{Resource}(xml, 'plan', elem.planList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeReference{Resource}(xml, 'action', elem.actionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseClinicalImpression(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClinicalImpression(jsn)); {2}
end;

function TFHIRJsonParser.ParseClinicalImpression(jsn : TJsonObject) : TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('assessor') then
        result.assessor := ParseReference{TFhirPractitioner}(jsn.vObj['assessor']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirClinicalImpressionStatusEnum, SYSTEMS_TFhirClinicalImpressionStatusEnum);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('previous') then
        result.previous := ParseReference{TFhirClinicalImpression}(jsn.vObj['previous']);{q}
    if jsn.has('problem') then
      iterateArray(jsn.vArr['problem'], result.problemList, parseReference{Resource});
    if jsn.has('triggerCodeableConcept') {a4} then
      result.trigger := ParseCodeableConcept(jsn.vObj['triggerCodeableConcept']);
    if jsn.has('triggerReference') {a3} then
      result.trigger := ParseReference(jsn.vObj['triggerReference']);
    if jsn.has('investigations') then
      iterateArray(jsn.vArr['investigations'], result.investigationsList, parseClinicalImpressionInvestigations);
    if jsn.has('protocol') or jsn.has('_protocol') then
        result.protocolElement := ParseUri(jsn['protocol'], jsn.vObj['_protocol']);{q}
    if jsn.has('summary') or jsn.has('_summary') then
        result.summaryElement := ParseString(jsn['summary'], jsn.vObj['_summary']);{q}
    if jsn.has('finding') then
      iterateArray(jsn.vArr['finding'], result.findingList, parseClinicalImpressionFinding);
    if jsn.has('resolved') then
      iterateArray(jsn.vArr['resolved'], result.resolvedList, parseCodeableConcept);
    if jsn.has('ruledOut') then
      iterateArray(jsn.vArr['ruledOut'], result.ruledOutList, parseClinicalImpressionRuledOut);
    if jsn.has('prognosis') or jsn.has('_prognosis') then
        result.prognosisElement := ParseString(jsn['prognosis'], jsn.vObj['_prognosis']);{q}
    if jsn.has('plan') then
      iterateArray(jsn.vArr['plan'], result.planList, parseReference{Resource});
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeClinicalImpression(json : TJSONWriter; name : string; elem : TFhirClinicalImpression; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'assessor', elem.assessor); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirClinicalImpressionStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirClinicalImpressionStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClinicalImpression}(json, 'previous', elem.previous); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.problemList.Count > 0) then
  begin
    json.valueArray('problem');
    for i := 0 to elem.problemList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.problemList[i]); {z - Reference(Condition|AllergyIntolerance)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.trigger is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'triggerCodeableConcept', TFhirCodeableConcept(elem.trigger)) 
  else if (SummaryOption in [soFull, soData]) and (elem.trigger is TFhirReference) then
    ComposeReference(json, 'triggerReference', TFhirReference(elem.trigger));
  if (SummaryOption in [soFull, soData]) and (elem.investigationsList.Count > 0) then
  begin
    json.valueArray('investigations');
    for i := 0 to elem.investigationsList.Count - 1 do
      ComposeClinicalImpressionInvestigations(json, '', elem.investigationsList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'protocol', elem.protocolElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'protocol', elem.protocolElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'summary', elem.summaryElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'summary', elem.summaryElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.findingList.Count > 0) then
  begin
    json.valueArray('finding');
    for i := 0 to elem.findingList.Count - 1 do
      ComposeClinicalImpressionFinding(json, '', elem.findingList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.resolvedList.Count > 0) then
  begin
    json.valueArray('resolved');
    for i := 0 to elem.resolvedList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.resolvedList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.ruledOutList.Count > 0) then
  begin
    json.valueArray('ruledOut');
    for i := 0 to elem.ruledOutList.Count - 1 do
      ComposeClinicalImpressionRuledOut(json, '', elem.ruledOutList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'prognosis', elem.prognosisElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'prognosis', elem.prognosisElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.planList.Count > 0) then
  begin
    json.valueArray('plan');
    for i := 0 to elem.planList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.planList[i]); {z - Reference(CarePlan|Appointment|CommunicationRequest|DeviceUseRequest|DiagnosticOrder|MedicationOrder|NutritionOrder|Order|ProcedureRequest|ProcessRequest|ReferralRequest|SupplyRequest|VisionPrescription)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.actionList[i]); {z - Reference(ReferralRequest|ProcedureRequest|Procedure|MedicationOrder|DiagnosticOrder|NutritionOrder|SupplyRequest|Appointment)}
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeClinicalImpression(parent :  TRDFComplex; parentType, name : String; elem : TFhirClinicalImpression; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ClinicalImpression');
  end;
  composeDomainResource(this, 'ClinicalImpression', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'ClinicalImpression', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'ClinicalImpression', 'assessor', elem.assessorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ClinicalImpression', 'status', elem.StatusElement, CODES_TFhirClinicalImpressionStatusEnum, SYSTEMS_TFhirClinicalImpressionStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ClinicalImpression', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ClinicalImpression', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClinicalImpression}(this, 'ClinicalImpression', 'previous', elem.previousElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.problemList.Count - 1 do
      ComposeReference{Resource}(this, 'ClinicalImpression', 'problem', elem.problemList[i], i);
  if (SummaryOption in [soFull, soData]) and (elem.trigger is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ClinicalImpression', 'triggerCodeableConcept', TFhirCodeableConcept(elem.trigger), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.trigger is TFhirReference) {2} then
    ComposeReference(this, 'ClinicalImpression', 'triggerReference', TFhirReference(elem.trigger), -1);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.investigationsList.Count - 1 do
      ComposeClinicalImpressionInvestigations(this, 'ClinicalImpression', 'investigations', elem.investigationsList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ClinicalImpression', 'protocol', elem.protocolElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ClinicalImpression', 'summary', elem.summaryElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.findingList.Count - 1 do
      ComposeClinicalImpressionFinding(this, 'ClinicalImpression', 'finding', elem.findingList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.resolvedList.Count - 1 do
      ComposeCodeableConcept(this, 'ClinicalImpression', 'resolved', elem.resolvedList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.ruledOutList.Count - 1 do
      ComposeClinicalImpressionRuledOut(this, 'ClinicalImpression', 'ruledOut', elem.ruledOutList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ClinicalImpression', 'prognosis', elem.prognosisElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.planList.Count - 1 do
      ComposeReference{Resource}(this, 'ClinicalImpression', 'plan', elem.planList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeReference{Resource}(this, 'ClinicalImpression', 'action', elem.actionList[i], i);
end;

function TFHIRXmlParser.ParseCommunicationPayload(element : IXmlDomElement; path : string) : TFhirCommunicationPayload;
var
  child : IXMLDOMElement;
begin
  result := TFhirCommunicationPayload.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'contentString') then
        result.content := ParseString(child, path+'/contentString'){x.3}
      else if (child.baseName = 'contentAttachment') then
        result.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.baseName = 'contentReference') then
        result.content := ParseReference(child, path+'/contentReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCommunicationPayload(xml : TXmlBuilder; name : string; elem : TFhirCommunicationPayload);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirString) {6} then
    ComposeString(xml, 'contentString', TFhirString(elem.content))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCommunicationPayload(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCommunicationPayload(jsn)); {2}
end;

function TFHIRJsonParser.ParseCommunicationPayload(jsn : TJsonObject) : TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentString') or jsn.has('_contentString') then
      result.content := parseString(jsn['contentString'], jsn.vObj['_contentString']);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCommunicationPayload(json : TJSONWriter; name : string; elem : TFhirCommunicationPayload; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirString) then 
  begin
    ComposeStringValue(json, 'contentString', TFhirString(elem.content), false);
    ComposeStringProps(json, 'contentString', TFhirString(elem.content), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content));
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeCommunicationPayload(parent :  TRDFComplex; parentType, name : String; elem : TFhirCommunicationPayload; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:CommunicationPayload');
  end;
  composeBackboneElement(this, 'CommunicationPayload', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirString) {6} then
    ComposeString(this, 'CommunicationPayload', 'contentString', TFhirString(elem.content), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'CommunicationPayload', 'contentAttachment', TFhirAttachment(elem.content), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'CommunicationPayload', 'contentReference', TFhirReference(elem.content), -1);
end;

function TFHIRXmlParser.ParseCommunication(element : IXmlDomElement; path : string) : TFhirCommunication;
var
  child : IXMLDOMElement;
begin
  result := TFhirCommunication.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'sender') then
        result.sender := ParseReference{Resource}(child, path+'/sender') {b}
      else if (child.baseName = 'recipient') then
        result.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.baseName = 'payload') then
        result.payloadList.Add(ParseCommunicationPayload(child, path+'/payload')){y.2}
      else if (child.baseName = 'medium') then
        result.mediumList.Add(ParseCodeableConcept(child, path+'/medium')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirCommunicationStatusEnum, SYSTEMS_TFhirCommunicationStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'sent') then
        result.sentElement := ParseDateTime(child, path+'/sent') {b}
      else if (child.baseName = 'received') then
        result.receivedElement := ParseDateTime(child, path+'/received') {b}
      else if (child.baseName = 'reason') then
        result.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'requestDetail') then
        result.requestDetail := ParseReference{TFhirCommunicationRequest}(child, path+'/requestDetail') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCommunication(xml : TXmlBuilder; name : string; elem : TFhirCommunication);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'sender', elem.sender);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationPayload(xml, 'payload', elem.payloadList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(xml, 'medium', elem.mediumList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCommunicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'sent', elem.sentElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'received', elem.receivedElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirCommunicationRequest}(xml, 'requestDetail', elem.requestDetail);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCommunication(jsn)); {2}
end;

function TFHIRJsonParser.ParseCommunication(jsn : TJsonObject) : TFhirCommunication;
begin
  result := TFhirCommunication.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('sender') then
        result.sender := ParseReference{Resource}(jsn.vObj['sender']);{q}
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{Resource});
    if jsn.has('payload') then
      iterateArray(jsn.vArr['payload'], result.payloadList, parseCommunicationPayload);
    if jsn.has('medium') then
      iterateArray(jsn.vArr['medium'], result.mediumList, parseCodeableConcept);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirCommunicationStatusEnum, SYSTEMS_TFhirCommunicationStatusEnum);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('sent') or jsn.has('_sent') then
        result.sentElement := ParseDateTime(jsn['sent'], jsn.vObj['_sent']);{q}
    if jsn.has('received') or jsn.has('_received') then
        result.receivedElement := ParseDateTime(jsn['received'], jsn.vObj['_received']);{q}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('requestDetail') then
        result.requestDetail := ParseReference{TFhirCommunicationRequest}(jsn.vObj['requestDetail']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCommunication(json : TJSONWriter; name : string; elem : TFhirCommunication; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'sender', elem.sender); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.recipientList.Count > 0) then
  begin
    json.valueArray('recipient');
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.recipientList[i]); {z - Reference(Device|Organization|Patient|Practitioner|RelatedPerson|Group)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.payloadList.Count > 0) then
  begin
    json.valueArray('payload');
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationPayload(json, '', elem.payloadList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.mediumList.Count > 0) then
  begin
    json.valueArray('medium');
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.mediumList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCommunicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCommunicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'sent', elem.sentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'sent', elem.sentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'received', elem.receivedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'received', elem.receivedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonList.Count > 0) then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirCommunicationRequest}(json, 'requestDetail', elem.requestDetail); {a}
end;

procedure TFHIRRDFComposer.ComposeCommunication(parent :  TRDFComplex; parentType, name : String; elem : TFhirCommunication; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Communication');
  end;
  composeDomainResource(this, 'Communication', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Communication', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Communication', 'category', elem.categoryElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Communication', 'sender', elem.senderElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(this, 'Communication', 'recipient', elem.recipientList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationPayload(this, 'Communication', 'payload', elem.payloadList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(this, 'Communication', 'medium', elem.mediumList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Communication', 'status', elem.StatusElement, CODES_TFhirCommunicationStatusEnum, SYSTEMS_TFhirCommunicationStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'Communication', 'encounter', elem.encounterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Communication', 'sent', elem.sentElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Communication', 'received', elem.receivedElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Communication', 'reason', elem.reasonList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'Communication', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirCommunicationRequest}(this, 'Communication', 'requestDetail', elem.requestDetailElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseCommunicationRequestPayload(element : IXmlDomElement; path : string) : TFhirCommunicationRequestPayload;
var
  child : IXMLDOMElement;
begin
  result := TFhirCommunicationRequestPayload.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'contentString') then
        result.content := ParseString(child, path+'/contentString'){x.3}
      else if (child.baseName = 'contentAttachment') then
        result.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.baseName = 'contentReference') then
        result.content := ParseReference(child, path+'/contentReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequestPayload(xml : TXmlBuilder; name : string; elem : TFhirCommunicationRequestPayload);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirString) {6} then
    ComposeString(xml, 'contentString', TFhirString(elem.content))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCommunicationRequestPayload(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCommunicationRequestPayload(jsn)); {2}
end;

function TFHIRJsonParser.ParseCommunicationRequestPayload(jsn : TJsonObject) : TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentString') or jsn.has('_contentString') then
      result.content := parseString(jsn['contentString'], jsn.vObj['_contentString']);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCommunicationRequestPayload(json : TJSONWriter; name : string; elem : TFhirCommunicationRequestPayload; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirString) then 
  begin
    ComposeStringValue(json, 'contentString', TFhirString(elem.content), false);
    ComposeStringProps(json, 'contentString', TFhirString(elem.content), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content));
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeCommunicationRequestPayload(parent :  TRDFComplex; parentType, name : String; elem : TFhirCommunicationRequestPayload; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:CommunicationRequestPayload');
  end;
  composeBackboneElement(this, 'CommunicationRequestPayload', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirString) {6} then
    ComposeString(this, 'CommunicationRequestPayload', 'contentString', TFhirString(elem.content), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'CommunicationRequestPayload', 'contentAttachment', TFhirAttachment(elem.content), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'CommunicationRequestPayload', 'contentReference', TFhirReference(elem.content), -1);
end;

function TFHIRXmlParser.ParseCommunicationRequest(element : IXmlDomElement; path : string) : TFhirCommunicationRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirCommunicationRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'sender') then
        result.sender := ParseReference{Resource}(child, path+'/sender') {b}
      else if (child.baseName = 'recipient') then
        result.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.baseName = 'payload') then
        result.payloadList.Add(ParseCommunicationRequestPayload(child, path+'/payload')){y.2}
      else if (child.baseName = 'medium') then
        result.mediumList.Add(ParseCodeableConcept(child, path+'/medium')){y.2}
      else if (child.baseName = 'requester') then
        result.requester := ParseReference{Resource}(child, path+'/requester') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirCommunicationRequestStatusEnum, SYSTEMS_TFhirCommunicationRequestStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'scheduledDateTime') then
        result.scheduled := ParseDateTime(child, path+'/scheduledDateTime'){x.3}
      else if (child.baseName = 'scheduledPeriod') then
        result.scheduled := ParsePeriod(child, path+'/scheduledPeriod'){x.3}
      else if (child.baseName = 'reason') then
        result.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.baseName = 'requestedOn') then
        result.requestedOnElement := ParseDateTime(child, path+'/requestedOn') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'priority') then
        result.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequest(xml : TXmlBuilder; name : string; elem : TFhirCommunicationRequest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'sender', elem.sender);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationRequestPayload(xml, 'payload', elem.payloadList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(xml, 'medium', elem.mediumList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'requester', elem.requester);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCommunicationRequestStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'scheduledDateTime', TFhirDateTime(elem.scheduled))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(xml, 'scheduledPeriod', TFhirPeriod(elem.scheduled));
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'requestedOn', elem.requestedOnElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCommunicationRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCommunicationRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseCommunicationRequest(jsn : TJsonObject) : TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('sender') then
        result.sender := ParseReference{Resource}(jsn.vObj['sender']);{q}
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{Resource});
    if jsn.has('payload') then
      iterateArray(jsn.vArr['payload'], result.payloadList, parseCommunicationRequestPayload);
    if jsn.has('medium') then
      iterateArray(jsn.vArr['medium'], result.mediumList, parseCodeableConcept);
    if jsn.has('requester') then
        result.requester := ParseReference{Resource}(jsn.vObj['requester']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirCommunicationRequestStatusEnum, SYSTEMS_TFhirCommunicationRequestStatusEnum);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('scheduledDateTime') or jsn.has('_scheduledDateTime') then
      result.scheduled := parseDateTime(jsn['scheduledDateTime'], jsn.vObj['_scheduledDateTime']);
    if jsn.has('scheduledPeriod') {a4} then
      result.scheduled := ParsePeriod(jsn.vObj['scheduledPeriod']);
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('requestedOn') or jsn.has('_requestedOn') then
        result.requestedOnElement := ParseDateTime(jsn['requestedOn'], jsn.vObj['_requestedOn']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCommunicationRequest(json : TJSONWriter; name : string; elem : TFhirCommunicationRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'sender', elem.sender); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.recipientList.Count > 0) then
  begin
    json.valueArray('recipient');
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.recipientList[i]); {z - Reference(Device|Organization|Patient|Practitioner|RelatedPerson)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.payloadList.Count > 0) then
  begin
    json.valueArray('payload');
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationRequestPayload(json, '', elem.payloadList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.mediumList.Count > 0) then
  begin
    json.valueArray('medium');
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.mediumList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'requester', elem.requester); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCommunicationRequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCommunicationRequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'scheduledDateTime', TFhirDateTime(elem.scheduled), false);
    ComposeDateTimeProps(json, 'scheduledDateTime', TFhirDateTime(elem.scheduled), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirPeriod) then 
    ComposePeriod(json, 'scheduledPeriod', TFhirPeriod(elem.scheduled)) ;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonList.Count > 0) then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'requestedOn', elem.requestedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'requestedOn', elem.requestedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'priority', elem.priority); {a}
end;

procedure TFHIRRDFComposer.ComposeCommunicationRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirCommunicationRequest; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:CommunicationRequest');
  end;
  composeDomainResource(this, 'CommunicationRequest', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CommunicationRequest', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'CommunicationRequest', 'category', elem.categoryElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'CommunicationRequest', 'sender', elem.senderElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(this, 'CommunicationRequest', 'recipient', elem.recipientList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationRequestPayload(this, 'CommunicationRequest', 'payload', elem.payloadList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(this, 'CommunicationRequest', 'medium', elem.mediumList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'CommunicationRequest', 'requester', elem.requesterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'CommunicationRequest', 'status', elem.StatusElement, CODES_TFhirCommunicationRequestStatusEnum, SYSTEMS_TFhirCommunicationRequestStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'CommunicationRequest', 'encounter', elem.encounterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirDateTime) {6} then
    ComposeDateTime(this, 'CommunicationRequest', 'scheduledDateTime', TFhirDateTime(elem.scheduled), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(this, 'CommunicationRequest', 'scheduledPeriod', TFhirPeriod(elem.scheduled), -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'CommunicationRequest', 'reason', elem.reasonList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'CommunicationRequest', 'requestedOn', elem.requestedOnElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'CommunicationRequest', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'CommunicationRequest', 'priority', elem.priorityElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseCompositionAttester(element : IXmlDomElement; path : string) : TFhirCompositionAttester;
var
  child : IXMLDOMElement;
begin
  result := TFhirCompositionAttester.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'mode') then
        result.modeList.Add(ParseEnum(CODES_TFhirCompositionAttestationModeEnum, SYSTEMS_TFhirCompositionAttestationModeEnum, path+'/mode', child)){y.1}
      else if (child.baseName = 'time') then
        result.timeElement := ParseDateTime(child, path+'/time') {b}
      else if (child.baseName = 'party') then
        result.party := ParseReference{Resource}(child, path+'/party') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCompositionAttester(xml : TXmlBuilder; name : string; elem : TFhirCompositionAttester);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.modeList.Count - 1 do
      ComposeEnum(xml, 'mode', elem.modeList[i], CODES_TFhirCompositionAttestationModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'time', elem.timeElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'party', elem.party);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCompositionAttester(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionAttester(jsn)); {2}
end;

function TFHIRJsonParser.ParseCompositionAttester(jsn : TJsonObject) : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode') then
      iterateEnumArray(jsn.vArr['mode'], jsn.vArr['_mode'], jsn.path+'/mode', result.modeList, parseEnum, CODES_TFhirCompositionAttestationModeEnum, SYSTEMS_TFhirCompositionAttestationModeEnum);
    if jsn.has('time') or jsn.has('_time') then
        result.timeElement := ParseDateTime(jsn['time'], jsn.vObj['_time']);{q}
    if jsn.has('party') then
        result.party := ParseReference{Resource}(jsn.vObj['party']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCompositionAttester(json : TJSONWriter; name : string; elem : TFhirCompositionAttester; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.modeList.Count > 0) then
  begin
    json.valueArray('mode');
    ext := false;
    for i := 0 to elem.modeList.Count - 1 do
    begin
      ext := ext or ((elem.modeList[i].id <> '') or (elem.modeList[i].hasExtensionList));
      ComposeEnumValue(json, '', elem.modeList[i], CODES_TFhirCompositionAttestationModeEnum, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_mode');
      for i := 0 to elem.modeList.Count - 1 do
        ComposeEnumProps(json, '', elem.modeList[i], CODES_TFhirCompositionAttestationModeEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'time', elem.timeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'time', elem.timeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'party', elem.party); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeCompositionAttester(parent :  TRDFComplex; parentType, name : String; elem : TFhirCompositionAttester; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:CompositionAttester');
  end;
  composeBackboneElement(this, 'CompositionAttester', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.modeList.Count - 1 do
      ComposeEnum(this, 'CompositionAttester', 'mode', elem.modeList[i], CODES_TFhirCompositionAttestationModeEnum, SYSTEMS_TFhirCompositionAttestationModeEnum, i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.modeList.Count - 1 do
      ComposeEnum(this, 'CompositionAttester', 'mode', elem.modeList[i], CODES_TFhirCompositionAttestationModeEnum, SYSTEMS_TFhirCompositionAttestationModeEnum, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'CompositionAttester', 'time', elem.timeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'CompositionAttester', 'party', elem.partyElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseCompositionEvent(element : IXmlDomElement; path : string) : TFhirCompositionEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirCompositionEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeList.Add(ParseCodeableConcept(child, path+'/code')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseReference{TFhirReference}(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCompositionEvent(xml : TXmlBuilder; name : string; elem : TFhirCompositionEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(xml, 'code', elem.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCompositionEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseCompositionEvent(jsn : TJsonObject) : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCompositionEvent(json : TJSONWriter; name : string; elem : TFhirCompositionEvent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.codeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.detailList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeCompositionEvent(parent :  TRDFComplex; parentType, name : String; elem : TFhirCompositionEvent; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:CompositionEvent');
  end;
  composeBackboneElement(this, 'CompositionEvent', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'CompositionEvent', 'code', elem.codeList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'CompositionEvent', 'period', elem.periodElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'CompositionEvent', 'detail', elem.detailList[i], i);
end;

function TFHIRXmlParser.ParseCompositionSection(element : IXmlDomElement; path : string) : TFhirCompositionSection;
var
  child : IXMLDOMElement;
begin
  result := TFhirCompositionSection.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'title') then
        result.titleElement := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'text') then
        result.text := ParseNarrative(child, path+'/text') {b}
      else if (child.baseName = 'mode') then
        result.modeElement := ParseEnum(CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, path+'/mode', child){1a}
      else if (child.baseName = 'orderedBy') then
        result.orderedBy := ParseCodeableConcept(child, path+'/orderedBy') {b}
      else if (child.baseName = 'entry') then
        result.entryList.Add(ParseReference{TFhirReference}(child, path+'/entry')){y.2}
      else if (child.baseName = 'emptyReason') then
        result.emptyReason := ParseCodeableConcept(child, path+'/emptyReason') {b}
      else if (child.baseName = 'section') then
        result.sectionList.Add(ParseCompositionSection(child, path+'/section')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCompositionSection(xml : TXmlBuilder; name : string; elem : TFhirCompositionSection);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', elem.titleElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeNarrative(xml, 'text', elem.text);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirListModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'orderedBy', elem.orderedBy);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'entry', elem.entryList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'emptyReason', elem.emptyReason);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(xml, 'section', elem.sectionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCompositionSection(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionSection(jsn)); {2}
end;

function TFHIRJsonParser.ParseCompositionSection(jsn : TJsonObject) : TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('text') then
        result.text := ParseNarrative(jsn.vObj['text']);{q}
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn['mode'], jsn.vObj['_mode'], CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum);
    if jsn.has('orderedBy') then
        result.orderedBy := ParseCodeableConcept(jsn.vObj['orderedBy']);{q}
    if jsn.has('entry') then
      iterateArray(jsn.vArr['entry'], result.entryList, parseReference{TFhirReference});
    if jsn.has('emptyReason') then
        result.emptyReason := ParseCodeableConcept(jsn.vObj['emptyReason']);{q}
    if jsn.has('section') then
      iterateArray(jsn.vArr['section'], result.sectionList, parseCompositionSection);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCompositionSection(json : TJSONWriter; name : string; elem : TFhirCompositionSection; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeNarrative(json, 'text', elem.text); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirListModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirListModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'orderedBy', elem.orderedBy); {a}
  if (SummaryOption in [soFull, soData]) and (elem.entryList.Count > 0) then
  begin
    json.valueArray('entry');
    for i := 0 to elem.entryList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.entryList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'emptyReason', elem.emptyReason); {a}
  if (SummaryOption in [soFull, soData]) and (elem.sectionList.Count > 0) then
  begin
    json.valueArray('section');
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(json, '', elem.sectionList[i]); {z - @Composition.section}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeCompositionSection(parent :  TRDFComplex; parentType, name : String; elem : TFhirCompositionSection; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:CompositionSection');
  end;
  composeBackboneElement(this, 'CompositionSection', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CompositionSection', 'title', elem.titleElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CompositionSection', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeNarrative(this, 'CompositionSection', 'text', elem.textElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'CompositionSection', 'mode', elem.ModeElement, CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CompositionSection', 'orderedBy', elem.orderedByElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'CompositionSection', 'entry', elem.entryList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CompositionSection', 'emptyReason', elem.emptyReasonElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(this, 'CompositionSection', 'section', elem.sectionList[i], i);
end;

function TFHIRXmlParser.ParseComposition(element : IXmlDomElement; path : string) : TFhirComposition;
var
  child : IXMLDOMElement;
begin
  result := TFhirComposition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'class') then
        result.class_ := ParseCodeableConcept(child, path+'/class') {b}
      else if (child.baseName = 'title') then
        result.titleElement := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'confidentiality') then
        result.confidentialityElement := ParseEnum(CODES_TFhirV3ConfidentialityEnum, SYSTEMS_TFhirV3ConfidentialityEnum, path+'/confidentiality', child){1a}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.baseName = 'author') then
        result.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.baseName = 'attester') then
        result.attesterList.Add(ParseCompositionAttester(child, path+'/attester')){y.2}
      else if (child.baseName = 'custodian') then
        result.custodian := ParseReference{TFhirOrganization}(child, path+'/custodian') {b}
      else if (child.baseName = 'event') then
        result.eventList.Add(ParseCompositionEvent(child, path+'/event')){y.2}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'section') then
        result.sectionList.Add(ParseCompositionSection(child, path+'/section')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeComposition(xml : TXmlBuilder; name : string; elem : TFhirComposition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'class', elem.class_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', elem.titleElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCompositionStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'confidentiality', elem.ConfidentialityElement, CODES_TFhirV3ConfidentialityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.attesterList.Count - 1 do
      ComposeCompositionAttester(xml, 'attester', elem.attesterList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'custodian', elem.custodian);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCompositionEvent(xml, 'event', elem.eventList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(xml, 'section', elem.sectionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseComposition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseComposition(jsn)); {2}
end;

function TFHIRJsonParser.ParseComposition(jsn : TJsonObject) : TFhirComposition;
begin
  result := TFhirComposition.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('class') then
        result.class_ := ParseCodeableConcept(jsn.vObj['class']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum);
    if jsn.has('confidentiality') or jsn.has('_confidentiality')  then
      result.confidentialityElement := parseEnum(jsn.path+'/confidentiality', jsn['confidentiality'], jsn.vObj['_confidentiality'], CODES_TFhirV3ConfidentialityEnum, SYSTEMS_TFhirV3ConfidentialityEnum);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{Resource});
    if jsn.has('attester') then
      iterateArray(jsn.vArr['attester'], result.attesterList, parseCompositionAttester);
    if jsn.has('custodian') then
        result.custodian := ParseReference{TFhirOrganization}(jsn.vObj['custodian']);{q}
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseCompositionEvent);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('section') then
      iterateArray(jsn.vArr['section'], result.sectionList, parseCompositionSection);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeComposition(json : TJSONWriter; name : string; elem : TFhirComposition; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'class', elem.class_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCompositionStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCompositionStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'confidentiality', elem.ConfidentialityElement, CODES_TFhirV3ConfidentialityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'confidentiality', elem.ConfidentialityElement, CODES_TFhirV3ConfidentialityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.authorList[i]); {z - Reference(Practitioner|Device|Patient|RelatedPerson)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.attesterList.Count > 0) then
  begin
    json.valueArray('attester');
    for i := 0 to elem.attesterList.Count - 1 do
      ComposeCompositionAttester(json, '', elem.attesterList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'custodian', elem.custodian); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.eventList.Count > 0) then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCompositionEvent(json, '', elem.eventList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soData]) and (elem.sectionList.Count > 0) then
  begin
    json.valueArray('section');
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(json, '', elem.sectionList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeComposition(parent :  TRDFComplex; parentType, name : String; elem : TFhirComposition; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Composition');
  end;
  composeDomainResource(this, 'Composition', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Composition', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Composition', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Composition', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Composition', 'class', elem.class_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Composition', 'title', elem.titleElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Composition', 'status', elem.StatusElement, CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Composition', 'confidentiality', elem.ConfidentialityElement, CODES_TFhirV3ConfidentialityEnum, SYSTEMS_TFhirV3ConfidentialityEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'Composition', 'subject', elem.subjectElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(this, 'Composition', 'author', elem.authorList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.attesterList.Count - 1 do
      ComposeCompositionAttester(this, 'Composition', 'attester', elem.attesterList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Composition', 'custodian', elem.custodianElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCompositionEvent(this, 'Composition', 'event', elem.eventList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'Composition', 'encounter', elem.encounterElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(this, 'Composition', 'section', elem.sectionList[i], i);
end;

function TFHIRXmlParser.ParseConceptMapContact(element : IXmlDomElement; path : string) : TFhirConceptMapContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMapContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMapContact(xml : TXmlBuilder; name : string; elem : TFhirConceptMapContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMapContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMapContact(jsn : TJsonObject) : TFhirConceptMapContact;
begin
  result := TFhirConceptMapContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMapContact(json : TJSONWriter; name : string; elem : TFhirConceptMapContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConceptMapContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirConceptMapContact; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConceptMapContact');
  end;
  composeBackboneElement(this, 'ConceptMapContact', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConceptMapContact', 'name', elem.nameElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'ConceptMapContact', 'telecom', elem.telecomList[i], i);
end;

function TFHIRXmlParser.ParseConceptMapElement(element : IXmlDomElement; path : string) : TFhirConceptMapElement;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMapElement.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'codeSystem') then
        result.codeSystemElement := ParseUri(child, path+'/codeSystem') {b}
      else if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'target') then
        result.targetList.Add(ParseConceptMapElementTarget(child, path+'/target')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMapElement(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'codeSystem', elem.codeSystemElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.targetList.Count - 1 do
      ComposeConceptMapElementTarget(xml, 'target', elem.targetList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMapElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapElement(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMapElement(jsn : TJsonObject) : TFhirConceptMapElement;
begin
  result := TFhirConceptMapElement.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('codeSystem') or jsn.has('_codeSystem') then
        result.codeSystemElement := ParseUri(jsn['codeSystem'], jsn.vObj['_codeSystem']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('target') then
      iterateArray(jsn.vArr['target'], result.targetList, parseConceptMapElementTarget);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMapElement(json : TJSONWriter; name : string; elem : TFhirConceptMapElement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'codeSystem', elem.codeSystemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'codeSystem', elem.codeSystemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.targetList.Count > 0) then
  begin
    json.valueArray('target');
    for i := 0 to elem.targetList.Count - 1 do
      ComposeConceptMapElementTarget(json, '', elem.targetList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConceptMapElement(parent :  TRDFComplex; parentType, name : String; elem : TFhirConceptMapElement; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConceptMapElement');
  end;
  composeBackboneElement(this, 'ConceptMapElement', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ConceptMapElement', 'codeSystem', elem.codeSystemElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ConceptMapElement', 'code', elem.codeElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.targetList.Count - 1 do
      ComposeConceptMapElementTarget(this, 'ConceptMapElement', 'target', elem.targetList[i], i);
end;

function TFHIRXmlParser.ParseConceptMapElementTarget(element : IXmlDomElement; path : string) : TFhirConceptMapElementTarget;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMapElementTarget.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'codeSystem') then
        result.codeSystemElement := ParseUri(child, path+'/codeSystem') {b}
      else if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'equivalence') then
        result.equivalenceElement := ParseEnum(CODES_TFhirConceptMapEquivalenceEnum, SYSTEMS_TFhirConceptMapEquivalenceEnum, path+'/equivalence', child){1a}
      else if (child.baseName = 'comments') then
        result.commentsElement := ParseString(child, path+'/comments') {b}
      else if (child.baseName = 'dependsOn') then
        result.dependsOnList.Add(ParseConceptMapElementTargetDependsOn(child, path+'/dependsOn')){y.2}
      else if (child.baseName = 'product') then
        result.productList.Add(ParseConceptMapElementTargetDependsOn(child, path+'/product')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMapElementTarget(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElementTarget);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'codeSystem', elem.codeSystemElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'equivalence', elem.EquivalenceElement, CODES_TFhirConceptMapEquivalenceEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comments', elem.commentsElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.dependsOnList.Count - 1 do
      ComposeConceptMapElementTargetDependsOn(xml, 'dependsOn', elem.dependsOnList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.productList.Count - 1 do
      ComposeConceptMapElementTargetDependsOn(xml, 'product', elem.productList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMapElementTarget(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapElementTarget(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMapElementTarget(jsn : TJsonObject) : TFhirConceptMapElementTarget;
begin
  result := TFhirConceptMapElementTarget.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('codeSystem') or jsn.has('_codeSystem') then
        result.codeSystemElement := ParseUri(jsn['codeSystem'], jsn.vObj['_codeSystem']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('equivalence') or jsn.has('_equivalence')  then
      result.equivalenceElement := parseEnum(jsn.path+'/equivalence', jsn['equivalence'], jsn.vObj['_equivalence'], CODES_TFhirConceptMapEquivalenceEnum, SYSTEMS_TFhirConceptMapEquivalenceEnum);
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsElement := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    if jsn.has('dependsOn') then
      iterateArray(jsn.vArr['dependsOn'], result.dependsOnList, parseConceptMapElementTargetDependsOn);
    if jsn.has('product') then
      iterateArray(jsn.vArr['product'], result.productList, parseConceptMapElementTargetDependsOn);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMapElementTarget(json : TJSONWriter; name : string; elem : TFhirConceptMapElementTarget; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'codeSystem', elem.codeSystemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'codeSystem', elem.codeSystemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'equivalence', elem.EquivalenceElement, CODES_TFhirConceptMapEquivalenceEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'equivalence', elem.EquivalenceElement, CODES_TFhirConceptMapEquivalenceEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comments', elem.commentsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comments', elem.commentsElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.dependsOnList.Count > 0) then
  begin
    json.valueArray('dependsOn');
    for i := 0 to elem.dependsOnList.Count - 1 do
      ComposeConceptMapElementTargetDependsOn(json, '', elem.dependsOnList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.productList.Count > 0) then
  begin
    json.valueArray('product');
    for i := 0 to elem.productList.Count - 1 do
      ComposeConceptMapElementTargetDependsOn(json, '', elem.productList[i]); {z - @ConceptMap.element.target.dependsOn}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConceptMapElementTarget(parent :  TRDFComplex; parentType, name : String; elem : TFhirConceptMapElementTarget; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConceptMapElementTarget');
  end;
  composeBackboneElement(this, 'ConceptMapElementTarget', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ConceptMapElementTarget', 'codeSystem', elem.codeSystemElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ConceptMapElementTarget', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'ConceptMapElementTarget', 'equivalence', elem.EquivalenceElement, CODES_TFhirConceptMapEquivalenceEnum, SYSTEMS_TFhirConceptMapEquivalenceEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMapElementTarget', 'comments', elem.commentsElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.dependsOnList.Count - 1 do
      ComposeConceptMapElementTargetDependsOn(this, 'ConceptMapElementTarget', 'dependsOn', elem.dependsOnList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.productList.Count - 1 do
      ComposeConceptMapElementTargetDependsOn(this, 'ConceptMapElementTarget', 'product', elem.productList[i], i);
end;

function TFHIRXmlParser.ParseConceptMapElementTargetDependsOn(element : IXmlDomElement; path : string) : TFhirConceptMapElementTargetDependsOn;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMapElementTargetDependsOn.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'element') then
        result.elementElement := ParseUri(child, path+'/element') {b}
      else if (child.baseName = 'codeSystem') then
        result.codeSystemElement := ParseUri(child, path+'/codeSystem') {b}
      else if (child.baseName = 'code') then
        result.codeElement := ParseString(child, path+'/code') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMapElementTargetDependsOn(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElementTargetDependsOn);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'element', elem.elementElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'codeSystem', elem.codeSystemElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'code', elem.codeElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMapElementTargetDependsOn(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapElementTargetDependsOn(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMapElementTargetDependsOn(jsn : TJsonObject) : TFhirConceptMapElementTargetDependsOn;
begin
  result := TFhirConceptMapElementTargetDependsOn.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('element') or jsn.has('_element') then
        result.elementElement := ParseUri(jsn['element'], jsn.vObj['_element']);{q}
    if jsn.has('codeSystem') or jsn.has('_codeSystem') then
        result.codeSystemElement := ParseUri(jsn['codeSystem'], jsn.vObj['_codeSystem']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseString(jsn['code'], jsn.vObj['_code']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMapElementTargetDependsOn(json : TJSONWriter; name : string; elem : TFhirConceptMapElementTargetDependsOn; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'element', elem.elementElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'element', elem.elementElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'codeSystem', elem.codeSystemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'codeSystem', elem.codeSystemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'code', elem.codeElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConceptMapElementTargetDependsOn(parent :  TRDFComplex; parentType, name : String; elem : TFhirConceptMapElementTargetDependsOn; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConceptMapElementTargetDependsOn');
  end;
  composeBackboneElement(this, 'ConceptMapElementTargetDependsOn', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ConceptMapElementTargetDependsOn', 'element', elem.elementElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ConceptMapElementTargetDependsOn', 'codeSystem', elem.codeSystemElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMapElementTargetDependsOn', 'code', elem.codeElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseConceptMap(element : IXmlDomElement; path : string) : TFhirConceptMap;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMap.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseConceptMapContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'useContext') then
        result.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.baseName = 'requirements') then
        result.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'copyright') then
        result.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.baseName = 'sourceUri') then
        result.source := ParseUri(child, path+'/sourceUri'){x.3}
      else if (child.baseName = 'sourceReference') then
        result.source := ParseReference(child, path+'/sourceReference') {a}
      else if (child.baseName = 'targetUri') then
        result.target := ParseUri(child, path+'/targetUri'){x.3}
      else if (child.baseName = 'targetReference') then
        result.target := ParseReference(child, path+'/targetReference') {a}
      else if (child.baseName = 'element') then
        result.elementList.Add(ParseConceptMapElement(child, path+'/element')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMap(xml : TXmlBuilder; name : string; elem : TFhirConceptMap);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeConceptMapContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyright', elem.copyrightElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirUri) {6} then
    ComposeUri(xml, 'sourceUri', TFhirUri(elem.source))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirReference) {2} then
    ComposeReference(xml, 'sourceReference', TFhirReference(elem.source));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirUri) {6} then
    ComposeUri(xml, 'targetUri', TFhirUri(elem.target))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirReference) {2} then
    ComposeReference(xml, 'targetReference', TFhirReference(elem.target));
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.elementList.Count - 1 do
      ComposeConceptMapElement(xml, 'element', elem.elementList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMap(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMap(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMap(jsn : TJsonObject) : TFhirConceptMap;
begin
  result := TFhirConceptMap.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseConceptMapContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('sourceUri') or jsn.has('_sourceUri') then
      result.source := parseUri(jsn['sourceUri'], jsn.vObj['_sourceUri']);
    if jsn.has('sourceReference') {a3} then
      result.source := ParseReference(jsn.vObj['sourceReference']);
    if jsn.has('targetUri') or jsn.has('_targetUri') then
      result.target := parseUri(jsn['targetUri'], jsn.vObj['_targetUri']);
    if jsn.has('targetReference') {a3} then
      result.target := ParseReference(jsn.vObj['targetReference']);
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseConceptMapElement);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMap(json : TJSONWriter; name : string; elem : TFhirConceptMap; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeConceptMapContact(json, '', elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.useContextList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirUri) then 
  begin
    ComposeUriValue(json, 'sourceUri', TFhirUri(elem.source), false);
    ComposeUriProps(json, 'sourceUri', TFhirUri(elem.source), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirReference) then
    ComposeReference(json, 'sourceReference', TFhirReference(elem.source));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirUri) then 
  begin
    ComposeUriValue(json, 'targetUri', TFhirUri(elem.target), false);
    ComposeUriProps(json, 'targetUri', TFhirUri(elem.target), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirReference) then
    ComposeReference(json, 'targetReference', TFhirReference(elem.target));
  if (SummaryOption in [soFull, soData]) and (elem.elementList.Count > 0) then
  begin
    json.valueArray('element');
    for i := 0 to elem.elementList.Count - 1 do
      ComposeConceptMapElement(json, '', elem.elementList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeConceptMap(parent :  TRDFComplex; parentType, name : String; elem : TFhirConceptMap; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConceptMap');
  end;
  composeDomainResource(this, 'ConceptMap', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ConceptMap', 'url', elem.urlElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'ConceptMap', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConceptMap', 'version', elem.versionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConceptMap', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ConceptMap', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ConceptMap', 'experimental', elem.experimentalElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConceptMap', 'publisher', elem.publisherElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeConceptMapContact(this, 'ConceptMap', 'contact', elem.contactList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ConceptMap', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConceptMap', 'description', elem.descriptionElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(this, 'ConceptMap', 'useContext', elem.useContextList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap', 'requirements', elem.requirementsElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap', 'copyright', elem.copyrightElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirUri) {6} then
    ComposeUri(this, 'ConceptMap', 'sourceUri', TFhirUri(elem.source), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirReference) {2} then
    ComposeReference(this, 'ConceptMap', 'sourceReference', TFhirReference(elem.source), -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirUri) {6} then
    ComposeUri(this, 'ConceptMap', 'targetUri', TFhirUri(elem.target), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirReference) {2} then
    ComposeReference(this, 'ConceptMap', 'targetReference', TFhirReference(elem.target), -1);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.elementList.Count - 1 do
      ComposeConceptMapElement(this, 'ConceptMap', 'element', elem.elementList[i], i);
end;

function TFHIRXmlParser.ParseConditionStage(element : IXmlDomElement; path : string) : TFhirConditionStage;
var
  child : IXMLDOMElement;
begin
  result := TFhirConditionStage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'summary') then
        result.summary := ParseCodeableConcept(child, path+'/summary') {b}
      else if (child.baseName = 'assessment') then
        result.assessmentList.Add(ParseReference{Resource}(child, path+'/assessment')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConditionStage(xml : TXmlBuilder; name : string; elem : TFhirConditionStage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'summary', elem.summary);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.assessmentList.Count - 1 do
      ComposeReference{Resource}(xml, 'assessment', elem.assessmentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConditionStage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionStage(jsn)); {2}
end;

function TFHIRJsonParser.ParseConditionStage(jsn : TJsonObject) : TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('summary') then
        result.summary := ParseCodeableConcept(jsn.vObj['summary']);{q}
    if jsn.has('assessment') then
      iterateArray(jsn.vArr['assessment'], result.assessmentList, parseReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConditionStage(json : TJSONWriter; name : string; elem : TFhirConditionStage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'summary', elem.summary); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.assessmentList.Count > 0) then
  begin
    json.valueArray('assessment');
    for i := 0 to elem.assessmentList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.assessmentList[i]); {z - Reference(ClinicalImpression|DiagnosticReport|Observation)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConditionStage(parent :  TRDFComplex; parentType, name : String; elem : TFhirConditionStage; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConditionStage');
  end;
  composeBackboneElement(this, 'ConditionStage', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ConditionStage', 'summary', elem.summaryElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.assessmentList.Count - 1 do
      ComposeReference{Resource}(this, 'ConditionStage', 'assessment', elem.assessmentList[i], i);
end;

function TFHIRXmlParser.ParseConditionEvidence(element : IXmlDomElement; path : string) : TFhirConditionEvidence;
var
  child : IXMLDOMElement;
begin
  result := TFhirConditionEvidence.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseReference{TFhirReference}(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConditionEvidence(xml : TXmlBuilder; name : string; elem : TFhirConditionEvidence);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConditionEvidence(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionEvidence(jsn)); {2}
end;

function TFHIRJsonParser.ParseConditionEvidence(jsn : TJsonObject) : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConditionEvidence(json : TJSONWriter; name : string; elem : TFhirConditionEvidence; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.detailList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConditionEvidence(parent :  TRDFComplex; parentType, name : String; elem : TFhirConditionEvidence; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConditionEvidence');
  end;
  composeBackboneElement(this, 'ConditionEvidence', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ConditionEvidence', 'code', elem.codeElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'ConditionEvidence', 'detail', elem.detailList[i], i);
end;

function TFHIRXmlParser.ParseCondition(element : IXmlDomElement; path : string) : TFhirCondition;
var
  child : IXMLDOMElement;
begin
  result := TFhirCondition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'asserter') then
        result.asserter := ParseReference{Resource}(child, path+'/asserter') {b}
      else if (child.baseName = 'dateRecorded') then
        result.dateRecordedElement := ParseDate(child, path+'/dateRecorded') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'clinicalStatus') then
        result.clinicalStatusElement := ParseCode(child, path+'/clinicalStatus') {b}
      else if (child.baseName = 'verificationStatus') then
        result.verificationStatusElement := ParseEnum(CODES_TFhirConditionVerStatusEnum, SYSTEMS_TFhirConditionVerStatusEnum, path+'/verificationStatus', child){1a}
      else if (child.baseName = 'severity') then
        result.severity := ParseCodeableConcept(child, path+'/severity') {b}
      else if (child.baseName = 'onsetDateTime') then
        result.onset := ParseDateTime(child, path+'/onsetDateTime'){x.3}
      else if (child.baseName = 'onsetQuantity') then
        result.onset := ParseQuantity(child, path+'/onsetQuantity'){x.3}
      else if (child.baseName = 'onsetPeriod') then
        result.onset := ParsePeriod(child, path+'/onsetPeriod'){x.3}
      else if (child.baseName = 'onsetRange') then
        result.onset := ParseRange(child, path+'/onsetRange'){x.3}
      else if (child.baseName = 'onsetString') then
        result.onset := ParseString(child, path+'/onsetString'){x.3}
      else if (child.baseName = 'abatementDateTime') then
        result.abatement := ParseDateTime(child, path+'/abatementDateTime'){x.3}
      else if (child.baseName = 'abatementQuantity') then
        result.abatement := ParseQuantity(child, path+'/abatementQuantity'){x.3}
      else if (child.baseName = 'abatementBoolean') then
        result.abatement := ParseBoolean(child, path+'/abatementBoolean'){x.3}
      else if (child.baseName = 'abatementPeriod') then
        result.abatement := ParsePeriod(child, path+'/abatementPeriod'){x.3}
      else if (child.baseName = 'abatementRange') then
        result.abatement := ParseRange(child, path+'/abatementRange'){x.3}
      else if (child.baseName = 'abatementString') then
        result.abatement := ParseString(child, path+'/abatementString'){x.3}
      else if (child.baseName = 'stage') then
        result.stage := ParseConditionStage(child, path+'/stage') {b}
      else if (child.baseName = 'evidence') then
        result.evidenceList.Add(ParseConditionEvidence(child, path+'/evidence')){y.2}
      else if (child.baseName = 'bodySite') then
        result.bodySiteList.Add(ParseCodeableConcept(child, path+'/bodySite')){y.2}
      else if (child.baseName = 'notes') then
        result.notesElement := ParseString(child, path+'/notes') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCondition(xml : TXmlBuilder; name : string; elem : TFhirCondition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'asserter', elem.asserter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'dateRecorded', elem.dateRecordedElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'clinicalStatus', elem.clinicalStatusElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'verificationStatus', elem.VerificationStatusElement, CODES_TFhirConditionVerStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'severity', elem.severity);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'onsetDateTime', TFhirDateTime(elem.onset))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'onsetQuantity', TFhirQuantity(elem.onset))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(xml, 'onsetPeriod', TFhirPeriod(elem.onset))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirRange) {6} then
    ComposeRange(xml, 'onsetRange', TFhirRange(elem.onset))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirString) {6} then
    ComposeString(xml, 'onsetString', TFhirString(elem.onset));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'abatementDateTime', TFhirDateTime(elem.abatement))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'abatementQuantity', TFhirQuantity(elem.abatement))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'abatementBoolean', TFhirBoolean(elem.abatement))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirPeriod) {6} then
    ComposePeriod(xml, 'abatementPeriod', TFhirPeriod(elem.abatement))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirRange) {6} then
    ComposeRange(xml, 'abatementRange', TFhirRange(elem.abatement))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirString) {6} then
    ComposeString(xml, 'abatementString', TFhirString(elem.abatement));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeConditionStage(xml, 'stage', elem.stage);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.evidenceList.Count - 1 do
      ComposeConditionEvidence(xml, 'evidence', elem.evidenceList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'bodySite', elem.bodySiteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'notes', elem.notesElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCondition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCondition(jsn)); {2}
end;

function TFHIRJsonParser.ParseCondition(jsn : TJsonObject) : TFhirCondition;
begin
  result := TFhirCondition.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('asserter') then
        result.asserter := ParseReference{Resource}(jsn.vObj['asserter']);{q}
    if jsn.has('dateRecorded') or jsn.has('_dateRecorded') then
        result.dateRecordedElement := ParseDate(jsn['dateRecorded'], jsn.vObj['_dateRecorded']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('clinicalStatus') or jsn.has('_clinicalStatus') then
        result.clinicalStatusElement := ParseCode(jsn['clinicalStatus'], jsn.vObj['_clinicalStatus']);{q}
    if jsn.has('verificationStatus') or jsn.has('_verificationStatus')  then
      result.verificationStatusElement := parseEnum(jsn.path+'/verificationStatus', jsn['verificationStatus'], jsn.vObj['_verificationStatus'], CODES_TFhirConditionVerStatusEnum, SYSTEMS_TFhirConditionVerStatusEnum);
    if jsn.has('severity') then
        result.severity := ParseCodeableConcept(jsn.vObj['severity']);{q}
    if jsn.has('onsetDateTime') or jsn.has('_onsetDateTime') then
      result.onset := parseDateTime(jsn['onsetDateTime'], jsn.vObj['_onsetDateTime']);
    if jsn.has('onsetQuantity') {a4} then
      result.onset := ParseQuantity(jsn.vObj['onsetQuantity']);
    if jsn.has('onsetPeriod') {a4} then
      result.onset := ParsePeriod(jsn.vObj['onsetPeriod']);
    if jsn.has('onsetRange') {a4} then
      result.onset := ParseRange(jsn.vObj['onsetRange']);
    if jsn.has('onsetString') or jsn.has('_onsetString') then
      result.onset := parseString(jsn['onsetString'], jsn.vObj['_onsetString']);
    if jsn.has('abatementDateTime') or jsn.has('_abatementDateTime') then
      result.abatement := parseDateTime(jsn['abatementDateTime'], jsn.vObj['_abatementDateTime']);
    if jsn.has('abatementQuantity') {a4} then
      result.abatement := ParseQuantity(jsn.vObj['abatementQuantity']);
    if jsn.has('abatementBoolean') or jsn.has('_abatementBoolean') then
      result.abatement := parseBoolean(jsn['abatementBoolean'], jsn.vObj['_abatementBoolean']);
    if jsn.has('abatementPeriod') {a4} then
      result.abatement := ParsePeriod(jsn.vObj['abatementPeriod']);
    if jsn.has('abatementRange') {a4} then
      result.abatement := ParseRange(jsn.vObj['abatementRange']);
    if jsn.has('abatementString') or jsn.has('_abatementString') then
      result.abatement := parseString(jsn['abatementString'], jsn.vObj['_abatementString']);
    if jsn.has('stage') then
        result.stage := ParseConditionStage(jsn.vObj['stage']);{q}
    if jsn.has('evidence') then
      iterateArray(jsn.vArr['evidence'], result.evidenceList, parseConditionEvidence);
    if jsn.has('bodySite') then
      iterateArray(jsn.vArr['bodySite'], result.bodySiteList, parseCodeableConcept);
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesElement := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCondition(json : TJSONWriter; name : string; elem : TFhirCondition; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'asserter', elem.asserter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'dateRecorded', elem.dateRecordedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'dateRecorded', elem.dateRecordedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeValue(json, 'clinicalStatus', elem.clinicalStatusElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeProps(json, 'clinicalStatus', elem.clinicalStatusElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'verificationStatus', elem.VerificationStatusElement, CODES_TFhirConditionVerStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'verificationStatus', elem.VerificationStatusElement, CODES_TFhirConditionVerStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'severity', elem.severity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'onsetDateTime', TFhirDateTime(elem.onset), false);
    ComposeDateTimeProps(json, 'onsetDateTime', TFhirDateTime(elem.onset), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirQuantity) then 
    ComposeQuantity(json, 'onsetQuantity', TFhirQuantity(elem.onset)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirPeriod) then 
    ComposePeriod(json, 'onsetPeriod', TFhirPeriod(elem.onset)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirRange) then 
    ComposeRange(json, 'onsetRange', TFhirRange(elem.onset)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirString) then 
  begin
    ComposeStringValue(json, 'onsetString', TFhirString(elem.onset), false);
    ComposeStringProps(json, 'onsetString', TFhirString(elem.onset), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'abatementDateTime', TFhirDateTime(elem.abatement), false);
    ComposeDateTimeProps(json, 'abatementDateTime', TFhirDateTime(elem.abatement), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirQuantity) then 
    ComposeQuantity(json, 'abatementQuantity', TFhirQuantity(elem.abatement)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'abatementBoolean', TFhirBoolean(elem.abatement), false);
    ComposeBooleanProps(json, 'abatementBoolean', TFhirBoolean(elem.abatement), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirPeriod) then 
    ComposePeriod(json, 'abatementPeriod', TFhirPeriod(elem.abatement)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirRange) then 
    ComposeRange(json, 'abatementRange', TFhirRange(elem.abatement)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirString) then 
  begin
    ComposeStringValue(json, 'abatementString', TFhirString(elem.abatement), false);
    ComposeStringProps(json, 'abatementString', TFhirString(elem.abatement), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeConditionStage(json, 'stage', elem.stage); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.evidenceList.Count > 0) then
  begin
    json.valueArray('evidence');
    for i := 0 to elem.evidenceList.Count - 1 do
      ComposeConditionEvidence(json, '', elem.evidenceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySiteList.Count > 0) then
  begin
    json.valueArray('bodySite');
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.bodySiteList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'notes', elem.notesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'notes', elem.notesElement, false);
end;

procedure TFHIRRDFComposer.ComposeCondition(parent :  TRDFComplex; parentType, name : String; elem : TFhirCondition; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Condition');
  end;
  composeDomainResource(this, 'Condition', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Condition', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'Condition', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'Condition', 'encounter', elem.encounterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Condition', 'asserter', elem.asserterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'Condition', 'dateRecorded', elem.dateRecordedElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Condition', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Condition', 'category', elem.categoryElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'Condition', 'clinicalStatus', elem.clinicalStatusElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Condition', 'verificationStatus', elem.VerificationStatusElement, CODES_TFhirConditionVerStatusEnum, SYSTEMS_TFhirConditionVerStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Condition', 'severity', elem.severityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Condition', 'onsetDateTime', TFhirDateTime(elem.onset), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Condition', 'onsetQuantity', TFhirQuantity(elem.onset), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(this, 'Condition', 'onsetPeriod', TFhirPeriod(elem.onset), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirRange) {6} then
    ComposeRange(this, 'Condition', 'onsetRange', TFhirRange(elem.onset), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirString) {6} then
    ComposeString(this, 'Condition', 'onsetString', TFhirString(elem.onset), -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Condition', 'abatementDateTime', TFhirDateTime(elem.abatement), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Condition', 'abatementQuantity', TFhirQuantity(elem.abatement), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Condition', 'abatementBoolean', TFhirBoolean(elem.abatement), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirPeriod) {6} then
    ComposePeriod(this, 'Condition', 'abatementPeriod', TFhirPeriod(elem.abatement), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirRange) {6} then
    ComposeRange(this, 'Condition', 'abatementRange', TFhirRange(elem.abatement), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirString) {6} then
    ComposeString(this, 'Condition', 'abatementString', TFhirString(elem.abatement), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeConditionStage(this, 'Condition', 'stage', elem.stageElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.evidenceList.Count - 1 do
      ComposeConditionEvidence(this, 'Condition', 'evidence', elem.evidenceList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'Condition', 'bodySite', elem.bodySiteList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Condition', 'notes', elem.notesElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseConformanceContact(element : IXmlDomElement; path : string) : TFhirConformanceContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceContact(xml : TXmlBuilder; name : string; elem : TFhirConformanceContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceContact(jsn : TJsonObject) : TFhirConformanceContact;
begin
  result := TFhirConformanceContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceContact(json : TJSONWriter; name : string; elem : TFhirConformanceContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConformanceContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceContact; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConformanceContact');
  end;
  composeBackboneElement(this, 'ConformanceContact', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConformanceContact', 'name', elem.nameElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'ConformanceContact', 'telecom', elem.telecomList[i], i);
end;

function TFHIRXmlParser.ParseConformanceSoftware(element : IXmlDomElement; path : string) : TFhirConformanceSoftware;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceSoftware.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'releaseDate') then
        result.releaseDateElement := ParseDateTime(child, path+'/releaseDate') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceSoftware(xml : TXmlBuilder; name : string; elem : TFhirConformanceSoftware);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'releaseDate', elem.releaseDateElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceSoftware(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceSoftware(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceSoftware(jsn : TJsonObject) : TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('releaseDate') or jsn.has('_releaseDate') then
        result.releaseDateElement := ParseDateTime(jsn['releaseDate'], jsn.vObj['_releaseDate']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceSoftware(json : TJSONWriter; name : string; elem : TFhirConformanceSoftware; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'releaseDate', elem.releaseDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'releaseDate', elem.releaseDateElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConformanceSoftware(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceSoftware; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConformanceSoftware');
  end;
  composeBackboneElement(this, 'ConformanceSoftware', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConformanceSoftware', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConformanceSoftware', 'version', elem.versionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ConformanceSoftware', 'releaseDate', elem.releaseDateElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseConformanceImplementation(element : IXmlDomElement; path : string) : TFhirConformanceImplementation;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceImplementation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceImplementation(xml : TXmlBuilder; name : string; elem : TFhirConformanceImplementation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceImplementation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceImplementation(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceImplementation(jsn : TJsonObject) : TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceImplementation(json : TJSONWriter; name : string; elem : TFhirConformanceImplementation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConformanceImplementation(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceImplementation; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConformanceImplementation');
  end;
  composeBackboneElement(this, 'ConformanceImplementation', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConformanceImplementation', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ConformanceImplementation', 'url', elem.urlElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseConformanceRest(element : IXmlDomElement; path : string) : TFhirConformanceRest;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRest.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'mode') then
        result.modeElement := ParseEnum(CODES_TFhirRestfulConformanceModeEnum, SYSTEMS_TFhirRestfulConformanceModeEnum, path+'/mode', child){1a}
      else if (child.baseName = 'documentation') then
        result.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'security') then
        result.security := ParseConformanceRestSecurity(child, path+'/security') {b}
      else if (child.baseName = 'resource') then
        result.resourceList.Add(ParseConformanceRestResource(child, path+'/resource')){y.2}
      else if (child.baseName = 'interaction') then
        result.interactionList.Add(ParseConformanceRestInteraction(child, path+'/interaction')){y.2}
      else if (child.baseName = 'transactionMode') then
        result.transactionModeElement := ParseEnum(CODES_TFhirTransactionModeEnum, SYSTEMS_TFhirTransactionModeEnum, path+'/transactionMode', child){1a}
      else if (child.baseName = 'searchParam') then
        result.searchParamList.Add(ParseConformanceRestResourceSearchParam(child, path+'/searchParam')){y.2}
      else if (child.baseName = 'operation') then
        result.operationList.Add(ParseConformanceRestOperation(child, path+'/operation')){y.2}
      else if (child.baseName = 'compartment') then
        result.compartmentList.Add(ParseUri(child, path+'/compartment')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRest(xml : TXmlBuilder; name : string; elem : TFhirConformanceRest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirRestfulConformanceModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeConformanceRestSecurity(xml, 'security', elem.security);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeConformanceRestResource(xml, 'resource', elem.resourceList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeConformanceRestInteraction(xml, 'interaction', elem.interactionList[i]);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'transactionMode', elem.TransactionModeElement, CODES_TFhirTransactionModeEnum);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeConformanceRestResourceSearchParam(xml, 'searchParam', elem.searchParamList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.operationList.Count - 1 do
      ComposeConformanceRestOperation(xml, 'operation', elem.operationList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.compartmentList.Count - 1 do
      ComposeUri(xml, 'compartment', elem.compartmentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRest(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRest(jsn : TJsonObject) : TFhirConformanceRest;
begin
  result := TFhirConformanceRest.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn['mode'], jsn.vObj['_mode'], CODES_TFhirRestfulConformanceModeEnum, SYSTEMS_TFhirRestfulConformanceModeEnum);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('security') then
        result.security := ParseConformanceRestSecurity(jsn.vObj['security']);{q}
    if jsn.has('resource') then
      iterateArray(jsn.vArr['resource'], result.resourceList, parseConformanceRestResource);
    if jsn.has('interaction') then
      iterateArray(jsn.vArr['interaction'], result.interactionList, parseConformanceRestInteraction);
    if jsn.has('transactionMode') or jsn.has('_transactionMode')  then
      result.transactionModeElement := parseEnum(jsn.path+'/transactionMode', jsn['transactionMode'], jsn.vObj['_transactionMode'], CODES_TFhirTransactionModeEnum, SYSTEMS_TFhirTransactionModeEnum);
    if jsn.has('searchParam') then
      iterateArray(jsn.vArr['searchParam'], result.searchParamList, parseConformanceRestResourceSearchParam);
    if jsn.has('operation') then
      iterateArray(jsn.vArr['operation'], result.operationList, parseConformanceRestOperation);
      if jsn.has('compartment') or jsn.has('_compartment') then
      iteratePrimitiveArray(jsn.vArr['compartment'], jsn.vArr['_compartment'], result.compartmentList, parseUri);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRest(json : TJSONWriter; name : string; elem : TFhirConformanceRest; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirRestfulConformanceModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirRestfulConformanceModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeConformanceRestSecurity(json, 'security', elem.security); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.resourceList.Count > 0) then
  begin
    json.valueArray('resource');
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeConformanceRestResource(json, '', elem.resourceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.interactionList.Count > 0) then
  begin
    json.valueArray('interaction');
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeConformanceRestInteraction(json, '', elem.interactionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'transactionMode', elem.TransactionModeElement, CODES_TFhirTransactionModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'transactionMode', elem.TransactionModeElement, CODES_TFhirTransactionModeEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.searchParamList.Count > 0) then
  begin
    json.valueArray('searchParam');
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeConformanceRestResourceSearchParam(json, '', elem.searchParamList[i]); {z - @Conformance.rest.resource.searchParam}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.operationList.Count > 0) then
  begin
    json.valueArray('operation');
    for i := 0 to elem.operationList.Count - 1 do
      ComposeConformanceRestOperation(json, '', elem.operationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.compartmentList.Count > 0) then
  begin
    json.valueArray('compartment');
    ext := false;
    for i := 0 to elem.compartmentList.Count - 1 do
    begin
      ext := ext or ((elem.compartmentList[i].id <> '') or (elem.compartmentList[i].hasExtensionList));
      ComposeUriValue(json, '',elem.compartmentList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_compartment');
      for i := 0 to elem.compartmentList.Count - 1 do
        ComposeUriProps(json, '',elem.compartmentList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConformanceRest(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceRest; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConformanceRest');
  end;
  composeBackboneElement(this, 'ConformanceRest', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ConformanceRest', 'mode', elem.ModeElement, CODES_TFhirRestfulConformanceModeEnum, SYSTEMS_TFhirRestfulConformanceModeEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConformanceRest', 'documentation', elem.documentationElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeConformanceRestSecurity(this, 'ConformanceRest', 'security', elem.securityElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeConformanceRestResource(this, 'ConformanceRest', 'resource', elem.resourceList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeConformanceRestInteraction(this, 'ConformanceRest', 'interaction', elem.interactionList[i], i);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'ConformanceRest', 'transactionMode', elem.TransactionModeElement, CODES_TFhirTransactionModeEnum, SYSTEMS_TFhirTransactionModeEnum, -1);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeConformanceRestResourceSearchParam(this, 'ConformanceRest', 'searchParam', elem.searchParamList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.operationList.Count - 1 do
      ComposeConformanceRestOperation(this, 'ConformanceRest', 'operation', elem.operationList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.compartmentList.Count - 1 do
      ComposeUri(this, 'ConformanceRest', 'compartment', elem.compartmentList[i], i);
end;

function TFHIRXmlParser.ParseConformanceRestSecurity(element : IXmlDomElement; path : string) : TFhirConformanceRestSecurity;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'cors') then
        result.corsElement := ParseBoolean(child, path+'/cors') {b}
      else if (child.baseName = 'service') then
        result.serviceList.Add(ParseCodeableConcept(child, path+'/service')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'certificate') then
        result.certificateList.Add(ParseConformanceRestSecurityCertificate(child, path+'/certificate')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestSecurity(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurity);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'cors', elem.corsElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.serviceList.Count - 1 do
      ComposeCodeableConcept(xml, 'service', elem.serviceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.certificateList.Count - 1 do
      ComposeConformanceRestSecurityCertificate(xml, 'certificate', elem.certificateList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestSecurity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestSecurity(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestSecurity(jsn : TJsonObject) : TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('cors') or jsn.has('_cors') then
        result.corsElement := ParseBoolean(jsn['cors'], jsn.vObj['_cors']);{q}
    if jsn.has('service') then
      iterateArray(jsn.vArr['service'], result.serviceList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('certificate') then
      iterateArray(jsn.vArr['certificate'], result.certificateList, parseConformanceRestSecurityCertificate);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestSecurity(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurity; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'cors', elem.corsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'cors', elem.corsElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.serviceList.Count > 0) then
  begin
    json.valueArray('service');
    for i := 0 to elem.serviceList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.serviceList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.certificateList.Count > 0) then
  begin
    json.valueArray('certificate');
    for i := 0 to elem.certificateList.Count - 1 do
      ComposeConformanceRestSecurityCertificate(json, '', elem.certificateList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConformanceRestSecurity(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceRestSecurity; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConformanceRestSecurity');
  end;
  composeBackboneElement(this, 'ConformanceRestSecurity', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ConformanceRestSecurity', 'cors', elem.corsElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.serviceList.Count - 1 do
      ComposeCodeableConcept(this, 'ConformanceRestSecurity', 'service', elem.serviceList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConformanceRestSecurity', 'description', elem.descriptionElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.certificateList.Count - 1 do
      ComposeConformanceRestSecurityCertificate(this, 'ConformanceRestSecurity', 'certificate', elem.certificateList[i], i);
end;

function TFHIRXmlParser.ParseConformanceRestSecurityCertificate(element : IXmlDomElement; path : string) : TFhirConformanceRestSecurityCertificate;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseCode(child, path+'/type') {b}
      else if (child.baseName = 'blob') then
        result.blobElement := ParseBase64Binary(child, path+'/blob') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestSecurityCertificate(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurityCertificate);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'type', elem.type_Element);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64Binary(xml, 'blob', elem.blobElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestSecurityCertificate(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestSecurityCertificate(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestSecurityCertificate(jsn : TJsonObject) : TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := ParseCode(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('blob') or jsn.has('_blob') then
        result.blobElement := ParseBase64Binary(jsn['blob'], jsn.vObj['_blob']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestSecurityCertificate(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurityCertificate; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64BinaryValue(json, 'blob', elem.blobElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64BinaryProps(json, 'blob', elem.blobElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConformanceRestSecurityCertificate(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceRestSecurityCertificate; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConformanceRestSecurityCertificate');
  end;
  composeBackboneElement(this, 'ConformanceRestSecurityCertificate', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ConformanceRestSecurityCertificate', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64Binary(this, 'ConformanceRestSecurityCertificate', 'blob', elem.blobElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseConformanceRestResource(element : IXmlDomElement; path : string) : TFhirConformanceRestResource;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestResource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/type', child){1a}
      else if (child.baseName = 'profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if (child.baseName = 'interaction') then
        result.interactionList.Add(ParseConformanceRestResourceInteraction(child, path+'/interaction')){y.2}
      else if (child.baseName = 'versioning') then
        result.versioningElement := ParseEnum(CODES_TFhirVersioningPolicyEnum, SYSTEMS_TFhirVersioningPolicyEnum, path+'/versioning', child){1a}
      else if (child.baseName = 'readHistory') then
        result.readHistoryElement := ParseBoolean(child, path+'/readHistory') {b}
      else if (child.baseName = 'updateCreate') then
        result.updateCreateElement := ParseBoolean(child, path+'/updateCreate') {b}
      else if (child.baseName = 'conditionalCreate') then
        result.conditionalCreateElement := ParseBoolean(child, path+'/conditionalCreate') {b}
      else if (child.baseName = 'conditionalUpdate') then
        result.conditionalUpdateElement := ParseBoolean(child, path+'/conditionalUpdate') {b}
      else if (child.baseName = 'conditionalDelete') then
        result.conditionalDeleteElement := ParseEnum(CODES_TFhirConditionalDeleteStatusEnum, SYSTEMS_TFhirConditionalDeleteStatusEnum, path+'/conditionalDelete', child){1a}
      else if (child.baseName = 'searchInclude') then
        result.searchIncludeList.Add(ParseString(child, path+'/searchInclude')){y.2}
      else if (child.baseName = 'searchRevInclude') then
        result.searchRevIncludeList.Add(ParseString(child, path+'/searchRevInclude')){y.2}
      else if (child.baseName = 'searchParam') then
        result.searchParamList.Add(ParseConformanceRestResourceSearchParam(child, path+'/searchParam')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResource(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResource);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeConformanceRestResourceInteraction(xml, 'interaction', elem.interactionList[i]);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'versioning', elem.VersioningElement, CODES_TFhirVersioningPolicyEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'readHistory', elem.readHistoryElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'updateCreate', elem.updateCreateElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'conditionalCreate', elem.conditionalCreateElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'conditionalUpdate', elem.conditionalUpdateElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'conditionalDelete', elem.ConditionalDeleteElement, CODES_TFhirConditionalDeleteStatusEnum);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.searchIncludeList.Count - 1 do
      ComposeString(xml, 'searchInclude', elem.searchIncludeList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.searchRevIncludeList.Count - 1 do
      ComposeString(xml, 'searchRevInclude', elem.searchRevIncludeList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeConformanceRestResourceSearchParam(xml, 'searchParam', elem.searchParamList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestResource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestResource(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestResource(jsn : TJsonObject) : TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(jsn.vObj['profile']);{q}
    if jsn.has('interaction') then
      iterateArray(jsn.vArr['interaction'], result.interactionList, parseConformanceRestResourceInteraction);
    if jsn.has('versioning') or jsn.has('_versioning')  then
      result.versioningElement := parseEnum(jsn.path+'/versioning', jsn['versioning'], jsn.vObj['_versioning'], CODES_TFhirVersioningPolicyEnum, SYSTEMS_TFhirVersioningPolicyEnum);
    if jsn.has('readHistory') or jsn.has('_readHistory') then
        result.readHistoryElement := ParseBoolean(jsn['readHistory'], jsn.vObj['_readHistory']);{q}
    if jsn.has('updateCreate') or jsn.has('_updateCreate') then
        result.updateCreateElement := ParseBoolean(jsn['updateCreate'], jsn.vObj['_updateCreate']);{q}
    if jsn.has('conditionalCreate') or jsn.has('_conditionalCreate') then
        result.conditionalCreateElement := ParseBoolean(jsn['conditionalCreate'], jsn.vObj['_conditionalCreate']);{q}
    if jsn.has('conditionalUpdate') or jsn.has('_conditionalUpdate') then
        result.conditionalUpdateElement := ParseBoolean(jsn['conditionalUpdate'], jsn.vObj['_conditionalUpdate']);{q}
    if jsn.has('conditionalDelete') or jsn.has('_conditionalDelete')  then
      result.conditionalDeleteElement := parseEnum(jsn.path+'/conditionalDelete', jsn['conditionalDelete'], jsn.vObj['_conditionalDelete'], CODES_TFhirConditionalDeleteStatusEnum, SYSTEMS_TFhirConditionalDeleteStatusEnum);
      if jsn.has('searchInclude') or jsn.has('_searchInclude') then
      iteratePrimitiveArray(jsn.vArr['searchInclude'], jsn.vArr['_searchInclude'], result.searchIncludeList, parseString);
      if jsn.has('searchRevInclude') or jsn.has('_searchRevInclude') then
      iteratePrimitiveArray(jsn.vArr['searchRevInclude'], jsn.vArr['_searchRevInclude'], result.searchRevIncludeList, parseString);
    if jsn.has('searchParam') then
      iterateArray(jsn.vArr['searchParam'], result.searchParamList, parseConformanceRestResourceSearchParam);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestResource(json : TJSONWriter; name : string; elem : TFhirConformanceRestResource; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(json, 'profile', elem.profile); {a}
  if (SummaryOption in [soFull, soData]) and (elem.interactionList.Count > 0) then
  begin
    json.valueArray('interaction');
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeConformanceRestResourceInteraction(json, '', elem.interactionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'versioning', elem.VersioningElement, CODES_TFhirVersioningPolicyEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'versioning', elem.VersioningElement, CODES_TFhirVersioningPolicyEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'readHistory', elem.readHistoryElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'readHistory', elem.readHistoryElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'updateCreate', elem.updateCreateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'updateCreate', elem.updateCreateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'conditionalCreate', elem.conditionalCreateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'conditionalCreate', elem.conditionalCreateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'conditionalUpdate', elem.conditionalUpdateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'conditionalUpdate', elem.conditionalUpdateElement, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'conditionalDelete', elem.ConditionalDeleteElement, CODES_TFhirConditionalDeleteStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'conditionalDelete', elem.ConditionalDeleteElement, CODES_TFhirConditionalDeleteStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.searchIncludeList.Count > 0) then
  begin
    json.valueArray('searchInclude');
    ext := false;
    for i := 0 to elem.searchIncludeList.Count - 1 do
    begin
      ext := ext or ((elem.searchIncludeList[i].id <> '') or (elem.searchIncludeList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.searchIncludeList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_searchInclude');
      for i := 0 to elem.searchIncludeList.Count - 1 do
        ComposeStringProps(json, '',elem.searchIncludeList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.searchRevIncludeList.Count > 0) then
  begin
    json.valueArray('searchRevInclude');
    ext := false;
    for i := 0 to elem.searchRevIncludeList.Count - 1 do
    begin
      ext := ext or ((elem.searchRevIncludeList[i].id <> '') or (elem.searchRevIncludeList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.searchRevIncludeList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_searchRevInclude');
      for i := 0 to elem.searchRevIncludeList.Count - 1 do
        ComposeStringProps(json, '',elem.searchRevIncludeList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.searchParamList.Count > 0) then
  begin
    json.valueArray('searchParam');
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeConformanceRestResourceSearchParam(json, '', elem.searchParamList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConformanceRestResource(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceRestResource; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConformanceRestResource');
  end;
  composeBackboneElement(this, 'ConformanceRestResource', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ConformanceRestResource', 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(this, 'ConformanceRestResource', 'profile', elem.profileElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeConformanceRestResourceInteraction(this, 'ConformanceRestResource', 'interaction', elem.interactionList[i], i);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'ConformanceRestResource', 'versioning', elem.VersioningElement, CODES_TFhirVersioningPolicyEnum, SYSTEMS_TFhirVersioningPolicyEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ConformanceRestResource', 'readHistory', elem.readHistoryElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ConformanceRestResource', 'updateCreate', elem.updateCreateElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ConformanceRestResource', 'conditionalCreate', elem.conditionalCreateElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ConformanceRestResource', 'conditionalUpdate', elem.conditionalUpdateElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'ConformanceRestResource', 'conditionalDelete', elem.ConditionalDeleteElement, CODES_TFhirConditionalDeleteStatusEnum, SYSTEMS_TFhirConditionalDeleteStatusEnum, -1);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.searchIncludeList.Count - 1 do
      ComposeString(this, 'ConformanceRestResource', 'searchInclude', elem.searchIncludeList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.searchRevIncludeList.Count - 1 do
      ComposeString(this, 'ConformanceRestResource', 'searchRevInclude', elem.searchRevIncludeList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeConformanceRestResourceSearchParam(this, 'ConformanceRestResource', 'searchParam', elem.searchParamList[i], i);
end;

function TFHIRXmlParser.ParseConformanceRestResourceInteraction(element : IXmlDomElement; path : string) : TFhirConformanceRestResourceInteraction;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestResourceInteraction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeElement := ParseEnum(CODES_TFhirTypeRestfulInteractionEnum, SYSTEMS_TFhirTypeRestfulInteractionEnum, path+'/code', child){1a}
      else if (child.baseName = 'documentation') then
        result.documentationElement := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResourceInteraction(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceInteraction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirTypeRestfulInteractionEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestResourceInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestResourceInteraction(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestResourceInteraction(jsn : TJsonObject) : TFhirConformanceRestResourceInteraction;
begin
  result := TFhirConformanceRestResourceInteraction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn['code'], jsn.vObj['_code'], CODES_TFhirTypeRestfulInteractionEnum, SYSTEMS_TFhirTypeRestfulInteractionEnum);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestResourceInteraction(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceInteraction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirTypeRestfulInteractionEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirTypeRestfulInteractionEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConformanceRestResourceInteraction(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceRestResourceInteraction; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConformanceRestResourceInteraction');
  end;
  composeBackboneElement(this, 'ConformanceRestResourceInteraction', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'ConformanceRestResourceInteraction', 'code', elem.CodeElement, CODES_TFhirTypeRestfulInteractionEnum, SYSTEMS_TFhirTypeRestfulInteractionEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConformanceRestResourceInteraction', 'documentation', elem.documentationElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseConformanceRestResourceSearchParam(element : IXmlDomElement; path : string) : TFhirConformanceRestResourceSearchParam;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'definition') then
        result.definitionElement := ParseUri(child, path+'/definition') {b}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, path+'/type', child){1a}
      else if (child.baseName = 'documentation') then
        result.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'target') then
        result.target.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/target', child)){y.1}
      else if (child.baseName = 'modifier') then
        result.modifierList.Add(ParseEnum(CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum, path+'/modifier', child)){y.1}
      else if (child.baseName = 'chain') then
        result.chainList.Add(ParseString(child, path+'/chain')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResourceSearchParam(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceSearchParam);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'definition', elem.definitionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.target.Count - 1 do
      ComposeEnum(xml, 'target', elem.target[i], CODES_TFhirResourceTypesEnum);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeEnum(xml, 'modifier', elem.modifierList[i], CODES_TFhirSearchModifierCodeEnum);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.chainList.Count - 1 do
      ComposeString(xml, 'chain', elem.chainList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestResourceSearchParam(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestResourceSearchParam(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestResourceSearchParam(jsn : TJsonObject) : TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := ParseUri(jsn['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('target') or jsn.has('_target') then
      iterateEnumArray(jsn.vArr['target'], jsn.vArr['_target'], jsn.path+'/target', result.target, parseEnum, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('modifier') or jsn.has('_modifier') then
      iterateEnumArray(jsn.vArr['modifier'], jsn.vArr['_modifier'], jsn.path+'/modifier', result.modifierList, parseEnum, CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum);
      if jsn.has('chain') or jsn.has('_chain') then
      iteratePrimitiveArray(jsn.vArr['chain'], jsn.vArr['_chain'], result.chainList, parseString);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestResourceSearchParam(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceSearchParam; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.target.Count > 0) then
  begin
    json.valueArray('target');
    ext := false;
    for i := 0 to elem.target.Count - 1 do
    begin
      ext := ext or ((elem.target[i].id <> '') or (elem.target[i].hasExtensionList));
      ComposeEnumValue(json, '', elem.target[i], CODES_TFhirResourceTypesEnum, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_target');
      for i := 0 to elem.target.Count - 1 do
        ComposeEnumProps(json, '', elem.target[i], CODES_TFhirResourceTypesEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.modifierList.Count > 0) then
  begin
    json.valueArray('modifier');
    ext := false;
    for i := 0 to elem.modifierList.Count - 1 do
    begin
      ext := ext or ((elem.modifierList[i].id <> '') or (elem.modifierList[i].hasExtensionList));
      ComposeEnumValue(json, '', elem.modifierList[i], CODES_TFhirSearchModifierCodeEnum, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_modifier');
      for i := 0 to elem.modifierList.Count - 1 do
        ComposeEnumProps(json, '', elem.modifierList[i], CODES_TFhirSearchModifierCodeEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.chainList.Count > 0) then
  begin
    json.valueArray('chain');
    ext := false;
    for i := 0 to elem.chainList.Count - 1 do
    begin
      ext := ext or ((elem.chainList[i].id <> '') or (elem.chainList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.chainList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_chain');
      for i := 0 to elem.chainList.Count - 1 do
        ComposeStringProps(json, '',elem.chainList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConformanceRestResourceSearchParam(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceRestResourceSearchParam; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConformanceRestResourceSearchParam');
  end;
  composeBackboneElement(this, 'ConformanceRestResourceSearchParam', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConformanceRestResourceSearchParam', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ConformanceRestResourceSearchParam', 'definition', elem.definitionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'ConformanceRestResourceSearchParam', 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConformanceRestResourceSearchParam', 'documentation', elem.documentationElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.target.Count - 1 do
      ComposeEnum(this, 'ConformanceRestResourceSearchParam', 'target', elem.target[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.target.Count - 1 do
      ComposeEnum(this, 'ConformanceRestResourceSearchParam', 'target', elem.target[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeEnum(this, 'ConformanceRestResourceSearchParam', 'modifier', elem.modifierList[i], CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum, i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeEnum(this, 'ConformanceRestResourceSearchParam', 'modifier', elem.modifierList[i], CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum, i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.chainList.Count - 1 do
      ComposeString(this, 'ConformanceRestResourceSearchParam', 'chain', elem.chainList[i], i);
end;

function TFHIRXmlParser.ParseConformanceRestInteraction(element : IXmlDomElement; path : string) : TFhirConformanceRestInteraction;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestInteraction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeElement := ParseEnum(CODES_TFhirSystemRestfulInteractionEnum, SYSTEMS_TFhirSystemRestfulInteractionEnum, path+'/code', child){1a}
      else if (child.baseName = 'documentation') then
        result.documentationElement := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestInteraction(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestInteraction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirSystemRestfulInteractionEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestInteraction(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestInteraction(jsn : TJsonObject) : TFhirConformanceRestInteraction;
begin
  result := TFhirConformanceRestInteraction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn['code'], jsn.vObj['_code'], CODES_TFhirSystemRestfulInteractionEnum, SYSTEMS_TFhirSystemRestfulInteractionEnum);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestInteraction(json : TJSONWriter; name : string; elem : TFhirConformanceRestInteraction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirSystemRestfulInteractionEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirSystemRestfulInteractionEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConformanceRestInteraction(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceRestInteraction; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConformanceRestInteraction');
  end;
  composeBackboneElement(this, 'ConformanceRestInteraction', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'ConformanceRestInteraction', 'code', elem.CodeElement, CODES_TFhirSystemRestfulInteractionEnum, SYSTEMS_TFhirSystemRestfulInteractionEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConformanceRestInteraction', 'documentation', elem.documentationElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseConformanceRestOperation(element : IXmlDomElement; path : string) : TFhirConformanceRestOperation;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestOperation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'definition') then
        result.definition := ParseReference{TFhirOperationDefinition}(child, path+'/definition') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestOperation(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestOperation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOperationDefinition}(xml, 'definition', elem.definition);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestOperation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestOperation(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestOperation(jsn : TJsonObject) : TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('definition') then
        result.definition := ParseReference{TFhirOperationDefinition}(jsn.vObj['definition']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestOperation(json : TJSONWriter; name : string; elem : TFhirConformanceRestOperation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOperationDefinition}(json, 'definition', elem.definition); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConformanceRestOperation(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceRestOperation; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConformanceRestOperation');
  end;
  composeBackboneElement(this, 'ConformanceRestOperation', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConformanceRestOperation', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOperationDefinition}(this, 'ConformanceRestOperation', 'definition', elem.definitionElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseConformanceMessaging(element : IXmlDomElement; path : string) : TFhirConformanceMessaging;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceMessaging.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'endpoint') then
        result.endpointList.Add(ParseConformanceMessagingEndpoint(child, path+'/endpoint')){y.2}
      else if (child.baseName = 'reliableCache') then
        result.reliableCacheElement := ParseUnsignedInt(child, path+'/reliableCache') {b}
      else if (child.baseName = 'documentation') then
        result.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'event') then
        result.eventList.Add(ParseConformanceMessagingEvent(child, path+'/event')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceMessaging(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessaging);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeConformanceMessagingEndpoint(xml, 'endpoint', elem.endpointList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(xml, 'reliableCache', elem.reliableCacheElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeConformanceMessagingEvent(xml, 'event', elem.eventList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceMessaging(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceMessaging(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceMessaging(jsn : TJsonObject) : TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('endpoint') then
      iterateArray(jsn.vArr['endpoint'], result.endpointList, parseConformanceMessagingEndpoint);
    if jsn.has('reliableCache') or jsn.has('_reliableCache') then
        result.reliableCacheElement := ParseUnsignedInt(jsn['reliableCache'], jsn.vObj['_reliableCache']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseConformanceMessagingEvent);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceMessaging(json : TJSONWriter; name : string; elem : TFhirConformanceMessaging; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.endpointList.Count > 0) then
  begin
    json.valueArray('endpoint');
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeConformanceMessagingEndpoint(json, '', elem.endpointList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedIntValue(json, 'reliableCache', elem.reliableCacheElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedIntProps(json, 'reliableCache', elem.reliableCacheElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.eventList.Count > 0) then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeConformanceMessagingEvent(json, '', elem.eventList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConformanceMessaging(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceMessaging; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConformanceMessaging');
  end;
  composeBackboneElement(this, 'ConformanceMessaging', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeConformanceMessagingEndpoint(this, 'ConformanceMessaging', 'endpoint', elem.endpointList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'ConformanceMessaging', 'reliableCache', elem.reliableCacheElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConformanceMessaging', 'documentation', elem.documentationElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeConformanceMessagingEvent(this, 'ConformanceMessaging', 'event', elem.eventList[i], i);
end;

function TFHIRXmlParser.ParseConformanceMessagingEndpoint(element : IXmlDomElement; path : string) : TFhirConformanceMessagingEndpoint;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceMessagingEndpoint.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'protocol') then
        result.protocol := ParseCoding(child, path+'/protocol') {b}
      else if (child.baseName = 'address') then
        result.addressElement := ParseUri(child, path+'/address') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceMessagingEndpoint(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessagingEndpoint);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'protocol', elem.protocol);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'address', elem.addressElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceMessagingEndpoint(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceMessagingEndpoint(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceMessagingEndpoint(jsn : TJsonObject) : TFhirConformanceMessagingEndpoint;
begin
  result := TFhirConformanceMessagingEndpoint.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('protocol') then
        result.protocol := ParseCoding(jsn.vObj['protocol']);{q}
    if jsn.has('address') or jsn.has('_address') then
        result.addressElement := ParseUri(jsn['address'], jsn.vObj['_address']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceMessagingEndpoint(json : TJSONWriter; name : string; elem : TFhirConformanceMessagingEndpoint; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'protocol', elem.protocol); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'address', elem.addressElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'address', elem.addressElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConformanceMessagingEndpoint(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceMessagingEndpoint; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConformanceMessagingEndpoint');
  end;
  composeBackboneElement(this, 'ConformanceMessagingEndpoint', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(false, this, 'ConformanceMessagingEndpoint', 'protocol', elem.protocolElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ConformanceMessagingEndpoint', 'address', elem.addressElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseConformanceMessagingEvent(element : IXmlDomElement; path : string) : TFhirConformanceMessagingEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCoding(child, path+'/code') {b}
      else if (child.baseName = 'category') then
        result.categoryElement := ParseEnum(CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum, path+'/category', child){1a}
      else if (child.baseName = 'mode') then
        result.modeElement := ParseEnum(CODES_TFhirMessageConformanceEventModeEnum, SYSTEMS_TFhirMessageConformanceEventModeEnum, path+'/mode', child){1a}
      else if (child.baseName = 'focus') then
        result.focusElement := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/focus', child){1a}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirStructureDefinition}(child, path+'/request') {b}
      else if (child.baseName = 'response') then
        result.response := ParseReference{TFhirStructureDefinition}(child, path+'/response') {b}
      else if (child.baseName = 'documentation') then
        result.documentationElement := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceMessagingEvent(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessagingEvent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategoryEnum);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirMessageConformanceEventModeEnum);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'focus', elem.FocusElement, CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(xml, 'request', elem.request);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(xml, 'response', elem.response);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceMessagingEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceMessagingEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceMessagingEvent(jsn : TJsonObject) : TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q}
    if jsn.has('category') or jsn.has('_category')  then
      result.categoryElement := parseEnum(jsn.path+'/category', jsn['category'], jsn.vObj['_category'], CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn['mode'], jsn.vObj['_mode'], CODES_TFhirMessageConformanceEventModeEnum, SYSTEMS_TFhirMessageConformanceEventModeEnum);
    if jsn.has('focus') or jsn.has('_focus')  then
      result.focusElement := parseEnum(jsn.path+'/focus', jsn['focus'], jsn.vObj['_focus'], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('request') then
        result.request := ParseReference{TFhirStructureDefinition}(jsn.vObj['request']);{q}
    if jsn.has('response') then
        result.response := ParseReference{TFhirStructureDefinition}(jsn.vObj['response']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceMessagingEvent(json : TJSONWriter; name : string; elem : TFhirConformanceMessagingEvent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategoryEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategoryEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirMessageConformanceEventModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirMessageConformanceEventModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'focus', elem.FocusElement, CODES_TFhirResourceTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'focus', elem.FocusElement, CODES_TFhirResourceTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(json, 'response', elem.response); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConformanceMessagingEvent(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceMessagingEvent; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConformanceMessagingEvent');
  end;
  composeBackboneElement(this, 'ConformanceMessagingEvent', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(false, this, 'ConformanceMessagingEvent', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'ConformanceMessagingEvent', 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum, -1);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'ConformanceMessagingEvent', 'mode', elem.ModeElement, CODES_TFhirMessageConformanceEventModeEnum, SYSTEMS_TFhirMessageConformanceEventModeEnum, -1);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'ConformanceMessagingEvent', 'focus', elem.FocusElement, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(this, 'ConformanceMessagingEvent', 'request', elem.requestElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(this, 'ConformanceMessagingEvent', 'response', elem.responseElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConformanceMessagingEvent', 'documentation', elem.documentationElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseConformanceDocument(element : IXmlDomElement; path : string) : TFhirConformanceDocument;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceDocument.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'mode') then
        result.modeElement := ParseEnum(CODES_TFhirDocumentModeEnum, SYSTEMS_TFhirDocumentModeEnum, path+'/mode', child){1a}
      else if (child.baseName = 'documentation') then
        result.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceDocument(xml : TXmlBuilder; name : string; elem : TFhirConformanceDocument);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirDocumentModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceDocument(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceDocument(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceDocument(jsn : TJsonObject) : TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn['mode'], jsn.vObj['_mode'], CODES_TFhirDocumentModeEnum, SYSTEMS_TFhirDocumentModeEnum);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(jsn.vObj['profile']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceDocument(json : TJSONWriter; name : string; elem : TFhirConformanceDocument; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirDocumentModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirDocumentModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(json, 'profile', elem.profile); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeConformanceDocument(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformanceDocument; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ConformanceDocument');
  end;
  composeBackboneElement(this, 'ConformanceDocument', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'ConformanceDocument', 'mode', elem.ModeElement, CODES_TFhirDocumentModeEnum, SYSTEMS_TFhirDocumentModeEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConformanceDocument', 'documentation', elem.documentationElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(this, 'ConformanceDocument', 'profile', elem.profileElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseConformance(element : IXmlDomElement; path : string) : TFhirConformance;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformance.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseConformanceContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'requirements') then
        result.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'copyright') then
        result.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.baseName = 'kind') then
        result.kindElement := ParseEnum(CODES_TFhirConformanceStatementKindEnum, SYSTEMS_TFhirConformanceStatementKindEnum, path+'/kind', child){1a}
      else if (child.baseName = 'software') then
        result.software := ParseConformanceSoftware(child, path+'/software') {b}
      else if (child.baseName = 'implementation') then
        result.implementation_ := ParseConformanceImplementation(child, path+'/implementation') {b}
      else if (child.baseName = 'fhirVersion') then
        result.fhirVersionElement := ParseId(child, path+'/fhirVersion') {b}
      else if (child.baseName = 'acceptUnknown') then
        result.acceptUnknownElement := ParseEnum(CODES_TFhirUnknownContentCodeEnum, SYSTEMS_TFhirUnknownContentCodeEnum, path+'/acceptUnknown', child){1a}
      else if (child.baseName = 'format') then
        result.formatList.Add(ParseCode(child, path+'/format')){y.2}
      else if (child.baseName = 'profile') then
        result.profileList.Add(ParseReference{TFhirStructureDefinition}(child, path+'/profile')){y.2}
      else if (child.baseName = 'rest') then
        result.restList.Add(ParseConformanceRest(child, path+'/rest')){y.2}
      else if (child.baseName = 'messaging') then
        result.messagingList.Add(ParseConformanceMessaging(child, path+'/messaging')){y.2}
      else if (child.baseName = 'document') then
        result.documentList.Add(ParseConformanceDocument(child, path+'/document')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformance(xml : TXmlBuilder; name : string; elem : TFhirConformance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeConformanceContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyright', elem.copyrightElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirConformanceStatementKindEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeConformanceSoftware(xml, 'software', elem.software);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeConformanceImplementation(xml, 'implementation', elem.implementation_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'fhirVersion', elem.fhirVersionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'acceptUnknown', elem.AcceptUnknownElement, CODES_TFhirUnknownContentCodeEnum);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.formatList.Count - 1 do
      ComposeCode(xml, 'format', elem.formatList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profileList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.restList.Count - 1 do
      ComposeConformanceRest(xml, 'rest', elem.restList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.messagingList.Count - 1 do
      ComposeConformanceMessaging(xml, 'messaging', elem.messagingList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.documentList.Count - 1 do
      ComposeConformanceDocument(xml, 'document', elem.documentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformance(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformance(jsn : TJsonObject) : TFhirConformance;
begin
  result := TFhirConformance.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseConformanceContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn['kind'], jsn.vObj['_kind'], CODES_TFhirConformanceStatementKindEnum, SYSTEMS_TFhirConformanceStatementKindEnum);
    if jsn.has('software') then
        result.software := ParseConformanceSoftware(jsn.vObj['software']);{q}
    if jsn.has('implementation') then
        result.implementation_ := ParseConformanceImplementation(jsn.vObj['implementation']);{q}
    if jsn.has('fhirVersion') or jsn.has('_fhirVersion') then
        result.fhirVersionElement := ParseId(jsn['fhirVersion'], jsn.vObj['_fhirVersion']);{q}
    if jsn.has('acceptUnknown') or jsn.has('_acceptUnknown')  then
      result.acceptUnknownElement := parseEnum(jsn.path+'/acceptUnknown', jsn['acceptUnknown'], jsn.vObj['_acceptUnknown'], CODES_TFhirUnknownContentCodeEnum, SYSTEMS_TFhirUnknownContentCodeEnum);
      if jsn.has('format') or jsn.has('_format') then
      iteratePrimitiveArray(jsn.vArr['format'], jsn.vArr['_format'], result.formatList, parseCode);
    if jsn.has('profile') then
      iterateArray(jsn.vArr['profile'], result.profileList, parseReference{TFhirStructureDefinition});
    if jsn.has('rest') then
      iterateArray(jsn.vArr['rest'], result.restList, parseConformanceRest);
    if jsn.has('messaging') then
      iterateArray(jsn.vArr['messaging'], result.messagingList, parseConformanceMessaging);
    if jsn.has('document') then
      iterateArray(jsn.vArr['document'], result.documentList, parseConformanceDocument);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformance(json : TJSONWriter; name : string; elem : TFhirConformance; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeConformanceContact(json, '', elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirConformanceStatementKindEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirConformanceStatementKindEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeConformanceSoftware(json, 'software', elem.software); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeConformanceImplementation(json, 'implementation', elem.implementation_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdValue(json, 'fhirVersion', elem.fhirVersionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdProps(json, 'fhirVersion', elem.fhirVersionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'acceptUnknown', elem.AcceptUnknownElement, CODES_TFhirUnknownContentCodeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'acceptUnknown', elem.AcceptUnknownElement, CODES_TFhirUnknownContentCodeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.formatList.Count > 0) then
  begin
    json.valueArray('format');
    ext := false;
    for i := 0 to elem.formatList.Count - 1 do
    begin
      ext := ext or ((elem.formatList[i].id <> '') or (elem.formatList[i].hasExtensionList));
      ComposeCodeValue(json, '',elem.formatList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_format');
      for i := 0 to elem.formatList.Count - 1 do
        ComposeCodeProps(json, '',elem.formatList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.profileList.Count > 0) then
  begin
    json.valueArray('profile');
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirStructureDefinition}(json, '', elem.profileList[i]); {z - Reference(StructureDefinition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.restList.Count > 0) then
  begin
    json.valueArray('rest');
    for i := 0 to elem.restList.Count - 1 do
      ComposeConformanceRest(json, '', elem.restList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.messagingList.Count > 0) then
  begin
    json.valueArray('messaging');
    for i := 0 to elem.messagingList.Count - 1 do
      ComposeConformanceMessaging(json, '', elem.messagingList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.documentList.Count > 0) then
  begin
    json.valueArray('document');
    for i := 0 to elem.documentList.Count - 1 do
      ComposeConformanceDocument(json, '', elem.documentList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeConformance(parent :  TRDFComplex; parentType, name : String; elem : TFhirConformance; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Conformance');
  end;
  composeDomainResource(this, 'Conformance', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Conformance', 'url', elem.urlElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Conformance', 'version', elem.versionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Conformance', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Conformance', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Conformance', 'experimental', elem.experimentalElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Conformance', 'publisher', elem.publisherElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeConformanceContact(this, 'Conformance', 'contact', elem.contactList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Conformance', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Conformance', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Conformance', 'requirements', elem.requirementsElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Conformance', 'copyright', elem.copyrightElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Conformance', 'kind', elem.KindElement, CODES_TFhirConformanceStatementKindEnum, SYSTEMS_TFhirConformanceStatementKindEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeConformanceSoftware(this, 'Conformance', 'software', elem.softwareElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeConformanceImplementation(this, 'Conformance', 'implementation', elem.implementation_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'Conformance', 'fhirVersion', elem.fhirVersionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Conformance', 'acceptUnknown', elem.AcceptUnknownElement, CODES_TFhirUnknownContentCodeEnum, SYSTEMS_TFhirUnknownContentCodeEnum, -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.formatList.Count - 1 do
      ComposeCode(this, 'Conformance', 'format', elem.formatList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirStructureDefinition}(this, 'Conformance', 'profile', elem.profileList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.restList.Count - 1 do
      ComposeConformanceRest(this, 'Conformance', 'rest', elem.restList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.messagingList.Count - 1 do
      ComposeConformanceMessaging(this, 'Conformance', 'messaging', elem.messagingList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.documentList.Count - 1 do
      ComposeConformanceDocument(this, 'Conformance', 'document', elem.documentList[i], i);
end;

function TFHIRXmlParser.ParseContractActor(element : IXmlDomElement; path : string) : TFhirContractActor;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractActor.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'entity') then
        result.entity := ParseReference{Resource}(child, path+'/entity') {b}
      else if (child.baseName = 'role') then
        result.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractActor(xml : TXmlBuilder; name : string; elem : TFhirContractActor);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'entity', elem.entity);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractActor(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractActor(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractActor(jsn : TJsonObject) : TFhirContractActor;
begin
  result := TFhirContractActor.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('entity') then
        result.entity := ParseReference{Resource}(jsn.vObj['entity']);{q}
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContractActor(json : TJSONWriter; name : string; elem : TFhirContractActor; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(json, 'entity', elem.entity); {a}
  if (SummaryOption in [soFull, soData]) and (elem.roleList.Count > 0) then
  begin
    json.valueArray('role');
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.roleList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeContractActor(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractActor; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ContractActor');
  end;
  composeBackboneElement(this, 'ContractActor', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'ContractActor', 'entity', elem.entityElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'ContractActor', 'role', elem.roleList[i], i);
end;

function TFHIRXmlParser.ParseContractValuedItem(element : IXmlDomElement; path : string) : TFhirContractValuedItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractValuedItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'entityCodeableConcept') then
        result.entity := ParseCodeableConcept(child, path+'/entityCodeableConcept'){x.3}
      else if (child.baseName = 'entityReference') then
        result.entity := ParseReference(child, path+'/entityReference') {a}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'effectiveTime') then
        result.effectiveTimeElement := ParseDateTime(child, path+'/effectiveTime') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'unitPrice') then
        result.unitPrice := ParseQuantity(child, path+'/unitPrice') {b}
      else if (child.baseName = 'factor') then
        result.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.baseName = 'points') then
        result.pointsElement := ParseDecimal(child, path+'/points') {b}
      else if (child.baseName = 'net') then
        result.net := ParseQuantity(child, path+'/net') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractValuedItem(xml : TXmlBuilder; name : string; elem : TFhirContractValuedItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'entityCodeableConcept', TFhirCodeableConcept(elem.entity))
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) {2} then
    ComposeReference(xml, 'entityReference', TFhirReference(elem.entity));
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'effectiveTime', elem.effectiveTimeElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'unitPrice', elem.unitPrice);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'points', elem.pointsElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'net', elem.net);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractValuedItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractValuedItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractValuedItem(jsn : TJsonObject) : TFhirContractValuedItem;
begin
  result := TFhirContractValuedItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('entityCodeableConcept') {a4} then
      result.entity := ParseCodeableConcept(jsn.vObj['entityCodeableConcept']);
    if jsn.has('entityReference') {a3} then
      result.entity := ParseReference(jsn.vObj['entityReference']);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('effectiveTime') or jsn.has('_effectiveTime') then
        result.effectiveTimeElement := ParseDateTime(jsn['effectiveTime'], jsn.vObj['_effectiveTime']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseQuantity(jsn.vObj['unitPrice']);{q}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('points') or jsn.has('_points') then
        result.pointsElement := ParseDecimal(jsn['points'], jsn.vObj['_points']);{q}
    if jsn.has('net') then
        result.net := ParseQuantity(jsn.vObj['net']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContractValuedItem(json : TJSONWriter; name : string; elem : TFhirContractValuedItem; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'entityCodeableConcept', TFhirCodeableConcept(elem.entity)) 
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) then
    ComposeReference(json, 'entityReference', TFhirReference(elem.entity));
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'effectiveTime', elem.effectiveTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'effectiveTime', elem.effectiveTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'net', elem.net); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeContractValuedItem(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractValuedItem; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ContractValuedItem');
  end;
  composeBackboneElement(this, 'ContractValuedItem', name, elem, index);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ContractValuedItem', 'entityCodeableConcept', TFhirCodeableConcept(elem.entity), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) {2} then
    ComposeReference(this, 'ContractValuedItem', 'entityReference', TFhirReference(elem.entity), -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'ContractValuedItem', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'ContractValuedItem', 'effectiveTime', elem.effectiveTimeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ContractValuedItem', 'quantity', elem.quantityElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ContractValuedItem', 'unitPrice', elem.unitPriceElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ContractValuedItem', 'factor', elem.factorElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ContractValuedItem', 'points', elem.pointsElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ContractValuedItem', 'net', elem.netElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseContractSigner(element : IXmlDomElement; path : string) : TFhirContractSigner;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractSigner.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'party') then
        result.party := ParseReference{Resource}(child, path+'/party') {b}
      else if (child.baseName = 'signature') then
        result.signatureElement := ParseString(child, path+'/signature') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractSigner(xml : TXmlBuilder; name : string; elem : TFhirContractSigner);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'party', elem.party);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'signature', elem.signatureElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractSigner(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractSigner(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractSigner(jsn : TJsonObject) : TFhirContractSigner;
begin
  result := TFhirContractSigner.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('party') then
        result.party := ParseReference{Resource}(jsn.vObj['party']);{q}
    if jsn.has('signature') or jsn.has('_signature') then
        result.signatureElement := ParseString(jsn['signature'], jsn.vObj['_signature']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContractSigner(json : TJSONWriter; name : string; elem : TFhirContractSigner; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(json, 'party', elem.party); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'signature', elem.signatureElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'signature', elem.signatureElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeContractSigner(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractSigner; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ContractSigner');
  end;
  composeBackboneElement(this, 'ContractSigner', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(false, this, 'ContractSigner', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'ContractSigner', 'party', elem.partyElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ContractSigner', 'signature', elem.signatureElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseContractTerm(element : IXmlDomElement; path : string) : TFhirContractTerm;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractTerm.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'issued') then
        result.issuedElement := ParseDateTime(child, path+'/issued') {b}
      else if (child.baseName = 'applies') then
        result.applies := ParsePeriod(child, path+'/applies') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'subType') then
        result.subType := ParseCodeableConcept(child, path+'/subType') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.baseName = 'action') then
        result.actionList.Add(ParseCodeableConcept(child, path+'/action')){y.2}
      else if (child.baseName = 'actionReason') then
        result.actionReasonList.Add(ParseCodeableConcept(child, path+'/actionReason')){y.2}
      else if (child.baseName = 'actor') then
        result.actorList.Add(ParseContractTermActor(child, path+'/actor')){y.2}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'valuedItem') then
        result.valuedItemList.Add(ParseContractTermValuedItem(child, path+'/valuedItem')){y.2}
      else if (child.baseName = 'group') then
        result.groupList.Add(ParseContractTerm(child, path+'/group')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractTerm(xml : TXmlBuilder; name : string; elem : TFhirContractTerm);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'issued', elem.issuedElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'applies', elem.applies);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'subType', elem.subType);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(xml, 'action', elem.actionList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'actionReason', elem.actionReasonList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actorList.Count - 1 do
      ComposeContractTermActor(xml, 'actor', elem.actorList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractTermValuedItem(xml, 'valuedItem', elem.valuedItemList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeContractTerm(xml, 'group', elem.groupList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractTerm(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTerm(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTerm(jsn : TJsonObject) : TFhirContractTerm;
begin
  result := TFhirContractTerm.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := ParseDateTime(jsn['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('applies') then
        result.applies := ParsePeriod(jsn.vObj['applies']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('subType') then
        result.subType := ParseCodeableConcept(jsn.vObj['subType']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q}
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseCodeableConcept);
    if jsn.has('actionReason') then
      iterateArray(jsn.vArr['actionReason'], result.actionReasonList, parseCodeableConcept);
    if jsn.has('actor') then
      iterateArray(jsn.vArr['actor'], result.actorList, parseContractTermActor);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('valuedItem') then
      iterateArray(jsn.vArr['valuedItem'], result.valuedItemList, parseContractTermValuedItem);
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseContractTerm);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContractTerm(json : TJSONWriter; name : string; elem : TFhirContractTerm; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'applies', elem.applies); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'subType', elem.subType); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soData]) and (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.actionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.actionReasonList.Count > 0) then
  begin
    json.valueArray('actionReason');
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.actionReasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.actorList.Count > 0) then
  begin
    json.valueArray('actor');
    for i := 0 to elem.actorList.Count - 1 do
      ComposeContractTermActor(json, '', elem.actorList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.valuedItemList.Count > 0) then
  begin
    json.valueArray('valuedItem');
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractTermValuedItem(json, '', elem.valuedItemList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.groupList.Count > 0) then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeContractTerm(json, '', elem.groupList[i]); {z - @Contract.term}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeContractTerm(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractTerm; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ContractTerm');
  end;
  composeBackboneElement(this, 'ContractTerm', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'ContractTerm', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ContractTerm', 'issued', elem.issuedElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'ContractTerm', 'applies', elem.appliesElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ContractTerm', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ContractTerm', 'subType', elem.subTypeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'ContractTerm', 'subject', elem.subjectElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(this, 'ContractTerm', 'action', elem.actionList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'ContractTerm', 'actionReason', elem.actionReasonList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actorList.Count - 1 do
      ComposeContractTermActor(this, 'ContractTerm', 'actor', elem.actorList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ContractTerm', 'text', elem.textElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractTermValuedItem(this, 'ContractTerm', 'valuedItem', elem.valuedItemList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeContractTerm(this, 'ContractTerm', 'group', elem.groupList[i], i);
end;

function TFHIRXmlParser.ParseContractTermActor(element : IXmlDomElement; path : string) : TFhirContractTermActor;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractTermActor.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'entity') then
        result.entity := ParseReference{Resource}(child, path+'/entity') {b}
      else if (child.baseName = 'role') then
        result.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractTermActor(xml : TXmlBuilder; name : string; elem : TFhirContractTermActor);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'entity', elem.entity);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractTermActor(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTermActor(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTermActor(jsn : TJsonObject) : TFhirContractTermActor;
begin
  result := TFhirContractTermActor.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('entity') then
        result.entity := ParseReference{Resource}(jsn.vObj['entity']);{q}
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContractTermActor(json : TJSONWriter; name : string; elem : TFhirContractTermActor; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(json, 'entity', elem.entity); {a}
  if (SummaryOption in [soFull, soData]) and (elem.roleList.Count > 0) then
  begin
    json.valueArray('role');
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.roleList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeContractTermActor(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractTermActor; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ContractTermActor');
  end;
  composeBackboneElement(this, 'ContractTermActor', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'ContractTermActor', 'entity', elem.entityElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'ContractTermActor', 'role', elem.roleList[i], i);
end;

function TFHIRXmlParser.ParseContractTermValuedItem(element : IXmlDomElement; path : string) : TFhirContractTermValuedItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractTermValuedItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'entityCodeableConcept') then
        result.entity := ParseCodeableConcept(child, path+'/entityCodeableConcept'){x.3}
      else if (child.baseName = 'entityReference') then
        result.entity := ParseReference(child, path+'/entityReference') {a}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'effectiveTime') then
        result.effectiveTimeElement := ParseDateTime(child, path+'/effectiveTime') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'unitPrice') then
        result.unitPrice := ParseQuantity(child, path+'/unitPrice') {b}
      else if (child.baseName = 'factor') then
        result.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.baseName = 'points') then
        result.pointsElement := ParseDecimal(child, path+'/points') {b}
      else if (child.baseName = 'net') then
        result.net := ParseQuantity(child, path+'/net') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractTermValuedItem(xml : TXmlBuilder; name : string; elem : TFhirContractTermValuedItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'entityCodeableConcept', TFhirCodeableConcept(elem.entity))
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) {2} then
    ComposeReference(xml, 'entityReference', TFhirReference(elem.entity));
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'effectiveTime', elem.effectiveTimeElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'unitPrice', elem.unitPrice);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'points', elem.pointsElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'net', elem.net);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractTermValuedItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTermValuedItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTermValuedItem(jsn : TJsonObject) : TFhirContractTermValuedItem;
begin
  result := TFhirContractTermValuedItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('entityCodeableConcept') {a4} then
      result.entity := ParseCodeableConcept(jsn.vObj['entityCodeableConcept']);
    if jsn.has('entityReference') {a3} then
      result.entity := ParseReference(jsn.vObj['entityReference']);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('effectiveTime') or jsn.has('_effectiveTime') then
        result.effectiveTimeElement := ParseDateTime(jsn['effectiveTime'], jsn.vObj['_effectiveTime']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseQuantity(jsn.vObj['unitPrice']);{q}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('points') or jsn.has('_points') then
        result.pointsElement := ParseDecimal(jsn['points'], jsn.vObj['_points']);{q}
    if jsn.has('net') then
        result.net := ParseQuantity(jsn.vObj['net']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContractTermValuedItem(json : TJSONWriter; name : string; elem : TFhirContractTermValuedItem; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'entityCodeableConcept', TFhirCodeableConcept(elem.entity)) 
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) then
    ComposeReference(json, 'entityReference', TFhirReference(elem.entity));
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'effectiveTime', elem.effectiveTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'effectiveTime', elem.effectiveTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'net', elem.net); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeContractTermValuedItem(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractTermValuedItem; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ContractTermValuedItem');
  end;
  composeBackboneElement(this, 'ContractTermValuedItem', name, elem, index);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ContractTermValuedItem', 'entityCodeableConcept', TFhirCodeableConcept(elem.entity), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) {2} then
    ComposeReference(this, 'ContractTermValuedItem', 'entityReference', TFhirReference(elem.entity), -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'ContractTermValuedItem', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'ContractTermValuedItem', 'effectiveTime', elem.effectiveTimeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ContractTermValuedItem', 'quantity', elem.quantityElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ContractTermValuedItem', 'unitPrice', elem.unitPriceElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ContractTermValuedItem', 'factor', elem.factorElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ContractTermValuedItem', 'points', elem.pointsElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ContractTermValuedItem', 'net', elem.netElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseContractFriendly(element : IXmlDomElement; path : string) : TFhirContractFriendly;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractFriendly.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'contentAttachment') then
        result.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.baseName = 'contentReference') then
        result.content := ParseReference(child, path+'/contentReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractFriendly(xml : TXmlBuilder; name : string; elem : TFhirContractFriendly);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (SummaryOption in [soFull, soData]) and (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractFriendly(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractFriendly(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractFriendly(jsn : TJsonObject) : TFhirContractFriendly;
begin
  result := TFhirContractFriendly.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContractFriendly(json : TJSONWriter; name : string; elem : TFhirContractFriendly; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (SummaryOption in [soFull, soData]) and (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content));
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeContractFriendly(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractFriendly; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ContractFriendly');
  end;
  composeBackboneElement(this, 'ContractFriendly', name, elem, index);
  if (SummaryOption in [soFull, soData]) and (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ContractFriendly', 'contentAttachment', TFhirAttachment(elem.content), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'ContractFriendly', 'contentReference', TFhirReference(elem.content), -1);
end;

function TFHIRXmlParser.ParseContractLegal(element : IXmlDomElement; path : string) : TFhirContractLegal;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractLegal.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'contentAttachment') then
        result.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.baseName = 'contentReference') then
        result.content := ParseReference(child, path+'/contentReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractLegal(xml : TXmlBuilder; name : string; elem : TFhirContractLegal);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (SummaryOption in [soFull, soData]) and (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractLegal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractLegal(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractLegal(jsn : TJsonObject) : TFhirContractLegal;
begin
  result := TFhirContractLegal.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContractLegal(json : TJSONWriter; name : string; elem : TFhirContractLegal; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (SummaryOption in [soFull, soData]) and (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content));
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeContractLegal(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractLegal; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ContractLegal');
  end;
  composeBackboneElement(this, 'ContractLegal', name, elem, index);
  if (SummaryOption in [soFull, soData]) and (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ContractLegal', 'contentAttachment', TFhirAttachment(elem.content), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'ContractLegal', 'contentReference', TFhirReference(elem.content), -1);
end;

function TFHIRXmlParser.ParseContractRule(element : IXmlDomElement; path : string) : TFhirContractRule;
var
  child : IXMLDOMElement;
begin
  result := TFhirContractRule.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'contentAttachment') then
        result.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.baseName = 'contentReference') then
        result.content := ParseReference(child, path+'/contentReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContractRule(xml : TXmlBuilder; name : string; elem : TFhirContractRule);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (SummaryOption in [soFull, soData]) and (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContractRule(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractRule(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractRule(jsn : TJsonObject) : TFhirContractRule;
begin
  result := TFhirContractRule.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContractRule(json : TJSONWriter; name : string; elem : TFhirContractRule; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (SummaryOption in [soFull, soData]) and (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content));
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeContractRule(parent :  TRDFComplex; parentType, name : String; elem : TFhirContractRule; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ContractRule');
  end;
  composeBackboneElement(this, 'ContractRule', name, elem, index);
  if (SummaryOption in [soFull, soData]) and (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ContractRule', 'contentAttachment', TFhirAttachment(elem.content), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'ContractRule', 'contentReference', TFhirReference(elem.content), -1);
end;

function TFHIRXmlParser.ParseContract(element : IXmlDomElement; path : string) : TFhirContract;
var
  child : IXMLDOMElement;
begin
  result := TFhirContract.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'issued') then
        result.issuedElement := ParseDateTime(child, path+'/issued') {b}
      else if (child.baseName = 'applies') then
        result.applies := ParsePeriod(child, path+'/applies') {b}
      else if (child.baseName = 'subject') then
        result.subjectList.Add(ParseReference{TFhirReference}(child, path+'/subject')){y.2}
      else if (child.baseName = 'authority') then
        result.authorityList.Add(ParseReference{TFhirOrganization}(child, path+'/authority')){y.2}
      else if (child.baseName = 'domain') then
        result.domainList.Add(ParseReference{TFhirLocation}(child, path+'/domain')){y.2}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'subType') then
        result.subTypeList.Add(ParseCodeableConcept(child, path+'/subType')){y.2}
      else if (child.baseName = 'action') then
        result.actionList.Add(ParseCodeableConcept(child, path+'/action')){y.2}
      else if (child.baseName = 'actionReason') then
        result.actionReasonList.Add(ParseCodeableConcept(child, path+'/actionReason')){y.2}
      else if (child.baseName = 'actor') then
        result.actorList.Add(ParseContractActor(child, path+'/actor')){y.2}
      else if (child.baseName = 'valuedItem') then
        result.valuedItemList.Add(ParseContractValuedItem(child, path+'/valuedItem')){y.2}
      else if (child.baseName = 'signer') then
        result.signerList.Add(ParseContractSigner(child, path+'/signer')){y.2}
      else if (child.baseName = 'term') then
        result.termList.Add(ParseContractTerm(child, path+'/term')){y.2}
      else if (child.baseName = 'bindingAttachment') then
        result.binding := ParseAttachment(child, path+'/bindingAttachment'){x.3}
      else if (child.baseName = 'bindingReference') then
        result.binding := ParseReference(child, path+'/bindingReference') {a}
      else if (child.baseName = 'friendly') then
        result.friendlyList.Add(ParseContractFriendly(child, path+'/friendly')){y.2}
      else if (child.baseName = 'legal') then
        result.legalList.Add(ParseContractLegal(child, path+'/legal')){y.2}
      else if (child.baseName = 'rule') then
        result.ruleList.Add(ParseContractRule(child, path+'/rule')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContract(xml : TXmlBuilder; name : string; elem : TFhirContract);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'issued', elem.issuedElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'applies', elem.applies);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'subject', elem.subjectList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.authorityList.Count - 1 do
      ComposeReference{TFhirOrganization}(xml, 'authority', elem.authorityList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.domainList.Count - 1 do
      ComposeReference{TFhirLocation}(xml, 'domain', elem.domainList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.subTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'subType', elem.subTypeList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(xml, 'action', elem.actionList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'actionReason', elem.actionReasonList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actorList.Count - 1 do
      ComposeContractActor(xml, 'actor', elem.actorList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractValuedItem(xml, 'valuedItem', elem.valuedItemList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.signerList.Count - 1 do
      ComposeContractSigner(xml, 'signer', elem.signerList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.termList.Count - 1 do
      ComposeContractTerm(xml, 'term', elem.termList[i]);
  if (SummaryOption in [soFull, soData]) and (elem.binding is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'bindingAttachment', TFhirAttachment(elem.binding))
  else if (SummaryOption in [soFull, soData]) and (elem.binding is TFhirReference) {2} then
    ComposeReference(xml, 'bindingReference', TFhirReference(elem.binding));
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.friendlyList.Count - 1 do
      ComposeContractFriendly(xml, 'friendly', elem.friendlyList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.legalList.Count - 1 do
      ComposeContractLegal(xml, 'legal', elem.legalList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeContractRule(xml, 'rule', elem.ruleList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContract(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContract(jsn)); {2}
end;

function TFHIRJsonParser.ParseContract(jsn : TJsonObject) : TFhirContract;
begin
  result := TFhirContract.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := ParseDateTime(jsn['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('applies') then
        result.applies := ParsePeriod(jsn.vObj['applies']);{q}
    if jsn.has('subject') then
      iterateArray(jsn.vArr['subject'], result.subjectList, parseReference{TFhirReference});
    if jsn.has('authority') then
      iterateArray(jsn.vArr['authority'], result.authorityList, parseReference{TFhirOrganization});
    if jsn.has('domain') then
      iterateArray(jsn.vArr['domain'], result.domainList, parseReference{TFhirLocation});
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('subType') then
      iterateArray(jsn.vArr['subType'], result.subTypeList, parseCodeableConcept);
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseCodeableConcept);
    if jsn.has('actionReason') then
      iterateArray(jsn.vArr['actionReason'], result.actionReasonList, parseCodeableConcept);
    if jsn.has('actor') then
      iterateArray(jsn.vArr['actor'], result.actorList, parseContractActor);
    if jsn.has('valuedItem') then
      iterateArray(jsn.vArr['valuedItem'], result.valuedItemList, parseContractValuedItem);
    if jsn.has('signer') then
      iterateArray(jsn.vArr['signer'], result.signerList, parseContractSigner);
    if jsn.has('term') then
      iterateArray(jsn.vArr['term'], result.termList, parseContractTerm);
    if jsn.has('bindingAttachment') {a4} then
      result.binding := ParseAttachment(jsn.vObj['bindingAttachment']);
    if jsn.has('bindingReference') {a3} then
      result.binding := ParseReference(jsn.vObj['bindingReference']);
    if jsn.has('friendly') then
      iterateArray(jsn.vArr['friendly'], result.friendlyList, parseContractFriendly);
    if jsn.has('legal') then
      iterateArray(jsn.vArr['legal'], result.legalList, parseContractLegal);
    if jsn.has('rule') then
      iterateArray(jsn.vArr['rule'], result.ruleList, parseContractRule);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContract(json : TJSONWriter; name : string; elem : TFhirContract; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'applies', elem.applies); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.subjectList.Count > 0) then
  begin
    json.valueArray('subject');
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.subjectList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.authorityList.Count > 0) then
  begin
    json.valueArray('authority');
    for i := 0 to elem.authorityList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.authorityList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.domainList.Count > 0) then
  begin
    json.valueArray('domain');
    for i := 0 to elem.domainList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '', elem.domainList[i]); {z - Reference(Location)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.subTypeList.Count > 0) then
  begin
    json.valueArray('subType');
    for i := 0 to elem.subTypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.subTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.actionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.actionReasonList.Count > 0) then
  begin
    json.valueArray('actionReason');
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.actionReasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.actorList.Count > 0) then
  begin
    json.valueArray('actor');
    for i := 0 to elem.actorList.Count - 1 do
      ComposeContractActor(json, '', elem.actorList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.valuedItemList.Count > 0) then
  begin
    json.valueArray('valuedItem');
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractValuedItem(json, '', elem.valuedItemList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.signerList.Count > 0) then
  begin
    json.valueArray('signer');
    for i := 0 to elem.signerList.Count - 1 do
      ComposeContractSigner(json, '', elem.signerList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.termList.Count > 0) then
  begin
    json.valueArray('term');
    for i := 0 to elem.termList.Count - 1 do
      ComposeContractTerm(json, '', elem.termList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.binding is TFhirAttachment) then 
    ComposeAttachment(json, 'bindingAttachment', TFhirAttachment(elem.binding)) 
  else if (SummaryOption in [soFull, soData]) and (elem.binding is TFhirReference) then
    ComposeReference(json, 'bindingReference', TFhirReference(elem.binding));
  if (SummaryOption in [soFull, soData]) and (elem.friendlyList.Count > 0) then
  begin
    json.valueArray('friendly');
    for i := 0 to elem.friendlyList.Count - 1 do
      ComposeContractFriendly(json, '', elem.friendlyList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.legalList.Count > 0) then
  begin
    json.valueArray('legal');
    for i := 0 to elem.legalList.Count - 1 do
      ComposeContractLegal(json, '', elem.legalList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.ruleList.Count > 0) then
  begin
    json.valueArray('rule');
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeContractRule(json, '', elem.ruleList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeContract(parent :  TRDFComplex; parentType, name : String; elem : TFhirContract; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Contract');
  end;
  composeDomainResource(this, 'Contract', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Contract', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Contract', 'issued', elem.issuedElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Contract', 'applies', elem.appliesElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Contract', 'subject', elem.subjectList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.authorityList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'Contract', 'authority', elem.authorityList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.domainList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'Contract', 'domain', elem.domainList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Contract', 'type', elem.type_Element, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.subTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract', 'subType', elem.subTypeList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract', 'action', elem.actionList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract', 'actionReason', elem.actionReasonList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actorList.Count - 1 do
      ComposeContractActor(this, 'Contract', 'actor', elem.actorList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractValuedItem(this, 'Contract', 'valuedItem', elem.valuedItemList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.signerList.Count - 1 do
      ComposeContractSigner(this, 'Contract', 'signer', elem.signerList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.termList.Count - 1 do
      ComposeContractTerm(this, 'Contract', 'term', elem.termList[i], i);
  if (SummaryOption in [soFull, soData]) and (elem.binding is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract', 'bindingAttachment', TFhirAttachment(elem.binding), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.binding is TFhirReference) {2} then
    ComposeReference(this, 'Contract', 'bindingReference', TFhirReference(elem.binding), -1);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.friendlyList.Count - 1 do
      ComposeContractFriendly(this, 'Contract', 'friendly', elem.friendlyList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.legalList.Count - 1 do
      ComposeContractLegal(this, 'Contract', 'legal', elem.legalList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeContractRule(this, 'Contract', 'rule', elem.ruleList[i], i);
end;

function TFHIRXmlParser.ParseCoverage(element : IXmlDomElement; path : string) : TFhirCoverage;
var
  child : IXMLDOMElement;
begin
  result := TFhirCoverage.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'issuer') then
        result.issuer := ParseReference{TFhirOrganization}(child, path+'/issuer') {b}
      else if (child.baseName = 'bin') then
        result.bin := ParseIdentifier(child, path+'/bin') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'subscriberId') then
        result.subscriberId := ParseIdentifier(child, path+'/subscriberId') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'group') then
        result.groupElement := ParseString(child, path+'/group') {b}
      else if (child.baseName = 'plan') then
        result.planElement := ParseString(child, path+'/plan') {b}
      else if (child.baseName = 'subPlan') then
        result.subPlanElement := ParseString(child, path+'/subPlan') {b}
      else if (child.baseName = 'dependent') then
        result.dependentElement := ParsePositiveInt(child, path+'/dependent') {b}
      else if (child.baseName = 'sequence') then
        result.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.baseName = 'subscriber') then
        result.subscriber := ParseReference{TFhirPatient}(child, path+'/subscriber') {b}
      else if (child.baseName = 'network') then
        result.network := ParseIdentifier(child, path+'/network') {b}
      else if (child.baseName = 'contract') then
        result.contractList.Add(ParseReference{TFhirContract}(child, path+'/contract')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCoverage(xml : TXmlBuilder; name : string; elem : TFhirCoverage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'issuer', elem.issuer);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'bin', elem.bin);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'subscriberId', elem.subscriberId);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'group', elem.groupElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'plan', elem.planElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'subPlan', elem.subPlanElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'dependent', elem.dependentElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(xml, 'subscriber', elem.subscriber);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'network', elem.network);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.contractList.Count - 1 do
      ComposeReference{TFhirContract}(xml, 'contract', elem.contractList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoverage(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoverage(jsn : TJsonObject) : TFhirCoverage;
begin
  result := TFhirCoverage.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('issuer') then
        result.issuer := ParseReference{TFhirOrganization}(jsn.vObj['issuer']);{q}
    if jsn.has('bin') then
        result.bin := ParseIdentifier(jsn.vObj['bin']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('subscriberId') then
        result.subscriberId := ParseIdentifier(jsn.vObj['subscriberId']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('group') or jsn.has('_group') then
        result.groupElement := ParseString(jsn['group'], jsn.vObj['_group']);{q}
    if jsn.has('plan') or jsn.has('_plan') then
        result.planElement := ParseString(jsn['plan'], jsn.vObj['_plan']);{q}
    if jsn.has('subPlan') or jsn.has('_subPlan') then
        result.subPlanElement := ParseString(jsn['subPlan'], jsn.vObj['_subPlan']);{q}
    if jsn.has('dependent') or jsn.has('_dependent') then
        result.dependentElement := ParsePositiveInt(jsn['dependent'], jsn.vObj['_dependent']);{q}
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('subscriber') then
        result.subscriber := ParseReference{TFhirPatient}(jsn.vObj['subscriber']);{q}
    if jsn.has('network') then
        result.network := ParseIdentifier(jsn.vObj['network']);{q}
    if jsn.has('contract') then
      iterateArray(jsn.vArr['contract'], result.contractList, parseReference{TFhirContract});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCoverage(json : TJSONWriter; name : string; elem : TFhirCoverage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'issuer', elem.issuer); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'bin', elem.bin); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'subscriberId', elem.subscriberId); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'group', elem.groupElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'group', elem.groupElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'plan', elem.planElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'plan', elem.planElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'subPlan', elem.subPlanElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'subPlan', elem.subPlanElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'dependent', elem.dependentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'dependent', elem.dependentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(json, 'subscriber', elem.subscriber); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'network', elem.network); {a}
  if (SummaryOption in [soFull, soData]) and (elem.contractList.Count > 0) then
  begin
    json.valueArray('contract');
    for i := 0 to elem.contractList.Count - 1 do
      ComposeReference{TFhirContract}(json, '', elem.contractList[i]); {z - Reference(Contract)}
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeCoverage(parent :  TRDFComplex; parentType, name : String; elem : TFhirCoverage; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Coverage');
  end;
  composeDomainResource(this, 'Coverage', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Coverage', 'issuer', elem.issuerElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Coverage', 'bin', elem.binElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Coverage', 'period', elem.periodElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'Coverage', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Coverage', 'subscriberId', elem.subscriberIdElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Coverage', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage', 'group', elem.groupElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage', 'plan', elem.planElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage', 'subPlan', elem.subPlanElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Coverage', 'dependent', elem.dependentElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Coverage', 'sequence', elem.sequenceElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(this, 'Coverage', 'subscriber', elem.subscriberElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Coverage', 'network', elem.networkElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.contractList.Count - 1 do
      ComposeReference{TFhirContract}(this, 'Coverage', 'contract', elem.contractList[i], i);
end;

function TFHIRXmlParser.ParseDataElementContact(element : IXmlDomElement; path : string) : TFhirDataElementContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirDataElementContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDataElementContact(xml : TXmlBuilder; name : string; elem : TFhirDataElementContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDataElementContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDataElementContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseDataElementContact(jsn : TJsonObject) : TFhirDataElementContact;
begin
  result := TFhirDataElementContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDataElementContact(json : TJSONWriter; name : string; elem : TFhirDataElementContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeDataElementContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirDataElementContact; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DataElementContact');
  end;
  composeBackboneElement(this, 'DataElementContact', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DataElementContact', 'name', elem.nameElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'DataElementContact', 'telecom', elem.telecomList[i], i);
end;

function TFHIRXmlParser.ParseDataElementMapping(element : IXmlDomElement; path : string) : TFhirDataElementMapping;
var
  child : IXMLDOMElement;
begin
  result := TFhirDataElementMapping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identity') then
        result.identityElement := ParseId(child, path+'/identity') {b}
      else if (child.baseName = 'uri') then
        result.uriElement := ParseUri(child, path+'/uri') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'comments') then
        result.commentsElement := ParseString(child, path+'/comments') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDataElementMapping(xml : TXmlBuilder; name : string; elem : TFhirDataElementMapping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'identity', elem.identityElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'uri', elem.uriElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comments', elem.commentsElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDataElementMapping(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDataElementMapping(jsn)); {2}
end;

function TFHIRJsonParser.ParseDataElementMapping(jsn : TJsonObject) : TFhirDataElementMapping;
begin
  result := TFhirDataElementMapping.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identity') or jsn.has('_identity') then
        result.identityElement := ParseId(jsn['identity'], jsn.vObj['_identity']);{q}
    if jsn.has('uri') or jsn.has('_uri') then
        result.uriElement := ParseUri(jsn['uri'], jsn.vObj['_uri']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsElement := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDataElementMapping(json : TJSONWriter; name : string; elem : TFhirDataElementMapping; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'identity', elem.identityElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'identity', elem.identityElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comments', elem.commentsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comments', elem.commentsElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeDataElementMapping(parent :  TRDFComplex; parentType, name : String; elem : TFhirDataElementMapping; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DataElementMapping');
  end;
  composeBackboneElement(this, 'DataElementMapping', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'DataElementMapping', 'identity', elem.identityElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'DataElementMapping', 'uri', elem.uriElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DataElementMapping', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DataElementMapping', 'comments', elem.commentsElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseDataElement(element : IXmlDomElement; path : string) : TFhirDataElement;
var
  child : IXMLDOMElement;
begin
  result := TFhirDataElement.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseDataElementContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'useContext') then
        result.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.baseName = 'copyright') then
        result.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.baseName = 'stringency') then
        result.stringencyElement := ParseEnum(CODES_TFhirDataelementStringencyEnum, SYSTEMS_TFhirDataelementStringencyEnum, path+'/stringency', child){1a}
      else if (child.baseName = 'mapping') then
        result.mappingList.Add(ParseDataElementMapping(child, path+'/mapping')){y.2}
      else if (child.baseName = 'element') then
        result.elementList.Add(ParseElementDefinition(child, path+'/element')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDataElement(xml : TXmlBuilder; name : string; elem : TFhirDataElement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeDataElementContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyright', elem.copyrightElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'stringency', elem.StringencyElement, CODES_TFhirDataelementStringencyEnum);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeDataElementMapping(xml, 'mapping', elem.mappingList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(xml, 'element', elem.elementList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDataElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDataElement(jsn)); {2}
end;

function TFHIRJsonParser.ParseDataElement(jsn : TJsonObject) : TFhirDataElement;
begin
  result := TFhirDataElement.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseDataElementContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('stringency') or jsn.has('_stringency')  then
      result.stringencyElement := parseEnum(jsn.path+'/stringency', jsn['stringency'], jsn.vObj['_stringency'], CODES_TFhirDataelementStringencyEnum, SYSTEMS_TFhirDataelementStringencyEnum);
    if jsn.has('mapping') then
      iterateArray(jsn.vArr['mapping'], result.mappingList, parseDataElementMapping);
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseElementDefinition);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDataElement(json : TJSONWriter; name : string; elem : TFhirDataElement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeDataElementContact(json, '', elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.useContextList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'stringency', elem.StringencyElement, CODES_TFhirDataelementStringencyEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'stringency', elem.StringencyElement, CODES_TFhirDataelementStringencyEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.mappingList.Count > 0) then
  begin
    json.valueArray('mapping');
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeDataElementMapping(json, '', elem.mappingList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.elementList.Count > 0) then
  begin
    json.valueArray('element');
    for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(json, '', elem.elementList[i]); {z - ElementDefinition}
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeDataElement(parent :  TRDFComplex; parentType, name : String; elem : TFhirDataElement; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DataElement');
  end;
  composeDomainResource(this, 'DataElement', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'DataElement', 'url', elem.urlElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DataElement', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DataElement', 'version', elem.versionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DataElement', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DataElement', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'DataElement', 'experimental', elem.experimentalElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DataElement', 'publisher', elem.publisherElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeDataElementContact(this, 'DataElement', 'contact', elem.contactList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'DataElement', 'date', elem.dateElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(this, 'DataElement', 'useContext', elem.useContextList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DataElement', 'copyright', elem.copyrightElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DataElement', 'stringency', elem.StringencyElement, CODES_TFhirDataelementStringencyEnum, SYSTEMS_TFhirDataelementStringencyEnum, -1);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeDataElementMapping(this, 'DataElement', 'mapping', elem.mappingList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(this, 'DataElement', 'element', elem.elementList[i], i);
end;

function TFHIRXmlParser.ParseDetectedIssueMitigation(element : IXmlDomElement; path : string) : TFhirDetectedIssueMitigation;
var
  child : IXMLDOMElement;
begin
  result := TFhirDetectedIssueMitigation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'action') then
        result.action := ParseCodeableConcept(child, path+'/action') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{TFhirPractitioner}(child, path+'/author') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDetectedIssueMitigation(xml : TXmlBuilder; name : string; elem : TFhirDetectedIssueMitigation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'action', elem.action);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'author', elem.author);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDetectedIssueMitigation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDetectedIssueMitigation(jsn)); {2}
end;

function TFHIRJsonParser.ParseDetectedIssueMitigation(jsn : TJsonObject) : TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('action') then
        result.action := ParseCodeableConcept(jsn.vObj['action']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('author') then
        result.author := ParseReference{TFhirPractitioner}(jsn.vObj['author']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDetectedIssueMitigation(json : TJSONWriter; name : string; elem : TFhirDetectedIssueMitigation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'action', elem.action); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'author', elem.author); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeDetectedIssueMitigation(parent :  TRDFComplex; parentType, name : String; elem : TFhirDetectedIssueMitigation; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DetectedIssueMitigation');
  end;
  composeBackboneElement(this, 'DetectedIssueMitigation', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'DetectedIssueMitigation', 'action', elem.actionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'DetectedIssueMitigation', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'DetectedIssueMitigation', 'author', elem.authorElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseDetectedIssue(element : IXmlDomElement; path : string) : TFhirDetectedIssue;
var
  child : IXMLDOMElement;
begin
  result := TFhirDetectedIssue.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'severity') then
        result.severityElement := ParseEnum(CODES_TFhirDetectedissueSeverityEnum, SYSTEMS_TFhirDetectedissueSeverityEnum, path+'/severity', child){1a}
      else if (child.baseName = 'implicated') then
        result.implicatedList.Add(ParseReference{TFhirReference}(child, path+'/implicated')){y.2}
      else if (child.baseName = 'detail') then
        result.detailElement := ParseString(child, path+'/detail') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'reference') then
        result.referenceElement := ParseUri(child, path+'/reference') {b}
      else if (child.baseName = 'mitigation') then
        result.mitigationList.Add(ParseDetectedIssueMitigation(child, path+'/mitigation')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDetectedIssue(xml : TXmlBuilder; name : string; elem : TFhirDetectedIssue);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'severity', elem.SeverityElement, CODES_TFhirDetectedissueSeverityEnum);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.implicatedList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'implicated', elem.implicatedList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'detail', elem.detailElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'reference', elem.referenceElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.mitigationList.Count - 1 do
      ComposeDetectedIssueMitigation(xml, 'mitigation', elem.mitigationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDetectedIssue(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDetectedIssue(jsn)); {2}
end;

function TFHIRJsonParser.ParseDetectedIssue(jsn : TJsonObject) : TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityElement := parseEnum(jsn.path+'/severity', jsn['severity'], jsn.vObj['_severity'], CODES_TFhirDetectedissueSeverityEnum, SYSTEMS_TFhirDetectedissueSeverityEnum);
    if jsn.has('implicated') then
      iterateArray(jsn.vArr['implicated'], result.implicatedList, parseReference{TFhirReference});
    if jsn.has('detail') or jsn.has('_detail') then
        result.detailElement := ParseString(jsn['detail'], jsn.vObj['_detail']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceElement := ParseUri(jsn['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('mitigation') then
      iterateArray(jsn.vArr['mitigation'], result.mitigationList, parseDetectedIssueMitigation);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDetectedIssue(json : TJSONWriter; name : string; elem : TFhirDetectedIssue; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'severity', elem.SeverityElement, CODES_TFhirDetectedissueSeverityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'severity', elem.SeverityElement, CODES_TFhirDetectedissueSeverityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.implicatedList.Count > 0) then
  begin
    json.valueArray('implicated');
    for i := 0 to elem.implicatedList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.implicatedList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'detail', elem.detailElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'detail', elem.detailElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.mitigationList.Count > 0) then
  begin
    json.valueArray('mitigation');
    for i := 0 to elem.mitigationList.Count - 1 do
      ComposeDetectedIssueMitigation(json, '', elem.mitigationList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeDetectedIssue(parent :  TRDFComplex; parentType, name : String; elem : TFhirDetectedIssue; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DetectedIssue');
  end;
  composeDomainResource(this, 'DetectedIssue', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'DetectedIssue', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DetectedIssue', 'category', elem.categoryElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DetectedIssue', 'severity', elem.SeverityElement, CODES_TFhirDetectedissueSeverityEnum, SYSTEMS_TFhirDetectedissueSeverityEnum, -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.implicatedList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'DetectedIssue', 'implicated', elem.implicatedList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DetectedIssue', 'detail', elem.detailElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'DetectedIssue', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'DetectedIssue', 'author', elem.authorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'DetectedIssue', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'DetectedIssue', 'reference', elem.referenceElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.mitigationList.Count - 1 do
      ComposeDetectedIssueMitigation(this, 'DetectedIssue', 'mitigation', elem.mitigationList[i], i);
end;

function TFHIRXmlParser.ParseDevice(element : IXmlDomElement; path : string) : TFhirDevice;
var
  child : IXMLDOMElement;
begin
  result := TFhirDevice.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'note') then
        result.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirDevicestatusEnum, SYSTEMS_TFhirDevicestatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'manufacturer') then
        result.manufacturerElement := ParseString(child, path+'/manufacturer') {b}
      else if (child.baseName = 'model') then
        result.modelElement := ParseString(child, path+'/model') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'manufactureDate') then
        result.manufactureDateElement := ParseDateTime(child, path+'/manufactureDate') {b}
      else if (child.baseName = 'expiry') then
        result.expiryElement := ParseDateTime(child, path+'/expiry') {b}
      else if (child.baseName = 'udi') then
        result.udiElement := ParseString(child, path+'/udi') {b}
      else if (child.baseName = 'lotNumber') then
        result.lotNumberElement := ParseString(child, path+'/lotNumber') {b}
      else if (child.baseName = 'owner') then
        result.owner := ParseReference{TFhirOrganization}(child, path+'/owner') {b}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseContactPoint(child, path+'/contact')){y.2}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDevice(xml : TXmlBuilder; name : string; elem : TFhirDevice);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDevicestatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'manufacturer', elem.manufacturerElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'model', elem.modelElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'manufactureDate', elem.manufactureDateElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'expiry', elem.expiryElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'udi', elem.udiElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'lotNumber', elem.lotNumberElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'owner', elem.owner);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDevice(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDevice(jsn)); {2}
end;

function TFHIRJsonParser.ParseDevice(jsn : TJsonObject) : TFhirDevice;
begin
  result := TFhirDevice.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirDevicestatusEnum, SYSTEMS_TFhirDevicestatusEnum);
    if jsn.has('manufacturer') or jsn.has('_manufacturer') then
        result.manufacturerElement := ParseString(jsn['manufacturer'], jsn.vObj['_manufacturer']);{q}
    if jsn.has('model') or jsn.has('_model') then
        result.modelElement := ParseString(jsn['model'], jsn.vObj['_model']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('manufactureDate') or jsn.has('_manufactureDate') then
        result.manufactureDateElement := ParseDateTime(jsn['manufactureDate'], jsn.vObj['_manufactureDate']);{q}
    if jsn.has('expiry') or jsn.has('_expiry') then
        result.expiryElement := ParseDateTime(jsn['expiry'], jsn.vObj['_expiry']);{q}
    if jsn.has('udi') or jsn.has('_udi') then
        result.udiElement := ParseString(jsn['udi'], jsn.vObj['_udi']);{q}
    if jsn.has('lotNumber') or jsn.has('_lotNumber') then
        result.lotNumberElement := ParseString(jsn['lotNumber'], jsn.vObj['_lotNumber']);{q}
    if jsn.has('owner') then
        result.owner := ParseReference{TFhirOrganization}(jsn.vObj['owner']);{q}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactPoint);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDevice(json : TJSONWriter; name : string; elem : TFhirDevice; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDevicestatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDevicestatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'manufacturer', elem.manufacturerElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'manufacturer', elem.manufacturerElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'model', elem.modelElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'model', elem.modelElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'manufactureDate', elem.manufactureDateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'manufactureDate', elem.manufactureDateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'expiry', elem.expiryElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'expiry', elem.expiryElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'udi', elem.udiElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'udi', elem.udiElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'owner', elem.owner); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soData]) and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(json, '', elem.contactList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
end;

procedure TFHIRRDFComposer.ComposeDevice(parent :  TRDFComplex; parentType, name : String; elem : TFhirDevice; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Device');
  end;
  composeDomainResource(this, 'Device', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Device', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Device', 'type', elem.type_Element, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Device', 'note', elem.noteList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Device', 'status', elem.StatusElement, CODES_TFhirDevicestatusEnum, SYSTEMS_TFhirDevicestatusEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Device', 'manufacturer', elem.manufacturerElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Device', 'model', elem.modelElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Device', 'version', elem.versionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Device', 'manufactureDate', elem.manufactureDateElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Device', 'expiry', elem.expiryElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Device', 'udi', elem.udiElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Device', 'lotNumber', elem.lotNumberElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Device', 'owner', elem.ownerElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'Device', 'location', elem.locationElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(this, 'Device', 'patient', elem.patientElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(this, 'Device', 'contact', elem.contactList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Device', 'url', elem.urlElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseDeviceComponentProductionSpecification(element : IXmlDomElement; path : string) : TFhirDeviceComponentProductionSpecification;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceComponentProductionSpecification.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'specType') then
        result.specType := ParseCodeableConcept(child, path+'/specType') {b}
      else if (child.baseName = 'componentId') then
        result.componentId := ParseIdentifier(child, path+'/componentId') {b}
      else if (child.baseName = 'productionSpec') then
        result.productionSpecElement := ParseString(child, path+'/productionSpec') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceComponentProductionSpecification(xml : TXmlBuilder; name : string; elem : TFhirDeviceComponentProductionSpecification);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'specType', elem.specType);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'componentId', elem.componentId);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'productionSpec', elem.productionSpecElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceComponentProductionSpecification(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceComponentProductionSpecification(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceComponentProductionSpecification(jsn : TJsonObject) : TFhirDeviceComponentProductionSpecification;
begin
  result := TFhirDeviceComponentProductionSpecification.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('specType') then
        result.specType := ParseCodeableConcept(jsn.vObj['specType']);{q}
    if jsn.has('componentId') then
        result.componentId := ParseIdentifier(jsn.vObj['componentId']);{q}
    if jsn.has('productionSpec') or jsn.has('_productionSpec') then
        result.productionSpecElement := ParseString(jsn['productionSpec'], jsn.vObj['_productionSpec']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceComponentProductionSpecification(json : TJSONWriter; name : string; elem : TFhirDeviceComponentProductionSpecification; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'specType', elem.specType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'componentId', elem.componentId); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'productionSpec', elem.productionSpecElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'productionSpec', elem.productionSpecElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeDeviceComponentProductionSpecification(parent :  TRDFComplex; parentType, name : String; elem : TFhirDeviceComponentProductionSpecification; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DeviceComponentProductionSpecification');
  end;
  composeBackboneElement(this, 'DeviceComponentProductionSpecification', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DeviceComponentProductionSpecification', 'specType', elem.specTypeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'DeviceComponentProductionSpecification', 'componentId', elem.componentIdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DeviceComponentProductionSpecification', 'productionSpec', elem.productionSpecElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseDeviceComponent(element : IXmlDomElement; path : string) : TFhirDeviceComponent;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceComponent.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'lastSystemChange') then
        result.lastSystemChangeElement := ParseInstant(child, path+'/lastSystemChange') {b}
      else if (child.baseName = 'source') then
        result.source := ParseReference{TFhirDevice}(child, path+'/source') {b}
      else if (child.baseName = 'parent') then
        result.parent := ParseReference{TFhirDeviceComponent}(child, path+'/parent') {b}
      else if (child.baseName = 'operationalStatus') then
        result.operationalStatusList.Add(ParseCodeableConcept(child, path+'/operationalStatus')){y.2}
      else if (child.baseName = 'parameterGroup') then
        result.parameterGroup := ParseCodeableConcept(child, path+'/parameterGroup') {b}
      else if (child.baseName = 'measurementPrinciple') then
        result.measurementPrincipleElement := ParseEnum(CODES_TFhirMeasurementPrincipleEnum, SYSTEMS_TFhirMeasurementPrincipleEnum, path+'/measurementPrinciple', child){1a}
      else if (child.baseName = 'productionSpecification') then
        result.productionSpecificationList.Add(ParseDeviceComponentProductionSpecification(child, path+'/productionSpecification')){y.2}
      else if (child.baseName = 'languageCode') then
        result.languageCode := ParseCodeableConcept(child, path+'/languageCode') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceComponent(xml : TXmlBuilder; name : string; elem : TFhirDeviceComponent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'lastSystemChange', elem.lastSystemChangeElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(xml, 'source', elem.source);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDeviceComponent}(xml, 'parent', elem.parent);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.operationalStatusList.Count - 1 do
      ComposeCodeableConcept(xml, 'operationalStatus', elem.operationalStatusList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'parameterGroup', elem.parameterGroup);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'measurementPrinciple', elem.MeasurementPrincipleElement, CODES_TFhirMeasurementPrincipleEnum);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.productionSpecificationList.Count - 1 do
      ComposeDeviceComponentProductionSpecification(xml, 'productionSpecification', elem.productionSpecificationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'languageCode', elem.languageCode);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceComponent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceComponent(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceComponent(jsn : TJsonObject) : TFhirDeviceComponent;
begin
  result := TFhirDeviceComponent.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('lastSystemChange') or jsn.has('_lastSystemChange') then
        result.lastSystemChangeElement := ParseInstant(jsn['lastSystemChange'], jsn.vObj['_lastSystemChange']);{q}
    if jsn.has('source') then
        result.source := ParseReference{TFhirDevice}(jsn.vObj['source']);{q}
    if jsn.has('parent') then
        result.parent := ParseReference{TFhirDeviceComponent}(jsn.vObj['parent']);{q}
    if jsn.has('operationalStatus') then
      iterateArray(jsn.vArr['operationalStatus'], result.operationalStatusList, parseCodeableConcept);
    if jsn.has('parameterGroup') then
        result.parameterGroup := ParseCodeableConcept(jsn.vObj['parameterGroup']);{q}
    if jsn.has('measurementPrinciple') or jsn.has('_measurementPrinciple')  then
      result.measurementPrincipleElement := parseEnum(jsn.path+'/measurementPrinciple', jsn['measurementPrinciple'], jsn.vObj['_measurementPrinciple'], CODES_TFhirMeasurementPrincipleEnum, SYSTEMS_TFhirMeasurementPrincipleEnum);
    if jsn.has('productionSpecification') then
      iterateArray(jsn.vArr['productionSpecification'], result.productionSpecificationList, parseDeviceComponentProductionSpecification);
    if jsn.has('languageCode') then
        result.languageCode := ParseCodeableConcept(jsn.vObj['languageCode']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceComponent(json : TJSONWriter; name : string; elem : TFhirDeviceComponent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantValue(json, 'lastSystemChange', elem.lastSystemChangeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantProps(json, 'lastSystemChange', elem.lastSystemChangeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDeviceComponent}(json, 'parent', elem.parent); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.operationalStatusList.Count > 0) then
  begin
    json.valueArray('operationalStatus');
    for i := 0 to elem.operationalStatusList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.operationalStatusList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'parameterGroup', elem.parameterGroup); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'measurementPrinciple', elem.MeasurementPrincipleElement, CODES_TFhirMeasurementPrincipleEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'measurementPrinciple', elem.MeasurementPrincipleElement, CODES_TFhirMeasurementPrincipleEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.productionSpecificationList.Count > 0) then
  begin
    json.valueArray('productionSpecification');
    for i := 0 to elem.productionSpecificationList.Count - 1 do
      ComposeDeviceComponentProductionSpecification(json, '', elem.productionSpecificationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'languageCode', elem.languageCode); {a}
end;

procedure TFHIRRDFComposer.ComposeDeviceComponent(parent :  TRDFComplex; parentType, name : String; elem : TFhirDeviceComponent; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DeviceComponent');
  end;
  composeDomainResource(this, 'DeviceComponent', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DeviceComponent', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'DeviceComponent', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'DeviceComponent', 'lastSystemChange', elem.lastSystemChangeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(this, 'DeviceComponent', 'source', elem.sourceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDeviceComponent}(this, 'DeviceComponent', 'parent', elem.parentElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.operationalStatusList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceComponent', 'operationalStatus', elem.operationalStatusList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DeviceComponent', 'parameterGroup', elem.parameterGroupElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DeviceComponent', 'measurementPrinciple', elem.MeasurementPrincipleElement, CODES_TFhirMeasurementPrincipleEnum, SYSTEMS_TFhirMeasurementPrincipleEnum, -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.productionSpecificationList.Count - 1 do
      ComposeDeviceComponentProductionSpecification(this, 'DeviceComponent', 'productionSpecification', elem.productionSpecificationList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DeviceComponent', 'languageCode', elem.languageCodeElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseDeviceMetricCalibration(element : IXmlDomElement; path : string) : TFhirDeviceMetricCalibration;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceMetricCalibration.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirMetricCalibrationTypeEnum, SYSTEMS_TFhirMetricCalibrationTypeEnum, path+'/type', child){1a}
      else if (child.baseName = 'state') then
        result.stateElement := ParseEnum(CODES_TFhirMetricCalibrationStateEnum, SYSTEMS_TFhirMetricCalibrationStateEnum, path+'/state', child){1a}
      else if (child.baseName = 'time') then
        result.timeElement := ParseInstant(child, path+'/time') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceMetricCalibration(xml : TXmlBuilder; name : string; elem : TFhirDeviceMetricCalibration);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirMetricCalibrationTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'state', elem.StateElement, CODES_TFhirMetricCalibrationStateEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'time', elem.timeElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceMetricCalibration(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceMetricCalibration(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceMetricCalibration(jsn : TJsonObject) : TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirMetricCalibrationTypeEnum, SYSTEMS_TFhirMetricCalibrationTypeEnum);
    if jsn.has('state') or jsn.has('_state')  then
      result.stateElement := parseEnum(jsn.path+'/state', jsn['state'], jsn.vObj['_state'], CODES_TFhirMetricCalibrationStateEnum, SYSTEMS_TFhirMetricCalibrationStateEnum);
    if jsn.has('time') or jsn.has('_time') then
        result.timeElement := ParseInstant(jsn['time'], jsn.vObj['_time']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceMetricCalibration(json : TJSONWriter; name : string; elem : TFhirDeviceMetricCalibration; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirMetricCalibrationTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirMetricCalibrationTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'state', elem.StateElement, CODES_TFhirMetricCalibrationStateEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'state', elem.StateElement, CODES_TFhirMetricCalibrationStateEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantValue(json, 'time', elem.timeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantProps(json, 'time', elem.timeElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeDeviceMetricCalibration(parent :  TRDFComplex; parentType, name : String; elem : TFhirDeviceMetricCalibration; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DeviceMetricCalibration');
  end;
  composeBackboneElement(this, 'DeviceMetricCalibration', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DeviceMetricCalibration', 'type', elem.Type_Element, CODES_TFhirMetricCalibrationTypeEnum, SYSTEMS_TFhirMetricCalibrationTypeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DeviceMetricCalibration', 'state', elem.StateElement, CODES_TFhirMetricCalibrationStateEnum, SYSTEMS_TFhirMetricCalibrationStateEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'DeviceMetricCalibration', 'time', elem.timeElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseDeviceMetric(element : IXmlDomElement; path : string) : TFhirDeviceMetric;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceMetric.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'unit') then
        result.unit_ := ParseCodeableConcept(child, path+'/unit') {b}
      else if (child.baseName = 'source') then
        result.source := ParseReference{TFhirDevice}(child, path+'/source') {b}
      else if (child.baseName = 'parent') then
        result.parent := ParseReference{TFhirDeviceComponent}(child, path+'/parent') {b}
      else if (child.baseName = 'operationalStatus') then
        result.operationalStatusElement := ParseEnum(CODES_TFhirMetricOperationalStatusEnum, SYSTEMS_TFhirMetricOperationalStatusEnum, path+'/operationalStatus', child){1a}
      else if (child.baseName = 'color') then
        result.colorElement := ParseEnum(CODES_TFhirMetricColorEnum, SYSTEMS_TFhirMetricColorEnum, path+'/color', child){1a}
      else if (child.baseName = 'category') then
        result.categoryElement := ParseEnum(CODES_TFhirMetricCategoryEnum, SYSTEMS_TFhirMetricCategoryEnum, path+'/category', child){1a}
      else if (child.baseName = 'measurementPeriod') then
        result.measurementPeriod := ParseTiming(child, path+'/measurementPeriod') {b}
      else if (child.baseName = 'calibration') then
        result.calibrationList.Add(ParseDeviceMetricCalibration(child, path+'/calibration')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceMetric(xml : TXmlBuilder; name : string; elem : TFhirDeviceMetric);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'unit', elem.unit_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(xml, 'source', elem.source);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDeviceComponent}(xml, 'parent', elem.parent);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'operationalStatus', elem.OperationalStatusElement, CODES_TFhirMetricOperationalStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'color', elem.ColorElement, CODES_TFhirMetricColorEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'category', elem.CategoryElement, CODES_TFhirMetricCategoryEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(xml, 'measurementPeriod', elem.measurementPeriod);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.calibrationList.Count - 1 do
      ComposeDeviceMetricCalibration(xml, 'calibration', elem.calibrationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceMetric(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceMetric(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceMetric(jsn : TJsonObject) : TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('unit') then
        result.unit_ := ParseCodeableConcept(jsn.vObj['unit']);{q}
    if jsn.has('source') then
        result.source := ParseReference{TFhirDevice}(jsn.vObj['source']);{q}
    if jsn.has('parent') then
        result.parent := ParseReference{TFhirDeviceComponent}(jsn.vObj['parent']);{q}
    if jsn.has('operationalStatus') or jsn.has('_operationalStatus')  then
      result.operationalStatusElement := parseEnum(jsn.path+'/operationalStatus', jsn['operationalStatus'], jsn.vObj['_operationalStatus'], CODES_TFhirMetricOperationalStatusEnum, SYSTEMS_TFhirMetricOperationalStatusEnum);
    if jsn.has('color') or jsn.has('_color')  then
      result.colorElement := parseEnum(jsn.path+'/color', jsn['color'], jsn.vObj['_color'], CODES_TFhirMetricColorEnum, SYSTEMS_TFhirMetricColorEnum);
    if jsn.has('category') or jsn.has('_category')  then
      result.categoryElement := parseEnum(jsn.path+'/category', jsn['category'], jsn.vObj['_category'], CODES_TFhirMetricCategoryEnum, SYSTEMS_TFhirMetricCategoryEnum);
    if jsn.has('measurementPeriod') then
        result.measurementPeriod := ParseTiming(jsn.vObj['measurementPeriod']);{q}
    if jsn.has('calibration') then
      iterateArray(jsn.vArr['calibration'], result.calibrationList, parseDeviceMetricCalibration);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceMetric(json : TJSONWriter; name : string; elem : TFhirDeviceMetric; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'unit', elem.unit_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDeviceComponent}(json, 'parent', elem.parent); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'operationalStatus', elem.OperationalStatusElement, CODES_TFhirMetricOperationalStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'operationalStatus', elem.OperationalStatusElement, CODES_TFhirMetricOperationalStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'color', elem.ColorElement, CODES_TFhirMetricColorEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'color', elem.ColorElement, CODES_TFhirMetricColorEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'category', elem.CategoryElement, CODES_TFhirMetricCategoryEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'category', elem.CategoryElement, CODES_TFhirMetricCategoryEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(json, 'measurementPeriod', elem.measurementPeriod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.calibrationList.Count > 0) then
  begin
    json.valueArray('calibration');
    for i := 0 to elem.calibrationList.Count - 1 do
      ComposeDeviceMetricCalibration(json, '', elem.calibrationList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeDeviceMetric(parent :  TRDFComplex; parentType, name : String; elem : TFhirDeviceMetric; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DeviceMetric');
  end;
  composeDomainResource(this, 'DeviceMetric', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DeviceMetric', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'DeviceMetric', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DeviceMetric', 'unit', elem.unit_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(this, 'DeviceMetric', 'source', elem.sourceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDeviceComponent}(this, 'DeviceMetric', 'parent', elem.parentElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DeviceMetric', 'operationalStatus', elem.OperationalStatusElement, CODES_TFhirMetricOperationalStatusEnum, SYSTEMS_TFhirMetricOperationalStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DeviceMetric', 'color', elem.ColorElement, CODES_TFhirMetricColorEnum, SYSTEMS_TFhirMetricColorEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DeviceMetric', 'category', elem.CategoryElement, CODES_TFhirMetricCategoryEnum, SYSTEMS_TFhirMetricCategoryEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(this, 'DeviceMetric', 'measurementPeriod', elem.measurementPeriodElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.calibrationList.Count - 1 do
      ComposeDeviceMetricCalibration(this, 'DeviceMetric', 'calibration', elem.calibrationList[i], i);
end;

function TFHIRXmlParser.ParseDeviceUseRequest(element : IXmlDomElement; path : string) : TFhirDeviceUseRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceUseRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'bodySiteCodeableConcept') then
        result.bodySite := ParseCodeableConcept(child, path+'/bodySiteCodeableConcept'){x.3}
      else if (child.baseName = 'bodySiteReference') then
        result.bodySite := ParseReference(child, path+'/bodySiteReference') {a}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirDeviceUseRequestStatusEnum, SYSTEMS_TFhirDeviceUseRequestStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'device') then
        result.device := ParseReference{TFhirDevice}(child, path+'/device') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'indication') then
        result.indicationList.Add(ParseCodeableConcept(child, path+'/indication')){y.2}
      else if (child.baseName = 'notes') then
        result.notesList.Add(ParseString(child, path+'/notes')){y.2}
      else if (child.baseName = 'prnReason') then
        result.prnReasonList.Add(ParseCodeableConcept(child, path+'/prnReason')){y.2}
      else if (child.baseName = 'orderedOn') then
        result.orderedOnElement := ParseDateTime(child, path+'/orderedOn') {b}
      else if (child.baseName = 'recordedOn') then
        result.recordedOnElement := ParseDateTime(child, path+'/recordedOn') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'timingTiming') then
        result.timing := ParseTiming(child, path+'/timingTiming'){x.3}
      else if (child.baseName = 'timingPeriod') then
        result.timing := ParsePeriod(child, path+'/timingPeriod'){x.3}
      else if (child.baseName = 'timingDateTime') then
        result.timing := ParseDateTime(child, path+'/timingDateTime'){x.3}
      else if (child.baseName = 'priority') then
        result.priorityElement := ParseEnum(CODES_TFhirDeviceUseRequestPriorityEnum, SYSTEMS_TFhirDeviceUseRequestPriorityEnum, path+'/priority', child){1a}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceUseRequest(xml : TXmlBuilder; name : string; elem : TFhirDeviceUseRequest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirReference) {2} then
    ComposeReference(xml, 'bodySiteReference', TFhirReference(elem.bodySite));
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDeviceUseRequestStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(xml, 'device', elem.device);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'indication', elem.indicationList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeString(xml, 'notes', elem.notesList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.prnReasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'prnReason', elem.prnReasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'orderedOn', elem.orderedOnElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'recordedOn', elem.recordedOnElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(xml, 'timingTiming', TFhirTiming(elem.timing))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(elem.timing));
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'priority', elem.PriorityElement, CODES_TFhirDeviceUseRequestPriorityEnum);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceUseRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceUseRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceUseRequest(jsn : TJsonObject) : TFhirDeviceUseRequest;
begin
  result := TFhirDeviceUseRequest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('bodySiteCodeableConcept') {a4} then
      result.bodySite := ParseCodeableConcept(jsn.vObj['bodySiteCodeableConcept']);
    if jsn.has('bodySiteReference') {a3} then
      result.bodySite := ParseReference(jsn.vObj['bodySiteReference']);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirDeviceUseRequestStatusEnum, SYSTEMS_TFhirDeviceUseRequestStatusEnum);
    if jsn.has('device') then
        result.device := ParseReference{TFhirDevice}(jsn.vObj['device']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('indication') then
      iterateArray(jsn.vArr['indication'], result.indicationList, parseCodeableConcept);
      if jsn.has('notes') or jsn.has('_notes') then
      iteratePrimitiveArray(jsn.vArr['notes'], jsn.vArr['_notes'], result.notesList, parseString);
    if jsn.has('prnReason') then
      iterateArray(jsn.vArr['prnReason'], result.prnReasonList, parseCodeableConcept);
    if jsn.has('orderedOn') or jsn.has('_orderedOn') then
        result.orderedOnElement := ParseDateTime(jsn['orderedOn'], jsn.vObj['_orderedOn']);{q}
    if jsn.has('recordedOn') or jsn.has('_recordedOn') then
        result.recordedOnElement := ParseDateTime(jsn['recordedOn'], jsn.vObj['_recordedOn']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('timingTiming') {a4} then
      result.timing := ParseTiming(jsn.vObj['timingTiming']);
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('timingDateTime') or jsn.has('_timingDateTime') then
      result.timing := parseDateTime(jsn['timingDateTime'], jsn.vObj['_timingDateTime']);
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn.path+'/priority', jsn['priority'], jsn.vObj['_priority'], CODES_TFhirDeviceUseRequestPriorityEnum, SYSTEMS_TFhirDeviceUseRequestPriorityEnum);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceUseRequest(json : TJSONWriter; name : string; elem : TFhirDeviceUseRequest; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirReference) then
    ComposeReference(json, 'bodySiteReference', TFhirReference(elem.bodySite));
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDeviceUseRequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDeviceUseRequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(json, 'device', elem.device); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.indicationList.Count > 0) then
  begin
    json.valueArray('indication');
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.indicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.notesList.Count > 0) then
  begin
    json.valueArray('notes');
    ext := false;
    for i := 0 to elem.notesList.Count - 1 do
    begin
      ext := ext or ((elem.notesList[i].id <> '') or (elem.notesList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.notesList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_notes');
      for i := 0 to elem.notesList.Count - 1 do
        ComposeStringProps(json, '',elem.notesList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.prnReasonList.Count > 0) then
  begin
    json.valueArray('prnReason');
    for i := 0 to elem.prnReasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.prnReasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'orderedOn', elem.orderedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'orderedOn', elem.orderedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'recordedOn', elem.recordedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'recordedOn', elem.recordedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirTiming) then 
    ComposeTiming(json, 'timingTiming', TFhirTiming(elem.timing)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
    ComposeDateTimeProps(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirDeviceUseRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirDeviceUseRequestPriorityEnum, false);
end;

procedure TFHIRRDFComposer.ComposeDeviceUseRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirDeviceUseRequest; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DeviceUseRequest');
  end;
  composeDomainResource(this, 'DeviceUseRequest', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'DeviceUseRequest', 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirReference) {2} then
    ComposeReference(this, 'DeviceUseRequest', 'bodySiteReference', TFhirReference(elem.bodySite), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DeviceUseRequest', 'status', elem.StatusElement, CODES_TFhirDeviceUseRequestStatusEnum, SYSTEMS_TFhirDeviceUseRequestStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(this, 'DeviceUseRequest', 'device', elem.deviceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'DeviceUseRequest', 'encounter', elem.encounterElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DeviceUseRequest', 'identifier', elem.identifierList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceUseRequest', 'indication', elem.indicationList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeString(this, 'DeviceUseRequest', 'notes', elem.notesList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.prnReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceUseRequest', 'prnReason', elem.prnReasonList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'DeviceUseRequest', 'orderedOn', elem.orderedOnElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'DeviceUseRequest', 'recordedOn', elem.recordedOnElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'DeviceUseRequest', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'DeviceUseRequest', 'timingTiming', TFhirTiming(elem.timing), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'DeviceUseRequest', 'timingPeriod', TFhirPeriod(elem.timing), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DeviceUseRequest', 'timingDateTime', TFhirDateTime(elem.timing), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DeviceUseRequest', 'priority', elem.PriorityElement, CODES_TFhirDeviceUseRequestPriorityEnum, SYSTEMS_TFhirDeviceUseRequestPriorityEnum, -1);
end;

function TFHIRXmlParser.ParseDeviceUseStatement(element : IXmlDomElement; path : string) : TFhirDeviceUseStatement;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceUseStatement.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'bodySiteCodeableConcept') then
        result.bodySite := ParseCodeableConcept(child, path+'/bodySiteCodeableConcept'){x.3}
      else if (child.baseName = 'bodySiteReference') then
        result.bodySite := ParseReference(child, path+'/bodySiteReference') {a}
      else if (child.baseName = 'whenUsed') then
        result.whenUsed := ParsePeriod(child, path+'/whenUsed') {b}
      else if (child.baseName = 'device') then
        result.device := ParseReference{TFhirDevice}(child, path+'/device') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'indication') then
        result.indicationList.Add(ParseCodeableConcept(child, path+'/indication')){y.2}
      else if (child.baseName = 'notes') then
        result.notesList.Add(ParseString(child, path+'/notes')){y.2}
      else if (child.baseName = 'recordedOn') then
        result.recordedOnElement := ParseDateTime(child, path+'/recordedOn') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'timingTiming') then
        result.timing := ParseTiming(child, path+'/timingTiming'){x.3}
      else if (child.baseName = 'timingPeriod') then
        result.timing := ParsePeriod(child, path+'/timingPeriod'){x.3}
      else if (child.baseName = 'timingDateTime') then
        result.timing := ParseDateTime(child, path+'/timingDateTime'){x.3}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceUseStatement(xml : TXmlBuilder; name : string; elem : TFhirDeviceUseStatement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirReference) {2} then
    ComposeReference(xml, 'bodySiteReference', TFhirReference(elem.bodySite));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'whenUsed', elem.whenUsed);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(xml, 'device', elem.device);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'indication', elem.indicationList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeString(xml, 'notes', elem.notesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'recordedOn', elem.recordedOnElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(xml, 'timingTiming', TFhirTiming(elem.timing))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(elem.timing));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceUseStatement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceUseStatement(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceUseStatement(jsn : TJsonObject) : TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('bodySiteCodeableConcept') {a4} then
      result.bodySite := ParseCodeableConcept(jsn.vObj['bodySiteCodeableConcept']);
    if jsn.has('bodySiteReference') {a3} then
      result.bodySite := ParseReference(jsn.vObj['bodySiteReference']);
    if jsn.has('whenUsed') then
        result.whenUsed := ParsePeriod(jsn.vObj['whenUsed']);{q}
    if jsn.has('device') then
        result.device := ParseReference{TFhirDevice}(jsn.vObj['device']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('indication') then
      iterateArray(jsn.vArr['indication'], result.indicationList, parseCodeableConcept);
      if jsn.has('notes') or jsn.has('_notes') then
      iteratePrimitiveArray(jsn.vArr['notes'], jsn.vArr['_notes'], result.notesList, parseString);
    if jsn.has('recordedOn') or jsn.has('_recordedOn') then
        result.recordedOnElement := ParseDateTime(jsn['recordedOn'], jsn.vObj['_recordedOn']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('timingTiming') {a4} then
      result.timing := ParseTiming(jsn.vObj['timingTiming']);
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('timingDateTime') or jsn.has('_timingDateTime') then
      result.timing := parseDateTime(jsn['timingDateTime'], jsn.vObj['_timingDateTime']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceUseStatement(json : TJSONWriter; name : string; elem : TFhirDeviceUseStatement; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirReference) then
    ComposeReference(json, 'bodySiteReference', TFhirReference(elem.bodySite));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'whenUsed', elem.whenUsed); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(json, 'device', elem.device); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.indicationList.Count > 0) then
  begin
    json.valueArray('indication');
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.indicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.notesList.Count > 0) then
  begin
    json.valueArray('notes');
    ext := false;
    for i := 0 to elem.notesList.Count - 1 do
    begin
      ext := ext or ((elem.notesList[i].id <> '') or (elem.notesList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.notesList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_notes');
      for i := 0 to elem.notesList.Count - 1 do
        ComposeStringProps(json, '',elem.notesList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'recordedOn', elem.recordedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'recordedOn', elem.recordedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirTiming) then 
    ComposeTiming(json, 'timingTiming', TFhirTiming(elem.timing)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
    ComposeDateTimeProps(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
  end;
end;

procedure TFHIRRDFComposer.ComposeDeviceUseStatement(parent :  TRDFComplex; parentType, name : String; elem : TFhirDeviceUseStatement; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DeviceUseStatement');
  end;
  composeDomainResource(this, 'DeviceUseStatement', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'DeviceUseStatement', 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirReference) {2} then
    ComposeReference(this, 'DeviceUseStatement', 'bodySiteReference', TFhirReference(elem.bodySite), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'DeviceUseStatement', 'whenUsed', elem.whenUsedElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(this, 'DeviceUseStatement', 'device', elem.deviceElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DeviceUseStatement', 'identifier', elem.identifierList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceUseStatement', 'indication', elem.indicationList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeString(this, 'DeviceUseStatement', 'notes', elem.notesList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'DeviceUseStatement', 'recordedOn', elem.recordedOnElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'DeviceUseStatement', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'DeviceUseStatement', 'timingTiming', TFhirTiming(elem.timing), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'DeviceUseStatement', 'timingPeriod', TFhirPeriod(elem.timing), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DeviceUseStatement', 'timingDateTime', TFhirDateTime(elem.timing), -1);
end;

function TFHIRXmlParser.ParseDiagnosticOrderEvent(element : IXmlDomElement; path : string) : TFhirDiagnosticOrderEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'description') then
        result.description := ParseCodeableConcept(child, path+'/description') {b}
      else if (child.baseName = 'dateTime') then
        result.dateTimeElement := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.baseName = 'actor') then
        result.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrderEvent(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderEvent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'description', elem.description);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'dateTime', elem.dateTimeElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticOrderEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticOrderEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseDiagnosticOrderEvent(jsn : TJsonObject) : TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum);
    if jsn.has('description') then
        result.description := ParseCodeableConcept(jsn.vObj['description']);{q}
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeElement := ParseDateTime(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('actor') then
        result.actor := ParseReference{Resource}(jsn.vObj['actor']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticOrderEvent(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderEvent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'description', elem.description); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'dateTime', elem.dateTimeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'dateTime', elem.dateTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(json, 'actor', elem.actor); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeDiagnosticOrderEvent(parent :  TRDFComplex; parentType, name : String; elem : TFhirDiagnosticOrderEvent; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DiagnosticOrderEvent');
  end;
  composeBackboneElement(this, 'DiagnosticOrderEvent', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DiagnosticOrderEvent', 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DiagnosticOrderEvent', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'DiagnosticOrderEvent', 'dateTime', elem.dateTimeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'DiagnosticOrderEvent', 'actor', elem.actorElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseDiagnosticOrderItem(element : IXmlDomElement; path : string) : TFhirDiagnosticOrderItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'specimen') then
        result.specimenList.Add(ParseReference{TFhirSpecimen}(child, path+'/specimen')){y.2}
      else if (child.baseName = 'bodySite') then
        result.bodySite := ParseCodeableConcept(child, path+'/bodySite') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'event') then
        result.eventList.Add(ParseDiagnosticOrderEvent(child, path+'/event')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrderItem(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderItem);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimenList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'bodySite', elem.bodySite);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(xml, 'event', elem.eventList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticOrderItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticOrderItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseDiagnosticOrderItem(jsn : TJsonObject) : TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseReference{TFhirSpecimen});
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum);
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseDiagnosticOrderEvent);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticOrderItem(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderItem; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (elem.specimenList.Count > 0) then
  begin
    json.valueArray('specimen');
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '', elem.specimenList[i]); {z - Reference(Specimen)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.eventList.Count > 0) then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(json, '', elem.eventList[i]); {z - @DiagnosticOrder.event}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeDiagnosticOrderItem(parent :  TRDFComplex; parentType, name : String; elem : TFhirDiagnosticOrderItem; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DiagnosticOrderItem');
  end;
  composeBackboneElement(this, 'DiagnosticOrderItem', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DiagnosticOrderItem', 'code', elem.codeElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(this, 'DiagnosticOrderItem', 'specimen', elem.specimenList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'DiagnosticOrderItem', 'bodySite', elem.bodySiteElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DiagnosticOrderItem', 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum, -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(this, 'DiagnosticOrderItem', 'event', elem.eventList[i], i);
end;

function TFHIRXmlParser.ParseDiagnosticOrder(element : IXmlDomElement; path : string) : TFhirDiagnosticOrder;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticOrder.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'orderer') then
        result.orderer := ParseReference{TFhirPractitioner}(child, path+'/orderer') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'reason') then
        result.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.baseName = 'supportingInformation') then
        result.supportingInformationList.Add(ParseReference{Resource}(child, path+'/supportingInformation')){y.2}
      else if (child.baseName = 'specimen') then
        result.specimenList.Add(ParseReference{TFhirSpecimen}(child, path+'/specimen')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'priority') then
        result.priorityElement := ParseEnum(CODES_TFhirDiagnosticOrderPriorityEnum, SYSTEMS_TFhirDiagnosticOrderPriorityEnum, path+'/priority', child){1a}
      else if (child.baseName = 'event') then
        result.eventList.Add(ParseDiagnosticOrderEvent(child, path+'/event')){y.2}
      else if (child.baseName = 'item') then
        result.itemList.Add(ParseDiagnosticOrderItem(child, path+'/item')){y.2}
      else if (child.baseName = 'note') then
        result.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrder(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrder);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'orderer', elem.orderer);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{Resource}(xml, 'supportingInformation', elem.supportingInformationList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimenList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'priority', elem.PriorityElement, CODES_TFhirDiagnosticOrderPriorityEnum);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(xml, 'event', elem.eventList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeDiagnosticOrderItem(xml, 'item', elem.itemList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticOrder(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticOrder(jsn)); {2}
end;

function TFHIRJsonParser.ParseDiagnosticOrder(jsn : TJsonObject) : TFhirDiagnosticOrder;
begin
  result := TFhirDiagnosticOrder.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('orderer') then
        result.orderer := ParseReference{TFhirPractitioner}(jsn.vObj['orderer']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('supportingInformation') then
      iterateArray(jsn.vArr['supportingInformation'], result.supportingInformationList, parseReference{Resource});
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseReference{TFhirSpecimen});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum);
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn.path+'/priority', jsn['priority'], jsn.vObj['_priority'], CODES_TFhirDiagnosticOrderPriorityEnum, SYSTEMS_TFhirDiagnosticOrderPriorityEnum);
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseDiagnosticOrderEvent);
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseDiagnosticOrderItem);
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticOrder(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrder; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'orderer', elem.orderer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soData]) and (elem.reasonList.Count > 0) then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.supportingInformationList.Count > 0) then
  begin
    json.valueArray('supportingInformation');
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.supportingInformationList[i]); {z - Reference(Observation|Condition|DocumentReference)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.specimenList.Count > 0) then
  begin
    json.valueArray('specimen');
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '', elem.specimenList[i]); {z - Reference(Specimen)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirDiagnosticOrderPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirDiagnosticOrderPriorityEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.eventList.Count > 0) then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(json, '', elem.eventList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.itemList.Count > 0) then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeDiagnosticOrderItem(json, '', elem.itemList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeDiagnosticOrder(parent :  TRDFComplex; parentType, name : String; elem : TFhirDiagnosticOrder; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DiagnosticOrder');
  end;
  composeDomainResource(this, 'DiagnosticOrder', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'DiagnosticOrder', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'DiagnosticOrder', 'orderer', elem.ordererElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DiagnosticOrder', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'DiagnosticOrder', 'encounter', elem.encounterElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'DiagnosticOrder', 'reason', elem.reasonList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{Resource}(this, 'DiagnosticOrder', 'supportingInformation', elem.supportingInformationList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(this, 'DiagnosticOrder', 'specimen', elem.specimenList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DiagnosticOrder', 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DiagnosticOrder', 'priority', elem.PriorityElement, CODES_TFhirDiagnosticOrderPriorityEnum, SYSTEMS_TFhirDiagnosticOrderPriorityEnum, -1);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(this, 'DiagnosticOrder', 'event', elem.eventList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeDiagnosticOrderItem(this, 'DiagnosticOrder', 'item', elem.itemList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'DiagnosticOrder', 'note', elem.noteList[i], i);
end;

function TFHIRXmlParser.ParseDiagnosticReportImage(element : IXmlDomElement; path : string) : TFhirDiagnosticReportImage;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'comment') then
        result.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.baseName = 'link') then
        result.link_ := ParseReference{TFhirMedia}(child, path+'/link') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReportImage(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReportImage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', elem.commentElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirMedia}(xml, 'link', elem.link_);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticReportImage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticReportImage(jsn)); {2}
end;

function TFHIRJsonParser.ParseDiagnosticReportImage(jsn : TJsonObject) : TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('link') then
        result.link_ := ParseReference{TFhirMedia}(jsn.vObj['link']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticReportImage(json : TJSONWriter; name : string; elem : TFhirDiagnosticReportImage; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirMedia}(json, 'link', elem.link_); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeDiagnosticReportImage(parent :  TRDFComplex; parentType, name : String; elem : TFhirDiagnosticReportImage; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DiagnosticReportImage');
  end;
  composeBackboneElement(this, 'DiagnosticReportImage', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DiagnosticReportImage', 'comment', elem.commentElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirMedia}(this, 'DiagnosticReportImage', 'link', elem.link_Element, -1);{x.2}
end;

function TFHIRXmlParser.ParseDiagnosticReport(element : IXmlDomElement; path : string) : TFhirDiagnosticReport;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticReport.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirDiagnosticReportStatusEnum, SYSTEMS_TFhirDiagnosticReportStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'effectiveDateTime') then
        result.effective := ParseDateTime(child, path+'/effectiveDateTime'){x.3}
      else if (child.baseName = 'effectivePeriod') then
        result.effective := ParsePeriod(child, path+'/effectivePeriod'){x.3}
      else if (child.baseName = 'issued') then
        result.issuedElement := ParseInstant(child, path+'/issued') {b}
      else if (child.baseName = 'performer') then
        result.performer := ParseReference{Resource}(child, path+'/performer') {b}
      else if (child.baseName = 'request') then
        result.requestList.Add(ParseReference{Resource}(child, path+'/request')){y.2}
      else if (child.baseName = 'specimen') then
        result.specimenList.Add(ParseReference{TFhirSpecimen}(child, path+'/specimen')){y.2}
      else if (child.baseName = 'result') then
        result.resultList.Add(ParseReference{TFhirObservation}(child, path+'/result')){y.2}
      else if (child.baseName = 'imagingStudy') then
        result.imagingStudyList.Add(ParseReference{Resource}(child, path+'/imagingStudy')){y.2}
      else if (child.baseName = 'image') then
        result.imageList.Add(ParseDiagnosticReportImage(child, path+'/image')){y.2}
      else if (child.baseName = 'conclusion') then
        result.conclusionElement := ParseString(child, path+'/conclusion') {b}
      else if (child.baseName = 'codedDiagnosis') then
        result.codedDiagnosisList.Add(ParseCodeableConcept(child, path+'/codedDiagnosis')){y.2}
      else if (child.baseName = 'presentedForm') then
        result.presentedFormList.Add(ParseAttachment(child, path+'/presentedForm')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReport(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReport);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDiagnosticReportStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveDateTime', TFhirDateTime(elem.effective))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectivePeriod', TFhirPeriod(elem.effective));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'issued', elem.issuedElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'performer', elem.performer);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.requestList.Count - 1 do
      ComposeReference{Resource}(xml, 'request', elem.requestList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimenList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.resultList.Count - 1 do
      ComposeReference{TFhirObservation}(xml, 'result', elem.resultList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.imagingStudyList.Count - 1 do
      ComposeReference{Resource}(xml, 'imagingStudy', elem.imagingStudyList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.imageList.Count - 1 do
      ComposeDiagnosticReportImage(xml, 'image', elem.imageList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'conclusion', elem.conclusionElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.codedDiagnosisList.Count - 1 do
      ComposeCodeableConcept(xml, 'codedDiagnosis', elem.codedDiagnosisList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.presentedFormList.Count - 1 do
      ComposeAttachment(xml, 'presentedForm', elem.presentedFormList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticReport(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticReport(jsn)); {2}
end;

function TFHIRJsonParser.ParseDiagnosticReport(jsn : TJsonObject) : TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticReportStatusEnum, SYSTEMS_TFhirDiagnosticReportStatusEnum);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('effectiveDateTime') or jsn.has('_effectiveDateTime') then
      result.effective := parseDateTime(jsn['effectiveDateTime'], jsn.vObj['_effectiveDateTime']);
    if jsn.has('effectivePeriod') {a4} then
      result.effective := ParsePeriod(jsn.vObj['effectivePeriod']);
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := ParseInstant(jsn['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('performer') then
        result.performer := ParseReference{Resource}(jsn.vObj['performer']);{q}
    if jsn.has('request') then
      iterateArray(jsn.vArr['request'], result.requestList, parseReference{Resource});
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseReference{TFhirSpecimen});
    if jsn.has('result') then
      iterateArray(jsn.vArr['result'], result.resultList, parseReference{TFhirObservation});
    if jsn.has('imagingStudy') then
      iterateArray(jsn.vArr['imagingStudy'], result.imagingStudyList, parseReference{Resource});
    if jsn.has('image') then
      iterateArray(jsn.vArr['image'], result.imageList, parseDiagnosticReportImage);
    if jsn.has('conclusion') or jsn.has('_conclusion') then
        result.conclusionElement := ParseString(jsn['conclusion'], jsn.vObj['_conclusion']);{q}
    if jsn.has('codedDiagnosis') then
      iterateArray(jsn.vArr['codedDiagnosis'], result.codedDiagnosisList, parseCodeableConcept);
    if jsn.has('presentedForm') then
      iterateArray(jsn.vArr['presentedForm'], result.presentedFormList, parseAttachment);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticReport(json : TJSONWriter; name : string; elem : TFhirDiagnosticReport; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticReportStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticReportStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
    ComposeDateTimeProps(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) then 
    ComposePeriod(json, 'effectivePeriod', TFhirPeriod(elem.effective)) ;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantValue(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantProps(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'performer', elem.performer); {a}
  if (SummaryOption in [soFull, soData]) and (elem.requestList.Count > 0) then
  begin
    json.valueArray('request');
    for i := 0 to elem.requestList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.requestList[i]); {z - Reference(DiagnosticOrder|ProcedureRequest|ReferralRequest)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.specimenList.Count > 0) then
  begin
    json.valueArray('specimen');
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '', elem.specimenList[i]); {z - Reference(Specimen)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.resultList.Count > 0) then
  begin
    json.valueArray('result');
    for i := 0 to elem.resultList.Count - 1 do
      ComposeReference{TFhirObservation}(json, '', elem.resultList[i]); {z - Reference(Observation)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.imagingStudyList.Count > 0) then
  begin
    json.valueArray('imagingStudy');
    for i := 0 to elem.imagingStudyList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.imagingStudyList[i]); {z - Reference(ImagingStudy|ImagingObjectSelection)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.imageList.Count > 0) then
  begin
    json.valueArray('image');
    for i := 0 to elem.imageList.Count - 1 do
      ComposeDiagnosticReportImage(json, '', elem.imageList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'conclusion', elem.conclusionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'conclusion', elem.conclusionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.codedDiagnosisList.Count > 0) then
  begin
    json.valueArray('codedDiagnosis');
    for i := 0 to elem.codedDiagnosisList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.codedDiagnosisList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.presentedFormList.Count > 0) then
  begin
    json.valueArray('presentedForm');
    for i := 0 to elem.presentedFormList.Count - 1 do
      ComposeAttachment(json, '', elem.presentedFormList[i]); {z - Attachment}
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeDiagnosticReport(parent :  TRDFComplex; parentType, name : String; elem : TFhirDiagnosticReport; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DiagnosticReport');
  end;
  composeDomainResource(this, 'DiagnosticReport', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DiagnosticReport', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DiagnosticReport', 'status', elem.StatusElement, CODES_TFhirDiagnosticReportStatusEnum, SYSTEMS_TFhirDiagnosticReportStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DiagnosticReport', 'category', elem.categoryElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DiagnosticReport', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'DiagnosticReport', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'DiagnosticReport', 'encounter', elem.encounterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DiagnosticReport', 'effectiveDateTime', TFhirDateTime(elem.effective), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'DiagnosticReport', 'effectivePeriod', TFhirPeriod(elem.effective), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'DiagnosticReport', 'issued', elem.issuedElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'DiagnosticReport', 'performer', elem.performerElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.requestList.Count - 1 do
      ComposeReference{Resource}(this, 'DiagnosticReport', 'request', elem.requestList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(this, 'DiagnosticReport', 'specimen', elem.specimenList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.resultList.Count - 1 do
      ComposeReference{TFhirObservation}(this, 'DiagnosticReport', 'result', elem.resultList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.imagingStudyList.Count - 1 do
      ComposeReference{Resource}(this, 'DiagnosticReport', 'imagingStudy', elem.imagingStudyList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.imageList.Count - 1 do
      ComposeDiagnosticReportImage(this, 'DiagnosticReport', 'image', elem.imageList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DiagnosticReport', 'conclusion', elem.conclusionElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.codedDiagnosisList.Count - 1 do
      ComposeCodeableConcept(this, 'DiagnosticReport', 'codedDiagnosis', elem.codedDiagnosisList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.presentedFormList.Count - 1 do
      ComposeAttachment(this, 'DiagnosticReport', 'presentedForm', elem.presentedFormList[i], i);
end;

function TFHIRXmlParser.ParseDocumentManifestContent(element : IXmlDomElement; path : string) : TFhirDocumentManifestContent;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentManifestContent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'pAttachment') then
        result.p := ParseAttachment(child, path+'/pAttachment'){x.3}
      else if (child.baseName = 'pReference') then
        result.p := ParseReference(child, path+'/pReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifestContent(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifestContent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.p is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'pAttachment', TFhirAttachment(elem.p))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.p is TFhirReference) {2} then
    ComposeReference(xml, 'pReference', TFhirReference(elem.p));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentManifestContent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentManifestContent(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentManifestContent(jsn : TJsonObject) : TFhirDocumentManifestContent;
begin
  result := TFhirDocumentManifestContent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('pAttachment') {a4} then
      result.p := ParseAttachment(jsn.vObj['pAttachment']);
    if jsn.has('pReference') {a3} then
      result.p := ParseReference(jsn.vObj['pReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentManifestContent(json : TJSONWriter; name : string; elem : TFhirDocumentManifestContent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.p is TFhirAttachment) then 
    ComposeAttachment(json, 'pAttachment', TFhirAttachment(elem.p)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.p is TFhirReference) then
    ComposeReference(json, 'pReference', TFhirReference(elem.p));
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeDocumentManifestContent(parent :  TRDFComplex; parentType, name : String; elem : TFhirDocumentManifestContent; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DocumentManifestContent');
  end;
  composeBackboneElement(this, 'DocumentManifestContent', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.p is TFhirAttachment) {6} then
    ComposeAttachment(this, 'DocumentManifestContent', 'pAttachment', TFhirAttachment(elem.p), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.p is TFhirReference) {2} then
    ComposeReference(this, 'DocumentManifestContent', 'pReference', TFhirReference(elem.p), -1);
end;

function TFHIRXmlParser.ParseDocumentManifestRelated(element : IXmlDomElement; path : string) : TFhirDocumentManifestRelated;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentManifestRelated.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'ref') then
        result.ref := ParseReference{TFhirReference}(child, path+'/ref') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifestRelated(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifestRelated);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'ref', elem.ref);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentManifestRelated(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentManifestRelated(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentManifestRelated(jsn : TJsonObject) : TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('ref') then
        result.ref := ParseReference{TFhirReference}(jsn.vObj['ref']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentManifestRelated(json : TJSONWriter; name : string; elem : TFhirDocumentManifestRelated; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'ref', elem.ref); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeDocumentManifestRelated(parent :  TRDFComplex; parentType, name : String; elem : TFhirDocumentManifestRelated; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DocumentManifestRelated');
  end;
  composeBackboneElement(this, 'DocumentManifestRelated', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'DocumentManifestRelated', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'DocumentManifestRelated', 'ref', elem.refElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseDocumentManifest(element : IXmlDomElement; path : string) : TFhirDocumentManifest;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentManifest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(child, path+'/masterIdentifier') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'recipient') then
        result.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'author') then
        result.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'source') then
        result.sourceElement := ParseUri(child, path+'/source') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'content') then
        result.contentList.Add(ParseDocumentManifestContent(child, path+'/content')){y.2}
      else if (child.baseName = 'related') then
        result.relatedList.Add(ParseDocumentManifestRelated(child, path+'/related')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifest(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'masterIdentifier', elem.masterIdentifier);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'source', elem.sourceElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentManifestContent(xml, 'content', elem.contentList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentManifestRelated(xml, 'related', elem.relatedList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentManifest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentManifest(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentManifest(jsn : TJsonObject) : TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(jsn.vObj['masterIdentifier']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{Resource});
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{Resource});
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('source') or jsn.has('_source') then
        result.sourceElement := ParseUri(jsn['source'], jsn.vObj['_source']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseDocumentManifestContent);
    if jsn.has('related') then
      iterateArray(jsn.vArr['related'], result.relatedList, parseDocumentManifestRelated);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentManifest(json : TJSONWriter; name : string; elem : TFhirDocumentManifest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'masterIdentifier', elem.masterIdentifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.recipientList.Count > 0) then
  begin
    json.valueArray('recipient');
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.recipientList[i]); {z - Reference(Patient|Practitioner|RelatedPerson|Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.authorList[i]); {z - Reference(Practitioner|Organization|Device|Patient|RelatedPerson)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'source', elem.sourceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'source', elem.sourceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.contentList.Count > 0) then
  begin
    json.valueArray('content');
    for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentManifestContent(json, '', elem.contentList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.relatedList.Count > 0) then
  begin
    json.valueArray('related');
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentManifestRelated(json, '', elem.relatedList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeDocumentManifest(parent :  TRDFComplex; parentType, name : String; elem : TFhirDocumentManifest; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DocumentManifest');
  end;
  composeDomainResource(this, 'DocumentManifest', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'DocumentManifest', 'masterIdentifier', elem.masterIdentifierElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DocumentManifest', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'DocumentManifest', 'subject', elem.subjectElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(this, 'DocumentManifest', 'recipient', elem.recipientList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DocumentManifest', 'type', elem.type_Element, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(this, 'DocumentManifest', 'author', elem.authorList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'DocumentManifest', 'created', elem.createdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'DocumentManifest', 'source', elem.sourceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DocumentManifest', 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DocumentManifest', 'description', elem.descriptionElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentManifestContent(this, 'DocumentManifest', 'content', elem.contentList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentManifestRelated(this, 'DocumentManifest', 'related', elem.relatedList[i], i);
end;

function TFHIRXmlParser.ParseDocumentReferenceRelatesTo(element : IXmlDomElement; path : string) : TFhirDocumentReferenceRelatesTo;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeElement := ParseEnum(CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum, path+'/code', child){1a}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirDocumentReference}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceRelatesTo(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceRelatesTo);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDocumentReference}(xml, 'target', elem.target);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceRelatesTo(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceRelatesTo(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReferenceRelatesTo(jsn : TJsonObject) : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn['code'], jsn.vObj['_code'], CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum);
    if jsn.has('target') then
        result.target := ParseReference{TFhirDocumentReference}(jsn.vObj['target']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceRelatesTo(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceRelatesTo; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDocumentReference}(json, 'target', elem.target); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeDocumentReferenceRelatesTo(parent :  TRDFComplex; parentType, name : String; elem : TFhirDocumentReferenceRelatesTo; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DocumentReferenceRelatesTo');
  end;
  composeBackboneElement(this, 'DocumentReferenceRelatesTo', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DocumentReferenceRelatesTo', 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDocumentReference}(this, 'DocumentReferenceRelatesTo', 'target', elem.targetElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseDocumentReferenceContent(element : IXmlDomElement; path : string) : TFhirDocumentReferenceContent;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReferenceContent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'attachment') then
        result.attachment := ParseAttachment(child, path+'/attachment') {b}
      else if (child.baseName = 'format') then
        result.formatList.Add(ParseCoding(child, path+'/format')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContent(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(xml, 'attachment', elem.attachment);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.formatList.Count - 1 do
      ComposeCoding(xml, 'format', elem.formatList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceContent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceContent(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReferenceContent(jsn : TJsonObject) : TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('attachment') then
        result.attachment := ParseAttachment(jsn.vObj['attachment']);{q}
    if jsn.has('format') then
      iterateArray(jsn.vArr['format'], result.formatList, parseCoding);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceContent(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(json, 'attachment', elem.attachment); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.formatList.Count > 0) then
  begin
    json.valueArray('format');
    for i := 0 to elem.formatList.Count - 1 do
      ComposeCoding(json, '', elem.formatList[i]); {z - Coding}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeDocumentReferenceContent(parent :  TRDFComplex; parentType, name : String; elem : TFhirDocumentReferenceContent; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DocumentReferenceContent');
  end;
  composeBackboneElement(this, 'DocumentReferenceContent', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(this, 'DocumentReferenceContent', 'attachment', elem.attachmentElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.formatList.Count - 1 do
      ComposeCoding(false, this, 'DocumentReferenceContent', 'format', elem.formatList[i], i);
end;

function TFHIRXmlParser.ParseDocumentReferenceContext(element : IXmlDomElement; path : string) : TFhirDocumentReferenceContext;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'event') then
        result.eventList.Add(ParseCodeableConcept(child, path+'/event')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'facilityType') then
        result.facilityType := ParseCodeableConcept(child, path+'/facilityType') {b}
      else if (child.baseName = 'practiceSetting') then
        result.practiceSetting := ParseCodeableConcept(child, path+'/practiceSetting') {b}
      else if (child.baseName = 'sourcePatientInfo') then
        result.sourcePatientInfo := ParseReference{TFhirPatient}(child, path+'/sourcePatientInfo') {b}
      else if (child.baseName = 'related') then
        result.relatedList.Add(ParseDocumentReferenceContextRelated(child, path+'/related')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContext(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContext);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCodeableConcept(xml, 'event', elem.eventList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'facilityType', elem.facilityType);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'practiceSetting', elem.practiceSetting);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'sourcePatientInfo', elem.sourcePatientInfo);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentReferenceContextRelated(xml, 'related', elem.relatedList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceContext(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceContext(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReferenceContext(jsn : TJsonObject) : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('facilityType') then
        result.facilityType := ParseCodeableConcept(jsn.vObj['facilityType']);{q}
    if jsn.has('practiceSetting') then
        result.practiceSetting := ParseCodeableConcept(jsn.vObj['practiceSetting']);{q}
    if jsn.has('sourcePatientInfo') then
        result.sourcePatientInfo := ParseReference{TFhirPatient}(jsn.vObj['sourcePatientInfo']);{q}
    if jsn.has('related') then
      iterateArray(jsn.vArr['related'], result.relatedList, parseDocumentReferenceContextRelated);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceContext(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContext; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.eventList.Count > 0) then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.eventList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'facilityType', elem.facilityType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'practiceSetting', elem.practiceSetting); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'sourcePatientInfo', elem.sourcePatientInfo); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.relatedList.Count > 0) then
  begin
    json.valueArray('related');
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentReferenceContextRelated(json, '', elem.relatedList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeDocumentReferenceContext(parent :  TRDFComplex; parentType, name : String; elem : TFhirDocumentReferenceContext; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DocumentReferenceContext');
  end;
  composeBackboneElement(this, 'DocumentReferenceContext', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'DocumentReferenceContext', 'encounter', elem.encounterElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCodeableConcept(this, 'DocumentReferenceContext', 'event', elem.eventList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'DocumentReferenceContext', 'period', elem.periodElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DocumentReferenceContext', 'facilityType', elem.facilityTypeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DocumentReferenceContext', 'practiceSetting', elem.practiceSettingElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'DocumentReferenceContext', 'sourcePatientInfo', elem.sourcePatientInfoElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentReferenceContextRelated(this, 'DocumentReferenceContext', 'related', elem.relatedList[i], i);
end;

function TFHIRXmlParser.ParseDocumentReferenceContextRelated(element : IXmlDomElement; path : string) : TFhirDocumentReferenceContextRelated;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReferenceContextRelated.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'ref') then
        result.ref := ParseReference{TFhirReference}(child, path+'/ref') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContextRelated(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContextRelated);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'ref', elem.ref);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceContextRelated(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceContextRelated(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReferenceContextRelated(jsn : TJsonObject) : TFhirDocumentReferenceContextRelated;
begin
  result := TFhirDocumentReferenceContextRelated.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('ref') then
        result.ref := ParseReference{TFhirReference}(jsn.vObj['ref']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceContextRelated(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContextRelated; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'ref', elem.ref); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeDocumentReferenceContextRelated(parent :  TRDFComplex; parentType, name : String; elem : TFhirDocumentReferenceContextRelated; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DocumentReferenceContextRelated');
  end;
  composeBackboneElement(this, 'DocumentReferenceContextRelated', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'DocumentReferenceContextRelated', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'DocumentReferenceContextRelated', 'ref', elem.refElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseDocumentReference(element : IXmlDomElement; path : string) : TFhirDocumentReference;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReference.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(child, path+'/masterIdentifier') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'class') then
        result.class_ := ParseCodeableConcept(child, path+'/class') {b}
      else if (child.baseName = 'author') then
        result.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.baseName = 'custodian') then
        result.custodian := ParseReference{TFhirOrganization}(child, path+'/custodian') {b}
      else if (child.baseName = 'authenticator') then
        result.authenticator := ParseReference{Resource}(child, path+'/authenticator') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'indexed') then
        result.indexedElement := ParseInstant(child, path+'/indexed') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'docStatus') then
        result.docStatus := ParseCodeableConcept(child, path+'/docStatus') {b}
      else if (child.baseName = 'relatesTo') then
        result.relatesToList.Add(ParseDocumentReferenceRelatesTo(child, path+'/relatesTo')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'securityLabel') then
        result.securityLabelList.Add(ParseCodeableConcept(child, path+'/securityLabel')){y.2}
      else if (child.baseName = 'content') then
        result.contentList.Add(ParseDocumentReferenceContent(child, path+'/content')){y.2}
      else if (child.baseName = 'context') then
        result.context := ParseDocumentReferenceContext(child, path+'/context') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReference(xml : TXmlBuilder; name : string; elem : TFhirDocumentReference);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'masterIdentifier', elem.masterIdentifier);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'class', elem.class_);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'custodian', elem.custodian);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'authenticator', elem.authenticator);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'indexed', elem.indexedElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'docStatus', elem.docStatus);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.relatesToList.Count - 1 do
      ComposeDocumentReferenceRelatesTo(xml, 'relatesTo', elem.relatesToList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCodeableConcept(xml, 'securityLabel', elem.securityLabelList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentReferenceContent(xml, 'content', elem.contentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDocumentReferenceContext(xml, 'context', elem.context);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReference(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReference(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReference(jsn : TJsonObject) : TFhirDocumentReference;
begin
  result := TFhirDocumentReference.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(jsn.vObj['masterIdentifier']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('class') then
        result.class_ := ParseCodeableConcept(jsn.vObj['class']);{q}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{Resource});
    if jsn.has('custodian') then
        result.custodian := ParseReference{TFhirOrganization}(jsn.vObj['custodian']);{q}
    if jsn.has('authenticator') then
        result.authenticator := ParseReference{Resource}(jsn.vObj['authenticator']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('indexed') or jsn.has('_indexed') then
        result.indexedElement := ParseInstant(jsn['indexed'], jsn.vObj['_indexed']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum);
    if jsn.has('docStatus') then
        result.docStatus := ParseCodeableConcept(jsn.vObj['docStatus']);{q}
    if jsn.has('relatesTo') then
      iterateArray(jsn.vArr['relatesTo'], result.relatesToList, parseDocumentReferenceRelatesTo);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('securityLabel') then
      iterateArray(jsn.vArr['securityLabel'], result.securityLabelList, parseCodeableConcept);
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseDocumentReferenceContent);
    if jsn.has('context') then
        result.context := ParseDocumentReferenceContext(jsn.vObj['context']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReference(json : TJSONWriter; name : string; elem : TFhirDocumentReference; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'masterIdentifier', elem.masterIdentifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'class', elem.class_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.authorList[i]); {z - Reference(Practitioner|Organization|Device|Patient|RelatedPerson)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'custodian', elem.custodian); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'authenticator', elem.authenticator); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantValue(json, 'indexed', elem.indexedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantProps(json, 'indexed', elem.indexedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'docStatus', elem.docStatus); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.relatesToList.Count > 0) then
  begin
    json.valueArray('relatesTo');
    for i := 0 to elem.relatesToList.Count - 1 do
      ComposeDocumentReferenceRelatesTo(json, '', elem.relatesToList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.securityLabelList.Count > 0) then
  begin
    json.valueArray('securityLabel');
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.securityLabelList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.contentList.Count > 0) then
  begin
    json.valueArray('content');
    for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentReferenceContent(json, '', elem.contentList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDocumentReferenceContext(json, 'context', elem.context); {a}
end;

procedure TFHIRRDFComposer.ComposeDocumentReference(parent :  TRDFComplex; parentType, name : String; elem : TFhirDocumentReference; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:DocumentReference');
  end;
  composeDomainResource(this, 'DocumentReference', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'DocumentReference', 'masterIdentifier', elem.masterIdentifierElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DocumentReference', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'DocumentReference', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DocumentReference', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DocumentReference', 'class', elem.class_Element, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(this, 'DocumentReference', 'author', elem.authorList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'DocumentReference', 'custodian', elem.custodianElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'DocumentReference', 'authenticator', elem.authenticatorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'DocumentReference', 'created', elem.createdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'DocumentReference', 'indexed', elem.indexedElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'DocumentReference', 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DocumentReference', 'docStatus', elem.docStatusElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.relatesToList.Count - 1 do
      ComposeDocumentReferenceRelatesTo(this, 'DocumentReference', 'relatesTo', elem.relatesToList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DocumentReference', 'description', elem.descriptionElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCodeableConcept(this, 'DocumentReference', 'securityLabel', elem.securityLabelList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentReferenceContent(this, 'DocumentReference', 'content', elem.contentList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDocumentReferenceContext(this, 'DocumentReference', 'context', elem.contextElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseEligibilityRequest(element : IXmlDomElement; path : string) : TFhirEligibilityRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirEligibilityRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirOrganization}(child, path+'/target') {b}
      else if (child.baseName = 'provider') then
        result.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEligibilityRequest(xml : TXmlBuilder; name : string; elem : TFhirEligibilityRequest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'target', elem.target);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEligibilityRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEligibilityRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseEligibilityRequest(jsn : TJsonObject) : TFhirEligibilityRequest;
begin
  result := TFhirEligibilityRequest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirOrganization}(jsn.vObj['target']);{q}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEligibilityRequest(json : TJSONWriter; name : string; elem : TFhirEligibilityRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'target', elem.target); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
end;

procedure TFHIRRDFComposer.ComposeEligibilityRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirEligibilityRequest; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:EligibilityRequest');
  end;
  composeDomainResource(this, 'EligibilityRequest', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EligibilityRequest', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'EligibilityRequest', 'ruleset', elem.rulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'EligibilityRequest', 'originalRuleset', elem.originalRulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'EligibilityRequest', 'created', elem.createdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'EligibilityRequest', 'target', elem.targetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'EligibilityRequest', 'provider', elem.providerElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'EligibilityRequest', 'organization', elem.organizationElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseEligibilityResponse(element : IXmlDomElement; path : string) : TFhirEligibilityResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirEligibilityResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirEligibilityRequest}(child, path+'/request') {b}
      else if (child.baseName = 'outcome') then
        result.outcomeElement := ParseEnum(CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, path+'/outcome', child){1a}
      else if (child.baseName = 'disposition') then
        result.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.baseName = 'requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEligibilityResponse(xml : TXmlBuilder; name : string; elem : TFhirEligibilityResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEligibilityRequest}(xml, 'request', elem.request);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEligibilityResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEligibilityResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseEligibilityResponse(jsn : TJsonObject) : TFhirEligibilityResponse;
begin
  result := TFhirEligibilityResponse.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirEligibilityRequest}(jsn.vObj['request']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn['outcome'], jsn.vObj['_outcome'], CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEligibilityResponse(json : TJSONWriter; name : string; elem : TFhirEligibilityResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEligibilityRequest}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
end;

procedure TFHIRRDFComposer.ComposeEligibilityResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirEligibilityResponse; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:EligibilityResponse');
  end;
  composeDomainResource(this, 'EligibilityResponse', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EligibilityResponse', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEligibilityRequest}(this, 'EligibilityResponse', 'request', elem.requestElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'EligibilityResponse', 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'EligibilityResponse', 'disposition', elem.dispositionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'EligibilityResponse', 'ruleset', elem.rulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'EligibilityResponse', 'originalRuleset', elem.originalRulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'EligibilityResponse', 'created', elem.createdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'EligibilityResponse', 'organization', elem.organizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'EligibilityResponse', 'requestProvider', elem.requestProviderElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'EligibilityResponse', 'requestOrganization', elem.requestOrganizationElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseEncounterStatusHistory(element : IXmlDomElement; path : string) : TFhirEncounterStatusHistory;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounterStatusHistory.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirEncounterStateEnum, SYSTEMS_TFhirEncounterStateEnum, path+'/status', child){1a}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounterStatusHistory(xml : TXmlBuilder; name : string; elem : TFhirEncounterStatusHistory);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEncounterStateEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounterStatusHistory(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterStatusHistory(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterStatusHistory(jsn : TJsonObject) : TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirEncounterStateEnum, SYSTEMS_TFhirEncounterStateEnum);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounterStatusHistory(json : TJSONWriter; name : string; elem : TFhirEncounterStatusHistory; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEncounterStateEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEncounterStateEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeEncounterStatusHistory(parent :  TRDFComplex; parentType, name : String; elem : TFhirEncounterStatusHistory; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:EncounterStatusHistory');
  end;
  composeBackboneElement(this, 'EncounterStatusHistory', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'EncounterStatusHistory', 'status', elem.StatusElement, CODES_TFhirEncounterStateEnum, SYSTEMS_TFhirEncounterStateEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'EncounterStatusHistory', 'period', elem.periodElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseEncounterParticipant(element : IXmlDomElement; path : string) : TFhirEncounterParticipant;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounterParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'individual') then
        result.individual := ParseReference{Resource}(child, path+'/individual') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounterParticipant(xml : TXmlBuilder; name : string; elem : TFhirEncounterParticipant);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'individual', elem.individual);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounterParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterParticipant(jsn : TJsonObject) : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('individual') then
        result.individual := ParseReference{Resource}(jsn.vObj['individual']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounterParticipant(json : TJSONWriter; name : string; elem : TFhirEncounterParticipant; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'individual', elem.individual); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeEncounterParticipant(parent :  TRDFComplex; parentType, name : String; elem : TFhirEncounterParticipant; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:EncounterParticipant');
  end;
  composeBackboneElement(this, 'EncounterParticipant', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'EncounterParticipant', 'type', elem.type_List[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'EncounterParticipant', 'period', elem.periodElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'EncounterParticipant', 'individual', elem.individualElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseEncounterHospitalization(element : IXmlDomElement; path : string) : TFhirEncounterHospitalization;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounterHospitalization.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'preAdmissionIdentifier') then
        result.preAdmissionIdentifier := ParseIdentifier(child, path+'/preAdmissionIdentifier') {b}
      else if (child.baseName = 'origin') then
        result.origin := ParseReference{TFhirLocation}(child, path+'/origin') {b}
      else if (child.baseName = 'admitSource') then
        result.admitSource := ParseCodeableConcept(child, path+'/admitSource') {b}
      else if (child.baseName = 'admittingDiagnosis') then
        result.admittingDiagnosisList.Add(ParseReference{TFhirCondition}(child, path+'/admittingDiagnosis')){y.2}
      else if (child.baseName = 'reAdmission') then
        result.reAdmission := ParseCodeableConcept(child, path+'/reAdmission') {b}
      else if (child.baseName = 'dietPreference') then
        result.dietPreferenceList.Add(ParseCodeableConcept(child, path+'/dietPreference')){y.2}
      else if (child.baseName = 'specialCourtesy') then
        result.specialCourtesyList.Add(ParseCodeableConcept(child, path+'/specialCourtesy')){y.2}
      else if (child.baseName = 'specialArrangement') then
        result.specialArrangementList.Add(ParseCodeableConcept(child, path+'/specialArrangement')){y.2}
      else if (child.baseName = 'destination') then
        result.destination := ParseReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.baseName = 'dischargeDisposition') then
        result.dischargeDisposition := ParseCodeableConcept(child, path+'/dischargeDisposition') {b}
      else if (child.baseName = 'dischargeDiagnosis') then
        result.dischargeDiagnosisList.Add(ParseReference{TFhirCondition}(child, path+'/dischargeDiagnosis')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounterHospitalization(xml : TXmlBuilder; name : string; elem : TFhirEncounterHospitalization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'preAdmissionIdentifier', elem.preAdmissionIdentifier);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(xml, 'origin', elem.origin);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'admitSource', elem.admitSource);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.admittingDiagnosisList.Count - 1 do
      ComposeReference{TFhirCondition}(xml, 'admittingDiagnosis', elem.admittingDiagnosisList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'reAdmission', elem.reAdmission);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.dietPreferenceList.Count - 1 do
      ComposeCodeableConcept(xml, 'dietPreference', elem.dietPreferenceList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.specialCourtesyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialCourtesy', elem.specialCourtesyList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.specialArrangementList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialArrangement', elem.specialArrangementList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(xml, 'destination', elem.destination);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'dischargeDisposition', elem.dischargeDisposition);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.dischargeDiagnosisList.Count - 1 do
      ComposeReference{TFhirCondition}(xml, 'dischargeDiagnosis', elem.dischargeDiagnosisList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounterHospitalization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterHospitalization(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterHospitalization(jsn : TJsonObject) : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('preAdmissionIdentifier') then
        result.preAdmissionIdentifier := ParseIdentifier(jsn.vObj['preAdmissionIdentifier']);{q}
    if jsn.has('origin') then
        result.origin := ParseReference{TFhirLocation}(jsn.vObj['origin']);{q}
    if jsn.has('admitSource') then
        result.admitSource := ParseCodeableConcept(jsn.vObj['admitSource']);{q}
    if jsn.has('admittingDiagnosis') then
      iterateArray(jsn.vArr['admittingDiagnosis'], result.admittingDiagnosisList, parseReference{TFhirCondition});
    if jsn.has('reAdmission') then
        result.reAdmission := ParseCodeableConcept(jsn.vObj['reAdmission']);{q}
    if jsn.has('dietPreference') then
      iterateArray(jsn.vArr['dietPreference'], result.dietPreferenceList, parseCodeableConcept);
    if jsn.has('specialCourtesy') then
      iterateArray(jsn.vArr['specialCourtesy'], result.specialCourtesyList, parseCodeableConcept);
    if jsn.has('specialArrangement') then
      iterateArray(jsn.vArr['specialArrangement'], result.specialArrangementList, parseCodeableConcept);
    if jsn.has('destination') then
        result.destination := ParseReference{TFhirLocation}(jsn.vObj['destination']);{q}
    if jsn.has('dischargeDisposition') then
        result.dischargeDisposition := ParseCodeableConcept(jsn.vObj['dischargeDisposition']);{q}
    if jsn.has('dischargeDiagnosis') then
      iterateArray(jsn.vArr['dischargeDiagnosis'], result.dischargeDiagnosisList, parseReference{TFhirCondition});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounterHospitalization(json : TJSONWriter; name : string; elem : TFhirEncounterHospitalization; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'preAdmissionIdentifier', elem.preAdmissionIdentifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(json, 'origin', elem.origin); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'admitSource', elem.admitSource); {a}
  if (SummaryOption in [soFull, soData]) and (elem.admittingDiagnosisList.Count > 0) then
  begin
    json.valueArray('admittingDiagnosis');
    for i := 0 to elem.admittingDiagnosisList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.admittingDiagnosisList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'reAdmission', elem.reAdmission); {a}
  if (SummaryOption in [soFull, soData]) and (elem.dietPreferenceList.Count > 0) then
  begin
    json.valueArray('dietPreference');
    for i := 0 to elem.dietPreferenceList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.dietPreferenceList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.specialCourtesyList.Count > 0) then
  begin
    json.valueArray('specialCourtesy');
    for i := 0 to elem.specialCourtesyList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.specialCourtesyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.specialArrangementList.Count > 0) then
  begin
    json.valueArray('specialArrangement');
    for i := 0 to elem.specialArrangementList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.specialArrangementList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'dischargeDisposition', elem.dischargeDisposition); {a}
  if (SummaryOption in [soFull, soData]) and (elem.dischargeDiagnosisList.Count > 0) then
  begin
    json.valueArray('dischargeDiagnosis');
    for i := 0 to elem.dischargeDiagnosisList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.dischargeDiagnosisList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeEncounterHospitalization(parent :  TRDFComplex; parentType, name : String; elem : TFhirEncounterHospitalization; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:EncounterHospitalization');
  end;
  composeBackboneElement(this, 'EncounterHospitalization', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'EncounterHospitalization', 'preAdmissionIdentifier', elem.preAdmissionIdentifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'EncounterHospitalization', 'origin', elem.originElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EncounterHospitalization', 'admitSource', elem.admitSourceElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.admittingDiagnosisList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'EncounterHospitalization', 'admittingDiagnosis', elem.admittingDiagnosisList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EncounterHospitalization', 'reAdmission', elem.reAdmissionElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.dietPreferenceList.Count - 1 do
      ComposeCodeableConcept(this, 'EncounterHospitalization', 'dietPreference', elem.dietPreferenceList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.specialCourtesyList.Count - 1 do
      ComposeCodeableConcept(this, 'EncounterHospitalization', 'specialCourtesy', elem.specialCourtesyList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.specialArrangementList.Count - 1 do
      ComposeCodeableConcept(this, 'EncounterHospitalization', 'specialArrangement', elem.specialArrangementList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'EncounterHospitalization', 'destination', elem.destinationElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EncounterHospitalization', 'dischargeDisposition', elem.dischargeDispositionElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.dischargeDiagnosisList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'EncounterHospitalization', 'dischargeDiagnosis', elem.dischargeDiagnosisList[i], i);
end;

function TFHIRXmlParser.ParseEncounterLocation(element : IXmlDomElement; path : string) : TFhirEncounterLocation;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounterLocation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirEncounterLocationStatusEnum, SYSTEMS_TFhirEncounterLocationStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounterLocation(xml : TXmlBuilder; name : string; elem : TFhirEncounterLocation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEncounterLocationStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounterLocation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterLocation(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterLocation(jsn : TJsonObject) : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirEncounterLocationStatusEnum, SYSTEMS_TFhirEncounterLocationStatusEnum);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounterLocation(json : TJSONWriter; name : string; elem : TFhirEncounterLocation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEncounterLocationStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEncounterLocationStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeEncounterLocation(parent :  TRDFComplex; parentType, name : String; elem : TFhirEncounterLocation; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:EncounterLocation');
  end;
  composeBackboneElement(this, 'EncounterLocation', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'EncounterLocation', 'location', elem.locationElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'EncounterLocation', 'status', elem.StatusElement, CODES_TFhirEncounterLocationStatusEnum, SYSTEMS_TFhirEncounterLocationStatusEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'EncounterLocation', 'period', elem.periodElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseEncounter(element : IXmlDomElement; path : string) : TFhirEncounter;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounter.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirEncounterStateEnum, SYSTEMS_TFhirEncounterStateEnum, path+'/status', child){1a}
      else if (child.baseName = 'statusHistory') then
        result.statusHistoryList.Add(ParseEncounterStatusHistory(child, path+'/statusHistory')){y.2}
      else if (child.baseName = 'class') then
        result.class_Element := ParseEnum(CODES_TFhirEncounterClassEnum, SYSTEMS_TFhirEncounterClassEnum, path+'/class', child){1a}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.baseName = 'priority') then
        result.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'episodeOfCare') then
        result.episodeOfCareList.Add(ParseReference{TFhirEpisodeOfCare}(child, path+'/episodeOfCare')){y.2}
      else if (child.baseName = 'incomingReferral') then
        result.incomingReferralList.Add(ParseReference{TFhirReferralRequest}(child, path+'/incomingReferral')){y.2}
      else if (child.baseName = 'participant') then
        result.participantList.Add(ParseEncounterParticipant(child, path+'/participant')){y.2}
      else if (child.baseName = 'appointment') then
        result.appointment := ParseReference{TFhirAppointment}(child, path+'/appointment') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'length') then
        result.length := ParseQuantity(child, path+'/length') {b}
      else if (child.baseName = 'reason') then
        result.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.baseName = 'indication') then
        result.indicationList.Add(ParseReference{Resource}(child, path+'/indication')){y.2}
      else if (child.baseName = 'hospitalization') then
        result.hospitalization := ParseEncounterHospitalization(child, path+'/hospitalization') {b}
      else if (child.baseName = 'location') then
        result.locationList.Add(ParseEncounterLocation(child, path+'/location')){y.2}
      else if (child.baseName = 'serviceProvider') then
        result.serviceProvider := ParseReference{TFhirOrganization}(child, path+'/serviceProvider') {b}
      else if (child.baseName = 'partOf') then
        result.partOf := ParseReference{TFhirEncounter}(child, path+'/partOf') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounter(xml : TXmlBuilder; name : string; elem : TFhirEncounter);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEncounterStateEnum);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEncounterStatusHistory(xml, 'statusHistory', elem.statusHistoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'class', elem.Class_Element, CODES_TFhirEncounterClassEnum);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.episodeOfCareList.Count - 1 do
      ComposeReference{TFhirEpisodeOfCare}(xml, 'episodeOfCare', elem.episodeOfCareList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.incomingReferralList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(xml, 'incomingReferral', elem.incomingReferralList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeEncounterParticipant(xml, 'participant', elem.participantList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirAppointment}(xml, 'appointment', elem.appointment);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'length', elem.length);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeReference{Resource}(xml, 'indication', elem.indicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeEncounterHospitalization(xml, 'hospitalization', elem.hospitalization);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeEncounterLocation(xml, 'location', elem.locationList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'serviceProvider', elem.serviceProvider);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'partOf', elem.partOf);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounter(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounter(jsn : TJsonObject) : TFhirEncounter;
begin
  result := TFhirEncounter.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirEncounterStateEnum, SYSTEMS_TFhirEncounterStateEnum);
    if jsn.has('statusHistory') then
      iterateArray(jsn.vArr['statusHistory'], result.statusHistoryList, parseEncounterStatusHistory);
    if jsn.has('class') or jsn.has('_class')  then
      result.class_Element := parseEnum(jsn.path+'/class', jsn['class'], jsn.vObj['_class'], CODES_TFhirEncounterClassEnum, SYSTEMS_TFhirEncounterClassEnum);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('episodeOfCare') then
      iterateArray(jsn.vArr['episodeOfCare'], result.episodeOfCareList, parseReference{TFhirEpisodeOfCare});
    if jsn.has('incomingReferral') then
      iterateArray(jsn.vArr['incomingReferral'], result.incomingReferralList, parseReference{TFhirReferralRequest});
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseEncounterParticipant);
    if jsn.has('appointment') then
        result.appointment := ParseReference{TFhirAppointment}(jsn.vObj['appointment']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('length') then
        result.length := ParseQuantity(jsn.vObj['length']);{q}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('indication') then
      iterateArray(jsn.vArr['indication'], result.indicationList, parseReference{Resource});
    if jsn.has('hospitalization') then
        result.hospitalization := ParseEncounterHospitalization(jsn.vObj['hospitalization']);{q}
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseEncounterLocation);
    if jsn.has('serviceProvider') then
        result.serviceProvider := ParseReference{TFhirOrganization}(jsn.vObj['serviceProvider']);{q}
    if jsn.has('partOf') then
        result.partOf := ParseReference{TFhirEncounter}(jsn.vObj['partOf']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounter(json : TJSONWriter; name : string; elem : TFhirEncounter; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEncounterStateEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEncounterStateEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.statusHistoryList.Count > 0) then
  begin
    json.valueArray('statusHistory');
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEncounterStatusHistory(json, '', elem.statusHistoryList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'class', elem.Class_Element, CODES_TFhirEncounterClassEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'class', elem.Class_Element, CODES_TFhirEncounterClassEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.episodeOfCareList.Count > 0) then
  begin
    json.valueArray('episodeOfCare');
    for i := 0 to elem.episodeOfCareList.Count - 1 do
      ComposeReference{TFhirEpisodeOfCare}(json, '', elem.episodeOfCareList[i]); {z - Reference(EpisodeOfCare)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.incomingReferralList.Count > 0) then
  begin
    json.valueArray('incomingReferral');
    for i := 0 to elem.incomingReferralList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(json, '', elem.incomingReferralList[i]); {z - Reference(ReferralRequest)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.participantList.Count > 0) then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeEncounterParticipant(json, '', elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirAppointment}(json, 'appointment', elem.appointment); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'length', elem.length); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonList.Count > 0) then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.indicationList.Count > 0) then
  begin
    json.valueArray('indication');
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.indicationList[i]); {z - Reference(Condition|Procedure)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeEncounterHospitalization(json, 'hospitalization', elem.hospitalization); {a}
  if (SummaryOption in [soFull, soData]) and (elem.locationList.Count > 0) then
  begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeEncounterLocation(json, '', elem.locationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'serviceProvider', elem.serviceProvider); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(json, 'partOf', elem.partOf); {a}
end;

procedure TFHIRRDFComposer.ComposeEncounter(parent :  TRDFComplex; parentType, name : String; elem : TFhirEncounter; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Encounter');
  end;
  composeDomainResource(this, 'Encounter', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Encounter', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Encounter', 'status', elem.StatusElement, CODES_TFhirEncounterStateEnum, SYSTEMS_TFhirEncounterStateEnum, -1);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEncounterStatusHistory(this, 'Encounter', 'statusHistory', elem.statusHistoryList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Encounter', 'class', elem.Class_Element, CODES_TFhirEncounterClassEnum, SYSTEMS_TFhirEncounterClassEnum, -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter', 'type', elem.type_List[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter', 'priority', elem.priorityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'Encounter', 'patient', elem.patientElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.episodeOfCareList.Count - 1 do
      ComposeReference{TFhirEpisodeOfCare}(this, 'Encounter', 'episodeOfCare', elem.episodeOfCareList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.incomingReferralList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(this, 'Encounter', 'incomingReferral', elem.incomingReferralList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeEncounterParticipant(this, 'Encounter', 'participant', elem.participantList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirAppointment}(this, 'Encounter', 'appointment', elem.appointmentElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Encounter', 'period', elem.periodElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Encounter', 'length', elem.lengthElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter', 'reason', elem.reasonList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeReference{Resource}(this, 'Encounter', 'indication', elem.indicationList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeEncounterHospitalization(this, 'Encounter', 'hospitalization', elem.hospitalizationElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeEncounterLocation(this, 'Encounter', 'location', elem.locationList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Encounter', 'serviceProvider', elem.serviceProviderElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(this, 'Encounter', 'partOf', elem.partOfElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseEnrollmentRequest(element : IXmlDomElement; path : string) : TFhirEnrollmentRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirEnrollmentRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirOrganization}(child, path+'/target') {b}
      else if (child.baseName = 'provider') then
        result.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'coverage') then
        result.coverage := ParseReference{TFhirCoverage}(child, path+'/coverage') {b}
      else if (child.baseName = 'relationship') then
        result.relationship := ParseCoding(child, path+'/relationship') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEnrollmentRequest(xml : TXmlBuilder; name : string; elem : TFhirEnrollmentRequest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'target', elem.target);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirCoverage}(xml, 'coverage', elem.coverage);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'relationship', elem.relationship);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEnrollmentRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEnrollmentRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseEnrollmentRequest(jsn : TJsonObject) : TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirOrganization}(jsn.vObj['target']);{q}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('coverage') then
        result.coverage := ParseReference{TFhirCoverage}(jsn.vObj['coverage']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCoding(jsn.vObj['relationship']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEnrollmentRequest(json : TJSONWriter; name : string; elem : TFhirEnrollmentRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'target', elem.target); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirCoverage}(json, 'coverage', elem.coverage); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'relationship', elem.relationship); {a}
end;

procedure TFHIRRDFComposer.ComposeEnrollmentRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirEnrollmentRequest; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:EnrollmentRequest');
  end;
  composeDomainResource(this, 'EnrollmentRequest', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EnrollmentRequest', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'EnrollmentRequest', 'ruleset', elem.rulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'EnrollmentRequest', 'originalRuleset', elem.originalRulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'EnrollmentRequest', 'created', elem.createdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'EnrollmentRequest', 'target', elem.targetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'EnrollmentRequest', 'provider', elem.providerElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'EnrollmentRequest', 'organization', elem.organizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'EnrollmentRequest', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirCoverage}(this, 'EnrollmentRequest', 'coverage', elem.coverageElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'EnrollmentRequest', 'relationship', elem.relationshipElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseEnrollmentResponse(element : IXmlDomElement; path : string) : TFhirEnrollmentResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirEnrollmentResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirEnrollmentRequest}(child, path+'/request') {b}
      else if (child.baseName = 'outcome') then
        result.outcomeElement := ParseEnum(CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, path+'/outcome', child){1a}
      else if (child.baseName = 'disposition') then
        result.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.baseName = 'requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEnrollmentResponse(xml : TXmlBuilder; name : string; elem : TFhirEnrollmentResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEnrollmentRequest}(xml, 'request', elem.request);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEnrollmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEnrollmentResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseEnrollmentResponse(jsn : TJsonObject) : TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirEnrollmentRequest}(jsn.vObj['request']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn['outcome'], jsn.vObj['_outcome'], CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEnrollmentResponse(json : TJSONWriter; name : string; elem : TFhirEnrollmentResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEnrollmentRequest}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
end;

procedure TFHIRRDFComposer.ComposeEnrollmentResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirEnrollmentResponse; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:EnrollmentResponse');
  end;
  composeDomainResource(this, 'EnrollmentResponse', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EnrollmentResponse', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEnrollmentRequest}(this, 'EnrollmentResponse', 'request', elem.requestElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'EnrollmentResponse', 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'EnrollmentResponse', 'disposition', elem.dispositionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'EnrollmentResponse', 'ruleset', elem.rulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'EnrollmentResponse', 'originalRuleset', elem.originalRulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'EnrollmentResponse', 'created', elem.createdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'EnrollmentResponse', 'organization', elem.organizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'EnrollmentResponse', 'requestProvider', elem.requestProviderElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'EnrollmentResponse', 'requestOrganization', elem.requestOrganizationElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseEpisodeOfCareStatusHistory(element : IXmlDomElement; path : string) : TFhirEpisodeOfCareStatusHistory;
var
  child : IXMLDOMElement;
begin
  result := TFhirEpisodeOfCareStatusHistory.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareStatusHistory(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCareStatusHistory);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEpisodeOfCareStatusHistory(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEpisodeOfCareStatusHistory(jsn)); {2}
end;

function TFHIRJsonParser.ParseEpisodeOfCareStatusHistory(jsn : TJsonObject) : TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEpisodeOfCareStatusHistory(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCareStatusHistory; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeEpisodeOfCareStatusHistory(parent :  TRDFComplex; parentType, name : String; elem : TFhirEpisodeOfCareStatusHistory; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:EpisodeOfCareStatusHistory');
  end;
  composeBackboneElement(this, 'EpisodeOfCareStatusHistory', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'EpisodeOfCareStatusHistory', 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'EpisodeOfCareStatusHistory', 'period', elem.periodElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseEpisodeOfCareCareTeam(element : IXmlDomElement; path : string) : TFhirEpisodeOfCareCareTeam;
var
  child : IXMLDOMElement;
begin
  result := TFhirEpisodeOfCareCareTeam.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'role') then
        result.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'member') then
        result.member := ParseReference{Resource}(child, path+'/member') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareCareTeam(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCareCareTeam);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'member', elem.member);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEpisodeOfCareCareTeam(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEpisodeOfCareCareTeam(jsn)); {2}
end;

function TFHIRJsonParser.ParseEpisodeOfCareCareTeam(jsn : TJsonObject) : TFhirEpisodeOfCareCareTeam;
begin
  result := TFhirEpisodeOfCareCareTeam.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('member') then
        result.member := ParseReference{Resource}(jsn.vObj['member']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEpisodeOfCareCareTeam(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCareCareTeam; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.roleList.Count > 0) then
  begin
    json.valueArray('role');
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.roleList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(json, 'member', elem.member); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeEpisodeOfCareCareTeam(parent :  TRDFComplex; parentType, name : String; elem : TFhirEpisodeOfCareCareTeam; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:EpisodeOfCareCareTeam');
  end;
  composeBackboneElement(this, 'EpisodeOfCareCareTeam', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'EpisodeOfCareCareTeam', 'role', elem.roleList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'EpisodeOfCareCareTeam', 'period', elem.periodElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'EpisodeOfCareCareTeam', 'member', elem.memberElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseEpisodeOfCare(element : IXmlDomElement; path : string) : TFhirEpisodeOfCare;
var
  child : IXMLDOMElement;
begin
  result := TFhirEpisodeOfCare.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'statusHistory') then
        result.statusHistoryList.Add(ParseEpisodeOfCareStatusHistory(child, path+'/statusHistory')){y.2}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.baseName = 'condition') then
        result.conditionList.Add(ParseReference{TFhirCondition}(child, path+'/condition')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'referralRequest') then
        result.referralRequestList.Add(ParseReference{TFhirReferralRequest}(child, path+'/referralRequest')){y.2}
      else if (child.baseName = 'careManager') then
        result.careManager := ParseReference{TFhirPractitioner}(child, path+'/careManager') {b}
      else if (child.baseName = 'careTeam') then
        result.careTeamList.Add(ParseEpisodeOfCareCareTeam(child, path+'/careTeam')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCare(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCare);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEpisodeOfCareStatusHistory(xml, 'statusHistory', elem.statusHistoryList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeReference{TFhirCondition}(xml, 'condition', elem.conditionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.referralRequestList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(xml, 'referralRequest', elem.referralRequestList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'careManager', elem.careManager);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeEpisodeOfCareCareTeam(xml, 'careTeam', elem.careTeamList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEpisodeOfCare(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEpisodeOfCare(jsn)); {2}
end;

function TFHIRJsonParser.ParseEpisodeOfCare(jsn : TJsonObject) : TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum);
    if jsn.has('statusHistory') then
      iterateArray(jsn.vArr['statusHistory'], result.statusHistoryList, parseEpisodeOfCareStatusHistory);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('condition') then
      iterateArray(jsn.vArr['condition'], result.conditionList, parseReference{TFhirCondition});
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('referralRequest') then
      iterateArray(jsn.vArr['referralRequest'], result.referralRequestList, parseReference{TFhirReferralRequest});
    if jsn.has('careManager') then
        result.careManager := ParseReference{TFhirPractitioner}(jsn.vObj['careManager']);{q}
    if jsn.has('careTeam') then
      iterateArray(jsn.vArr['careTeam'], result.careTeamList, parseEpisodeOfCareCareTeam);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEpisodeOfCare(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCare; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.statusHistoryList.Count > 0) then
  begin
    json.valueArray('statusHistory');
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEpisodeOfCareStatusHistory(json, '', elem.statusHistoryList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.conditionList.Count > 0) then
  begin
    json.valueArray('condition');
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.conditionList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) and (elem.referralRequestList.Count > 0) then
  begin
    json.valueArray('referralRequest');
    for i := 0 to elem.referralRequestList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(json, '', elem.referralRequestList[i]); {z - Reference(ReferralRequest)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'careManager', elem.careManager); {a}
  if (SummaryOption in [soFull, soData]) and (elem.careTeamList.Count > 0) then
  begin
    json.valueArray('careTeam');
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeEpisodeOfCareCareTeam(json, '', elem.careTeamList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeEpisodeOfCare(parent :  TRDFComplex; parentType, name : String; elem : TFhirEpisodeOfCare; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:EpisodeOfCare');
  end;
  composeDomainResource(this, 'EpisodeOfCare', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EpisodeOfCare', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'EpisodeOfCare', 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, -1);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEpisodeOfCareStatusHistory(this, 'EpisodeOfCare', 'statusHistory', elem.statusHistoryList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'EpisodeOfCare', 'type', elem.type_List[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'EpisodeOfCare', 'condition', elem.conditionList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'EpisodeOfCare', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'EpisodeOfCare', 'managingOrganization', elem.managingOrganizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'EpisodeOfCare', 'period', elem.periodElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.referralRequestList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(this, 'EpisodeOfCare', 'referralRequest', elem.referralRequestList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'EpisodeOfCare', 'careManager', elem.careManagerElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeEpisodeOfCareCareTeam(this, 'EpisodeOfCare', 'careTeam', elem.careTeamList[i], i);
end;

function TFHIRXmlParser.ParseExplanationOfBenefit(element : IXmlDomElement; path : string) : TFhirExplanationOfBenefit;
var
  child : IXMLDOMElement;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirClaim}(child, path+'/request') {b}
      else if (child.baseName = 'outcome') then
        result.outcomeElement := ParseEnum(CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, path+'/outcome', child){1a}
      else if (child.baseName = 'disposition') then
        result.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.baseName = 'requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefit(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefit);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaim}(xml, 'request', elem.request);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefit(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefit(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefit(jsn : TJsonObject) : TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirClaim}(jsn.vObj['request']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn['outcome'], jsn.vObj['_outcome'], CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefit(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefit; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaim}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
end;

procedure TFHIRRDFComposer.ComposeExplanationOfBenefit(parent :  TRDFComplex; parentType, name : String; elem : TFhirExplanationOfBenefit; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ExplanationOfBenefit');
  end;
  composeDomainResource(this, 'ExplanationOfBenefit', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ExplanationOfBenefit', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaim}(this, 'ExplanationOfBenefit', 'request', elem.requestElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ExplanationOfBenefit', 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ExplanationOfBenefit', 'disposition', elem.dispositionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ExplanationOfBenefit', 'ruleset', elem.rulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ExplanationOfBenefit', 'originalRuleset', elem.originalRulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ExplanationOfBenefit', 'created', elem.createdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'ExplanationOfBenefit', 'organization', elem.organizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'ExplanationOfBenefit', 'requestProvider', elem.requestProviderElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'ExplanationOfBenefit', 'requestOrganization', elem.requestOrganizationElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseFamilyMemberHistoryCondition(element : IXmlDomElement; path : string) : TFhirFamilyMemberHistoryCondition;
var
  child : IXMLDOMElement;
begin
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'outcome') then
        result.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.baseName = 'onsetQuantity') then
        result.onset := ParseQuantity(child, path+'/onsetQuantity'){x.3}
      else if (child.baseName = 'onsetRange') then
        result.onset := ParseRange(child, path+'/onsetRange'){x.3}
      else if (child.baseName = 'onsetPeriod') then
        result.onset := ParsePeriod(child, path+'/onsetPeriod'){x.3}
      else if (child.baseName = 'onsetString') then
        result.onset := ParseString(child, path+'/onsetString'){x.3}
      else if (child.baseName = 'note') then
        result.note := ParseAnnotation(child, path+'/note') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistoryCondition(xml : TXmlBuilder; name : string; elem : TFhirFamilyMemberHistoryCondition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'onsetQuantity', TFhirQuantity(elem.onset))
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirRange) {6} then
    ComposeRange(xml, 'onsetRange', TFhirRange(elem.onset))
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(xml, 'onsetPeriod', TFhirPeriod(elem.onset))
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirString) {6} then
    ComposeString(xml, 'onsetString', TFhirString(elem.onset));
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(xml, 'note', elem.note);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseFamilyMemberHistoryCondition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFamilyMemberHistoryCondition(jsn)); {2}
end;

function TFHIRJsonParser.ParseFamilyMemberHistoryCondition(jsn : TJsonObject) : TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('outcome') then
        result.outcome := ParseCodeableConcept(jsn.vObj['outcome']);{q}
    if jsn.has('onsetQuantity') {a4} then
      result.onset := ParseQuantity(jsn.vObj['onsetQuantity']);
    if jsn.has('onsetRange') {a4} then
      result.onset := ParseRange(jsn.vObj['onsetRange']);
    if jsn.has('onsetPeriod') {a4} then
      result.onset := ParsePeriod(jsn.vObj['onsetPeriod']);
    if jsn.has('onsetString') or jsn.has('_onsetString') then
      result.onset := parseString(jsn['onsetString'], jsn.vObj['_onsetString']);
    if jsn.has('note') then
        result.note := ParseAnnotation(jsn.vObj['note']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeFamilyMemberHistoryCondition(json : TJSONWriter; name : string; elem : TFhirFamilyMemberHistoryCondition; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'outcome', elem.outcome); {a}
  if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirQuantity) then 
    ComposeQuantity(json, 'onsetQuantity', TFhirQuantity(elem.onset)) 
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirRange) then 
    ComposeRange(json, 'onsetRange', TFhirRange(elem.onset)) 
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirPeriod) then 
    ComposePeriod(json, 'onsetPeriod', TFhirPeriod(elem.onset)) 
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirString) then 
  begin
    ComposeStringValue(json, 'onsetString', TFhirString(elem.onset), false);
    ComposeStringProps(json, 'onsetString', TFhirString(elem.onset), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(json, 'note', elem.note); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeFamilyMemberHistoryCondition(parent :  TRDFComplex; parentType, name : String; elem : TFhirFamilyMemberHistoryCondition; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:FamilyMemberHistoryCondition');
  end;
  composeBackboneElement(this, 'FamilyMemberHistoryCondition', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'FamilyMemberHistoryCondition', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'FamilyMemberHistoryCondition', 'outcome', elem.outcomeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirQuantity) {6} then
    ComposeQuantity(this, 'FamilyMemberHistoryCondition', 'onsetQuantity', TFhirQuantity(elem.onset), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirRange) {6} then
    ComposeRange(this, 'FamilyMemberHistoryCondition', 'onsetRange', TFhirRange(elem.onset), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(this, 'FamilyMemberHistoryCondition', 'onsetPeriod', TFhirPeriod(elem.onset), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistoryCondition', 'onsetString', TFhirString(elem.onset), -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(this, 'FamilyMemberHistoryCondition', 'note', elem.noteElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseFamilyMemberHistory(element : IXmlDomElement; path : string) : TFhirFamilyMemberHistory;
var
  child : IXMLDOMElement;
begin
  result := TFhirFamilyMemberHistory.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirHistoryStatusEnum, SYSTEMS_TFhirHistoryStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'relationship') then
        result.relationship := ParseCodeableConcept(child, path+'/relationship') {b}
      else if (child.baseName = 'gender') then
        result.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.baseName = 'bornPeriod') then
        result.born := ParsePeriod(child, path+'/bornPeriod'){x.3}
      else if (child.baseName = 'bornDate') then
        result.born := ParseDate(child, path+'/bornDate'){x.3}
      else if (child.baseName = 'bornString') then
        result.born := ParseString(child, path+'/bornString'){x.3}
      else if (child.baseName = 'ageQuantity') then
        result.age := ParseQuantity(child, path+'/ageQuantity'){x.3}
      else if (child.baseName = 'ageRange') then
        result.age := ParseRange(child, path+'/ageRange'){x.3}
      else if (child.baseName = 'ageString') then
        result.age := ParseString(child, path+'/ageString'){x.3}
      else if (child.baseName = 'deceasedBoolean') then
        result.deceased := ParseBoolean(child, path+'/deceasedBoolean'){x.3}
      else if (child.baseName = 'deceasedQuantity') then
        result.deceased := ParseQuantity(child, path+'/deceasedQuantity'){x.3}
      else if (child.baseName = 'deceasedRange') then
        result.deceased := ParseRange(child, path+'/deceasedRange'){x.3}
      else if (child.baseName = 'deceasedDate') then
        result.deceased := ParseDate(child, path+'/deceasedDate'){x.3}
      else if (child.baseName = 'deceasedString') then
        result.deceased := ParseString(child, path+'/deceasedString'){x.3}
      else if (child.baseName = 'note') then
        result.note := ParseAnnotation(child, path+'/note') {b}
      else if (child.baseName = 'condition') then
        result.conditionList.Add(ParseFamilyMemberHistoryCondition(child, path+'/condition')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistory(xml : TXmlBuilder; name : string; elem : TFhirFamilyMemberHistory);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirHistoryStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'relationship', elem.relationship);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soData]) and (elem.born is TFhirPeriod) {6} then
    ComposePeriod(xml, 'bornPeriod', TFhirPeriod(elem.born))
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirDate) {6} then
    ComposeDate(xml, 'bornDate', TFhirDate(elem.born))
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirString) {6} then
    ComposeString(xml, 'bornString', TFhirString(elem.born));
  if (SummaryOption in [soFull, soData]) and (elem.age is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'ageQuantity', TFhirQuantity(elem.age))
  else if (SummaryOption in [soFull, soData]) and (elem.age is TFhirRange) {6} then
    ComposeRange(xml, 'ageRange', TFhirRange(elem.age))
  else if (SummaryOption in [soFull, soData]) and (elem.age is TFhirString) {6} then
    ComposeString(xml, 'ageString', TFhirString(elem.age));
  if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'deceasedBoolean', TFhirBoolean(elem.deceased))
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'deceasedQuantity', TFhirQuantity(elem.deceased))
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirRange) {6} then
    ComposeRange(xml, 'deceasedRange', TFhirRange(elem.deceased))
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirDate) {6} then
    ComposeDate(xml, 'deceasedDate', TFhirDate(elem.deceased))
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirString) {6} then
    ComposeString(xml, 'deceasedString', TFhirString(elem.deceased));
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(xml, 'note', elem.note);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeFamilyMemberHistoryCondition(xml, 'condition', elem.conditionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseFamilyMemberHistory(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFamilyMemberHistory(jsn)); {2}
end;

function TFHIRJsonParser.ParseFamilyMemberHistory(jsn : TJsonObject) : TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirHistoryStatusEnum, SYSTEMS_TFhirHistoryStatusEnum);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCodeableConcept(jsn.vObj['relationship']);{q}
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('bornPeriod') {a4} then
      result.born := ParsePeriod(jsn.vObj['bornPeriod']);
    if jsn.has('bornDate') or jsn.has('_bornDate') then
      result.born := parseDate(jsn['bornDate'], jsn.vObj['_bornDate']);
    if jsn.has('bornString') or jsn.has('_bornString') then
      result.born := parseString(jsn['bornString'], jsn.vObj['_bornString']);
    if jsn.has('ageQuantity') {a4} then
      result.age := ParseQuantity(jsn.vObj['ageQuantity']);
    if jsn.has('ageRange') {a4} then
      result.age := ParseRange(jsn.vObj['ageRange']);
    if jsn.has('ageString') or jsn.has('_ageString') then
      result.age := parseString(jsn['ageString'], jsn.vObj['_ageString']);
    if jsn.has('deceasedBoolean') or jsn.has('_deceasedBoolean') then
      result.deceased := parseBoolean(jsn['deceasedBoolean'], jsn.vObj['_deceasedBoolean']);
    if jsn.has('deceasedQuantity') {a4} then
      result.deceased := ParseQuantity(jsn.vObj['deceasedQuantity']);
    if jsn.has('deceasedRange') {a4} then
      result.deceased := ParseRange(jsn.vObj['deceasedRange']);
    if jsn.has('deceasedDate') or jsn.has('_deceasedDate') then
      result.deceased := parseDate(jsn['deceasedDate'], jsn.vObj['_deceasedDate']);
    if jsn.has('deceasedString') or jsn.has('_deceasedString') then
      result.deceased := parseString(jsn['deceasedString'], jsn.vObj['_deceasedString']);
    if jsn.has('note') then
        result.note := ParseAnnotation(jsn.vObj['note']);{q}
    if jsn.has('condition') then
      iterateArray(jsn.vArr['condition'], result.conditionList, parseFamilyMemberHistoryCondition);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeFamilyMemberHistory(json : TJSONWriter; name : string; elem : TFhirFamilyMemberHistory; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirHistoryStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirHistoryStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'relationship', elem.relationship); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.born is TFhirPeriod) then 
    ComposePeriod(json, 'bornPeriod', TFhirPeriod(elem.born)) 
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirDate) then 
  begin
    ComposeDateValue(json, 'bornDate', TFhirDate(elem.born), false);
    ComposeDateProps(json, 'bornDate', TFhirDate(elem.born), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirString) then 
  begin
    ComposeStringValue(json, 'bornString', TFhirString(elem.born), false);
    ComposeStringProps(json, 'bornString', TFhirString(elem.born), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.age is TFhirQuantity) then 
    ComposeQuantity(json, 'ageQuantity', TFhirQuantity(elem.age)) 
  else if (SummaryOption in [soFull, soData]) and (elem.age is TFhirRange) then 
    ComposeRange(json, 'ageRange', TFhirRange(elem.age)) 
  else if (SummaryOption in [soFull, soData]) and (elem.age is TFhirString) then 
  begin
    ComposeStringValue(json, 'ageString', TFhirString(elem.age), false);
    ComposeStringProps(json, 'ageString', TFhirString(elem.age), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
    ComposeBooleanProps(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirQuantity) then 
    ComposeQuantity(json, 'deceasedQuantity', TFhirQuantity(elem.deceased)) 
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirRange) then 
    ComposeRange(json, 'deceasedRange', TFhirRange(elem.deceased)) 
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirDate) then 
  begin
    ComposeDateValue(json, 'deceasedDate', TFhirDate(elem.deceased), false);
    ComposeDateProps(json, 'deceasedDate', TFhirDate(elem.deceased), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirString) then 
  begin
    ComposeStringValue(json, 'deceasedString', TFhirString(elem.deceased), false);
    ComposeStringProps(json, 'deceasedString', TFhirString(elem.deceased), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(json, 'note', elem.note); {a}
  if (SummaryOption in [soFull, soData]) and (elem.conditionList.Count > 0) then
  begin
    json.valueArray('condition');
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeFamilyMemberHistoryCondition(json, '', elem.conditionList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeFamilyMemberHistory(parent :  TRDFComplex; parentType, name : String; elem : TFhirFamilyMemberHistory; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:FamilyMemberHistory');
  end;
  composeDomainResource(this, 'FamilyMemberHistory', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'FamilyMemberHistory', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'FamilyMemberHistory', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'FamilyMemberHistory', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'FamilyMemberHistory', 'status', elem.StatusElement, CODES_TFhirHistoryStatusEnum, SYSTEMS_TFhirHistoryStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'FamilyMemberHistory', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'FamilyMemberHistory', 'relationship', elem.relationshipElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'FamilyMemberHistory', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, -1);
  if (SummaryOption in [soFull, soData]) and (elem.born is TFhirPeriod) {6} then
    ComposePeriod(this, 'FamilyMemberHistory', 'bornPeriod', TFhirPeriod(elem.born), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirDate) {6} then
    ComposeDate(this, 'FamilyMemberHistory', 'bornDate', TFhirDate(elem.born), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory', 'bornString', TFhirString(elem.born), -1);
  if (SummaryOption in [soFull, soData]) and (elem.age is TFhirQuantity) {6} then
    ComposeQuantity(this, 'FamilyMemberHistory', 'ageQuantity', TFhirQuantity(elem.age), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.age is TFhirRange) {6} then
    ComposeRange(this, 'FamilyMemberHistory', 'ageRange', TFhirRange(elem.age), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.age is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory', 'ageString', TFhirString(elem.age), -1);
  if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(this, 'FamilyMemberHistory', 'deceasedBoolean', TFhirBoolean(elem.deceased), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirQuantity) {6} then
    ComposeQuantity(this, 'FamilyMemberHistory', 'deceasedQuantity', TFhirQuantity(elem.deceased), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirRange) {6} then
    ComposeRange(this, 'FamilyMemberHistory', 'deceasedRange', TFhirRange(elem.deceased), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirDate) {6} then
    ComposeDate(this, 'FamilyMemberHistory', 'deceasedDate', TFhirDate(elem.deceased), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory', 'deceasedString', TFhirString(elem.deceased), -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(this, 'FamilyMemberHistory', 'note', elem.noteElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeFamilyMemberHistoryCondition(this, 'FamilyMemberHistory', 'condition', elem.conditionList[i], i);
end;

function TFHIRXmlParser.ParseFlag(element : IXmlDomElement; path : string) : TFhirFlag;
var
  child : IXMLDOMElement;
begin
  result := TFhirFlag.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirFlagStatusEnum, SYSTEMS_TFhirFlagStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeFlag(xml : TXmlBuilder; name : string; elem : TFhirFlag);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirFlagStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseFlag(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFlag(jsn)); {2}
end;

function TFHIRJsonParser.ParseFlag(jsn : TJsonObject) : TFhirFlag;
begin
  result := TFhirFlag.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirFlagStatusEnum, SYSTEMS_TFhirFlagStatusEnum);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeFlag(json : TJSONWriter; name : string; elem : TFhirFlag; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirFlagStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirFlagStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
end;

procedure TFHIRRDFComposer.ComposeFlag(parent :  TRDFComplex; parentType, name : String; elem : TFhirFlag; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Flag');
  end;
  composeDomainResource(this, 'Flag', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Flag', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Flag', 'category', elem.categoryElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Flag', 'status', elem.StatusElement, CODES_TFhirFlagStatusEnum, SYSTEMS_TFhirFlagStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Flag', 'period', elem.periodElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Flag', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'Flag', 'encounter', elem.encounterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Flag', 'author', elem.authorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Flag', 'code', elem.codeElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseGoalOutcome(element : IXmlDomElement; path : string) : TFhirGoalOutcome;
var
  child : IXMLDOMElement;
begin
  result := TFhirGoalOutcome.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'resultCodeableConcept') then
        result.result := ParseCodeableConcept(child, path+'/resultCodeableConcept'){x.3}
      else if (child.baseName = 'resultReference') then
        result.result := ParseReference(child, path+'/resultReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeGoalOutcome(xml : TXmlBuilder; name : string; elem : TFhirGoalOutcome);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and (elem.result is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'resultCodeableConcept', TFhirCodeableConcept(elem.result))
  else if (SummaryOption in [soFull, soData]) and (elem.result is TFhirReference) {2} then
    ComposeReference(xml, 'resultReference', TFhirReference(elem.result));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseGoalOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGoalOutcome(jsn)); {2}
end;

function TFHIRJsonParser.ParseGoalOutcome(jsn : TJsonObject) : TFhirGoalOutcome;
begin
  result := TFhirGoalOutcome.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('resultCodeableConcept') {a4} then
      result.result := ParseCodeableConcept(jsn.vObj['resultCodeableConcept']);
    if jsn.has('resultReference') {a3} then
      result.result := ParseReference(jsn.vObj['resultReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeGoalOutcome(json : TJSONWriter; name : string; elem : TFhirGoalOutcome; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.result is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'resultCodeableConcept', TFhirCodeableConcept(elem.result)) 
  else if (SummaryOption in [soFull, soData]) and (elem.result is TFhirReference) then
    ComposeReference(json, 'resultReference', TFhirReference(elem.result));
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeGoalOutcome(parent :  TRDFComplex; parentType, name : String; elem : TFhirGoalOutcome; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:GoalOutcome');
  end;
  composeBackboneElement(this, 'GoalOutcome', name, elem, index);
  if (SummaryOption in [soFull, soData]) and (elem.result is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'GoalOutcome', 'resultCodeableConcept', TFhirCodeableConcept(elem.result), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.result is TFhirReference) {2} then
    ComposeReference(this, 'GoalOutcome', 'resultReference', TFhirReference(elem.result), -1);
end;

function TFHIRXmlParser.ParseGoal(element : IXmlDomElement; path : string) : TFhirGoal;
var
  child : IXMLDOMElement;
begin
  result := TFhirGoal.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'startDate') then
        result.start := ParseDate(child, path+'/startDate'){x.3}
      else if (child.baseName = 'startCodeableConcept') then
        result.start := ParseCodeableConcept(child, path+'/startCodeableConcept'){x.3}
      else if (child.baseName = 'targetDate') then
        result.target := ParseDate(child, path+'/targetDate'){x.3}
      else if (child.baseName = 'targetQuantity') then
        result.target := ParseQuantity(child, path+'/targetQuantity'){x.3}
      else if (child.baseName = 'category') then
        result.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirGoalStatusEnum, SYSTEMS_TFhirGoalStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'statusDate') then
        result.statusDateElement := ParseDate(child, path+'/statusDate') {b}
      else if (child.baseName = 'statusReason') then
        result.statusReason := ParseCodeableConcept(child, path+'/statusReason') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'priority') then
        result.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if (child.baseName = 'addresses') then
        result.addressesList.Add(ParseReference{Resource}(child, path+'/addresses')){y.2}
      else if (child.baseName = 'note') then
        result.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.baseName = 'outcome') then
        result.outcomeList.Add(ParseGoalOutcome(child, path+'/outcome')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeGoal(xml : TXmlBuilder; name : string; elem : TFhirGoal);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirDate) {6} then
    ComposeDate(xml, 'startDate', TFhirDate(elem.start))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'startCodeableConcept', TFhirCodeableConcept(elem.start));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirDate) {6} then
    ComposeDate(xml, 'targetDate', TFhirDate(elem.target))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'targetQuantity', TFhirQuantity(elem.target));
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirGoalStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'statusDate', elem.statusDateElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'statusReason', elem.statusReason);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{Resource}(xml, 'addresses', elem.addressesList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.outcomeList.Count - 1 do
      ComposeGoalOutcome(xml, 'outcome', elem.outcomeList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseGoal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGoal(jsn)); {2}
end;

function TFHIRJsonParser.ParseGoal(jsn : TJsonObject) : TFhirGoal;
begin
  result := TFhirGoal.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('startDate') or jsn.has('_startDate') then
      result.start := parseDate(jsn['startDate'], jsn.vObj['_startDate']);
    if jsn.has('startCodeableConcept') {a4} then
      result.start := ParseCodeableConcept(jsn.vObj['startCodeableConcept']);
    if jsn.has('targetDate') or jsn.has('_targetDate') then
      result.target := parseDate(jsn['targetDate'], jsn.vObj['_targetDate']);
    if jsn.has('targetQuantity') {a4} then
      result.target := ParseQuantity(jsn.vObj['targetQuantity']);
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirGoalStatusEnum, SYSTEMS_TFhirGoalStatusEnum);
    if jsn.has('statusDate') or jsn.has('_statusDate') then
        result.statusDateElement := ParseDate(jsn['statusDate'], jsn.vObj['_statusDate']);{q}
    if jsn.has('statusReason') then
        result.statusReason := ParseCodeableConcept(jsn.vObj['statusReason']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q}
    if jsn.has('addresses') then
      iterateArray(jsn.vArr['addresses'], result.addressesList, parseReference{Resource});
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('outcome') then
      iterateArray(jsn.vArr['outcome'], result.outcomeList, parseGoalOutcome);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeGoal(json : TJSONWriter; name : string; elem : TFhirGoal; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirDate) then 
  begin
    ComposeDateValue(json, 'startDate', TFhirDate(elem.start), false);
    ComposeDateProps(json, 'startDate', TFhirDate(elem.start), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'startCodeableConcept', TFhirCodeableConcept(elem.start)) ;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirDate) then 
  begin
    ComposeDateValue(json, 'targetDate', TFhirDate(elem.target), false);
    ComposeDateProps(json, 'targetDate', TFhirDate(elem.target), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirQuantity) then 
    ComposeQuantity(json, 'targetQuantity', TFhirQuantity(elem.target)) ;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirGoalStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirGoalStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'statusDate', elem.statusDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'statusDate', elem.statusDateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'statusReason', elem.statusReason); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  if (SummaryOption in [soFull, soData]) and (elem.addressesList.Count > 0) then
  begin
    json.valueArray('addresses');
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.addressesList[i]); {z - Reference(Condition|Observation|MedicationStatement|NutritionOrder|ProcedureRequest|RiskAssessment)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.outcomeList.Count > 0) then
  begin
    json.valueArray('outcome');
    for i := 0 to elem.outcomeList.Count - 1 do
      ComposeGoalOutcome(json, '', elem.outcomeList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeGoal(parent :  TRDFComplex; parentType, name : String; elem : TFhirGoal; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Goal');
  end;
  composeDomainResource(this, 'Goal', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Goal', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Goal', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirDate) {6} then
    ComposeDate(this, 'Goal', 'startDate', TFhirDate(elem.start), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Goal', 'startCodeableConcept', TFhirCodeableConcept(elem.start), -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirDate) {6} then
    ComposeDate(this, 'Goal', 'targetDate', TFhirDate(elem.target), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Goal', 'targetQuantity', TFhirQuantity(elem.target), -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Goal', 'category', elem.categoryList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Goal', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Goal', 'status', elem.StatusElement, CODES_TFhirGoalStatusEnum, SYSTEMS_TFhirGoalStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'Goal', 'statusDate', elem.statusDateElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Goal', 'statusReason', elem.statusReasonElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Goal', 'author', elem.authorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Goal', 'priority', elem.priorityElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{Resource}(this, 'Goal', 'addresses', elem.addressesList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Goal', 'note', elem.noteList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.outcomeList.Count - 1 do
      ComposeGoalOutcome(this, 'Goal', 'outcome', elem.outcomeList[i], i);
end;

function TFHIRXmlParser.ParseGroupCharacteristic(element : IXmlDomElement; path : string) : TFhirGroupCharacteristic;
var
  child : IXMLDOMElement;
begin
  result := TFhirGroupCharacteristic.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.baseName = 'valueRange') then
        result.value := ParseRange(child, path+'/valueRange'){x.3}
      else if (child.baseName = 'exclude') then
        result.excludeElement := ParseBoolean(child, path+'/exclude') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeGroupCharacteristic(xml : TXmlBuilder; name : string; elem : TFhirGroupCharacteristic);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value));
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'exclude', elem.excludeElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseGroupCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGroupCharacteristic(jsn)); {2}
end;

function TFHIRJsonParser.ParseGroupCharacteristic(jsn : TJsonObject) : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('exclude') or jsn.has('_exclude') then
        result.excludeElement := ParseBoolean(jsn['exclude'], jsn.vObj['_exclude']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeGroupCharacteristic(json : TJSONWriter; name : string; elem : TFhirGroupCharacteristic; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) ;
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'exclude', elem.excludeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'exclude', elem.excludeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeGroupCharacteristic(parent :  TRDFComplex; parentType, name : String; elem : TFhirGroupCharacteristic; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:GroupCharacteristic');
  end;
  composeBackboneElement(this, 'GroupCharacteristic', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'GroupCharacteristic', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'GroupCharacteristic', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'GroupCharacteristic', 'valueBoolean', TFhirBoolean(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'GroupCharacteristic', 'valueQuantity', TFhirQuantity(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'GroupCharacteristic', 'valueRange', TFhirRange(elem.value), -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'GroupCharacteristic', 'exclude', elem.excludeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'GroupCharacteristic', 'period', elem.periodElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseGroupMember(element : IXmlDomElement; path : string) : TFhirGroupMember;
var
  child : IXMLDOMElement;
begin
  result := TFhirGroupMember.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'entity') then
        result.entity := ParseReference{Resource}(child, path+'/entity') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'inactive') then
        result.inactiveElement := ParseBoolean(child, path+'/inactive') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeGroupMember(xml : TXmlBuilder; name : string; elem : TFhirGroupMember);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'entity', elem.entity);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'inactive', elem.inactiveElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseGroupMember(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGroupMember(jsn)); {2}
end;

function TFHIRJsonParser.ParseGroupMember(jsn : TJsonObject) : TFhirGroupMember;
begin
  result := TFhirGroupMember.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('entity') then
        result.entity := ParseReference{Resource}(jsn.vObj['entity']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('inactive') or jsn.has('_inactive') then
        result.inactiveElement := ParseBoolean(jsn['inactive'], jsn.vObj['_inactive']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeGroupMember(json : TJSONWriter; name : string; elem : TFhirGroupMember; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(json, 'entity', elem.entity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'inactive', elem.inactiveElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'inactive', elem.inactiveElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeGroupMember(parent :  TRDFComplex; parentType, name : String; elem : TFhirGroupMember; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:GroupMember');
  end;
  composeBackboneElement(this, 'GroupMember', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'GroupMember', 'entity', elem.entityElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'GroupMember', 'period', elem.periodElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'GroupMember', 'inactive', elem.inactiveElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseGroup(element : IXmlDomElement; path : string) : TFhirGroup;
var
  child : IXMLDOMElement;
begin
  result := TFhirGroup.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirGroupTypeEnum, SYSTEMS_TFhirGroupTypeEnum, path+'/type', child){1a}
      else if (child.baseName = 'actual') then
        result.actualElement := ParseBoolean(child, path+'/actual') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'quantity') then
        result.quantityElement := ParseUnsignedInt(child, path+'/quantity') {b}
      else if (child.baseName = 'characteristic') then
        result.characteristicList.Add(ParseGroupCharacteristic(child, path+'/characteristic')){y.2}
      else if (child.baseName = 'member') then
        result.memberList.Add(ParseGroupMember(child, path+'/member')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeGroup(xml : TXmlBuilder; name : string; elem : TFhirGroup);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirGroupTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'actual', elem.actualElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'quantity', elem.quantityElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeGroupCharacteristic(xml, 'characteristic', elem.characteristicList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.memberList.Count - 1 do
      ComposeGroupMember(xml, 'member', elem.memberList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGroup(jsn)); {2}
end;

function TFHIRJsonParser.ParseGroup(jsn : TJsonObject) : TFhirGroup;
begin
  result := TFhirGroup.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirGroupTypeEnum, SYSTEMS_TFhirGroupTypeEnum);
    if jsn.has('actual') or jsn.has('_actual') then
        result.actualElement := ParseBoolean(jsn['actual'], jsn.vObj['_actual']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('quantity') or jsn.has('_quantity') then
        result.quantityElement := ParseUnsignedInt(jsn['quantity'], jsn.vObj['_quantity']);{q}
    if jsn.has('characteristic') then
      iterateArray(jsn.vArr['characteristic'], result.characteristicList, parseGroupCharacteristic);
    if jsn.has('member') then
      iterateArray(jsn.vArr['member'], result.memberList, parseGroupMember);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeGroup(json : TJSONWriter; name : string; elem : TFhirGroup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirGroupTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirGroupTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'actual', elem.actualElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'actual', elem.actualElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntValue(json, 'quantity', elem.quantityElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntProps(json, 'quantity', elem.quantityElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.characteristicList.Count > 0) then
  begin
    json.valueArray('characteristic');
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeGroupCharacteristic(json, '', elem.characteristicList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.memberList.Count > 0) then
  begin
    json.valueArray('member');
    for i := 0 to elem.memberList.Count - 1 do
      ComposeGroupMember(json, '', elem.memberList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeGroup(parent :  TRDFComplex; parentType, name : String; elem : TFhirGroup; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Group');
  end;
  composeDomainResource(this, 'Group', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Group', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Group', 'type', elem.Type_Element, CODES_TFhirGroupTypeEnum, SYSTEMS_TFhirGroupTypeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Group', 'actual', elem.actualElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Group', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Group', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'Group', 'quantity', elem.quantityElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeGroupCharacteristic(this, 'Group', 'characteristic', elem.characteristicList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.memberList.Count - 1 do
      ComposeGroupMember(this, 'Group', 'member', elem.memberList[i], i);
end;

function TFHIRXmlParser.ParseHealthcareServiceServiceType(element : IXmlDomElement; path : string) : TFhirHealthcareServiceServiceType;
var
  child : IXMLDOMElement;
begin
  result := TFhirHealthcareServiceServiceType.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'specialty') then
        result.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceServiceType(xml : TXmlBuilder; name : string; elem : TFhirHealthcareServiceServiceType);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialty', elem.specialtyList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseHealthcareServiceServiceType(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHealthcareServiceServiceType(jsn)); {2}
end;

function TFHIRJsonParser.ParseHealthcareServiceServiceType(jsn : TJsonObject) : TFhirHealthcareServiceServiceType;
begin
  result := TFhirHealthcareServiceServiceType.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('specialty') then
      iterateArray(jsn.vArr['specialty'], result.specialtyList, parseCodeableConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeHealthcareServiceServiceType(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceServiceType; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.specialtyList.Count > 0) then
  begin
    json.valueArray('specialty');
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.specialtyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeHealthcareServiceServiceType(parent :  TRDFComplex; parentType, name : String; elem : TFhirHealthcareServiceServiceType; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:HealthcareServiceServiceType');
  end;
  composeBackboneElement(this, 'HealthcareServiceServiceType', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'HealthcareServiceServiceType', 'type', elem.type_Element, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareServiceServiceType', 'specialty', elem.specialtyList[i], i);
end;

function TFHIRXmlParser.ParseHealthcareServiceAvailableTime(element : IXmlDomElement; path : string) : TFhirHealthcareServiceAvailableTime;
var
  child : IXMLDOMElement;
begin
  result := TFhirHealthcareServiceAvailableTime.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'daysOfWeek') then
        result.daysOfWeekList.Add(ParseEnum(CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, path+'/daysOfWeek', child)){y.1}
      else if (child.baseName = 'allDay') then
        result.allDayElement := ParseBoolean(child, path+'/allDay') {b}
      else if (child.baseName = 'availableStartTime') then
        result.availableStartTimeElement := ParseTime(child, path+'/availableStartTime') {b}
      else if (child.baseName = 'availableEndTime') then
        result.availableEndTimeElement := ParseTime(child, path+'/availableEndTime') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceAvailableTime(xml : TXmlBuilder; name : string; elem : TFhirHealthcareServiceAvailableTime);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(xml, 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'allDay', elem.allDayElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(xml, 'availableStartTime', elem.availableStartTimeElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(xml, 'availableEndTime', elem.availableEndTimeElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseHealthcareServiceAvailableTime(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHealthcareServiceAvailableTime(jsn)); {2}
end;

function TFHIRJsonParser.ParseHealthcareServiceAvailableTime(jsn : TJsonObject) : TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('daysOfWeek') or jsn.has('_daysOfWeek') then
      iterateEnumArray(jsn.vArr['daysOfWeek'], jsn.vArr['_daysOfWeek'], jsn.path+'/daysOfWeek', result.daysOfWeekList, parseEnum, CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum);
    if jsn.has('allDay') or jsn.has('_allDay') then
        result.allDayElement := ParseBoolean(jsn['allDay'], jsn.vObj['_allDay']);{q}
    if jsn.has('availableStartTime') or jsn.has('_availableStartTime') then
        result.availableStartTimeElement := ParseTime(jsn['availableStartTime'], jsn.vObj['_availableStartTime']);{q}
    if jsn.has('availableEndTime') or jsn.has('_availableEndTime') then
        result.availableEndTimeElement := ParseTime(jsn['availableEndTime'], jsn.vObj['_availableEndTime']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeHealthcareServiceAvailableTime(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceAvailableTime; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.daysOfWeekList.Count > 0) then
  begin
    json.valueArray('daysOfWeek');
    ext := false;
    for i := 0 to elem.daysOfWeekList.Count - 1 do
    begin
      ext := ext or ((elem.daysOfWeekList[i].id <> '') or (elem.daysOfWeekList[i].hasExtensionList));
      ComposeEnumValue(json, '', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_daysOfWeek');
      for i := 0 to elem.daysOfWeekList.Count - 1 do
        ComposeEnumProps(json, '', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'allDay', elem.allDayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'allDay', elem.allDayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeValue(json, 'availableStartTime', elem.availableStartTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeProps(json, 'availableStartTime', elem.availableStartTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeValue(json, 'availableEndTime', elem.availableEndTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeProps(json, 'availableEndTime', elem.availableEndTimeElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeHealthcareServiceAvailableTime(parent :  TRDFComplex; parentType, name : String; elem : TFhirHealthcareServiceAvailableTime; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:HealthcareServiceAvailableTime');
  end;
  composeBackboneElement(this, 'HealthcareServiceAvailableTime', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(this, 'HealthcareServiceAvailableTime', 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(this, 'HealthcareServiceAvailableTime', 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'HealthcareServiceAvailableTime', 'allDay', elem.allDayElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(this, 'HealthcareServiceAvailableTime', 'availableStartTime', elem.availableStartTimeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(this, 'HealthcareServiceAvailableTime', 'availableEndTime', elem.availableEndTimeElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseHealthcareServiceNotAvailable(element : IXmlDomElement; path : string) : TFhirHealthcareServiceNotAvailable;
var
  child : IXMLDOMElement;
begin
  result := TFhirHealthcareServiceNotAvailable.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'during') then
        result.during := ParsePeriod(child, path+'/during') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceNotAvailable(xml : TXmlBuilder; name : string; elem : TFhirHealthcareServiceNotAvailable);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'during', elem.during);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseHealthcareServiceNotAvailable(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHealthcareServiceNotAvailable(jsn)); {2}
end;

function TFHIRJsonParser.ParseHealthcareServiceNotAvailable(jsn : TJsonObject) : TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('during') then
        result.during := ParsePeriod(jsn.vObj['during']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeHealthcareServiceNotAvailable(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceNotAvailable; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'during', elem.during); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeHealthcareServiceNotAvailable(parent :  TRDFComplex; parentType, name : String; elem : TFhirHealthcareServiceNotAvailable; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:HealthcareServiceNotAvailable');
  end;
  composeBackboneElement(this, 'HealthcareServiceNotAvailable', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'HealthcareServiceNotAvailable', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'HealthcareServiceNotAvailable', 'during', elem.duringElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseHealthcareService(element : IXmlDomElement; path : string) : TFhirHealthcareService;
var
  child : IXMLDOMElement;
begin
  result := TFhirHealthcareService.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'providedBy') then
        result.providedBy := ParseReference{TFhirOrganization}(child, path+'/providedBy') {b}
      else if (child.baseName = 'serviceCategory') then
        result.serviceCategory := ParseCodeableConcept(child, path+'/serviceCategory') {b}
      else if (child.baseName = 'serviceType') then
        result.serviceTypeList.Add(ParseHealthcareServiceServiceType(child, path+'/serviceType')){y.2}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'serviceName') then
        result.serviceNameElement := ParseString(child, path+'/serviceName') {b}
      else if (child.baseName = 'comment') then
        result.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.baseName = 'extraDetails') then
        result.extraDetailsElement := ParseString(child, path+'/extraDetails') {b}
      else if (child.baseName = 'photo') then
        result.photo := ParseAttachment(child, path+'/photo') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'coverageArea') then
        result.coverageAreaList.Add(ParseReference{TFhirLocation}(child, path+'/coverageArea')){y.2}
      else if (child.baseName = 'serviceProvisionCode') then
        result.serviceProvisionCodeList.Add(ParseCodeableConcept(child, path+'/serviceProvisionCode')){y.2}
      else if (child.baseName = 'eligibility') then
        result.eligibility := ParseCodeableConcept(child, path+'/eligibility') {b}
      else if (child.baseName = 'eligibilityNote') then
        result.eligibilityNoteElement := ParseString(child, path+'/eligibilityNote') {b}
      else if (child.baseName = 'programName') then
        result.programNameList.Add(ParseString(child, path+'/programName')){y.2}
      else if (child.baseName = 'characteristic') then
        result.characteristicList.Add(ParseCodeableConcept(child, path+'/characteristic')){y.2}
      else if (child.baseName = 'referralMethod') then
        result.referralMethodList.Add(ParseCodeableConcept(child, path+'/referralMethod')){y.2}
      else if (child.baseName = 'publicKey') then
        result.publicKeyElement := ParseString(child, path+'/publicKey') {b}
      else if (child.baseName = 'appointmentRequired') then
        result.appointmentRequiredElement := ParseBoolean(child, path+'/appointmentRequired') {b}
      else if (child.baseName = 'availableTime') then
        result.availableTimeList.Add(ParseHealthcareServiceAvailableTime(child, path+'/availableTime')){y.2}
      else if (child.baseName = 'notAvailable') then
        result.notAvailableList.Add(ParseHealthcareServiceNotAvailable(child, path+'/notAvailable')){y.2}
      else if (child.baseName = 'availabilityExceptions') then
        result.availabilityExceptionsElement := ParseString(child, path+'/availabilityExceptions') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeHealthcareService(xml : TXmlBuilder; name : string; elem : TFhirHealthcareService);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'providedBy', elem.providedBy);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'serviceCategory', elem.serviceCategory);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeHealthcareServiceServiceType(xml, 'serviceType', elem.serviceTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'serviceName', elem.serviceNameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'comment', elem.commentElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'extraDetails', elem.extraDetailsElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(xml, 'photo', elem.photo);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.coverageAreaList.Count - 1 do
      ComposeReference{TFhirLocation}(xml, 'coverageArea', elem.coverageAreaList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.serviceProvisionCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'serviceProvisionCode', elem.serviceProvisionCodeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'eligibility', elem.eligibility);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'eligibilityNote', elem.eligibilityNoteElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.programNameList.Count - 1 do
      ComposeString(xml, 'programName', elem.programNameList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeCodeableConcept(xml, 'characteristic', elem.characteristicList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.referralMethodList.Count - 1 do
      ComposeCodeableConcept(xml, 'referralMethod', elem.referralMethodList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'publicKey', elem.publicKeyElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'appointmentRequired', elem.appointmentRequiredElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.availableTimeList.Count - 1 do
      ComposeHealthcareServiceAvailableTime(xml, 'availableTime', elem.availableTimeList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.notAvailableList.Count - 1 do
      ComposeHealthcareServiceNotAvailable(xml, 'notAvailable', elem.notAvailableList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'availabilityExceptions', elem.availabilityExceptionsElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseHealthcareService(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHealthcareService(jsn)); {2}
end;

function TFHIRJsonParser.ParseHealthcareService(jsn : TJsonObject) : TFhirHealthcareService;
begin
  result := TFhirHealthcareService.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('providedBy') then
        result.providedBy := ParseReference{TFhirOrganization}(jsn.vObj['providedBy']);{q}
    if jsn.has('serviceCategory') then
        result.serviceCategory := ParseCodeableConcept(jsn.vObj['serviceCategory']);{q}
    if jsn.has('serviceType') then
      iterateArray(jsn.vArr['serviceType'], result.serviceTypeList, parseHealthcareServiceServiceType);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('serviceName') or jsn.has('_serviceName') then
        result.serviceNameElement := ParseString(jsn['serviceName'], jsn.vObj['_serviceName']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('extraDetails') or jsn.has('_extraDetails') then
        result.extraDetailsElement := ParseString(jsn['extraDetails'], jsn.vObj['_extraDetails']);{q}
    if jsn.has('photo') then
        result.photo := ParseAttachment(jsn.vObj['photo']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('coverageArea') then
      iterateArray(jsn.vArr['coverageArea'], result.coverageAreaList, parseReference{TFhirLocation});
    if jsn.has('serviceProvisionCode') then
      iterateArray(jsn.vArr['serviceProvisionCode'], result.serviceProvisionCodeList, parseCodeableConcept);
    if jsn.has('eligibility') then
        result.eligibility := ParseCodeableConcept(jsn.vObj['eligibility']);{q}
    if jsn.has('eligibilityNote') or jsn.has('_eligibilityNote') then
        result.eligibilityNoteElement := ParseString(jsn['eligibilityNote'], jsn.vObj['_eligibilityNote']);{q}
      if jsn.has('programName') or jsn.has('_programName') then
      iteratePrimitiveArray(jsn.vArr['programName'], jsn.vArr['_programName'], result.programNameList, parseString);
    if jsn.has('characteristic') then
      iterateArray(jsn.vArr['characteristic'], result.characteristicList, parseCodeableConcept);
    if jsn.has('referralMethod') then
      iterateArray(jsn.vArr['referralMethod'], result.referralMethodList, parseCodeableConcept);
    if jsn.has('publicKey') or jsn.has('_publicKey') then
        result.publicKeyElement := ParseString(jsn['publicKey'], jsn.vObj['_publicKey']);{q}
    if jsn.has('appointmentRequired') or jsn.has('_appointmentRequired') then
        result.appointmentRequiredElement := ParseBoolean(jsn['appointmentRequired'], jsn.vObj['_appointmentRequired']);{q}
    if jsn.has('availableTime') then
      iterateArray(jsn.vArr['availableTime'], result.availableTimeList, parseHealthcareServiceAvailableTime);
    if jsn.has('notAvailable') then
      iterateArray(jsn.vArr['notAvailable'], result.notAvailableList, parseHealthcareServiceNotAvailable);
    if jsn.has('availabilityExceptions') or jsn.has('_availabilityExceptions') then
        result.availabilityExceptionsElement := ParseString(jsn['availabilityExceptions'], jsn.vObj['_availabilityExceptions']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeHealthcareService(json : TJSONWriter; name : string; elem : TFhirHealthcareService; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'providedBy', elem.providedBy); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'serviceCategory', elem.serviceCategory); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.serviceTypeList.Count > 0) then
  begin
    json.valueArray('serviceType');
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeHealthcareServiceServiceType(json, '', elem.serviceTypeList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'serviceName', elem.serviceNameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'serviceName', elem.serviceNameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'extraDetails', elem.extraDetailsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'extraDetails', elem.extraDetailsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(json, 'photo', elem.photo); {a}
  if (SummaryOption in [soFull, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.coverageAreaList.Count > 0) then
  begin
    json.valueArray('coverageArea');
    for i := 0 to elem.coverageAreaList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '', elem.coverageAreaList[i]); {z - Reference(Location)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.serviceProvisionCodeList.Count > 0) then
  begin
    json.valueArray('serviceProvisionCode');
    for i := 0 to elem.serviceProvisionCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.serviceProvisionCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'eligibility', elem.eligibility); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'eligibilityNote', elem.eligibilityNoteElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'eligibilityNote', elem.eligibilityNoteElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.programNameList.Count > 0) then
  begin
    json.valueArray('programName');
    ext := false;
    for i := 0 to elem.programNameList.Count - 1 do
    begin
      ext := ext or ((elem.programNameList[i].id <> '') or (elem.programNameList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.programNameList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_programName');
      for i := 0 to elem.programNameList.Count - 1 do
        ComposeStringProps(json, '',elem.programNameList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.characteristicList.Count > 0) then
  begin
    json.valueArray('characteristic');
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.characteristicList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.referralMethodList.Count > 0) then
  begin
    json.valueArray('referralMethod');
    for i := 0 to elem.referralMethodList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.referralMethodList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'publicKey', elem.publicKeyElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'publicKey', elem.publicKeyElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'appointmentRequired', elem.appointmentRequiredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'appointmentRequired', elem.appointmentRequiredElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.availableTimeList.Count > 0) then
  begin
    json.valueArray('availableTime');
    for i := 0 to elem.availableTimeList.Count - 1 do
      ComposeHealthcareServiceAvailableTime(json, '', elem.availableTimeList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.notAvailableList.Count > 0) then
  begin
    json.valueArray('notAvailable');
    for i := 0 to elem.notAvailableList.Count - 1 do
      ComposeHealthcareServiceNotAvailable(json, '', elem.notAvailableList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'availabilityExceptions', elem.availabilityExceptionsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'availabilityExceptions', elem.availabilityExceptionsElement, false);
end;

procedure TFHIRRDFComposer.ComposeHealthcareService(parent :  TRDFComplex; parentType, name : String; elem : TFhirHealthcareService; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:HealthcareService');
  end;
  composeDomainResource(this, 'HealthcareService', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'HealthcareService', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'HealthcareService', 'providedBy', elem.providedByElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'HealthcareService', 'serviceCategory', elem.serviceCategoryElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeHealthcareServiceServiceType(this, 'HealthcareService', 'serviceType', elem.serviceTypeList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(this, 'HealthcareService', 'location', elem.locationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'HealthcareService', 'serviceName', elem.serviceNameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'HealthcareService', 'comment', elem.commentElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'HealthcareService', 'extraDetails', elem.extraDetailsElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(this, 'HealthcareService', 'photo', elem.photoElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'HealthcareService', 'telecom', elem.telecomList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.coverageAreaList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'HealthcareService', 'coverageArea', elem.coverageAreaList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.serviceProvisionCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'serviceProvisionCode', elem.serviceProvisionCodeList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'HealthcareService', 'eligibility', elem.eligibilityElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'HealthcareService', 'eligibilityNote', elem.eligibilityNoteElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.programNameList.Count - 1 do
      ComposeString(this, 'HealthcareService', 'programName', elem.programNameList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'characteristic', elem.characteristicList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.referralMethodList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'referralMethod', elem.referralMethodList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'HealthcareService', 'publicKey', elem.publicKeyElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'HealthcareService', 'appointmentRequired', elem.appointmentRequiredElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.availableTimeList.Count - 1 do
      ComposeHealthcareServiceAvailableTime(this, 'HealthcareService', 'availableTime', elem.availableTimeList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.notAvailableList.Count - 1 do
      ComposeHealthcareServiceNotAvailable(this, 'HealthcareService', 'notAvailable', elem.notAvailableList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'HealthcareService', 'availabilityExceptions', elem.availabilityExceptionsElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseImagingObjectSelectionStudy(element : IXmlDomElement; path : string) : TFhirImagingObjectSelectionStudy;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingObjectSelectionStudy.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'uid') then
        result.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'imagingStudy') then
        result.imagingStudy := ParseReference{TFhirImagingStudy}(child, path+'/imagingStudy') {b}
      else if (child.baseName = 'series') then
        result.seriesList.Add(ParseImagingObjectSelectionStudySeries(child, path+'/series')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelectionStudy(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudy);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(xml, 'uid', elem.uidElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirImagingStudy}(xml, 'imagingStudy', elem.imagingStudy);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingObjectSelectionStudySeries(xml, 'series', elem.seriesList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingObjectSelectionStudy(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingObjectSelectionStudy(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingObjectSelectionStudy(jsn : TJsonObject) : TFhirImagingObjectSelectionStudy;
begin
  result := TFhirImagingObjectSelectionStudy.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('imagingStudy') then
        result.imagingStudy := ParseReference{TFhirImagingStudy}(jsn.vObj['imagingStudy']);{q}
    if jsn.has('series') then
      iterateArray(jsn.vArr['series'], result.seriesList, parseImagingObjectSelectionStudySeries);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingObjectSelectionStudy(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudy; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidValue(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidProps(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirImagingStudy}(json, 'imagingStudy', elem.imagingStudy); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.seriesList.Count > 0) then
  begin
    json.valueArray('series');
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingObjectSelectionStudySeries(json, '', elem.seriesList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImagingObjectSelectionStudy(parent :  TRDFComplex; parentType, name : String; elem : TFhirImagingObjectSelectionStudy; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImagingObjectSelectionStudy');
  end;
  composeBackboneElement(this, 'ImagingObjectSelectionStudy', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(this, 'ImagingObjectSelectionStudy', 'uid', elem.uidElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ImagingObjectSelectionStudy', 'url', elem.urlElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirImagingStudy}(this, 'ImagingObjectSelectionStudy', 'imagingStudy', elem.imagingStudyElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingObjectSelectionStudySeries(this, 'ImagingObjectSelectionStudy', 'series', elem.seriesList[i], i);
end;

function TFHIRXmlParser.ParseImagingObjectSelectionStudySeries(element : IXmlDomElement; path : string) : TFhirImagingObjectSelectionStudySeries;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingObjectSelectionStudySeries.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'uid') then
        result.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'instance') then
        result.instanceList.Add(ParseImagingObjectSelectionStudySeriesInstance(child, path+'/instance')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelectionStudySeries(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudySeries);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(xml, 'uid', elem.uidElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingObjectSelectionStudySeriesInstance(xml, 'instance', elem.instanceList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingObjectSelectionStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingObjectSelectionStudySeries(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingObjectSelectionStudySeries(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeries;
begin
  result := TFhirImagingObjectSelectionStudySeries.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('instance') then
      iterateArray(jsn.vArr['instance'], result.instanceList, parseImagingObjectSelectionStudySeriesInstance);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingObjectSelectionStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeries; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidValue(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidProps(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.instanceList.Count > 0) then
  begin
    json.valueArray('instance');
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingObjectSelectionStudySeriesInstance(json, '', elem.instanceList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImagingObjectSelectionStudySeries(parent :  TRDFComplex; parentType, name : String; elem : TFhirImagingObjectSelectionStudySeries; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImagingObjectSelectionStudySeries');
  end;
  composeBackboneElement(this, 'ImagingObjectSelectionStudySeries', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(this, 'ImagingObjectSelectionStudySeries', 'uid', elem.uidElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ImagingObjectSelectionStudySeries', 'url', elem.urlElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingObjectSelectionStudySeriesInstance(this, 'ImagingObjectSelectionStudySeries', 'instance', elem.instanceList[i], i);
end;

function TFHIRXmlParser.ParseImagingObjectSelectionStudySeriesInstance(element : IXmlDomElement; path : string) : TFhirImagingObjectSelectionStudySeriesInstance;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sopClass') then
        result.sopClassElement := ParseOid(child, path+'/sopClass') {b}
      else if (child.baseName = 'uid') then
        result.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'frames') then
        result.framesList.Add(ParseImagingObjectSelectionStudySeriesInstanceFrames(child, path+'/frames')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelectionStudySeriesInstance(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(xml, 'sopClass', elem.sopClassElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(xml, 'uid', elem.uidElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.framesList.Count - 1 do
      ComposeImagingObjectSelectionStudySeriesInstanceFrames(xml, 'frames', elem.framesList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingObjectSelectionStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingObjectSelectionStudySeriesInstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingObjectSelectionStudySeriesInstance(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeriesInstance;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstance.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sopClass') or jsn.has('_sopClass') then
        result.sopClassElement := ParseOid(jsn['sopClass'], jsn.vObj['_sopClass']);{q}
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('frames') then
      iterateArray(jsn.vArr['frames'], result.framesList, parseImagingObjectSelectionStudySeriesInstanceFrames);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingObjectSelectionStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidValue(json, 'sopClass', elem.sopClassElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidProps(json, 'sopClass', elem.sopClassElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidValue(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidProps(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.framesList.Count > 0) then
  begin
    json.valueArray('frames');
    for i := 0 to elem.framesList.Count - 1 do
      ComposeImagingObjectSelectionStudySeriesInstanceFrames(json, '', elem.framesList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImagingObjectSelectionStudySeriesInstance(parent :  TRDFComplex; parentType, name : String; elem : TFhirImagingObjectSelectionStudySeriesInstance; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImagingObjectSelectionStudySeriesInstance');
  end;
  composeBackboneElement(this, 'ImagingObjectSelectionStudySeriesInstance', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(this, 'ImagingObjectSelectionStudySeriesInstance', 'sopClass', elem.sopClassElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(this, 'ImagingObjectSelectionStudySeriesInstance', 'uid', elem.uidElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ImagingObjectSelectionStudySeriesInstance', 'url', elem.urlElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.framesList.Count - 1 do
      ComposeImagingObjectSelectionStudySeriesInstanceFrames(this, 'ImagingObjectSelectionStudySeriesInstance', 'frames', elem.framesList[i], i);
end;

function TFHIRXmlParser.ParseImagingObjectSelectionStudySeriesInstanceFrames(element : IXmlDomElement; path : string) : TFhirImagingObjectSelectionStudySeriesInstanceFrames;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceFrames.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'frameNumbers') then
        result.frameNumbersList.Add(ParseUnsignedInt(child, path+'/frameNumbers')){y.2}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelectionStudySeriesInstanceFrames(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.frameNumbersList.Count - 1 do
      ComposeUnsignedInt(xml, 'frameNumbers', elem.frameNumbersList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingObjectSelectionStudySeriesInstanceFrames(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingObjectSelectionStudySeriesInstanceFrames(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingObjectSelectionStudySeriesInstanceFrames(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeriesInstanceFrames;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceFrames.create;
  try
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('frameNumbers') or jsn.has('_frameNumbers') then
      iteratePrimitiveArray(jsn.vArr['frameNumbers'], jsn.vArr['_frameNumbers'], result.frameNumbersList, parseUnsignedInt);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingObjectSelectionStudySeriesInstanceFrames(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.frameNumbersList.Count > 0) then
  begin
    json.valueArray('frameNumbers');
    ext := false;
    for i := 0 to elem.frameNumbersList.Count - 1 do
    begin
      ext := ext or ((elem.frameNumbersList[i].id <> '') or (elem.frameNumbersList[i].hasExtensionList));
      ComposeUnsignedIntValue(json, '',elem.frameNumbersList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_frameNumbers');
      for i := 0 to elem.frameNumbersList.Count - 1 do
        ComposeUnsignedIntProps(json, '',elem.frameNumbersList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImagingObjectSelectionStudySeriesInstanceFrames(parent :  TRDFComplex; parentType, name : String; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImagingObjectSelectionStudySeriesInstanceFrames');
  end;
  composeBackboneElement(this, 'ImagingObjectSelectionStudySeriesInstanceFrames', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.frameNumbersList.Count - 1 do
      ComposeUnsignedInt(this, 'ImagingObjectSelectionStudySeriesInstanceFrames', 'frameNumbers', elem.frameNumbersList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ImagingObjectSelectionStudySeriesInstanceFrames', 'url', elem.urlElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseImagingObjectSelection(element : IXmlDomElement; path : string) : TFhirImagingObjectSelection;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingObjectSelection.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'uid') then
        result.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'title') then
        result.title := ParseCodeableConcept(child, path+'/title') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'authoringTime') then
        result.authoringTimeElement := ParseDateTime(child, path+'/authoringTime') {b}
      else if (child.baseName = 'study') then
        result.studyList.Add(ParseImagingObjectSelectionStudy(child, path+'/study')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelection(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelection);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(xml, 'uid', elem.uidElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'title', elem.title);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'authoringTime', elem.authoringTimeElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.studyList.Count - 1 do
      ComposeImagingObjectSelectionStudy(xml, 'study', elem.studyList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingObjectSelection(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingObjectSelection(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingObjectSelection(jsn : TJsonObject) : TFhirImagingObjectSelection;
begin
  result := TFhirImagingObjectSelection.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('title') then
        result.title := ParseCodeableConcept(jsn.vObj['title']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('authoringTime') or jsn.has('_authoringTime') then
        result.authoringTimeElement := ParseDateTime(jsn['authoringTime'], jsn.vObj['_authoringTime']);{q}
    if jsn.has('study') then
      iterateArray(jsn.vArr['study'], result.studyList, parseImagingObjectSelectionStudy);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingObjectSelection(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelection; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidValue(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidProps(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'title', elem.title); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'authoringTime', elem.authoringTimeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'authoringTime', elem.authoringTimeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.studyList.Count > 0) then
  begin
    json.valueArray('study');
    for i := 0 to elem.studyList.Count - 1 do
      ComposeImagingObjectSelectionStudy(json, '', elem.studyList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeImagingObjectSelection(parent :  TRDFComplex; parentType, name : String; elem : TFhirImagingObjectSelection; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImagingObjectSelection');
  end;
  composeDomainResource(this, 'ImagingObjectSelection', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(this, 'ImagingObjectSelection', 'uid', elem.uidElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'ImagingObjectSelection', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ImagingObjectSelection', 'title', elem.titleElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImagingObjectSelection', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'ImagingObjectSelection', 'author', elem.authorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ImagingObjectSelection', 'authoringTime', elem.authoringTimeElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.studyList.Count - 1 do
      ComposeImagingObjectSelectionStudy(this, 'ImagingObjectSelection', 'study', elem.studyList[i], i);
end;

function TFHIRXmlParser.ParseImagingStudySeries(element : IXmlDomElement; path : string) : TFhirImagingStudySeries;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingStudySeries.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'number') then
        result.numberElement := ParseUnsignedInt(child, path+'/number') {b}
      else if (child.baseName = 'modality') then
        result.modality := ParseCoding(child, path+'/modality') {b}
      else if (child.baseName = 'uid') then
        result.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'numberOfInstances') then
        result.numberOfInstancesElement := ParseUnsignedInt(child, path+'/numberOfInstances') {b}
      else if (child.baseName = 'availability') then
        result.availabilityElement := ParseEnum(CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum, path+'/availability', child){1a}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'bodySite') then
        result.bodySite := ParseCoding(child, path+'/bodySite') {b}
      else if (child.baseName = 'laterality') then
        result.laterality := ParseCoding(child, path+'/laterality') {b}
      else if (child.baseName = 'started') then
        result.startedElement := ParseDateTime(child, path+'/started') {b}
      else if (child.baseName = 'instance') then
        result.instanceList.Add(ParseImagingStudySeriesInstance(child, path+'/instance')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeries(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeries);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'number', elem.numberElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'modality', elem.modality);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(xml, 'uid', elem.uidElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'numberOfInstances', elem.numberOfInstancesElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'bodySite', elem.bodySite);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'laterality', elem.laterality);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'started', elem.startedElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingStudySeriesInstance(xml, 'instance', elem.instanceList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudySeries(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingStudySeries(jsn : TJsonObject) : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('number') or jsn.has('_number') then
        result.numberElement := ParseUnsignedInt(jsn['number'], jsn.vObj['_number']);{q}
    if jsn.has('modality') then
        result.modality := ParseCoding(jsn.vObj['modality']);{q}
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('numberOfInstances') or jsn.has('_numberOfInstances') then
        result.numberOfInstancesElement := ParseUnsignedInt(jsn['numberOfInstances'], jsn.vObj['_numberOfInstances']);{q}
    if jsn.has('availability') or jsn.has('_availability')  then
      result.availabilityElement := parseEnum(jsn.path+'/availability', jsn['availability'], jsn.vObj['_availability'], CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('bodySite') then
        result.bodySite := ParseCoding(jsn.vObj['bodySite']);{q}
    if jsn.has('laterality') then
        result.laterality := ParseCoding(jsn.vObj['laterality']);{q}
    if jsn.has('started') or jsn.has('_started') then
        result.startedElement := ParseDateTime(jsn['started'], jsn.vObj['_started']);{q}
    if jsn.has('instance') then
      iterateArray(jsn.vArr['instance'], result.instanceList, parseImagingStudySeriesInstance);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingStudySeries; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntValue(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntProps(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'modality', elem.modality); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidValue(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidProps(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntValue(json, 'numberOfInstances', elem.numberOfInstancesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntProps(json, 'numberOfInstances', elem.numberOfInstancesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'bodySite', elem.bodySite); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'laterality', elem.laterality); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'started', elem.startedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'started', elem.startedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.instanceList.Count > 0) then
  begin
    json.valueArray('instance');
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingStudySeriesInstance(json, '', elem.instanceList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImagingStudySeries(parent :  TRDFComplex; parentType, name : String; elem : TFhirImagingStudySeries; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImagingStudySeries');
  end;
  composeBackboneElement(this, 'ImagingStudySeries', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudySeries', 'number', elem.numberElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ImagingStudySeries', 'modality', elem.modalityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(this, 'ImagingStudySeries', 'uid', elem.uidElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImagingStudySeries', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudySeries', 'numberOfInstances', elem.numberOfInstancesElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ImagingStudySeries', 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ImagingStudySeries', 'url', elem.urlElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ImagingStudySeries', 'bodySite', elem.bodySiteElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ImagingStudySeries', 'laterality', elem.lateralityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ImagingStudySeries', 'started', elem.startedElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingStudySeriesInstance(this, 'ImagingStudySeries', 'instance', elem.instanceList[i], i);
end;

function TFHIRXmlParser.ParseImagingStudySeriesInstance(element : IXmlDomElement; path : string) : TFhirImagingStudySeriesInstance;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'number') then
        result.numberElement := ParseUnsignedInt(child, path+'/number') {b}
      else if (child.baseName = 'uid') then
        result.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'sopClass') then
        result.sopClassElement := ParseOid(child, path+'/sopClass') {b}
      else if (child.baseName = 'type') then
        result.type_Element := ParseString(child, path+'/type') {b}
      else if (child.baseName = 'title') then
        result.titleElement := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'content') then
        result.contentList.Add(ParseAttachment(child, path+'/content')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeriesInstance(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeriesInstance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'number', elem.numberElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(xml, 'uid', elem.uidElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(xml, 'sopClass', elem.sopClassElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'type', elem.type_Element);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', elem.titleElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contentList.Count - 1 do
      ComposeAttachment(xml, 'content', elem.contentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudySeriesInstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingStudySeriesInstance(jsn : TJsonObject) : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('number') or jsn.has('_number') then
        result.numberElement := ParseUnsignedInt(jsn['number'], jsn.vObj['_number']);{q}
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('sopClass') or jsn.has('_sopClass') then
        result.sopClassElement := ParseOid(jsn['sopClass'], jsn.vObj['_sopClass']);{q}
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := ParseString(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseAttachment);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingStudySeriesInstance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntValue(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntProps(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidValue(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidProps(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidValue(json, 'sopClass', elem.sopClassElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidProps(json, 'sopClass', elem.sopClassElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.contentList.Count > 0) then
  begin
    json.valueArray('content');
    for i := 0 to elem.contentList.Count - 1 do
      ComposeAttachment(json, '', elem.contentList[i]); {z - Attachment}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImagingStudySeriesInstance(parent :  TRDFComplex; parentType, name : String; elem : TFhirImagingStudySeriesInstance; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImagingStudySeriesInstance');
  end;
  composeBackboneElement(this, 'ImagingStudySeriesInstance', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudySeriesInstance', 'number', elem.numberElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(this, 'ImagingStudySeriesInstance', 'uid', elem.uidElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(this, 'ImagingStudySeriesInstance', 'sopClass', elem.sopClassElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImagingStudySeriesInstance', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImagingStudySeriesInstance', 'title', elem.titleElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contentList.Count - 1 do
      ComposeAttachment(this, 'ImagingStudySeriesInstance', 'content', elem.contentList[i], i);
end;

function TFHIRXmlParser.ParseImagingStudy(element : IXmlDomElement; path : string) : TFhirImagingStudy;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingStudy.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'started') then
        result.startedElement := ParseDateTime(child, path+'/started') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'uid') then
        result.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'accession') then
        result.accession := ParseIdentifier(child, path+'/accession') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'order') then
        result.orderList.Add(ParseReference{TFhirDiagnosticOrder}(child, path+'/order')){y.2}
      else if (child.baseName = 'modalityList') then
        result.modalityListList.Add(ParseCoding(child, path+'/modalityList')){y.2}
      else if (child.baseName = 'referrer') then
        result.referrer := ParseReference{TFhirPractitioner}(child, path+'/referrer') {b}
      else if (child.baseName = 'availability') then
        result.availabilityElement := ParseEnum(CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum, path+'/availability', child){1a}
      else if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'numberOfSeries') then
        result.numberOfSeriesElement := ParseUnsignedInt(child, path+'/numberOfSeries') {b}
      else if (child.baseName = 'numberOfInstances') then
        result.numberOfInstancesElement := ParseUnsignedInt(child, path+'/numberOfInstances') {b}
      else if (child.baseName = 'procedure') then
        result.procedure_List.Add(ParseReference{TFhirProcedure}(child, path+'/procedure')){y.2}
      else if (child.baseName = 'interpreter') then
        result.interpreter := ParseReference{TFhirPractitioner}(child, path+'/interpreter') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'series') then
        result.seriesList.Add(ParseImagingStudySeries(child, path+'/series')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingStudy(xml : TXmlBuilder; name : string; elem : TFhirImagingStudy);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'started', elem.startedElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(xml, 'uid', elem.uidElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'accession', elem.accession);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.orderList.Count - 1 do
      ComposeReference{TFhirDiagnosticOrder}(xml, 'order', elem.orderList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.modalityListList.Count - 1 do
      ComposeCoding(xml, 'modalityList', elem.modalityListList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'referrer', elem.referrer);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'numberOfSeries', elem.numberOfSeriesElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'numberOfInstances', elem.numberOfInstancesElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.procedure_List.Count - 1 do
      ComposeReference{TFhirProcedure}(xml, 'procedure', elem.procedure_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'interpreter', elem.interpreter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingStudySeries(xml, 'series', elem.seriesList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingStudy(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudy(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingStudy(jsn : TJsonObject) : TFhirImagingStudy;
begin
  result := TFhirImagingStudy.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('started') or jsn.has('_started') then
        result.startedElement := ParseDateTime(jsn['started'], jsn.vObj['_started']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('accession') then
        result.accession := ParseIdentifier(jsn.vObj['accession']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('order') then
      iterateArray(jsn.vArr['order'], result.orderList, parseReference{TFhirDiagnosticOrder});
    if jsn.has('modalityList') then
      iterateArray(jsn.vArr['modalityList'], result.modalityListList, parseCoding);
    if jsn.has('referrer') then
        result.referrer := ParseReference{TFhirPractitioner}(jsn.vObj['referrer']);{q}
    if jsn.has('availability') or jsn.has('_availability')  then
      result.availabilityElement := parseEnum(jsn.path+'/availability', jsn['availability'], jsn.vObj['_availability'], CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('numberOfSeries') or jsn.has('_numberOfSeries') then
        result.numberOfSeriesElement := ParseUnsignedInt(jsn['numberOfSeries'], jsn.vObj['_numberOfSeries']);{q}
    if jsn.has('numberOfInstances') or jsn.has('_numberOfInstances') then
        result.numberOfInstancesElement := ParseUnsignedInt(jsn['numberOfInstances'], jsn.vObj['_numberOfInstances']);{q}
    if jsn.has('procedure') then
      iterateArray(jsn.vArr['procedure'], result.procedure_List, parseReference{TFhirProcedure});
    if jsn.has('interpreter') then
        result.interpreter := ParseReference{TFhirPractitioner}(jsn.vObj['interpreter']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('series') then
      iterateArray(jsn.vArr['series'], result.seriesList, parseImagingStudySeries);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingStudy(json : TJSONWriter; name : string; elem : TFhirImagingStudy; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'started', elem.startedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'started', elem.startedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidValue(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidProps(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'accession', elem.accession); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.orderList.Count > 0) then
  begin
    json.valueArray('order');
    for i := 0 to elem.orderList.Count - 1 do
      ComposeReference{TFhirDiagnosticOrder}(json, '', elem.orderList[i]); {z - Reference(DiagnosticOrder)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.modalityListList.Count > 0) then
  begin
    json.valueArray('modalityList');
    for i := 0 to elem.modalityListList.Count - 1 do
      ComposeCoding(json, '', elem.modalityListList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'referrer', elem.referrer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntValue(json, 'numberOfSeries', elem.numberOfSeriesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntProps(json, 'numberOfSeries', elem.numberOfSeriesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntValue(json, 'numberOfInstances', elem.numberOfInstancesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntProps(json, 'numberOfInstances', elem.numberOfInstancesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.procedure_List.Count > 0) then
  begin
    json.valueArray('procedure');
    for i := 0 to elem.procedure_List.Count - 1 do
      ComposeReference{TFhirProcedure}(json, '', elem.procedure_List[i]); {z - Reference(Procedure)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'interpreter', elem.interpreter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.seriesList.Count > 0) then
  begin
    json.valueArray('series');
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingStudySeries(json, '', elem.seriesList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeImagingStudy(parent :  TRDFComplex; parentType, name : String; elem : TFhirImagingStudy; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImagingStudy');
  end;
  composeDomainResource(this, 'ImagingStudy', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ImagingStudy', 'started', elem.startedElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'ImagingStudy', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(this, 'ImagingStudy', 'uid', elem.uidElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'ImagingStudy', 'accession', elem.accessionElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ImagingStudy', 'identifier', elem.identifierList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.orderList.Count - 1 do
      ComposeReference{TFhirDiagnosticOrder}(this, 'ImagingStudy', 'order', elem.orderList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.modalityListList.Count - 1 do
      ComposeCoding(false, this, 'ImagingStudy', 'modalityList', elem.modalityListList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'ImagingStudy', 'referrer', elem.referrerElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ImagingStudy', 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ImagingStudy', 'url', elem.urlElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudy', 'numberOfSeries', elem.numberOfSeriesElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudy', 'numberOfInstances', elem.numberOfInstancesElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.procedure_List.Count - 1 do
      ComposeReference{TFhirProcedure}(this, 'ImagingStudy', 'procedure', elem.procedure_List[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'ImagingStudy', 'interpreter', elem.interpreterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImagingStudy', 'description', elem.descriptionElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingStudySeries(this, 'ImagingStudy', 'series', elem.seriesList[i], i);
end;

function TFHIRXmlParser.ParseImmunizationExplanation(element : IXmlDomElement; path : string) : TFhirImmunizationExplanation;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationExplanation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'reason') then
        result.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.baseName = 'reasonNotGiven') then
        result.reasonNotGivenList.Add(ParseCodeableConcept(child, path+'/reasonNotGiven')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationExplanation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationExplanation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonNotGiven', elem.reasonNotGivenList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationExplanation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationExplanation(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationExplanation(jsn : TJsonObject) : TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('reasonNotGiven') then
      iterateArray(jsn.vArr['reasonNotGiven'], result.reasonNotGivenList, parseCodeableConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationExplanation(json : TJSONWriter; name : string; elem : TFhirImmunizationExplanation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.reasonList.Count > 0) then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.reasonNotGivenList.Count > 0) then
  begin
    json.valueArray('reasonNotGiven');
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonNotGivenList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImmunizationExplanation(parent :  TRDFComplex; parentType, name : String; elem : TFhirImmunizationExplanation; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImmunizationExplanation');
  end;
  composeBackboneElement(this, 'ImmunizationExplanation', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'ImmunizationExplanation', 'reason', elem.reasonList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(this, 'ImmunizationExplanation', 'reasonNotGiven', elem.reasonNotGivenList[i], i);
end;

function TFHIRXmlParser.ParseImmunizationReaction(element : IXmlDomElement; path : string) : TFhirImmunizationReaction;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationReaction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'detail') then
        result.detail := ParseReference{TFhirObservation}(child, path+'/detail') {b}
      else if (child.baseName = 'reported') then
        result.reportedElement := ParseBoolean(child, path+'/reported') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationReaction(xml : TXmlBuilder; name : string; elem : TFhirImmunizationReaction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirObservation}(xml, 'detail', elem.detail);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'reported', elem.reportedElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationReaction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationReaction(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationReaction(jsn : TJsonObject) : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('detail') then
        result.detail := ParseReference{TFhirObservation}(jsn.vObj['detail']);{q}
    if jsn.has('reported') or jsn.has('_reported') then
        result.reportedElement := ParseBoolean(jsn['reported'], jsn.vObj['_reported']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationReaction(json : TJSONWriter; name : string; elem : TFhirImmunizationReaction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirObservation}(json, 'detail', elem.detail); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'reported', elem.reportedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'reported', elem.reportedElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImmunizationReaction(parent :  TRDFComplex; parentType, name : String; elem : TFhirImmunizationReaction; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImmunizationReaction');
  end;
  composeBackboneElement(this, 'ImmunizationReaction', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'ImmunizationReaction', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirObservation}(this, 'ImmunizationReaction', 'detail', elem.detailElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ImmunizationReaction', 'reported', elem.reportedElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseImmunizationVaccinationProtocol(element : IXmlDomElement; path : string) : TFhirImmunizationVaccinationProtocol;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'doseSequence') then
        result.doseSequenceElement := ParsePositiveInt(child, path+'/doseSequence') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'authority') then
        result.authority := ParseReference{TFhirOrganization}(child, path+'/authority') {b}
      else if (child.baseName = 'series') then
        result.seriesElement := ParseString(child, path+'/series') {b}
      else if (child.baseName = 'seriesDoses') then
        result.seriesDosesElement := ParsePositiveInt(child, path+'/seriesDoses') {b}
      else if (child.baseName = 'targetDisease') then
        result.targetDiseaseList.Add(ParseCodeableConcept(child, path+'/targetDisease')){y.2}
      else if (child.baseName = 'doseStatus') then
        result.doseStatus := ParseCodeableConcept(child, path+'/doseStatus') {b}
      else if (child.baseName = 'doseStatusReason') then
        result.doseStatusReason := ParseCodeableConcept(child, path+'/doseStatusReason') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationVaccinationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationVaccinationProtocol);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'doseSequence', elem.doseSequenceElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'authority', elem.authority);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'series', elem.seriesElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'seriesDoses', elem.seriesDosesElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.targetDiseaseList.Count - 1 do
      ComposeCodeableConcept(xml, 'targetDisease', elem.targetDiseaseList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'doseStatus', elem.doseStatus);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'doseStatusReason', elem.doseStatusReason);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationVaccinationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationVaccinationProtocol(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationVaccinationProtocol(jsn : TJsonObject) : TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('doseSequence') or jsn.has('_doseSequence') then
        result.doseSequenceElement := ParsePositiveInt(jsn['doseSequence'], jsn.vObj['_doseSequence']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('authority') then
        result.authority := ParseReference{TFhirOrganization}(jsn.vObj['authority']);{q}
    if jsn.has('series') or jsn.has('_series') then
        result.seriesElement := ParseString(jsn['series'], jsn.vObj['_series']);{q}
    if jsn.has('seriesDoses') or jsn.has('_seriesDoses') then
        result.seriesDosesElement := ParsePositiveInt(jsn['seriesDoses'], jsn.vObj['_seriesDoses']);{q}
    if jsn.has('targetDisease') then
      iterateArray(jsn.vArr['targetDisease'], result.targetDiseaseList, parseCodeableConcept);
    if jsn.has('doseStatus') then
        result.doseStatus := ParseCodeableConcept(jsn.vObj['doseStatus']);{q}
    if jsn.has('doseStatusReason') then
        result.doseStatusReason := ParseCodeableConcept(jsn.vObj['doseStatusReason']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationVaccinationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationVaccinationProtocol; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntValue(json, 'doseSequence', elem.doseSequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntProps(json, 'doseSequence', elem.doseSequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'authority', elem.authority); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'series', elem.seriesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'series', elem.seriesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntValue(json, 'seriesDoses', elem.seriesDosesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntProps(json, 'seriesDoses', elem.seriesDosesElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.targetDiseaseList.Count > 0) then
  begin
    json.valueArray('targetDisease');
    for i := 0 to elem.targetDiseaseList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.targetDiseaseList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'doseStatus', elem.doseStatus); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'doseStatusReason', elem.doseStatusReason); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImmunizationVaccinationProtocol(parent :  TRDFComplex; parentType, name : String; elem : TFhirImmunizationVaccinationProtocol; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImmunizationVaccinationProtocol');
  end;
  composeBackboneElement(this, 'ImmunizationVaccinationProtocol', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ImmunizationVaccinationProtocol', 'doseSequence', elem.doseSequenceElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImmunizationVaccinationProtocol', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'ImmunizationVaccinationProtocol', 'authority', elem.authorityElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImmunizationVaccinationProtocol', 'series', elem.seriesElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ImmunizationVaccinationProtocol', 'seriesDoses', elem.seriesDosesElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.targetDiseaseList.Count - 1 do
      ComposeCodeableConcept(this, 'ImmunizationVaccinationProtocol', 'targetDisease', elem.targetDiseaseList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ImmunizationVaccinationProtocol', 'doseStatus', elem.doseStatusElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ImmunizationVaccinationProtocol', 'doseStatusReason', elem.doseStatusReasonElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseImmunization(element : IXmlDomElement; path : string) : TFhirImmunization;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunization.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirMedicationAdminStatusEnum, SYSTEMS_TFhirMedicationAdminStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'vaccineCode') then
        result.vaccineCode := ParseCodeableConcept(child, path+'/vaccineCode') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'wasNotGiven') then
        result.wasNotGivenElement := ParseBoolean(child, path+'/wasNotGiven') {b}
      else if (child.baseName = 'reported') then
        result.reportedElement := ParseBoolean(child, path+'/reported') {b}
      else if (child.baseName = 'performer') then
        result.performer := ParseReference{TFhirPractitioner}(child, path+'/performer') {b}
      else if (child.baseName = 'requester') then
        result.requester := ParseReference{TFhirPractitioner}(child, path+'/requester') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'manufacturer') then
        result.manufacturer := ParseReference{TFhirOrganization}(child, path+'/manufacturer') {b}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'lotNumber') then
        result.lotNumberElement := ParseString(child, path+'/lotNumber') {b}
      else if (child.baseName = 'expirationDate') then
        result.expirationDateElement := ParseDate(child, path+'/expirationDate') {b}
      else if (child.baseName = 'site') then
        result.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'doseQuantity') then
        result.doseQuantity := ParseQuantity(child, path+'/doseQuantity') {b}
      else if (child.baseName = 'note') then
        result.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.baseName = 'explanation') then
        result.explanation := ParseImmunizationExplanation(child, path+'/explanation') {b}
      else if (child.baseName = 'reaction') then
        result.reactionList.Add(ParseImmunizationReaction(child, path+'/reaction')){y.2}
      else if (child.baseName = 'vaccinationProtocol') then
        result.vaccinationProtocolList.Add(ParseImmunizationVaccinationProtocol(child, path+'/vaccinationProtocol')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunization(xml : TXmlBuilder; name : string; elem : TFhirImmunization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'vaccineCode', elem.vaccineCode);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'wasNotGiven', elem.wasNotGivenElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'reported', elem.reportedElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'performer', elem.performer);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'requester', elem.requester);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'manufacturer', elem.manufacturer);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'lotNumber', elem.lotNumberElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'expirationDate', elem.expirationDateElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'site', elem.site);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'route', elem.route);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'doseQuantity', elem.doseQuantity);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeImmunizationExplanation(xml, 'explanation', elem.explanation);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeImmunizationReaction(xml, 'reaction', elem.reactionList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.vaccinationProtocolList.Count - 1 do
      ComposeImmunizationVaccinationProtocol(xml, 'vaccinationProtocol', elem.vaccinationProtocolList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunization(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunization(jsn : TJsonObject) : TFhirImmunization;
begin
  result := TFhirImmunization.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirMedicationAdminStatusEnum, SYSTEMS_TFhirMedicationAdminStatusEnum);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('vaccineCode') then
        result.vaccineCode := ParseCodeableConcept(jsn.vObj['vaccineCode']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('wasNotGiven') or jsn.has('_wasNotGiven') then
        result.wasNotGivenElement := ParseBoolean(jsn['wasNotGiven'], jsn.vObj['_wasNotGiven']);{q}
    if jsn.has('reported') or jsn.has('_reported') then
        result.reportedElement := ParseBoolean(jsn['reported'], jsn.vObj['_reported']);{q}
    if jsn.has('performer') then
        result.performer := ParseReference{TFhirPractitioner}(jsn.vObj['performer']);{q}
    if jsn.has('requester') then
        result.requester := ParseReference{TFhirPractitioner}(jsn.vObj['requester']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('manufacturer') then
        result.manufacturer := ParseReference{TFhirOrganization}(jsn.vObj['manufacturer']);{q}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('lotNumber') or jsn.has('_lotNumber') then
        result.lotNumberElement := ParseString(jsn['lotNumber'], jsn.vObj['_lotNumber']);{q}
    if jsn.has('expirationDate') or jsn.has('_expirationDate') then
        result.expirationDateElement := ParseDate(jsn['expirationDate'], jsn.vObj['_expirationDate']);{q}
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('doseQuantity') then
        result.doseQuantity := ParseQuantity(jsn.vObj['doseQuantity']);{q}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('explanation') then
        result.explanation := ParseImmunizationExplanation(jsn.vObj['explanation']);{q}
    if jsn.has('reaction') then
      iterateArray(jsn.vArr['reaction'], result.reactionList, parseImmunizationReaction);
    if jsn.has('vaccinationProtocol') then
      iterateArray(jsn.vArr['vaccinationProtocol'], result.vaccinationProtocolList, parseImmunizationVaccinationProtocol);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunization(json : TJSONWriter; name : string; elem : TFhirImmunization; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'vaccineCode', elem.vaccineCode); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'wasNotGiven', elem.wasNotGivenElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'wasNotGiven', elem.wasNotGivenElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'reported', elem.reportedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'reported', elem.reportedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'performer', elem.performer); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'requester', elem.requester); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'manufacturer', elem.manufacturer); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateValue(json, 'expirationDate', elem.expirationDateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateProps(json, 'expirationDate', elem.expirationDateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'site', elem.site); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'route', elem.route); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'doseQuantity', elem.doseQuantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeImmunizationExplanation(json, 'explanation', elem.explanation); {a}
  if (SummaryOption in [soFull, soData]) and (elem.reactionList.Count > 0) then
  begin
    json.valueArray('reaction');
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeImmunizationReaction(json, '', elem.reactionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.vaccinationProtocolList.Count > 0) then
  begin
    json.valueArray('vaccinationProtocol');
    for i := 0 to elem.vaccinationProtocolList.Count - 1 do
      ComposeImmunizationVaccinationProtocol(json, '', elem.vaccinationProtocolList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeImmunization(parent :  TRDFComplex; parentType, name : String; elem : TFhirImmunization; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Immunization');
  end;
  composeDomainResource(this, 'Immunization', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Immunization', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Immunization', 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum, SYSTEMS_TFhirMedicationAdminStatusEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Immunization', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Immunization', 'vaccineCode', elem.vaccineCodeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(this, 'Immunization', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Immunization', 'wasNotGiven', elem.wasNotGivenElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Immunization', 'reported', elem.reportedElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'Immunization', 'performer', elem.performerElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'Immunization', 'requester', elem.requesterElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(this, 'Immunization', 'encounter', elem.encounterElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Immunization', 'manufacturer', elem.manufacturerElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'Immunization', 'location', elem.locationElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Immunization', 'lotNumber', elem.lotNumberElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'Immunization', 'expirationDate', elem.expirationDateElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Immunization', 'site', elem.siteElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Immunization', 'route', elem.routeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Immunization', 'doseQuantity', elem.doseQuantityElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Immunization', 'note', elem.noteList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeImmunizationExplanation(this, 'Immunization', 'explanation', elem.explanationElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeImmunizationReaction(this, 'Immunization', 'reaction', elem.reactionList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.vaccinationProtocolList.Count - 1 do
      ComposeImmunizationVaccinationProtocol(this, 'Immunization', 'vaccinationProtocol', elem.vaccinationProtocolList[i], i);
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendation(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendation;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'vaccineCode') then
        result.vaccineCode := ParseCodeableConcept(child, path+'/vaccineCode') {b}
      else if (child.baseName = 'doseNumber') then
        result.doseNumberElement := ParsePositiveInt(child, path+'/doseNumber') {b}
      else if (child.baseName = 'forecastStatus') then
        result.forecastStatus := ParseCodeableConcept(child, path+'/forecastStatus') {b}
      else if (child.baseName = 'dateCriterion') then
        result.dateCriterionList.Add(ParseImmunizationRecommendationRecommendationDateCriterion(child, path+'/dateCriterion')){y.2}
      else if (child.baseName = 'protocol') then
        result.protocol := ParseImmunizationRecommendationRecommendationProtocol(child, path+'/protocol') {b}
      else if (child.baseName = 'supportingImmunization') then
        result.supportingImmunizationList.Add(ParseReference{TFhirImmunization}(child, path+'/supportingImmunization')){y.2}
      else if (child.baseName = 'supportingPatientInformation') then
        result.supportingPatientInformationList.Add(ParseReference{Resource}(child, path+'/supportingPatientInformation')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'vaccineCode', elem.vaccineCode);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'doseNumber', elem.doseNumberElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'forecastStatus', elem.forecastStatus);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.dateCriterionList.Count - 1 do
      ComposeImmunizationRecommendationRecommendationDateCriterion(xml, 'dateCriterion', elem.dateCriterionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeImmunizationRecommendationRecommendationProtocol(xml, 'protocol', elem.protocol);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.supportingImmunizationList.Count - 1 do
      ComposeReference{TFhirImmunization}(xml, 'supportingImmunization', elem.supportingImmunizationList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.supportingPatientInformationList.Count - 1 do
      ComposeReference{Resource}(xml, 'supportingPatientInformation', elem.supportingPatientInformationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendationRecommendation(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationRecommendationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('vaccineCode') then
        result.vaccineCode := ParseCodeableConcept(jsn.vObj['vaccineCode']);{q}
    if jsn.has('doseNumber') or jsn.has('_doseNumber') then
        result.doseNumberElement := ParsePositiveInt(jsn['doseNumber'], jsn.vObj['_doseNumber']);{q}
    if jsn.has('forecastStatus') then
        result.forecastStatus := ParseCodeableConcept(jsn.vObj['forecastStatus']);{q}
    if jsn.has('dateCriterion') then
      iterateArray(jsn.vArr['dateCriterion'], result.dateCriterionList, parseImmunizationRecommendationRecommendationDateCriterion);
    if jsn.has('protocol') then
        result.protocol := ParseImmunizationRecommendationRecommendationProtocol(jsn.vObj['protocol']);{q}
    if jsn.has('supportingImmunization') then
      iterateArray(jsn.vArr['supportingImmunization'], result.supportingImmunizationList, parseReference{TFhirImmunization});
    if jsn.has('supportingPatientInformation') then
      iterateArray(jsn.vArr['supportingPatientInformation'], result.supportingPatientInformationList, parseReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'vaccineCode', elem.vaccineCode); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'doseNumber', elem.doseNumberElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'doseNumber', elem.doseNumberElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'forecastStatus', elem.forecastStatus); {a}
  if (SummaryOption in [soFull, soData]) and (elem.dateCriterionList.Count > 0) then
  begin
    json.valueArray('dateCriterion');
    for i := 0 to elem.dateCriterionList.Count - 1 do
      ComposeImmunizationRecommendationRecommendationDateCriterion(json, '', elem.dateCriterionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeImmunizationRecommendationRecommendationProtocol(json, 'protocol', elem.protocol); {a}
  if (SummaryOption in [soFull, soData]) and (elem.supportingImmunizationList.Count > 0) then
  begin
    json.valueArray('supportingImmunization');
    for i := 0 to elem.supportingImmunizationList.Count - 1 do
      ComposeReference{TFhirImmunization}(json, '', elem.supportingImmunizationList[i]); {z - Reference(Immunization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.supportingPatientInformationList.Count > 0) then
  begin
    json.valueArray('supportingPatientInformation');
    for i := 0 to elem.supportingPatientInformationList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.supportingPatientInformationList[i]); {z - Reference(Observation|AllergyIntolerance)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImmunizationRecommendationRecommendation(parent :  TRDFComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendation; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImmunizationRecommendationRecommendation');
  end;
  composeBackboneElement(this, 'ImmunizationRecommendationRecommendation', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ImmunizationRecommendationRecommendation', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ImmunizationRecommendationRecommendation', 'vaccineCode', elem.vaccineCodeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ImmunizationRecommendationRecommendation', 'doseNumber', elem.doseNumberElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ImmunizationRecommendationRecommendation', 'forecastStatus', elem.forecastStatusElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.dateCriterionList.Count - 1 do
      ComposeImmunizationRecommendationRecommendationDateCriterion(this, 'ImmunizationRecommendationRecommendation', 'dateCriterion', elem.dateCriterionList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeImmunizationRecommendationRecommendationProtocol(this, 'ImmunizationRecommendationRecommendation', 'protocol', elem.protocolElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.supportingImmunizationList.Count - 1 do
      ComposeReference{TFhirImmunization}(this, 'ImmunizationRecommendationRecommendation', 'supportingImmunization', elem.supportingImmunizationList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.supportingPatientInformationList.Count - 1 do
      ComposeReference{Resource}(this, 'ImmunizationRecommendationRecommendation', 'supportingPatientInformation', elem.supportingPatientInformationList[i], i);
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationDateCriterion(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendationDateCriterion;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseDateTime(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendationRecommendationDateCriterion(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDateTime(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(parent :  TRDFComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendationDateCriterion; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImmunizationRecommendationRecommendationDateCriterion');
  end;
  composeBackboneElement(this, 'ImmunizationRecommendationRecommendationDateCriterion', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ImmunizationRecommendationRecommendationDateCriterion', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'ImmunizationRecommendationRecommendationDateCriterion', 'value', elem.valueElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationProtocol(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendationProtocol;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'doseSequence') then
        result.doseSequenceElement := ParseInteger(child, path+'/doseSequence') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'authority') then
        result.authority := ParseReference{TFhirOrganization}(child, path+'/authority') {b}
      else if (child.baseName = 'series') then
        result.seriesElement := ParseString(child, path+'/series') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'doseSequence', elem.doseSequenceElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'authority', elem.authority);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'series', elem.seriesElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendationRecommendationProtocol(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('doseSequence') or jsn.has('_doseSequence') then
        result.doseSequenceElement := ParseInteger(jsn['doseSequence'], jsn.vObj['_doseSequence']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('authority') then
        result.authority := ParseReference{TFhirOrganization}(jsn.vObj['authority']);{q}
    if jsn.has('series') or jsn.has('_series') then
        result.seriesElement := ParseString(jsn['series'], jsn.vObj['_series']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendationRecommendationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'doseSequence', elem.doseSequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'doseSequence', elem.doseSequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'authority', elem.authority); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'series', elem.seriesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'series', elem.seriesElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImmunizationRecommendationRecommendationProtocol(parent :  TRDFComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendationProtocol; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImmunizationRecommendationRecommendationProtocol');
  end;
  composeBackboneElement(this, 'ImmunizationRecommendationRecommendationProtocol', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'ImmunizationRecommendationRecommendationProtocol', 'doseSequence', elem.doseSequenceElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImmunizationRecommendationRecommendationProtocol', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'ImmunizationRecommendationRecommendationProtocol', 'authority', elem.authorityElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImmunizationRecommendationRecommendationProtocol', 'series', elem.seriesElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseImmunizationRecommendation(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendation;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'recommendation') then
        result.recommendationList.Add(ParseImmunizationRecommendationRecommendation(child, path+'/recommendation')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.recommendationList.Count - 1 do
      ComposeImmunizationRecommendationRecommendation(xml, 'recommendation', elem.recommendationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendation(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('recommendation') then
      iterateArray(jsn.vArr['recommendation'], result.recommendationList, parseImmunizationRecommendationRecommendation);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.recommendationList.Count > 0) then
  begin
    json.valueArray('recommendation');
    for i := 0 to elem.recommendationList.Count - 1 do
      ComposeImmunizationRecommendationRecommendation(json, '', elem.recommendationList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeImmunizationRecommendation(parent :  TRDFComplex; parentType, name : String; elem : TFhirImmunizationRecommendation; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImmunizationRecommendation');
  end;
  composeDomainResource(this, 'ImmunizationRecommendation', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ImmunizationRecommendation', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'ImmunizationRecommendation', 'patient', elem.patientElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.recommendationList.Count - 1 do
      ComposeImmunizationRecommendationRecommendation(this, 'ImmunizationRecommendation', 'recommendation', elem.recommendationList[i], i);
end;

function TFHIRXmlParser.ParseImplementationGuideContact(element : IXmlDomElement; path : string) : TFhirImplementationGuideContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirImplementationGuideContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideContact(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuideContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImplementationGuideContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuideContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuideContact(jsn : TJsonObject) : TFhirImplementationGuideContact;
begin
  result := TFhirImplementationGuideContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImplementationGuideContact(json : TJSONWriter; name : string; elem : TFhirImplementationGuideContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImplementationGuideContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirImplementationGuideContact; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImplementationGuideContact');
  end;
  composeBackboneElement(this, 'ImplementationGuideContact', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImplementationGuideContact', 'name', elem.nameElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'ImplementationGuideContact', 'telecom', elem.telecomList[i], i);
end;

function TFHIRXmlParser.ParseImplementationGuideDependency(element : IXmlDomElement; path : string) : TFhirImplementationGuideDependency;
var
  child : IXMLDOMElement;
begin
  result := TFhirImplementationGuideDependency.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirGuideDependencyTypeEnum, SYSTEMS_TFhirGuideDependencyTypeEnum, path+'/type', child){1a}
      else if (child.baseName = 'uri') then
        result.uriElement := ParseUri(child, path+'/uri') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDependency(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuideDependency);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirGuideDependencyTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'uri', elem.uriElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImplementationGuideDependency(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuideDependency(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuideDependency(jsn : TJsonObject) : TFhirImplementationGuideDependency;
begin
  result := TFhirImplementationGuideDependency.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirGuideDependencyTypeEnum, SYSTEMS_TFhirGuideDependencyTypeEnum);
    if jsn.has('uri') or jsn.has('_uri') then
        result.uriElement := ParseUri(jsn['uri'], jsn.vObj['_uri']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImplementationGuideDependency(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDependency; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirGuideDependencyTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirGuideDependencyTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'uri', elem.uriElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImplementationGuideDependency(parent :  TRDFComplex; parentType, name : String; elem : TFhirImplementationGuideDependency; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImplementationGuideDependency');
  end;
  composeBackboneElement(this, 'ImplementationGuideDependency', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ImplementationGuideDependency', 'type', elem.Type_Element, CODES_TFhirGuideDependencyTypeEnum, SYSTEMS_TFhirGuideDependencyTypeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ImplementationGuideDependency', 'uri', elem.uriElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseImplementationGuidePackage(element : IXmlDomElement; path : string) : TFhirImplementationGuidePackage;
var
  child : IXMLDOMElement;
begin
  result := TFhirImplementationGuidePackage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'resource') then
        result.resourceList.Add(ParseImplementationGuidePackageResource(child, path+'/resource')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuidePackage(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuidePackage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeImplementationGuidePackageResource(xml, 'resource', elem.resourceList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImplementationGuidePackage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuidePackage(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuidePackage(jsn : TJsonObject) : TFhirImplementationGuidePackage;
begin
  result := TFhirImplementationGuidePackage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('resource') then
      iterateArray(jsn.vArr['resource'], result.resourceList, parseImplementationGuidePackageResource);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImplementationGuidePackage(json : TJSONWriter; name : string; elem : TFhirImplementationGuidePackage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.resourceList.Count > 0) then
  begin
    json.valueArray('resource');
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeImplementationGuidePackageResource(json, '', elem.resourceList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImplementationGuidePackage(parent :  TRDFComplex; parentType, name : String; elem : TFhirImplementationGuidePackage; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImplementationGuidePackage');
  end;
  composeBackboneElement(this, 'ImplementationGuidePackage', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImplementationGuidePackage', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuidePackage', 'description', elem.descriptionElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeImplementationGuidePackageResource(this, 'ImplementationGuidePackage', 'resource', elem.resourceList[i], i);
end;

function TFHIRXmlParser.ParseImplementationGuidePackageResource(element : IXmlDomElement; path : string) : TFhirImplementationGuidePackageResource;
var
  child : IXMLDOMElement;
begin
  result := TFhirImplementationGuidePackageResource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'purpose') then
        result.purposeElement := ParseEnum(CODES_TFhirGuideResourcePurposeEnum, SYSTEMS_TFhirGuideResourcePurposeEnum, path+'/purpose', child){1a}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'acronym') then
        result.acronymElement := ParseString(child, path+'/acronym') {b}
      else if (child.baseName = 'sourceUri') then
        result.source := ParseUri(child, path+'/sourceUri'){x.3}
      else if (child.baseName = 'sourceReference') then
        result.source := ParseReference(child, path+'/sourceReference') {a}
      else if (child.baseName = 'exampleFor') then
        result.exampleFor := ParseReference{TFhirStructureDefinition}(child, path+'/exampleFor') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuidePackageResource(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuidePackageResource);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'purpose', elem.PurposeElement, CODES_TFhirGuideResourcePurposeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'acronym', elem.acronymElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirUri) {6} then
    ComposeUri(xml, 'sourceUri', TFhirUri(elem.source))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirReference) {2} then
    ComposeReference(xml, 'sourceReference', TFhirReference(elem.source));
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(xml, 'exampleFor', elem.exampleFor);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImplementationGuidePackageResource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuidePackageResource(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuidePackageResource(jsn : TJsonObject) : TFhirImplementationGuidePackageResource;
begin
  result := TFhirImplementationGuidePackageResource.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('purpose') or jsn.has('_purpose')  then
      result.purposeElement := parseEnum(jsn.path+'/purpose', jsn['purpose'], jsn.vObj['_purpose'], CODES_TFhirGuideResourcePurposeEnum, SYSTEMS_TFhirGuideResourcePurposeEnum);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('acronym') or jsn.has('_acronym') then
        result.acronymElement := ParseString(jsn['acronym'], jsn.vObj['_acronym']);{q}
    if jsn.has('sourceUri') or jsn.has('_sourceUri') then
      result.source := parseUri(jsn['sourceUri'], jsn.vObj['_sourceUri']);
    if jsn.has('sourceReference') {a3} then
      result.source := ParseReference(jsn.vObj['sourceReference']);
    if jsn.has('exampleFor') then
        result.exampleFor := ParseReference{TFhirStructureDefinition}(jsn.vObj['exampleFor']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImplementationGuidePackageResource(json : TJSONWriter; name : string; elem : TFhirImplementationGuidePackageResource; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'purpose', elem.PurposeElement, CODES_TFhirGuideResourcePurposeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'purpose', elem.PurposeElement, CODES_TFhirGuideResourcePurposeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'acronym', elem.acronymElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'acronym', elem.acronymElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirUri) then 
  begin
    ComposeUriValue(json, 'sourceUri', TFhirUri(elem.source), false);
    ComposeUriProps(json, 'sourceUri', TFhirUri(elem.source), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirReference) then
    ComposeReference(json, 'sourceReference', TFhirReference(elem.source));
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(json, 'exampleFor', elem.exampleFor); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImplementationGuidePackageResource(parent :  TRDFComplex; parentType, name : String; elem : TFhirImplementationGuidePackageResource; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImplementationGuidePackageResource');
  end;
  composeBackboneElement(this, 'ImplementationGuidePackageResource', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ImplementationGuidePackageResource', 'purpose', elem.PurposeElement, CODES_TFhirGuideResourcePurposeEnum, SYSTEMS_TFhirGuideResourcePurposeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImplementationGuidePackageResource', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuidePackageResource', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuidePackageResource', 'acronym', elem.acronymElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirUri) {6} then
    ComposeUri(this, 'ImplementationGuidePackageResource', 'sourceUri', TFhirUri(elem.source), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirReference) {2} then
    ComposeReference(this, 'ImplementationGuidePackageResource', 'sourceReference', TFhirReference(elem.source), -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(this, 'ImplementationGuidePackageResource', 'exampleFor', elem.exampleForElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseImplementationGuideGlobal(element : IXmlDomElement; path : string) : TFhirImplementationGuideGlobal;
var
  child : IXMLDOMElement;
begin
  result := TFhirImplementationGuideGlobal.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/type', child){1a}
      else if (child.baseName = 'profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideGlobal(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuideGlobal);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImplementationGuideGlobal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuideGlobal(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuideGlobal(jsn : TJsonObject) : TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(jsn.vObj['profile']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImplementationGuideGlobal(json : TJSONWriter; name : string; elem : TFhirImplementationGuideGlobal; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirStructureDefinition}(json, 'profile', elem.profile); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImplementationGuideGlobal(parent :  TRDFComplex; parentType, name : String; elem : TFhirImplementationGuideGlobal; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImplementationGuideGlobal');
  end;
  composeBackboneElement(this, 'ImplementationGuideGlobal', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ImplementationGuideGlobal', 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirStructureDefinition}(this, 'ImplementationGuideGlobal', 'profile', elem.profileElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseImplementationGuidePage(element : IXmlDomElement; path : string) : TFhirImplementationGuidePage;
var
  child : IXMLDOMElement;
begin
  result := TFhirImplementationGuidePage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'source') then
        result.sourceElement := ParseUri(child, path+'/source') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'kind') then
        result.kindElement := ParseEnum(CODES_TFhirGuidePageKindEnum, SYSTEMS_TFhirGuidePageKindEnum, path+'/kind', child){1a}
      else if (child.baseName = 'type') then
        result.type_.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/type', child)){y.1}
      else if (child.baseName = 'package') then
        result.packageList.Add(ParseString(child, path+'/package')){y.2}
      else if (child.baseName = 'format') then
        result.formatElement := ParseCode(child, path+'/format') {b}
      else if (child.baseName = 'page') then
        result.pageList.Add(ParseImplementationGuidePage(child, path+'/page')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuidePage(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuidePage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'source', elem.sourceElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirGuidePageKindEnum);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.type_.Count - 1 do
      ComposeEnum(xml, 'type', elem.type_[i], CODES_TFhirResourceTypesEnum);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.packageList.Count - 1 do
      ComposeString(xml, 'package', elem.packageList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'format', elem.formatElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.pageList.Count - 1 do
      ComposeImplementationGuidePage(xml, 'page', elem.pageList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImplementationGuidePage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuidePage(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuidePage(jsn : TJsonObject) : TFhirImplementationGuidePage;
begin
  result := TFhirImplementationGuidePage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('source') or jsn.has('_source') then
        result.sourceElement := ParseUri(jsn['source'], jsn.vObj['_source']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn['kind'], jsn.vObj['_kind'], CODES_TFhirGuidePageKindEnum, SYSTEMS_TFhirGuidePageKindEnum);
    if jsn.has('type') or jsn.has('_type') then
      iterateEnumArray(jsn.vArr['type'], jsn.vArr['_type'], jsn.path+'/type', result.type_, parseEnum, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
      if jsn.has('package') or jsn.has('_package') then
      iteratePrimitiveArray(jsn.vArr['package'], jsn.vArr['_package'], result.packageList, parseString);
    if jsn.has('format') or jsn.has('_format') then
        result.formatElement := ParseCode(jsn['format'], jsn.vObj['_format']);{q}
    if jsn.has('page') then
      iterateArray(jsn.vArr['page'], result.pageList, parseImplementationGuidePage);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImplementationGuidePage(json : TJSONWriter; name : string; elem : TFhirImplementationGuidePage; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'source', elem.sourceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'source', elem.sourceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirGuidePageKindEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirGuidePageKindEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.type_.Count > 0) then
  begin
    json.valueArray('type');
    ext := false;
    for i := 0 to elem.type_.Count - 1 do
    begin
      ext := ext or ((elem.type_[i].id <> '') or (elem.type_[i].hasExtensionList));
      ComposeEnumValue(json, '', elem.type_[i], CODES_TFhirResourceTypesEnum, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_type');
      for i := 0 to elem.type_.Count - 1 do
        ComposeEnumProps(json, '', elem.type_[i], CODES_TFhirResourceTypesEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.packageList.Count > 0) then
  begin
    json.valueArray('package');
    ext := false;
    for i := 0 to elem.packageList.Count - 1 do
    begin
      ext := ext or ((elem.packageList[i].id <> '') or (elem.packageList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.packageList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_package');
      for i := 0 to elem.packageList.Count - 1 do
        ComposeStringProps(json, '',elem.packageList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'format', elem.formatElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'format', elem.formatElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.pageList.Count > 0) then
  begin
    json.valueArray('page');
    for i := 0 to elem.pageList.Count - 1 do
      ComposeImplementationGuidePage(json, '', elem.pageList[i]); {z - @ImplementationGuide.page}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeImplementationGuidePage(parent :  TRDFComplex; parentType, name : String; elem : TFhirImplementationGuidePage; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImplementationGuidePage');
  end;
  composeBackboneElement(this, 'ImplementationGuidePage', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ImplementationGuidePage', 'source', elem.sourceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImplementationGuidePage', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ImplementationGuidePage', 'kind', elem.KindElement, CODES_TFhirGuidePageKindEnum, SYSTEMS_TFhirGuidePageKindEnum, -1);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.type_.Count - 1 do
      ComposeEnum(this, 'ImplementationGuidePage', 'type', elem.type_[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.type_.Count - 1 do
      ComposeEnum(this, 'ImplementationGuidePage', 'type', elem.type_[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.packageList.Count - 1 do
      ComposeString(this, 'ImplementationGuidePage', 'package', elem.packageList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ImplementationGuidePage', 'format', elem.formatElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.pageList.Count - 1 do
      ComposeImplementationGuidePage(this, 'ImplementationGuidePage', 'page', elem.pageList[i], i);
end;

function TFHIRXmlParser.ParseImplementationGuide(element : IXmlDomElement; path : string) : TFhirImplementationGuide;
var
  child : IXMLDOMElement;
begin
  result := TFhirImplementationGuide.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseImplementationGuideContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'useContext') then
        result.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.baseName = 'copyright') then
        result.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.baseName = 'fhirVersion') then
        result.fhirVersionElement := ParseId(child, path+'/fhirVersion') {b}
      else if (child.baseName = 'dependency') then
        result.dependencyList.Add(ParseImplementationGuideDependency(child, path+'/dependency')){y.2}
      else if (child.baseName = 'package') then
        result.packageList.Add(ParseImplementationGuidePackage(child, path+'/package')){y.2}
      else if (child.baseName = 'global') then
        result.globalList.Add(ParseImplementationGuideGlobal(child, path+'/global')){y.2}
      else if (child.baseName = 'binary') then
        result.binaryList.Add(ParseUri(child, path+'/binary')){y.2}
      else if (child.baseName = 'page') then
        result.page := ParseImplementationGuidePage(child, path+'/page') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuide(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuide);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeImplementationGuideContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyright', elem.copyrightElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'fhirVersion', elem.fhirVersionElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.dependencyList.Count - 1 do
      ComposeImplementationGuideDependency(xml, 'dependency', elem.dependencyList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.packageList.Count - 1 do
      ComposeImplementationGuidePackage(xml, 'package', elem.packageList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.globalList.Count - 1 do
      ComposeImplementationGuideGlobal(xml, 'global', elem.globalList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.binaryList.Count - 1 do
      ComposeUri(xml, 'binary', elem.binaryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeImplementationGuidePage(xml, 'page', elem.page);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImplementationGuide(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuide(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuide(jsn : TJsonObject) : TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseImplementationGuideContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('fhirVersion') or jsn.has('_fhirVersion') then
        result.fhirVersionElement := ParseId(jsn['fhirVersion'], jsn.vObj['_fhirVersion']);{q}
    if jsn.has('dependency') then
      iterateArray(jsn.vArr['dependency'], result.dependencyList, parseImplementationGuideDependency);
    if jsn.has('package') then
      iterateArray(jsn.vArr['package'], result.packageList, parseImplementationGuidePackage);
    if jsn.has('global') then
      iterateArray(jsn.vArr['global'], result.globalList, parseImplementationGuideGlobal);
      if jsn.has('binary') or jsn.has('_binary') then
      iteratePrimitiveArray(jsn.vArr['binary'], jsn.vArr['_binary'], result.binaryList, parseUri);
    if jsn.has('page') then
        result.page := ParseImplementationGuidePage(jsn.vObj['page']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImplementationGuide(json : TJSONWriter; name : string; elem : TFhirImplementationGuide; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeImplementationGuideContact(json, '', elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.useContextList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdValue(json, 'fhirVersion', elem.fhirVersionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdProps(json, 'fhirVersion', elem.fhirVersionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dependencyList.Count > 0) then
  begin
    json.valueArray('dependency');
    for i := 0 to elem.dependencyList.Count - 1 do
      ComposeImplementationGuideDependency(json, '', elem.dependencyList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.packageList.Count > 0) then
  begin
    json.valueArray('package');
    for i := 0 to elem.packageList.Count - 1 do
      ComposeImplementationGuidePackage(json, '', elem.packageList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.globalList.Count > 0) then
  begin
    json.valueArray('global');
    for i := 0 to elem.globalList.Count - 1 do
      ComposeImplementationGuideGlobal(json, '', elem.globalList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.binaryList.Count > 0) then
  begin
    json.valueArray('binary');
    ext := false;
    for i := 0 to elem.binaryList.Count - 1 do
    begin
      ext := ext or ((elem.binaryList[i].id <> '') or (elem.binaryList[i].hasExtensionList));
      ComposeUriValue(json, '',elem.binaryList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_binary');
      for i := 0 to elem.binaryList.Count - 1 do
        ComposeUriProps(json, '',elem.binaryList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeImplementationGuidePage(json, 'page', elem.page); {a}
end;

procedure TFHIRRDFComposer.ComposeImplementationGuide(parent :  TRDFComplex; parentType, name : String; elem : TFhirImplementationGuide; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ImplementationGuide');
  end;
  composeDomainResource(this, 'ImplementationGuide', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ImplementationGuide', 'url', elem.urlElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImplementationGuide', 'version', elem.versionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImplementationGuide', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ImplementationGuide', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ImplementationGuide', 'experimental', elem.experimentalElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImplementationGuide', 'publisher', elem.publisherElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeImplementationGuideContact(this, 'ImplementationGuide', 'contact', elem.contactList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ImplementationGuide', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImplementationGuide', 'description', elem.descriptionElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(this, 'ImplementationGuide', 'useContext', elem.useContextList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuide', 'copyright', elem.copyrightElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'ImplementationGuide', 'fhirVersion', elem.fhirVersionElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.dependencyList.Count - 1 do
      ComposeImplementationGuideDependency(this, 'ImplementationGuide', 'dependency', elem.dependencyList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.packageList.Count - 1 do
      ComposeImplementationGuidePackage(this, 'ImplementationGuide', 'package', elem.packageList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.globalList.Count - 1 do
      ComposeImplementationGuideGlobal(this, 'ImplementationGuide', 'global', elem.globalList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.binaryList.Count - 1 do
      ComposeUri(this, 'ImplementationGuide', 'binary', elem.binaryList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeImplementationGuidePage(this, 'ImplementationGuide', 'page', elem.pageElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseListEntry(element : IXmlDomElement; path : string) : TFhirListEntry;
var
  child : IXMLDOMElement;
begin
  result := TFhirListEntry.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'flag') then
        result.flag := ParseCodeableConcept(child, path+'/flag') {b}
      else if (child.baseName = 'deleted') then
        result.deletedElement := ParseBoolean(child, path+'/deleted') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'item') then
        result.item := ParseReference{TFhirReference}(child, path+'/item') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeListEntry(xml : TXmlBuilder; name : string; elem : TFhirListEntry);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'flag', elem.flag);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'deleted', elem.deletedElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(xml, 'item', elem.item);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseListEntry(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseListEntry(jsn)); {2}
end;

function TFHIRJsonParser.ParseListEntry(jsn : TJsonObject) : TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('flag') then
        result.flag := ParseCodeableConcept(jsn.vObj['flag']);{q}
    if jsn.has('deleted') or jsn.has('_deleted') then
        result.deletedElement := ParseBoolean(jsn['deleted'], jsn.vObj['_deleted']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('item') then
        result.item := ParseReference{TFhirReference}(jsn.vObj['item']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeListEntry(json : TJSONWriter; name : string; elem : TFhirListEntry; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'flag', elem.flag); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'deleted', elem.deletedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'deleted', elem.deletedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(json, 'item', elem.item); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeListEntry(parent :  TRDFComplex; parentType, name : String; elem : TFhirListEntry; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ListEntry');
  end;
  composeBackboneElement(this, 'ListEntry', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ListEntry', 'flag', elem.flagElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ListEntry', 'deleted', elem.deletedElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'ListEntry', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'ListEntry', 'item', elem.itemElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseList(element : IXmlDomElement; path : string) : TFhirList;
var
  child : IXMLDOMElement;
begin
  result := TFhirList.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'title') then
        result.titleElement := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'source') then
        result.source := ParseReference{Resource}(child, path+'/source') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirListStatusEnum, SYSTEMS_TFhirListStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'orderedBy') then
        result.orderedBy := ParseCodeableConcept(child, path+'/orderedBy') {b}
      else if (child.baseName = 'mode') then
        result.modeElement := ParseEnum(CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, path+'/mode', child){1a}
      else if (child.baseName = 'note') then
        result.noteElement := ParseString(child, path+'/note') {b}
      else if (child.baseName = 'entry') then
        result.entryList.Add(ParseListEntry(child, path+'/entry')){y.2}
      else if (child.baseName = 'emptyReason') then
        result.emptyReason := ParseCodeableConcept(child, path+'/emptyReason') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeList(xml : TXmlBuilder; name : string; elem : TFhirList);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', elem.titleElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'source', elem.source);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirListStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'orderedBy', elem.orderedBy);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirListModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'note', elem.noteElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeListEntry(xml, 'entry', elem.entryList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'emptyReason', elem.emptyReason);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseList(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseList(jsn)); {2}
end;

function TFHIRJsonParser.ParseList(jsn : TJsonObject) : TFhirList;
begin
  result := TFhirList.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('source') then
        result.source := ParseReference{Resource}(jsn.vObj['source']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirListStatusEnum, SYSTEMS_TFhirListStatusEnum);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('orderedBy') then
        result.orderedBy := ParseCodeableConcept(jsn.vObj['orderedBy']);{q}
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn['mode'], jsn.vObj['_mode'], CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum);
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    if jsn.has('entry') then
      iterateArray(jsn.vArr['entry'], result.entryList, parseListEntry);
    if jsn.has('emptyReason') then
        result.emptyReason := ParseCodeableConcept(jsn.vObj['emptyReason']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeList(json : TJSONWriter; name : string; elem : TFhirList; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirListStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirListStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'orderedBy', elem.orderedBy); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirListModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirListModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.entryList.Count > 0) then
  begin
    json.valueArray('entry');
    for i := 0 to elem.entryList.Count - 1 do
      ComposeListEntry(json, '', elem.entryList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'emptyReason', elem.emptyReason); {a}
end;

procedure TFHIRRDFComposer.ComposeList(parent :  TRDFComplex; parentType, name : String; elem : TFhirList; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:List');
  end;
  composeDomainResource(this, 'List', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'List', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'List', 'title', elem.titleElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'List', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'List', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'List', 'source', elem.sourceElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(this, 'List', 'encounter', elem.encounterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'List', 'status', elem.StatusElement, CODES_TFhirListStatusEnum, SYSTEMS_TFhirListStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'List', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'List', 'orderedBy', elem.orderedByElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'List', 'mode', elem.ModeElement, CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'List', 'note', elem.noteElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeListEntry(this, 'List', 'entry', elem.entryList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'List', 'emptyReason', elem.emptyReasonElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseLocationPosition(element : IXmlDomElement; path : string) : TFhirLocationPosition;
var
  child : IXMLDOMElement;
begin
  result := TFhirLocationPosition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'longitude') then
        result.longitudeElement := ParseDecimal(child, path+'/longitude') {b}
      else if (child.baseName = 'latitude') then
        result.latitudeElement := ParseDecimal(child, path+'/latitude') {b}
      else if (child.baseName = 'altitude') then
        result.altitudeElement := ParseDecimal(child, path+'/altitude') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeLocationPosition(xml : TXmlBuilder; name : string; elem : TFhirLocationPosition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'longitude', elem.longitudeElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'latitude', elem.latitudeElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'altitude', elem.altitudeElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseLocationPosition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseLocationPosition(jsn)); {2}
end;

function TFHIRJsonParser.ParseLocationPosition(jsn : TJsonObject) : TFhirLocationPosition;
begin
  result := TFhirLocationPosition.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('longitude') or jsn.has('_longitude') then
        result.longitudeElement := ParseDecimal(jsn['longitude'], jsn.vObj['_longitude']);{q}
    if jsn.has('latitude') or jsn.has('_latitude') then
        result.latitudeElement := ParseDecimal(jsn['latitude'], jsn.vObj['_latitude']);{q}
    if jsn.has('altitude') or jsn.has('_altitude') then
        result.altitudeElement := ParseDecimal(jsn['altitude'], jsn.vObj['_altitude']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeLocationPosition(json : TJSONWriter; name : string; elem : TFhirLocationPosition; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'longitude', elem.longitudeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'longitude', elem.longitudeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'latitude', elem.latitudeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'latitude', elem.latitudeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'altitude', elem.altitudeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'altitude', elem.altitudeElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeLocationPosition(parent :  TRDFComplex; parentType, name : String; elem : TFhirLocationPosition; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:LocationPosition');
  end;
  composeBackboneElement(this, 'LocationPosition', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'LocationPosition', 'longitude', elem.longitudeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'LocationPosition', 'latitude', elem.latitudeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'LocationPosition', 'altitude', elem.altitudeElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseLocation(element : IXmlDomElement; path : string) : TFhirLocation;
var
  child : IXMLDOMElement;
begin
  result := TFhirLocation.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirLocationStatusEnum, SYSTEMS_TFhirLocationStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'mode') then
        result.modeElement := ParseEnum(CODES_TFhirLocationModeEnum, SYSTEMS_TFhirLocationModeEnum, path+'/mode', child){1a}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'address') then
        result.address := ParseAddress(child, path+'/address') {b}
      else if (child.baseName = 'physicalType') then
        result.physicalType := ParseCodeableConcept(child, path+'/physicalType') {b}
      else if (child.baseName = 'position') then
        result.position := ParseLocationPosition(child, path+'/position') {b}
      else if (child.baseName = 'managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.baseName = 'partOf') then
        result.partOf := ParseReference{TFhirLocation}(child, path+'/partOf') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeLocation(xml : TXmlBuilder; name : string; elem : TFhirLocation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirLocationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirLocationModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(xml, 'address', elem.address);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'physicalType', elem.physicalType);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeLocationPosition(xml, 'position', elem.position);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(xml, 'partOf', elem.partOf);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseLocation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseLocation(jsn)); {2}
end;

function TFHIRJsonParser.ParseLocation(jsn : TJsonObject) : TFhirLocation;
begin
  result := TFhirLocation.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirLocationStatusEnum, SYSTEMS_TFhirLocationStatusEnum);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn['mode'], jsn.vObj['_mode'], CODES_TFhirLocationModeEnum, SYSTEMS_TFhirLocationModeEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q}
    if jsn.has('physicalType') then
        result.physicalType := ParseCodeableConcept(jsn.vObj['physicalType']);{q}
    if jsn.has('position') then
        result.position := ParseLocationPosition(jsn.vObj['position']);{q}
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q}
    if jsn.has('partOf') then
        result.partOf := ParseReference{TFhirLocation}(jsn.vObj['partOf']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeLocation(json : TJSONWriter; name : string; elem : TFhirLocation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirLocationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirLocationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirLocationModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirLocationModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(json, 'address', elem.address); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'physicalType', elem.physicalType); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeLocationPosition(json, 'position', elem.position); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(json, 'partOf', elem.partOf); {a}
end;

procedure TFHIRRDFComposer.ComposeLocation(parent :  TRDFComplex; parentType, name : String; elem : TFhirLocation; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Location');
  end;
  composeDomainResource(this, 'Location', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Location', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Location', 'status', elem.StatusElement, CODES_TFhirLocationStatusEnum, SYSTEMS_TFhirLocationStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Location', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Location', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Location', 'mode', elem.ModeElement, CODES_TFhirLocationModeEnum, SYSTEMS_TFhirLocationModeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Location', 'type', elem.type_Element, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Location', 'telecom', elem.telecomList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(this, 'Location', 'address', elem.addressElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Location', 'physicalType', elem.physicalTypeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeLocationPosition(this, 'Location', 'position', elem.positionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Location', 'managingOrganization', elem.managingOrganizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'Location', 'partOf', elem.partOfElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMedia(element : IXmlDomElement; path : string) : TFhirMedia;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedia.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirDigitalMediaTypeEnum, SYSTEMS_TFhirDigitalMediaTypeEnum, path+'/type', child){1a}
      else if (child.baseName = 'subtype') then
        result.subtype := ParseCodeableConcept(child, path+'/subtype') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'operator') then
        result.operator := ParseReference{TFhirPractitioner}(child, path+'/operator') {b}
      else if (child.baseName = 'view') then
        result.view := ParseCodeableConcept(child, path+'/view') {b}
      else if (child.baseName = 'deviceName') then
        result.deviceNameElement := ParseString(child, path+'/deviceName') {b}
      else if (child.baseName = 'height') then
        result.heightElement := ParsePositiveInt(child, path+'/height') {b}
      else if (child.baseName = 'width') then
        result.widthElement := ParsePositiveInt(child, path+'/width') {b}
      else if (child.baseName = 'frames') then
        result.framesElement := ParsePositiveInt(child, path+'/frames') {b}
      else if (child.baseName = 'duration') then
        result.durationElement := ParseUnsignedInt(child, path+'/duration') {b}
      else if (child.baseName = 'content') then
        result.content := ParseAttachment(child, path+'/content') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedia(xml : TXmlBuilder; name : string; elem : TFhirMedia);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirDigitalMediaTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'subtype', elem.subtype);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'operator', elem.operator);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'view', elem.view);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'deviceName', elem.deviceNameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'height', elem.heightElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'width', elem.widthElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'frames', elem.framesElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'duration', elem.durationElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeAttachment(xml, 'content', elem.content);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedia(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedia(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedia(jsn : TJsonObject) : TFhirMedia;
begin
  result := TFhirMedia.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirDigitalMediaTypeEnum, SYSTEMS_TFhirDigitalMediaTypeEnum);
    if jsn.has('subtype') then
        result.subtype := ParseCodeableConcept(jsn.vObj['subtype']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('operator') then
        result.operator := ParseReference{TFhirPractitioner}(jsn.vObj['operator']);{q}
    if jsn.has('view') then
        result.view := ParseCodeableConcept(jsn.vObj['view']);{q}
    if jsn.has('deviceName') or jsn.has('_deviceName') then
        result.deviceNameElement := ParseString(jsn['deviceName'], jsn.vObj['_deviceName']);{q}
    if jsn.has('height') or jsn.has('_height') then
        result.heightElement := ParsePositiveInt(jsn['height'], jsn.vObj['_height']);{q}
    if jsn.has('width') or jsn.has('_width') then
        result.widthElement := ParsePositiveInt(jsn['width'], jsn.vObj['_width']);{q}
    if jsn.has('frames') or jsn.has('_frames') then
        result.framesElement := ParsePositiveInt(jsn['frames'], jsn.vObj['_frames']);{q}
    if jsn.has('duration') or jsn.has('_duration') then
        result.durationElement := ParseUnsignedInt(jsn['duration'], jsn.vObj['_duration']);{q}
    if jsn.has('content') then
        result.content := ParseAttachment(jsn.vObj['content']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedia(json : TJSONWriter; name : string; elem : TFhirMedia; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirDigitalMediaTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirDigitalMediaTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'subtype', elem.subtype); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'operator', elem.operator); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'view', elem.view); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'deviceName', elem.deviceNameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'deviceName', elem.deviceNameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'height', elem.heightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'height', elem.heightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'width', elem.widthElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'width', elem.widthElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'frames', elem.framesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'frames', elem.framesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntValue(json, 'duration', elem.durationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntProps(json, 'duration', elem.durationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeAttachment(json, 'content', elem.content); {a}
end;

procedure TFHIRRDFComposer.ComposeMedia(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedia; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Media');
  end;
  composeDomainResource(this, 'Media', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Media', 'type', elem.Type_Element, CODES_TFhirDigitalMediaTypeEnum, SYSTEMS_TFhirDigitalMediaTypeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Media', 'subtype', elem.subtypeElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Media', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Media', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'Media', 'operator', elem.operatorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Media', 'view', elem.viewElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Media', 'deviceName', elem.deviceNameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Media', 'height', elem.heightElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Media', 'width', elem.widthElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Media', 'frames', elem.framesElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'Media', 'duration', elem.durationElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeAttachment(this, 'Media', 'content', elem.contentElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMedicationProduct(element : IXmlDomElement; path : string) : TFhirMedicationProduct;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationProduct.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'form') then
        result.form := ParseCodeableConcept(child, path+'/form') {b}
      else if (child.baseName = 'ingredient') then
        result.ingredientList.Add(ParseMedicationProductIngredient(child, path+'/ingredient')){y.2}
      else if (child.baseName = 'batch') then
        result.batchList.Add(ParseMedicationProductBatch(child, path+'/batch')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationProduct(xml : TXmlBuilder; name : string; elem : TFhirMedicationProduct);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'form', elem.form);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeMedicationProductIngredient(xml, 'ingredient', elem.ingredientList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.batchList.Count - 1 do
      ComposeMedicationProductBatch(xml, 'batch', elem.batchList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationProduct(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationProduct(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationProduct(jsn : TJsonObject) : TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('form') then
        result.form := ParseCodeableConcept(jsn.vObj['form']);{q}
    if jsn.has('ingredient') then
      iterateArray(jsn.vArr['ingredient'], result.ingredientList, parseMedicationProductIngredient);
    if jsn.has('batch') then
      iterateArray(jsn.vArr['batch'], result.batchList, parseMedicationProductBatch);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationProduct(json : TJSONWriter; name : string; elem : TFhirMedicationProduct; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'form', elem.form); {a}
  if (SummaryOption in [soFull, soData]) and (elem.ingredientList.Count > 0) then
  begin
    json.valueArray('ingredient');
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeMedicationProductIngredient(json, '', elem.ingredientList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.batchList.Count > 0) then
  begin
    json.valueArray('batch');
    for i := 0 to elem.batchList.Count - 1 do
      ComposeMedicationProductBatch(json, '', elem.batchList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeMedicationProduct(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationProduct; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MedicationProduct');
  end;
  composeBackboneElement(this, 'MedicationProduct', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationProduct', 'form', elem.formElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeMedicationProductIngredient(this, 'MedicationProduct', 'ingredient', elem.ingredientList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.batchList.Count - 1 do
      ComposeMedicationProductBatch(this, 'MedicationProduct', 'batch', elem.batchList[i], i);
end;

function TFHIRXmlParser.ParseMedicationProductIngredient(element : IXmlDomElement; path : string) : TFhirMedicationProductIngredient;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'item') then
        result.item := ParseReference{Resource}(child, path+'/item') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseRatio(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationProductIngredient(xml : TXmlBuilder; name : string; elem : TFhirMedicationProductIngredient);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'item', elem.item);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeRatio(xml, 'amount', elem.amount);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationProductIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationProductIngredient(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationProductIngredient(jsn : TJsonObject) : TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('item') then
        result.item := ParseReference{Resource}(jsn.vObj['item']);{q}
    if jsn.has('amount') then
        result.amount := ParseRatio(jsn.vObj['amount']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationProductIngredient(json : TJSONWriter; name : string; elem : TFhirMedicationProductIngredient; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(json, 'item', elem.item); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeRatio(json, 'amount', elem.amount); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeMedicationProductIngredient(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationProductIngredient; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MedicationProductIngredient');
  end;
  composeBackboneElement(this, 'MedicationProductIngredient', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'MedicationProductIngredient', 'item', elem.itemElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeRatio(this, 'MedicationProductIngredient', 'amount', elem.amountElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMedicationProductBatch(element : IXmlDomElement; path : string) : TFhirMedicationProductBatch;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationProductBatch.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'lotNumber') then
        result.lotNumberElement := ParseString(child, path+'/lotNumber') {b}
      else if (child.baseName = 'expirationDate') then
        result.expirationDateElement := ParseDateTime(child, path+'/expirationDate') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationProductBatch(xml : TXmlBuilder; name : string; elem : TFhirMedicationProductBatch);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'lotNumber', elem.lotNumberElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'expirationDate', elem.expirationDateElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationProductBatch(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationProductBatch(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationProductBatch(jsn : TJsonObject) : TFhirMedicationProductBatch;
begin
  result := TFhirMedicationProductBatch.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('lotNumber') or jsn.has('_lotNumber') then
        result.lotNumberElement := ParseString(jsn['lotNumber'], jsn.vObj['_lotNumber']);{q}
    if jsn.has('expirationDate') or jsn.has('_expirationDate') then
        result.expirationDateElement := ParseDateTime(jsn['expirationDate'], jsn.vObj['_expirationDate']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationProductBatch(json : TJSONWriter; name : string; elem : TFhirMedicationProductBatch; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'expirationDate', elem.expirationDateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'expirationDate', elem.expirationDateElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeMedicationProductBatch(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationProductBatch; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MedicationProductBatch');
  end;
  composeBackboneElement(this, 'MedicationProductBatch', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'MedicationProductBatch', 'lotNumber', elem.lotNumberElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'MedicationProductBatch', 'expirationDate', elem.expirationDateElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMedicationPackage(element : IXmlDomElement; path : string) : TFhirMedicationPackage;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPackage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'container') then
        result.container := ParseCodeableConcept(child, path+'/container') {b}
      else if (child.baseName = 'content') then
        result.contentList.Add(ParseMedicationPackageContent(child, path+'/content')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackage(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'container', elem.container);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.contentList.Count - 1 do
      ComposeMedicationPackageContent(xml, 'content', elem.contentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPackage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPackage(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationPackage(jsn : TJsonObject) : TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('container') then
        result.container := ParseCodeableConcept(jsn.vObj['container']);{q}
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseMedicationPackageContent);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPackage(json : TJSONWriter; name : string; elem : TFhirMedicationPackage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'container', elem.container); {a}
  if (SummaryOption in [soFull, soData]) and (elem.contentList.Count > 0) then
  begin
    json.valueArray('content');
    for i := 0 to elem.contentList.Count - 1 do
      ComposeMedicationPackageContent(json, '', elem.contentList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeMedicationPackage(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationPackage; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MedicationPackage');
  end;
  composeBackboneElement(this, 'MedicationPackage', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationPackage', 'container', elem.containerElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.contentList.Count - 1 do
      ComposeMedicationPackageContent(this, 'MedicationPackage', 'content', elem.contentList[i], i);
end;

function TFHIRXmlParser.ParseMedicationPackageContent(element : IXmlDomElement; path : string) : TFhirMedicationPackageContent;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPackageContent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'item') then
        result.item := ParseReference{TFhirMedication}(child, path+'/item') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackageContent(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackageContent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirMedication}(xml, 'item', elem.item);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPackageContent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPackageContent(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationPackageContent(jsn : TJsonObject) : TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('item') then
        result.item := ParseReference{TFhirMedication}(jsn.vObj['item']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPackageContent(json : TJSONWriter; name : string; elem : TFhirMedicationPackageContent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirMedication}(json, 'item', elem.item); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeMedicationPackageContent(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationPackageContent; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MedicationPackageContent');
  end;
  composeBackboneElement(this, 'MedicationPackageContent', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirMedication}(this, 'MedicationPackageContent', 'item', elem.itemElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'MedicationPackageContent', 'amount', elem.amountElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMedication(element : IXmlDomElement; path : string) : TFhirMedication;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedication.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'isBrand') then
        result.isBrandElement := ParseBoolean(child, path+'/isBrand') {b}
      else if (child.baseName = 'manufacturer') then
        result.manufacturer := ParseReference{TFhirOrganization}(child, path+'/manufacturer') {b}
      else if (child.baseName = 'product') then
        result.product := ParseMedicationProduct(child, path+'/product') {b}
      else if (child.baseName = 'package') then
        result.package := ParseMedicationPackage(child, path+'/package') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedication(xml : TXmlBuilder; name : string; elem : TFhirMedication);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'isBrand', elem.isBrandElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'manufacturer', elem.manufacturer);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationProduct(xml, 'product', elem.product);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationPackage(xml, 'package', elem.package);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedication(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedication(jsn : TJsonObject) : TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('isBrand') or jsn.has('_isBrand') then
        result.isBrandElement := ParseBoolean(jsn['isBrand'], jsn.vObj['_isBrand']);{q}
    if jsn.has('manufacturer') then
        result.manufacturer := ParseReference{TFhirOrganization}(jsn.vObj['manufacturer']);{q}
    if jsn.has('product') then
        result.product := ParseMedicationProduct(jsn.vObj['product']);{q}
    if jsn.has('package') then
        result.package := ParseMedicationPackage(jsn.vObj['package']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedication(json : TJSONWriter; name : string; elem : TFhirMedication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'isBrand', elem.isBrandElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'isBrand', elem.isBrandElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'manufacturer', elem.manufacturer); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationProduct(json, 'product', elem.product); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationPackage(json, 'package', elem.package); {a}
end;

procedure TFHIRRDFComposer.ComposeMedication(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedication; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Medication');
  end;
  composeDomainResource(this, 'Medication', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Medication', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Medication', 'isBrand', elem.isBrandElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Medication', 'manufacturer', elem.manufacturerElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationProduct(this, 'Medication', 'product', elem.productElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationPackage(this, 'Medication', 'package', elem.packageElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMedicationAdministrationDosage(element : IXmlDomElement; path : string) : TFhirMedicationAdministrationDosage;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'siteCodeableConcept') then
        result.site := ParseCodeableConcept(child, path+'/siteCodeableConcept'){x.3}
      else if (child.baseName = 'siteReference') then
        result.site := ParseReference(child, path+'/siteReference') {a}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'rateRatio') then
        result.rate := ParseRatio(child, path+'/rateRatio'){x.3}
      else if (child.baseName = 'rateRange') then
        result.rate := ParseRange(child, path+'/rateRange'){x.3}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministrationDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministrationDosage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'siteCodeableConcept', TFhirCodeableConcept(elem.site))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) {2} then
    ComposeReference(xml, 'siteReference', TFhirReference(elem.site));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'route', elem.route);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(xml, 'rateRatio', TFhirRatio(elem.rate))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(xml, 'rateRange', TFhirRange(elem.rate));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationAdministrationDosage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationAdministrationDosage(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationAdministrationDosage(jsn : TJsonObject) : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('siteCodeableConcept') {a4} then
      result.site := ParseCodeableConcept(jsn.vObj['siteCodeableConcept']);
    if jsn.has('siteReference') {a3} then
      result.site := ParseReference(jsn.vObj['siteReference']);
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('rateRatio') {a4} then
      result.rate := ParseRatio(jsn.vObj['rateRatio']);
    if jsn.has('rateRange') {a4} then
      result.rate := ParseRange(jsn.vObj['rateRange']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationAdministrationDosage(json : TJSONWriter; name : string; elem : TFhirMedicationAdministrationDosage; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'siteCodeableConcept', TFhirCodeableConcept(elem.site)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) then
    ComposeReference(json, 'siteReference', TFhirReference(elem.site));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'route', elem.route); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) then 
    ComposeRatio(json, 'rateRatio', TFhirRatio(elem.rate)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) then 
    ComposeRange(json, 'rateRange', TFhirRange(elem.rate)) ;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeMedicationAdministrationDosage(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationAdministrationDosage; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MedicationAdministrationDosage');
  end;
  composeBackboneElement(this, 'MedicationAdministrationDosage', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MedicationAdministrationDosage', 'text', elem.textElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationAdministrationDosage', 'siteCodeableConcept', TFhirCodeableConcept(elem.site), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) {2} then
    ComposeReference(this, 'MedicationAdministrationDosage', 'siteReference', TFhirReference(elem.site), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationAdministrationDosage', 'route', elem.routeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationAdministrationDosage', 'method', elem.methodElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'MedicationAdministrationDosage', 'quantity', elem.quantityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'MedicationAdministrationDosage', 'rateRatio', TFhirRatio(elem.rate), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(this, 'MedicationAdministrationDosage', 'rateRange', TFhirRange(elem.rate), -1);
end;

function TFHIRXmlParser.ParseMedicationAdministration(element : IXmlDomElement; path : string) : TFhirMedicationAdministration;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationAdministration.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirMedicationAdminStatusEnum, SYSTEMS_TFhirMedicationAdminStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'practitioner') then
        result.practitioner := ParseReference{Resource}(child, path+'/practitioner') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'prescription') then
        result.prescription := ParseReference{TFhirMedicationOrder}(child, path+'/prescription') {b}
      else if (child.baseName = 'wasNotGiven') then
        result.wasNotGivenElement := ParseBoolean(child, path+'/wasNotGiven') {b}
      else if (child.baseName = 'reasonNotGiven') then
        result.reasonNotGivenList.Add(ParseCodeableConcept(child, path+'/reasonNotGiven')){y.2}
      else if (child.baseName = 'reasonGiven') then
        result.reasonGivenList.Add(ParseCodeableConcept(child, path+'/reasonGiven')){y.2}
      else if (child.baseName = 'effectiveTimeDateTime') then
        result.effectiveTime := ParseDateTime(child, path+'/effectiveTimeDateTime'){x.3}
      else if (child.baseName = 'effectiveTimePeriod') then
        result.effectiveTime := ParsePeriod(child, path+'/effectiveTimePeriod'){x.3}
      else if (child.baseName = 'medicationCodeableConcept') then
        result.medication := ParseCodeableConcept(child, path+'/medicationCodeableConcept'){x.3}
      else if (child.baseName = 'medicationReference') then
        result.medication := ParseReference(child, path+'/medicationReference') {a}
      else if (child.baseName = 'device') then
        result.deviceList.Add(ParseReference{TFhirDevice}(child, path+'/device')){y.2}
      else if (child.baseName = 'note') then
        result.noteElement := ParseString(child, path+'/note') {b}
      else if (child.baseName = 'dosage') then
        result.dosage := ParseMedicationAdministrationDosage(child, path+'/dosage') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministration(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministration);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'practitioner', elem.practitioner);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirMedicationOrder}(xml, 'prescription', elem.prescription);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'wasNotGiven', elem.wasNotGivenElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonNotGiven', elem.reasonNotGivenList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.reasonGivenList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonGiven', elem.reasonGivenList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effectiveTime is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveTimeDateTime', TFhirDateTime(elem.effectiveTime))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effectiveTime is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectiveTimePeriod', TFhirPeriod(elem.effectiveTime));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) {2} then
    ComposeReference(xml, 'medicationReference', TFhirReference(elem.medication));
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeReference{TFhirDevice}(xml, 'device', elem.deviceList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'note', elem.noteElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMedicationAdministrationDosage(xml, 'dosage', elem.dosage);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationAdministration(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationAdministration(jsn : TJsonObject) : TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirMedicationAdminStatusEnum, SYSTEMS_TFhirMedicationAdminStatusEnum);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('practitioner') then
        result.practitioner := ParseReference{Resource}(jsn.vObj['practitioner']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('prescription') then
        result.prescription := ParseReference{TFhirMedicationOrder}(jsn.vObj['prescription']);{q}
    if jsn.has('wasNotGiven') or jsn.has('_wasNotGiven') then
        result.wasNotGivenElement := ParseBoolean(jsn['wasNotGiven'], jsn.vObj['_wasNotGiven']);{q}
    if jsn.has('reasonNotGiven') then
      iterateArray(jsn.vArr['reasonNotGiven'], result.reasonNotGivenList, parseCodeableConcept);
    if jsn.has('reasonGiven') then
      iterateArray(jsn.vArr['reasonGiven'], result.reasonGivenList, parseCodeableConcept);
    if jsn.has('effectiveTimeDateTime') or jsn.has('_effectiveTimeDateTime') then
      result.effectiveTime := parseDateTime(jsn['effectiveTimeDateTime'], jsn.vObj['_effectiveTimeDateTime']);
    if jsn.has('effectiveTimePeriod') {a4} then
      result.effectiveTime := ParsePeriod(jsn.vObj['effectiveTimePeriod']);
    if jsn.has('medicationCodeableConcept') {a4} then
      result.medication := ParseCodeableConcept(jsn.vObj['medicationCodeableConcept']);
    if jsn.has('medicationReference') {a3} then
      result.medication := ParseReference(jsn.vObj['medicationReference']);
    if jsn.has('device') then
      iterateArray(jsn.vArr['device'], result.deviceList, parseReference{TFhirDevice});
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    if jsn.has('dosage') then
        result.dosage := ParseMedicationAdministrationDosage(jsn.vObj['dosage']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationAdministration(json : TJSONWriter; name : string; elem : TFhirMedicationAdministration; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'practitioner', elem.practitioner); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirMedicationOrder}(json, 'prescription', elem.prescription); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'wasNotGiven', elem.wasNotGivenElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'wasNotGiven', elem.wasNotGivenElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonNotGivenList.Count > 0) then
  begin
    json.valueArray('reasonNotGiven');
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonNotGivenList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonGivenList.Count > 0) then
  begin
    json.valueArray('reasonGiven');
    for i := 0 to elem.reasonGivenList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonGivenList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effectiveTime is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'effectiveTimeDateTime', TFhirDateTime(elem.effectiveTime), false);
    ComposeDateTimeProps(json, 'effectiveTimeDateTime', TFhirDateTime(elem.effectiveTime), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effectiveTime is TFhirPeriod) then 
    ComposePeriod(json, 'effectiveTimePeriod', TFhirPeriod(elem.effectiveTime)) ;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) then
    ComposeReference(json, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.deviceList.Count > 0) then
  begin
    json.valueArray('device');
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeReference{TFhirDevice}(json, '', elem.deviceList[i]); {z - Reference(Device)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMedicationAdministrationDosage(json, 'dosage', elem.dosage); {a}
end;

procedure TFHIRRDFComposer.ComposeMedicationAdministration(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationAdministration; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MedicationAdministration');
  end;
  composeDomainResource(this, 'MedicationAdministration', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationAdministration', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'MedicationAdministration', 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum, SYSTEMS_TFhirMedicationAdminStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'MedicationAdministration', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'MedicationAdministration', 'practitioner', elem.practitionerElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'MedicationAdministration', 'encounter', elem.encounterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirMedicationOrder}(this, 'MedicationAdministration', 'prescription', elem.prescriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'MedicationAdministration', 'wasNotGiven', elem.wasNotGivenElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationAdministration', 'reasonNotGiven', elem.reasonNotGivenList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.reasonGivenList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationAdministration', 'reasonGiven', elem.reasonGivenList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effectiveTime is TFhirDateTime) {6} then
    ComposeDateTime(this, 'MedicationAdministration', 'effectiveTimeDateTime', TFhirDateTime(elem.effectiveTime), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effectiveTime is TFhirPeriod) {6} then
    ComposePeriod(this, 'MedicationAdministration', 'effectiveTimePeriod', TFhirPeriod(elem.effectiveTime), -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationAdministration', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationAdministration', 'medicationReference', TFhirReference(elem.medication), -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'MedicationAdministration', 'device', elem.deviceList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MedicationAdministration', 'note', elem.noteElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMedicationAdministrationDosage(this, 'MedicationAdministration', 'dosage', elem.dosageElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMedicationDispenseDosageInstruction(element : IXmlDomElement; path : string) : TFhirMedicationDispenseDosageInstruction;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationDispenseDosageInstruction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(child, path+'/additionalInstructions') {b}
      else if (child.baseName = 'timing') then
        result.timing := ParseTiming(child, path+'/timing') {b}
      else if (child.baseName = 'asNeededBoolean') then
        result.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.baseName = 'asNeededCodeableConcept') then
        result.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.baseName = 'siteCodeableConcept') then
        result.site := ParseCodeableConcept(child, path+'/siteCodeableConcept'){x.3}
      else if (child.baseName = 'siteReference') then
        result.site := ParseReference(child, path+'/siteReference') {a}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'doseRange') then
        result.dose := ParseRange(child, path+'/doseRange'){x.3}
      else if (child.baseName = 'doseQuantity') then
        result.dose := ParseQuantity(child, path+'/doseQuantity'){x.3}
      else if (child.baseName = 'rateRatio') then
        result.rate := ParseRatio(child, path+'/rateRatio'){x.3}
      else if (child.baseName = 'rateRange') then
        result.rate := ParseRange(child, path+'/rateRange'){x.3}
      else if (child.baseName = 'maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseDosageInstruction(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseDosageInstruction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'additionalInstructions', elem.additionalInstructions);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(xml, 'timing', elem.timing);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'siteCodeableConcept', TFhirCodeableConcept(elem.site))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) {2} then
    ComposeReference(xml, 'siteReference', TFhirReference(elem.site));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'route', elem.route);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirRange) {6} then
    ComposeRange(xml, 'doseRange', TFhirRange(elem.dose))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'doseQuantity', TFhirQuantity(elem.dose));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(xml, 'rateRatio', TFhirRatio(elem.rate))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(xml, 'rateRange', TFhirRange(elem.rate));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationDispenseDosageInstruction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispenseDosageInstruction(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationDispenseDosageInstruction(jsn : TJsonObject) : TFhirMedicationDispenseDosageInstruction;
begin
  result := TFhirMedicationDispenseDosageInstruction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(jsn.vObj['additionalInstructions']);{q}
    if jsn.has('timing') then
        result.timing := ParseTiming(jsn.vObj['timing']);{q}
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('siteCodeableConcept') {a4} then
      result.site := ParseCodeableConcept(jsn.vObj['siteCodeableConcept']);
    if jsn.has('siteReference') {a3} then
      result.site := ParseReference(jsn.vObj['siteReference']);
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('doseRange') {a4} then
      result.dose := ParseRange(jsn.vObj['doseRange']);
    if jsn.has('doseQuantity') {a4} then
      result.dose := ParseQuantity(jsn.vObj['doseQuantity']);
    if jsn.has('rateRatio') {a4} then
      result.rate := ParseRatio(jsn.vObj['rateRatio']);
    if jsn.has('rateRange') {a4} then
      result.rate := ParseRange(jsn.vObj['rateRange']);
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationDispenseDosageInstruction(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseDosageInstruction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'additionalInstructions', elem.additionalInstructions); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(json, 'timing', elem.timing); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) ;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'siteCodeableConcept', TFhirCodeableConcept(elem.site)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) then
    ComposeReference(json, 'siteReference', TFhirReference(elem.site));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'route', elem.route); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirRange) then 
    ComposeRange(json, 'doseRange', TFhirRange(elem.dose)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirQuantity) then 
    ComposeQuantity(json, 'doseQuantity', TFhirQuantity(elem.dose)) ;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) then 
    ComposeRatio(json, 'rateRatio', TFhirRatio(elem.rate)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) then 
    ComposeRange(json, 'rateRange', TFhirRange(elem.rate)) ;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeMedicationDispenseDosageInstruction(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationDispenseDosageInstruction; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MedicationDispenseDosageInstruction');
  end;
  composeBackboneElement(this, 'MedicationDispenseDosageInstruction', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MedicationDispenseDosageInstruction', 'text', elem.textElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationDispenseDosageInstruction', 'additionalInstructions', elem.additionalInstructionsElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(this, 'MedicationDispenseDosageInstruction', 'timing', elem.timingElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(this, 'MedicationDispenseDosageInstruction', 'asNeededBoolean', TFhirBoolean(elem.asNeeded), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationDispenseDosageInstruction', 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded), -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationDispenseDosageInstruction', 'siteCodeableConcept', TFhirCodeableConcept(elem.site), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) {2} then
    ComposeReference(this, 'MedicationDispenseDosageInstruction', 'siteReference', TFhirReference(elem.site), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationDispenseDosageInstruction', 'route', elem.routeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationDispenseDosageInstruction', 'method', elem.methodElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirRange) {6} then
    ComposeRange(this, 'MedicationDispenseDosageInstruction', 'doseRange', TFhirRange(elem.dose), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MedicationDispenseDosageInstruction', 'doseQuantity', TFhirQuantity(elem.dose), -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'MedicationDispenseDosageInstruction', 'rateRatio', TFhirRatio(elem.rate), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(this, 'MedicationDispenseDosageInstruction', 'rateRange', TFhirRange(elem.rate), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'MedicationDispenseDosageInstruction', 'maxDosePerPeriod', elem.maxDosePerPeriodElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMedicationDispenseSubstitution(element : IXmlDomElement; path : string) : TFhirMedicationDispenseSubstitution;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'reason') then
        result.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.baseName = 'responsibleParty') then
        result.responsiblePartyList.Add(ParseReference{TFhirPractitioner}(child, path+'/responsibleParty')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseSubstitution);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.responsiblePartyList.Count - 1 do
      ComposeReference{TFhirPractitioner}(xml, 'responsibleParty', elem.responsiblePartyList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationDispenseSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispenseSubstitution(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationDispenseSubstitution(jsn : TJsonObject) : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('responsibleParty') then
      iterateArray(jsn.vArr['responsibleParty'], result.responsiblePartyList, parseReference{TFhirPractitioner});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationDispenseSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseSubstitution; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonList.Count > 0) then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.responsiblePartyList.Count > 0) then
  begin
    json.valueArray('responsibleParty');
    for i := 0 to elem.responsiblePartyList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.responsiblePartyList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeMedicationDispenseSubstitution(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationDispenseSubstitution; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MedicationDispenseSubstitution');
  end;
  composeBackboneElement(this, 'MedicationDispenseSubstitution', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationDispenseSubstitution', 'type', elem.type_Element, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationDispenseSubstitution', 'reason', elem.reasonList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.responsiblePartyList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'MedicationDispenseSubstitution', 'responsibleParty', elem.responsiblePartyList[i], i);
end;

function TFHIRXmlParser.ParseMedicationDispense(element : IXmlDomElement; path : string) : TFhirMedicationDispense;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationDispense.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirMedicationDispenseStatusEnum, SYSTEMS_TFhirMedicationDispenseStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'dispenser') then
        result.dispenser := ParseReference{TFhirPractitioner}(child, path+'/dispenser') {b}
      else if (child.baseName = 'authorizingPrescription') then
        result.authorizingPrescriptionList.Add(ParseReference{TFhirMedicationOrder}(child, path+'/authorizingPrescription')){y.2}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'daysSupply') then
        result.daysSupply := ParseQuantity(child, path+'/daysSupply') {b}
      else if (child.baseName = 'medicationCodeableConcept') then
        result.medication := ParseCodeableConcept(child, path+'/medicationCodeableConcept'){x.3}
      else if (child.baseName = 'medicationReference') then
        result.medication := ParseReference(child, path+'/medicationReference') {a}
      else if (child.baseName = 'whenPrepared') then
        result.whenPreparedElement := ParseDateTime(child, path+'/whenPrepared') {b}
      else if (child.baseName = 'whenHandedOver') then
        result.whenHandedOverElement := ParseDateTime(child, path+'/whenHandedOver') {b}
      else if (child.baseName = 'destination') then
        result.destination := ParseReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.baseName = 'receiver') then
        result.receiverList.Add(ParseReference{Resource}(child, path+'/receiver')){y.2}
      else if (child.baseName = 'note') then
        result.noteElement := ParseString(child, path+'/note') {b}
      else if (child.baseName = 'dosageInstruction') then
        result.dosageInstructionList.Add(ParseMedicationDispenseDosageInstruction(child, path+'/dosageInstruction')){y.2}
      else if (child.baseName = 'substitution') then
        result.substitution := ParseMedicationDispenseSubstitution(child, path+'/substitution') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispense);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationDispenseStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'dispenser', elem.dispenser);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.authorizingPrescriptionList.Count - 1 do
      ComposeReference{TFhirMedicationOrder}(xml, 'authorizingPrescription', elem.authorizingPrescriptionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'daysSupply', elem.daysSupply);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) {2} then
    ComposeReference(xml, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'whenPrepared', elem.whenPreparedElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'whenHandedOver', elem.whenHandedOverElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(xml, 'destination', elem.destination);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{Resource}(xml, 'receiver', elem.receiverList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'note', elem.noteElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeMedicationDispenseDosageInstruction(xml, 'dosageInstruction', elem.dosageInstructionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMedicationDispenseSubstitution(xml, 'substitution', elem.substitution);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispense(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationDispense(jsn : TJsonObject) : TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirMedicationDispenseStatusEnum, SYSTEMS_TFhirMedicationDispenseStatusEnum);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('dispenser') then
        result.dispenser := ParseReference{TFhirPractitioner}(jsn.vObj['dispenser']);{q}
    if jsn.has('authorizingPrescription') then
      iterateArray(jsn.vArr['authorizingPrescription'], result.authorizingPrescriptionList, parseReference{TFhirMedicationOrder});
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('daysSupply') then
        result.daysSupply := ParseQuantity(jsn.vObj['daysSupply']);{q}
    if jsn.has('medicationCodeableConcept') {a4} then
      result.medication := ParseCodeableConcept(jsn.vObj['medicationCodeableConcept']);
    if jsn.has('medicationReference') {a3} then
      result.medication := ParseReference(jsn.vObj['medicationReference']);
    if jsn.has('whenPrepared') or jsn.has('_whenPrepared') then
        result.whenPreparedElement := ParseDateTime(jsn['whenPrepared'], jsn.vObj['_whenPrepared']);{q}
    if jsn.has('whenHandedOver') or jsn.has('_whenHandedOver') then
        result.whenHandedOverElement := ParseDateTime(jsn['whenHandedOver'], jsn.vObj['_whenHandedOver']);{q}
    if jsn.has('destination') then
        result.destination := ParseReference{TFhirLocation}(jsn.vObj['destination']);{q}
    if jsn.has('receiver') then
      iterateArray(jsn.vArr['receiver'], result.receiverList, parseReference{Resource});
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    if jsn.has('dosageInstruction') then
      iterateArray(jsn.vArr['dosageInstruction'], result.dosageInstructionList, parseMedicationDispenseDosageInstruction);
    if jsn.has('substitution') then
        result.substitution := ParseMedicationDispenseSubstitution(jsn.vObj['substitution']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationDispense(json : TJSONWriter; name : string; elem : TFhirMedicationDispense; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMedicationDispenseStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMedicationDispenseStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'dispenser', elem.dispenser); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.authorizingPrescriptionList.Count > 0) then
  begin
    json.valueArray('authorizingPrescription');
    for i := 0 to elem.authorizingPrescriptionList.Count - 1 do
      ComposeReference{TFhirMedicationOrder}(json, '', elem.authorizingPrescriptionList[i]); {z - Reference(MedicationOrder)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'daysSupply', elem.daysSupply); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) then
    ComposeReference(json, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'whenPrepared', elem.whenPreparedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'whenPrepared', elem.whenPreparedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'whenHandedOver', elem.whenHandedOverElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'whenHandedOver', elem.whenHandedOverElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.receiverList.Count > 0) then
  begin
    json.valueArray('receiver');
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.receiverList[i]); {z - Reference(Patient|Practitioner)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dosageInstructionList.Count > 0) then
  begin
    json.valueArray('dosageInstruction');
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeMedicationDispenseDosageInstruction(json, '', elem.dosageInstructionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMedicationDispenseSubstitution(json, 'substitution', elem.substitution); {a}
end;

procedure TFHIRRDFComposer.ComposeMedicationDispense(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationDispense; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MedicationDispense');
  end;
  composeDomainResource(this, 'MedicationDispense', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'MedicationDispense', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'MedicationDispense', 'status', elem.StatusElement, CODES_TFhirMedicationDispenseStatusEnum, SYSTEMS_TFhirMedicationDispenseStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'MedicationDispense', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'MedicationDispense', 'dispenser', elem.dispenserElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.authorizingPrescriptionList.Count - 1 do
      ComposeReference{TFhirMedicationOrder}(this, 'MedicationDispense', 'authorizingPrescription', elem.authorizingPrescriptionList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationDispense', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'MedicationDispense', 'quantity', elem.quantityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'MedicationDispense', 'daysSupply', elem.daysSupplyElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationDispense', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationDispense', 'medicationReference', TFhirReference(elem.medication), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'MedicationDispense', 'whenPrepared', elem.whenPreparedElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'MedicationDispense', 'whenHandedOver', elem.whenHandedOverElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(this, 'MedicationDispense', 'destination', elem.destinationElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{Resource}(this, 'MedicationDispense', 'receiver', elem.receiverList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MedicationDispense', 'note', elem.noteElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeMedicationDispenseDosageInstruction(this, 'MedicationDispense', 'dosageInstruction', elem.dosageInstructionList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMedicationDispenseSubstitution(this, 'MedicationDispense', 'substitution', elem.substitutionElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMedicationOrderDosageInstruction(element : IXmlDomElement; path : string) : TFhirMedicationOrderDosageInstruction;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationOrderDosageInstruction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(child, path+'/additionalInstructions') {b}
      else if (child.baseName = 'timing') then
        result.timing := ParseTiming(child, path+'/timing') {b}
      else if (child.baseName = 'asNeededBoolean') then
        result.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.baseName = 'asNeededCodeableConcept') then
        result.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.baseName = 'siteCodeableConcept') then
        result.site := ParseCodeableConcept(child, path+'/siteCodeableConcept'){x.3}
      else if (child.baseName = 'siteReference') then
        result.site := ParseReference(child, path+'/siteReference') {a}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'doseRange') then
        result.dose := ParseRange(child, path+'/doseRange'){x.3}
      else if (child.baseName = 'doseQuantity') then
        result.dose := ParseQuantity(child, path+'/doseQuantity'){x.3}
      else if (child.baseName = 'rateRatio') then
        result.rate := ParseRatio(child, path+'/rateRatio'){x.3}
      else if (child.baseName = 'rateRange') then
        result.rate := ParseRange(child, path+'/rateRange'){x.3}
      else if (child.baseName = 'maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationOrderDosageInstruction(xml : TXmlBuilder; name : string; elem : TFhirMedicationOrderDosageInstruction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'additionalInstructions', elem.additionalInstructions);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(xml, 'timing', elem.timing);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'siteCodeableConcept', TFhirCodeableConcept(elem.site))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) {2} then
    ComposeReference(xml, 'siteReference', TFhirReference(elem.site));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'route', elem.route);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirRange) {6} then
    ComposeRange(xml, 'doseRange', TFhirRange(elem.dose))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'doseQuantity', TFhirQuantity(elem.dose));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(xml, 'rateRatio', TFhirRatio(elem.rate))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(xml, 'rateRange', TFhirRange(elem.rate));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationOrderDosageInstruction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationOrderDosageInstruction(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationOrderDosageInstruction(jsn : TJsonObject) : TFhirMedicationOrderDosageInstruction;
begin
  result := TFhirMedicationOrderDosageInstruction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(jsn.vObj['additionalInstructions']);{q}
    if jsn.has('timing') then
        result.timing := ParseTiming(jsn.vObj['timing']);{q}
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('siteCodeableConcept') {a4} then
      result.site := ParseCodeableConcept(jsn.vObj['siteCodeableConcept']);
    if jsn.has('siteReference') {a3} then
      result.site := ParseReference(jsn.vObj['siteReference']);
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('doseRange') {a4} then
      result.dose := ParseRange(jsn.vObj['doseRange']);
    if jsn.has('doseQuantity') {a4} then
      result.dose := ParseQuantity(jsn.vObj['doseQuantity']);
    if jsn.has('rateRatio') {a4} then
      result.rate := ParseRatio(jsn.vObj['rateRatio']);
    if jsn.has('rateRange') {a4} then
      result.rate := ParseRange(jsn.vObj['rateRange']);
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationOrderDosageInstruction(json : TJSONWriter; name : string; elem : TFhirMedicationOrderDosageInstruction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'additionalInstructions', elem.additionalInstructions); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(json, 'timing', elem.timing); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) ;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'siteCodeableConcept', TFhirCodeableConcept(elem.site)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) then
    ComposeReference(json, 'siteReference', TFhirReference(elem.site));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'route', elem.route); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirRange) then 
    ComposeRange(json, 'doseRange', TFhirRange(elem.dose)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirQuantity) then 
    ComposeQuantity(json, 'doseQuantity', TFhirQuantity(elem.dose)) ;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) then 
    ComposeRatio(json, 'rateRatio', TFhirRatio(elem.rate)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) then 
    ComposeRange(json, 'rateRange', TFhirRange(elem.rate)) ;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeMedicationOrderDosageInstruction(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationOrderDosageInstruction; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MedicationOrderDosageInstruction');
  end;
  composeBackboneElement(this, 'MedicationOrderDosageInstruction', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MedicationOrderDosageInstruction', 'text', elem.textElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationOrderDosageInstruction', 'additionalInstructions', elem.additionalInstructionsElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(this, 'MedicationOrderDosageInstruction', 'timing', elem.timingElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(this, 'MedicationOrderDosageInstruction', 'asNeededBoolean', TFhirBoolean(elem.asNeeded), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationOrderDosageInstruction', 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded), -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationOrderDosageInstruction', 'siteCodeableConcept', TFhirCodeableConcept(elem.site), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) {2} then
    ComposeReference(this, 'MedicationOrderDosageInstruction', 'siteReference', TFhirReference(elem.site), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationOrderDosageInstruction', 'route', elem.routeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationOrderDosageInstruction', 'method', elem.methodElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirRange) {6} then
    ComposeRange(this, 'MedicationOrderDosageInstruction', 'doseRange', TFhirRange(elem.dose), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MedicationOrderDosageInstruction', 'doseQuantity', TFhirQuantity(elem.dose), -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'MedicationOrderDosageInstruction', 'rateRatio', TFhirRatio(elem.rate), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(this, 'MedicationOrderDosageInstruction', 'rateRange', TFhirRange(elem.rate), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'MedicationOrderDosageInstruction', 'maxDosePerPeriod', elem.maxDosePerPeriodElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMedicationOrderDispenseRequest(element : IXmlDomElement; path : string) : TFhirMedicationOrderDispenseRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationOrderDispenseRequest.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'medicationCodeableConcept') then
        result.medication := ParseCodeableConcept(child, path+'/medicationCodeableConcept'){x.3}
      else if (child.baseName = 'medicationReference') then
        result.medication := ParseReference(child, path+'/medicationReference') {a}
      else if (child.baseName = 'validityPeriod') then
        result.validityPeriod := ParsePeriod(child, path+'/validityPeriod') {b}
      else if (child.baseName = 'numberOfRepeatsAllowed') then
        result.numberOfRepeatsAllowedElement := ParsePositiveInt(child, path+'/numberOfRepeatsAllowed') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'expectedSupplyDuration') then
        result.expectedSupplyDuration := ParseQuantity(child, path+'/expectedSupplyDuration') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationOrderDispenseRequest(xml : TXmlBuilder; name : string; elem : TFhirMedicationOrderDispenseRequest);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) {2} then
    ComposeReference(xml, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'validityPeriod', elem.validityPeriod);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'expectedSupplyDuration', elem.expectedSupplyDuration);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationOrderDispenseRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationOrderDispenseRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationOrderDispenseRequest(jsn : TJsonObject) : TFhirMedicationOrderDispenseRequest;
begin
  result := TFhirMedicationOrderDispenseRequest.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('medicationCodeableConcept') {a4} then
      result.medication := ParseCodeableConcept(jsn.vObj['medicationCodeableConcept']);
    if jsn.has('medicationReference') {a3} then
      result.medication := ParseReference(jsn.vObj['medicationReference']);
    if jsn.has('validityPeriod') then
        result.validityPeriod := ParsePeriod(jsn.vObj['validityPeriod']);{q}
    if jsn.has('numberOfRepeatsAllowed') or jsn.has('_numberOfRepeatsAllowed') then
        result.numberOfRepeatsAllowedElement := ParsePositiveInt(jsn['numberOfRepeatsAllowed'], jsn.vObj['_numberOfRepeatsAllowed']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('expectedSupplyDuration') then
        result.expectedSupplyDuration := ParseQuantity(jsn.vObj['expectedSupplyDuration']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationOrderDispenseRequest(json : TJSONWriter; name : string; elem : TFhirMedicationOrderDispenseRequest; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) then
    ComposeReference(json, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'validityPeriod', elem.validityPeriod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'expectedSupplyDuration', elem.expectedSupplyDuration); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeMedicationOrderDispenseRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationOrderDispenseRequest; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MedicationOrderDispenseRequest');
  end;
  composeBackboneElement(this, 'MedicationOrderDispenseRequest', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationOrderDispenseRequest', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationOrderDispenseRequest', 'medicationReference', TFhirReference(elem.medication), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'MedicationOrderDispenseRequest', 'validityPeriod', elem.validityPeriodElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'MedicationOrderDispenseRequest', 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'MedicationOrderDispenseRequest', 'quantity', elem.quantityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'MedicationOrderDispenseRequest', 'expectedSupplyDuration', elem.expectedSupplyDurationElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMedicationOrderSubstitution(element : IXmlDomElement; path : string) : TFhirMedicationOrderSubstitution;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationOrderSubstitution.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationOrderSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationOrderSubstitution);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationOrderSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationOrderSubstitution(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationOrderSubstitution(jsn : TJsonObject) : TFhirMedicationOrderSubstitution;
begin
  result := TFhirMedicationOrderSubstitution.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationOrderSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationOrderSubstitution; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeMedicationOrderSubstitution(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationOrderSubstitution; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MedicationOrderSubstitution');
  end;
  composeBackboneElement(this, 'MedicationOrderSubstitution', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationOrderSubstitution', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationOrderSubstitution', 'reason', elem.reasonElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMedicationOrder(element : IXmlDomElement; path : string) : TFhirMedicationOrder;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationOrder.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'dateWritten') then
        result.dateWrittenElement := ParseDateTime(child, path+'/dateWritten') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirMedicationOrderStatusEnum, SYSTEMS_TFhirMedicationOrderStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'dateEnded') then
        result.dateEndedElement := ParseDateTime(child, path+'/dateEnded') {b}
      else if (child.baseName = 'reasonEnded') then
        result.reasonEnded := ParseCodeableConcept(child, path+'/reasonEnded') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'prescriber') then
        result.prescriber := ParseReference{TFhirPractitioner}(child, path+'/prescriber') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'reasonCodeableConcept') then
        result.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.baseName = 'reasonReference') then
        result.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.baseName = 'note') then
        result.noteElement := ParseString(child, path+'/note') {b}
      else if (child.baseName = 'medicationCodeableConcept') then
        result.medication := ParseCodeableConcept(child, path+'/medicationCodeableConcept'){x.3}
      else if (child.baseName = 'medicationReference') then
        result.medication := ParseReference(child, path+'/medicationReference') {a}
      else if (child.baseName = 'dosageInstruction') then
        result.dosageInstructionList.Add(ParseMedicationOrderDosageInstruction(child, path+'/dosageInstruction')){y.2}
      else if (child.baseName = 'dispenseRequest') then
        result.dispenseRequest := ParseMedicationOrderDispenseRequest(child, path+'/dispenseRequest') {b}
      else if (child.baseName = 'substitution') then
        result.substitution := ParseMedicationOrderSubstitution(child, path+'/substitution') {b}
      else if (child.baseName = 'priorPrescription') then
        result.priorPrescription := ParseReference{TFhirMedicationOrder}(child, path+'/priorPrescription') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationOrder(xml : TXmlBuilder; name : string; elem : TFhirMedicationOrder);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'dateWritten', elem.dateWrittenElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationOrderStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'dateEnded', elem.dateEndedElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'reasonEnded', elem.reasonEnded);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'prescriber', elem.prescriber);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'note', elem.noteElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) {2} then
    ComposeReference(xml, 'medicationReference', TFhirReference(elem.medication));
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeMedicationOrderDosageInstruction(xml, 'dosageInstruction', elem.dosageInstructionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMedicationOrderDispenseRequest(xml, 'dispenseRequest', elem.dispenseRequest);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMedicationOrderSubstitution(xml, 'substitution', elem.substitution);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirMedicationOrder}(xml, 'priorPrescription', elem.priorPrescription);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationOrder(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationOrder(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationOrder(jsn : TJsonObject) : TFhirMedicationOrder;
begin
  result := TFhirMedicationOrder.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('dateWritten') or jsn.has('_dateWritten') then
        result.dateWrittenElement := ParseDateTime(jsn['dateWritten'], jsn.vObj['_dateWritten']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirMedicationOrderStatusEnum, SYSTEMS_TFhirMedicationOrderStatusEnum);
    if jsn.has('dateEnded') or jsn.has('_dateEnded') then
        result.dateEndedElement := ParseDateTime(jsn['dateEnded'], jsn.vObj['_dateEnded']);{q}
    if jsn.has('reasonEnded') then
        result.reasonEnded := ParseCodeableConcept(jsn.vObj['reasonEnded']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('prescriber') then
        result.prescriber := ParseReference{TFhirPractitioner}(jsn.vObj['prescriber']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    if jsn.has('medicationCodeableConcept') {a4} then
      result.medication := ParseCodeableConcept(jsn.vObj['medicationCodeableConcept']);
    if jsn.has('medicationReference') {a3} then
      result.medication := ParseReference(jsn.vObj['medicationReference']);
    if jsn.has('dosageInstruction') then
      iterateArray(jsn.vArr['dosageInstruction'], result.dosageInstructionList, parseMedicationOrderDosageInstruction);
    if jsn.has('dispenseRequest') then
        result.dispenseRequest := ParseMedicationOrderDispenseRequest(jsn.vObj['dispenseRequest']);{q}
    if jsn.has('substitution') then
        result.substitution := ParseMedicationOrderSubstitution(jsn.vObj['substitution']);{q}
    if jsn.has('priorPrescription') then
        result.priorPrescription := ParseReference{TFhirMedicationOrder}(jsn.vObj['priorPrescription']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationOrder(json : TJSONWriter; name : string; elem : TFhirMedicationOrder; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'dateWritten', elem.dateWrittenElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'dateWritten', elem.dateWrittenElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMedicationOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMedicationOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'dateEnded', elem.dateEndedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'dateEnded', elem.dateEndedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'reasonEnded', elem.reasonEnded); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'prescriber', elem.prescriber); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) then
    ComposeReference(json, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dosageInstructionList.Count > 0) then
  begin
    json.valueArray('dosageInstruction');
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeMedicationOrderDosageInstruction(json, '', elem.dosageInstructionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMedicationOrderDispenseRequest(json, 'dispenseRequest', elem.dispenseRequest); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMedicationOrderSubstitution(json, 'substitution', elem.substitution); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirMedicationOrder}(json, 'priorPrescription', elem.priorPrescription); {a}
end;

procedure TFHIRRDFComposer.ComposeMedicationOrder(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationOrder; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MedicationOrder');
  end;
  composeDomainResource(this, 'MedicationOrder', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationOrder', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'MedicationOrder', 'dateWritten', elem.dateWrittenElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'MedicationOrder', 'status', elem.StatusElement, CODES_TFhirMedicationOrderStatusEnum, SYSTEMS_TFhirMedicationOrderStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'MedicationOrder', 'dateEnded', elem.dateEndedElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationOrder', 'reasonEnded', elem.reasonEndedElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'MedicationOrder', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'MedicationOrder', 'prescriber', elem.prescriberElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'MedicationOrder', 'encounter', elem.encounterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationOrder', 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(this, 'MedicationOrder', 'reasonReference', TFhirReference(elem.reason), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MedicationOrder', 'note', elem.noteElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationOrder', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationOrder', 'medicationReference', TFhirReference(elem.medication), -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeMedicationOrderDosageInstruction(this, 'MedicationOrder', 'dosageInstruction', elem.dosageInstructionList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMedicationOrderDispenseRequest(this, 'MedicationOrder', 'dispenseRequest', elem.dispenseRequestElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMedicationOrderSubstitution(this, 'MedicationOrder', 'substitution', elem.substitutionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirMedicationOrder}(this, 'MedicationOrder', 'priorPrescription', elem.priorPrescriptionElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMedicationStatementDosage(element : IXmlDomElement; path : string) : TFhirMedicationStatementDosage;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'timing') then
        result.timing := ParseTiming(child, path+'/timing') {b}
      else if (child.baseName = 'asNeededBoolean') then
        result.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.baseName = 'asNeededCodeableConcept') then
        result.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.baseName = 'siteCodeableConcept') then
        result.site := ParseCodeableConcept(child, path+'/siteCodeableConcept'){x.3}
      else if (child.baseName = 'siteReference') then
        result.site := ParseReference(child, path+'/siteReference') {a}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'quantityQuantity') then
        result.quantity := ParseQuantity(child, path+'/quantityQuantity'){x.3}
      else if (child.baseName = 'quantityRange') then
        result.quantity := ParseRange(child, path+'/quantityRange'){x.3}
      else if (child.baseName = 'rateRatio') then
        result.rate := ParseRatio(child, path+'/rateRatio'){x.3}
      else if (child.baseName = 'rateRange') then
        result.rate := ParseRange(child, path+'/rateRange'){x.3}
      else if (child.baseName = 'maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationStatementDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatementDosage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(xml, 'timing', elem.timing);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'siteCodeableConcept', TFhirCodeableConcept(elem.site))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) {2} then
    ComposeReference(xml, 'siteReference', TFhirReference(elem.site));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'route', elem.route);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'quantityQuantity', TFhirQuantity(elem.quantity))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirRange) {6} then
    ComposeRange(xml, 'quantityRange', TFhirRange(elem.quantity));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(xml, 'rateRatio', TFhirRatio(elem.rate))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(xml, 'rateRange', TFhirRange(elem.rate));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationStatementDosage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationStatementDosage(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationStatementDosage(jsn : TJsonObject) : TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('timing') then
        result.timing := ParseTiming(jsn.vObj['timing']);{q}
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('siteCodeableConcept') {a4} then
      result.site := ParseCodeableConcept(jsn.vObj['siteCodeableConcept']);
    if jsn.has('siteReference') {a3} then
      result.site := ParseReference(jsn.vObj['siteReference']);
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('quantityQuantity') {a4} then
      result.quantity := ParseQuantity(jsn.vObj['quantityQuantity']);
    if jsn.has('quantityRange') {a4} then
      result.quantity := ParseRange(jsn.vObj['quantityRange']);
    if jsn.has('rateRatio') {a4} then
      result.rate := ParseRatio(jsn.vObj['rateRatio']);
    if jsn.has('rateRange') {a4} then
      result.rate := ParseRange(jsn.vObj['rateRange']);
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationStatementDosage(json : TJSONWriter; name : string; elem : TFhirMedicationStatementDosage; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(json, 'timing', elem.timing); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) ;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'siteCodeableConcept', TFhirCodeableConcept(elem.site)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) then
    ComposeReference(json, 'siteReference', TFhirReference(elem.site));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'route', elem.route); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirQuantity) then 
    ComposeQuantity(json, 'quantityQuantity', TFhirQuantity(elem.quantity)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirRange) then 
    ComposeRange(json, 'quantityRange', TFhirRange(elem.quantity)) ;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) then 
    ComposeRatio(json, 'rateRatio', TFhirRatio(elem.rate)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) then 
    ComposeRange(json, 'rateRange', TFhirRange(elem.rate)) ;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeMedicationStatementDosage(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationStatementDosage; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MedicationStatementDosage');
  end;
  composeBackboneElement(this, 'MedicationStatementDosage', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MedicationStatementDosage', 'text', elem.textElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(this, 'MedicationStatementDosage', 'timing', elem.timingElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(this, 'MedicationStatementDosage', 'asNeededBoolean', TFhirBoolean(elem.asNeeded), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationStatementDosage', 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded), -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationStatementDosage', 'siteCodeableConcept', TFhirCodeableConcept(elem.site), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) {2} then
    ComposeReference(this, 'MedicationStatementDosage', 'siteReference', TFhirReference(elem.site), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationStatementDosage', 'route', elem.routeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationStatementDosage', 'method', elem.methodElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MedicationStatementDosage', 'quantityQuantity', TFhirQuantity(elem.quantity), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirRange) {6} then
    ComposeRange(this, 'MedicationStatementDosage', 'quantityRange', TFhirRange(elem.quantity), -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'MedicationStatementDosage', 'rateRatio', TFhirRatio(elem.rate), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(this, 'MedicationStatementDosage', 'rateRange', TFhirRange(elem.rate), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'MedicationStatementDosage', 'maxDosePerPeriod', elem.maxDosePerPeriodElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMedicationStatement(element : IXmlDomElement; path : string) : TFhirMedicationStatement;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationStatement.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'informationSource') then
        result.informationSource := ParseReference{Resource}(child, path+'/informationSource') {b}
      else if (child.baseName = 'dateAsserted') then
        result.dateAssertedElement := ParseDateTime(child, path+'/dateAsserted') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirMedicationStatementStatusEnum, SYSTEMS_TFhirMedicationStatementStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'wasNotTaken') then
        result.wasNotTakenElement := ParseBoolean(child, path+'/wasNotTaken') {b}
      else if (child.baseName = 'reasonNotTaken') then
        result.reasonNotTakenList.Add(ParseCodeableConcept(child, path+'/reasonNotTaken')){y.2}
      else if (child.baseName = 'reasonForUseCodeableConcept') then
        result.reasonForUse := ParseCodeableConcept(child, path+'/reasonForUseCodeableConcept'){x.3}
      else if (child.baseName = 'reasonForUseReference') then
        result.reasonForUse := ParseReference(child, path+'/reasonForUseReference') {a}
      else if (child.baseName = 'effectiveDateTime') then
        result.effective := ParseDateTime(child, path+'/effectiveDateTime'){x.3}
      else if (child.baseName = 'effectivePeriod') then
        result.effective := ParsePeriod(child, path+'/effectivePeriod'){x.3}
      else if (child.baseName = 'note') then
        result.noteElement := ParseString(child, path+'/note') {b}
      else if (child.baseName = 'supportingInformation') then
        result.supportingInformationList.Add(ParseReference{TFhirReference}(child, path+'/supportingInformation')){y.2}
      else if (child.baseName = 'medicationCodeableConcept') then
        result.medication := ParseCodeableConcept(child, path+'/medicationCodeableConcept'){x.3}
      else if (child.baseName = 'medicationReference') then
        result.medication := ParseReference(child, path+'/medicationReference') {a}
      else if (child.baseName = 'dosage') then
        result.dosageList.Add(ParseMedicationStatementDosage(child, path+'/dosage')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationStatement(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'informationSource', elem.informationSource);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'dateAsserted', elem.dateAssertedElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationStatementStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'wasNotTaken', elem.wasNotTakenElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.reasonNotTakenList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonNotTaken', elem.reasonNotTakenList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonForUse is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonForUseCodeableConcept', TFhirCodeableConcept(elem.reasonForUse))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonForUse is TFhirReference) {2} then
    ComposeReference(xml, 'reasonForUseReference', TFhirReference(elem.reasonForUse));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveDateTime', TFhirDateTime(elem.effective))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectivePeriod', TFhirPeriod(elem.effective));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'note', elem.noteElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'supportingInformation', elem.supportingInformationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) {2} then
    ComposeReference(xml, 'medicationReference', TFhirReference(elem.medication));
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeMedicationStatementDosage(xml, 'dosage', elem.dosageList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationStatement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationStatement(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationStatement(jsn : TJsonObject) : TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('informationSource') then
        result.informationSource := ParseReference{Resource}(jsn.vObj['informationSource']);{q}
    if jsn.has('dateAsserted') or jsn.has('_dateAsserted') then
        result.dateAssertedElement := ParseDateTime(jsn['dateAsserted'], jsn.vObj['_dateAsserted']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirMedicationStatementStatusEnum, SYSTEMS_TFhirMedicationStatementStatusEnum);
    if jsn.has('wasNotTaken') or jsn.has('_wasNotTaken') then
        result.wasNotTakenElement := ParseBoolean(jsn['wasNotTaken'], jsn.vObj['_wasNotTaken']);{q}
    if jsn.has('reasonNotTaken') then
      iterateArray(jsn.vArr['reasonNotTaken'], result.reasonNotTakenList, parseCodeableConcept);
    if jsn.has('reasonForUseCodeableConcept') {a4} then
      result.reasonForUse := ParseCodeableConcept(jsn.vObj['reasonForUseCodeableConcept']);
    if jsn.has('reasonForUseReference') {a3} then
      result.reasonForUse := ParseReference(jsn.vObj['reasonForUseReference']);
    if jsn.has('effectiveDateTime') or jsn.has('_effectiveDateTime') then
      result.effective := parseDateTime(jsn['effectiveDateTime'], jsn.vObj['_effectiveDateTime']);
    if jsn.has('effectivePeriod') {a4} then
      result.effective := ParsePeriod(jsn.vObj['effectivePeriod']);
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    if jsn.has('supportingInformation') then
      iterateArray(jsn.vArr['supportingInformation'], result.supportingInformationList, parseReference{TFhirReference});
    if jsn.has('medicationCodeableConcept') {a4} then
      result.medication := ParseCodeableConcept(jsn.vObj['medicationCodeableConcept']);
    if jsn.has('medicationReference') {a3} then
      result.medication := ParseReference(jsn.vObj['medicationReference']);
    if jsn.has('dosage') then
      iterateArray(jsn.vArr['dosage'], result.dosageList, parseMedicationStatementDosage);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationStatement(json : TJSONWriter; name : string; elem : TFhirMedicationStatement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'informationSource', elem.informationSource); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'dateAsserted', elem.dateAssertedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'dateAsserted', elem.dateAssertedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMedicationStatementStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMedicationStatementStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'wasNotTaken', elem.wasNotTakenElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'wasNotTaken', elem.wasNotTakenElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonNotTakenList.Count > 0) then
  begin
    json.valueArray('reasonNotTaken');
    for i := 0 to elem.reasonNotTakenList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonNotTakenList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonForUse is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonForUseCodeableConcept', TFhirCodeableConcept(elem.reasonForUse)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonForUse is TFhirReference) then
    ComposeReference(json, 'reasonForUseReference', TFhirReference(elem.reasonForUse));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
    ComposeDateTimeProps(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) then 
    ComposePeriod(json, 'effectivePeriod', TFhirPeriod(elem.effective)) ;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.supportingInformationList.Count > 0) then
  begin
    json.valueArray('supportingInformation');
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.supportingInformationList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) then
    ComposeReference(json, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dosageList.Count > 0) then
  begin
    json.valueArray('dosage');
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeMedicationStatementDosage(json, '', elem.dosageList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeMedicationStatement(parent :  TRDFComplex; parentType, name : String; elem : TFhirMedicationStatement; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MedicationStatement');
  end;
  composeDomainResource(this, 'MedicationStatement', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationStatement', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'MedicationStatement', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'MedicationStatement', 'informationSource', elem.informationSourceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'MedicationStatement', 'dateAsserted', elem.dateAssertedElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'MedicationStatement', 'status', elem.StatusElement, CODES_TFhirMedicationStatementStatusEnum, SYSTEMS_TFhirMedicationStatementStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'MedicationStatement', 'wasNotTaken', elem.wasNotTakenElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.reasonNotTakenList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationStatement', 'reasonNotTaken', elem.reasonNotTakenList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonForUse is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationStatement', 'reasonForUseCodeableConcept', TFhirCodeableConcept(elem.reasonForUse), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonForUse is TFhirReference) {2} then
    ComposeReference(this, 'MedicationStatement', 'reasonForUseReference', TFhirReference(elem.reasonForUse), -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'MedicationStatement', 'effectiveDateTime', TFhirDateTime(elem.effective), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'MedicationStatement', 'effectivePeriod', TFhirPeriod(elem.effective), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MedicationStatement', 'note', elem.noteElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'MedicationStatement', 'supportingInformation', elem.supportingInformationList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationStatement', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationStatement', 'medicationReference', TFhirReference(elem.medication), -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeMedicationStatementDosage(this, 'MedicationStatement', 'dosage', elem.dosageList[i], i);
end;

function TFHIRXmlParser.ParseMessageHeaderResponse(element : IXmlDomElement; path : string) : TFhirMessageHeaderResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierElement := ParseId(child, path+'/identifier') {b}
      else if (child.baseName = 'code') then
        result.codeElement := ParseEnum(CODES_TFhirResponseCodeEnum, SYSTEMS_TFhirResponseCodeEnum, path+'/code', child){1a}
      else if (child.baseName = 'details') then
        result.details := ParseReference{TFhirOperationOutcome}(child, path+'/details') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderResponse(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderResponse);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'identifier', elem.identifierElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirResponseCodeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOperationOutcome}(xml, 'details', elem.details);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMessageHeaderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageHeaderResponse(jsn : TJsonObject) : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierElement := ParseId(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn['code'], jsn.vObj['_code'], CODES_TFhirResponseCodeEnum, SYSTEMS_TFhirResponseCodeEnum);
    if jsn.has('details') then
        result.details := ParseReference{TFhirOperationOutcome}(jsn.vObj['details']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderResponse(json : TJSONWriter; name : string; elem : TFhirMessageHeaderResponse; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdValue(json, 'identifier', elem.identifierElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdProps(json, 'identifier', elem.identifierElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirResponseCodeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirResponseCodeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOperationOutcome}(json, 'details', elem.details); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeMessageHeaderResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirMessageHeaderResponse; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MessageHeaderResponse');
  end;
  composeBackboneElement(this, 'MessageHeaderResponse', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'MessageHeaderResponse', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'MessageHeaderResponse', 'code', elem.CodeElement, CODES_TFhirResponseCodeEnum, SYSTEMS_TFhirResponseCodeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOperationOutcome}(this, 'MessageHeaderResponse', 'details', elem.detailsElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMessageHeaderSource(element : IXmlDomElement; path : string) : TFhirMessageHeaderSource;
var
  child : IXMLDOMElement;
begin
  result := TFhirMessageHeaderSource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'software') then
        result.softwareElement := ParseString(child, path+'/software') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'contact') then
        result.contact := ParseContactPoint(child, path+'/contact') {b}
      else if (child.baseName = 'endpoint') then
        result.endpointElement := ParseUri(child, path+'/endpoint') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderSource(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderSource);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'software', elem.softwareElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeContactPoint(xml, 'contact', elem.contact);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'endpoint', elem.endpointElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMessageHeaderSource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderSource(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageHeaderSource(jsn : TJsonObject) : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('software') or jsn.has('_software') then
        result.softwareElement := ParseString(jsn['software'], jsn.vObj['_software']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('contact') then
        result.contact := ParseContactPoint(jsn.vObj['contact']);{q}
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpointElement := ParseUri(jsn['endpoint'], jsn.vObj['_endpoint']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderSource(json : TJSONWriter; name : string; elem : TFhirMessageHeaderSource; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'software', elem.softwareElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'software', elem.softwareElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeContactPoint(json, 'contact', elem.contact); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'endpoint', elem.endpointElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'endpoint', elem.endpointElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeMessageHeaderSource(parent :  TRDFComplex; parentType, name : String; elem : TFhirMessageHeaderSource; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MessageHeaderSource');
  end;
  composeBackboneElement(this, 'MessageHeaderSource', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeaderSource', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeaderSource', 'software', elem.softwareElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeaderSource', 'version', elem.versionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeContactPoint(this, 'MessageHeaderSource', 'contact', elem.contactElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'MessageHeaderSource', 'endpoint', elem.endpointElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMessageHeaderDestination(element : IXmlDomElement; path : string) : TFhirMessageHeaderDestination;
var
  child : IXMLDOMElement;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirDevice}(child, path+'/target') {b}
      else if (child.baseName = 'endpoint') then
        result.endpointElement := ParseUri(child, path+'/endpoint') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderDestination(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderDestination);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(xml, 'target', elem.target);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'endpoint', elem.endpointElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMessageHeaderDestination(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderDestination(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageHeaderDestination(jsn : TJsonObject) : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirDevice}(jsn.vObj['target']);{q}
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpointElement := ParseUri(jsn['endpoint'], jsn.vObj['_endpoint']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderDestination(json : TJSONWriter; name : string; elem : TFhirMessageHeaderDestination; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(json, 'target', elem.target); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'endpoint', elem.endpointElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'endpoint', elem.endpointElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeMessageHeaderDestination(parent :  TRDFComplex; parentType, name : String; elem : TFhirMessageHeaderDestination; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MessageHeaderDestination');
  end;
  composeBackboneElement(this, 'MessageHeaderDestination', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeaderDestination', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(this, 'MessageHeaderDestination', 'target', elem.targetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'MessageHeaderDestination', 'endpoint', elem.endpointElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseMessageHeader(element : IXmlDomElement; path : string) : TFhirMessageHeader;
var
  child : IXMLDOMElement;
begin
  result := TFhirMessageHeader.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'timestamp') then
        result.timestampElement := ParseInstant(child, path+'/timestamp') {b}
      else if (child.baseName = 'event') then
        result.event := ParseCoding(child, path+'/event') {b}
      else if (child.baseName = 'response') then
        result.response := ParseMessageHeaderResponse(child, path+'/response') {b}
      else if (child.baseName = 'source') then
        result.source := ParseMessageHeaderSource(child, path+'/source') {b}
      else if (child.baseName = 'destination') then
        result.destinationList.Add(ParseMessageHeaderDestination(child, path+'/destination')){y.2}
      else if (child.baseName = 'enterer') then
        result.enterer := ParseReference{TFhirPractitioner}(child, path+'/enterer') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{TFhirPractitioner}(child, path+'/author') {b}
      else if (child.baseName = 'receiver') then
        result.receiver := ParseReference{Resource}(child, path+'/receiver') {b}
      else if (child.baseName = 'responsible') then
        result.responsible := ParseReference{Resource}(child, path+'/responsible') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.baseName = 'data') then
        result.dataList.Add(ParseReference{TFhirReference}(child, path+'/data')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMessageHeader(xml : TXmlBuilder; name : string; elem : TFhirMessageHeader);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'timestamp', elem.timestampElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'event', elem.event);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMessageHeaderResponse(xml, 'response', elem.response);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMessageHeaderSource(xml, 'source', elem.source);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.destinationList.Count - 1 do
      ComposeMessageHeaderDestination(xml, 'destination', elem.destinationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'enterer', elem.enterer);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'author', elem.author);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'receiver', elem.receiver);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'responsible', elem.responsible);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.dataList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'data', elem.dataList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMessageHeader(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeader(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageHeader(jsn : TJsonObject) : TFhirMessageHeader;
begin
  result := TFhirMessageHeader.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('timestamp') or jsn.has('_timestamp') then
        result.timestampElement := ParseInstant(jsn['timestamp'], jsn.vObj['_timestamp']);{q}
    if jsn.has('event') then
        result.event := ParseCoding(jsn.vObj['event']);{q}
    if jsn.has('response') then
        result.response := ParseMessageHeaderResponse(jsn.vObj['response']);{q}
    if jsn.has('source') then
        result.source := ParseMessageHeaderSource(jsn.vObj['source']);{q}
    if jsn.has('destination') then
      iterateArray(jsn.vArr['destination'], result.destinationList, parseMessageHeaderDestination);
    if jsn.has('enterer') then
        result.enterer := ParseReference{TFhirPractitioner}(jsn.vObj['enterer']);{q}
    if jsn.has('author') then
        result.author := ParseReference{TFhirPractitioner}(jsn.vObj['author']);{q}
    if jsn.has('receiver') then
        result.receiver := ParseReference{Resource}(jsn.vObj['receiver']);{q}
    if jsn.has('responsible') then
        result.responsible := ParseReference{Resource}(jsn.vObj['responsible']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    if jsn.has('data') then
      iterateArray(jsn.vArr['data'], result.dataList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMessageHeader(json : TJSONWriter; name : string; elem : TFhirMessageHeader; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantValue(json, 'timestamp', elem.timestampElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantProps(json, 'timestamp', elem.timestampElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'event', elem.event); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMessageHeaderResponse(json, 'response', elem.response); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMessageHeaderSource(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.destinationList.Count > 0) then
  begin
    json.valueArray('destination');
    for i := 0 to elem.destinationList.Count - 1 do
      ComposeMessageHeaderDestination(json, '', elem.destinationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'enterer', elem.enterer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'receiver', elem.receiver); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'responsible', elem.responsible); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dataList.Count > 0) then
  begin
    json.valueArray('data');
    for i := 0 to elem.dataList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.dataList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeMessageHeader(parent :  TRDFComplex; parentType, name : String; elem : TFhirMessageHeader; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:MessageHeader');
  end;
  composeDomainResource(this, 'MessageHeader', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'MessageHeader', 'timestamp', elem.timestampElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'MessageHeader', 'event', elem.eventElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMessageHeaderResponse(this, 'MessageHeader', 'response', elem.responseElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMessageHeaderSource(this, 'MessageHeader', 'source', elem.sourceElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.destinationList.Count - 1 do
      ComposeMessageHeaderDestination(this, 'MessageHeader', 'destination', elem.destinationList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'MessageHeader', 'enterer', elem.entererElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'MessageHeader', 'author', elem.authorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'MessageHeader', 'receiver', elem.receiverElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'MessageHeader', 'responsible', elem.responsibleElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MessageHeader', 'reason', elem.reasonElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.dataList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'MessageHeader', 'data', elem.dataList[i], i);
end;

function TFHIRXmlParser.ParseNamingSystemContact(element : IXmlDomElement; path : string) : TFhirNamingSystemContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirNamingSystemContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNamingSystemContact(xml : TXmlBuilder; name : string; elem : TFhirNamingSystemContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNamingSystemContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNamingSystemContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseNamingSystemContact(jsn : TJsonObject) : TFhirNamingSystemContact;
begin
  result := TFhirNamingSystemContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNamingSystemContact(json : TJSONWriter; name : string; elem : TFhirNamingSystemContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeNamingSystemContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirNamingSystemContact; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:NamingSystemContact');
  end;
  composeBackboneElement(this, 'NamingSystemContact', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NamingSystemContact', 'name', elem.nameElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'NamingSystemContact', 'telecom', elem.telecomList[i], i);
end;

function TFHIRXmlParser.ParseNamingSystemUniqueId(element : IXmlDomElement; path : string) : TFhirNamingSystemUniqueId;
var
  child : IXMLDOMElement;
begin
  result := TFhirNamingSystemUniqueId.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirNamingsystemIdentifierTypeEnum, SYSTEMS_TFhirNamingsystemIdentifierTypeEnum, path+'/type', child){1a}
      else if (child.baseName = 'value') then
        result.valueElement := ParseString(child, path+'/value') {b}
      else if (child.baseName = 'preferred') then
        result.preferredElement := ParseBoolean(child, path+'/preferred') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNamingSystemUniqueId(xml : TXmlBuilder; name : string; elem : TFhirNamingSystemUniqueId);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirNamingsystemIdentifierTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'value', elem.valueElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'preferred', elem.preferredElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNamingSystemUniqueId(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNamingSystemUniqueId(jsn)); {2}
end;

function TFHIRJsonParser.ParseNamingSystemUniqueId(jsn : TJsonObject) : TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirNamingsystemIdentifierTypeEnum, SYSTEMS_TFhirNamingsystemIdentifierTypeEnum);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    if jsn.has('preferred') or jsn.has('_preferred') then
        result.preferredElement := ParseBoolean(jsn['preferred'], jsn.vObj['_preferred']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNamingSystemUniqueId(json : TJSONWriter; name : string; elem : TFhirNamingSystemUniqueId; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirNamingsystemIdentifierTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirNamingsystemIdentifierTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'preferred', elem.preferredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'preferred', elem.preferredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeNamingSystemUniqueId(parent :  TRDFComplex; parentType, name : String; elem : TFhirNamingSystemUniqueId; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:NamingSystemUniqueId');
  end;
  composeBackboneElement(this, 'NamingSystemUniqueId', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'NamingSystemUniqueId', 'type', elem.Type_Element, CODES_TFhirNamingsystemIdentifierTypeEnum, SYSTEMS_TFhirNamingsystemIdentifierTypeEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NamingSystemUniqueId', 'value', elem.valueElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'NamingSystemUniqueId', 'preferred', elem.preferredElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'NamingSystemUniqueId', 'period', elem.periodElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseNamingSystem(element : IXmlDomElement; path : string) : TFhirNamingSystem;
var
  child : IXMLDOMElement;
begin
  result := TFhirNamingSystem.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'kind') then
        result.kindElement := ParseEnum(CODES_TFhirNamingsystemTypeEnum, SYSTEMS_TFhirNamingsystemTypeEnum, path+'/kind', child){1a}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseNamingSystemContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'responsible') then
        result.responsibleElement := ParseString(child, path+'/responsible') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'useContext') then
        result.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.baseName = 'usage') then
        result.usageElement := ParseString(child, path+'/usage') {b}
      else if (child.baseName = 'uniqueId') then
        result.uniqueIdList.Add(ParseNamingSystemUniqueId(child, path+'/uniqueId')){y.2}
      else if (child.baseName = 'replacedBy') then
        result.replacedBy := ParseReference{TFhirNamingSystem}(child, path+'/replacedBy') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNamingSystem(xml : TXmlBuilder; name : string; elem : TFhirNamingSystem);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirNamingsystemTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeNamingSystemContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'responsible', elem.responsibleElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'usage', elem.usageElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.uniqueIdList.Count - 1 do
      ComposeNamingSystemUniqueId(xml, 'uniqueId', elem.uniqueIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirNamingSystem}(xml, 'replacedBy', elem.replacedBy);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNamingSystem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNamingSystem(jsn)); {2}
end;

function TFHIRJsonParser.ParseNamingSystem(jsn : TJsonObject) : TFhirNamingSystem;
begin
  result := TFhirNamingSystem.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn['kind'], jsn.vObj['_kind'], CODES_TFhirNamingsystemTypeEnum, SYSTEMS_TFhirNamingsystemTypeEnum);
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseNamingSystemContact);
    if jsn.has('responsible') or jsn.has('_responsible') then
        result.responsibleElement := ParseString(jsn['responsible'], jsn.vObj['_responsible']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('usage') or jsn.has('_usage') then
        result.usageElement := ParseString(jsn['usage'], jsn.vObj['_usage']);{q}
    if jsn.has('uniqueId') then
      iterateArray(jsn.vArr['uniqueId'], result.uniqueIdList, parseNamingSystemUniqueId);
    if jsn.has('replacedBy') then
        result.replacedBy := ParseReference{TFhirNamingSystem}(jsn.vObj['replacedBy']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNamingSystem(json : TJSONWriter; name : string; elem : TFhirNamingSystem; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirNamingsystemTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirNamingsystemTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeNamingSystemContact(json, '', elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'responsible', elem.responsibleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'responsible', elem.responsibleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.useContextList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.uniqueIdList.Count > 0) then
  begin
    json.valueArray('uniqueId');
    for i := 0 to elem.uniqueIdList.Count - 1 do
      ComposeNamingSystemUniqueId(json, '', elem.uniqueIdList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirNamingSystem}(json, 'replacedBy', elem.replacedBy); {a}
end;

procedure TFHIRRDFComposer.ComposeNamingSystem(parent :  TRDFComplex; parentType, name : String; elem : TFhirNamingSystem; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:NamingSystem');
  end;
  composeDomainResource(this, 'NamingSystem', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NamingSystem', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'NamingSystem', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, -1);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'NamingSystem', 'kind', elem.KindElement, CODES_TFhirNamingsystemTypeEnum, SYSTEMS_TFhirNamingsystemTypeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NamingSystem', 'publisher', elem.publisherElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeNamingSystemContact(this, 'NamingSystem', 'contact', elem.contactList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NamingSystem', 'responsible', elem.responsibleElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'NamingSystem', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NamingSystem', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NamingSystem', 'description', elem.descriptionElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(this, 'NamingSystem', 'useContext', elem.useContextList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NamingSystem', 'usage', elem.usageElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.uniqueIdList.Count - 1 do
      ComposeNamingSystemUniqueId(this, 'NamingSystem', 'uniqueId', elem.uniqueIdList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirNamingSystem}(this, 'NamingSystem', 'replacedBy', elem.replacedByElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseNutritionOrderOralDiet(element : IXmlDomElement; path : string) : TFhirNutritionOrderOralDiet;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrderOralDiet.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.baseName = 'schedule') then
        result.scheduleList.Add(ParseTiming(child, path+'/schedule')){y.2}
      else if (child.baseName = 'nutrient') then
        result.nutrientList.Add(ParseNutritionOrderOralDietNutrient(child, path+'/nutrient')){y.2}
      else if (child.baseName = 'texture') then
        result.textureList.Add(ParseNutritionOrderOralDietTexture(child, path+'/texture')){y.2}
      else if (child.baseName = 'fluidConsistencyType') then
        result.fluidConsistencyTypeList.Add(ParseCodeableConcept(child, path+'/fluidConsistencyType')){y.2}
      else if (child.baseName = 'instruction') then
        result.instructionElement := ParseString(child, path+'/instruction') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDiet(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDiet);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(xml, 'schedule', elem.scheduleList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.nutrientList.Count - 1 do
      ComposeNutritionOrderOralDietNutrient(xml, 'nutrient', elem.nutrientList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.textureList.Count - 1 do
      ComposeNutritionOrderOralDietTexture(xml, 'texture', elem.textureList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.fluidConsistencyTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'fluidConsistencyType', elem.fluidConsistencyTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'instruction', elem.instructionElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrderOralDiet(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderOralDiet(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderOralDiet(jsn : TJsonObject) : TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('schedule') then
      iterateArray(jsn.vArr['schedule'], result.scheduleList, parseTiming);
    if jsn.has('nutrient') then
      iterateArray(jsn.vArr['nutrient'], result.nutrientList, parseNutritionOrderOralDietNutrient);
    if jsn.has('texture') then
      iterateArray(jsn.vArr['texture'], result.textureList, parseNutritionOrderOralDietTexture);
    if jsn.has('fluidConsistencyType') then
      iterateArray(jsn.vArr['fluidConsistencyType'], result.fluidConsistencyTypeList, parseCodeableConcept);
    if jsn.has('instruction') or jsn.has('_instruction') then
        result.instructionElement := ParseString(jsn['instruction'], jsn.vObj['_instruction']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderOralDiet(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDiet; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.scheduleList.Count > 0) then
  begin
    json.valueArray('schedule');
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(json, '', elem.scheduleList[i]); {z - Timing}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.nutrientList.Count > 0) then
  begin
    json.valueArray('nutrient');
    for i := 0 to elem.nutrientList.Count - 1 do
      ComposeNutritionOrderOralDietNutrient(json, '', elem.nutrientList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.textureList.Count > 0) then
  begin
    json.valueArray('texture');
    for i := 0 to elem.textureList.Count - 1 do
      ComposeNutritionOrderOralDietTexture(json, '', elem.textureList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.fluidConsistencyTypeList.Count > 0) then
  begin
    json.valueArray('fluidConsistencyType');
    for i := 0 to elem.fluidConsistencyTypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.fluidConsistencyTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'instruction', elem.instructionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'instruction', elem.instructionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeNutritionOrderOralDiet(parent :  TRDFComplex; parentType, name : String; elem : TFhirNutritionOrderOralDiet; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:NutritionOrderOralDiet');
  end;
  composeBackboneElement(this, 'NutritionOrderOralDiet', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrderOralDiet', 'type', elem.type_List[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(this, 'NutritionOrderOralDiet', 'schedule', elem.scheduleList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.nutrientList.Count - 1 do
      ComposeNutritionOrderOralDietNutrient(this, 'NutritionOrderOralDiet', 'nutrient', elem.nutrientList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.textureList.Count - 1 do
      ComposeNutritionOrderOralDietTexture(this, 'NutritionOrderOralDiet', 'texture', elem.textureList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.fluidConsistencyTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrderOralDiet', 'fluidConsistencyType', elem.fluidConsistencyTypeList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NutritionOrderOralDiet', 'instruction', elem.instructionElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietNutrient(element : IXmlDomElement; path : string) : TFhirNutritionOrderOralDietNutrient;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'modifier') then
        result.modifier := ParseCodeableConcept(child, path+'/modifier') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietNutrient(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDietNutrient);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'modifier', elem.modifier);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrderOralDietNutrient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderOralDietNutrient(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderOralDietNutrient(jsn : TJsonObject) : TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('modifier') then
        result.modifier := ParseCodeableConcept(jsn.vObj['modifier']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderOralDietNutrient(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDietNutrient; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'modifier', elem.modifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeNutritionOrderOralDietNutrient(parent :  TRDFComplex; parentType, name : String; elem : TFhirNutritionOrderOralDietNutrient; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:NutritionOrderOralDietNutrient');
  end;
  composeBackboneElement(this, 'NutritionOrderOralDietNutrient', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrderOralDietNutrient', 'modifier', elem.modifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrderOralDietNutrient', 'amount', elem.amountElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietTexture(element : IXmlDomElement; path : string) : TFhirNutritionOrderOralDietTexture;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'modifier') then
        result.modifier := ParseCodeableConcept(child, path+'/modifier') {b}
      else if (child.baseName = 'foodType') then
        result.foodType := ParseCodeableConcept(child, path+'/foodType') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietTexture(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDietTexture);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'modifier', elem.modifier);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'foodType', elem.foodType);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrderOralDietTexture(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderOralDietTexture(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderOralDietTexture(jsn : TJsonObject) : TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('modifier') then
        result.modifier := ParseCodeableConcept(jsn.vObj['modifier']);{q}
    if jsn.has('foodType') then
        result.foodType := ParseCodeableConcept(jsn.vObj['foodType']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderOralDietTexture(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDietTexture; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'modifier', elem.modifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'foodType', elem.foodType); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeNutritionOrderOralDietTexture(parent :  TRDFComplex; parentType, name : String; elem : TFhirNutritionOrderOralDietTexture; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:NutritionOrderOralDietTexture');
  end;
  composeBackboneElement(this, 'NutritionOrderOralDietTexture', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrderOralDietTexture', 'modifier', elem.modifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrderOralDietTexture', 'foodType', elem.foodTypeElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseNutritionOrderSupplement(element : IXmlDomElement; path : string) : TFhirNutritionOrderSupplement;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrderSupplement.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'productName') then
        result.productNameElement := ParseString(child, path+'/productName') {b}
      else if (child.baseName = 'schedule') then
        result.scheduleList.Add(ParseTiming(child, path+'/schedule')){y.2}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'instruction') then
        result.instructionElement := ParseString(child, path+'/instruction') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderSupplement(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderSupplement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'productName', elem.productNameElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(xml, 'schedule', elem.scheduleList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'instruction', elem.instructionElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrderSupplement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderSupplement(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderSupplement(jsn : TJsonObject) : TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('productName') or jsn.has('_productName') then
        result.productNameElement := ParseString(jsn['productName'], jsn.vObj['_productName']);{q}
    if jsn.has('schedule') then
      iterateArray(jsn.vArr['schedule'], result.scheduleList, parseTiming);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('instruction') or jsn.has('_instruction') then
        result.instructionElement := ParseString(jsn['instruction'], jsn.vObj['_instruction']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderSupplement(json : TJSONWriter; name : string; elem : TFhirNutritionOrderSupplement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'productName', elem.productNameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'productName', elem.productNameElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.scheduleList.Count > 0) then
  begin
    json.valueArray('schedule');
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(json, '', elem.scheduleList[i]); {z - Timing}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'instruction', elem.instructionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'instruction', elem.instructionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeNutritionOrderSupplement(parent :  TRDFComplex; parentType, name : String; elem : TFhirNutritionOrderSupplement; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:NutritionOrderSupplement');
  end;
  composeBackboneElement(this, 'NutritionOrderSupplement', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrderSupplement', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NutritionOrderSupplement', 'productName', elem.productNameElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(this, 'NutritionOrderSupplement', 'schedule', elem.scheduleList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrderSupplement', 'quantity', elem.quantityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NutritionOrderSupplement', 'instruction', elem.instructionElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormula(element : IXmlDomElement; path : string) : TFhirNutritionOrderEnteralFormula;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'baseFormulaType') then
        result.baseFormulaType := ParseCodeableConcept(child, path+'/baseFormulaType') {b}
      else if (child.baseName = 'baseFormulaProductName') then
        result.baseFormulaProductNameElement := ParseString(child, path+'/baseFormulaProductName') {b}
      else if (child.baseName = 'additiveType') then
        result.additiveType := ParseCodeableConcept(child, path+'/additiveType') {b}
      else if (child.baseName = 'additiveProductName') then
        result.additiveProductNameElement := ParseString(child, path+'/additiveProductName') {b}
      else if (child.baseName = 'caloricDensity') then
        result.caloricDensity := ParseQuantity(child, path+'/caloricDensity') {b}
      else if (child.baseName = 'routeofAdministration') then
        result.routeofAdministration := ParseCodeableConcept(child, path+'/routeofAdministration') {b}
      else if (child.baseName = 'administration') then
        result.administrationList.Add(ParseNutritionOrderEnteralFormulaAdministration(child, path+'/administration')){y.2}
      else if (child.baseName = 'maxVolumeToDeliver') then
        result.maxVolumeToDeliver := ParseQuantity(child, path+'/maxVolumeToDeliver') {b}
      else if (child.baseName = 'administrationInstruction') then
        result.administrationInstructionElement := ParseString(child, path+'/administrationInstruction') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormula(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderEnteralFormula);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'baseFormulaType', elem.baseFormulaType);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'baseFormulaProductName', elem.baseFormulaProductNameElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'additiveType', elem.additiveType);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'additiveProductName', elem.additiveProductNameElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'caloricDensity', elem.caloricDensity);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'routeofAdministration', elem.routeofAdministration);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.administrationList.Count - 1 do
      ComposeNutritionOrderEnteralFormulaAdministration(xml, 'administration', elem.administrationList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'maxVolumeToDeliver', elem.maxVolumeToDeliver);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'administrationInstruction', elem.administrationInstructionElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrderEnteralFormula(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderEnteralFormula(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderEnteralFormula(jsn : TJsonObject) : TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('baseFormulaType') then
        result.baseFormulaType := ParseCodeableConcept(jsn.vObj['baseFormulaType']);{q}
    if jsn.has('baseFormulaProductName') or jsn.has('_baseFormulaProductName') then
        result.baseFormulaProductNameElement := ParseString(jsn['baseFormulaProductName'], jsn.vObj['_baseFormulaProductName']);{q}
    if jsn.has('additiveType') then
        result.additiveType := ParseCodeableConcept(jsn.vObj['additiveType']);{q}
    if jsn.has('additiveProductName') or jsn.has('_additiveProductName') then
        result.additiveProductNameElement := ParseString(jsn['additiveProductName'], jsn.vObj['_additiveProductName']);{q}
    if jsn.has('caloricDensity') then
        result.caloricDensity := ParseQuantity(jsn.vObj['caloricDensity']);{q}
    if jsn.has('routeofAdministration') then
        result.routeofAdministration := ParseCodeableConcept(jsn.vObj['routeofAdministration']);{q}
    if jsn.has('administration') then
      iterateArray(jsn.vArr['administration'], result.administrationList, parseNutritionOrderEnteralFormulaAdministration);
    if jsn.has('maxVolumeToDeliver') then
        result.maxVolumeToDeliver := ParseQuantity(jsn.vObj['maxVolumeToDeliver']);{q}
    if jsn.has('administrationInstruction') or jsn.has('_administrationInstruction') then
        result.administrationInstructionElement := ParseString(jsn['administrationInstruction'], jsn.vObj['_administrationInstruction']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderEnteralFormula(json : TJSONWriter; name : string; elem : TFhirNutritionOrderEnteralFormula; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'baseFormulaType', elem.baseFormulaType); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'baseFormulaProductName', elem.baseFormulaProductNameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'baseFormulaProductName', elem.baseFormulaProductNameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'additiveType', elem.additiveType); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'additiveProductName', elem.additiveProductNameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'additiveProductName', elem.additiveProductNameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'caloricDensity', elem.caloricDensity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'routeofAdministration', elem.routeofAdministration); {a}
  if (SummaryOption in [soFull, soData]) and (elem.administrationList.Count > 0) then
  begin
    json.valueArray('administration');
    for i := 0 to elem.administrationList.Count - 1 do
      ComposeNutritionOrderEnteralFormulaAdministration(json, '', elem.administrationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'maxVolumeToDeliver', elem.maxVolumeToDeliver); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'administrationInstruction', elem.administrationInstructionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'administrationInstruction', elem.administrationInstructionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeNutritionOrderEnteralFormula(parent :  TRDFComplex; parentType, name : String; elem : TFhirNutritionOrderEnteralFormula; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:NutritionOrderEnteralFormula');
  end;
  composeBackboneElement(this, 'NutritionOrderEnteralFormula', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrderEnteralFormula', 'baseFormulaType', elem.baseFormulaTypeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NutritionOrderEnteralFormula', 'baseFormulaProductName', elem.baseFormulaProductNameElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrderEnteralFormula', 'additiveType', elem.additiveTypeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NutritionOrderEnteralFormula', 'additiveProductName', elem.additiveProductNameElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrderEnteralFormula', 'caloricDensity', elem.caloricDensityElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrderEnteralFormula', 'routeofAdministration', elem.routeofAdministrationElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.administrationList.Count - 1 do
      ComposeNutritionOrderEnteralFormulaAdministration(this, 'NutritionOrderEnteralFormula', 'administration', elem.administrationList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrderEnteralFormula', 'maxVolumeToDeliver', elem.maxVolumeToDeliverElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NutritionOrderEnteralFormula', 'administrationInstruction', elem.administrationInstructionElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormulaAdministration(element : IXmlDomElement; path : string) : TFhirNutritionOrderEnteralFormulaAdministration;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'schedule') then
        result.schedule := ParseTiming(child, path+'/schedule') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'rateQuantity') then
        result.rate := ParseQuantity(child, path+'/rateQuantity'){x.3}
      else if (child.baseName = 'rateRatio') then
        result.rate := ParseRatio(child, path+'/rateRatio'){x.3}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormulaAdministration(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderEnteralFormulaAdministration);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTiming(xml, 'schedule', elem.schedule);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'rateQuantity', TFhirQuantity(elem.rate))
  else if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(xml, 'rateRatio', TFhirRatio(elem.rate));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrderEnteralFormulaAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderEnteralFormulaAdministration(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderEnteralFormulaAdministration(jsn : TJsonObject) : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('schedule') then
        result.schedule := ParseTiming(jsn.vObj['schedule']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('rateQuantity') {a4} then
      result.rate := ParseQuantity(jsn.vObj['rateQuantity']);
    if jsn.has('rateRatio') {a4} then
      result.rate := ParseRatio(jsn.vObj['rateRatio']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderEnteralFormulaAdministration(json : TJSONWriter; name : string; elem : TFhirNutritionOrderEnteralFormulaAdministration; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTiming(json, 'schedule', elem.schedule); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirQuantity) then 
    ComposeQuantity(json, 'rateQuantity', TFhirQuantity(elem.rate)) 
  else if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirRatio) then 
    ComposeRatio(json, 'rateRatio', TFhirRatio(elem.rate)) ;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeNutritionOrderEnteralFormulaAdministration(parent :  TRDFComplex; parentType, name : String; elem : TFhirNutritionOrderEnteralFormulaAdministration; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:NutritionOrderEnteralFormulaAdministration');
  end;
  composeBackboneElement(this, 'NutritionOrderEnteralFormulaAdministration', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTiming(this, 'NutritionOrderEnteralFormulaAdministration', 'schedule', elem.scheduleElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrderEnteralFormulaAdministration', 'quantity', elem.quantityElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirQuantity) {6} then
    ComposeQuantity(this, 'NutritionOrderEnteralFormulaAdministration', 'rateQuantity', TFhirQuantity(elem.rate), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'NutritionOrderEnteralFormulaAdministration', 'rateRatio', TFhirRatio(elem.rate), -1);
end;

function TFHIRXmlParser.ParseNutritionOrder(element : IXmlDomElement; path : string) : TFhirNutritionOrder;
var
  child : IXMLDOMElement;
begin
  result := TFhirNutritionOrder.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'orderer') then
        result.orderer := ParseReference{TFhirPractitioner}(child, path+'/orderer') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'dateTime') then
        result.dateTimeElement := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirNutritionOrderStatusEnum, SYSTEMS_TFhirNutritionOrderStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'allergyIntolerance') then
        result.allergyIntoleranceList.Add(ParseReference{TFhirAllergyIntolerance}(child, path+'/allergyIntolerance')){y.2}
      else if (child.baseName = 'foodPreferenceModifier') then
        result.foodPreferenceModifierList.Add(ParseCodeableConcept(child, path+'/foodPreferenceModifier')){y.2}
      else if (child.baseName = 'excludeFoodModifier') then
        result.excludeFoodModifierList.Add(ParseCodeableConcept(child, path+'/excludeFoodModifier')){y.2}
      else if (child.baseName = 'oralDiet') then
        result.oralDiet := ParseNutritionOrderOralDiet(child, path+'/oralDiet') {b}
      else if (child.baseName = 'supplement') then
        result.supplementList.Add(ParseNutritionOrderSupplement(child, path+'/supplement')){y.2}
      else if (child.baseName = 'enteralFormula') then
        result.enteralFormula := ParseNutritionOrderEnteralFormula(child, path+'/enteralFormula') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrder(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrder);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'orderer', elem.orderer);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'dateTime', elem.dateTimeElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirNutritionOrderStatusEnum);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.allergyIntoleranceList.Count - 1 do
      ComposeReference{TFhirAllergyIntolerance}(xml, 'allergyIntolerance', elem.allergyIntoleranceList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.foodPreferenceModifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'foodPreferenceModifier', elem.foodPreferenceModifierList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.excludeFoodModifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'excludeFoodModifier', elem.excludeFoodModifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeNutritionOrderOralDiet(xml, 'oralDiet', elem.oralDiet);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.supplementList.Count - 1 do
      ComposeNutritionOrderSupplement(xml, 'supplement', elem.supplementList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeNutritionOrderEnteralFormula(xml, 'enteralFormula', elem.enteralFormula);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNutritionOrder(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrder(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrder(jsn : TJsonObject) : TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('orderer') then
        result.orderer := ParseReference{TFhirPractitioner}(jsn.vObj['orderer']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeElement := ParseDateTime(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirNutritionOrderStatusEnum, SYSTEMS_TFhirNutritionOrderStatusEnum);
    if jsn.has('allergyIntolerance') then
      iterateArray(jsn.vArr['allergyIntolerance'], result.allergyIntoleranceList, parseReference{TFhirAllergyIntolerance});
    if jsn.has('foodPreferenceModifier') then
      iterateArray(jsn.vArr['foodPreferenceModifier'], result.foodPreferenceModifierList, parseCodeableConcept);
    if jsn.has('excludeFoodModifier') then
      iterateArray(jsn.vArr['excludeFoodModifier'], result.excludeFoodModifierList, parseCodeableConcept);
    if jsn.has('oralDiet') then
        result.oralDiet := ParseNutritionOrderOralDiet(jsn.vObj['oralDiet']);{q}
    if jsn.has('supplement') then
      iterateArray(jsn.vArr['supplement'], result.supplementList, parseNutritionOrderSupplement);
    if jsn.has('enteralFormula') then
        result.enteralFormula := ParseNutritionOrderEnteralFormula(jsn.vObj['enteralFormula']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNutritionOrder(json : TJSONWriter; name : string; elem : TFhirNutritionOrder; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'orderer', elem.orderer); {a}
  if (SummaryOption in [soFull, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'dateTime', elem.dateTimeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'dateTime', elem.dateTimeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirNutritionOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirNutritionOrderStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.allergyIntoleranceList.Count > 0) then
  begin
    json.valueArray('allergyIntolerance');
    for i := 0 to elem.allergyIntoleranceList.Count - 1 do
      ComposeReference{TFhirAllergyIntolerance}(json, '', elem.allergyIntoleranceList[i]); {z - Reference(AllergyIntolerance)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.foodPreferenceModifierList.Count > 0) then
  begin
    json.valueArray('foodPreferenceModifier');
    for i := 0 to elem.foodPreferenceModifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.foodPreferenceModifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.excludeFoodModifierList.Count > 0) then
  begin
    json.valueArray('excludeFoodModifier');
    for i := 0 to elem.excludeFoodModifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.excludeFoodModifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeNutritionOrderOralDiet(json, 'oralDiet', elem.oralDiet); {a}
  if (SummaryOption in [soFull, soData]) and (elem.supplementList.Count > 0) then
  begin
    json.valueArray('supplement');
    for i := 0 to elem.supplementList.Count - 1 do
      ComposeNutritionOrderSupplement(json, '', elem.supplementList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeNutritionOrderEnteralFormula(json, 'enteralFormula', elem.enteralFormula); {a}
end;

procedure TFHIRRDFComposer.ComposeNutritionOrder(parent :  TRDFComplex; parentType, name : String; elem : TFhirNutritionOrder; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:NutritionOrder');
  end;
  composeDomainResource(this, 'NutritionOrder', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'NutritionOrder', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'NutritionOrder', 'orderer', elem.ordererElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'NutritionOrder', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(this, 'NutritionOrder', 'encounter', elem.encounterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'NutritionOrder', 'dateTime', elem.dateTimeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'NutritionOrder', 'status', elem.StatusElement, CODES_TFhirNutritionOrderStatusEnum, SYSTEMS_TFhirNutritionOrderStatusEnum, -1);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.allergyIntoleranceList.Count - 1 do
      ComposeReference{TFhirAllergyIntolerance}(this, 'NutritionOrder', 'allergyIntolerance', elem.allergyIntoleranceList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.foodPreferenceModifierList.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder', 'foodPreferenceModifier', elem.foodPreferenceModifierList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.excludeFoodModifierList.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder', 'excludeFoodModifier', elem.excludeFoodModifierList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeNutritionOrderOralDiet(this, 'NutritionOrder', 'oralDiet', elem.oralDietElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.supplementList.Count - 1 do
      ComposeNutritionOrderSupplement(this, 'NutritionOrder', 'supplement', elem.supplementList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeNutritionOrderEnteralFormula(this, 'NutritionOrder', 'enteralFormula', elem.enteralFormulaElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseObservationReferenceRange(element : IXmlDomElement; path : string) : TFhirObservationReferenceRange;
var
  child : IXMLDOMElement;
begin
  result := TFhirObservationReferenceRange.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'low') then
        result.low := ParseQuantity(child, path+'/low') {b}
      else if (child.baseName = 'high') then
        result.high := ParseQuantity(child, path+'/high') {b}
      else if (child.baseName = 'meaning') then
        result.meaning := ParseCodeableConcept(child, path+'/meaning') {b}
      else if (child.baseName = 'age') then
        result.age := ParseRange(child, path+'/age') {b}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeObservationReferenceRange(xml : TXmlBuilder; name : string; elem : TFhirObservationReferenceRange);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'low', elem.low);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'high', elem.high);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'meaning', elem.meaning);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(xml, 'age', elem.age);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseObservationReferenceRange(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservationReferenceRange(jsn)); {2}
end;

function TFHIRJsonParser.ParseObservationReferenceRange(jsn : TJsonObject) : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('low') then
        result.low := ParseQuantity(jsn.vObj['low']);{q}
    if jsn.has('high') then
        result.high := ParseQuantity(jsn.vObj['high']);{q}
    if jsn.has('meaning') then
        result.meaning := ParseCodeableConcept(jsn.vObj['meaning']);{q}
    if jsn.has('age') then
        result.age := ParseRange(jsn.vObj['age']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeObservationReferenceRange(json : TJSONWriter; name : string; elem : TFhirObservationReferenceRange; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'low', elem.low); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'high', elem.high); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'meaning', elem.meaning); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(json, 'age', elem.age); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeObservationReferenceRange(parent :  TRDFComplex; parentType, name : String; elem : TFhirObservationReferenceRange; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ObservationReferenceRange');
  end;
  composeBackboneElement(this, 'ObservationReferenceRange', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ObservationReferenceRange', 'low', elem.lowElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ObservationReferenceRange', 'high', elem.highElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ObservationReferenceRange', 'meaning', elem.meaningElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(this, 'ObservationReferenceRange', 'age', elem.ageElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ObservationReferenceRange', 'text', elem.textElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseObservationRelated(element : IXmlDomElement; path : string) : TFhirObservationRelated;
var
  child : IXMLDOMElement;
begin
  result := TFhirObservationRelated.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirObservationRelationshiptypesEnum, SYSTEMS_TFhirObservationRelationshiptypesEnum, path+'/type', child){1a}
      else if (child.baseName = 'target') then
        result.target := ParseReference{Resource}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeObservationRelated(xml : TXmlBuilder; name : string; elem : TFhirObservationRelated);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirObservationRelationshiptypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'target', elem.target);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseObservationRelated(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservationRelated(jsn)); {2}
end;

function TFHIRJsonParser.ParseObservationRelated(jsn : TJsonObject) : TFhirObservationRelated;
begin
  result := TFhirObservationRelated.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirObservationRelationshiptypesEnum, SYSTEMS_TFhirObservationRelationshiptypesEnum);
    if jsn.has('target') then
        result.target := ParseReference{Resource}(jsn.vObj['target']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeObservationRelated(json : TJSONWriter; name : string; elem : TFhirObservationRelated; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirObservationRelationshiptypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirObservationRelationshiptypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(json, 'target', elem.target); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeObservationRelated(parent :  TRDFComplex; parentType, name : String; elem : TFhirObservationRelated; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ObservationRelated');
  end;
  composeBackboneElement(this, 'ObservationRelated', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'ObservationRelated', 'type', elem.Type_Element, CODES_TFhirObservationRelationshiptypesEnum, SYSTEMS_TFhirObservationRelationshiptypesEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'ObservationRelated', 'target', elem.targetElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseObservationComponent(element : IXmlDomElement; path : string) : TFhirObservationComponent;
var
  child : IXMLDOMElement;
begin
  result := TFhirObservationComponent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.baseName = 'valueRange') then
        result.value := ParseRange(child, path+'/valueRange'){x.3}
      else if (child.baseName = 'valueRatio') then
        result.value := ParseRatio(child, path+'/valueRatio'){x.3}
      else if (child.baseName = 'valueSampledData') then
        result.value := ParseSampledData(child, path+'/valueSampledData'){x.3}
      else if (child.baseName = 'valueAttachment') then
        result.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.baseName = 'valueTime') then
        result.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.baseName = 'valueDateTime') then
        result.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.baseName = 'valuePeriod') then
        result.value := ParsePeriod(child, path+'/valuePeriod'){x.3}
      else if (child.baseName = 'dataAbsentReason') then
        result.dataAbsentReason := ParseCodeableConcept(child, path+'/dataAbsentReason') {b}
      else if (child.baseName = 'referenceRange') then
        result.referenceRangeList.Add(ParseObservationReferenceRange(child, path+'/referenceRange')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeObservationComponent(xml : TXmlBuilder; name : string; elem : TFhirObservationComponent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'dataAbsentReason', elem.dataAbsentReason);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(xml, 'referenceRange', elem.referenceRangeList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseObservationComponent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservationComponent(jsn)); {2}
end;

function TFHIRJsonParser.ParseObservationComponent(jsn : TJsonObject) : TFhirObservationComponent;
begin
  result := TFhirObservationComponent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueRatio') {a4} then
      result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueSampledData') {a4} then
      result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valuePeriod') {a4} then
      result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('dataAbsentReason') then
        result.dataAbsentReason := ParseCodeableConcept(jsn.vObj['dataAbsentReason']);{q}
    if jsn.has('referenceRange') then
      iterateArray(jsn.vArr['referenceRange'], result.referenceRangeList, parseObservationReferenceRange);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeObservationComponent(json : TJSONWriter; name : string; elem : TFhirObservationComponent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) then 
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) then 
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) then 
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value)) ;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'dataAbsentReason', elem.dataAbsentReason); {a}
  if (SummaryOption in [soFull, soData]) and (elem.referenceRangeList.Count > 0) then
  begin
    json.valueArray('referenceRange');
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(json, '', elem.referenceRangeList[i]); {z - @Observation.referenceRange}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeObservationComponent(parent :  TRDFComplex; parentType, name : String; elem : TFhirObservationComponent; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ObservationComponent');
  end;
  composeBackboneElement(this, 'ObservationComponent', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ObservationComponent', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ObservationComponent', 'valueQuantity', TFhirQuantity(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ObservationComponent', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'ObservationComponent', 'valueString', TFhirString(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'ObservationComponent', 'valueRange', TFhirRange(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'ObservationComponent', 'valueRatio', TFhirRatio(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'ObservationComponent', 'valueSampledData', TFhirSampledData(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ObservationComponent', 'valueAttachment', TFhirAttachment(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'ObservationComponent', 'valueTime', TFhirTime(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ObservationComponent', 'valueDateTime', TFhirDateTime(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'ObservationComponent', 'valuePeriod', TFhirPeriod(elem.value), -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ObservationComponent', 'dataAbsentReason', elem.dataAbsentReasonElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(this, 'ObservationComponent', 'referenceRange', elem.referenceRangeList[i], i);
end;

function TFHIRXmlParser.ParseObservation(element : IXmlDomElement; path : string) : TFhirObservation;
var
  child : IXMLDOMElement;
begin
  result := TFhirObservation.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'effectiveDateTime') then
        result.effective := ParseDateTime(child, path+'/effectiveDateTime'){x.3}
      else if (child.baseName = 'effectivePeriod') then
        result.effective := ParsePeriod(child, path+'/effectivePeriod'){x.3}
      else if (child.baseName = 'issued') then
        result.issuedElement := ParseInstant(child, path+'/issued') {b}
      else if (child.baseName = 'performer') then
        result.performerList.Add(ParseReference{Resource}(child, path+'/performer')){y.2}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.baseName = 'valueRange') then
        result.value := ParseRange(child, path+'/valueRange'){x.3}
      else if (child.baseName = 'valueRatio') then
        result.value := ParseRatio(child, path+'/valueRatio'){x.3}
      else if (child.baseName = 'valueSampledData') then
        result.value := ParseSampledData(child, path+'/valueSampledData'){x.3}
      else if (child.baseName = 'valueAttachment') then
        result.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.baseName = 'valueTime') then
        result.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.baseName = 'valueDateTime') then
        result.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.baseName = 'valuePeriod') then
        result.value := ParsePeriod(child, path+'/valuePeriod'){x.3}
      else if (child.baseName = 'dataAbsentReason') then
        result.dataAbsentReason := ParseCodeableConcept(child, path+'/dataAbsentReason') {b}
      else if (child.baseName = 'interpretation') then
        result.interpretation := ParseCodeableConcept(child, path+'/interpretation') {b}
      else if (child.baseName = 'comments') then
        result.commentsElement := ParseString(child, path+'/comments') {b}
      else if (child.baseName = 'bodySite') then
        result.bodySite := ParseCodeableConcept(child, path+'/bodySite') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'specimen') then
        result.specimen := ParseReference{TFhirSpecimen}(child, path+'/specimen') {b}
      else if (child.baseName = 'device') then
        result.device := ParseReference{Resource}(child, path+'/device') {b}
      else if (child.baseName = 'referenceRange') then
        result.referenceRangeList.Add(ParseObservationReferenceRange(child, path+'/referenceRange')){y.2}
      else if (child.baseName = 'related') then
        result.relatedList.Add(ParseObservationRelated(child, path+'/related')){y.2}
      else if (child.baseName = 'component') then
        result.componentList.Add(ParseObservationComponent(child, path+'/component')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeObservation(xml : TXmlBuilder; name : string; elem : TFhirObservation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveDateTime', TFhirDateTime(elem.effective))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectivePeriod', TFhirPeriod(elem.effective));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'issued', elem.issuedElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(xml, 'performer', elem.performerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'dataAbsentReason', elem.dataAbsentReason);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'interpretation', elem.interpretation);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comments', elem.commentsElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'bodySite', elem.bodySite);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimen);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'device', elem.device);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(xml, 'referenceRange', elem.referenceRangeList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeObservationRelated(xml, 'related', elem.relatedList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.componentList.Count - 1 do
      ComposeObservationComponent(xml, 'component', elem.componentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseObservation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservation(jsn)); {2}
end;

function TFHIRJsonParser.ParseObservation(jsn : TJsonObject) : TFhirObservation;
begin
  result := TFhirObservation.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('effectiveDateTime') or jsn.has('_effectiveDateTime') then
      result.effective := parseDateTime(jsn['effectiveDateTime'], jsn.vObj['_effectiveDateTime']);
    if jsn.has('effectivePeriod') {a4} then
      result.effective := ParsePeriod(jsn.vObj['effectivePeriod']);
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := ParseInstant(jsn['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseReference{Resource});
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueRatio') {a4} then
      result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueSampledData') {a4} then
      result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valuePeriod') {a4} then
      result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('dataAbsentReason') then
        result.dataAbsentReason := ParseCodeableConcept(jsn.vObj['dataAbsentReason']);{q}
    if jsn.has('interpretation') then
        result.interpretation := ParseCodeableConcept(jsn.vObj['interpretation']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsElement := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('specimen') then
        result.specimen := ParseReference{TFhirSpecimen}(jsn.vObj['specimen']);{q}
    if jsn.has('device') then
        result.device := ParseReference{Resource}(jsn.vObj['device']);{q}
    if jsn.has('referenceRange') then
      iterateArray(jsn.vArr['referenceRange'], result.referenceRangeList, parseObservationReferenceRange);
    if jsn.has('related') then
      iterateArray(jsn.vArr['related'], result.relatedList, parseObservationRelated);
    if jsn.has('component') then
      iterateArray(jsn.vArr['component'], result.componentList, parseObservationComponent);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeObservation(json : TJSONWriter; name : string; elem : TFhirObservation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
    ComposeDateTimeProps(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) then 
    ComposePeriod(json, 'effectivePeriod', TFhirPeriod(elem.effective)) ;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantValue(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantProps(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.performerList.Count > 0) then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.performerList[i]); {z - Reference(Practitioner|Organization|Patient|RelatedPerson)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) then 
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) then 
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) then 
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value)) ;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'dataAbsentReason', elem.dataAbsentReason); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'interpretation', elem.interpretation); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comments', elem.commentsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comments', elem.commentsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirSpecimen}(json, 'specimen', elem.specimen); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(json, 'device', elem.device); {a}
  if (SummaryOption in [soFull, soData]) and (elem.referenceRangeList.Count > 0) then
  begin
    json.valueArray('referenceRange');
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(json, '', elem.referenceRangeList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.relatedList.Count > 0) then
  begin
    json.valueArray('related');
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeObservationRelated(json, '', elem.relatedList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.componentList.Count > 0) then
  begin
    json.valueArray('component');
    for i := 0 to elem.componentList.Count - 1 do
      ComposeObservationComponent(json, '', elem.componentList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeObservation(parent :  TRDFComplex; parentType, name : String; elem : TFhirObservation; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Observation');
  end;
  composeDomainResource(this, 'Observation', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Observation', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Observation', 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation', 'category', elem.categoryElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Observation', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Observation', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(this, 'Observation', 'encounter', elem.encounterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Observation', 'effectiveDateTime', TFhirDateTime(elem.effective), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'Observation', 'effectivePeriod', TFhirPeriod(elem.effective), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'Observation', 'issued', elem.issuedElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(this, 'Observation', 'performer', elem.performerList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Observation', 'valueQuantity', TFhirQuantity(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Observation', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'Observation', 'valueString', TFhirString(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Observation', 'valueRange', TFhirRange(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Observation', 'valueRatio', TFhirRatio(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Observation', 'valueSampledData', TFhirSampledData(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Observation', 'valueAttachment', TFhirAttachment(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Observation', 'valueTime', TFhirTime(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Observation', 'valueDateTime', TFhirDateTime(elem.value), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Observation', 'valuePeriod', TFhirPeriod(elem.value), -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation', 'dataAbsentReason', elem.dataAbsentReasonElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation', 'interpretation', elem.interpretationElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Observation', 'comments', elem.commentsElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation', 'bodySite', elem.bodySiteElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation', 'method', elem.methodElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirSpecimen}(this, 'Observation', 'specimen', elem.specimenElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'Observation', 'device', elem.deviceElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(this, 'Observation', 'referenceRange', elem.referenceRangeList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeObservationRelated(this, 'Observation', 'related', elem.relatedList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.componentList.Count - 1 do
      ComposeObservationComponent(this, 'Observation', 'component', elem.componentList[i], i);
end;

function TFHIRXmlParser.ParseOperationDefinitionContact(element : IXmlDomElement; path : string) : TFhirOperationDefinitionContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationDefinitionContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionContact(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationDefinitionContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinitionContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationDefinitionContact(jsn : TJsonObject) : TFhirOperationDefinitionContact;
begin
  result := TFhirOperationDefinitionContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationDefinitionContact(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeOperationDefinitionContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirOperationDefinitionContact; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:OperationDefinitionContact');
  end;
  composeBackboneElement(this, 'OperationDefinitionContact', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'OperationDefinitionContact', 'name', elem.nameElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'OperationDefinitionContact', 'telecom', elem.telecomList[i], i);
end;

function TFHIRXmlParser.ParseOperationDefinitionParameter(element : IXmlDomElement; path : string) : TFhirOperationDefinitionParameter;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationDefinitionParameter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseCode(child, path+'/name') {b}
      else if (child.baseName = 'use') then
        result.useElement := ParseEnum(CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum, path+'/use', child){1a}
      else if (child.baseName = 'min') then
        result.minElement := ParseInteger(child, path+'/min') {b}
      else if (child.baseName = 'max') then
        result.maxElement := ParseString(child, path+'/max') {b}
      else if (child.baseName = 'documentation') then
        result.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirOperationParameterTypeEnum, SYSTEMS_TFhirOperationParameterTypeEnum, path+'/type', child){1a}
      else if (child.baseName = 'profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if (child.baseName = 'binding') then
        result.binding := ParseOperationDefinitionParameterBinding(child, path+'/binding') {b}
      else if (child.baseName = 'part') then
        result.partList.Add(ParseOperationDefinitionParameter(child, path+'/part')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameter(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionParameter);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'min', elem.minElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'max', elem.maxElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirOperationParameterTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeOperationDefinitionParameterBinding(xml, 'binding', elem.binding);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.partList.Count - 1 do
      ComposeOperationDefinitionParameter(xml, 'part', elem.partList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationDefinitionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinitionParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationDefinitionParameter(jsn : TJsonObject) : TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseCode(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn['use'], jsn.vObj['_use'], CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum);
    if jsn.has('min') or jsn.has('_min') then
        result.minElement := ParseInteger(jsn['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxElement := ParseString(jsn['max'], jsn.vObj['_max']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirOperationParameterTypeEnum, SYSTEMS_TFhirOperationParameterTypeEnum);
    if jsn.has('profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(jsn.vObj['profile']);{q}
    if jsn.has('binding') then
        result.binding := ParseOperationDefinitionParameterBinding(jsn.vObj['binding']);{q}
    if jsn.has('part') then
      iterateArray(jsn.vArr['part'], result.partList, parseOperationDefinitionParameter);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationDefinitionParameter(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameter; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'min', elem.minElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'min', elem.minElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirOperationParameterTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirOperationParameterTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(json, 'profile', elem.profile); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeOperationDefinitionParameterBinding(json, 'binding', elem.binding); {a}
  if (SummaryOption in [soFull, soData]) and (elem.partList.Count > 0) then
  begin
    json.valueArray('part');
    for i := 0 to elem.partList.Count - 1 do
      ComposeOperationDefinitionParameter(json, '', elem.partList[i]); {z - @OperationDefinition.parameter}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeOperationDefinitionParameter(parent :  TRDFComplex; parentType, name : String; elem : TFhirOperationDefinitionParameter; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:OperationDefinitionParameter');
  end;
  composeBackboneElement(this, 'OperationDefinitionParameter', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'OperationDefinitionParameter', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'OperationDefinitionParameter', 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'OperationDefinitionParameter', 'min', elem.minElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'OperationDefinitionParameter', 'max', elem.maxElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'OperationDefinitionParameter', 'documentation', elem.documentationElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'OperationDefinitionParameter', 'type', elem.Type_Element, CODES_TFhirOperationParameterTypeEnum, SYSTEMS_TFhirOperationParameterTypeEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(this, 'OperationDefinitionParameter', 'profile', elem.profileElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeOperationDefinitionParameterBinding(this, 'OperationDefinitionParameter', 'binding', elem.bindingElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.partList.Count - 1 do
      ComposeOperationDefinitionParameter(this, 'OperationDefinitionParameter', 'part', elem.partList[i], i);
end;

function TFHIRXmlParser.ParseOperationDefinitionParameterBinding(element : IXmlDomElement; path : string) : TFhirOperationDefinitionParameterBinding;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationDefinitionParameterBinding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'strength') then
        result.strengthElement := ParseEnum(CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, path+'/strength', child){1a}
      else if (child.baseName = 'valueSetUri') then
        result.valueSet := ParseUri(child, path+'/valueSetUri'){x.3}
      else if (child.baseName = 'valueSetReference') then
        result.valueSet := ParseReference(child, path+'/valueSetReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameterBinding(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionParameterBinding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum);
  if (SummaryOption in [soFull, soData]) and (elem.valueSet is TFhirUri) {6} then
    ComposeUri(xml, 'valueSetUri', TFhirUri(elem.valueSet))
  else if (SummaryOption in [soFull, soData]) and (elem.valueSet is TFhirReference) {2} then
    ComposeReference(xml, 'valueSetReference', TFhirReference(elem.valueSet));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationDefinitionParameterBinding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinitionParameterBinding(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationDefinitionParameterBinding(jsn : TJsonObject) : TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('strength') or jsn.has('_strength')  then
      result.strengthElement := parseEnum(jsn.path+'/strength', jsn['strength'], jsn.vObj['_strength'], CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum);
    if jsn.has('valueSetUri') or jsn.has('_valueSetUri') then
      result.valueSet := parseUri(jsn['valueSetUri'], jsn.vObj['_valueSetUri']);
    if jsn.has('valueSetReference') {a3} then
      result.valueSet := ParseReference(jsn.vObj['valueSetReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationDefinitionParameterBinding(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameterBinding; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.valueSet is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueSetUri', TFhirUri(elem.valueSet), false);
    ComposeUriProps(json, 'valueSetUri', TFhirUri(elem.valueSet), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.valueSet is TFhirReference) then
    ComposeReference(json, 'valueSetReference', TFhirReference(elem.valueSet));
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeOperationDefinitionParameterBinding(parent :  TRDFComplex; parentType, name : String; elem : TFhirOperationDefinitionParameterBinding; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:OperationDefinitionParameterBinding');
  end;
  composeBackboneElement(this, 'OperationDefinitionParameterBinding', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'OperationDefinitionParameterBinding', 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, -1);
  if (SummaryOption in [soFull, soData]) and (elem.valueSet is TFhirUri) {6} then
    ComposeUri(this, 'OperationDefinitionParameterBinding', 'valueSetUri', TFhirUri(elem.valueSet), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.valueSet is TFhirReference) {2} then
    ComposeReference(this, 'OperationDefinitionParameterBinding', 'valueSetReference', TFhirReference(elem.valueSet), -1);
end;

function TFHIRXmlParser.ParseOperationDefinition(element : IXmlDomElement; path : string) : TFhirOperationDefinition;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationDefinition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'kind') then
        result.kindElement := ParseEnum(CODES_TFhirOperationKindEnum, SYSTEMS_TFhirOperationKindEnum, path+'/kind', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseOperationDefinitionContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'requirements') then
        result.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'idempotent') then
        result.idempotentElement := ParseBoolean(child, path+'/idempotent') {b}
      else if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'notes') then
        result.notesElement := ParseString(child, path+'/notes') {b}
      else if (child.baseName = 'base') then
        result.base := ParseReference{TFhirOperationDefinition}(child, path+'/base') {b}
      else if (child.baseName = 'system') then
        result.systemElement := ParseBoolean(child, path+'/system') {b}
      else if (child.baseName = 'type') then
        result.type_.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/type', child)){y.1}
      else if (child.baseName = 'instance') then
        result.instanceElement := ParseBoolean(child, path+'/instance') {b}
      else if (child.baseName = 'parameter') then
        result.parameterList.Add(ParseOperationDefinitionParameter(child, path+'/parameter')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinition(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirOperationKindEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOperationDefinitionContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'idempotent', elem.idempotentElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'notes', elem.notesElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOperationDefinition}(xml, 'base', elem.base);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'system', elem.systemElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.type_.Count - 1 do
      ComposeEnum(xml, 'type', elem.type_[i], CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'instance', elem.instanceElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeOperationDefinitionParameter(xml, 'parameter', elem.parameterList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationDefinition(jsn : TJsonObject) : TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn['kind'], jsn.vObj['_kind'], CODES_TFhirOperationKindEnum, SYSTEMS_TFhirOperationKindEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseOperationDefinitionContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('idempotent') or jsn.has('_idempotent') then
        result.idempotentElement := ParseBoolean(jsn['idempotent'], jsn.vObj['_idempotent']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesElement := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    if jsn.has('base') then
        result.base := ParseReference{TFhirOperationDefinition}(jsn.vObj['base']);{q}
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseBoolean(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('type') or jsn.has('_type') then
      iterateEnumArray(jsn.vArr['type'], jsn.vArr['_type'], jsn.path+'/type', result.type_, parseEnum, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('instance') or jsn.has('_instance') then
        result.instanceElement := ParseBoolean(jsn['instance'], jsn.vObj['_instance']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseOperationDefinitionParameter);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationDefinition(json : TJSONWriter; name : string; elem : TFhirOperationDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirOperationKindEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirOperationKindEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOperationDefinitionContact(json, '', elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'idempotent', elem.idempotentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'idempotent', elem.idempotentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'notes', elem.notesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'notes', elem.notesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOperationDefinition}(json, 'base', elem.base); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.type_.Count > 0) then
  begin
    json.valueArray('type');
    ext := false;
    for i := 0 to elem.type_.Count - 1 do
    begin
      ext := ext or ((elem.type_[i].id <> '') or (elem.type_[i].hasExtensionList));
      ComposeEnumValue(json, '', elem.type_[i], CODES_TFhirResourceTypesEnum, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_type');
      for i := 0 to elem.type_.Count - 1 do
        ComposeEnumProps(json, '', elem.type_[i], CODES_TFhirResourceTypesEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'instance', elem.instanceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'instance', elem.instanceElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.parameterList.Count > 0) then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeOperationDefinitionParameter(json, '', elem.parameterList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeOperationDefinition(parent :  TRDFComplex; parentType, name : String; elem : TFhirOperationDefinition; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:OperationDefinition');
  end;
  composeDomainResource(this, 'OperationDefinition', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'OperationDefinition', 'url', elem.urlElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'OperationDefinition', 'version', elem.versionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'OperationDefinition', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'OperationDefinition', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, -1);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'OperationDefinition', 'kind', elem.KindElement, CODES_TFhirOperationKindEnum, SYSTEMS_TFhirOperationKindEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'OperationDefinition', 'experimental', elem.experimentalElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'OperationDefinition', 'publisher', elem.publisherElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOperationDefinitionContact(this, 'OperationDefinition', 'contact', elem.contactList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'OperationDefinition', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'OperationDefinition', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'OperationDefinition', 'requirements', elem.requirementsElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'OperationDefinition', 'idempotent', elem.idempotentElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'OperationDefinition', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'OperationDefinition', 'notes', elem.notesElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOperationDefinition}(this, 'OperationDefinition', 'base', elem.baseElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'OperationDefinition', 'system', elem.systemElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.type_.Count - 1 do
      ComposeEnum(this, 'OperationDefinition', 'type', elem.type_[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.type_.Count - 1 do
      ComposeEnum(this, 'OperationDefinition', 'type', elem.type_[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'OperationDefinition', 'instance', elem.instanceElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeOperationDefinitionParameter(this, 'OperationDefinition', 'parameter', elem.parameterList[i], i);
end;

function TFHIRXmlParser.ParseOperationOutcomeIssue(element : IXmlDomElement; path : string) : TFhirOperationOutcomeIssue;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'severity') then
        result.severityElement := ParseEnum(CODES_TFhirIssueSeverityEnum, SYSTEMS_TFhirIssueSeverityEnum, path+'/severity', child){1a}
      else if (child.baseName = 'code') then
        result.codeElement := ParseEnum(CODES_TFhirIssueTypeEnum, SYSTEMS_TFhirIssueTypeEnum, path+'/code', child){1a}
      else if (child.baseName = 'details') then
        result.details := ParseCodeableConcept(child, path+'/details') {b}
      else if (child.baseName = 'diagnostics') then
        result.diagnosticsElement := ParseString(child, path+'/diagnostics') {b}
      else if (child.baseName = 'location') then
        result.locationList.Add(ParseString(child, path+'/location')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcomeIssue(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcomeIssue);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'severity', elem.SeverityElement, CODES_TFhirIssueSeverityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirIssueTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'details', elem.details);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'diagnostics', elem.diagnosticsElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeString(xml, 'location', elem.locationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationOutcomeIssue(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationOutcomeIssue(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationOutcomeIssue(jsn : TJsonObject) : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityElement := parseEnum(jsn.path+'/severity', jsn['severity'], jsn.vObj['_severity'], CODES_TFhirIssueSeverityEnum, SYSTEMS_TFhirIssueSeverityEnum);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn['code'], jsn.vObj['_code'], CODES_TFhirIssueTypeEnum, SYSTEMS_TFhirIssueTypeEnum);
    if jsn.has('details') then
        result.details := ParseCodeableConcept(jsn.vObj['details']);{q}
    if jsn.has('diagnostics') or jsn.has('_diagnostics') then
        result.diagnosticsElement := ParseString(jsn['diagnostics'], jsn.vObj['_diagnostics']);{q}
      if jsn.has('location') or jsn.has('_location') then
      iteratePrimitiveArray(jsn.vArr['location'], jsn.vArr['_location'], result.locationList, parseString);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationOutcomeIssue(json : TJSONWriter; name : string; elem : TFhirOperationOutcomeIssue; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'severity', elem.SeverityElement, CODES_TFhirIssueSeverityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'severity', elem.SeverityElement, CODES_TFhirIssueSeverityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirIssueTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirIssueTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'details', elem.details); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'diagnostics', elem.diagnosticsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'diagnostics', elem.diagnosticsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.locationList.Count > 0) then
  begin
    json.valueArray('location');
    ext := false;
    for i := 0 to elem.locationList.Count - 1 do
    begin
      ext := ext or ((elem.locationList[i].id <> '') or (elem.locationList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.locationList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_location');
      for i := 0 to elem.locationList.Count - 1 do
        ComposeStringProps(json, '',elem.locationList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeOperationOutcomeIssue(parent :  TRDFComplex; parentType, name : String; elem : TFhirOperationOutcomeIssue; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:OperationOutcomeIssue');
  end;
  composeBackboneElement(this, 'OperationOutcomeIssue', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'OperationOutcomeIssue', 'severity', elem.SeverityElement, CODES_TFhirIssueSeverityEnum, SYSTEMS_TFhirIssueSeverityEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'OperationOutcomeIssue', 'code', elem.CodeElement, CODES_TFhirIssueTypeEnum, SYSTEMS_TFhirIssueTypeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'OperationOutcomeIssue', 'details', elem.detailsElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'OperationOutcomeIssue', 'diagnostics', elem.diagnosticsElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeString(this, 'OperationOutcomeIssue', 'location', elem.locationList[i], i);
end;

function TFHIRXmlParser.ParseOperationOutcome(element : IXmlDomElement; path : string) : TFhirOperationOutcome;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationOutcome.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'issue') then
        result.issueList.Add(ParseOperationOutcomeIssue(child, path+'/issue')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcome(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcome);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.issueList.Count - 1 do
      ComposeOperationOutcomeIssue(xml, 'issue', elem.issueList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationOutcome(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationOutcome(jsn : TJsonObject) : TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('issue') then
      iterateArray(jsn.vArr['issue'], result.issueList, parseOperationOutcomeIssue);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationOutcome(json : TJSONWriter; name : string; elem : TFhirOperationOutcome; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.issueList.Count > 0) then
  begin
    json.valueArray('issue');
    for i := 0 to elem.issueList.Count - 1 do
      ComposeOperationOutcomeIssue(json, '', elem.issueList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeOperationOutcome(parent :  TRDFComplex; parentType, name : String; elem : TFhirOperationOutcome; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:OperationOutcome');
  end;
  composeDomainResource(this, 'OperationOutcome', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.issueList.Count - 1 do
      ComposeOperationOutcomeIssue(this, 'OperationOutcome', 'issue', elem.issueList[i], i);
end;

function TFHIRXmlParser.ParseOrderWhen(element : IXmlDomElement; path : string) : TFhirOrderWhen;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrderWhen.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'schedule') then
        result.schedule := ParseTiming(child, path+'/schedule') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrderWhen(xml : TXmlBuilder; name : string; elem : TFhirOrderWhen);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(xml, 'schedule', elem.schedule);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrderWhen(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrderWhen(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrderWhen(jsn : TJsonObject) : TFhirOrderWhen;
begin
  result := TFhirOrderWhen.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('schedule') then
        result.schedule := ParseTiming(jsn.vObj['schedule']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrderWhen(json : TJSONWriter; name : string; elem : TFhirOrderWhen; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(json, 'schedule', elem.schedule); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeOrderWhen(parent :  TRDFComplex; parentType, name : String; elem : TFhirOrderWhen; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:OrderWhen');
  end;
  composeBackboneElement(this, 'OrderWhen', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'OrderWhen', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(this, 'OrderWhen', 'schedule', elem.scheduleElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseOrder(element : IXmlDomElement; path : string) : TFhirOrder;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrder.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'source') then
        result.source := ParseReference{Resource}(child, path+'/source') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{Resource}(child, path+'/target') {b}
      else if (child.baseName = 'reasonCodeableConcept') then
        result.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.baseName = 'reasonReference') then
        result.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.baseName = 'when') then
        result.when := ParseOrderWhen(child, path+'/when') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseReference{TFhirReference}(child, path+'/detail')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrder(xml : TXmlBuilder; name : string; elem : TFhirOrder);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'source', elem.source);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'target', elem.target);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOrderWhen(xml, 'when', elem.when);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrder(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrder(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrder(jsn : TJsonObject) : TFhirOrder;
begin
  result := TFhirOrder.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('source') then
        result.source := ParseReference{Resource}(jsn.vObj['source']);{q}
    if jsn.has('target') then
        result.target := ParseReference{Resource}(jsn.vObj['target']);{q}
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('when') then
        result.when := ParseOrderWhen(jsn.vObj['when']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrder(json : TJSONWriter; name : string; elem : TFhirOrder; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'target', elem.target); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOrderWhen(json, 'when', elem.when); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.detailList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeOrder(parent :  TRDFComplex; parentType, name : String; elem : TFhirOrder; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Order');
  end;
  composeDomainResource(this, 'Order', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Order', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Order', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Order', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Order', 'source', elem.sourceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Order', 'target', elem.targetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Order', 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(this, 'Order', 'reasonReference', TFhirReference(elem.reason), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOrderWhen(this, 'Order', 'when', elem.whenElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Order', 'detail', elem.detailList[i], i);
end;

function TFHIRXmlParser.ParseOrderResponse(element : IXmlDomElement; path : string) : TFhirOrderResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrderResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirOrder}(child, path+'/request') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'who') then
        result.who := ParseReference{Resource}(child, path+'/who') {b}
      else if (child.baseName = 'orderStatus') then
        result.orderStatusElement := ParseEnum(CODES_TFhirOrderStatusEnum, SYSTEMS_TFhirOrderStatusEnum, path+'/orderStatus', child){1a}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'fulfillment') then
        result.fulfillmentList.Add(ParseReference{TFhirReference}(child, path+'/fulfillment')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrderResponse(xml : TXmlBuilder; name : string; elem : TFhirOrderResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrder}(xml, 'request', elem.request);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'who', elem.who);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'orderStatus', elem.OrderStatusElement, CODES_TFhirOrderStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.fulfillmentList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'fulfillment', elem.fulfillmentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrderResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrderResponse(jsn : TJsonObject) : TFhirOrderResponse;
begin
  result := TFhirOrderResponse.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirOrder}(jsn.vObj['request']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('who') then
        result.who := ParseReference{Resource}(jsn.vObj['who']);{q}
    if jsn.has('orderStatus') or jsn.has('_orderStatus')  then
      result.orderStatusElement := parseEnum(jsn.path+'/orderStatus', jsn['orderStatus'], jsn.vObj['_orderStatus'], CODES_TFhirOrderStatusEnum, SYSTEMS_TFhirOrderStatusEnum);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('fulfillment') then
      iterateArray(jsn.vArr['fulfillment'], result.fulfillmentList, parseReference{TFhirReference});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrderResponse(json : TJSONWriter; name : string; elem : TFhirOrderResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrder}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'who', elem.who); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'orderStatus', elem.OrderStatusElement, CODES_TFhirOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'orderStatus', elem.OrderStatusElement, CODES_TFhirOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.fulfillmentList.Count > 0) then
  begin
    json.valueArray('fulfillment');
    for i := 0 to elem.fulfillmentList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.fulfillmentList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeOrderResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirOrderResponse; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:OrderResponse');
  end;
  composeDomainResource(this, 'OrderResponse', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'OrderResponse', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrder}(this, 'OrderResponse', 'request', elem.requestElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'OrderResponse', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'OrderResponse', 'who', elem.whoElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'OrderResponse', 'orderStatus', elem.OrderStatusElement, CODES_TFhirOrderStatusEnum, SYSTEMS_TFhirOrderStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'OrderResponse', 'description', elem.descriptionElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.fulfillmentList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'OrderResponse', 'fulfillment', elem.fulfillmentList[i], i);
end;

function TFHIRXmlParser.ParseOrganizationContact(element : IXmlDomElement; path : string) : TFhirOrganizationContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrganizationContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'purpose') then
        result.purpose := ParseCodeableConcept(child, path+'/purpose') {b}
      else if (child.baseName = 'name') then
        result.name := ParseHumanName(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'address') then
        result.address := ParseAddress(child, path+'/address') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrganizationContact(xml : TXmlBuilder; name : string; elem : TFhirOrganizationContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'purpose', elem.purpose);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(xml, 'name', elem.name);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(xml, 'address', elem.address);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrganizationContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrganizationContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrganizationContact(jsn : TJsonObject) : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('purpose') then
        result.purpose := ParseCodeableConcept(jsn.vObj['purpose']);{q}
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrganizationContact(json : TJSONWriter; name : string; elem : TFhirOrganizationContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'purpose', elem.purpose); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(json, 'name', elem.name); {a}
  if (SummaryOption in [soFull, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(json, 'address', elem.address); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeOrganizationContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirOrganizationContact; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:OrganizationContact');
  end;
  composeBackboneElement(this, 'OrganizationContact', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'OrganizationContact', 'purpose', elem.purposeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(this, 'OrganizationContact', 'name', elem.nameElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'OrganizationContact', 'telecom', elem.telecomList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(this, 'OrganizationContact', 'address', elem.addressElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseOrganization(element : IXmlDomElement; path : string) : TFhirOrganization;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrganization.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'active') then
        result.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'address') then
        result.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.baseName = 'partOf') then
        result.partOf := ParseReference{TFhirOrganization}(child, path+'/partOf') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseOrganizationContact(child, path+'/contact')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrganization(xml : TXmlBuilder; name : string; elem : TFhirOrganization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(xml, 'address', elem.addressList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'partOf', elem.partOf);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOrganizationContact(xml, 'contact', elem.contactList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrganization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrganization(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrganization(jsn : TJsonObject) : TFhirOrganization;
begin
  result := TFhirOrganization.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := ParseBoolean(jsn['active'], jsn.vObj['_active']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('partOf') then
        result.partOf := ParseReference{TFhirOrganization}(jsn.vObj['partOf']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseOrganizationContact);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrganization(json : TJSONWriter; name : string; elem : TFhirOrganization; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.addressList.Count > 0) then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '', elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'partOf', elem.partOf); {a}
  if (SummaryOption in [soFull, soData]) and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOrganizationContact(json, '', elem.contactList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeOrganization(parent :  TRDFComplex; parentType, name : String; elem : TFhirOrganization; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Organization');
  end;
  composeDomainResource(this, 'Organization', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Organization', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Organization', 'active', elem.activeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Organization', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Organization', 'name', elem.nameElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Organization', 'telecom', elem.telecomList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'Organization', 'address', elem.addressList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Organization', 'partOf', elem.partOfElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOrganizationContact(this, 'Organization', 'contact', elem.contactList[i], i);
end;

function TFHIRXmlParser.ParsePatientContact(element : IXmlDomElement; path : string) : TFhirPatientContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatientContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'relationship') then
        result.relationshipList.Add(ParseCodeableConcept(child, path+'/relationship')){y.2}
      else if (child.baseName = 'name') then
        result.name := ParseHumanName(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'address') then
        result.address := ParseAddress(child, path+'/address') {b}
      else if (child.baseName = 'gender') then
        result.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatientContact(xml : TXmlBuilder; name : string; elem : TFhirPatientContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.relationshipList.Count - 1 do
      ComposeCodeableConcept(xml, 'relationship', elem.relationshipList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(xml, 'name', elem.name);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(xml, 'address', elem.address);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatientContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientContact(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatientContact(jsn : TJsonObject) : TFhirPatientContact;
begin
  result := TFhirPatientContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('relationship') then
      iterateArray(jsn.vArr['relationship'], result.relationshipList, parseCodeableConcept);
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q}
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatientContact(json : TJSONWriter; name : string; elem : TFhirPatientContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.relationshipList.Count > 0) then
  begin
    json.valueArray('relationship');
    for i := 0 to elem.relationshipList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.relationshipList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(json, 'name', elem.name); {a}
  if (SummaryOption in [soFull, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(json, 'address', elem.address); {a}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposePatientContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirPatientContact; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:PatientContact');
  end;
  composeBackboneElement(this, 'PatientContact', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.relationshipList.Count - 1 do
      ComposeCodeableConcept(this, 'PatientContact', 'relationship', elem.relationshipList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(this, 'PatientContact', 'name', elem.nameElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'PatientContact', 'telecom', elem.telecomList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(this, 'PatientContact', 'address', elem.addressElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'PatientContact', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'PatientContact', 'organization', elem.organizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'PatientContact', 'period', elem.periodElement, -1);{x.2}
end;

function TFHIRXmlParser.ParsePatientAnimal(element : IXmlDomElement; path : string) : TFhirPatientAnimal;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatientAnimal.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'species') then
        result.species := ParseCodeableConcept(child, path+'/species') {b}
      else if (child.baseName = 'breed') then
        result.breed := ParseCodeableConcept(child, path+'/breed') {b}
      else if (child.baseName = 'genderStatus') then
        result.genderStatus := ParseCodeableConcept(child, path+'/genderStatus') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatientAnimal(xml : TXmlBuilder; name : string; elem : TFhirPatientAnimal);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'species', elem.species);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'breed', elem.breed);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'genderStatus', elem.genderStatus);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatientAnimal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientAnimal(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatientAnimal(jsn : TJsonObject) : TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('species') then
        result.species := ParseCodeableConcept(jsn.vObj['species']);{q}
    if jsn.has('breed') then
        result.breed := ParseCodeableConcept(jsn.vObj['breed']);{q}
    if jsn.has('genderStatus') then
        result.genderStatus := ParseCodeableConcept(jsn.vObj['genderStatus']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatientAnimal(json : TJSONWriter; name : string; elem : TFhirPatientAnimal; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'species', elem.species); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'breed', elem.breed); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'genderStatus', elem.genderStatus); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposePatientAnimal(parent :  TRDFComplex; parentType, name : String; elem : TFhirPatientAnimal; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:PatientAnimal');
  end;
  composeBackboneElement(this, 'PatientAnimal', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'PatientAnimal', 'species', elem.speciesElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'PatientAnimal', 'breed', elem.breedElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'PatientAnimal', 'genderStatus', elem.genderStatusElement, -1);{x.2}
end;

function TFHIRXmlParser.ParsePatientCommunication(element : IXmlDomElement; path : string) : TFhirPatientCommunication;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatientCommunication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'language') then
        result.language := ParseCodeableConcept(child, path+'/language') {b}
      else if (child.baseName = 'preferred') then
        result.preferredElement := ParseBoolean(child, path+'/preferred') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatientCommunication(xml : TXmlBuilder; name : string; elem : TFhirPatientCommunication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'language', elem.language);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'preferred', elem.preferredElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatientCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientCommunication(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatientCommunication(jsn : TJsonObject) : TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('language') then
        result.language := ParseCodeableConcept(jsn.vObj['language']);{q}
    if jsn.has('preferred') or jsn.has('_preferred') then
        result.preferredElement := ParseBoolean(jsn['preferred'], jsn.vObj['_preferred']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatientCommunication(json : TJSONWriter; name : string; elem : TFhirPatientCommunication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'language', elem.language); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'preferred', elem.preferredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'preferred', elem.preferredElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposePatientCommunication(parent :  TRDFComplex; parentType, name : String; elem : TFhirPatientCommunication; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:PatientCommunication');
  end;
  composeBackboneElement(this, 'PatientCommunication', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PatientCommunication', 'language', elem.languageElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'PatientCommunication', 'preferred', elem.preferredElement, -1);{x.2}
end;

function TFHIRXmlParser.ParsePatientLink(element : IXmlDomElement; path : string) : TFhirPatientLink;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatientLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'other') then
        result.other := ParseReference{TFhirPatient}(child, path+'/other') {b}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirLinkTypeEnum, SYSTEMS_TFhirLinkTypeEnum, path+'/type', child){1a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatientLink(xml : TXmlBuilder; name : string; elem : TFhirPatientLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(xml, 'other', elem.other);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirLinkTypeEnum);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatientLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientLink(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatientLink(jsn : TJsonObject) : TFhirPatientLink;
begin
  result := TFhirPatientLink.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('other') then
        result.other := ParseReference{TFhirPatient}(jsn.vObj['other']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirLinkTypeEnum, SYSTEMS_TFhirLinkTypeEnum);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatientLink(json : TJSONWriter; name : string; elem : TFhirPatientLink; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(json, 'other', elem.other); {a}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirLinkTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirLinkTypeEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposePatientLink(parent :  TRDFComplex; parentType, name : String; elem : TFhirPatientLink; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:PatientLink');
  end;
  composeBackboneElement(this, 'PatientLink', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(this, 'PatientLink', 'other', elem.otherElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'PatientLink', 'type', elem.Type_Element, CODES_TFhirLinkTypeEnum, SYSTEMS_TFhirLinkTypeEnum, -1);
end;

function TFHIRXmlParser.ParsePatient(element : IXmlDomElement; path : string) : TFhirPatient;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatient.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'active') then
        result.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.baseName = 'name') then
        result.nameList.Add(ParseHumanName(child, path+'/name')){y.2}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'gender') then
        result.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.baseName = 'birthDate') then
        result.birthDateElement := ParseDate(child, path+'/birthDate') {b}
      else if (child.baseName = 'deceasedBoolean') then
        result.deceased := ParseBoolean(child, path+'/deceasedBoolean'){x.3}
      else if (child.baseName = 'deceasedDateTime') then
        result.deceased := ParseDateTime(child, path+'/deceasedDateTime'){x.3}
      else if (child.baseName = 'address') then
        result.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.baseName = 'maritalStatus') then
        result.maritalStatus := ParseCodeableConcept(child, path+'/maritalStatus') {b}
      else if (child.baseName = 'multipleBirthBoolean') then
        result.multipleBirth := ParseBoolean(child, path+'/multipleBirthBoolean'){x.3}
      else if (child.baseName = 'multipleBirthInteger') then
        result.multipleBirth := ParseInteger(child, path+'/multipleBirthInteger'){x.3}
      else if (child.baseName = 'photo') then
        result.photoList.Add(ParseAttachment(child, path+'/photo')){y.2}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParsePatientContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'animal') then
        result.animal := ParsePatientAnimal(child, path+'/animal') {b}
      else if (child.baseName = 'communication') then
        result.communicationList.Add(ParsePatientCommunication(child, path+'/communication')){y.2}
      else if (child.baseName = 'careProvider') then
        result.careProviderList.Add(ParseReference{Resource}(child, path+'/careProvider')){y.2}
      else if (child.baseName = 'managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.baseName = 'link') then
        result.link_List.Add(ParsePatientLink(child, path+'/link')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatient(xml : TXmlBuilder; name : string; elem : TFhirPatient);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(xml, 'name', elem.nameList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'birthDate', elem.birthDateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'deceasedBoolean', TFhirBoolean(elem.deceased))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'deceasedDateTime', TFhirDateTime(elem.deceased));
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(xml, 'address', elem.addressList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'maritalStatus', elem.maritalStatus);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth))
  else if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirInteger) {6} then
    ComposeInteger(xml, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth));
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', elem.photoList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposePatientContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePatientAnimal(xml, 'animal', elem.animal);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposePatientCommunication(xml, 'communication', elem.communicationList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.careProviderList.Count - 1 do
      ComposeReference{Resource}(xml, 'careProvider', elem.careProviderList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.link_List.Count - 1 do
      ComposePatientLink(xml, 'link', elem.link_List[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatient(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatient(jsn : TJsonObject) : TFhirPatient;
begin
  result := TFhirPatient.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := ParseBoolean(jsn['active'], jsn.vObj['_active']);{q}
    if jsn.has('name') then
      iterateArray(jsn.vArr['name'], result.nameList, parseHumanName);
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDateElement := ParseDate(jsn['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('deceasedBoolean') or jsn.has('_deceasedBoolean') then
      result.deceased := parseBoolean(jsn['deceasedBoolean'], jsn.vObj['_deceasedBoolean']);
    if jsn.has('deceasedDateTime') or jsn.has('_deceasedDateTime') then
      result.deceased := parseDateTime(jsn['deceasedDateTime'], jsn.vObj['_deceasedDateTime']);
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('maritalStatus') then
        result.maritalStatus := ParseCodeableConcept(jsn.vObj['maritalStatus']);{q}
    if jsn.has('multipleBirthBoolean') or jsn.has('_multipleBirthBoolean') then
      result.multipleBirth := parseBoolean(jsn['multipleBirthBoolean'], jsn.vObj['_multipleBirthBoolean']);
    if jsn.has('multipleBirthInteger') or jsn.has('_multipleBirthInteger') then
      result.multipleBirth := parseInteger(jsn['multipleBirthInteger'], jsn.vObj['_multipleBirthInteger']);
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parsePatientContact);
    if jsn.has('animal') then
        result.animal := ParsePatientAnimal(jsn.vObj['animal']);{q}
    if jsn.has('communication') then
      iterateArray(jsn.vArr['communication'], result.communicationList, parsePatientCommunication);
    if jsn.has('careProvider') then
      iterateArray(jsn.vArr['careProvider'], result.careProviderList, parseReference{Resource});
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q}
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parsePatientLink);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatient(json : TJSONWriter; name : string; elem : TFhirPatient; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.nameList.Count > 0) then
  begin
    json.valueArray('name');
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(json, '', elem.nameList[i]); {z - HumanName}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
    ComposeBooleanProps(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'deceasedDateTime', TFhirDateTime(elem.deceased), false);
    ComposeDateTimeProps(json, 'deceasedDateTime', TFhirDateTime(elem.deceased), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.addressList.Count > 0) then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '', elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'maritalStatus', elem.maritalStatus); {a}
  if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth), false);
    ComposeBooleanProps(json, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth), false);
    ComposeIntegerProps(json, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.photoList.Count > 0) then
  begin
    json.valueArray('photo');
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '', elem.photoList[i]); {z - Attachment}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposePatientContact(json, '', elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePatientAnimal(json, 'animal', elem.animal); {a}
  if (SummaryOption in [soFull, soData]) and (elem.communicationList.Count > 0) then
  begin
    json.valueArray('communication');
    for i := 0 to elem.communicationList.Count - 1 do
      ComposePatientCommunication(json, '', elem.communicationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.careProviderList.Count > 0) then
  begin
    json.valueArray('careProvider');
    for i := 0 to elem.careProviderList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.careProviderList[i]); {z - Reference(Organization|Practitioner)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if (SummaryOption in [soFull, soData]) and (elem.link_List.Count > 0) then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposePatientLink(json, '', elem.link_List[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposePatient(parent :  TRDFComplex; parentType, name : String; elem : TFhirPatient; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Patient');
  end;
  composeDomainResource(this, 'Patient', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Patient', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Patient', 'active', elem.activeElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(this, 'Patient', 'name', elem.nameList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Patient', 'telecom', elem.telecomList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Patient', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'Patient', 'birthDate', elem.birthDateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Patient', 'deceasedBoolean', TFhirBoolean(elem.deceased), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Patient', 'deceasedDateTime', TFhirDateTime(elem.deceased), -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'Patient', 'address', elem.addressList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Patient', 'maritalStatus', elem.maritalStatusElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Patient', 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirInteger) {6} then
    ComposeInteger(this, 'Patient', 'multipleBirthInteger', TFhirInteger(elem.multipleBirth), -1);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(this, 'Patient', 'photo', elem.photoList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposePatientContact(this, 'Patient', 'contact', elem.contactList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePatientAnimal(this, 'Patient', 'animal', elem.animalElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposePatientCommunication(this, 'Patient', 'communication', elem.communicationList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.careProviderList.Count - 1 do
      ComposeReference{Resource}(this, 'Patient', 'careProvider', elem.careProviderList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Patient', 'managingOrganization', elem.managingOrganizationElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.link_List.Count - 1 do
      ComposePatientLink(this, 'Patient', 'link', elem.link_List[i], i);
end;

function TFHIRXmlParser.ParsePaymentNotice(element : IXmlDomElement; path : string) : TFhirPaymentNotice;
var
  child : IXMLDOMElement;
begin
  result := TFhirPaymentNotice.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirOrganization}(child, path+'/target') {b}
      else if (child.baseName = 'provider') then
        result.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirReference}(child, path+'/request') {b}
      else if (child.baseName = 'response') then
        result.response := ParseReference{TFhirReference}(child, path+'/response') {b}
      else if (child.baseName = 'paymentStatus') then
        result.paymentStatus := ParseCoding(child, path+'/paymentStatus') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePaymentNotice(xml : TXmlBuilder; name : string; elem : TFhirPaymentNotice);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'target', elem.target);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'request', elem.request);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'response', elem.response);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'paymentStatus', elem.paymentStatus);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePaymentNotice(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePaymentNotice(jsn)); {2}
end;

function TFHIRJsonParser.ParsePaymentNotice(jsn : TJsonObject) : TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirOrganization}(jsn.vObj['target']);{q}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('request') then
        result.request := ParseReference{TFhirReference}(jsn.vObj['request']);{q}
    if jsn.has('response') then
        result.response := ParseReference{TFhirReference}(jsn.vObj['response']);{q}
    if jsn.has('paymentStatus') then
        result.paymentStatus := ParseCoding(jsn.vObj['paymentStatus']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePaymentNotice(json : TJSONWriter; name : string; elem : TFhirPaymentNotice; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'target', elem.target); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'response', elem.response); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'paymentStatus', elem.paymentStatus); {a}
end;

procedure TFHIRRDFComposer.ComposePaymentNotice(parent :  TRDFComplex; parentType, name : String; elem : TFhirPaymentNotice; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:PaymentNotice');
  end;
  composeDomainResource(this, 'PaymentNotice', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PaymentNotice', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'PaymentNotice', 'ruleset', elem.rulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'PaymentNotice', 'originalRuleset', elem.originalRulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'PaymentNotice', 'created', elem.createdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'PaymentNotice', 'target', elem.targetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'PaymentNotice', 'provider', elem.providerElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'PaymentNotice', 'organization', elem.organizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'PaymentNotice', 'request', elem.requestElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'PaymentNotice', 'response', elem.responseElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'PaymentNotice', 'paymentStatus', elem.paymentStatusElement, -1);{x.2}
end;

function TFHIRXmlParser.ParsePaymentReconciliationDetail(element : IXmlDomElement; path : string) : TFhirPaymentReconciliationDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirReference}(child, path+'/request') {b}
      else if (child.baseName = 'responce') then
        result.responce := ParseReference{TFhirReference}(child, path+'/responce') {b}
      else if (child.baseName = 'submitter') then
        result.submitter := ParseReference{TFhirOrganization}(child, path+'/submitter') {b}
      else if (child.baseName = 'payee') then
        result.payee := ParseReference{TFhirOrganization}(child, path+'/payee') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDate(child, path+'/date') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationDetail(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliationDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'request', elem.request);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'responce', elem.responce);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'submitter', elem.submitter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'payee', elem.payee);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePaymentReconciliationDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePaymentReconciliationDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParsePaymentReconciliationDetail(jsn : TJsonObject) : TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('request') then
        result.request := ParseReference{TFhirReference}(jsn.vObj['request']);{q}
    if jsn.has('responce') then
        result.responce := ParseReference{TFhirReference}(jsn.vObj['responce']);{q}
    if jsn.has('submitter') then
        result.submitter := ParseReference{TFhirOrganization}(jsn.vObj['submitter']);{q}
    if jsn.has('payee') then
        result.payee := ParseReference{TFhirOrganization}(jsn.vObj['payee']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDate(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePaymentReconciliationDetail(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliationDetail; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'responce', elem.responce); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'submitter', elem.submitter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'payee', elem.payee); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposePaymentReconciliationDetail(parent :  TRDFComplex; parentType, name : String; elem : TFhirPaymentReconciliationDetail; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:PaymentReconciliationDetail');
  end;
  composeBackboneElement(this, 'PaymentReconciliationDetail', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'PaymentReconciliationDetail', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'PaymentReconciliationDetail', 'request', elem.requestElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'PaymentReconciliationDetail', 'responce', elem.responceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'PaymentReconciliationDetail', 'submitter', elem.submitterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'PaymentReconciliationDetail', 'payee', elem.payeeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'PaymentReconciliationDetail', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'PaymentReconciliationDetail', 'amount', elem.amountElement, -1);{x.2}
end;

function TFHIRXmlParser.ParsePaymentReconciliationNote(element : IXmlDomElement; path : string) : TFhirPaymentReconciliationNote;
var
  child : IXMLDOMElement;
begin
  result := TFhirPaymentReconciliationNote.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationNote(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliationNote);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePaymentReconciliationNote(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePaymentReconciliationNote(jsn)); {2}
end;

function TFHIRJsonParser.ParsePaymentReconciliationNote(jsn : TJsonObject) : TFhirPaymentReconciliationNote;
begin
  result := TFhirPaymentReconciliationNote.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePaymentReconciliationNote(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliationNote; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposePaymentReconciliationNote(parent :  TRDFComplex; parentType, name : String; elem : TFhirPaymentReconciliationNote; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:PaymentReconciliationNote');
  end;
  composeBackboneElement(this, 'PaymentReconciliationNote', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'PaymentReconciliationNote', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'PaymentReconciliationNote', 'text', elem.textElement, -1);{x.2}
end;

function TFHIRXmlParser.ParsePaymentReconciliation(element : IXmlDomElement; path : string) : TFhirPaymentReconciliation;
var
  child : IXMLDOMElement;
begin
  result := TFhirPaymentReconciliation.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirProcessRequest}(child, path+'/request') {b}
      else if (child.baseName = 'outcome') then
        result.outcomeElement := ParseEnum(CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, path+'/outcome', child){1a}
      else if (child.baseName = 'disposition') then
        result.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.baseName = 'requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParsePaymentReconciliationDetail(child, path+'/detail')){y.2}
      else if (child.baseName = 'form') then
        result.form := ParseCoding(child, path+'/form') {b}
      else if (child.baseName = 'total') then
        result.total := ParseQuantity(child, path+'/total') {b}
      else if (child.baseName = 'note') then
        result.noteList.Add(ParsePaymentReconciliationNote(child, path+'/note')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliation(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirProcessRequest}(xml, 'request', elem.request);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.detailList.Count - 1 do
      ComposePaymentReconciliationDetail(xml, 'detail', elem.detailList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'form', elem.form);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'total', elem.total);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.noteList.Count - 1 do
      ComposePaymentReconciliationNote(xml, 'note', elem.noteList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePaymentReconciliation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePaymentReconciliation(jsn)); {2}
end;

function TFHIRJsonParser.ParsePaymentReconciliation(jsn : TJsonObject) : TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirProcessRequest}(jsn.vObj['request']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn['outcome'], jsn.vObj['_outcome'], CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parsePaymentReconciliationDetail);
    if jsn.has('form') then
        result.form := ParseCoding(jsn.vObj['form']);{q}
    if jsn.has('total') then
        result.total := ParseQuantity(jsn.vObj['total']);{q}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parsePaymentReconciliationNote);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePaymentReconciliation(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirProcessRequest}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposePaymentReconciliationDetail(json, '', elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'form', elem.form); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'total', elem.total); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposePaymentReconciliationNote(json, '', elem.noteList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposePaymentReconciliation(parent :  TRDFComplex; parentType, name : String; elem : TFhirPaymentReconciliation; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:PaymentReconciliation');
  end;
  composeDomainResource(this, 'PaymentReconciliation', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PaymentReconciliation', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirProcessRequest}(this, 'PaymentReconciliation', 'request', elem.requestElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'PaymentReconciliation', 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'PaymentReconciliation', 'disposition', elem.dispositionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'PaymentReconciliation', 'ruleset', elem.rulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'PaymentReconciliation', 'originalRuleset', elem.originalRulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'PaymentReconciliation', 'created', elem.createdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'PaymentReconciliation', 'period', elem.periodElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'PaymentReconciliation', 'organization', elem.organizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'PaymentReconciliation', 'requestProvider', elem.requestProviderElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'PaymentReconciliation', 'requestOrganization', elem.requestOrganizationElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.detailList.Count - 1 do
      ComposePaymentReconciliationDetail(this, 'PaymentReconciliation', 'detail', elem.detailList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'PaymentReconciliation', 'form', elem.formElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'PaymentReconciliation', 'total', elem.totalElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.noteList.Count - 1 do
      ComposePaymentReconciliationNote(this, 'PaymentReconciliation', 'note', elem.noteList[i], i);
end;

function TFHIRXmlParser.ParsePersonLink(element : IXmlDomElement; path : string) : TFhirPersonLink;
var
  child : IXMLDOMElement;
begin
  result := TFhirPersonLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'target') then
        result.target := ParseReference{Resource}(child, path+'/target') {b}
      else if (child.baseName = 'assurance') then
        result.assuranceElement := ParseEnum(CODES_TFhirIdentityAssuranceLevelEnum, SYSTEMS_TFhirIdentityAssuranceLevelEnum, path+'/assurance', child){1a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePersonLink(xml : TXmlBuilder; name : string; elem : TFhirPersonLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'target', elem.target);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'assurance', elem.AssuranceElement, CODES_TFhirIdentityAssuranceLevelEnum);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePersonLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePersonLink(jsn)); {2}
end;

function TFHIRJsonParser.ParsePersonLink(jsn : TJsonObject) : TFhirPersonLink;
begin
  result := TFhirPersonLink.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('target') then
        result.target := ParseReference{Resource}(jsn.vObj['target']);{q}
    if jsn.has('assurance') or jsn.has('_assurance')  then
      result.assuranceElement := parseEnum(jsn.path+'/assurance', jsn['assurance'], jsn.vObj['_assurance'], CODES_TFhirIdentityAssuranceLevelEnum, SYSTEMS_TFhirIdentityAssuranceLevelEnum);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePersonLink(json : TJSONWriter; name : string; elem : TFhirPersonLink; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(json, 'target', elem.target); {a}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'assurance', elem.AssuranceElement, CODES_TFhirIdentityAssuranceLevelEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'assurance', elem.AssuranceElement, CODES_TFhirIdentityAssuranceLevelEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposePersonLink(parent :  TRDFComplex; parentType, name : String; elem : TFhirPersonLink; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:PersonLink');
  end;
  composeBackboneElement(this, 'PersonLink', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'PersonLink', 'target', elem.targetElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'PersonLink', 'assurance', elem.AssuranceElement, CODES_TFhirIdentityAssuranceLevelEnum, SYSTEMS_TFhirIdentityAssuranceLevelEnum, -1);
end;

function TFHIRXmlParser.ParsePerson(element : IXmlDomElement; path : string) : TFhirPerson;
var
  child : IXMLDOMElement;
begin
  result := TFhirPerson.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'name') then
        result.nameList.Add(ParseHumanName(child, path+'/name')){y.2}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'gender') then
        result.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.baseName = 'birthDate') then
        result.birthDateElement := ParseDate(child, path+'/birthDate') {b}
      else if (child.baseName = 'address') then
        result.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.baseName = 'photo') then
        result.photo := ParseAttachment(child, path+'/photo') {b}
      else if (child.baseName = 'managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.baseName = 'active') then
        result.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.baseName = 'link') then
        result.link_List.Add(ParsePersonLink(child, path+'/link')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePerson(xml : TXmlBuilder; name : string; elem : TFhirPerson);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(xml, 'name', elem.nameList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'birthDate', elem.birthDateElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(xml, 'address', elem.addressList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeAttachment(xml, 'photo', elem.photo);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.link_List.Count - 1 do
      ComposePersonLink(xml, 'link', elem.link_List[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePerson(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePerson(jsn)); {2}
end;

function TFHIRJsonParser.ParsePerson(jsn : TJsonObject) : TFhirPerson;
begin
  result := TFhirPerson.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('name') then
      iterateArray(jsn.vArr['name'], result.nameList, parseHumanName);
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDateElement := ParseDate(jsn['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('photo') then
        result.photo := ParseAttachment(jsn.vObj['photo']);{q}
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q}
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := ParseBoolean(jsn['active'], jsn.vObj['_active']);{q}
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parsePersonLink);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePerson(json : TJSONWriter; name : string; elem : TFhirPerson; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.nameList.Count > 0) then
  begin
    json.valueArray('name');
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(json, '', elem.nameList[i]); {z - HumanName}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.addressList.Count > 0) then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '', elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeAttachment(json, 'photo', elem.photo); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.link_List.Count > 0) then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposePersonLink(json, '', elem.link_List[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposePerson(parent :  TRDFComplex; parentType, name : String; elem : TFhirPerson; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Person');
  end;
  composeDomainResource(this, 'Person', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Person', 'identifier', elem.identifierList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(this, 'Person', 'name', elem.nameList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Person', 'telecom', elem.telecomList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Person', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'Person', 'birthDate', elem.birthDateElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'Person', 'address', elem.addressList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeAttachment(this, 'Person', 'photo', elem.photoElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Person', 'managingOrganization', elem.managingOrganizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Person', 'active', elem.activeElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.link_List.Count - 1 do
      ComposePersonLink(this, 'Person', 'link', elem.link_List[i], i);
end;

function TFHIRXmlParser.ParsePractitionerPractitionerRole(element : IXmlDomElement; path : string) : TFhirPractitionerPractitionerRole;
var
  child : IXMLDOMElement;
begin
  result := TFhirPractitionerPractitionerRole.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.baseName = 'role') then
        result.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.baseName = 'specialty') then
        result.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'location') then
        result.locationList.Add(ParseReference{TFhirLocation}(child, path+'/location')){y.2}
      else if (child.baseName = 'healthcareService') then
        result.healthcareServiceList.Add(ParseReference{TFhirHealthcareService}(child, path+'/healthcareService')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePractitionerPractitionerRole(xml : TXmlBuilder; name : string; elem : TFhirPractitionerPractitionerRole);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'role', elem.role);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialty', elem.specialtyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(xml, 'location', elem.locationList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.healthcareServiceList.Count - 1 do
      ComposeReference{TFhirHealthcareService}(xml, 'healthcareService', elem.healthcareServiceList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePractitionerPractitionerRole(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitionerPractitionerRole(jsn)); {2}
end;

function TFHIRJsonParser.ParsePractitionerPractitionerRole(jsn : TJsonObject) : TFhirPractitionerPractitionerRole;
begin
  result := TFhirPractitionerPractitionerRole.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q}
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q}
    if jsn.has('specialty') then
      iterateArray(jsn.vArr['specialty'], result.specialtyList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseReference{TFhirLocation});
    if jsn.has('healthcareService') then
      iterateArray(jsn.vArr['healthcareService'], result.healthcareServiceList, parseReference{TFhirHealthcareService});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePractitionerPractitionerRole(json : TJSONWriter; name : string; elem : TFhirPractitionerPractitionerRole; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'role', elem.role); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.specialtyList.Count > 0) then
  begin
    json.valueArray('specialty');
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.specialtyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) and (elem.locationList.Count > 0) then
  begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '', elem.locationList[i]); {z - Reference(Location)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.healthcareServiceList.Count > 0) then
  begin
    json.valueArray('healthcareService');
    for i := 0 to elem.healthcareServiceList.Count - 1 do
      ComposeReference{TFhirHealthcareService}(json, '', elem.healthcareServiceList[i]); {z - Reference(HealthcareService)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposePractitionerPractitionerRole(parent :  TRDFComplex; parentType, name : String; elem : TFhirPractitionerPractitionerRole; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:PractitionerPractitionerRole');
  end;
  composeBackboneElement(this, 'PractitionerPractitionerRole', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'PractitionerPractitionerRole', 'managingOrganization', elem.managingOrganizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'PractitionerPractitionerRole', 'role', elem.roleElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'PractitionerPractitionerRole', 'specialty', elem.specialtyList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'PractitionerPractitionerRole', 'period', elem.periodElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'PractitionerPractitionerRole', 'location', elem.locationList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.healthcareServiceList.Count - 1 do
      ComposeReference{TFhirHealthcareService}(this, 'PractitionerPractitionerRole', 'healthcareService', elem.healthcareServiceList[i], i);
end;

function TFHIRXmlParser.ParsePractitionerQualification(element : IXmlDomElement; path : string) : TFhirPractitionerQualification;
var
  child : IXMLDOMElement;
begin
  result := TFhirPractitionerQualification.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'issuer') then
        result.issuer := ParseReference{TFhirOrganization}(child, path+'/issuer') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePractitionerQualification(xml : TXmlBuilder; name : string; elem : TFhirPractitionerQualification);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'issuer', elem.issuer);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePractitionerQualification(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitionerQualification(jsn)); {2}
end;

function TFHIRJsonParser.ParsePractitionerQualification(jsn : TJsonObject) : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('issuer') then
        result.issuer := ParseReference{TFhirOrganization}(jsn.vObj['issuer']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePractitionerQualification(json : TJSONWriter; name : string; elem : TFhirPractitionerQualification; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'issuer', elem.issuer); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposePractitionerQualification(parent :  TRDFComplex; parentType, name : String; elem : TFhirPractitionerQualification; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:PractitionerQualification');
  end;
  composeBackboneElement(this, 'PractitionerQualification', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PractitionerQualification', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PractitionerQualification', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'PractitionerQualification', 'period', elem.periodElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'PractitionerQualification', 'issuer', elem.issuerElement, -1);{x.2}
end;

function TFHIRXmlParser.ParsePractitioner(element : IXmlDomElement; path : string) : TFhirPractitioner;
var
  child : IXMLDOMElement;
begin
  result := TFhirPractitioner.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'active') then
        result.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.baseName = 'name') then
        result.name := ParseHumanName(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'address') then
        result.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.baseName = 'gender') then
        result.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.baseName = 'birthDate') then
        result.birthDateElement := ParseDate(child, path+'/birthDate') {b}
      else if (child.baseName = 'photo') then
        result.photoList.Add(ParseAttachment(child, path+'/photo')){y.2}
      else if (child.baseName = 'practitionerRole') then
        result.practitionerRoleList.Add(ParsePractitionerPractitionerRole(child, path+'/practitionerRole')){y.2}
      else if (child.baseName = 'qualification') then
        result.qualificationList.Add(ParsePractitionerQualification(child, path+'/qualification')){y.2}
      else if (child.baseName = 'communication') then
        result.communicationList.Add(ParseCodeableConcept(child, path+'/communication')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePractitioner(xml : TXmlBuilder; name : string; elem : TFhirPractitioner);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeHumanName(xml, 'name', elem.name);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(xml, 'address', elem.addressList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'birthDate', elem.birthDateElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', elem.photoList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.practitionerRoleList.Count - 1 do
      ComposePractitionerPractitionerRole(xml, 'practitionerRole', elem.practitionerRoleList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.qualificationList.Count - 1 do
      ComposePractitionerQualification(xml, 'qualification', elem.qualificationList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'communication', elem.communicationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePractitioner(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitioner(jsn)); {2}
end;

function TFHIRJsonParser.ParsePractitioner(jsn : TJsonObject) : TFhirPractitioner;
begin
  result := TFhirPractitioner.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := ParseBoolean(jsn['active'], jsn.vObj['_active']);{q}
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDateElement := ParseDate(jsn['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    if jsn.has('practitionerRole') then
      iterateArray(jsn.vArr['practitionerRole'], result.practitionerRoleList, parsePractitionerPractitionerRole);
    if jsn.has('qualification') then
      iterateArray(jsn.vArr['qualification'], result.qualificationList, parsePractitionerQualification);
    if jsn.has('communication') then
      iterateArray(jsn.vArr['communication'], result.communicationList, parseCodeableConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePractitioner(json : TJSONWriter; name : string; elem : TFhirPractitioner; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeHumanName(json, 'name', elem.name); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.addressList.Count > 0) then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '', elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.photoList.Count > 0) then
  begin
    json.valueArray('photo');
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '', elem.photoList[i]); {z - Attachment}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.practitionerRoleList.Count > 0) then
  begin
    json.valueArray('practitionerRole');
    for i := 0 to elem.practitionerRoleList.Count - 1 do
      ComposePractitionerPractitionerRole(json, '', elem.practitionerRoleList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.qualificationList.Count > 0) then
  begin
    json.valueArray('qualification');
    for i := 0 to elem.qualificationList.Count - 1 do
      ComposePractitionerQualification(json, '', elem.qualificationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.communicationList.Count > 0) then
  begin
    json.valueArray('communication');
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.communicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposePractitioner(parent :  TRDFComplex; parentType, name : String; elem : TFhirPractitioner; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Practitioner');
  end;
  composeDomainResource(this, 'Practitioner', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Practitioner', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Practitioner', 'active', elem.activeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeHumanName(this, 'Practitioner', 'name', elem.nameElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Practitioner', 'telecom', elem.telecomList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'Practitioner', 'address', elem.addressList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Practitioner', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'Practitioner', 'birthDate', elem.birthDateElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(this, 'Practitioner', 'photo', elem.photoList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.practitionerRoleList.Count - 1 do
      ComposePractitionerPractitionerRole(this, 'Practitioner', 'practitionerRole', elem.practitionerRoleList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.qualificationList.Count - 1 do
      ComposePractitionerQualification(this, 'Practitioner', 'qualification', elem.qualificationList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(this, 'Practitioner', 'communication', elem.communicationList[i], i);
end;

function TFHIRXmlParser.ParseProcedurePerformer(element : IXmlDomElement; path : string) : TFhirProcedurePerformer;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcedurePerformer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'actor') then
        result.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.baseName = 'role') then
        result.role := ParseCodeableConcept(child, path+'/role') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcedurePerformer(xml : TXmlBuilder; name : string; elem : TFhirProcedurePerformer);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'role', elem.role);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcedurePerformer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedurePerformer(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedurePerformer(jsn : TJsonObject) : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('actor') then
        result.actor := ParseReference{Resource}(jsn.vObj['actor']);{q}
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcedurePerformer(json : TJSONWriter; name : string; elem : TFhirProcedurePerformer; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'actor', elem.actor); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'role', elem.role); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeProcedurePerformer(parent :  TRDFComplex; parentType, name : String; elem : TFhirProcedurePerformer; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ProcedurePerformer');
  end;
  composeBackboneElement(this, 'ProcedurePerformer', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'ProcedurePerformer', 'actor', elem.actorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ProcedurePerformer', 'role', elem.roleElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseProcedureFocalDevice(element : IXmlDomElement; path : string) : TFhirProcedureFocalDevice;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcedureFocalDevice.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'action') then
        result.action := ParseCodeableConcept(child, path+'/action') {b}
      else if (child.baseName = 'manipulated') then
        result.manipulated := ParseReference{TFhirDevice}(child, path+'/manipulated') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcedureFocalDevice(xml : TXmlBuilder; name : string; elem : TFhirProcedureFocalDevice);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'action', elem.action);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirDevice}(xml, 'manipulated', elem.manipulated);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcedureFocalDevice(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedureFocalDevice(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedureFocalDevice(jsn : TJsonObject) : TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('action') then
        result.action := ParseCodeableConcept(jsn.vObj['action']);{q}
    if jsn.has('manipulated') then
        result.manipulated := ParseReference{TFhirDevice}(jsn.vObj['manipulated']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcedureFocalDevice(json : TJSONWriter; name : string; elem : TFhirProcedureFocalDevice; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'action', elem.action); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirDevice}(json, 'manipulated', elem.manipulated); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeProcedureFocalDevice(parent :  TRDFComplex; parentType, name : String; elem : TFhirProcedureFocalDevice; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ProcedureFocalDevice');
  end;
  composeBackboneElement(this, 'ProcedureFocalDevice', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ProcedureFocalDevice', 'action', elem.actionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirDevice}(this, 'ProcedureFocalDevice', 'manipulated', elem.manipulatedElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseProcedure(element : IXmlDomElement; path : string) : TFhirProcedure;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcedure.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirProcedureStatusEnum, SYSTEMS_TFhirProcedureStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'notPerformed') then
        result.notPerformedElement := ParseBoolean(child, path+'/notPerformed') {b}
      else if (child.baseName = 'reasonNotPerformed') then
        result.reasonNotPerformedList.Add(ParseCodeableConcept(child, path+'/reasonNotPerformed')){y.2}
      else if (child.baseName = 'bodySite') then
        result.bodySiteList.Add(ParseCodeableConcept(child, path+'/bodySite')){y.2}
      else if (child.baseName = 'reasonCodeableConcept') then
        result.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.baseName = 'reasonReference') then
        result.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.baseName = 'performer') then
        result.performerList.Add(ParseProcedurePerformer(child, path+'/performer')){y.2}
      else if (child.baseName = 'performedDateTime') then
        result.performed := ParseDateTime(child, path+'/performedDateTime'){x.3}
      else if (child.baseName = 'performedPeriod') then
        result.performed := ParsePeriod(child, path+'/performedPeriod'){x.3}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'outcome') then
        result.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.baseName = 'report') then
        result.reportList.Add(ParseReference{TFhirDiagnosticReport}(child, path+'/report')){y.2}
      else if (child.baseName = 'complication') then
        result.complicationList.Add(ParseCodeableConcept(child, path+'/complication')){y.2}
      else if (child.baseName = 'followUp') then
        result.followUpList.Add(ParseCodeableConcept(child, path+'/followUp')){y.2}
      else if (child.baseName = 'request') then
        result.request := ParseReference{Resource}(child, path+'/request') {b}
      else if (child.baseName = 'notes') then
        result.notesList.Add(ParseAnnotation(child, path+'/notes')){y.2}
      else if (child.baseName = 'focalDevice') then
        result.focalDeviceList.Add(ParseProcedureFocalDevice(child, path+'/focalDevice')){y.2}
      else if (child.baseName = 'used') then
        result.usedList.Add(ParseReference{Resource}(child, path+'/used')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcedure(xml : TXmlBuilder; name : string; elem : TFhirProcedure);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirProcedureStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'notPerformed', elem.notPerformedElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reasonNotPerformedList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonNotPerformed', elem.reasonNotPerformedList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'bodySite', elem.bodySiteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeProcedurePerformer(xml, 'performer', elem.performerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'performedDateTime', TFhirDateTime(elem.performed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirPeriod) {6} then
    ComposePeriod(xml, 'performedPeriod', TFhirPeriod(elem.performed));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reportList.Count - 1 do
      ComposeReference{TFhirDiagnosticReport}(xml, 'report', elem.reportList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.complicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'complication', elem.complicationList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.followUpList.Count - 1 do
      ComposeCodeableConcept(xml, 'followUp', elem.followUpList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'request', elem.request);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeAnnotation(xml, 'notes', elem.notesList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.focalDeviceList.Count - 1 do
      ComposeProcedureFocalDevice(xml, 'focalDevice', elem.focalDeviceList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.usedList.Count - 1 do
      ComposeReference{Resource}(xml, 'used', elem.usedList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedure(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedure(jsn : TJsonObject) : TFhirProcedure;
begin
  result := TFhirProcedure.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirProcedureStatusEnum, SYSTEMS_TFhirProcedureStatusEnum);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('notPerformed') or jsn.has('_notPerformed') then
        result.notPerformedElement := ParseBoolean(jsn['notPerformed'], jsn.vObj['_notPerformed']);{q}
    if jsn.has('reasonNotPerformed') then
      iterateArray(jsn.vArr['reasonNotPerformed'], result.reasonNotPerformedList, parseCodeableConcept);
    if jsn.has('bodySite') then
      iterateArray(jsn.vArr['bodySite'], result.bodySiteList, parseCodeableConcept);
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseProcedurePerformer);
    if jsn.has('performedDateTime') or jsn.has('_performedDateTime') then
      result.performed := parseDateTime(jsn['performedDateTime'], jsn.vObj['_performedDateTime']);
    if jsn.has('performedPeriod') {a4} then
      result.performed := ParsePeriod(jsn.vObj['performedPeriod']);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('outcome') then
        result.outcome := ParseCodeableConcept(jsn.vObj['outcome']);{q}
    if jsn.has('report') then
      iterateArray(jsn.vArr['report'], result.reportList, parseReference{TFhirDiagnosticReport});
    if jsn.has('complication') then
      iterateArray(jsn.vArr['complication'], result.complicationList, parseCodeableConcept);
    if jsn.has('followUp') then
      iterateArray(jsn.vArr['followUp'], result.followUpList, parseCodeableConcept);
    if jsn.has('request') then
        result.request := ParseReference{Resource}(jsn.vObj['request']);{q}
    if jsn.has('notes') then
      iterateArray(jsn.vArr['notes'], result.notesList, parseAnnotation);
    if jsn.has('focalDevice') then
      iterateArray(jsn.vArr['focalDevice'], result.focalDeviceList, parseProcedureFocalDevice);
    if jsn.has('used') then
      iterateArray(jsn.vArr['used'], result.usedList, parseReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcedure(json : TJSONWriter; name : string; elem : TFhirProcedure; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirProcedureStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirProcedureStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'notPerformed', elem.notPerformedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'notPerformed', elem.notPerformedElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.reasonNotPerformedList.Count > 0) then
  begin
    json.valueArray('reasonNotPerformed');
    for i := 0 to elem.reasonNotPerformedList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonNotPerformedList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySiteList.Count > 0) then
  begin
    json.valueArray('bodySite');
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.bodySiteList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.performerList.Count > 0) then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeProcedurePerformer(json, '', elem.performerList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'performedDateTime', TFhirDateTime(elem.performed), false);
    ComposeDateTimeProps(json, 'performedDateTime', TFhirDateTime(elem.performed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirPeriod) then 
    ComposePeriod(json, 'performedPeriod', TFhirPeriod(elem.performed)) ;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'outcome', elem.outcome); {a}
  if (SummaryOption in [soFull, soData]) and (elem.reportList.Count > 0) then
  begin
    json.valueArray('report');
    for i := 0 to elem.reportList.Count - 1 do
      ComposeReference{TFhirDiagnosticReport}(json, '', elem.reportList[i]); {z - Reference(DiagnosticReport)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.complicationList.Count > 0) then
  begin
    json.valueArray('complication');
    for i := 0 to elem.complicationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.complicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.followUpList.Count > 0) then
  begin
    json.valueArray('followUp');
    for i := 0 to elem.followUpList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.followUpList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soData]) and (elem.notesList.Count > 0) then
  begin
    json.valueArray('notes');
    for i := 0 to elem.notesList.Count - 1 do
      ComposeAnnotation(json, '', elem.notesList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.focalDeviceList.Count > 0) then
  begin
    json.valueArray('focalDevice');
    for i := 0 to elem.focalDeviceList.Count - 1 do
      ComposeProcedureFocalDevice(json, '', elem.focalDeviceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.usedList.Count > 0) then
  begin
    json.valueArray('used');
    for i := 0 to elem.usedList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.usedList[i]); {z - Reference(Device|Medication|Substance)}
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeProcedure(parent :  TRDFComplex; parentType, name : String; elem : TFhirProcedure; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Procedure');
  end;
  composeDomainResource(this, 'Procedure', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Procedure', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Procedure', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Procedure', 'status', elem.StatusElement, CODES_TFhirProcedureStatusEnum, SYSTEMS_TFhirProcedureStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Procedure', 'category', elem.categoryElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Procedure', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Procedure', 'notPerformed', elem.notPerformedElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reasonNotPerformedList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'reasonNotPerformed', elem.reasonNotPerformedList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'bodySite', elem.bodySiteList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Procedure', 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(this, 'Procedure', 'reasonReference', TFhirReference(elem.reason), -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeProcedurePerformer(this, 'Procedure', 'performer', elem.performerList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Procedure', 'performedDateTime', TFhirDateTime(elem.performed), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirPeriod) {6} then
    ComposePeriod(this, 'Procedure', 'performedPeriod', TFhirPeriod(elem.performed), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'Procedure', 'encounter', elem.encounterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(this, 'Procedure', 'location', elem.locationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Procedure', 'outcome', elem.outcomeElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.reportList.Count - 1 do
      ComposeReference{TFhirDiagnosticReport}(this, 'Procedure', 'report', elem.reportList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.complicationList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'complication', elem.complicationList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.followUpList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'followUp', elem.followUpList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'Procedure', 'request', elem.requestElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeAnnotation(this, 'Procedure', 'notes', elem.notesList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.focalDeviceList.Count - 1 do
      ComposeProcedureFocalDevice(this, 'Procedure', 'focalDevice', elem.focalDeviceList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.usedList.Count - 1 do
      ComposeReference{Resource}(this, 'Procedure', 'used', elem.usedList[i], i);
end;

function TFHIRXmlParser.ParseProcedureRequest(element : IXmlDomElement; path : string) : TFhirProcedureRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcedureRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'bodySite') then
        result.bodySiteList.Add(ParseCodeableConcept(child, path+'/bodySite')){y.2}
      else if (child.baseName = 'reasonCodeableConcept') then
        result.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.baseName = 'reasonReference') then
        result.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.baseName = 'scheduledDateTime') then
        result.scheduled := ParseDateTime(child, path+'/scheduledDateTime'){x.3}
      else if (child.baseName = 'scheduledPeriod') then
        result.scheduled := ParsePeriod(child, path+'/scheduledPeriod'){x.3}
      else if (child.baseName = 'scheduledTiming') then
        result.scheduled := ParseTiming(child, path+'/scheduledTiming'){x.3}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'performer') then
        result.performer := ParseReference{Resource}(child, path+'/performer') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirProcedureRequestStatusEnum, SYSTEMS_TFhirProcedureRequestStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'notes') then
        result.notesList.Add(ParseAnnotation(child, path+'/notes')){y.2}
      else if (child.baseName = 'asNeededBoolean') then
        result.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.baseName = 'asNeededCodeableConcept') then
        result.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.baseName = 'orderedOn') then
        result.orderedOnElement := ParseDateTime(child, path+'/orderedOn') {b}
      else if (child.baseName = 'orderer') then
        result.orderer := ParseReference{Resource}(child, path+'/orderer') {b}
      else if (child.baseName = 'priority') then
        result.priorityElement := ParseEnum(CODES_TFhirProcedureRequestPriorityEnum, SYSTEMS_TFhirProcedureRequestPriorityEnum, path+'/priority', child){1a}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcedureRequest(xml : TXmlBuilder; name : string; elem : TFhirProcedureRequest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'bodySite', elem.bodySiteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'scheduledDateTime', TFhirDateTime(elem.scheduled))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(xml, 'scheduledPeriod', TFhirPeriod(elem.scheduled))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirTiming) {6} then
    ComposeTiming(xml, 'scheduledTiming', TFhirTiming(elem.scheduled));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'performer', elem.performer);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirProcedureRequestStatusEnum);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeAnnotation(xml, 'notes', elem.notesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'orderedOn', elem.orderedOnElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'orderer', elem.orderer);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'priority', elem.PriorityElement, CODES_TFhirProcedureRequestPriorityEnum);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcedureRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedureRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedureRequest(jsn : TJsonObject) : TFhirProcedureRequest;
begin
  result := TFhirProcedureRequest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('bodySite') then
      iterateArray(jsn.vArr['bodySite'], result.bodySiteList, parseCodeableConcept);
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('scheduledDateTime') or jsn.has('_scheduledDateTime') then
      result.scheduled := parseDateTime(jsn['scheduledDateTime'], jsn.vObj['_scheduledDateTime']);
    if jsn.has('scheduledPeriod') {a4} then
      result.scheduled := ParsePeriod(jsn.vObj['scheduledPeriod']);
    if jsn.has('scheduledTiming') {a4} then
      result.scheduled := ParseTiming(jsn.vObj['scheduledTiming']);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('performer') then
        result.performer := ParseReference{Resource}(jsn.vObj['performer']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirProcedureRequestStatusEnum, SYSTEMS_TFhirProcedureRequestStatusEnum);
    if jsn.has('notes') then
      iterateArray(jsn.vArr['notes'], result.notesList, parseAnnotation);
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('orderedOn') or jsn.has('_orderedOn') then
        result.orderedOnElement := ParseDateTime(jsn['orderedOn'], jsn.vObj['_orderedOn']);{q}
    if jsn.has('orderer') then
        result.orderer := ParseReference{Resource}(jsn.vObj['orderer']);{q}
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn.path+'/priority', jsn['priority'], jsn.vObj['_priority'], CODES_TFhirProcedureRequestPriorityEnum, SYSTEMS_TFhirProcedureRequestPriorityEnum);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcedureRequest(json : TJSONWriter; name : string; elem : TFhirProcedureRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySiteList.Count > 0) then
  begin
    json.valueArray('bodySite');
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.bodySiteList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'scheduledDateTime', TFhirDateTime(elem.scheduled), false);
    ComposeDateTimeProps(json, 'scheduledDateTime', TFhirDateTime(elem.scheduled), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirPeriod) then 
    ComposePeriod(json, 'scheduledPeriod', TFhirPeriod(elem.scheduled)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirTiming) then 
    ComposeTiming(json, 'scheduledTiming', TFhirTiming(elem.scheduled)) ;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'performer', elem.performer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirProcedureRequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirProcedureRequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.notesList.Count > 0) then
  begin
    json.valueArray('notes');
    for i := 0 to elem.notesList.Count - 1 do
      ComposeAnnotation(json, '', elem.notesList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) ;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'orderedOn', elem.orderedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'orderedOn', elem.orderedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'orderer', elem.orderer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirProcedureRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirProcedureRequestPriorityEnum, false);
end;

procedure TFHIRRDFComposer.ComposeProcedureRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirProcedureRequest; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ProcedureRequest');
  end;
  composeDomainResource(this, 'ProcedureRequest', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ProcedureRequest', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'ProcedureRequest', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ProcedureRequest', 'code', elem.codeElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ProcedureRequest', 'bodySite', elem.bodySiteList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ProcedureRequest', 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(this, 'ProcedureRequest', 'reasonReference', TFhirReference(elem.reason), -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ProcedureRequest', 'scheduledDateTime', TFhirDateTime(elem.scheduled), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(this, 'ProcedureRequest', 'scheduledPeriod', TFhirPeriod(elem.scheduled), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirTiming) {6} then
    ComposeTiming(this, 'ProcedureRequest', 'scheduledTiming', TFhirTiming(elem.scheduled), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'ProcedureRequest', 'encounter', elem.encounterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'ProcedureRequest', 'performer', elem.performerElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ProcedureRequest', 'status', elem.StatusElement, CODES_TFhirProcedureRequestStatusEnum, SYSTEMS_TFhirProcedureRequestStatusEnum, -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeAnnotation(this, 'ProcedureRequest', 'notes', elem.notesList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ProcedureRequest', 'asNeededBoolean', TFhirBoolean(elem.asNeeded), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ProcedureRequest', 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ProcedureRequest', 'orderedOn', elem.orderedOnElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'ProcedureRequest', 'orderer', elem.ordererElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ProcedureRequest', 'priority', elem.PriorityElement, CODES_TFhirProcedureRequestPriorityEnum, SYSTEMS_TFhirProcedureRequestPriorityEnum, -1);
end;

function TFHIRXmlParser.ParseProcessRequestItem(element : IXmlDomElement; path : string) : TFhirProcessRequestItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcessRequestItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'sequenceLinkId') then
        result.sequenceLinkIdElement := ParseInteger(child, path+'/sequenceLinkId') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcessRequestItem(xml : TXmlBuilder; name : string; elem : TFhirProcessRequestItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcessRequestItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcessRequestItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcessRequestItem(jsn : TJsonObject) : TFhirProcessRequestItem;
begin
  result := TFhirProcessRequestItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
        result.sequenceLinkIdElement := ParseInteger(jsn['sequenceLinkId'], jsn.vObj['_sequenceLinkId']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcessRequestItem(json : TJSONWriter; name : string; elem : TFhirProcessRequestItem; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeProcessRequestItem(parent :  TRDFComplex; parentType, name : String; elem : TFhirProcessRequestItem; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ProcessRequestItem');
  end;
  composeBackboneElement(this, 'ProcessRequestItem', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'ProcessRequestItem', 'sequenceLinkId', elem.sequenceLinkIdElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseProcessRequest(element : IXmlDomElement; path : string) : TFhirProcessRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcessRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'action') then
        result.actionElement := ParseEnum(CODES_TFhirActionlistEnum, SYSTEMS_TFhirActionlistEnum, path+'/action', child){1a}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'target') then
        result.target := ParseReference{TFhirOrganization}(child, path+'/target') {b}
      else if (child.baseName = 'provider') then
        result.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirReference}(child, path+'/request') {b}
      else if (child.baseName = 'response') then
        result.response := ParseReference{TFhirReference}(child, path+'/response') {b}
      else if (child.baseName = 'nullify') then
        result.nullifyElement := ParseBoolean(child, path+'/nullify') {b}
      else if (child.baseName = 'reference') then
        result.referenceElement := ParseString(child, path+'/reference') {b}
      else if (child.baseName = 'item') then
        result.itemList.Add(ParseProcessRequestItem(child, path+'/item')){y.2}
      else if (child.baseName = 'include') then
        result.includeList.Add(ParseString(child, path+'/include')){y.2}
      else if (child.baseName = 'exclude') then
        result.excludeList.Add(ParseString(child, path+'/exclude')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcessRequest(xml : TXmlBuilder; name : string; elem : TFhirProcessRequest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'action', elem.ActionElement, CODES_TFhirActionlistEnum);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'target', elem.target);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'request', elem.request);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'response', elem.response);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'nullify', elem.nullifyElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'reference', elem.referenceElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeProcessRequestItem(xml, 'item', elem.itemList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.includeList.Count - 1 do
      ComposeString(xml, 'include', elem.includeList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeString(xml, 'exclude', elem.excludeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcessRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcessRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcessRequest(jsn : TJsonObject) : TFhirProcessRequest;
begin
  result := TFhirProcessRequest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('action') or jsn.has('_action')  then
      result.actionElement := parseEnum(jsn.path+'/action', jsn['action'], jsn.vObj['_action'], CODES_TFhirActionlistEnum, SYSTEMS_TFhirActionlistEnum);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirOrganization}(jsn.vObj['target']);{q}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('request') then
        result.request := ParseReference{TFhirReference}(jsn.vObj['request']);{q}
    if jsn.has('response') then
        result.response := ParseReference{TFhirReference}(jsn.vObj['response']);{q}
    if jsn.has('nullify') or jsn.has('_nullify') then
        result.nullifyElement := ParseBoolean(jsn['nullify'], jsn.vObj['_nullify']);{q}
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceElement := ParseString(jsn['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseProcessRequestItem);
      if jsn.has('include') or jsn.has('_include') then
      iteratePrimitiveArray(jsn.vArr['include'], jsn.vArr['_include'], result.includeList, parseString);
      if jsn.has('exclude') or jsn.has('_exclude') then
      iteratePrimitiveArray(jsn.vArr['exclude'], jsn.vArr['_exclude'], result.excludeList, parseString);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcessRequest(json : TJSONWriter; name : string; elem : TFhirProcessRequest; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'action', elem.ActionElement, CODES_TFhirActionlistEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'action', elem.ActionElement, CODES_TFhirActionlistEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'target', elem.target); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'response', elem.response); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'nullify', elem.nullifyElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'nullify', elem.nullifyElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.itemList.Count > 0) then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeProcessRequestItem(json, '', elem.itemList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.includeList.Count > 0) then
  begin
    json.valueArray('include');
    ext := false;
    for i := 0 to elem.includeList.Count - 1 do
    begin
      ext := ext or ((elem.includeList[i].id <> '') or (elem.includeList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.includeList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_include');
      for i := 0 to elem.includeList.Count - 1 do
        ComposeStringProps(json, '',elem.includeList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.excludeList.Count > 0) then
  begin
    json.valueArray('exclude');
    ext := false;
    for i := 0 to elem.excludeList.Count - 1 do
    begin
      ext := ext or ((elem.excludeList[i].id <> '') or (elem.excludeList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.excludeList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_exclude');
      for i := 0 to elem.excludeList.Count - 1 do
        ComposeStringProps(json, '',elem.excludeList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
end;

procedure TFHIRRDFComposer.ComposeProcessRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirProcessRequest; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ProcessRequest');
  end;
  composeDomainResource(this, 'ProcessRequest', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ProcessRequest', 'action', elem.ActionElement, CODES_TFhirActionlistEnum, SYSTEMS_TFhirActionlistEnum, -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ProcessRequest', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ProcessRequest', 'ruleset', elem.rulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ProcessRequest', 'originalRuleset', elem.originalRulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ProcessRequest', 'created', elem.createdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'ProcessRequest', 'target', elem.targetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'ProcessRequest', 'provider', elem.providerElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'ProcessRequest', 'organization', elem.organizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'ProcessRequest', 'request', elem.requestElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'ProcessRequest', 'response', elem.responseElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ProcessRequest', 'nullify', elem.nullifyElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ProcessRequest', 'reference', elem.referenceElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeProcessRequestItem(this, 'ProcessRequest', 'item', elem.itemList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.includeList.Count - 1 do
      ComposeString(this, 'ProcessRequest', 'include', elem.includeList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeString(this, 'ProcessRequest', 'exclude', elem.excludeList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'ProcessRequest', 'period', elem.periodElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseProcessResponseNotes(element : IXmlDomElement; path : string) : TFhirProcessResponseNotes;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcessResponseNotes.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcessResponseNotes(xml : TXmlBuilder; name : string; elem : TFhirProcessResponseNotes);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcessResponseNotes(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcessResponseNotes(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcessResponseNotes(jsn : TJsonObject) : TFhirProcessResponseNotes;
begin
  result := TFhirProcessResponseNotes.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcessResponseNotes(json : TJSONWriter; name : string; elem : TFhirProcessResponseNotes; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeProcessResponseNotes(parent :  TRDFComplex; parentType, name : String; elem : TFhirProcessResponseNotes; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ProcessResponseNotes');
  end;
  composeBackboneElement(this, 'ProcessResponseNotes', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ProcessResponseNotes', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ProcessResponseNotes', 'text', elem.textElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseProcessResponse(element : IXmlDomElement; path : string) : TFhirProcessResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcessResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'request') then
        result.request := ParseReference{TFhirReference}(child, path+'/request') {b}
      else if (child.baseName = 'outcome') then
        result.outcome := ParseCoding(child, path+'/outcome') {b}
      else if (child.baseName = 'disposition') then
        result.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.baseName = 'ruleset') then
        result.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.baseName = 'originalRuleset') then
        result.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.baseName = 'created') then
        result.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.baseName = 'requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if (child.baseName = 'form') then
        result.form := ParseCoding(child, path+'/form') {b}
      else if (child.baseName = 'notes') then
        result.notesList.Add(ParseProcessResponseNotes(child, path+'/notes')){y.2}
      else if (child.baseName = 'error') then
        result.errorList.Add(ParseCoding(child, path+'/error')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcessResponse(xml : TXmlBuilder; name : string; elem : TFhirProcessResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'request', elem.request);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'outcome', elem.outcome);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'form', elem.form);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeProcessResponseNotes(xml, 'notes', elem.notesList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.errorList.Count - 1 do
      ComposeCoding(xml, 'error', elem.errorList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcessResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcessResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcessResponse(jsn : TJsonObject) : TFhirProcessResponse;
begin
  result := TFhirProcessResponse.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirReference}(jsn.vObj['request']);{q}
    if jsn.has('outcome') then
        result.outcome := ParseCoding(jsn.vObj['outcome']);{q}
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q}
    if jsn.has('form') then
        result.form := ParseCoding(jsn.vObj['form']);{q}
    if jsn.has('notes') then
      iterateArray(jsn.vArr['notes'], result.notesList, parseProcessResponseNotes);
    if jsn.has('error') then
      iterateArray(jsn.vArr['error'], result.errorList, parseCoding);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcessResponse(json : TJSONWriter; name : string; elem : TFhirProcessResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'outcome', elem.outcome); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'form', elem.form); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.notesList.Count > 0) then
  begin
    json.valueArray('notes');
    for i := 0 to elem.notesList.Count - 1 do
      ComposeProcessResponseNotes(json, '', elem.notesList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.errorList.Count > 0) then
  begin
    json.valueArray('error');
    for i := 0 to elem.errorList.Count - 1 do
      ComposeCoding(json, '', elem.errorList[i]); {z - Coding}
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeProcessResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirProcessResponse; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ProcessResponse');
  end;
  composeDomainResource(this, 'ProcessResponse', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ProcessResponse', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'ProcessResponse', 'request', elem.requestElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ProcessResponse', 'outcome', elem.outcomeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ProcessResponse', 'disposition', elem.dispositionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ProcessResponse', 'ruleset', elem.rulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ProcessResponse', 'originalRuleset', elem.originalRulesetElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ProcessResponse', 'created', elem.createdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'ProcessResponse', 'organization', elem.organizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'ProcessResponse', 'requestProvider', elem.requestProviderElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'ProcessResponse', 'requestOrganization', elem.requestOrganizationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ProcessResponse', 'form', elem.formElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeProcessResponseNotes(this, 'ProcessResponse', 'notes', elem.notesList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.errorList.Count - 1 do
      ComposeCoding(false, this, 'ProcessResponse', 'error', elem.errorList[i], i);
end;

function TFHIRXmlParser.ParseProvenanceAgent(element : IXmlDomElement; path : string) : TFhirProvenanceAgent;
var
  child : IXMLDOMElement;
begin
  result := TFhirProvenanceAgent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'role') then
        result.role := ParseCoding(child, path+'/role') {b}
      else if (child.baseName = 'actor') then
        result.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.baseName = 'userId') then
        result.userId := ParseIdentifier(child, path+'/userId') {b}
      else if (child.baseName = 'relatedAgent') then
        result.relatedAgentList.Add(ParseProvenanceAgentRelatedAgent(child, path+'/relatedAgent')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProvenanceAgent(xml : TXmlBuilder; name : string; elem : TFhirProvenanceAgent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'role', elem.role);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'userId', elem.userId);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.relatedAgentList.Count - 1 do
      ComposeProvenanceAgentRelatedAgent(xml, 'relatedAgent', elem.relatedAgentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProvenanceAgent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenanceAgent(jsn)); {2}
end;

function TFHIRJsonParser.ParseProvenanceAgent(jsn : TJsonObject) : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
        result.role := ParseCoding(jsn.vObj['role']);{q}
    if jsn.has('actor') then
        result.actor := ParseReference{Resource}(jsn.vObj['actor']);{q}
    if jsn.has('userId') then
        result.userId := ParseIdentifier(jsn.vObj['userId']);{q}
    if jsn.has('relatedAgent') then
      iterateArray(jsn.vArr['relatedAgent'], result.relatedAgentList, parseProvenanceAgentRelatedAgent);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProvenanceAgent(json : TJSONWriter; name : string; elem : TFhirProvenanceAgent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'role', elem.role); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'actor', elem.actor); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'userId', elem.userId); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.relatedAgentList.Count > 0) then
  begin
    json.valueArray('relatedAgent');
    for i := 0 to elem.relatedAgentList.Count - 1 do
      ComposeProvenanceAgentRelatedAgent(json, '', elem.relatedAgentList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeProvenanceAgent(parent :  TRDFComplex; parentType, name : String; elem : TFhirProvenanceAgent; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ProvenanceAgent');
  end;
  composeBackboneElement(this, 'ProvenanceAgent', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ProvenanceAgent', 'role', elem.roleElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'ProvenanceAgent', 'actor', elem.actorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'ProvenanceAgent', 'userId', elem.userIdElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.relatedAgentList.Count - 1 do
      ComposeProvenanceAgentRelatedAgent(this, 'ProvenanceAgent', 'relatedAgent', elem.relatedAgentList[i], i);
end;

function TFHIRXmlParser.ParseProvenanceAgentRelatedAgent(element : IXmlDomElement; path : string) : TFhirProvenanceAgentRelatedAgent;
var
  child : IXMLDOMElement;
begin
  result := TFhirProvenanceAgentRelatedAgent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'target') then
        result.targetElement := ParseUri(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProvenanceAgentRelatedAgent(xml : TXmlBuilder; name : string; elem : TFhirProvenanceAgentRelatedAgent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'target', elem.targetElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProvenanceAgentRelatedAgent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenanceAgentRelatedAgent(jsn)); {2}
end;

function TFHIRJsonParser.ParseProvenanceAgentRelatedAgent(jsn : TJsonObject) : TFhirProvenanceAgentRelatedAgent;
begin
  result := TFhirProvenanceAgentRelatedAgent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('target') or jsn.has('_target') then
        result.targetElement := ParseUri(jsn['target'], jsn.vObj['_target']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProvenanceAgentRelatedAgent(json : TJSONWriter; name : string; elem : TFhirProvenanceAgentRelatedAgent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'target', elem.targetElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'target', elem.targetElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeProvenanceAgentRelatedAgent(parent :  TRDFComplex; parentType, name : String; elem : TFhirProvenanceAgentRelatedAgent; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ProvenanceAgentRelatedAgent');
  end;
  composeBackboneElement(this, 'ProvenanceAgentRelatedAgent', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ProvenanceAgentRelatedAgent', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ProvenanceAgentRelatedAgent', 'target', elem.targetElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseProvenanceEntity(element : IXmlDomElement; path : string) : TFhirProvenanceEntity;
var
  child : IXMLDOMElement;
begin
  result := TFhirProvenanceEntity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'role') then
        result.roleElement := ParseEnum(CODES_TFhirProvenanceEntityRoleEnum, SYSTEMS_TFhirProvenanceEntityRoleEnum, path+'/role', child){1a}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'reference') then
        result.referenceElement := ParseUri(child, path+'/reference') {b}
      else if (child.baseName = 'display') then
        result.displayElement := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'agent') then
        result.agent := ParseProvenanceAgent(child, path+'/agent') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProvenanceEntity(xml : TXmlBuilder; name : string; elem : TFhirProvenanceEntity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'role', elem.RoleElement, CODES_TFhirProvenanceEntityRoleEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'reference', elem.referenceElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeProvenanceAgent(xml, 'agent', elem.agent);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProvenanceEntity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenanceEntity(jsn)); {2}
end;

function TFHIRJsonParser.ParseProvenanceEntity(jsn : TJsonObject) : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') or jsn.has('_role')  then
      result.roleElement := parseEnum(jsn.path+'/role', jsn['role'], jsn.vObj['_role'], CODES_TFhirProvenanceEntityRoleEnum, SYSTEMS_TFhirProvenanceEntityRoleEnum);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceElement := ParseUri(jsn['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('agent') then
        result.agent := ParseProvenanceAgent(jsn.vObj['agent']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProvenanceEntity(json : TJSONWriter; name : string; elem : TFhirProvenanceEntity; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'role', elem.RoleElement, CODES_TFhirProvenanceEntityRoleEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'role', elem.RoleElement, CODES_TFhirProvenanceEntityRoleEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeProvenanceAgent(json, 'agent', elem.agent); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeProvenanceEntity(parent :  TRDFComplex; parentType, name : String; elem : TFhirProvenanceEntity; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ProvenanceEntity');
  end;
  composeBackboneElement(this, 'ProvenanceEntity', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ProvenanceEntity', 'role', elem.RoleElement, CODES_TFhirProvenanceEntityRoleEnum, SYSTEMS_TFhirProvenanceEntityRoleEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'ProvenanceEntity', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ProvenanceEntity', 'reference', elem.referenceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ProvenanceEntity', 'display', elem.displayElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeProvenanceAgent(this, 'ProvenanceEntity', 'agent', elem.agentElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseProvenance(element : IXmlDomElement; path : string) : TFhirProvenance;
var
  child : IXMLDOMElement;
begin
  result := TFhirProvenance.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'target') then
        result.targetList.Add(ParseReference{TFhirReference}(child, path+'/target')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'recorded') then
        result.recordedElement := ParseInstant(child, path+'/recorded') {b}
      else if (child.baseName = 'reason') then
        result.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.baseName = 'activity') then
        result.activity := ParseCodeableConcept(child, path+'/activity') {b}
      else if (child.baseName = 'location') then
        result.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'policy') then
        result.policyList.Add(ParseUri(child, path+'/policy')){y.2}
      else if (child.baseName = 'agent') then
        result.agentList.Add(ParseProvenanceAgent(child, path+'/agent')){y.2}
      else if (child.baseName = 'entity') then
        result.entityList.Add(ParseProvenanceEntity(child, path+'/entity')){y.2}
      else if (child.baseName = 'signature') then
        result.signatureList.Add(ParseSignature(child, path+'/signature')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProvenance(xml : TXmlBuilder; name : string; elem : TFhirProvenance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.targetList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'target', elem.targetList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'recorded', elem.recordedElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'activity', elem.activity);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.policyList.Count - 1 do
      ComposeUri(xml, 'policy', elem.policyList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.agentList.Count - 1 do
      ComposeProvenanceAgent(xml, 'agent', elem.agentList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.entityList.Count - 1 do
      ComposeProvenanceEntity(xml, 'entity', elem.entityList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.signatureList.Count - 1 do
      ComposeSignature(xml, 'signature', elem.signatureList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProvenance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenance(jsn)); {2}
end;

function TFHIRJsonParser.ParseProvenance(jsn : TJsonObject) : TFhirProvenance;
begin
  result := TFhirProvenance.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('target') then
      iterateArray(jsn.vArr['target'], result.targetList, parseReference{TFhirReference});
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('recorded') or jsn.has('_recorded') then
        result.recordedElement := ParseInstant(jsn['recorded'], jsn.vObj['_recorded']);{q}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('activity') then
        result.activity := ParseCodeableConcept(jsn.vObj['activity']);{q}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q}
      if jsn.has('policy') or jsn.has('_policy') then
      iteratePrimitiveArray(jsn.vArr['policy'], jsn.vArr['_policy'], result.policyList, parseUri);
    if jsn.has('agent') then
      iterateArray(jsn.vArr['agent'], result.agentList, parseProvenanceAgent);
    if jsn.has('entity') then
      iterateArray(jsn.vArr['entity'], result.entityList, parseProvenanceEntity);
    if jsn.has('signature') then
      iterateArray(jsn.vArr['signature'], result.signatureList, parseSignature);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProvenance(json : TJSONWriter; name : string; elem : TFhirProvenance; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.targetList.Count > 0) then
  begin
    json.valueArray('target');
    for i := 0 to elem.targetList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.targetList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantValue(json, 'recorded', elem.recordedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantProps(json, 'recorded', elem.recordedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonList.Count > 0) then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'activity', elem.activity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.policyList.Count > 0) then
  begin
    json.valueArray('policy');
    ext := false;
    for i := 0 to elem.policyList.Count - 1 do
    begin
      ext := ext or ((elem.policyList[i].id <> '') or (elem.policyList[i].hasExtensionList));
      ComposeUriValue(json, '',elem.policyList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_policy');
      for i := 0 to elem.policyList.Count - 1 do
        ComposeUriProps(json, '',elem.policyList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.agentList.Count > 0) then
  begin
    json.valueArray('agent');
    for i := 0 to elem.agentList.Count - 1 do
      ComposeProvenanceAgent(json, '', elem.agentList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.entityList.Count > 0) then
  begin
    json.valueArray('entity');
    for i := 0 to elem.entityList.Count - 1 do
      ComposeProvenanceEntity(json, '', elem.entityList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.signatureList.Count > 0) then
  begin
    json.valueArray('signature');
    for i := 0 to elem.signatureList.Count - 1 do
      ComposeSignature(json, '', elem.signatureList[i]); {z - Signature}
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeProvenance(parent :  TRDFComplex; parentType, name : String; elem : TFhirProvenance; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Provenance');
  end;
  composeDomainResource(this, 'Provenance', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.targetList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Provenance', 'target', elem.targetList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Provenance', 'period', elem.periodElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'Provenance', 'recorded', elem.recordedElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Provenance', 'reason', elem.reasonList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Provenance', 'activity', elem.activityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(this, 'Provenance', 'location', elem.locationElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.policyList.Count - 1 do
      ComposeUri(this, 'Provenance', 'policy', elem.policyList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.agentList.Count - 1 do
      ComposeProvenanceAgent(this, 'Provenance', 'agent', elem.agentList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.entityList.Count - 1 do
      ComposeProvenanceEntity(this, 'Provenance', 'entity', elem.entityList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.signatureList.Count - 1 do
      ComposeSignature(this, 'Provenance', 'signature', elem.signatureList[i], i);
end;

function TFHIRXmlParser.ParseQuestionnaireGroup(element : IXmlDomElement; path : string) : TFhirQuestionnaireGroup;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'linkId') then
        result.linkIdElement := ParseString(child, path+'/linkId') {b}
      else if (child.baseName = 'title') then
        result.titleElement := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseCoding(child, path+'/concept')){y.2}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'required') then
        result.requiredElement := ParseBoolean(child, path+'/required') {b}
      else if (child.baseName = 'repeats') then
        result.repeatsElement := ParseBoolean(child, path+'/repeats') {b}
      else if (child.baseName = 'group') then
        result.groupList.Add(ParseQuestionnaireGroup(child, path+'/group')){y.2}
      else if (child.baseName = 'question') then
        result.questionList.Add(ParseQuestionnaireGroupQuestion(child, path+'/question')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireGroup(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroup);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'linkId', elem.linkIdElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', elem.titleElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCoding(xml, 'concept', elem.conceptList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'required', elem.requiredElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'repeats', elem.repeatsElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(xml, 'group', elem.groupList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.questionList.Count - 1 do
      ComposeQuestionnaireGroupQuestion(xml, 'question', elem.questionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireGroup(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireGroup(jsn : TJsonObject) : TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdElement := ParseString(jsn['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseCoding);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('required') or jsn.has('_required') then
        result.requiredElement := ParseBoolean(jsn['required'], jsn.vObj['_required']);{q}
    if jsn.has('repeats') or jsn.has('_repeats') then
        result.repeatsElement := ParseBoolean(jsn['repeats'], jsn.vObj['_repeats']);{q}
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireGroup);
    if jsn.has('question') then
      iterateArray(jsn.vArr['question'], result.questionList, parseQuestionnaireGroupQuestion);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.conceptList.Count > 0) then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCoding(json, '', elem.conceptList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'required', elem.requiredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'required', elem.requiredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'repeats', elem.repeatsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'repeats', elem.repeatsElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.groupList.Count > 0) then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(json, '', elem.groupList[i]); {z - @Questionnaire.group}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.questionList.Count > 0) then
  begin
    json.valueArray('question');
    for i := 0 to elem.questionList.Count - 1 do
      ComposeQuestionnaireGroupQuestion(json, '', elem.questionList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeQuestionnaireGroup(parent :  TRDFComplex; parentType, name : String; elem : TFhirQuestionnaireGroup; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:QuestionnaireGroup');
  end;
  composeBackboneElement(this, 'QuestionnaireGroup', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'QuestionnaireGroup', 'linkId', elem.linkIdElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'QuestionnaireGroup', 'title', elem.titleElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCoding(false, this, 'QuestionnaireGroup', 'concept', elem.conceptList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'QuestionnaireGroup', 'text', elem.textElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'QuestionnaireGroup', 'required', elem.requiredElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'QuestionnaireGroup', 'repeats', elem.repeatsElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(this, 'QuestionnaireGroup', 'group', elem.groupList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.questionList.Count - 1 do
      ComposeQuestionnaireGroupQuestion(this, 'QuestionnaireGroup', 'question', elem.questionList[i], i);
end;

function TFHIRXmlParser.ParseQuestionnaireGroupQuestion(element : IXmlDomElement; path : string) : TFhirQuestionnaireGroupQuestion;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireGroupQuestion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'linkId') then
        result.linkIdElement := ParseString(child, path+'/linkId') {b}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseCoding(child, path+'/concept')){y.2}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirAnswerFormatEnum, SYSTEMS_TFhirAnswerFormatEnum, path+'/type', child){1a}
      else if (child.baseName = 'required') then
        result.requiredElement := ParseBoolean(child, path+'/required') {b}
      else if (child.baseName = 'repeats') then
        result.repeatsElement := ParseBoolean(child, path+'/repeats') {b}
      else if (child.baseName = 'options') then
        result.options := ParseReference{TFhirValueSet}(child, path+'/options') {b}
      else if (child.baseName = 'option') then
        result.optionList.Add(ParseCoding(child, path+'/option')){y.2}
      else if (child.baseName = 'group') then
        result.groupList.Add(ParseQuestionnaireGroup(child, path+'/group')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireGroupQuestion(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroupQuestion);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'linkId', elem.linkIdElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCoding(xml, 'concept', elem.conceptList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirAnswerFormatEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'required', elem.requiredElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'repeats', elem.repeatsElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirValueSet}(xml, 'options', elem.options);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.optionList.Count - 1 do
      ComposeCoding(xml, 'option', elem.optionList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(xml, 'group', elem.groupList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireGroupQuestion(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdElement := ParseString(jsn['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseCoding);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirAnswerFormatEnum, SYSTEMS_TFhirAnswerFormatEnum);
    if jsn.has('required') or jsn.has('_required') then
        result.requiredElement := ParseBoolean(jsn['required'], jsn.vObj['_required']);{q}
    if jsn.has('repeats') or jsn.has('_repeats') then
        result.repeatsElement := ParseBoolean(jsn['repeats'], jsn.vObj['_repeats']);{q}
    if jsn.has('options') then
        result.options := ParseReference{TFhirValueSet}(jsn.vObj['options']);{q}
    if jsn.has('option') then
      iterateArray(jsn.vArr['option'], result.optionList, parseCoding);
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireGroup);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroupQuestion; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.conceptList.Count > 0) then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCoding(json, '', elem.conceptList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirAnswerFormatEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirAnswerFormatEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'required', elem.requiredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'required', elem.requiredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'repeats', elem.repeatsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'repeats', elem.repeatsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirValueSet}(json, 'options', elem.options); {a}
  if (SummaryOption in [soFull, soData]) and (elem.optionList.Count > 0) then
  begin
    json.valueArray('option');
    for i := 0 to elem.optionList.Count - 1 do
      ComposeCoding(json, '', elem.optionList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.groupList.Count > 0) then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(json, '', elem.groupList[i]); {z - @Questionnaire.group}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeQuestionnaireGroupQuestion(parent :  TRDFComplex; parentType, name : String; elem : TFhirQuestionnaireGroupQuestion; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:QuestionnaireGroupQuestion');
  end;
  composeBackboneElement(this, 'QuestionnaireGroupQuestion', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'QuestionnaireGroupQuestion', 'linkId', elem.linkIdElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCoding(false, this, 'QuestionnaireGroupQuestion', 'concept', elem.conceptList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'QuestionnaireGroupQuestion', 'text', elem.textElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'QuestionnaireGroupQuestion', 'type', elem.Type_Element, CODES_TFhirAnswerFormatEnum, SYSTEMS_TFhirAnswerFormatEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'QuestionnaireGroupQuestion', 'required', elem.requiredElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'QuestionnaireGroupQuestion', 'repeats', elem.repeatsElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirValueSet}(this, 'QuestionnaireGroupQuestion', 'options', elem.optionsElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.optionList.Count - 1 do
      ComposeCoding(false, this, 'QuestionnaireGroupQuestion', 'option', elem.optionList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(this, 'QuestionnaireGroupQuestion', 'group', elem.groupList[i], i);
end;

function TFHIRXmlParser.ParseQuestionnaire(element : IXmlDomElement; path : string) : TFhirQuestionnaire;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaire.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirQuestionnaireStatusEnum, SYSTEMS_TFhirQuestionnaireStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'subjectType') then
        result.subjectType.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/subjectType', child)){y.1}
      else if (child.baseName = 'group') then
        result.group := ParseQuestionnaireGroup(child, path+'/group') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaire(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaire);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirQuestionnaireStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.subjectType.Count - 1 do
      ComposeEnum(xml, 'subjectType', elem.subjectType[i], CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuestionnaireGroup(xml, 'group', elem.group);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaire(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaire(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaire(jsn : TJsonObject) : TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirQuestionnaireStatusEnum, SYSTEMS_TFhirQuestionnaireStatusEnum);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('subjectType') or jsn.has('_subjectType') then
      iterateEnumArray(jsn.vArr['subjectType'], jsn.vArr['_subjectType'], jsn.path+'/subjectType', result.subjectType, parseEnum, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('group') then
        result.group := ParseQuestionnaireGroup(jsn.vObj['group']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaire(json : TJSONWriter; name : string; elem : TFhirQuestionnaire; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirQuestionnaireStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirQuestionnaireStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.subjectType.Count > 0) then
  begin
    json.valueArray('subjectType');
    ext := false;
    for i := 0 to elem.subjectType.Count - 1 do
    begin
      ext := ext or ((elem.subjectType[i].id <> '') or (elem.subjectType[i].hasExtensionList));
      ComposeEnumValue(json, '', elem.subjectType[i], CODES_TFhirResourceTypesEnum, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_subjectType');
      for i := 0 to elem.subjectType.Count - 1 do
        ComposeEnumProps(json, '', elem.subjectType[i], CODES_TFhirResourceTypesEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuestionnaireGroup(json, 'group', elem.group); {a}
end;

procedure TFHIRRDFComposer.ComposeQuestionnaire(parent :  TRDFComplex; parentType, name : String; elem : TFhirQuestionnaire; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Questionnaire');
  end;
  composeDomainResource(this, 'Questionnaire', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Questionnaire', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Questionnaire', 'version', elem.versionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Questionnaire', 'status', elem.StatusElement, CODES_TFhirQuestionnaireStatusEnum, SYSTEMS_TFhirQuestionnaireStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Questionnaire', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Questionnaire', 'publisher', elem.publisherElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Questionnaire', 'telecom', elem.telecomList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.subjectType.Count - 1 do
      ComposeEnum(this, 'Questionnaire', 'subjectType', elem.subjectType[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.subjectType.Count - 1 do
      ComposeEnum(this, 'Questionnaire', 'subjectType', elem.subjectType[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuestionnaireGroup(this, 'Questionnaire', 'group', elem.groupElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseQuestionnaireResponseGroup(element : IXmlDomElement; path : string) : TFhirQuestionnaireResponseGroup;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireResponseGroup.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'linkId') then
        result.linkIdElement := ParseString(child, path+'/linkId') {b}
      else if (child.baseName = 'title') then
        result.titleElement := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.baseName = 'group') then
        result.groupList.Add(ParseQuestionnaireResponseGroup(child, path+'/group')){y.2}
      else if (child.baseName = 'question') then
        result.questionList.Add(ParseQuestionnaireResponseGroupQuestion(child, path+'/question')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseGroup(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireResponseGroup);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'linkId', elem.linkIdElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', elem.titleElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireResponseGroup(xml, 'group', elem.groupList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.questionList.Count - 1 do
      ComposeQuestionnaireResponseGroupQuestion(xml, 'question', elem.questionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireResponseGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireResponseGroup(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireResponseGroup(jsn : TJsonObject) : TFhirQuestionnaireResponseGroup;
begin
  result := TFhirQuestionnaireResponseGroup.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdElement := ParseString(jsn['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q}
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireResponseGroup);
    if jsn.has('question') then
      iterateArray(jsn.vArr['question'], result.questionList, parseQuestionnaireResponseGroupQuestion);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireResponseGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponseGroup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soData]) and (elem.groupList.Count > 0) then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireResponseGroup(json, '', elem.groupList[i]); {z - @QuestionnaireResponse.group}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.questionList.Count > 0) then
  begin
    json.valueArray('question');
    for i := 0 to elem.questionList.Count - 1 do
      ComposeQuestionnaireResponseGroupQuestion(json, '', elem.questionList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeQuestionnaireResponseGroup(parent :  TRDFComplex; parentType, name : String; elem : TFhirQuestionnaireResponseGroup; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:QuestionnaireResponseGroup');
  end;
  composeBackboneElement(this, 'QuestionnaireResponseGroup', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'QuestionnaireResponseGroup', 'linkId', elem.linkIdElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'QuestionnaireResponseGroup', 'title', elem.titleElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'QuestionnaireResponseGroup', 'text', elem.textElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'QuestionnaireResponseGroup', 'subject', elem.subjectElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireResponseGroup(this, 'QuestionnaireResponseGroup', 'group', elem.groupList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.questionList.Count - 1 do
      ComposeQuestionnaireResponseGroupQuestion(this, 'QuestionnaireResponseGroup', 'question', elem.questionList[i], i);
end;

function TFHIRXmlParser.ParseQuestionnaireResponseGroupQuestion(element : IXmlDomElement; path : string) : TFhirQuestionnaireResponseGroupQuestion;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireResponseGroupQuestion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'linkId') then
        result.linkIdElement := ParseString(child, path+'/linkId') {b}
      else if (child.baseName = 'text') then
        result.textElement := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'answer') then
        result.answerList.Add(ParseQuestionnaireResponseGroupQuestionAnswer(child, path+'/answer')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseGroupQuestion(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireResponseGroupQuestion);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'linkId', elem.linkIdElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.answerList.Count - 1 do
      ComposeQuestionnaireResponseGroupQuestionAnswer(xml, 'answer', elem.answerList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireResponseGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireResponseGroupQuestion(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireResponseGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireResponseGroupQuestion;
begin
  result := TFhirQuestionnaireResponseGroupQuestion.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdElement := ParseString(jsn['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('answer') then
      iterateArray(jsn.vArr['answer'], result.answerList, parseQuestionnaireResponseGroupQuestionAnswer);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireResponseGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponseGroupQuestion; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.answerList.Count > 0) then
  begin
    json.valueArray('answer');
    for i := 0 to elem.answerList.Count - 1 do
      ComposeQuestionnaireResponseGroupQuestionAnswer(json, '', elem.answerList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeQuestionnaireResponseGroupQuestion(parent :  TRDFComplex; parentType, name : String; elem : TFhirQuestionnaireResponseGroupQuestion; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:QuestionnaireResponseGroupQuestion');
  end;
  composeBackboneElement(this, 'QuestionnaireResponseGroupQuestion', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'QuestionnaireResponseGroupQuestion', 'linkId', elem.linkIdElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'QuestionnaireResponseGroupQuestion', 'text', elem.textElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.answerList.Count - 1 do
      ComposeQuestionnaireResponseGroupQuestionAnswer(this, 'QuestionnaireResponseGroupQuestion', 'answer', elem.answerList[i], i);
end;

function TFHIRXmlParser.ParseQuestionnaireResponseGroupQuestionAnswer(element : IXmlDomElement; path : string) : TFhirQuestionnaireResponseGroupQuestionAnswer;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireResponseGroupQuestionAnswer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.baseName = 'valueDecimal') then
        result.value := ParseDecimal(child, path+'/valueDecimal'){x.3}
      else if (child.baseName = 'valueInteger') then
        result.value := ParseInteger(child, path+'/valueInteger'){x.3}
      else if (child.baseName = 'valueDate') then
        result.value := ParseDate(child, path+'/valueDate'){x.3}
      else if (child.baseName = 'valueDateTime') then
        result.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.baseName = 'valueInstant') then
        result.value := ParseInstant(child, path+'/valueInstant'){x.3}
      else if (child.baseName = 'valueTime') then
        result.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.baseName = 'valueUri') then
        result.value := ParseUri(child, path+'/valueUri'){x.3}
      else if (child.baseName = 'valueAttachment') then
        result.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.baseName = 'valueCoding') then
        result.value := ParseCoding(child, path+'/valueCoding'){x.3}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.baseName = 'valueReference') then
        result.value := ParseReference(child, path+'/valueReference') {a}
      else if (child.baseName = 'group') then
        result.groupList.Add(ParseQuestionnaireResponseGroup(child, path+'/group')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseGroupQuestionAnswer(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireResponseGroupQuestionAnswer);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInstant) {6} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) {2} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value));
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireResponseGroup(xml, 'group', elem.groupList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireResponseGroupQuestionAnswer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireResponseGroupQuestionAnswer(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireResponseGroupQuestionAnswer(jsn : TJsonObject) : TFhirQuestionnaireResponseGroupQuestionAnswer;
begin
  result := TFhirQuestionnaireResponseGroupQuestionAnswer.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := parseDecimal(jsn['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
      result.value := parseDate(jsn['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
      result.value := parseInstant(jsn['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
      result.value := parseUri(jsn['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueCoding') {a4} then
      result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueReference') {a3} then
      result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireResponseGroup);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireResponseGroupQuestionAnswer(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponseGroupQuestionAnswer; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDate) then 
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInstant) then 
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCoding) then 
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value));
  if (SummaryOption in [soFull, soData]) and (elem.groupList.Count > 0) then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireResponseGroup(json, '', elem.groupList[i]); {z - @QuestionnaireResponse.group}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeQuestionnaireResponseGroupQuestionAnswer(parent :  TRDFComplex; parentType, name : String; elem : TFhirQuestionnaireResponseGroupQuestionAnswer; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:QuestionnaireResponseGroupQuestionAnswer');
  end;
  composeBackboneElement(this, 'QuestionnaireResponseGroupQuestionAnswer', name, elem, index);
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'QuestionnaireResponseGroupQuestionAnswer', 'valueBoolean', TFhirBoolean(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'QuestionnaireResponseGroupQuestionAnswer', 'valueDecimal', TFhirDecimal(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'QuestionnaireResponseGroupQuestionAnswer', 'valueInteger', TFhirInteger(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'QuestionnaireResponseGroupQuestionAnswer', 'valueDate', TFhirDate(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'QuestionnaireResponseGroupQuestionAnswer', 'valueDateTime', TFhirDateTime(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInstant) {6} then
    ComposeInstant(this, 'QuestionnaireResponseGroupQuestionAnswer', 'valueInstant', TFhirInstant(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'QuestionnaireResponseGroupQuestionAnswer', 'valueTime', TFhirTime(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'QuestionnaireResponseGroupQuestionAnswer', 'valueString', TFhirString(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'QuestionnaireResponseGroupQuestionAnswer', 'valueUri', TFhirUri(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'QuestionnaireResponseGroupQuestionAnswer', 'valueAttachment', TFhirAttachment(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCoding) {6} then
    ComposeCoding(false, this, 'QuestionnaireResponseGroupQuestionAnswer', 'valueCoding', TFhirCoding(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'QuestionnaireResponseGroupQuestionAnswer', 'valueQuantity', TFhirQuantity(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) {2} then
    ComposeReference(this, 'QuestionnaireResponseGroupQuestionAnswer', 'valueReference', TFhirReference(elem.value), -1);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireResponseGroup(this, 'QuestionnaireResponseGroupQuestionAnswer', 'group', elem.groupList[i], i);
end;

function TFHIRXmlParser.ParseQuestionnaireResponse(element : IXmlDomElement; path : string) : TFhirQuestionnaireResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'questionnaire') then
        result.questionnaire := ParseReference{TFhirQuestionnaire}(child, path+'/questionnaire') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirQuestionnaireAnswersStatusEnum, SYSTEMS_TFhirQuestionnaireAnswersStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.baseName = 'author') then
        result.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'authored') then
        result.authoredElement := ParseDateTime(child, path+'/authored') {b}
      else if (child.baseName = 'source') then
        result.source := ParseReference{Resource}(child, path+'/source') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'group') then
        result.group := ParseQuestionnaireResponseGroup(child, path+'/group') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponse(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireResponse);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirQuestionnaire}(xml, 'questionnaire', elem.questionnaire);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirQuestionnaireAnswersStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'authored', elem.authoredElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'source', elem.source);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuestionnaireResponseGroup(xml, 'group', elem.group);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireResponse(jsn : TJsonObject) : TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('questionnaire') then
        result.questionnaire := ParseReference{TFhirQuestionnaire}(jsn.vObj['questionnaire']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirQuestionnaireAnswersStatusEnum, SYSTEMS_TFhirQuestionnaireAnswersStatusEnum);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('authored') or jsn.has('_authored') then
        result.authoredElement := ParseDateTime(jsn['authored'], jsn.vObj['_authored']);{q}
    if jsn.has('source') then
        result.source := ParseReference{Resource}(jsn.vObj['source']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('group') then
        result.group := ParseQuestionnaireResponseGroup(jsn.vObj['group']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireResponse(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponse; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirQuestionnaire}(json, 'questionnaire', elem.questionnaire); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirQuestionnaireAnswersStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirQuestionnaireAnswersStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'authored', elem.authoredElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'authored', elem.authoredElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuestionnaireResponseGroup(json, 'group', elem.group); {a}
end;

procedure TFHIRRDFComposer.ComposeQuestionnaireResponse(parent :  TRDFComplex; parentType, name : String; elem : TFhirQuestionnaireResponse; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:QuestionnaireResponse');
  end;
  composeDomainResource(this, 'QuestionnaireResponse', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'QuestionnaireResponse', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirQuestionnaire}(this, 'QuestionnaireResponse', 'questionnaire', elem.questionnaireElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'QuestionnaireResponse', 'status', elem.StatusElement, CODES_TFhirQuestionnaireAnswersStatusEnum, SYSTEMS_TFhirQuestionnaireAnswersStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'QuestionnaireResponse', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'QuestionnaireResponse', 'author', elem.authorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'QuestionnaireResponse', 'authored', elem.authoredElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'QuestionnaireResponse', 'source', elem.sourceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'QuestionnaireResponse', 'encounter', elem.encounterElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuestionnaireResponseGroup(this, 'QuestionnaireResponse', 'group', elem.groupElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseReferralRequest(element : IXmlDomElement; path : string) : TFhirReferralRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirReferralRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirReferralstatusEnum, SYSTEMS_TFhirReferralstatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'specialty') then
        result.specialty := ParseCodeableConcept(child, path+'/specialty') {b}
      else if (child.baseName = 'priority') then
        result.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'requester') then
        result.requester := ParseReference{Resource}(child, path+'/requester') {b}
      else if (child.baseName = 'recipient') then
        result.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'dateSent') then
        result.dateSentElement := ParseDateTime(child, path+'/dateSent') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'serviceRequested') then
        result.serviceRequestedList.Add(ParseCodeableConcept(child, path+'/serviceRequested')){y.2}
      else if (child.baseName = 'supportingInformation') then
        result.supportingInformationList.Add(ParseReference{TFhirReference}(child, path+'/supportingInformation')){y.2}
      else if (child.baseName = 'fulfillmentTime') then
        result.fulfillmentTime := ParsePeriod(child, path+'/fulfillmentTime') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeReferralRequest(xml : TXmlBuilder; name : string; elem : TFhirReferralRequest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirReferralstatusEnum);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'specialty', elem.specialty);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'requester', elem.requester);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'dateSent', elem.dateSentElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.serviceRequestedList.Count - 1 do
      ComposeCodeableConcept(xml, 'serviceRequested', elem.serviceRequestedList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'supportingInformation', elem.supportingInformationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'fulfillmentTime', elem.fulfillmentTime);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseReferralRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseReferralRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseReferralRequest(jsn : TJsonObject) : TFhirReferralRequest;
begin
  result := TFhirReferralRequest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirReferralstatusEnum, SYSTEMS_TFhirReferralstatusEnum);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('specialty') then
        result.specialty := ParseCodeableConcept(jsn.vObj['specialty']);{q}
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('requester') then
        result.requester := ParseReference{Resource}(jsn.vObj['requester']);{q}
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{Resource});
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('dateSent') or jsn.has('_dateSent') then
        result.dateSentElement := ParseDateTime(jsn['dateSent'], jsn.vObj['_dateSent']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('serviceRequested') then
      iterateArray(jsn.vArr['serviceRequested'], result.serviceRequestedList, parseCodeableConcept);
    if jsn.has('supportingInformation') then
      iterateArray(jsn.vArr['supportingInformation'], result.supportingInformationList, parseReference{TFhirReference});
    if jsn.has('fulfillmentTime') then
        result.fulfillmentTime := ParsePeriod(jsn.vObj['fulfillmentTime']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeReferralRequest(json : TJSONWriter; name : string; elem : TFhirReferralRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirReferralstatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirReferralstatusEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'specialty', elem.specialty); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'requester', elem.requester); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.recipientList.Count > 0) then
  begin
    json.valueArray('recipient');
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.recipientList[i]); {z - Reference(Practitioner|Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'dateSent', elem.dateSentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'dateSent', elem.dateSentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.serviceRequestedList.Count > 0) then
  begin
    json.valueArray('serviceRequested');
    for i := 0 to elem.serviceRequestedList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.serviceRequestedList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.supportingInformationList.Count > 0) then
  begin
    json.valueArray('supportingInformation');
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.supportingInformationList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'fulfillmentTime', elem.fulfillmentTime); {a}
end;

procedure TFHIRRDFComposer.ComposeReferralRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirReferralRequest; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ReferralRequest');
  end;
  composeDomainResource(this, 'ReferralRequest', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ReferralRequest', 'status', elem.StatusElement, CODES_TFhirReferralstatusEnum, SYSTEMS_TFhirReferralstatusEnum, -1);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ReferralRequest', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ReferralRequest', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ReferralRequest', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ReferralRequest', 'specialty', elem.specialtyElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ReferralRequest', 'priority', elem.priorityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'ReferralRequest', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'ReferralRequest', 'requester', elem.requesterElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(this, 'ReferralRequest', 'recipient', elem.recipientList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(this, 'ReferralRequest', 'encounter', elem.encounterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ReferralRequest', 'dateSent', elem.dateSentElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ReferralRequest', 'reason', elem.reasonElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ReferralRequest', 'description', elem.descriptionElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.serviceRequestedList.Count - 1 do
      ComposeCodeableConcept(this, 'ReferralRequest', 'serviceRequested', elem.serviceRequestedList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'ReferralRequest', 'supportingInformation', elem.supportingInformationList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'ReferralRequest', 'fulfillmentTime', elem.fulfillmentTimeElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseRelatedPerson(element : IXmlDomElement; path : string) : TFhirRelatedPerson;
var
  child : IXMLDOMElement;
begin
  result := TFhirRelatedPerson.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'relationship') then
        result.relationship := ParseCodeableConcept(child, path+'/relationship') {b}
      else if (child.baseName = 'name') then
        result.name := ParseHumanName(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.baseName = 'gender') then
        result.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.baseName = 'birthDate') then
        result.birthDateElement := ParseDate(child, path+'/birthDate') {b}
      else if (child.baseName = 'address') then
        result.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.baseName = 'photo') then
        result.photoList.Add(ParseAttachment(child, path+'/photo')){y.2}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRelatedPerson(xml : TXmlBuilder; name : string; elem : TFhirRelatedPerson);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'relationship', elem.relationship);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeHumanName(xml, 'name', elem.name);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'birthDate', elem.birthDateElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(xml, 'address', elem.addressList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', elem.photoList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRelatedPerson(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRelatedPerson(jsn)); {2}
end;

function TFHIRJsonParser.ParseRelatedPerson(jsn : TJsonObject) : TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCodeableConcept(jsn.vObj['relationship']);{q}
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDateElement := ParseDate(jsn['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRelatedPerson(json : TJSONWriter; name : string; elem : TFhirRelatedPerson; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'relationship', elem.relationship); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeHumanName(json, 'name', elem.name); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.addressList.Count > 0) then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '', elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.photoList.Count > 0) then
  begin
    json.valueArray('photo');
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '', elem.photoList[i]); {z - Attachment}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
end;

procedure TFHIRRDFComposer.ComposeRelatedPerson(parent :  TRDFComplex; parentType, name : String; elem : TFhirRelatedPerson; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:RelatedPerson');
  end;
  composeDomainResource(this, 'RelatedPerson', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'RelatedPerson', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'RelatedPerson', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'RelatedPerson', 'relationship', elem.relationshipElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeHumanName(this, 'RelatedPerson', 'name', elem.nameElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'RelatedPerson', 'telecom', elem.telecomList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'RelatedPerson', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'RelatedPerson', 'birthDate', elem.birthDateElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'RelatedPerson', 'address', elem.addressList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(this, 'RelatedPerson', 'photo', elem.photoList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'RelatedPerson', 'period', elem.periodElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseRiskAssessmentPrediction(element : IXmlDomElement; path : string) : TFhirRiskAssessmentPrediction;
var
  child : IXMLDOMElement;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'outcome') then
        result.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.baseName = 'probabilityDecimal') then
        result.probability := ParseDecimal(child, path+'/probabilityDecimal'){x.3}
      else if (child.baseName = 'probabilityRange') then
        result.probability := ParseRange(child, path+'/probabilityRange'){x.3}
      else if (child.baseName = 'probabilityCodeableConcept') then
        result.probability := ParseCodeableConcept(child, path+'/probabilityCodeableConcept'){x.3}
      else if (child.baseName = 'relativeRisk') then
        result.relativeRiskElement := ParseDecimal(child, path+'/relativeRisk') {b}
      else if (child.baseName = 'whenPeriod') then
        result.when := ParsePeriod(child, path+'/whenPeriod'){x.3}
      else if (child.baseName = 'whenRange') then
        result.when := ParseRange(child, path+'/whenRange'){x.3}
      else if (child.baseName = 'rationale') then
        result.rationaleElement := ParseString(child, path+'/rationale') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessmentPrediction(xml : TXmlBuilder; name : string; elem : TFhirRiskAssessmentPrediction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'probabilityDecimal', TFhirDecimal(elem.probability))
  else if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirRange) {6} then
    ComposeRange(xml, 'probabilityRange', TFhirRange(elem.probability))
  else if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'probabilityCodeableConcept', TFhirCodeableConcept(elem.probability));
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'relativeRisk', elem.relativeRiskElement);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.when is TFhirPeriod) {6} then
    ComposePeriod(xml, 'whenPeriod', TFhirPeriod(elem.when))
  else if (SummaryOption in [soFull, soData]) and (elem.when is TFhirRange) {6} then
    ComposeRange(xml, 'whenRange', TFhirRange(elem.when));
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'rationale', elem.rationaleElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRiskAssessmentPrediction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRiskAssessmentPrediction(jsn)); {2}
end;

function TFHIRJsonParser.ParseRiskAssessmentPrediction(jsn : TJsonObject) : TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('outcome') then
        result.outcome := ParseCodeableConcept(jsn.vObj['outcome']);{q}
    if jsn.has('probabilityDecimal') or jsn.has('_probabilityDecimal') then
      result.probability := parseDecimal(jsn['probabilityDecimal'], jsn.vObj['_probabilityDecimal']);
    if jsn.has('probabilityRange') {a4} then
      result.probability := ParseRange(jsn.vObj['probabilityRange']);
    if jsn.has('probabilityCodeableConcept') {a4} then
      result.probability := ParseCodeableConcept(jsn.vObj['probabilityCodeableConcept']);
    if jsn.has('relativeRisk') or jsn.has('_relativeRisk') then
        result.relativeRiskElement := ParseDecimal(jsn['relativeRisk'], jsn.vObj['_relativeRisk']);{q}
    if jsn.has('whenPeriod') {a4} then
      result.when := ParsePeriod(jsn.vObj['whenPeriod']);
    if jsn.has('whenRange') {a4} then
      result.when := ParseRange(jsn.vObj['whenRange']);
    if jsn.has('rationale') or jsn.has('_rationale') then
        result.rationaleElement := ParseString(jsn['rationale'], jsn.vObj['_rationale']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRiskAssessmentPrediction(json : TJSONWriter; name : string; elem : TFhirRiskAssessmentPrediction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'outcome', elem.outcome); {a}
  if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'probabilityDecimal', TFhirDecimal(elem.probability), false);
    ComposeDecimalProps(json, 'probabilityDecimal', TFhirDecimal(elem.probability), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirRange) then 
    ComposeRange(json, 'probabilityRange', TFhirRange(elem.probability)) 
  else if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'probabilityCodeableConcept', TFhirCodeableConcept(elem.probability)) ;
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'relativeRisk', elem.relativeRiskElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'relativeRisk', elem.relativeRiskElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.when is TFhirPeriod) then 
    ComposePeriod(json, 'whenPeriod', TFhirPeriod(elem.when)) 
  else if (SummaryOption in [soFull, soData]) and (elem.when is TFhirRange) then 
    ComposeRange(json, 'whenRange', TFhirRange(elem.when)) ;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'rationale', elem.rationaleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'rationale', elem.rationaleElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeRiskAssessmentPrediction(parent :  TRDFComplex; parentType, name : String; elem : TFhirRiskAssessmentPrediction; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:RiskAssessmentPrediction');
  end;
  composeBackboneElement(this, 'RiskAssessmentPrediction', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'RiskAssessmentPrediction', 'outcome', elem.outcomeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirDecimal) {6} then
    ComposeDecimal(this, 'RiskAssessmentPrediction', 'probabilityDecimal', TFhirDecimal(elem.probability), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirRange) {6} then
    ComposeRange(this, 'RiskAssessmentPrediction', 'probabilityRange', TFhirRange(elem.probability), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'RiskAssessmentPrediction', 'probabilityCodeableConcept', TFhirCodeableConcept(elem.probability), -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'RiskAssessmentPrediction', 'relativeRisk', elem.relativeRiskElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.when is TFhirPeriod) {6} then
    ComposePeriod(this, 'RiskAssessmentPrediction', 'whenPeriod', TFhirPeriod(elem.when), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.when is TFhirRange) {6} then
    ComposeRange(this, 'RiskAssessmentPrediction', 'whenRange', TFhirRange(elem.when), -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RiskAssessmentPrediction', 'rationale', elem.rationaleElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseRiskAssessment(element : IXmlDomElement; path : string) : TFhirRiskAssessment;
var
  child : IXMLDOMElement;
begin
  result := TFhirRiskAssessment.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'condition') then
        result.condition := ParseReference{TFhirCondition}(child, path+'/condition') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'performer') then
        result.performer := ParseReference{Resource}(child, path+'/performer') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'basis') then
        result.basisList.Add(ParseReference{TFhirReference}(child, path+'/basis')){y.2}
      else if (child.baseName = 'prediction') then
        result.predictionList.Add(ParseRiskAssessmentPrediction(child, path+'/prediction')){y.2}
      else if (child.baseName = 'mitigation') then
        result.mitigationElement := ParseString(child, path+'/mitigation') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessment(xml : TXmlBuilder; name : string; elem : TFhirRiskAssessment);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirCondition}(xml, 'condition', elem.condition);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'performer', elem.performer);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.basisList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'basis', elem.basisList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.predictionList.Count - 1 do
      ComposeRiskAssessmentPrediction(xml, 'prediction', elem.predictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'mitigation', elem.mitigationElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRiskAssessment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRiskAssessment(jsn)); {2}
end;

function TFHIRJsonParser.ParseRiskAssessment(jsn : TJsonObject) : TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('condition') then
        result.condition := ParseReference{TFhirCondition}(jsn.vObj['condition']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('performer') then
        result.performer := ParseReference{Resource}(jsn.vObj['performer']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('basis') then
      iterateArray(jsn.vArr['basis'], result.basisList, parseReference{TFhirReference});
    if jsn.has('prediction') then
      iterateArray(jsn.vArr['prediction'], result.predictionList, parseRiskAssessmentPrediction);
    if jsn.has('mitigation') or jsn.has('_mitigation') then
        result.mitigationElement := ParseString(jsn['mitigation'], jsn.vObj['_mitigation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRiskAssessment(json : TJSONWriter; name : string; elem : TFhirRiskAssessment; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirCondition}(json, 'condition', elem.condition); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'performer', elem.performer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soData]) and (elem.basisList.Count > 0) then
  begin
    json.valueArray('basis');
    for i := 0 to elem.basisList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.basisList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.predictionList.Count > 0) then
  begin
    json.valueArray('prediction');
    for i := 0 to elem.predictionList.Count - 1 do
      ComposeRiskAssessmentPrediction(json, '', elem.predictionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'mitigation', elem.mitigationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'mitigation', elem.mitigationElement, false);
end;

procedure TFHIRRDFComposer.ComposeRiskAssessment(parent :  TRDFComplex; parentType, name : String; elem : TFhirRiskAssessment; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:RiskAssessment');
  end;
  composeDomainResource(this, 'RiskAssessment', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'RiskAssessment', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'RiskAssessment', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirCondition}(this, 'RiskAssessment', 'condition', elem.conditionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'RiskAssessment', 'encounter', elem.encounterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'RiskAssessment', 'performer', elem.performerElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'RiskAssessment', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'RiskAssessment', 'method', elem.methodElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.basisList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'RiskAssessment', 'basis', elem.basisList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.predictionList.Count - 1 do
      ComposeRiskAssessmentPrediction(this, 'RiskAssessment', 'prediction', elem.predictionList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RiskAssessment', 'mitigation', elem.mitigationElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseSchedule(element : IXmlDomElement; path : string) : TFhirSchedule;
var
  child : IXMLDOMElement;
begin
  result := TFhirSchedule.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.baseName = 'actor') then
        result.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.baseName = 'planningHorizon') then
        result.planningHorizon := ParsePeriod(child, path+'/planningHorizon') {b}
      else if (child.baseName = 'comment') then
        result.commentElement := ParseString(child, path+'/comment') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSchedule(xml : TXmlBuilder; name : string; elem : TFhirSchedule);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'planningHorizon', elem.planningHorizon);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', elem.commentElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSchedule(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSchedule(jsn)); {2}
end;

function TFHIRJsonParser.ParseSchedule(jsn : TJsonObject) : TFhirSchedule;
begin
  result := TFhirSchedule.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('actor') then
        result.actor := ParseReference{Resource}(jsn.vObj['actor']);{q}
    if jsn.has('planningHorizon') then
        result.planningHorizon := ParsePeriod(jsn.vObj['planningHorizon']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSchedule(json : TJSONWriter; name : string; elem : TFhirSchedule; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'actor', elem.actor); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'planningHorizon', elem.planningHorizon); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
end;

procedure TFHIRRDFComposer.ComposeSchedule(parent :  TRDFComplex; parentType, name : String; elem : TFhirSchedule; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Schedule');
  end;
  composeDomainResource(this, 'Schedule', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Schedule', 'identifier', elem.identifierList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Schedule', 'type', elem.type_List[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Schedule', 'actor', elem.actorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Schedule', 'planningHorizon', elem.planningHorizonElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Schedule', 'comment', elem.commentElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseSearchParameterContact(element : IXmlDomElement; path : string) : TFhirSearchParameterContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirSearchParameterContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSearchParameterContact(xml : TXmlBuilder; name : string; elem : TFhirSearchParameterContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSearchParameterContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSearchParameterContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseSearchParameterContact(jsn : TJsonObject) : TFhirSearchParameterContact;
begin
  result := TFhirSearchParameterContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSearchParameterContact(json : TJSONWriter; name : string; elem : TFhirSearchParameterContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeSearchParameterContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirSearchParameterContact; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:SearchParameterContact');
  end;
  composeBackboneElement(this, 'SearchParameterContact', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SearchParameterContact', 'name', elem.nameElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'SearchParameterContact', 'telecom', elem.telecomList[i], i);
end;

function TFHIRXmlParser.ParseSearchParameter(element : IXmlDomElement; path : string) : TFhirSearchParameter;
var
  child : IXMLDOMElement;
begin
  result := TFhirSearchParameter.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseSearchParameterContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'requirements') then
        result.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'base') then
        result.baseElement := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/base', child){1a}
      else if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, path+'/type', child){1a}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'xpath') then
        result.xpathElement := ParseString(child, path+'/xpath') {b}
      else if (child.baseName = 'xpathUsage') then
        result.xpathUsageElement := ParseEnum(CODES_TFhirSearchXpathUsageEnum, SYSTEMS_TFhirSearchXpathUsageEnum, path+'/xpathUsage', child){1a}
      else if (child.baseName = 'target') then
        result.target.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/target', child)){y.1}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSearchParameter(xml : TXmlBuilder; name : string; elem : TFhirSearchParameter);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeSearchParameterContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'base', elem.BaseElement, CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'xpath', elem.xpathElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'xpathUsage', elem.XpathUsageElement, CODES_TFhirSearchXpathUsageEnum);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.target.Count - 1 do
      ComposeEnum(xml, 'target', elem.target[i], CODES_TFhirResourceTypesEnum);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSearchParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSearchParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseSearchParameter(jsn : TJsonObject) : TFhirSearchParameter;
begin
  result := TFhirSearchParameter.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseSearchParameterContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('base') or jsn.has('_base')  then
      result.baseElement := parseEnum(jsn.path+'/base', jsn['base'], jsn.vObj['_base'], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('xpath') or jsn.has('_xpath') then
        result.xpathElement := ParseString(jsn['xpath'], jsn.vObj['_xpath']);{q}
    if jsn.has('xpathUsage') or jsn.has('_xpathUsage')  then
      result.xpathUsageElement := parseEnum(jsn.path+'/xpathUsage', jsn['xpathUsage'], jsn.vObj['_xpathUsage'], CODES_TFhirSearchXpathUsageEnum, SYSTEMS_TFhirSearchXpathUsageEnum);
    if jsn.has('target') or jsn.has('_target') then
      iterateEnumArray(jsn.vArr['target'], jsn.vArr['_target'], jsn.path+'/target', result.target, parseEnum, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSearchParameter(json : TJSONWriter; name : string; elem : TFhirSearchParameter; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeSearchParameterContact(json, '', elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'base', elem.BaseElement, CODES_TFhirResourceTypesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'base', elem.BaseElement, CODES_TFhirResourceTypesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'xpath', elem.xpathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'xpath', elem.xpathElement, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'xpathUsage', elem.XpathUsageElement, CODES_TFhirSearchXpathUsageEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'xpathUsage', elem.XpathUsageElement, CODES_TFhirSearchXpathUsageEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.target.Count > 0) then
  begin
    json.valueArray('target');
    ext := false;
    for i := 0 to elem.target.Count - 1 do
    begin
      ext := ext or ((elem.target[i].id <> '') or (elem.target[i].hasExtensionList));
      ComposeEnumValue(json, '', elem.target[i], CODES_TFhirResourceTypesEnum, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_target');
      for i := 0 to elem.target.Count - 1 do
        ComposeEnumProps(json, '', elem.target[i], CODES_TFhirResourceTypesEnum, true);
      json.FinishArray;
    end;
  end;
end;

procedure TFHIRRDFComposer.ComposeSearchParameter(parent :  TRDFComplex; parentType, name : String; elem : TFhirSearchParameter; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:SearchParameter');
  end;
  composeDomainResource(this, 'SearchParameter', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'SearchParameter', 'url', elem.urlElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SearchParameter', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'SearchParameter', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'SearchParameter', 'experimental', elem.experimentalElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SearchParameter', 'publisher', elem.publisherElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeSearchParameterContact(this, 'SearchParameter', 'contact', elem.contactList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'SearchParameter', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'SearchParameter', 'requirements', elem.requirementsElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'SearchParameter', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'SearchParameter', 'base', elem.BaseElement, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'SearchParameter', 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SearchParameter', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'SearchParameter', 'xpath', elem.xpathElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'SearchParameter', 'xpathUsage', elem.XpathUsageElement, CODES_TFhirSearchXpathUsageEnum, SYSTEMS_TFhirSearchXpathUsageEnum, -1);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.target.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'target', elem.target[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.target.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'target', elem.target[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, i);
end;

function TFHIRXmlParser.ParseSlot(element : IXmlDomElement; path : string) : TFhirSlot;
var
  child : IXMLDOMElement;
begin
  result := TFhirSlot.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'schedule') then
        result.schedule := ParseReference{TFhirSchedule}(child, path+'/schedule') {b}
      else if (child.baseName = 'freeBusyType') then
        result.freeBusyTypeElement := ParseEnum(CODES_TFhirSlotstatusEnum, SYSTEMS_TFhirSlotstatusEnum, path+'/freeBusyType', child){1a}
      else if (child.baseName = 'start') then
        result.startElement := ParseInstant(child, path+'/start') {b}
      else if (child.baseName = 'end') then
        result.end_Element := ParseInstant(child, path+'/end') {b}
      else if (child.baseName = 'overbooked') then
        result.overbookedElement := ParseBoolean(child, path+'/overbooked') {b}
      else if (child.baseName = 'comment') then
        result.commentElement := ParseString(child, path+'/comment') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSlot(xml : TXmlBuilder; name : string; elem : TFhirSlot);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirSchedule}(xml, 'schedule', elem.schedule);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'freeBusyType', elem.FreeBusyTypeElement, CODES_TFhirSlotstatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'start', elem.startElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'end', elem.end_Element);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'overbooked', elem.overbookedElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', elem.commentElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSlot(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSlot(jsn)); {2}
end;

function TFHIRJsonParser.ParseSlot(jsn : TJsonObject) : TFhirSlot;
begin
  result := TFhirSlot.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('schedule') then
        result.schedule := ParseReference{TFhirSchedule}(jsn.vObj['schedule']);{q}
    if jsn.has('freeBusyType') or jsn.has('_freeBusyType')  then
      result.freeBusyTypeElement := parseEnum(jsn.path+'/freeBusyType', jsn['freeBusyType'], jsn.vObj['_freeBusyType'], CODES_TFhirSlotstatusEnum, SYSTEMS_TFhirSlotstatusEnum);
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := ParseInstant(jsn['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := ParseInstant(jsn['end'], jsn.vObj['_end']);{q}
    if jsn.has('overbooked') or jsn.has('_overbooked') then
        result.overbookedElement := ParseBoolean(jsn['overbooked'], jsn.vObj['_overbooked']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSlot(json : TJSONWriter; name : string; elem : TFhirSlot; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirSchedule}(json, 'schedule', elem.schedule); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'freeBusyType', elem.FreeBusyTypeElement, CODES_TFhirSlotstatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'freeBusyType', elem.FreeBusyTypeElement, CODES_TFhirSlotstatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantValue(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantProps(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantValue(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantProps(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'overbooked', elem.overbookedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'overbooked', elem.overbookedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
end;

procedure TFHIRRDFComposer.ComposeSlot(parent :  TRDFComplex; parentType, name : String; elem : TFhirSlot; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Slot');
  end;
  composeDomainResource(this, 'Slot', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Slot', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Slot', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirSchedule}(this, 'Slot', 'schedule', elem.scheduleElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Slot', 'freeBusyType', elem.FreeBusyTypeElement, CODES_TFhirSlotstatusEnum, SYSTEMS_TFhirSlotstatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'Slot', 'start', elem.startElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'Slot', 'end', elem.end_Element, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Slot', 'overbooked', elem.overbookedElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Slot', 'comment', elem.commentElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseSpecimenCollection(element : IXmlDomElement; path : string) : TFhirSpecimenCollection;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimenCollection.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'collector') then
        result.collector := ParseReference{TFhirPractitioner}(child, path+'/collector') {b}
      else if (child.baseName = 'comment') then
        result.commentList.Add(ParseString(child, path+'/comment')){y.2}
      else if (child.baseName = 'collectedDateTime') then
        result.collected := ParseDateTime(child, path+'/collectedDateTime'){x.3}
      else if (child.baseName = 'collectedPeriod') then
        result.collected := ParsePeriod(child, path+'/collectedPeriod'){x.3}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'bodySite') then
        result.bodySite := ParseCodeableConcept(child, path+'/bodySite') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSpecimenCollection(xml : TXmlBuilder; name : string; elem : TFhirSpecimenCollection);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'collector', elem.collector);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.commentList.Count - 1 do
      ComposeString(xml, 'comment', elem.commentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'collectedDateTime', TFhirDateTime(elem.collected))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirPeriod) {6} then
    ComposePeriod(xml, 'collectedPeriod', TFhirPeriod(elem.collected));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'bodySite', elem.bodySite);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSpecimenCollection(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenCollection(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimenCollection(jsn : TJsonObject) : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('collector') then
        result.collector := ParseReference{TFhirPractitioner}(jsn.vObj['collector']);{q}
      if jsn.has('comment') or jsn.has('_comment') then
      iteratePrimitiveArray(jsn.vArr['comment'], jsn.vArr['_comment'], result.commentList, parseString);
    if jsn.has('collectedDateTime') or jsn.has('_collectedDateTime') then
      result.collected := parseDateTime(jsn['collectedDateTime'], jsn.vObj['_collectedDateTime']);
    if jsn.has('collectedPeriod') {a4} then
      result.collected := ParsePeriod(jsn.vObj['collectedPeriod']);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSpecimenCollection(json : TJSONWriter; name : string; elem : TFhirSpecimenCollection; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'collector', elem.collector); {a}
  if (SummaryOption in [soFull, soData]) and (elem.commentList.Count > 0) then
  begin
    json.valueArray('comment');
    ext := false;
    for i := 0 to elem.commentList.Count - 1 do
    begin
      ext := ext or ((elem.commentList[i].id <> '') or (elem.commentList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.commentList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_comment');
      for i := 0 to elem.commentList.Count - 1 do
        ComposeStringProps(json, '',elem.commentList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'collectedDateTime', TFhirDateTime(elem.collected), false);
    ComposeDateTimeProps(json, 'collectedDateTime', TFhirDateTime(elem.collected), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirPeriod) then 
    ComposePeriod(json, 'collectedPeriod', TFhirPeriod(elem.collected)) ;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeSpecimenCollection(parent :  TRDFComplex; parentType, name : String; elem : TFhirSpecimenCollection; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:SpecimenCollection');
  end;
  composeBackboneElement(this, 'SpecimenCollection', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'SpecimenCollection', 'collector', elem.collectorElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.commentList.Count - 1 do
      ComposeString(this, 'SpecimenCollection', 'comment', elem.commentList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirDateTime) {6} then
    ComposeDateTime(this, 'SpecimenCollection', 'collectedDateTime', TFhirDateTime(elem.collected), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirPeriod) {6} then
    ComposePeriod(this, 'SpecimenCollection', 'collectedPeriod', TFhirPeriod(elem.collected), -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'SpecimenCollection', 'quantity', elem.quantityElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'SpecimenCollection', 'method', elem.methodElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'SpecimenCollection', 'bodySite', elem.bodySiteElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseSpecimenTreatment(element : IXmlDomElement; path : string) : TFhirSpecimenTreatment;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimenTreatment.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'procedure') then
        result.procedure_ := ParseCodeableConcept(child, path+'/procedure') {b}
      else if (child.baseName = 'additive') then
        result.additiveList.Add(ParseReference{TFhirSubstance}(child, path+'/additive')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSpecimenTreatment(xml : TXmlBuilder; name : string; elem : TFhirSpecimenTreatment);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'procedure', elem.procedure_);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.additiveList.Count - 1 do
      ComposeReference{TFhirSubstance}(xml, 'additive', elem.additiveList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSpecimenTreatment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenTreatment(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimenTreatment(jsn : TJsonObject) : TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('procedure') then
        result.procedure_ := ParseCodeableConcept(jsn.vObj['procedure']);{q}
    if jsn.has('additive') then
      iterateArray(jsn.vArr['additive'], result.additiveList, parseReference{TFhirSubstance});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSpecimenTreatment(json : TJSONWriter; name : string; elem : TFhirSpecimenTreatment; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'procedure', elem.procedure_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.additiveList.Count > 0) then
  begin
    json.valueArray('additive');
    for i := 0 to elem.additiveList.Count - 1 do
      ComposeReference{TFhirSubstance}(json, '', elem.additiveList[i]); {z - Reference(Substance)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeSpecimenTreatment(parent :  TRDFComplex; parentType, name : String; elem : TFhirSpecimenTreatment; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:SpecimenTreatment');
  end;
  composeBackboneElement(this, 'SpecimenTreatment', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'SpecimenTreatment', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'SpecimenTreatment', 'procedure', elem.procedure_Element, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.additiveList.Count - 1 do
      ComposeReference{TFhirSubstance}(this, 'SpecimenTreatment', 'additive', elem.additiveList[i], i);
end;

function TFHIRXmlParser.ParseSpecimenContainer(element : IXmlDomElement; path : string) : TFhirSpecimenContainer;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimenContainer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'capacity') then
        result.capacity := ParseQuantity(child, path+'/capacity') {b}
      else if (child.baseName = 'specimenQuantity') then
        result.specimenQuantity := ParseQuantity(child, path+'/specimenQuantity') {b}
      else if (child.baseName = 'additiveCodeableConcept') then
        result.additive := ParseCodeableConcept(child, path+'/additiveCodeableConcept'){x.3}
      else if (child.baseName = 'additiveReference') then
        result.additive := ParseReference(child, path+'/additiveReference') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSpecimenContainer(xml : TXmlBuilder; name : string; elem : TFhirSpecimenContainer);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'capacity', elem.capacity);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'specimenQuantity', elem.specimenQuantity);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'additiveCodeableConcept', TFhirCodeableConcept(elem.additive))
  else if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirReference) {2} then
    ComposeReference(xml, 'additiveReference', TFhirReference(elem.additive));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSpecimenContainer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenContainer(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimenContainer(jsn : TJsonObject) : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('capacity') then
        result.capacity := ParseQuantity(jsn.vObj['capacity']);{q}
    if jsn.has('specimenQuantity') then
        result.specimenQuantity := ParseQuantity(jsn.vObj['specimenQuantity']);{q}
    if jsn.has('additiveCodeableConcept') {a4} then
      result.additive := ParseCodeableConcept(jsn.vObj['additiveCodeableConcept']);
    if jsn.has('additiveReference') {a3} then
      result.additive := ParseReference(jsn.vObj['additiveReference']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSpecimenContainer(json : TJSONWriter; name : string; elem : TFhirSpecimenContainer; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'capacity', elem.capacity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'specimenQuantity', elem.specimenQuantity); {a}
  if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'additiveCodeableConcept', TFhirCodeableConcept(elem.additive)) 
  else if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirReference) then
    ComposeReference(json, 'additiveReference', TFhirReference(elem.additive));
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeSpecimenContainer(parent :  TRDFComplex; parentType, name : String; elem : TFhirSpecimenContainer; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:SpecimenContainer');
  end;
  composeBackboneElement(this, 'SpecimenContainer', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'SpecimenContainer', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'SpecimenContainer', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'SpecimenContainer', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'SpecimenContainer', 'capacity', elem.capacityElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'SpecimenContainer', 'specimenQuantity', elem.specimenQuantityElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SpecimenContainer', 'additiveCodeableConcept', TFhirCodeableConcept(elem.additive), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirReference) {2} then
    ComposeReference(this, 'SpecimenContainer', 'additiveReference', TFhirReference(elem.additive), -1);
end;

function TFHIRXmlParser.ParseSpecimen(element : IXmlDomElement; path : string) : TFhirSpecimen;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimen.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirSpecimenStatusEnum, SYSTEMS_TFhirSpecimenStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'parent') then
        result.parentList.Add(ParseReference{TFhirSpecimen}(child, path+'/parent')){y.2}
      else if (child.baseName = 'subject') then
        result.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'accessionIdentifier') then
        result.accessionIdentifier := ParseIdentifier(child, path+'/accessionIdentifier') {b}
      else if (child.baseName = 'receivedTime') then
        result.receivedTimeElement := ParseDateTime(child, path+'/receivedTime') {b}
      else if (child.baseName = 'collection') then
        result.collection := ParseSpecimenCollection(child, path+'/collection') {b}
      else if (child.baseName = 'treatment') then
        result.treatmentList.Add(ParseSpecimenTreatment(child, path+'/treatment')){y.2}
      else if (child.baseName = 'container') then
        result.containerList.Add(ParseSpecimenContainer(child, path+'/container')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSpecimen(xml : TXmlBuilder; name : string; elem : TFhirSpecimen);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirSpecimenStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.parentList.Count - 1 do
      ComposeReference{TFhirSpecimen}(xml, 'parent', elem.parentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'accessionIdentifier', elem.accessionIdentifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'receivedTime', elem.receivedTimeElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeSpecimenCollection(xml, 'collection', elem.collection);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.treatmentList.Count - 1 do
      ComposeSpecimenTreatment(xml, 'treatment', elem.treatmentList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.containerList.Count - 1 do
      ComposeSpecimenContainer(xml, 'container', elem.containerList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSpecimen(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimen(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimen(jsn : TJsonObject) : TFhirSpecimen;
begin
  result := TFhirSpecimen.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirSpecimenStatusEnum, SYSTEMS_TFhirSpecimenStatusEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('parent') then
      iterateArray(jsn.vArr['parent'], result.parentList, parseReference{TFhirSpecimen});
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('accessionIdentifier') then
        result.accessionIdentifier := ParseIdentifier(jsn.vObj['accessionIdentifier']);{q}
    if jsn.has('receivedTime') or jsn.has('_receivedTime') then
        result.receivedTimeElement := ParseDateTime(jsn['receivedTime'], jsn.vObj['_receivedTime']);{q}
    if jsn.has('collection') then
        result.collection := ParseSpecimenCollection(jsn.vObj['collection']);{q}
    if jsn.has('treatment') then
      iterateArray(jsn.vArr['treatment'], result.treatmentList, parseSpecimenTreatment);
    if jsn.has('container') then
      iterateArray(jsn.vArr['container'], result.containerList, parseSpecimenContainer);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSpecimen(json : TJSONWriter; name : string; elem : TFhirSpecimen; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirSpecimenStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirSpecimenStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.parentList.Count > 0) then
  begin
    json.valueArray('parent');
    for i := 0 to elem.parentList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '', elem.parentList[i]); {z - Reference(Specimen)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'accessionIdentifier', elem.accessionIdentifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'receivedTime', elem.receivedTimeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'receivedTime', elem.receivedTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeSpecimenCollection(json, 'collection', elem.collection); {a}
  if (SummaryOption in [soFull, soData]) and (elem.treatmentList.Count > 0) then
  begin
    json.valueArray('treatment');
    for i := 0 to elem.treatmentList.Count - 1 do
      ComposeSpecimenTreatment(json, '', elem.treatmentList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.containerList.Count > 0) then
  begin
    json.valueArray('container');
    for i := 0 to elem.containerList.Count - 1 do
      ComposeSpecimenContainer(json, '', elem.containerList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeSpecimen(parent :  TRDFComplex; parentType, name : String; elem : TFhirSpecimen; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Specimen');
  end;
  composeDomainResource(this, 'Specimen', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Specimen', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Specimen', 'status', elem.StatusElement, CODES_TFhirSpecimenStatusEnum, SYSTEMS_TFhirSpecimenStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Specimen', 'type', elem.type_Element, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.parentList.Count - 1 do
      ComposeReference{TFhirSpecimen}(this, 'Specimen', 'parent', elem.parentList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Specimen', 'subject', elem.subjectElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Specimen', 'accessionIdentifier', elem.accessionIdentifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Specimen', 'receivedTime', elem.receivedTimeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeSpecimenCollection(this, 'Specimen', 'collection', elem.collectionElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.treatmentList.Count - 1 do
      ComposeSpecimenTreatment(this, 'Specimen', 'treatment', elem.treatmentList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.containerList.Count - 1 do
      ComposeSpecimenContainer(this, 'Specimen', 'container', elem.containerList[i], i);
end;

function TFHIRXmlParser.ParseStructureDefinitionContact(element : IXmlDomElement; path : string) : TFhirStructureDefinitionContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirStructureDefinitionContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionContact(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseStructureDefinitionContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinitionContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinitionContact(jsn : TJsonObject) : TFhirStructureDefinitionContact;
begin
  result := TFhirStructureDefinitionContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeStructureDefinitionContact(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeStructureDefinitionContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirStructureDefinitionContact; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:StructureDefinitionContact');
  end;
  composeBackboneElement(this, 'StructureDefinitionContact', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureDefinitionContact', 'name', elem.nameElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'StructureDefinitionContact', 'telecom', elem.telecomList[i], i);
end;

function TFHIRXmlParser.ParseStructureDefinitionMapping(element : IXmlDomElement; path : string) : TFhirStructureDefinitionMapping;
var
  child : IXMLDOMElement;
begin
  result := TFhirStructureDefinitionMapping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identity') then
        result.identityElement := ParseId(child, path+'/identity') {b}
      else if (child.baseName = 'uri') then
        result.uriElement := ParseUri(child, path+'/uri') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'comments') then
        result.commentsElement := ParseString(child, path+'/comments') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionMapping(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionMapping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'identity', elem.identityElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'uri', elem.uriElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comments', elem.commentsElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseStructureDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinitionMapping(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinitionMapping(jsn : TJsonObject) : TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identity') or jsn.has('_identity') then
        result.identityElement := ParseId(jsn['identity'], jsn.vObj['_identity']);{q}
    if jsn.has('uri') or jsn.has('_uri') then
        result.uriElement := ParseUri(jsn['uri'], jsn.vObj['_uri']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsElement := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeStructureDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionMapping; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'identity', elem.identityElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'identity', elem.identityElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comments', elem.commentsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comments', elem.commentsElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeStructureDefinitionMapping(parent :  TRDFComplex; parentType, name : String; elem : TFhirStructureDefinitionMapping; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:StructureDefinitionMapping');
  end;
  composeBackboneElement(this, 'StructureDefinitionMapping', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'StructureDefinitionMapping', 'identity', elem.identityElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'StructureDefinitionMapping', 'uri', elem.uriElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureDefinitionMapping', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureDefinitionMapping', 'comments', elem.commentsElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseStructureDefinitionSnapshot(element : IXmlDomElement; path : string) : TFhirStructureDefinitionSnapshot;
var
  child : IXMLDOMElement;
begin
  result := TFhirStructureDefinitionSnapshot.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'element') then
        result.elementList.Add(ParseElementDefinition(child, path+'/element')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionSnapshot(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionSnapshot);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(xml, 'element', elem.elementList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseStructureDefinitionSnapshot(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinitionSnapshot(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinitionSnapshot(jsn : TJsonObject) : TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseElementDefinition);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeStructureDefinitionSnapshot(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionSnapshot; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.elementList.Count > 0) then
  begin
    json.valueArray('element');
    for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(json, '', elem.elementList[i]); {z - ElementDefinition}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeStructureDefinitionSnapshot(parent :  TRDFComplex; parentType, name : String; elem : TFhirStructureDefinitionSnapshot; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:StructureDefinitionSnapshot');
  end;
  composeBackboneElement(this, 'StructureDefinitionSnapshot', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(this, 'StructureDefinitionSnapshot', 'element', elem.elementList[i], i);
end;

function TFHIRXmlParser.ParseStructureDefinitionDifferential(element : IXmlDomElement; path : string) : TFhirStructureDefinitionDifferential;
var
  child : IXMLDOMElement;
begin
  result := TFhirStructureDefinitionDifferential.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'element') then
        result.elementList.Add(ParseElementDefinition(child, path+'/element')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionDifferential(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionDifferential);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(xml, 'element', elem.elementList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseStructureDefinitionDifferential(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinitionDifferential(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinitionDifferential(jsn : TJsonObject) : TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseElementDefinition);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeStructureDefinitionDifferential(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionDifferential; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.elementList.Count > 0) then
  begin
    json.valueArray('element');
    for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(json, '', elem.elementList[i]); {z - ElementDefinition}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeStructureDefinitionDifferential(parent :  TRDFComplex; parentType, name : String; elem : TFhirStructureDefinitionDifferential; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:StructureDefinitionDifferential');
  end;
  composeBackboneElement(this, 'StructureDefinitionDifferential', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(this, 'StructureDefinitionDifferential', 'element', elem.elementList[i], i);
end;

function TFHIRXmlParser.ParseStructureDefinition(element : IXmlDomElement; path : string) : TFhirStructureDefinition;
var
  child : IXMLDOMElement;
begin
  result := TFhirStructureDefinition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'display') then
        result.displayElement := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseStructureDefinitionContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'useContext') then
        result.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.baseName = 'requirements') then
        result.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'copyright') then
        result.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.baseName = 'code') then
        result.codeList.Add(ParseCoding(child, path+'/code')){y.2}
      else if (child.baseName = 'fhirVersion') then
        result.fhirVersionElement := ParseId(child, path+'/fhirVersion') {b}
      else if (child.baseName = 'mapping') then
        result.mappingList.Add(ParseStructureDefinitionMapping(child, path+'/mapping')){y.2}
      else if (child.baseName = 'kind') then
        result.kindElement := ParseEnum(CODES_TFhirStructureDefinitionKindEnum, SYSTEMS_TFhirStructureDefinitionKindEnum, path+'/kind', child){1a}
      else if (child.baseName = 'constrainedType') then
        result.constrainedTypeElement := ParseEnum(CODES_TFhirDefinedTypesEnum, SYSTEMS_TFhirDefinedTypesEnum, path+'/constrainedType', child){1a}
      else if (child.baseName = 'abstract') then
        result.abstractElement := ParseBoolean(child, path+'/abstract') {b}
      else if (child.baseName = 'contextType') then
        result.contextTypeElement := ParseEnum(CODES_TFhirExtensionContextEnum, SYSTEMS_TFhirExtensionContextEnum, path+'/contextType', child){1a}
      else if (child.baseName = 'context') then
        result.contextList.Add(ParseString(child, path+'/context')){y.2}
      else if (child.baseName = 'base') then
        result.baseElement := ParseUri(child, path+'/base') {b}
      else if (child.baseName = 'snapshot') then
        result.snapshot := ParseStructureDefinitionSnapshot(child, path+'/snapshot') {b}
      else if (child.baseName = 'differential') then
        result.differential := ParseStructureDefinitionDifferential(child, path+'/differential') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinition(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeStructureDefinitionContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyright', elem.copyrightElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(xml, 'code', elem.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'fhirVersion', elem.fhirVersionElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeStructureDefinitionMapping(xml, 'mapping', elem.mappingList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirStructureDefinitionKindEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'constrainedType', elem.ConstrainedTypeElement, CODES_TFhirDefinedTypesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'abstract', elem.abstractElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'contextType', elem.ContextTypeElement, CODES_TFhirExtensionContextEnum);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contextList.Count - 1 do
      ComposeString(xml, 'context', elem.contextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'base', elem.baseElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeStructureDefinitionSnapshot(xml, 'snapshot', elem.snapshot);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeStructureDefinitionDifferential(xml, 'differential', elem.differential);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseStructureDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinition(jsn : TJsonObject) : TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseStructureDefinitionContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCoding);
    if jsn.has('fhirVersion') or jsn.has('_fhirVersion') then
        result.fhirVersionElement := ParseId(jsn['fhirVersion'], jsn.vObj['_fhirVersion']);{q}
    if jsn.has('mapping') then
      iterateArray(jsn.vArr['mapping'], result.mappingList, parseStructureDefinitionMapping);
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn['kind'], jsn.vObj['_kind'], CODES_TFhirStructureDefinitionKindEnum, SYSTEMS_TFhirStructureDefinitionKindEnum);
    if jsn.has('constrainedType') or jsn.has('_constrainedType')  then
      result.constrainedTypeElement := parseEnum(jsn.path+'/constrainedType', jsn['constrainedType'], jsn.vObj['_constrainedType'], CODES_TFhirDefinedTypesEnum, SYSTEMS_TFhirDefinedTypesEnum);
    if jsn.has('abstract') or jsn.has('_abstract') then
        result.abstractElement := ParseBoolean(jsn['abstract'], jsn.vObj['_abstract']);{q}
    if jsn.has('contextType') or jsn.has('_contextType')  then
      result.contextTypeElement := parseEnum(jsn.path+'/contextType', jsn['contextType'], jsn.vObj['_contextType'], CODES_TFhirExtensionContextEnum, SYSTEMS_TFhirExtensionContextEnum);
      if jsn.has('context') or jsn.has('_context') then
      iteratePrimitiveArray(jsn.vArr['context'], jsn.vArr['_context'], result.contextList, parseString);
    if jsn.has('base') or jsn.has('_base') then
        result.baseElement := ParseUri(jsn['base'], jsn.vObj['_base']);{q}
    if jsn.has('snapshot') then
        result.snapshot := ParseStructureDefinitionSnapshot(jsn.vObj['snapshot']);{q}
    if jsn.has('differential') then
        result.differential := ParseStructureDefinitionDifferential(jsn.vObj['differential']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeStructureDefinition(json : TJSONWriter; name : string; elem : TFhirStructureDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeStructureDefinitionContact(json, '', elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.useContextList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(json, '', elem.codeList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdValue(json, 'fhirVersion', elem.fhirVersionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdProps(json, 'fhirVersion', elem.fhirVersionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.mappingList.Count > 0) then
  begin
    json.valueArray('mapping');
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeStructureDefinitionMapping(json, '', elem.mappingList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirStructureDefinitionKindEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirStructureDefinitionKindEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'constrainedType', elem.ConstrainedTypeElement, CODES_TFhirDefinedTypesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'constrainedType', elem.ConstrainedTypeElement, CODES_TFhirDefinedTypesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'abstract', elem.abstractElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'abstract', elem.abstractElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'contextType', elem.ContextTypeElement, CODES_TFhirExtensionContextEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'contextType', elem.ContextTypeElement, CODES_TFhirExtensionContextEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.contextList.Count > 0) then
  begin
    json.valueArray('context');
    ext := false;
    for i := 0 to elem.contextList.Count - 1 do
    begin
      ext := ext or ((elem.contextList[i].id <> '') or (elem.contextList[i].hasExtensionList));
      ComposeStringValue(json, '',elem.contextList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_context');
      for i := 0 to elem.contextList.Count - 1 do
        ComposeStringProps(json, '',elem.contextList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'base', elem.baseElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'base', elem.baseElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStructureDefinitionSnapshot(json, 'snapshot', elem.snapshot); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStructureDefinitionDifferential(json, 'differential', elem.differential); {a}
end;

procedure TFHIRRDFComposer.ComposeStructureDefinition(parent :  TRDFComplex; parentType, name : String; elem : TFhirStructureDefinition; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:StructureDefinition');
  end;
  composeDomainResource(this, 'StructureDefinition', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'StructureDefinition', 'url', elem.urlElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'StructureDefinition', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureDefinition', 'version', elem.versionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureDefinition', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureDefinition', 'display', elem.displayElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'StructureDefinition', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'StructureDefinition', 'experimental', elem.experimentalElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureDefinition', 'publisher', elem.publisherElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeStructureDefinitionContact(this, 'StructureDefinition', 'contact', elem.contactList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'StructureDefinition', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureDefinition', 'description', elem.descriptionElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(this, 'StructureDefinition', 'useContext', elem.useContextList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureDefinition', 'requirements', elem.requirementsElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureDefinition', 'copyright', elem.copyrightElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(false, this, 'StructureDefinition', 'code', elem.codeList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'StructureDefinition', 'fhirVersion', elem.fhirVersionElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeStructureDefinitionMapping(this, 'StructureDefinition', 'mapping', elem.mappingList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'StructureDefinition', 'kind', elem.KindElement, CODES_TFhirStructureDefinitionKindEnum, SYSTEMS_TFhirStructureDefinitionKindEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'StructureDefinition', 'constrainedType', elem.ConstrainedTypeElement, CODES_TFhirDefinedTypesEnum, SYSTEMS_TFhirDefinedTypesEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'StructureDefinition', 'abstract', elem.abstractElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'StructureDefinition', 'contextType', elem.ContextTypeElement, CODES_TFhirExtensionContextEnum, SYSTEMS_TFhirExtensionContextEnum, -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contextList.Count - 1 do
      ComposeString(this, 'StructureDefinition', 'context', elem.contextList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'StructureDefinition', 'base', elem.baseElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeStructureDefinitionSnapshot(this, 'StructureDefinition', 'snapshot', elem.snapshotElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeStructureDefinitionDifferential(this, 'StructureDefinition', 'differential', elem.differentialElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseSubscriptionChannel(element : IXmlDomElement; path : string) : TFhirSubscriptionChannel;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubscriptionChannel.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_Element := ParseEnum(CODES_TFhirSubscriptionChannelTypeEnum, SYSTEMS_TFhirSubscriptionChannelTypeEnum, path+'/type', child){1a}
      else if (child.baseName = 'endpoint') then
        result.endpointElement := ParseUri(child, path+'/endpoint') {b}
      else if (child.baseName = 'payload') then
        result.payloadElement := ParseString(child, path+'/payload') {b}
      else if (child.baseName = 'header') then
        result.headerElement := ParseString(child, path+'/header') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionChannel(xml : TXmlBuilder; name : string; elem : TFhirSubscriptionChannel);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirSubscriptionChannelTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'endpoint', elem.endpointElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'payload', elem.payloadElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'header', elem.headerElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubscriptionChannel(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubscriptionChannel(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubscriptionChannel(jsn : TJsonObject) : TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn['type'], jsn.vObj['_type'], CODES_TFhirSubscriptionChannelTypeEnum, SYSTEMS_TFhirSubscriptionChannelTypeEnum);
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpointElement := ParseUri(jsn['endpoint'], jsn.vObj['_endpoint']);{q}
    if jsn.has('payload') or jsn.has('_payload') then
        result.payloadElement := ParseString(jsn['payload'], jsn.vObj['_payload']);{q}
    if jsn.has('header') or jsn.has('_header') then
        result.headerElement := ParseString(jsn['header'], jsn.vObj['_header']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubscriptionChannel(json : TJSONWriter; name : string; elem : TFhirSubscriptionChannel; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirSubscriptionChannelTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirSubscriptionChannelTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'endpoint', elem.endpointElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'endpoint', elem.endpointElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'payload', elem.payloadElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'payload', elem.payloadElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'header', elem.headerElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'header', elem.headerElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeSubscriptionChannel(parent :  TRDFComplex; parentType, name : String; elem : TFhirSubscriptionChannel; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:SubscriptionChannel');
  end;
  composeBackboneElement(this, 'SubscriptionChannel', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'SubscriptionChannel', 'type', elem.Type_Element, CODES_TFhirSubscriptionChannelTypeEnum, SYSTEMS_TFhirSubscriptionChannelTypeEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'SubscriptionChannel', 'endpoint', elem.endpointElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubscriptionChannel', 'payload', elem.payloadElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubscriptionChannel', 'header', elem.headerElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseSubscription(element : IXmlDomElement; path : string) : TFhirSubscription;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubscription.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'criteria') then
        result.criteriaElement := ParseString(child, path+'/criteria') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseContactPoint(child, path+'/contact')){y.2}
      else if (child.baseName = 'reason') then
        result.reasonElement := ParseString(child, path+'/reason') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirSubscriptionStatusEnum, SYSTEMS_TFhirSubscriptionStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'error') then
        result.errorElement := ParseString(child, path+'/error') {b}
      else if (child.baseName = 'channel') then
        result.channel := ParseSubscriptionChannel(child, path+'/channel') {b}
      else if (child.baseName = 'end') then
        result.end_Element := ParseInstant(child, path+'/end') {b}
      else if (child.baseName = 'tag') then
        result.tagList.Add(ParseCoding(child, path+'/tag')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubscription(xml : TXmlBuilder; name : string; elem : TFhirSubscription);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'criteria', elem.criteriaElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'reason', elem.reasonElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirSubscriptionStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'error', elem.errorElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubscriptionChannel(xml, 'channel', elem.channel);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'end', elem.end_Element);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.tagList.Count - 1 do
      ComposeCoding(xml, 'tag', elem.tagList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubscription(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubscription(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubscription(jsn : TJsonObject) : TFhirSubscription;
begin
  result := TFhirSubscription.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('criteria') or jsn.has('_criteria') then
        result.criteriaElement := ParseString(jsn['criteria'], jsn.vObj['_criteria']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactPoint);
    if jsn.has('reason') or jsn.has('_reason') then
        result.reasonElement := ParseString(jsn['reason'], jsn.vObj['_reason']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirSubscriptionStatusEnum, SYSTEMS_TFhirSubscriptionStatusEnum);
    if jsn.has('error') or jsn.has('_error') then
        result.errorElement := ParseString(jsn['error'], jsn.vObj['_error']);{q}
    if jsn.has('channel') then
        result.channel := ParseSubscriptionChannel(jsn.vObj['channel']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := ParseInstant(jsn['end'], jsn.vObj['_end']);{q}
    if jsn.has('tag') then
      iterateArray(jsn.vArr['tag'], result.tagList, parseCoding);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubscription(json : TJSONWriter; name : string; elem : TFhirSubscription; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'criteria', elem.criteriaElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'criteria', elem.criteriaElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(json, '', elem.contactList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'reason', elem.reasonElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'reason', elem.reasonElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirSubscriptionStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirSubscriptionStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'error', elem.errorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'error', elem.errorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubscriptionChannel(json, 'channel', elem.channel); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantValue(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantProps(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.tagList.Count > 0) then
  begin
    json.valueArray('tag');
    for i := 0 to elem.tagList.Count - 1 do
      ComposeCoding(json, '', elem.tagList[i]); {z - Coding}
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeSubscription(parent :  TRDFComplex; parentType, name : String; elem : TFhirSubscription; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Subscription');
  end;
  composeDomainResource(this, 'Subscription', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Subscription', 'criteria', elem.criteriaElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(this, 'Subscription', 'contact', elem.contactList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Subscription', 'reason', elem.reasonElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'Subscription', 'status', elem.StatusElement, CODES_TFhirSubscriptionStatusEnum, SYSTEMS_TFhirSubscriptionStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Subscription', 'error', elem.errorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubscriptionChannel(this, 'Subscription', 'channel', elem.channelElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'Subscription', 'end', elem.end_Element, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.tagList.Count - 1 do
      ComposeCoding(false, this, 'Subscription', 'tag', elem.tagList[i], i);
end;

function TFHIRXmlParser.ParseSubstanceInstance(element : IXmlDomElement; path : string) : TFhirSubstanceInstance;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubstanceInstance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'expiry') then
        result.expiryElement := ParseDateTime(child, path+'/expiry') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubstanceInstance(xml : TXmlBuilder; name : string; elem : TFhirSubstanceInstance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'expiry', elem.expiryElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubstanceInstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceInstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceInstance(jsn : TJsonObject) : TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('expiry') or jsn.has('_expiry') then
        result.expiryElement := ParseDateTime(jsn['expiry'], jsn.vObj['_expiry']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubstanceInstance(json : TJSONWriter; name : string; elem : TFhirSubstanceInstance; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'expiry', elem.expiryElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'expiry', elem.expiryElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeSubstanceInstance(parent :  TRDFComplex; parentType, name : String; elem : TFhirSubstanceInstance; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:SubstanceInstance');
  end;
  composeBackboneElement(this, 'SubstanceInstance', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstanceInstance', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'SubstanceInstance', 'expiry', elem.expiryElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'SubstanceInstance', 'quantity', elem.quantityElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseSubstanceIngredient(element : IXmlDomElement; path : string) : TFhirSubstanceIngredient;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubstanceIngredient.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'quantity') then
        result.quantity := ParseRatio(child, path+'/quantity') {b}
      else if (child.baseName = 'substance') then
        result.substance := ParseReference{TFhirSubstance}(child, path+'/substance') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubstanceIngredient(xml : TXmlBuilder; name : string; elem : TFhirSubstanceIngredient);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(xml, 'quantity', elem.quantity);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirSubstance}(xml, 'substance', elem.substance);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubstanceIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceIngredient(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceIngredient(jsn : TJsonObject) : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('quantity') then
        result.quantity := ParseRatio(jsn.vObj['quantity']);{q}
    if jsn.has('substance') then
        result.substance := ParseReference{TFhirSubstance}(jsn.vObj['substance']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubstanceIngredient(json : TJSONWriter; name : string; elem : TFhirSubstanceIngredient; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirSubstance}(json, 'substance', elem.substance); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeSubstanceIngredient(parent :  TRDFComplex; parentType, name : String; elem : TFhirSubstanceIngredient; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:SubstanceIngredient');
  end;
  composeBackboneElement(this, 'SubstanceIngredient', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'SubstanceIngredient', 'quantity', elem.quantityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirSubstance}(this, 'SubstanceIngredient', 'substance', elem.substanceElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseSubstance(element : IXmlDomElement; path : string) : TFhirSubstance;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubstance.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'category') then
        result.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'instance') then
        result.instanceList.Add(ParseSubstanceInstance(child, path+'/instance')){y.2}
      else if (child.baseName = 'ingredient') then
        result.ingredientList.Add(ParseSubstanceIngredient(child, path+'/ingredient')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubstance(xml : TXmlBuilder; name : string; elem : TFhirSubstance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeSubstanceInstance(xml, 'instance', elem.instanceList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeSubstanceIngredient(xml, 'ingredient', elem.ingredientList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstance(jsn : TJsonObject) : TFhirSubstance;
begin
  result := TFhirSubstance.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('instance') then
      iterateArray(jsn.vArr['instance'], result.instanceList, parseSubstanceInstance);
    if jsn.has('ingredient') then
      iterateArray(jsn.vArr['ingredient'], result.ingredientList, parseSubstanceIngredient);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubstance(json : TJSONWriter; name : string; elem : TFhirSubstance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.instanceList.Count > 0) then
  begin
    json.valueArray('instance');
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeSubstanceInstance(json, '', elem.instanceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.ingredientList.Count > 0) then
  begin
    json.valueArray('ingredient');
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeSubstanceIngredient(json, '', elem.ingredientList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeSubstance(parent :  TRDFComplex; parentType, name : String; elem : TFhirSubstance; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:Substance');
  end;
  composeDomainResource(this, 'Substance', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Substance', 'identifier', elem.identifierList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Substance', 'category', elem.categoryList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Substance', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Substance', 'description', elem.descriptionElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeSubstanceInstance(this, 'Substance', 'instance', elem.instanceList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeSubstanceIngredient(this, 'Substance', 'ingredient', elem.ingredientList[i], i);
end;

function TFHIRXmlParser.ParseSupplyDelivery(element : IXmlDomElement; path : string) : TFhirSupplyDelivery;
var
  child : IXMLDOMElement;
begin
  result := TFhirSupplyDelivery.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirSupplydeliveryStatusEnum, SYSTEMS_TFhirSupplydeliveryStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'suppliedItem') then
        result.suppliedItem := ParseReference{Resource}(child, path+'/suppliedItem') {b}
      else if (child.baseName = 'supplier') then
        result.supplier := ParseReference{TFhirPractitioner}(child, path+'/supplier') {b}
      else if (child.baseName = 'whenPrepared') then
        result.whenPrepared := ParsePeriod(child, path+'/whenPrepared') {b}
      else if (child.baseName = 'time') then
        result.timeElement := ParseDateTime(child, path+'/time') {b}
      else if (child.baseName = 'destination') then
        result.destination := ParseReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.baseName = 'receiver') then
        result.receiverList.Add(ParseReference{TFhirPractitioner}(child, path+'/receiver')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSupplyDelivery(xml : TXmlBuilder; name : string; elem : TFhirSupplyDelivery);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirSupplydeliveryStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'suppliedItem', elem.suppliedItem);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'supplier', elem.supplier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'whenPrepared', elem.whenPrepared);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'time', elem.timeElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(xml, 'destination', elem.destination);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{TFhirPractitioner}(xml, 'receiver', elem.receiverList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSupplyDelivery(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupplyDelivery(jsn)); {2}
end;

function TFHIRJsonParser.ParseSupplyDelivery(jsn : TJsonObject) : TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirSupplydeliveryStatusEnum, SYSTEMS_TFhirSupplydeliveryStatusEnum);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('suppliedItem') then
        result.suppliedItem := ParseReference{Resource}(jsn.vObj['suppliedItem']);{q}
    if jsn.has('supplier') then
        result.supplier := ParseReference{TFhirPractitioner}(jsn.vObj['supplier']);{q}
    if jsn.has('whenPrepared') then
        result.whenPrepared := ParsePeriod(jsn.vObj['whenPrepared']);{q}
    if jsn.has('time') or jsn.has('_time') then
        result.timeElement := ParseDateTime(jsn['time'], jsn.vObj['_time']);{q}
    if jsn.has('destination') then
        result.destination := ParseReference{TFhirLocation}(jsn.vObj['destination']);{q}
    if jsn.has('receiver') then
      iterateArray(jsn.vArr['receiver'], result.receiverList, parseReference{TFhirPractitioner});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSupplyDelivery(json : TJSONWriter; name : string; elem : TFhirSupplyDelivery; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirSupplydeliveryStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirSupplydeliveryStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'suppliedItem', elem.suppliedItem); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'supplier', elem.supplier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'whenPrepared', elem.whenPrepared); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'time', elem.timeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'time', elem.timeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.receiverList.Count > 0) then
  begin
    json.valueArray('receiver');
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.receiverList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeSupplyDelivery(parent :  TRDFComplex; parentType, name : String; elem : TFhirSupplyDelivery; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:SupplyDelivery');
  end;
  composeDomainResource(this, 'SupplyDelivery', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SupplyDelivery', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'SupplyDelivery', 'status', elem.StatusElement, CODES_TFhirSupplydeliveryStatusEnum, SYSTEMS_TFhirSupplydeliveryStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'SupplyDelivery', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SupplyDelivery', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'SupplyDelivery', 'quantity', elem.quantityElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'SupplyDelivery', 'suppliedItem', elem.suppliedItemElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'SupplyDelivery', 'supplier', elem.supplierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'SupplyDelivery', 'whenPrepared', elem.whenPreparedElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'SupplyDelivery', 'time', elem.timeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirLocation}(this, 'SupplyDelivery', 'destination', elem.destinationElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'SupplyDelivery', 'receiver', elem.receiverList[i], i);
end;

function TFHIRXmlParser.ParseSupplyRequestWhen(element : IXmlDomElement; path : string) : TFhirSupplyRequestWhen;
var
  child : IXMLDOMElement;
begin
  result := TFhirSupplyRequestWhen.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'schedule') then
        result.schedule := ParseTiming(child, path+'/schedule') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSupplyRequestWhen(xml : TXmlBuilder; name : string; elem : TFhirSupplyRequestWhen);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(xml, 'schedule', elem.schedule);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSupplyRequestWhen(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupplyRequestWhen(jsn)); {2}
end;

function TFHIRJsonParser.ParseSupplyRequestWhen(jsn : TJsonObject) : TFhirSupplyRequestWhen;
begin
  result := TFhirSupplyRequestWhen.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('schedule') then
        result.schedule := ParseTiming(jsn.vObj['schedule']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSupplyRequestWhen(json : TJSONWriter; name : string; elem : TFhirSupplyRequestWhen; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(json, 'schedule', elem.schedule); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeSupplyRequestWhen(parent :  TRDFComplex; parentType, name : String; elem : TFhirSupplyRequestWhen; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:SupplyRequestWhen');
  end;
  composeBackboneElement(this, 'SupplyRequestWhen', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SupplyRequestWhen', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(this, 'SupplyRequestWhen', 'schedule', elem.scheduleElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseSupplyRequest(element : IXmlDomElement; path : string) : TFhirSupplyRequest;
var
  child : IXMLDOMElement;
begin
  result := TFhirSupplyRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'source') then
        result.source := ParseReference{Resource}(child, path+'/source') {b}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirSupplyrequestStatusEnum, SYSTEMS_TFhirSupplyrequestStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'kind') then
        result.kind := ParseCodeableConcept(child, path+'/kind') {b}
      else if (child.baseName = 'orderedItem') then
        result.orderedItem := ParseReference{Resource}(child, path+'/orderedItem') {b}
      else if (child.baseName = 'supplier') then
        result.supplierList.Add(ParseReference{TFhirOrganization}(child, path+'/supplier')){y.2}
      else if (child.baseName = 'reasonCodeableConcept') then
        result.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.baseName = 'reasonReference') then
        result.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.baseName = 'when') then
        result.when := ParseSupplyRequestWhen(child, path+'/when') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSupplyRequest(xml : TXmlBuilder; name : string; elem : TFhirSupplyRequest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'source', elem.source);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirSupplyrequestStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'kind', elem.kind);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'orderedItem', elem.orderedItem);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.supplierList.Count - 1 do
      ComposeReference{TFhirOrganization}(xml, 'supplier', elem.supplierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSupplyRequestWhen(xml, 'when', elem.when);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSupplyRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupplyRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseSupplyRequest(jsn : TJsonObject) : TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('source') then
        result.source := ParseReference{Resource}(jsn.vObj['source']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirSupplyrequestStatusEnum, SYSTEMS_TFhirSupplyrequestStatusEnum);
    if jsn.has('kind') then
        result.kind := ParseCodeableConcept(jsn.vObj['kind']);{q}
    if jsn.has('orderedItem') then
        result.orderedItem := ParseReference{Resource}(jsn.vObj['orderedItem']);{q}
    if jsn.has('supplier') then
      iterateArray(jsn.vArr['supplier'], result.supplierList, parseReference{TFhirOrganization});
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('when') then
        result.when := ParseSupplyRequestWhen(jsn.vObj['when']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSupplyRequest(json : TJSONWriter; name : string; elem : TFhirSupplyRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirSupplyrequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirSupplyrequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'kind', elem.kind); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'orderedItem', elem.orderedItem); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.supplierList.Count > 0) then
  begin
    json.valueArray('supplier');
    for i := 0 to elem.supplierList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.supplierList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSupplyRequestWhen(json, 'when', elem.when); {a}
end;

procedure TFHIRRDFComposer.ComposeSupplyRequest(parent :  TRDFComplex; parentType, name : String; elem : TFhirSupplyRequest; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:SupplyRequest');
  end;
  composeDomainResource(this, 'SupplyRequest', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'SupplyRequest', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'SupplyRequest', 'source', elem.sourceElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'SupplyRequest', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SupplyRequest', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'SupplyRequest', 'status', elem.StatusElement, CODES_TFhirSupplyrequestStatusEnum, SYSTEMS_TFhirSupplyrequestStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SupplyRequest', 'kind', elem.kindElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'SupplyRequest', 'orderedItem', elem.orderedItemElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.supplierList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'SupplyRequest', 'supplier', elem.supplierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SupplyRequest', 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(this, 'SupplyRequest', 'reasonReference', TFhirReference(elem.reason), -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSupplyRequestWhen(this, 'SupplyRequest', 'when', elem.whenElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseTestScriptContact(element : IXmlDomElement; path : string) : TFhirTestScriptContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirTestScriptContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTestScriptContact(xml : TXmlBuilder; name : string; elem : TFhirTestScriptContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTestScriptContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptContact(jsn : TJsonObject) : TFhirTestScriptContact;
begin
  result := TFhirTestScriptContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTestScriptContact(json : TJSONWriter; name : string; elem : TFhirTestScriptContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeTestScriptContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptContact; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:TestScriptContact');
  end;
  composeBackboneElement(this, 'TestScriptContact', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TestScriptContact', 'name', elem.nameElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'TestScriptContact', 'telecom', elem.telecomList[i], i);
end;

function TFHIRXmlParser.ParseTestScriptMetadata(element : IXmlDomElement; path : string) : TFhirTestScriptMetadata;
var
  child : IXMLDOMElement;
begin
  result := TFhirTestScriptMetadata.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'link') then
        result.link_List.Add(ParseTestScriptMetadataLink(child, path+'/link')){y.2}
      else if (child.baseName = 'capability') then
        result.capabilityList.Add(ParseTestScriptMetadataCapability(child, path+'/capability')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadata(xml : TXmlBuilder; name : string; elem : TFhirTestScriptMetadata);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeTestScriptMetadataLink(xml, 'link', elem.link_List[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.capabilityList.Count - 1 do
      ComposeTestScriptMetadataCapability(xml, 'capability', elem.capabilityList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTestScriptMetadata(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptMetadata(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptMetadata(jsn : TJsonObject) : TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parseTestScriptMetadataLink);
    if jsn.has('capability') then
      iterateArray(jsn.vArr['capability'], result.capabilityList, parseTestScriptMetadataCapability);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTestScriptMetadata(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadata; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.link_List.Count > 0) then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposeTestScriptMetadataLink(json, '', elem.link_List[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.capabilityList.Count > 0) then
  begin
    json.valueArray('capability');
    for i := 0 to elem.capabilityList.Count - 1 do
      ComposeTestScriptMetadataCapability(json, '', elem.capabilityList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeTestScriptMetadata(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptMetadata; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:TestScriptMetadata');
  end;
  composeBackboneElement(this, 'TestScriptMetadata', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeTestScriptMetadataLink(this, 'TestScriptMetadata', 'link', elem.link_List[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.capabilityList.Count - 1 do
      ComposeTestScriptMetadataCapability(this, 'TestScriptMetadata', 'capability', elem.capabilityList[i], i);
end;

function TFHIRXmlParser.ParseTestScriptMetadataLink(element : IXmlDomElement; path : string) : TFhirTestScriptMetadataLink;
var
  child : IXMLDOMElement;
begin
  result := TFhirTestScriptMetadataLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadataLink(xml : TXmlBuilder; name : string; elem : TFhirTestScriptMetadataLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTestScriptMetadataLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptMetadataLink(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptMetadataLink(jsn : TJsonObject) : TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTestScriptMetadataLink(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadataLink; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeTestScriptMetadataLink(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptMetadataLink; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:TestScriptMetadataLink');
  end;
  composeBackboneElement(this, 'TestScriptMetadataLink', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'TestScriptMetadataLink', 'url', elem.urlElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptMetadataLink', 'description', elem.descriptionElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseTestScriptMetadataCapability(element : IXmlDomElement; path : string) : TFhirTestScriptMetadataCapability;
var
  child : IXMLDOMElement;
begin
  result := TFhirTestScriptMetadataCapability.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'required') then
        result.requiredElement := ParseBoolean(child, path+'/required') {b}
      else if (child.baseName = 'validated') then
        result.validatedElement := ParseBoolean(child, path+'/validated') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'destination') then
        result.destinationElement := ParseInteger(child, path+'/destination') {b}
      else if (child.baseName = 'link') then
        result.link_List.Add(ParseUri(child, path+'/link')){y.2}
      else if (child.baseName = 'conformance') then
        result.conformance := ParseReference{TFhirConformance}(child, path+'/conformance') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadataCapability(xml : TXmlBuilder; name : string; elem : TFhirTestScriptMetadataCapability);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'required', elem.requiredElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'validated', elem.validatedElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'destination', elem.destinationElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeUri(xml, 'link', elem.link_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirConformance}(xml, 'conformance', elem.conformance);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTestScriptMetadataCapability(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptMetadataCapability(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptMetadataCapability(jsn : TJsonObject) : TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('required') or jsn.has('_required') then
        result.requiredElement := ParseBoolean(jsn['required'], jsn.vObj['_required']);{q}
    if jsn.has('validated') or jsn.has('_validated') then
        result.validatedElement := ParseBoolean(jsn['validated'], jsn.vObj['_validated']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('destination') or jsn.has('_destination') then
        result.destinationElement := ParseInteger(jsn['destination'], jsn.vObj['_destination']);{q}
      if jsn.has('link') or jsn.has('_link') then
      iteratePrimitiveArray(jsn.vArr['link'], jsn.vArr['_link'], result.link_List, parseUri);
    if jsn.has('conformance') then
        result.conformance := ParseReference{TFhirConformance}(jsn.vObj['conformance']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTestScriptMetadataCapability(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadataCapability; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'required', elem.requiredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'required', elem.requiredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'validated', elem.validatedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'validated', elem.validatedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'destination', elem.destinationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'destination', elem.destinationElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.link_List.Count > 0) then
  begin
    json.valueArray('link');
    ext := false;
    for i := 0 to elem.link_List.Count - 1 do
    begin
      ext := ext or ((elem.link_List[i].id <> '') or (elem.link_List[i].hasExtensionList));
      ComposeUriValue(json, '',elem.link_List[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_link');
      for i := 0 to elem.link_List.Count - 1 do
        ComposeUriProps(json, '',elem.link_List[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirConformance}(json, 'conformance', elem.conformance); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeTestScriptMetadataCapability(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptMetadataCapability; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:TestScriptMetadataCapability');
  end;
  composeBackboneElement(this, 'TestScriptMetadataCapability', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TestScriptMetadataCapability', 'required', elem.requiredElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TestScriptMetadataCapability', 'validated', elem.validatedElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptMetadataCapability', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'TestScriptMetadataCapability', 'destination', elem.destinationElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeUri(this, 'TestScriptMetadataCapability', 'link', elem.link_List[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirConformance}(this, 'TestScriptMetadataCapability', 'conformance', elem.conformanceElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseTestScriptFixture(element : IXmlDomElement; path : string) : TFhirTestScriptFixture;
var
  child : IXMLDOMElement;
begin
  result := TFhirTestScriptFixture.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'autocreate') then
        result.autocreateElement := ParseBoolean(child, path+'/autocreate') {b}
      else if (child.baseName = 'autodelete') then
        result.autodeleteElement := ParseBoolean(child, path+'/autodelete') {b}
      else if (child.baseName = 'resource') then
        result.resource := ParseReference{TFhirReference}(child, path+'/resource') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTestScriptFixture(xml : TXmlBuilder; name : string; elem : TFhirTestScriptFixture);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'autocreate', elem.autocreateElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'autodelete', elem.autodeleteElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(xml, 'resource', elem.resource);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTestScriptFixture(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptFixture(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptFixture(jsn : TJsonObject) : TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('autocreate') or jsn.has('_autocreate') then
        result.autocreateElement := ParseBoolean(jsn['autocreate'], jsn.vObj['_autocreate']);{q}
    if jsn.has('autodelete') or jsn.has('_autodelete') then
        result.autodeleteElement := ParseBoolean(jsn['autodelete'], jsn.vObj['_autodelete']);{q}
    if jsn.has('resource') then
        result.resource := ParseReference{TFhirReference}(jsn.vObj['resource']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTestScriptFixture(json : TJSONWriter; name : string; elem : TFhirTestScriptFixture; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'autocreate', elem.autocreateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'autocreate', elem.autocreateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'autodelete', elem.autodeleteElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'autodelete', elem.autodeleteElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(json, 'resource', elem.resource); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeTestScriptFixture(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptFixture; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:TestScriptFixture');
  end;
  composeBackboneElement(this, 'TestScriptFixture', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TestScriptFixture', 'autocreate', elem.autocreateElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TestScriptFixture', 'autodelete', elem.autodeleteElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'TestScriptFixture', 'resource', elem.resourceElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseTestScriptVariable(element : IXmlDomElement; path : string) : TFhirTestScriptVariable;
var
  child : IXMLDOMElement;
begin
  result := TFhirTestScriptVariable.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'headerField') then
        result.headerFieldElement := ParseString(child, path+'/headerField') {b}
      else if (child.baseName = 'path') then
        result.pathElement := ParseString(child, path+'/path') {b}
      else if (child.baseName = 'sourceId') then
        result.sourceIdElement := ParseId(child, path+'/sourceId') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTestScriptVariable(xml : TXmlBuilder; name : string; elem : TFhirTestScriptVariable);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'headerField', elem.headerFieldElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'path', elem.pathElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'sourceId', elem.sourceIdElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTestScriptVariable(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptVariable(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptVariable(jsn : TJsonObject) : TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('headerField') or jsn.has('_headerField') then
        result.headerFieldElement := ParseString(jsn['headerField'], jsn.vObj['_headerField']);{q}
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := ParseString(jsn['path'], jsn.vObj['_path']);{q}
    if jsn.has('sourceId') or jsn.has('_sourceId') then
        result.sourceIdElement := ParseId(jsn['sourceId'], jsn.vObj['_sourceId']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTestScriptVariable(json : TJSONWriter; name : string; elem : TFhirTestScriptVariable; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'headerField', elem.headerFieldElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'headerField', elem.headerFieldElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'sourceId', elem.sourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'sourceId', elem.sourceIdElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeTestScriptVariable(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptVariable; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:TestScriptVariable');
  end;
  composeBackboneElement(this, 'TestScriptVariable', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptVariable', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptVariable', 'headerField', elem.headerFieldElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptVariable', 'path', elem.pathElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScriptVariable', 'sourceId', elem.sourceIdElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseTestScriptSetup(element : IXmlDomElement; path : string) : TFhirTestScriptSetup;
var
  child : IXMLDOMElement;
begin
  result := TFhirTestScriptSetup.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'metadata') then
        result.metadata := ParseTestScriptMetadata(child, path+'/metadata') {b}
      else if (child.baseName = 'action') then
        result.actionList.Add(ParseTestScriptSetupAction(child, path+'/action')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetup(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetup);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptMetadata(xml, 'metadata', elem.metadata);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptSetupAction(xml, 'action', elem.actionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTestScriptSetup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptSetup(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptSetup(jsn : TJsonObject) : TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('metadata') then
        result.metadata := ParseTestScriptMetadata(jsn.vObj['metadata']);{q}
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseTestScriptSetupAction);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTestScriptSetup(json : TJSONWriter; name : string; elem : TFhirTestScriptSetup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptMetadata(json, 'metadata', elem.metadata); {a}
  if (SummaryOption in [soFull, soData]) and (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptSetupAction(json, '', elem.actionList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeTestScriptSetup(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptSetup; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:TestScriptSetup');
  end;
  composeBackboneElement(this, 'TestScriptSetup', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptMetadata(this, 'TestScriptSetup', 'metadata', elem.metadataElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptSetupAction(this, 'TestScriptSetup', 'action', elem.actionList[i], i);
end;

function TFHIRXmlParser.ParseTestScriptSetupAction(element : IXmlDomElement; path : string) : TFhirTestScriptSetupAction;
var
  child : IXMLDOMElement;
begin
  result := TFhirTestScriptSetupAction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'operation') then
        result.operation := ParseTestScriptSetupActionOperation(child, path+'/operation') {b}
      else if (child.baseName = 'assert') then
        result.assert := ParseTestScriptSetupActionAssert(child, path+'/assert') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupAction(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupAction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(xml, 'operation', elem.operation);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(xml, 'assert', elem.assert);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTestScriptSetupAction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptSetupAction(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptSetupAction(jsn : TJsonObject) : TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('operation') then
        result.operation := ParseTestScriptSetupActionOperation(jsn.vObj['operation']);{q}
    if jsn.has('assert') then
        result.assert := ParseTestScriptSetupActionAssert(jsn.vObj['assert']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTestScriptSetupAction(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupAction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(json, 'operation', elem.operation); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(json, 'assert', elem.assert); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeTestScriptSetupAction(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptSetupAction; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:TestScriptSetupAction');
  end;
  composeBackboneElement(this, 'TestScriptSetupAction', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(this, 'TestScriptSetupAction', 'operation', elem.operationElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(this, 'TestScriptSetupAction', 'assert', elem.assertElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseTestScriptSetupActionOperation(element : IXmlDomElement; path : string) : TFhirTestScriptSetupActionOperation;
var
  child : IXMLDOMElement;
begin
  result := TFhirTestScriptSetupActionOperation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'resource') then
        result.resourceElement := ParseEnum(CODES_TFhirDefinedTypesEnum, SYSTEMS_TFhirDefinedTypesEnum, path+'/resource', child){1a}
      else if (child.baseName = 'label') then
        result.label_Element := ParseString(child, path+'/label') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'accept') then
        result.acceptElement := ParseEnum(CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, path+'/accept', child){1a}
      else if (child.baseName = 'contentType') then
        result.contentTypeElement := ParseEnum(CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, path+'/contentType', child){1a}
      else if (child.baseName = 'destination') then
        result.destinationElement := ParseInteger(child, path+'/destination') {b}
      else if (child.baseName = 'encodeRequestUrl') then
        result.encodeRequestUrlElement := ParseBoolean(child, path+'/encodeRequestUrl') {b}
      else if (child.baseName = 'params') then
        result.paramsElement := ParseString(child, path+'/params') {b}
      else if (child.baseName = 'requestHeader') then
        result.requestHeaderList.Add(ParseTestScriptSetupActionOperationRequestHeader(child, path+'/requestHeader')){y.2}
      else if (child.baseName = 'responseId') then
        result.responseIdElement := ParseId(child, path+'/responseId') {b}
      else if (child.baseName = 'sourceId') then
        result.sourceIdElement := ParseId(child, path+'/sourceId') {b}
      else if (child.baseName = 'targetId') then
        result.targetIdElement := ParseId(child, path+'/targetId') {b}
      else if (child.baseName = 'url') then
        result.urlElement := ParseString(child, path+'/url') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionOperation(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupActionOperation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'resource', elem.ResourceElement, CODES_TFhirDefinedTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'label', elem.label_Element);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'accept', elem.AcceptElement, CODES_TFhirContentTypeEnum);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'destination', elem.destinationElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'encodeRequestUrl', elem.encodeRequestUrlElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'params', elem.paramsElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.requestHeaderList.Count - 1 do
      ComposeTestScriptSetupActionOperationRequestHeader(xml, 'requestHeader', elem.requestHeaderList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'responseId', elem.responseIdElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'sourceId', elem.sourceIdElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'targetId', elem.targetIdElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'url', elem.urlElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTestScriptSetupActionOperation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptSetupActionOperation(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptSetupActionOperation(jsn : TJsonObject) : TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('resource') or jsn.has('_resource')  then
      result.resourceElement := parseEnum(jsn.path+'/resource', jsn['resource'], jsn.vObj['_resource'], CODES_TFhirDefinedTypesEnum, SYSTEMS_TFhirDefinedTypesEnum);
    if jsn.has('label') or jsn.has('_label') then
        result.label_Element := ParseString(jsn['label'], jsn.vObj['_label']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('accept') or jsn.has('_accept')  then
      result.acceptElement := parseEnum(jsn.path+'/accept', jsn['accept'], jsn.vObj['_accept'], CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum);
    if jsn.has('contentType') or jsn.has('_contentType')  then
      result.contentTypeElement := parseEnum(jsn.path+'/contentType', jsn['contentType'], jsn.vObj['_contentType'], CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum);
    if jsn.has('destination') or jsn.has('_destination') then
        result.destinationElement := ParseInteger(jsn['destination'], jsn.vObj['_destination']);{q}
    if jsn.has('encodeRequestUrl') or jsn.has('_encodeRequestUrl') then
        result.encodeRequestUrlElement := ParseBoolean(jsn['encodeRequestUrl'], jsn.vObj['_encodeRequestUrl']);{q}
    if jsn.has('params') or jsn.has('_params') then
        result.paramsElement := ParseString(jsn['params'], jsn.vObj['_params']);{q}
    if jsn.has('requestHeader') then
      iterateArray(jsn.vArr['requestHeader'], result.requestHeaderList, parseTestScriptSetupActionOperationRequestHeader);
    if jsn.has('responseId') or jsn.has('_responseId') then
        result.responseIdElement := ParseId(jsn['responseId'], jsn.vObj['_responseId']);{q}
    if jsn.has('sourceId') or jsn.has('_sourceId') then
        result.sourceIdElement := ParseId(jsn['sourceId'], jsn.vObj['_sourceId']);{q}
    if jsn.has('targetId') or jsn.has('_targetId') then
        result.targetIdElement := ParseId(jsn['targetId'], jsn.vObj['_targetId']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseString(jsn['url'], jsn.vObj['_url']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTestScriptSetupActionOperation(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionOperation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'resource', elem.ResourceElement, CODES_TFhirDefinedTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'resource', elem.ResourceElement, CODES_TFhirDefinedTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'accept', elem.AcceptElement, CODES_TFhirContentTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'accept', elem.AcceptElement, CODES_TFhirContentTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'destination', elem.destinationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'destination', elem.destinationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'encodeRequestUrl', elem.encodeRequestUrlElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'encodeRequestUrl', elem.encodeRequestUrlElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'params', elem.paramsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'params', elem.paramsElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.requestHeaderList.Count > 0) then
  begin
    json.valueArray('requestHeader');
    for i := 0 to elem.requestHeaderList.Count - 1 do
      ComposeTestScriptSetupActionOperationRequestHeader(json, '', elem.requestHeaderList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'responseId', elem.responseIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'responseId', elem.responseIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'sourceId', elem.sourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'sourceId', elem.sourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'targetId', elem.targetIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'targetId', elem.targetIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'url', elem.urlElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeTestScriptSetupActionOperation(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptSetupActionOperation; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:TestScriptSetupActionOperation');
  end;
  composeBackboneElement(this, 'TestScriptSetupActionOperation', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(false, this, 'TestScriptSetupActionOperation', 'type', elem.type_Element, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'TestScriptSetupActionOperation', 'resource', elem.ResourceElement, CODES_TFhirDefinedTypesEnum, SYSTEMS_TFhirDefinedTypesEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptSetupActionOperation', 'label', elem.label_Element, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptSetupActionOperation', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'TestScriptSetupActionOperation', 'accept', elem.AcceptElement, CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, -1);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'TestScriptSetupActionOperation', 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'TestScriptSetupActionOperation', 'destination', elem.destinationElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TestScriptSetupActionOperation', 'encodeRequestUrl', elem.encodeRequestUrlElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptSetupActionOperation', 'params', elem.paramsElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.requestHeaderList.Count - 1 do
      ComposeTestScriptSetupActionOperationRequestHeader(this, 'TestScriptSetupActionOperation', 'requestHeader', elem.requestHeaderList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScriptSetupActionOperation', 'responseId', elem.responseIdElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScriptSetupActionOperation', 'sourceId', elem.sourceIdElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScriptSetupActionOperation', 'targetId', elem.targetIdElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptSetupActionOperation', 'url', elem.urlElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseTestScriptSetupActionOperationRequestHeader(element : IXmlDomElement; path : string) : TFhirTestScriptSetupActionOperationRequestHeader;
var
  child : IXMLDOMElement;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'field') then
        result.fieldElement := ParseString(child, path+'/field') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseString(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionOperationRequestHeader(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupActionOperationRequestHeader);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'field', elem.fieldElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTestScriptSetupActionOperationRequestHeader(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptSetupActionOperationRequestHeader(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptSetupActionOperationRequestHeader(jsn : TJsonObject) : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('field') or jsn.has('_field') then
        result.fieldElement := ParseString(jsn['field'], jsn.vObj['_field']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTestScriptSetupActionOperationRequestHeader(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionOperationRequestHeader; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'field', elem.fieldElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'field', elem.fieldElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeTestScriptSetupActionOperationRequestHeader(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptSetupActionOperationRequestHeader; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:TestScriptSetupActionOperationRequestHeader');
  end;
  composeBackboneElement(this, 'TestScriptSetupActionOperationRequestHeader', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptSetupActionOperationRequestHeader', 'field', elem.fieldElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptSetupActionOperationRequestHeader', 'value', elem.valueElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseTestScriptSetupActionAssert(element : IXmlDomElement; path : string) : TFhirTestScriptSetupActionAssert;
var
  child : IXMLDOMElement;
begin
  result := TFhirTestScriptSetupActionAssert.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'label') then
        result.label_Element := ParseString(child, path+'/label') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'direction') then
        result.directionElement := ParseEnum(CODES_TFhirAssertDirectionCodesEnum, SYSTEMS_TFhirAssertDirectionCodesEnum, path+'/direction', child){1a}
      else if (child.baseName = 'compareToSourceId') then
        result.compareToSourceIdElement := ParseString(child, path+'/compareToSourceId') {b}
      else if (child.baseName = 'compareToSourcePath') then
        result.compareToSourcePathElement := ParseString(child, path+'/compareToSourcePath') {b}
      else if (child.baseName = 'contentType') then
        result.contentTypeElement := ParseEnum(CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, path+'/contentType', child){1a}
      else if (child.baseName = 'headerField') then
        result.headerFieldElement := ParseString(child, path+'/headerField') {b}
      else if (child.baseName = 'minimumId') then
        result.minimumIdElement := ParseString(child, path+'/minimumId') {b}
      else if (child.baseName = 'navigationLinks') then
        result.navigationLinksElement := ParseBoolean(child, path+'/navigationLinks') {b}
      else if (child.baseName = 'operator') then
        result.operatorElement := ParseEnum(CODES_TFhirAssertOperatorCodesEnum, SYSTEMS_TFhirAssertOperatorCodesEnum, path+'/operator', child){1a}
      else if (child.baseName = 'path') then
        result.pathElement := ParseString(child, path+'/path') {b}
      else if (child.baseName = 'resource') then
        result.resourceElement := ParseEnum(CODES_TFhirDefinedTypesEnum, SYSTEMS_TFhirDefinedTypesEnum, path+'/resource', child){1a}
      else if (child.baseName = 'response') then
        result.responseElement := ParseEnum(CODES_TFhirAssertResponseCodeTypesEnum, SYSTEMS_TFhirAssertResponseCodeTypesEnum, path+'/response', child){1a}
      else if (child.baseName = 'responseCode') then
        result.responseCodeElement := ParseString(child, path+'/responseCode') {b}
      else if (child.baseName = 'sourceId') then
        result.sourceIdElement := ParseId(child, path+'/sourceId') {b}
      else if (child.baseName = 'validateProfileId') then
        result.validateProfileIdElement := ParseId(child, path+'/validateProfileId') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseString(child, path+'/value') {b}
      else if (child.baseName = 'warningOnly') then
        result.warningOnlyElement := ParseBoolean(child, path+'/warningOnly') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionAssert(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupActionAssert);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'label', elem.label_Element);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'direction', elem.DirectionElement, CODES_TFhirAssertDirectionCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'compareToSourceId', elem.compareToSourceIdElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'compareToSourcePath', elem.compareToSourcePathElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'headerField', elem.headerFieldElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'minimumId', elem.minimumIdElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'navigationLinks', elem.navigationLinksElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'operator', elem.OperatorElement, CODES_TFhirAssertOperatorCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'path', elem.pathElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'resource', elem.ResourceElement, CODES_TFhirDefinedTypesEnum);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'response', elem.ResponseElement, CODES_TFhirAssertResponseCodeTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'responseCode', elem.responseCodeElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'sourceId', elem.sourceIdElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'validateProfileId', elem.validateProfileIdElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'value', elem.valueElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'warningOnly', elem.warningOnlyElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTestScriptSetupActionAssert(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptSetupActionAssert(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptSetupActionAssert(jsn : TJsonObject) : TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('label') or jsn.has('_label') then
        result.label_Element := ParseString(jsn['label'], jsn.vObj['_label']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('direction') or jsn.has('_direction')  then
      result.directionElement := parseEnum(jsn.path+'/direction', jsn['direction'], jsn.vObj['_direction'], CODES_TFhirAssertDirectionCodesEnum, SYSTEMS_TFhirAssertDirectionCodesEnum);
    if jsn.has('compareToSourceId') or jsn.has('_compareToSourceId') then
        result.compareToSourceIdElement := ParseString(jsn['compareToSourceId'], jsn.vObj['_compareToSourceId']);{q}
    if jsn.has('compareToSourcePath') or jsn.has('_compareToSourcePath') then
        result.compareToSourcePathElement := ParseString(jsn['compareToSourcePath'], jsn.vObj['_compareToSourcePath']);{q}
    if jsn.has('contentType') or jsn.has('_contentType')  then
      result.contentTypeElement := parseEnum(jsn.path+'/contentType', jsn['contentType'], jsn.vObj['_contentType'], CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum);
    if jsn.has('headerField') or jsn.has('_headerField') then
        result.headerFieldElement := ParseString(jsn['headerField'], jsn.vObj['_headerField']);{q}
    if jsn.has('minimumId') or jsn.has('_minimumId') then
        result.minimumIdElement := ParseString(jsn['minimumId'], jsn.vObj['_minimumId']);{q}
    if jsn.has('navigationLinks') or jsn.has('_navigationLinks') then
        result.navigationLinksElement := ParseBoolean(jsn['navigationLinks'], jsn.vObj['_navigationLinks']);{q}
    if jsn.has('operator') or jsn.has('_operator')  then
      result.operatorElement := parseEnum(jsn.path+'/operator', jsn['operator'], jsn.vObj['_operator'], CODES_TFhirAssertOperatorCodesEnum, SYSTEMS_TFhirAssertOperatorCodesEnum);
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := ParseString(jsn['path'], jsn.vObj['_path']);{q}
    if jsn.has('resource') or jsn.has('_resource')  then
      result.resourceElement := parseEnum(jsn.path+'/resource', jsn['resource'], jsn.vObj['_resource'], CODES_TFhirDefinedTypesEnum, SYSTEMS_TFhirDefinedTypesEnum);
    if jsn.has('response') or jsn.has('_response')  then
      result.responseElement := parseEnum(jsn.path+'/response', jsn['response'], jsn.vObj['_response'], CODES_TFhirAssertResponseCodeTypesEnum, SYSTEMS_TFhirAssertResponseCodeTypesEnum);
    if jsn.has('responseCode') or jsn.has('_responseCode') then
        result.responseCodeElement := ParseString(jsn['responseCode'], jsn.vObj['_responseCode']);{q}
    if jsn.has('sourceId') or jsn.has('_sourceId') then
        result.sourceIdElement := ParseId(jsn['sourceId'], jsn.vObj['_sourceId']);{q}
    if jsn.has('validateProfileId') or jsn.has('_validateProfileId') then
        result.validateProfileIdElement := ParseId(jsn['validateProfileId'], jsn.vObj['_validateProfileId']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    if jsn.has('warningOnly') or jsn.has('_warningOnly') then
        result.warningOnlyElement := ParseBoolean(jsn['warningOnly'], jsn.vObj['_warningOnly']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTestScriptSetupActionAssert(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionAssert; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'direction', elem.DirectionElement, CODES_TFhirAssertDirectionCodesEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'direction', elem.DirectionElement, CODES_TFhirAssertDirectionCodesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'compareToSourceId', elem.compareToSourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'compareToSourceId', elem.compareToSourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'compareToSourcePath', elem.compareToSourcePathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'compareToSourcePath', elem.compareToSourcePathElement, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'headerField', elem.headerFieldElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'headerField', elem.headerFieldElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'minimumId', elem.minimumIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'minimumId', elem.minimumIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'navigationLinks', elem.navigationLinksElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'navigationLinks', elem.navigationLinksElement, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'operator', elem.OperatorElement, CODES_TFhirAssertOperatorCodesEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'operator', elem.OperatorElement, CODES_TFhirAssertOperatorCodesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'resource', elem.ResourceElement, CODES_TFhirDefinedTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'resource', elem.ResourceElement, CODES_TFhirDefinedTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'response', elem.ResponseElement, CODES_TFhirAssertResponseCodeTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'response', elem.ResponseElement, CODES_TFhirAssertResponseCodeTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'responseCode', elem.responseCodeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'responseCode', elem.responseCodeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'sourceId', elem.sourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'sourceId', elem.sourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'validateProfileId', elem.validateProfileIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'validateProfileId', elem.validateProfileIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'warningOnly', elem.warningOnlyElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'warningOnly', elem.warningOnlyElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeTestScriptSetupActionAssert(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssert; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:TestScriptSetupActionAssert');
  end;
  composeBackboneElement(this, 'TestScriptSetupActionAssert', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptSetupActionAssert', 'label', elem.label_Element, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptSetupActionAssert', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'TestScriptSetupActionAssert', 'direction', elem.DirectionElement, CODES_TFhirAssertDirectionCodesEnum, SYSTEMS_TFhirAssertDirectionCodesEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptSetupActionAssert', 'compareToSourceId', elem.compareToSourceIdElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptSetupActionAssert', 'compareToSourcePath', elem.compareToSourcePathElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'TestScriptSetupActionAssert', 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptSetupActionAssert', 'headerField', elem.headerFieldElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptSetupActionAssert', 'minimumId', elem.minimumIdElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TestScriptSetupActionAssert', 'navigationLinks', elem.navigationLinksElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'TestScriptSetupActionAssert', 'operator', elem.OperatorElement, CODES_TFhirAssertOperatorCodesEnum, SYSTEMS_TFhirAssertOperatorCodesEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptSetupActionAssert', 'path', elem.pathElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'TestScriptSetupActionAssert', 'resource', elem.ResourceElement, CODES_TFhirDefinedTypesEnum, SYSTEMS_TFhirDefinedTypesEnum, -1);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'TestScriptSetupActionAssert', 'response', elem.ResponseElement, CODES_TFhirAssertResponseCodeTypesEnum, SYSTEMS_TFhirAssertResponseCodeTypesEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptSetupActionAssert', 'responseCode', elem.responseCodeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScriptSetupActionAssert', 'sourceId', elem.sourceIdElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScriptSetupActionAssert', 'validateProfileId', elem.validateProfileIdElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptSetupActionAssert', 'value', elem.valueElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TestScriptSetupActionAssert', 'warningOnly', elem.warningOnlyElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseTestScriptTest(element : IXmlDomElement; path : string) : TFhirTestScriptTest;
var
  child : IXMLDOMElement;
begin
  result := TFhirTestScriptTest.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'metadata') then
        result.metadata := ParseTestScriptMetadata(child, path+'/metadata') {b}
      else if (child.baseName = 'action') then
        result.actionList.Add(ParseTestScriptTestAction(child, path+'/action')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTest(xml : TXmlBuilder; name : string; elem : TFhirTestScriptTest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptMetadata(xml, 'metadata', elem.metadata);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTestAction(xml, 'action', elem.actionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTestScriptTest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptTest(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptTest(jsn : TJsonObject) : TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('metadata') then
        result.metadata := ParseTestScriptMetadata(jsn.vObj['metadata']);{q}
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseTestScriptTestAction);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTestScriptTest(json : TJSONWriter; name : string; elem : TFhirTestScriptTest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptMetadata(json, 'metadata', elem.metadata); {a}
  if (SummaryOption in [soFull, soData]) and (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTestAction(json, '', elem.actionList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeTestScriptTest(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptTest; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:TestScriptTest');
  end;
  composeBackboneElement(this, 'TestScriptTest', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptTest', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScriptTest', 'description', elem.descriptionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptMetadata(this, 'TestScriptTest', 'metadata', elem.metadataElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTestAction(this, 'TestScriptTest', 'action', elem.actionList[i], i);
end;

function TFHIRXmlParser.ParseTestScriptTestAction(element : IXmlDomElement; path : string) : TFhirTestScriptTestAction;
var
  child : IXMLDOMElement;
begin
  result := TFhirTestScriptTestAction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'operation') then
        result.operation := ParseTestScriptSetupActionOperation(child, path+'/operation') {b}
      else if (child.baseName = 'assert') then
        result.assert := ParseTestScriptSetupActionAssert(child, path+'/assert') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTestAction(xml : TXmlBuilder; name : string; elem : TFhirTestScriptTestAction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(xml, 'operation', elem.operation);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(xml, 'assert', elem.assert);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTestScriptTestAction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptTestAction(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptTestAction(jsn : TJsonObject) : TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('operation') then
        result.operation := ParseTestScriptSetupActionOperation(jsn.vObj['operation']);{q}
    if jsn.has('assert') then
        result.assert := ParseTestScriptSetupActionAssert(jsn.vObj['assert']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTestScriptTestAction(json : TJSONWriter; name : string; elem : TFhirTestScriptTestAction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(json, 'operation', elem.operation); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(json, 'assert', elem.assert); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeTestScriptTestAction(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptTestAction; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:TestScriptTestAction');
  end;
  composeBackboneElement(this, 'TestScriptTestAction', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(this, 'TestScriptTestAction', 'operation', elem.operationElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(this, 'TestScriptTestAction', 'assert', elem.assertElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseTestScriptTeardown(element : IXmlDomElement; path : string) : TFhirTestScriptTeardown;
var
  child : IXMLDOMElement;
begin
  result := TFhirTestScriptTeardown.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'action') then
        result.actionList.Add(ParseTestScriptTeardownAction(child, path+'/action')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTeardown(xml : TXmlBuilder; name : string; elem : TFhirTestScriptTeardown);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTeardownAction(xml, 'action', elem.actionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTestScriptTeardown(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptTeardown(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptTeardown(jsn : TJsonObject) : TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseTestScriptTeardownAction);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTestScriptTeardown(json : TJSONWriter; name : string; elem : TFhirTestScriptTeardown; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTeardownAction(json, '', elem.actionList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeTestScriptTeardown(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptTeardown; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:TestScriptTeardown');
  end;
  composeBackboneElement(this, 'TestScriptTeardown', name, elem, index);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTeardownAction(this, 'TestScriptTeardown', 'action', elem.actionList[i], i);
end;

function TFHIRXmlParser.ParseTestScriptTeardownAction(element : IXmlDomElement; path : string) : TFhirTestScriptTeardownAction;
var
  child : IXMLDOMElement;
begin
  result := TFhirTestScriptTeardownAction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'operation') then
        result.operation := ParseTestScriptSetupActionOperation(child, path+'/operation') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTeardownAction(xml : TXmlBuilder; name : string; elem : TFhirTestScriptTeardownAction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(xml, 'operation', elem.operation);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTestScriptTeardownAction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptTeardownAction(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptTeardownAction(jsn : TJsonObject) : TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('operation') then
        result.operation := ParseTestScriptSetupActionOperation(jsn.vObj['operation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTestScriptTeardownAction(json : TJSONWriter; name : string; elem : TFhirTestScriptTeardownAction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(json, 'operation', elem.operation); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeTestScriptTeardownAction(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScriptTeardownAction; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:TestScriptTeardownAction');
  end;
  composeBackboneElement(this, 'TestScriptTeardownAction', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(this, 'TestScriptTeardownAction', 'operation', elem.operationElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseTestScript(element : IXmlDomElement; path : string) : TFhirTestScript;
var
  child : IXMLDOMElement;
begin
  result := TFhirTestScript.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'experimental') then
        result.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseTestScriptContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'useContext') then
        result.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.baseName = 'requirements') then
        result.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'copyright') then
        result.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.baseName = 'metadata') then
        result.metadata := ParseTestScriptMetadata(child, path+'/metadata') {b}
      else if (child.baseName = 'multiserver') then
        result.multiserverElement := ParseBoolean(child, path+'/multiserver') {b}
      else if (child.baseName = 'fixture') then
        result.fixtureList.Add(ParseTestScriptFixture(child, path+'/fixture')){y.2}
      else if (child.baseName = 'profile') then
        result.profileList.Add(ParseReference{TFhirReference}(child, path+'/profile')){y.2}
      else if (child.baseName = 'variable') then
        result.variableList.Add(ParseTestScriptVariable(child, path+'/variable')){y.2}
      else if (child.baseName = 'setup') then
        result.setup := ParseTestScriptSetup(child, path+'/setup') {b}
      else if (child.baseName = 'test') then
        result.testList.Add(ParseTestScriptTest(child, path+'/test')){y.2}
      else if (child.baseName = 'teardown') then
        result.teardown := ParseTestScriptTeardown(child, path+'/teardown') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeTestScript(xml : TXmlBuilder; name : string; elem : TFhirTestScript);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeTestScriptContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyright', elem.copyrightElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptMetadata(xml, 'metadata', elem.metadata);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'multiserver', elem.multiserverElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.fixtureList.Count - 1 do
      ComposeTestScriptFixture(xml, 'fixture', elem.fixtureList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'profile', elem.profileList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.variableList.Count - 1 do
      ComposeTestScriptVariable(xml, 'variable', elem.variableList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetup(xml, 'setup', elem.setup);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.testList.Count - 1 do
      ComposeTestScriptTest(xml, 'test', elem.testList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptTeardown(xml, 'teardown', elem.teardown);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseTestScript(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScript(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScript(jsn : TJsonObject) : TFhirTestScript;
begin
  result := TFhirTestScript.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseTestScriptContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('metadata') then
        result.metadata := ParseTestScriptMetadata(jsn.vObj['metadata']);{q}
    if jsn.has('multiserver') or jsn.has('_multiserver') then
        result.multiserverElement := ParseBoolean(jsn['multiserver'], jsn.vObj['_multiserver']);{q}
    if jsn.has('fixture') then
      iterateArray(jsn.vArr['fixture'], result.fixtureList, parseTestScriptFixture);
    if jsn.has('profile') then
      iterateArray(jsn.vArr['profile'], result.profileList, parseReference{TFhirReference});
    if jsn.has('variable') then
      iterateArray(jsn.vArr['variable'], result.variableList, parseTestScriptVariable);
    if jsn.has('setup') then
        result.setup := ParseTestScriptSetup(jsn.vObj['setup']);{q}
    if jsn.has('test') then
      iterateArray(jsn.vArr['test'], result.testList, parseTestScriptTest);
    if jsn.has('teardown') then
        result.teardown := ParseTestScriptTeardown(jsn.vObj['teardown']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeTestScript(json : TJSONWriter; name : string; elem : TFhirTestScript; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeTestScriptContact(json, '', elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.useContextList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptMetadata(json, 'metadata', elem.metadata); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'multiserver', elem.multiserverElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'multiserver', elem.multiserverElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.fixtureList.Count > 0) then
  begin
    json.valueArray('fixture');
    for i := 0 to elem.fixtureList.Count - 1 do
      ComposeTestScriptFixture(json, '', elem.fixtureList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.profileList.Count > 0) then
  begin
    json.valueArray('profile');
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.profileList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.variableList.Count > 0) then
  begin
    json.valueArray('variable');
    for i := 0 to elem.variableList.Count - 1 do
      ComposeTestScriptVariable(json, '', elem.variableList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetup(json, 'setup', elem.setup); {a}
  if (SummaryOption in [soFull, soData]) and (elem.testList.Count > 0) then
  begin
    json.valueArray('test');
    for i := 0 to elem.testList.Count - 1 do
      ComposeTestScriptTest(json, '', elem.testList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptTeardown(json, 'teardown', elem.teardown); {a}
end;

procedure TFHIRRDFComposer.ComposeTestScript(parent :  TRDFComplex; parentType, name : String; elem : TFhirTestScript; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:TestScript');
  end;
  composeDomainResource(this, 'TestScript', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'TestScript', 'url', elem.urlElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TestScript', 'version', elem.versionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TestScript', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'TestScript', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'TestScript', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'TestScript', 'experimental', elem.experimentalElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TestScript', 'publisher', elem.publisherElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeTestScriptContact(this, 'TestScript', 'contact', elem.contactList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'TestScript', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TestScript', 'description', elem.descriptionElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(this, 'TestScript', 'useContext', elem.useContextList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript', 'requirements', elem.requirementsElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript', 'copyright', elem.copyrightElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptMetadata(this, 'TestScript', 'metadata', elem.metadataElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TestScript', 'multiserver', elem.multiserverElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.fixtureList.Count - 1 do
      ComposeTestScriptFixture(this, 'TestScript', 'fixture', elem.fixtureList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'TestScript', 'profile', elem.profileList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.variableList.Count - 1 do
      ComposeTestScriptVariable(this, 'TestScript', 'variable', elem.variableList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetup(this, 'TestScript', 'setup', elem.setupElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.testList.Count - 1 do
      ComposeTestScriptTest(this, 'TestScript', 'test', elem.testList[i], i);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptTeardown(this, 'TestScript', 'teardown', elem.teardownElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseValueSetContact(element : IXmlDomElement; path : string) : TFhirValueSetContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetContact(xml : TXmlBuilder; name : string; elem : TFhirValueSetContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetContact(jsn : TJsonObject) : TFhirValueSetContact;
begin
  result := TFhirValueSetContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetContact(json : TJSONWriter; name : string; elem : TFhirValueSetContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeValueSetContact(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetContact; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ValueSetContact');
  end;
  composeBackboneElement(this, 'ValueSetContact', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ValueSetContact', 'name', elem.nameElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'ValueSetContact', 'telecom', elem.telecomList[i], i);
end;

function TFHIRXmlParser.ParseValueSetCodeSystem(element : IXmlDomElement; path : string) : TFhirValueSetCodeSystem;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetCodeSystem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'caseSensitive') then
        result.caseSensitiveElement := ParseBoolean(child, path+'/caseSensitive') {b}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseValueSetCodeSystemConcept(child, path+'/concept')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetCodeSystem(xml : TXmlBuilder; name : string; elem : TFhirValueSetCodeSystem);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'system', elem.systemElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'caseSensitive', elem.caseSensitiveElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetCodeSystemConcept(xml, 'concept', elem.conceptList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetCodeSystem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetCodeSystem(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetCodeSystem(jsn : TJsonObject) : TFhirValueSetCodeSystem;
begin
  result := TFhirValueSetCodeSystem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('caseSensitive') or jsn.has('_caseSensitive') then
        result.caseSensitiveElement := ParseBoolean(jsn['caseSensitive'], jsn.vObj['_caseSensitive']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseValueSetCodeSystemConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetCodeSystem(json : TJSONWriter; name : string; elem : TFhirValueSetCodeSystem; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'caseSensitive', elem.caseSensitiveElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'caseSensitive', elem.caseSensitiveElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.conceptList.Count > 0) then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetCodeSystemConcept(json, '', elem.conceptList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeValueSetCodeSystem(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetCodeSystem; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ValueSetCodeSystem');
  end;
  composeBackboneElement(this, 'ValueSetCodeSystem', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ValueSetCodeSystem', 'system', elem.systemElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ValueSetCodeSystem', 'version', elem.versionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ValueSetCodeSystem', 'caseSensitive', elem.caseSensitiveElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetCodeSystemConcept(this, 'ValueSetCodeSystem', 'concept', elem.conceptList[i], i);
end;

function TFHIRXmlParser.ParseValueSetCodeSystemConcept(element : IXmlDomElement; path : string) : TFhirValueSetCodeSystemConcept;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetCodeSystemConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'abstract') then
        result.abstractElement := ParseBoolean(child, path+'/abstract') {b}
      else if (child.baseName = 'display') then
        result.displayElement := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'definition') then
        result.definitionElement := ParseString(child, path+'/definition') {b}
      else if (child.baseName = 'designation') then
        result.designationList.Add(ParseValueSetCodeSystemConceptDesignation(child, path+'/designation')){y.2}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseValueSetCodeSystemConcept(child, path+'/concept')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetCodeSystemConcept(xml : TXmlBuilder; name : string; elem : TFhirValueSetCodeSystemConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'abstract', elem.abstractElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'definition', elem.definitionElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetCodeSystemConceptDesignation(xml, 'designation', elem.designationList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetCodeSystemConcept(xml, 'concept', elem.conceptList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetCodeSystemConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetCodeSystemConcept(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetCodeSystemConcept(jsn : TJsonObject) : TFhirValueSetCodeSystemConcept;
begin
  result := TFhirValueSetCodeSystemConcept.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('abstract') or jsn.has('_abstract') then
        result.abstractElement := ParseBoolean(jsn['abstract'], jsn.vObj['_abstract']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := ParseString(jsn['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('designation') then
      iterateArray(jsn.vArr['designation'], result.designationList, parseValueSetCodeSystemConceptDesignation);
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseValueSetCodeSystemConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetCodeSystemConcept(json : TJSONWriter; name : string; elem : TFhirValueSetCodeSystemConcept; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'abstract', elem.abstractElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'abstract', elem.abstractElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.designationList.Count > 0) then
  begin
    json.valueArray('designation');
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetCodeSystemConceptDesignation(json, '', elem.designationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.conceptList.Count > 0) then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetCodeSystemConcept(json, '', elem.conceptList[i]); {z - @ValueSet.codeSystem.concept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeValueSetCodeSystemConcept(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetCodeSystemConcept; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ValueSetCodeSystemConcept');
  end;
  composeBackboneElement(this, 'ValueSetCodeSystemConcept', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ValueSetCodeSystemConcept', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ValueSetCodeSystemConcept', 'abstract', elem.abstractElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSetCodeSystemConcept', 'display', elem.displayElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSetCodeSystemConcept', 'definition', elem.definitionElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetCodeSystemConceptDesignation(this, 'ValueSetCodeSystemConcept', 'designation', elem.designationList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetCodeSystemConcept(this, 'ValueSetCodeSystemConcept', 'concept', elem.conceptList[i], i);
end;

function TFHIRXmlParser.ParseValueSetCodeSystemConceptDesignation(element : IXmlDomElement; path : string) : TFhirValueSetCodeSystemConceptDesignation;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetCodeSystemConceptDesignation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'language') then
        result.languageElement := ParseCode(child, path+'/language') {b}
      else if (child.baseName = 'use') then
        result.use := ParseCoding(child, path+'/use') {b}
      else if (child.baseName = 'value') then
        result.valueElement := ParseString(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetCodeSystemConceptDesignation(xml : TXmlBuilder; name : string; elem : TFhirValueSetCodeSystemConceptDesignation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'language', elem.languageElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'use', elem.use);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetCodeSystemConceptDesignation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetCodeSystemConceptDesignation(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetCodeSystemConceptDesignation(jsn : TJsonObject) : TFhirValueSetCodeSystemConceptDesignation;
begin
  result := TFhirValueSetCodeSystemConceptDesignation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('language') or jsn.has('_language') then
        result.languageElement := ParseCode(jsn['language'], jsn.vObj['_language']);{q}
    if jsn.has('use') then
        result.use := ParseCoding(jsn.vObj['use']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetCodeSystemConceptDesignation(json : TJSONWriter; name : string; elem : TFhirValueSetCodeSystemConceptDesignation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'use', elem.use); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeValueSetCodeSystemConceptDesignation(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetCodeSystemConceptDesignation; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ValueSetCodeSystemConceptDesignation');
  end;
  composeBackboneElement(this, 'ValueSetCodeSystemConceptDesignation', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ValueSetCodeSystemConceptDesignation', 'language', elem.languageElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(false, this, 'ValueSetCodeSystemConceptDesignation', 'use', elem.useElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSetCodeSystemConceptDesignation', 'value', elem.valueElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseValueSetCompose(element : IXmlDomElement; path : string) : TFhirValueSetCompose;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetCompose.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'import') then
        result.importList.Add(ParseUri(child, path+'/import')){y.2}
      else if (child.baseName = 'include') then
        result.includeList.Add(ParseValueSetComposeInclude(child, path+'/include')){y.2}
      else if (child.baseName = 'exclude') then
        result.excludeList.Add(ParseValueSetComposeInclude(child, path+'/exclude')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetCompose(xml : TXmlBuilder; name : string; elem : TFhirValueSetCompose);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.importList.Count - 1 do
      ComposeUri(xml, 'import', elem.importList[i]);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.includeList.Count - 1 do
      ComposeValueSetComposeInclude(xml, 'include', elem.includeList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeValueSetComposeInclude(xml, 'exclude', elem.excludeList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetCompose(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetCompose(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetCompose(jsn : TJsonObject) : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('import') or jsn.has('_import') then
      iteratePrimitiveArray(jsn.vArr['import'], jsn.vArr['_import'], result.importList, parseUri);
    if jsn.has('include') then
      iterateArray(jsn.vArr['include'], result.includeList, parseValueSetComposeInclude);
    if jsn.has('exclude') then
      iterateArray(jsn.vArr['exclude'], result.excludeList, parseValueSetComposeInclude);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetCompose(json : TJSONWriter; name : string; elem : TFhirValueSetCompose; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.importList.Count > 0) then
  begin
    json.valueArray('import');
    ext := false;
    for i := 0 to elem.importList.Count - 1 do
    begin
      ext := ext or ((elem.importList[i].id <> '') or (elem.importList[i].hasExtensionList));
      ComposeUriValue(json, '',elem.importList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_import');
      for i := 0 to elem.importList.Count - 1 do
        ComposeUriProps(json, '',elem.importList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.includeList.Count > 0) then
  begin
    json.valueArray('include');
    for i := 0 to elem.includeList.Count - 1 do
      ComposeValueSetComposeInclude(json, '', elem.includeList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.excludeList.Count > 0) then
  begin
    json.valueArray('exclude');
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeValueSetComposeInclude(json, '', elem.excludeList[i]); {z - @ValueSet.compose.include}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeValueSetCompose(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetCompose; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ValueSetCompose');
  end;
  composeBackboneElement(this, 'ValueSetCompose', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.importList.Count - 1 do
      ComposeUri(this, 'ValueSetCompose', 'import', elem.importList[i], i);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.includeList.Count - 1 do
      ComposeValueSetComposeInclude(this, 'ValueSetCompose', 'include', elem.includeList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeValueSetComposeInclude(this, 'ValueSetCompose', 'exclude', elem.excludeList[i], i);
end;

function TFHIRXmlParser.ParseValueSetComposeInclude(element : IXmlDomElement; path : string) : TFhirValueSetComposeInclude;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseValueSetComposeIncludeConcept(child, path+'/concept')){y.2}
      else if (child.baseName = 'filter') then
        result.filterList.Add(ParseValueSetComposeIncludeFilter(child, path+'/filter')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeInclude(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeInclude);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'system', elem.systemElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetComposeIncludeConcept(xml, 'concept', elem.conceptList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.filterList.Count - 1 do
      ComposeValueSetComposeIncludeFilter(xml, 'filter', elem.filterList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetComposeInclude(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeInclude(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetComposeInclude(jsn : TJsonObject) : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseValueSetComposeIncludeConcept);
    if jsn.has('filter') then
      iterateArray(jsn.vArr['filter'], result.filterList, parseValueSetComposeIncludeFilter);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeInclude(json : TJSONWriter; name : string; elem : TFhirValueSetComposeInclude; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.conceptList.Count > 0) then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetComposeIncludeConcept(json, '', elem.conceptList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.filterList.Count > 0) then
  begin
    json.valueArray('filter');
    for i := 0 to elem.filterList.Count - 1 do
      ComposeValueSetComposeIncludeFilter(json, '', elem.filterList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeValueSetComposeInclude(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetComposeInclude; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ValueSetComposeInclude');
  end;
  composeBackboneElement(this, 'ValueSetComposeInclude', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ValueSetComposeInclude', 'system', elem.systemElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ValueSetComposeInclude', 'version', elem.versionElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetComposeIncludeConcept(this, 'ValueSetComposeInclude', 'concept', elem.conceptList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.filterList.Count - 1 do
      ComposeValueSetComposeIncludeFilter(this, 'ValueSetComposeInclude', 'filter', elem.filterList[i], i);
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeConcept(element : IXmlDomElement; path : string) : TFhirValueSetComposeIncludeConcept;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'display') then
        result.displayElement := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'designation') then
        result.designationList.Add(ParseValueSetCodeSystemConceptDesignation(child, path+'/designation')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeConcept(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetCodeSystemConceptDesignation(xml, 'designation', elem.designationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeIncludeConcept(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetComposeIncludeConcept(jsn : TJsonObject) : TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('designation') then
      iterateArray(jsn.vArr['designation'], result.designationList, parseValueSetCodeSystemConceptDesignation);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeIncludeConcept(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeConcept; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.designationList.Count > 0) then
  begin
    json.valueArray('designation');
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetCodeSystemConceptDesignation(json, '', elem.designationList[i]); {z - @ValueSet.codeSystem.concept.designation}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeValueSetComposeIncludeConcept(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeConcept; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ValueSetComposeIncludeConcept');
  end;
  composeBackboneElement(this, 'ValueSetComposeIncludeConcept', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ValueSetComposeIncludeConcept', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSetComposeIncludeConcept', 'display', elem.displayElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetCodeSystemConceptDesignation(this, 'ValueSetComposeIncludeConcept', 'designation', elem.designationList[i], i);
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeFilter(element : IXmlDomElement; path : string) : TFhirValueSetComposeIncludeFilter;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'property') then
        result.property_Element := ParseCode(child, path+'/property') {b}
      else if (child.baseName = 'op') then
        result.opElement := ParseEnum(CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum, path+'/op', child){1a}
      else if (child.baseName = 'value') then
        result.valueElement := ParseCode(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeFilter(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeFilter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'property', elem.property_Element);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(xml, 'op', elem.OpElement, CODES_TFhirFilterOperatorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'value', elem.valueElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeFilter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeIncludeFilter(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetComposeIncludeFilter(jsn : TJsonObject) : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('property') or jsn.has('_property') then
        result.property_Element := ParseCode(jsn['property'], jsn.vObj['_property']);{q}
    if jsn.has('op') or jsn.has('_op')  then
      result.opElement := parseEnum(jsn.path+'/op', jsn['op'], jsn.vObj['_op'], CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseCode(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeIncludeFilter(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeFilter; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'property', elem.property_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'property', elem.property_Element, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumValue(json, 'op', elem.OpElement, CODES_TFhirFilterOperatorEnum, false);
  if (SummaryOption in [soFull, soData]) then
     ComposeEnumProps(json, 'op', elem.OpElement, CODES_TFhirFilterOperatorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeValueSetComposeIncludeFilter(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeFilter; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ValueSetComposeIncludeFilter');
  end;
  composeBackboneElement(this, 'ValueSetComposeIncludeFilter', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ValueSetComposeIncludeFilter', 'property', elem.property_Element, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
     ComposeEnum(this, 'ValueSetComposeIncludeFilter', 'op', elem.OpElement, CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ValueSetComposeIncludeFilter', 'value', elem.valueElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseValueSetExpansion(element : IXmlDomElement; path : string) : TFhirValueSetExpansion;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetExpansion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierElement := ParseUri(child, path+'/identifier') {b}
      else if (child.baseName = 'timestamp') then
        result.timestampElement := ParseDateTime(child, path+'/timestamp') {b}
      else if (child.baseName = 'total') then
        result.totalElement := ParseInteger(child, path+'/total') {b}
      else if (child.baseName = 'offset') then
        result.offsetElement := ParseInteger(child, path+'/offset') {b}
      else if (child.baseName = 'parameter') then
        result.parameterList.Add(ParseValueSetExpansionParameter(child, path+'/parameter')){y.2}
      else if (child.baseName = 'contains') then
        result.containsList.Add(ParseValueSetExpansionContains(child, path+'/contains')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansion(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansion);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'identifier', elem.identifierElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'timestamp', elem.timestampElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'total', elem.totalElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'offset', elem.offsetElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeValueSetExpansionParameter(xml, 'parameter', elem.parameterList[i]);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(xml, 'contains', elem.containsList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetExpansion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetExpansion(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetExpansion(jsn : TJsonObject) : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierElement := ParseUri(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('timestamp') or jsn.has('_timestamp') then
        result.timestampElement := ParseDateTime(jsn['timestamp'], jsn.vObj['_timestamp']);{q}
    if jsn.has('total') or jsn.has('_total') then
        result.totalElement := ParseInteger(jsn['total'], jsn.vObj['_total']);{q}
    if jsn.has('offset') or jsn.has('_offset') then
        result.offsetElement := ParseInteger(jsn['offset'], jsn.vObj['_offset']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseValueSetExpansionParameter);
    if jsn.has('contains') then
      iterateArray(jsn.vArr['contains'], result.containsList, parseValueSetExpansionContains);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetExpansion(json : TJSONWriter; name : string; elem : TFhirValueSetExpansion; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'identifier', elem.identifierElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'identifier', elem.identifierElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'timestamp', elem.timestampElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'timestamp', elem.timestampElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'total', elem.totalElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'total', elem.totalElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'offset', elem.offsetElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'offset', elem.offsetElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.parameterList.Count > 0) then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeValueSetExpansionParameter(json, '', elem.parameterList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.containsList.Count > 0) then
  begin
    json.valueArray('contains');
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(json, '', elem.containsList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeValueSetExpansion(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetExpansion; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ValueSetExpansion');
  end;
  composeBackboneElement(this, 'ValueSetExpansion', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ValueSetExpansion', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'ValueSetExpansion', 'timestamp', elem.timestampElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'ValueSetExpansion', 'total', elem.totalElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'ValueSetExpansion', 'offset', elem.offsetElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeValueSetExpansionParameter(this, 'ValueSetExpansion', 'parameter', elem.parameterList[i], i);
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(this, 'ValueSetExpansion', 'contains', elem.containsList[i], i);
end;

function TFHIRXmlParser.ParseValueSetExpansionParameter(element : IXmlDomElement; path : string) : TFhirValueSetExpansionParameter;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetExpansionParameter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.baseName = 'valueInteger') then
        result.value := ParseInteger(child, path+'/valueInteger'){x.3}
      else if (child.baseName = 'valueDecimal') then
        result.value := ParseDecimal(child, path+'/valueDecimal'){x.3}
      else if (child.baseName = 'valueUri') then
        result.value := ParseUri(child, path+'/valueUri'){x.3}
      else if (child.baseName = 'valueCode') then
        result.value := ParseCode(child, path+'/valueCode'){x.3}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionParameter(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansionParameter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetExpansionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetExpansionParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetExpansionParameter(jsn : TJsonObject) : TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := parseDecimal(jsn['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
      result.value := parseUri(jsn['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('valueCode') or jsn.has('_valueCode') then
      result.value := parseCode(jsn['valueCode'], jsn.vObj['_valueCode']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetExpansionParameter(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionParameter; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCode) then 
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeValueSetExpansionParameter(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetExpansionParameter; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ValueSetExpansionParameter');
  end;
  composeBackboneElement(this, 'ValueSetExpansionParameter', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSetExpansionParameter', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'ValueSetExpansionParameter', 'valueString', TFhirString(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ValueSetExpansionParameter', 'valueBoolean', TFhirBoolean(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'ValueSetExpansionParameter', 'valueInteger', TFhirInteger(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ValueSetExpansionParameter', 'valueDecimal', TFhirDecimal(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'ValueSetExpansionParameter', 'valueUri', TFhirUri(elem.value), -1)
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCode) {6} then
    ComposeCode(this, 'ValueSetExpansionParameter', 'valueCode', TFhirCode(elem.value), -1);
end;

function TFHIRXmlParser.ParseValueSetExpansionContains(element : IXmlDomElement; path : string) : TFhirValueSetExpansionContains;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'abstract') then
        result.abstractElement := ParseBoolean(child, path+'/abstract') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'code') then
        result.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'display') then
        result.displayElement := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'contains') then
        result.containsList.Add(ParseValueSetExpansionContains(child, path+'/contains')){y.2}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionContains(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansionContains);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'system', elem.systemElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'abstract', elem.abstractElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(xml, 'contains', elem.containsList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetExpansionContains(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetExpansionContains(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetExpansionContains(jsn : TJsonObject) : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('abstract') or jsn.has('_abstract') then
        result.abstractElement := ParseBoolean(jsn['abstract'], jsn.vObj['_abstract']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('contains') then
      iterateArray(jsn.vArr['contains'], result.containsList, parseValueSetExpansionContains);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetExpansionContains(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionContains; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'abstract', elem.abstractElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'abstract', elem.abstractElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.containsList.Count > 0) then
  begin
    json.valueArray('contains');
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(json, '', elem.containsList[i]); {z - @ValueSet.expansion.contains}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeValueSetExpansionContains(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSetExpansionContains; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ValueSetExpansionContains');
  end;
  composeBackboneElement(this, 'ValueSetExpansionContains', name, elem, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ValueSetExpansionContains', 'system', elem.systemElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ValueSetExpansionContains', 'abstract', elem.abstractElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSetExpansionContains', 'version', elem.versionElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ValueSetExpansionContains', 'code', elem.codeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSetExpansionContains', 'display', elem.displayElement, -1);{x.2}
  if SummaryOption in [soFull, soData] then
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(this, 'ValueSetExpansionContains', 'contains', elem.containsList[i], i);
end;

function TFHIRXmlParser.ParseValueSet(element : IXmlDomElement; path : string) : TFhirValueSet;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSet.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'url') then
        result.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'version') then
        result.versionElement := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.nameElement := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'status') then
        result.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.baseName = 'experimental') then
        result.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'publisher') then
        result.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseValueSetContact(child, path+'/contact')){y.2}
      else if (child.baseName = 'date') then
        result.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'lockedDate') then
        result.lockedDateElement := ParseDate(child, path+'/lockedDate') {b}
      else if (child.baseName = 'description') then
        result.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'useContext') then
        result.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.baseName = 'immutable') then
        result.immutableElement := ParseBoolean(child, path+'/immutable') {b}
      else if (child.baseName = 'requirements') then
        result.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'copyright') then
        result.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.baseName = 'extensible') then
        result.extensibleElement := ParseBoolean(child, path+'/extensible') {b}
      else if (child.baseName = 'codeSystem') then
        result.codeSystem := ParseValueSetCodeSystem(child, path+'/codeSystem') {b}
      else if (child.baseName = 'compose') then
        result.compose := ParseValueSetCompose(child, path+'/compose') {b}
      else if (child.baseName = 'expansion') then
        result.expansion := ParseValueSetExpansion(child, path+'/expansion') {b}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSet(xml : TXmlBuilder; name : string; elem : TFhirValueSet);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeValueSetContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'lockedDate', elem.lockedDateElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'immutable', elem.immutableElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyright', elem.copyrightElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'extensible', elem.extensibleElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeValueSetCodeSystem(xml, 'codeSystem', elem.codeSystem);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeValueSetCompose(xml, 'compose', elem.compose);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeValueSetExpansion(xml, 'expansion', elem.expansion);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSet(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSet(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSet(jsn : TJsonObject) : TFhirValueSet;
begin
  result := TFhirValueSet.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseValueSetContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('lockedDate') or jsn.has('_lockedDate') then
        result.lockedDateElement := ParseDate(jsn['lockedDate'], jsn.vObj['_lockedDate']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('immutable') or jsn.has('_immutable') then
        result.immutableElement := ParseBoolean(jsn['immutable'], jsn.vObj['_immutable']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('extensible') or jsn.has('_extensible') then
        result.extensibleElement := ParseBoolean(jsn['extensible'], jsn.vObj['_extensible']);{q}
    if jsn.has('codeSystem') then
        result.codeSystem := ParseValueSetCodeSystem(jsn.vObj['codeSystem']);{q}
    if jsn.has('compose') then
        result.compose := ParseValueSetCompose(jsn.vObj['compose']);{q}
    if jsn.has('expansion') then
        result.expansion := ParseValueSetExpansion(jsn.vObj['expansion']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSet(json : TJSONWriter; name : string; elem : TFhirValueSet; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeValueSetContact(json, '', elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'lockedDate', elem.lockedDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'lockedDate', elem.lockedDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.useContextList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'immutable', elem.immutableElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'immutable', elem.immutableElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'extensible', elem.extensibleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'extensible', elem.extensibleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeValueSetCodeSystem(json, 'codeSystem', elem.codeSystem); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeValueSetCompose(json, 'compose', elem.compose); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeValueSetExpansion(json, 'expansion', elem.expansion); {a}
end;

procedure TFHIRRDFComposer.ComposeValueSet(parent :  TRDFComplex; parentType, name : String; elem : TFhirValueSet; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:ValueSet');
  end;
  composeDomainResource(this, 'ValueSet', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ValueSet', 'url', elem.urlElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'ValueSet', 'identifier', elem.identifierElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ValueSet', 'version', elem.versionElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ValueSet', 'name', elem.nameElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'ValueSet', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ValueSet', 'experimental', elem.experimentalElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ValueSet', 'publisher', elem.publisherElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeValueSetContact(this, 'ValueSet', 'contact', elem.contactList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ValueSet', 'date', elem.dateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'ValueSet', 'lockedDate', elem.lockedDateElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ValueSet', 'description', elem.descriptionElement, -1);{x.2}
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(this, 'ValueSet', 'useContext', elem.useContextList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ValueSet', 'immutable', elem.immutableElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet', 'requirements', elem.requirementsElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet', 'copyright', elem.copyrightElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ValueSet', 'extensible', elem.extensibleElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeValueSetCodeSystem(this, 'ValueSet', 'codeSystem', elem.codeSystemElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeValueSetCompose(this, 'ValueSet', 'compose', elem.composeElement, -1);{x.2}
  if (SummaryOption in [soFull, soData]) then
    ComposeValueSetExpansion(this, 'ValueSet', 'expansion', elem.expansionElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseVisionPrescriptionDispense(element : IXmlDomElement; path : string) : TFhirVisionPrescriptionDispense;
var
  child : IXMLDOMElement;
begin
  result := TFhirVisionPrescriptionDispense.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'product') then
        result.product := ParseCoding(child, path+'/product') {b}
      else if (child.baseName = 'eye') then
        result.eyeElement := ParseEnum(CODES_TFhirVisionEyeCodesEnum, SYSTEMS_TFhirVisionEyeCodesEnum, path+'/eye', child){1a}
      else if (child.baseName = 'sphere') then
        result.sphereElement := ParseDecimal(child, path+'/sphere') {b}
      else if (child.baseName = 'cylinder') then
        result.cylinderElement := ParseDecimal(child, path+'/cylinder') {b}
      else if (child.baseName = 'axis') then
        result.axisElement := ParseInteger(child, path+'/axis') {b}
      else if (child.baseName = 'prism') then
        result.prismElement := ParseDecimal(child, path+'/prism') {b}
      else if (child.baseName = 'base') then
        result.baseElement := ParseEnum(CODES_TFhirVisionBaseCodesEnum, SYSTEMS_TFhirVisionBaseCodesEnum, path+'/base', child){1a}
      else if (child.baseName = 'add') then
        result.addElement := ParseDecimal(child, path+'/add') {b}
      else if (child.baseName = 'power') then
        result.powerElement := ParseDecimal(child, path+'/power') {b}
      else if (child.baseName = 'backCurve') then
        result.backCurveElement := ParseDecimal(child, path+'/backCurve') {b}
      else if (child.baseName = 'diameter') then
        result.diameterElement := ParseDecimal(child, path+'/diameter') {b}
      else if (child.baseName = 'duration') then
        result.duration := ParseQuantity(child, path+'/duration') {b}
      else if (child.baseName = 'color') then
        result.colorElement := ParseString(child, path+'/color') {b}
      else if (child.baseName = 'brand') then
        result.brandElement := ParseString(child, path+'/brand') {b}
      else if (child.baseName = 'notes') then
        result.notesElement := ParseString(child, path+'/notes') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescriptionDispense(xml : TXmlBuilder; name : string; elem : TFhirVisionPrescriptionDispense);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'product', elem.product);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'eye', elem.EyeElement, CODES_TFhirVisionEyeCodesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'sphere', elem.sphereElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'cylinder', elem.cylinderElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'axis', elem.axisElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'prism', elem.prismElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(xml, 'base', elem.BaseElement, CODES_TFhirVisionBaseCodesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'add', elem.addElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'power', elem.powerElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'backCurve', elem.backCurveElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'diameter', elem.diameterElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'duration', elem.duration);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'color', elem.colorElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'brand', elem.brandElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'notes', elem.notesElement);{x.2}
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseVisionPrescriptionDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseVisionPrescriptionDispense(jsn)); {2}
end;

function TFHIRJsonParser.ParseVisionPrescriptionDispense(jsn : TJsonObject) : TFhirVisionPrescriptionDispense;
begin
  result := TFhirVisionPrescriptionDispense.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('product') then
        result.product := ParseCoding(jsn.vObj['product']);{q}
    if jsn.has('eye') or jsn.has('_eye')  then
      result.eyeElement := parseEnum(jsn.path+'/eye', jsn['eye'], jsn.vObj['_eye'], CODES_TFhirVisionEyeCodesEnum, SYSTEMS_TFhirVisionEyeCodesEnum);
    if jsn.has('sphere') or jsn.has('_sphere') then
        result.sphereElement := ParseDecimal(jsn['sphere'], jsn.vObj['_sphere']);{q}
    if jsn.has('cylinder') or jsn.has('_cylinder') then
        result.cylinderElement := ParseDecimal(jsn['cylinder'], jsn.vObj['_cylinder']);{q}
    if jsn.has('axis') or jsn.has('_axis') then
        result.axisElement := ParseInteger(jsn['axis'], jsn.vObj['_axis']);{q}
    if jsn.has('prism') or jsn.has('_prism') then
        result.prismElement := ParseDecimal(jsn['prism'], jsn.vObj['_prism']);{q}
    if jsn.has('base') or jsn.has('_base')  then
      result.baseElement := parseEnum(jsn.path+'/base', jsn['base'], jsn.vObj['_base'], CODES_TFhirVisionBaseCodesEnum, SYSTEMS_TFhirVisionBaseCodesEnum);
    if jsn.has('add') or jsn.has('_add') then
        result.addElement := ParseDecimal(jsn['add'], jsn.vObj['_add']);{q}
    if jsn.has('power') or jsn.has('_power') then
        result.powerElement := ParseDecimal(jsn['power'], jsn.vObj['_power']);{q}
    if jsn.has('backCurve') or jsn.has('_backCurve') then
        result.backCurveElement := ParseDecimal(jsn['backCurve'], jsn.vObj['_backCurve']);{q}
    if jsn.has('diameter') or jsn.has('_diameter') then
        result.diameterElement := ParseDecimal(jsn['diameter'], jsn.vObj['_diameter']);{q}
    if jsn.has('duration') then
        result.duration := ParseQuantity(jsn.vObj['duration']);{q}
    if jsn.has('color') or jsn.has('_color') then
        result.colorElement := ParseString(jsn['color'], jsn.vObj['_color']);{q}
    if jsn.has('brand') or jsn.has('_brand') then
        result.brandElement := ParseString(jsn['brand'], jsn.vObj['_brand']);{q}
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesElement := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeVisionPrescriptionDispense(json : TJSONWriter; name : string; elem : TFhirVisionPrescriptionDispense; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'product', elem.product); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'eye', elem.EyeElement, CODES_TFhirVisionEyeCodesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'eye', elem.EyeElement, CODES_TFhirVisionEyeCodesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'sphere', elem.sphereElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'sphere', elem.sphereElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'cylinder', elem.cylinderElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'cylinder', elem.cylinderElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'axis', elem.axisElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'axis', elem.axisElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'prism', elem.prismElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'prism', elem.prismElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumValue(json, 'base', elem.BaseElement, CODES_TFhirVisionBaseCodesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnumProps(json, 'base', elem.BaseElement, CODES_TFhirVisionBaseCodesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'add', elem.addElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'add', elem.addElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'power', elem.powerElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'power', elem.powerElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'backCurve', elem.backCurveElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'backCurve', elem.backCurveElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'diameter', elem.diameterElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'diameter', elem.diameterElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'duration', elem.duration); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'color', elem.colorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'color', elem.colorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'brand', elem.brandElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'brand', elem.brandElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'notes', elem.notesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'notes', elem.notesElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRRDFComposer.ComposeVisionPrescriptionDispense(parent :  TRDFComplex; parentType, name : String; elem : TFhirVisionPrescriptionDispense; index : integer);
var
  this : TRDFComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:VisionPrescriptionDispense');
  end;
  composeBackboneElement(this, 'VisionPrescriptionDispense', name, elem, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(false, this, 'VisionPrescriptionDispense', 'product', elem.productElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'VisionPrescriptionDispense', 'eye', elem.EyeElement, CODES_TFhirVisionEyeCodesEnum, SYSTEMS_TFhirVisionEyeCodesEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'VisionPrescriptionDispense', 'sphere', elem.sphereElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'VisionPrescriptionDispense', 'cylinder', elem.cylinderElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'VisionPrescriptionDispense', 'axis', elem.axisElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'VisionPrescriptionDispense', 'prism', elem.prismElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
     ComposeEnum(this, 'VisionPrescriptionDispense', 'base', elem.BaseElement, CODES_TFhirVisionBaseCodesEnum, SYSTEMS_TFhirVisionBaseCodesEnum, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'VisionPrescriptionDispense', 'add', elem.addElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'VisionPrescriptionDispense', 'power', elem.powerElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'VisionPrescriptionDispense', 'backCurve', elem.backCurveElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'VisionPrescriptionDispense', 'diameter', elem.diameterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'VisionPrescriptionDispense', 'duration', elem.durationElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'VisionPrescriptionDispense', 'color', elem.colorElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'VisionPrescriptionDispense', 'brand', elem.brandElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'VisionPrescriptionDispense', 'notes', elem.notesElement, -1);{x.2}
end;

function TFHIRXmlParser.ParseVisionPrescription(element : IXmlDomElement; path : string) : TFhirVisionPrescription;
var
  child : IXMLDOMElement;
begin
  result := TFhirVisionPrescription.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.baseName = 'dateWritten') then
        result.dateWrittenElement := ParseDateTime(child, path+'/dateWritten') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'prescriber') then
        result.prescriber := ParseReference{TFhirPractitioner}(child, path+'/prescriber') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'reasonCodeableConcept') then
        result.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.baseName = 'reasonReference') then
        result.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.baseName = 'dispense') then
        result.dispenseList.Add(ParseVisionPrescriptionDispense(child, path+'/dispense')){y.2}
      else if Not ParseDomainResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescription(xml : TXmlBuilder; name : string; elem : TFhirVisionPrescription);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  xml.open(name);
  composeDomainResourceChildren(xml, elem);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'dateWritten', elem.dateWrittenElement);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'prescriber', elem.prescriber);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.dispenseList.Count - 1 do
      ComposeVisionPrescriptionDispense(xml, 'dispense', elem.dispenseList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseVisionPrescription(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseVisionPrescription(jsn)); {2}
end;

function TFHIRJsonParser.ParseVisionPrescription(jsn : TJsonObject) : TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription.create;
  try
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('dateWritten') or jsn.has('_dateWritten') then
        result.dateWrittenElement := ParseDateTime(jsn['dateWritten'], jsn.vObj['_dateWritten']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('prescriber') then
        result.prescriber := ParseReference{TFhirPractitioner}(jsn.vObj['prescriber']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('dispense') then
      iterateArray(jsn.vArr['dispense'], result.dispenseList, parseVisionPrescriptionDispense);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeVisionPrescription(json : TJSONWriter; name : string; elem : TFhirVisionPrescription; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'dateWritten', elem.dateWrittenElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'dateWritten', elem.dateWrittenElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'prescriber', elem.prescriber); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dispenseList.Count > 0) then
  begin
    json.valueArray('dispense');
    for i := 0 to elem.dispenseList.Count - 1 do
      ComposeVisionPrescriptionDispense(json, '', elem.dispenseList[i]); {z - }
    json.FinishArray;
  end;
end;

procedure TFHIRRDFComposer.ComposeVisionPrescription(parent :  TRDFComplex; parentType, name : String; elem : TFhirVisionPrescription; index : integer);
var
  this : TRDFComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.predicate('fhir:'+parentType+'.'+name);
    this.predicate('a', 'fhir:VisionPrescription');
  end;
  composeDomainResource(this, 'VisionPrescription', name, elem, index);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'VisionPrescription', 'identifier', elem.identifierList[i], i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'VisionPrescription', 'dateWritten', elem.dateWrittenElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'VisionPrescription', 'patient', elem.patientElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'VisionPrescription', 'prescriber', elem.prescriberElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'VisionPrescription', 'encounter', elem.encounterElement, -1);{x.2}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'VisionPrescription', 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason), -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(this, 'VisionPrescription', 'reasonReference', TFhirReference(elem.reason), -1);
  if SummaryOption in [soFull, soSummary, soData] then
    for i := 0 to elem.dispenseList.Count - 1 do
      ComposeVisionPrescriptionDispense(this, 'VisionPrescription', 'dispense', elem.dispenseList[i], i);
end;

function TFHIRXmlParser.ParseResource(element : IXmlDomElement; path : String) : TFhirResource;
begin
  if (element = nil) Then
    Raise Exception.Create('error - element is nil')
  else if element.baseName = 'Parameters' Then
    result := ParseParameters(element, path+'/Parameters')
  else if element.baseName = 'Account' Then
    result := ParseAccount(element, path+'/Account')
  else if element.baseName = 'AllergyIntolerance' Then
    result := ParseAllergyIntolerance(element, path+'/AllergyIntolerance')
  else if element.baseName = 'Appointment' Then
    result := ParseAppointment(element, path+'/Appointment')
  else if element.baseName = 'AppointmentResponse' Then
    result := ParseAppointmentResponse(element, path+'/AppointmentResponse')
  else if element.baseName = 'AuditEvent' Then
    result := ParseAuditEvent(element, path+'/AuditEvent')
  else if element.baseName = 'Basic' Then
    result := ParseBasic(element, path+'/Basic')
  else if element.baseName = 'Binary' Then
    result := ParseBinary(element, path+'/Binary')
  else if element.baseName = 'BodySite' Then
    result := ParseBodySite(element, path+'/BodySite')
  else if element.baseName = 'Bundle' Then
    result := ParseBundle(element, path+'/Bundle')
  else if element.baseName = 'CarePlan' Then
    result := ParseCarePlan(element, path+'/CarePlan')
  else if element.baseName = 'Claim' Then
    result := ParseClaim(element, path+'/Claim')
  else if element.baseName = 'ClaimResponse' Then
    result := ParseClaimResponse(element, path+'/ClaimResponse')
  else if element.baseName = 'ClinicalImpression' Then
    result := ParseClinicalImpression(element, path+'/ClinicalImpression')
  else if element.baseName = 'Communication' Then
    result := ParseCommunication(element, path+'/Communication')
  else if element.baseName = 'CommunicationRequest' Then
    result := ParseCommunicationRequest(element, path+'/CommunicationRequest')
  else if element.baseName = 'Composition' Then
    result := ParseComposition(element, path+'/Composition')
  else if element.baseName = 'ConceptMap' Then
    result := ParseConceptMap(element, path+'/ConceptMap')
  else if element.baseName = 'Condition' Then
    result := ParseCondition(element, path+'/Condition')
  else if element.baseName = 'Conformance' Then
    result := ParseConformance(element, path+'/Conformance')
  else if element.baseName = 'Contract' Then
    result := ParseContract(element, path+'/Contract')
  else if element.baseName = 'Coverage' Then
    result := ParseCoverage(element, path+'/Coverage')
  else if element.baseName = 'DataElement' Then
    result := ParseDataElement(element, path+'/DataElement')
  else if element.baseName = 'DetectedIssue' Then
    result := ParseDetectedIssue(element, path+'/DetectedIssue')
  else if element.baseName = 'Device' Then
    result := ParseDevice(element, path+'/Device')
  else if element.baseName = 'DeviceComponent' Then
    result := ParseDeviceComponent(element, path+'/DeviceComponent')
  else if element.baseName = 'DeviceMetric' Then
    result := ParseDeviceMetric(element, path+'/DeviceMetric')
  else if element.baseName = 'DeviceUseRequest' Then
    result := ParseDeviceUseRequest(element, path+'/DeviceUseRequest')
  else if element.baseName = 'DeviceUseStatement' Then
    result := ParseDeviceUseStatement(element, path+'/DeviceUseStatement')
  else if element.baseName = 'DiagnosticOrder' Then
    result := ParseDiagnosticOrder(element, path+'/DiagnosticOrder')
  else if element.baseName = 'DiagnosticReport' Then
    result := ParseDiagnosticReport(element, path+'/DiagnosticReport')
  else if element.baseName = 'DocumentManifest' Then
    result := ParseDocumentManifest(element, path+'/DocumentManifest')
  else if element.baseName = 'DocumentReference' Then
    result := ParseDocumentReference(element, path+'/DocumentReference')
  else if element.baseName = 'EligibilityRequest' Then
    result := ParseEligibilityRequest(element, path+'/EligibilityRequest')
  else if element.baseName = 'EligibilityResponse' Then
    result := ParseEligibilityResponse(element, path+'/EligibilityResponse')
  else if element.baseName = 'Encounter' Then
    result := ParseEncounter(element, path+'/Encounter')
  else if element.baseName = 'EnrollmentRequest' Then
    result := ParseEnrollmentRequest(element, path+'/EnrollmentRequest')
  else if element.baseName = 'EnrollmentResponse' Then
    result := ParseEnrollmentResponse(element, path+'/EnrollmentResponse')
  else if element.baseName = 'EpisodeOfCare' Then
    result := ParseEpisodeOfCare(element, path+'/EpisodeOfCare')
  else if element.baseName = 'ExplanationOfBenefit' Then
    result := ParseExplanationOfBenefit(element, path+'/ExplanationOfBenefit')
  else if element.baseName = 'FamilyMemberHistory' Then
    result := ParseFamilyMemberHistory(element, path+'/FamilyMemberHistory')
  else if element.baseName = 'Flag' Then
    result := ParseFlag(element, path+'/Flag')
  else if element.baseName = 'Goal' Then
    result := ParseGoal(element, path+'/Goal')
  else if element.baseName = 'Group' Then
    result := ParseGroup(element, path+'/Group')
  else if element.baseName = 'HealthcareService' Then
    result := ParseHealthcareService(element, path+'/HealthcareService')
  else if element.baseName = 'ImagingObjectSelection' Then
    result := ParseImagingObjectSelection(element, path+'/ImagingObjectSelection')
  else if element.baseName = 'ImagingStudy' Then
    result := ParseImagingStudy(element, path+'/ImagingStudy')
  else if element.baseName = 'Immunization' Then
    result := ParseImmunization(element, path+'/Immunization')
  else if element.baseName = 'ImmunizationRecommendation' Then
    result := ParseImmunizationRecommendation(element, path+'/ImmunizationRecommendation')
  else if element.baseName = 'ImplementationGuide' Then
    result := ParseImplementationGuide(element, path+'/ImplementationGuide')
  else if element.baseName = 'List' Then
    result := ParseList(element, path+'/List')
  else if element.baseName = 'Location' Then
    result := ParseLocation(element, path+'/Location')
  else if element.baseName = 'Media' Then
    result := ParseMedia(element, path+'/Media')
  else if element.baseName = 'Medication' Then
    result := ParseMedication(element, path+'/Medication')
  else if element.baseName = 'MedicationAdministration' Then
    result := ParseMedicationAdministration(element, path+'/MedicationAdministration')
  else if element.baseName = 'MedicationDispense' Then
    result := ParseMedicationDispense(element, path+'/MedicationDispense')
  else if element.baseName = 'MedicationOrder' Then
    result := ParseMedicationOrder(element, path+'/MedicationOrder')
  else if element.baseName = 'MedicationStatement' Then
    result := ParseMedicationStatement(element, path+'/MedicationStatement')
  else if element.baseName = 'MessageHeader' Then
    result := ParseMessageHeader(element, path+'/MessageHeader')
  else if element.baseName = 'NamingSystem' Then
    result := ParseNamingSystem(element, path+'/NamingSystem')
  else if element.baseName = 'NutritionOrder' Then
    result := ParseNutritionOrder(element, path+'/NutritionOrder')
  else if element.baseName = 'Observation' Then
    result := ParseObservation(element, path+'/Observation')
  else if element.baseName = 'OperationDefinition' Then
    result := ParseOperationDefinition(element, path+'/OperationDefinition')
  else if element.baseName = 'OperationOutcome' Then
    result := ParseOperationOutcome(element, path+'/OperationOutcome')
  else if element.baseName = 'Order' Then
    result := ParseOrder(element, path+'/Order')
  else if element.baseName = 'OrderResponse' Then
    result := ParseOrderResponse(element, path+'/OrderResponse')
  else if element.baseName = 'Organization' Then
    result := ParseOrganization(element, path+'/Organization')
  else if element.baseName = 'Patient' Then
    result := ParsePatient(element, path+'/Patient')
  else if element.baseName = 'PaymentNotice' Then
    result := ParsePaymentNotice(element, path+'/PaymentNotice')
  else if element.baseName = 'PaymentReconciliation' Then
    result := ParsePaymentReconciliation(element, path+'/PaymentReconciliation')
  else if element.baseName = 'Person' Then
    result := ParsePerson(element, path+'/Person')
  else if element.baseName = 'Practitioner' Then
    result := ParsePractitioner(element, path+'/Practitioner')
  else if element.baseName = 'Procedure' Then
    result := ParseProcedure(element, path+'/Procedure')
  else if element.baseName = 'ProcedureRequest' Then
    result := ParseProcedureRequest(element, path+'/ProcedureRequest')
  else if element.baseName = 'ProcessRequest' Then
    result := ParseProcessRequest(element, path+'/ProcessRequest')
  else if element.baseName = 'ProcessResponse' Then
    result := ParseProcessResponse(element, path+'/ProcessResponse')
  else if element.baseName = 'Provenance' Then
    result := ParseProvenance(element, path+'/Provenance')
  else if element.baseName = 'Questionnaire' Then
    result := ParseQuestionnaire(element, path+'/Questionnaire')
  else if element.baseName = 'QuestionnaireResponse' Then
    result := ParseQuestionnaireResponse(element, path+'/QuestionnaireResponse')
  else if element.baseName = 'ReferralRequest' Then
    result := ParseReferralRequest(element, path+'/ReferralRequest')
  else if element.baseName = 'RelatedPerson' Then
    result := ParseRelatedPerson(element, path+'/RelatedPerson')
  else if element.baseName = 'RiskAssessment' Then
    result := ParseRiskAssessment(element, path+'/RiskAssessment')
  else if element.baseName = 'Schedule' Then
    result := ParseSchedule(element, path+'/Schedule')
  else if element.baseName = 'SearchParameter' Then
    result := ParseSearchParameter(element, path+'/SearchParameter')
  else if element.baseName = 'Slot' Then
    result := ParseSlot(element, path+'/Slot')
  else if element.baseName = 'Specimen' Then
    result := ParseSpecimen(element, path+'/Specimen')
  else if element.baseName = 'StructureDefinition' Then
    result := ParseStructureDefinition(element, path+'/StructureDefinition')
  else if element.baseName = 'Subscription' Then
    result := ParseSubscription(element, path+'/Subscription')
  else if element.baseName = 'Substance' Then
    result := ParseSubstance(element, path+'/Substance')
  else if element.baseName = 'SupplyDelivery' Then
    result := ParseSupplyDelivery(element, path+'/SupplyDelivery')
  else if element.baseName = 'SupplyRequest' Then
    result := ParseSupplyRequest(element, path+'/SupplyRequest')
  else if element.baseName = 'TestScript' Then
    result := ParseTestScript(element, path+'/TestScript')
  else if element.baseName = 'ValueSet' Then
    result := ParseValueSet(element, path+'/ValueSet')
  else if element.baseName = 'VisionPrescription' Then
    result := ParseVisionPrescription(element, path+'/VisionPrescription')
  else
    raise Exception.create('Error: the element '+element.baseName+' is not recognised as a valid resource name');
end;

procedure TFHIRXmlComposer.ComposeResource(xml : TXmlBuilder; resource: TFhirResource; links : TFhirBundleLinkList);
begin
  if (resource = nil) Then
    Raise Exception.Create('error - resource is nil');
  Case resource.ResourceType of
    frtParameters: ComposeParameters(xml, 'Parameters', TFhirParameters(resource));
    frtAccount: ComposeAccount(xml, 'Account', TFhirAccount(resource));
    frtAllergyIntolerance: ComposeAllergyIntolerance(xml, 'AllergyIntolerance', TFhirAllergyIntolerance(resource));
    frtAppointment: ComposeAppointment(xml, 'Appointment', TFhirAppointment(resource));
    frtAppointmentResponse: ComposeAppointmentResponse(xml, 'AppointmentResponse', TFhirAppointmentResponse(resource));
    frtAuditEvent: ComposeAuditEvent(xml, 'AuditEvent', TFhirAuditEvent(resource));
    frtBasic: ComposeBasic(xml, 'Basic', TFhirBasic(resource));
    frtBinary: ComposeBinary(xml, 'Binary', TFhirBinary(resource));
    frtBodySite: ComposeBodySite(xml, 'BodySite', TFhirBodySite(resource));
    frtBundle: ComposeBundle(xml, 'Bundle', TFhirBundle(resource));
    frtCarePlan: ComposeCarePlan(xml, 'CarePlan', TFhirCarePlan(resource));
    frtClaim: ComposeClaim(xml, 'Claim', TFhirClaim(resource));
    frtClaimResponse: ComposeClaimResponse(xml, 'ClaimResponse', TFhirClaimResponse(resource));
    frtClinicalImpression: ComposeClinicalImpression(xml, 'ClinicalImpression', TFhirClinicalImpression(resource));
    frtCommunication: ComposeCommunication(xml, 'Communication', TFhirCommunication(resource));
    frtCommunicationRequest: ComposeCommunicationRequest(xml, 'CommunicationRequest', TFhirCommunicationRequest(resource));
    frtComposition: ComposeComposition(xml, 'Composition', TFhirComposition(resource));
    frtConceptMap: ComposeConceptMap(xml, 'ConceptMap', TFhirConceptMap(resource));
    frtCondition: ComposeCondition(xml, 'Condition', TFhirCondition(resource));
    frtConformance: ComposeConformance(xml, 'Conformance', TFhirConformance(resource));
    frtContract: ComposeContract(xml, 'Contract', TFhirContract(resource));
    frtCoverage: ComposeCoverage(xml, 'Coverage', TFhirCoverage(resource));
    frtDataElement: ComposeDataElement(xml, 'DataElement', TFhirDataElement(resource));
    frtDetectedIssue: ComposeDetectedIssue(xml, 'DetectedIssue', TFhirDetectedIssue(resource));
    frtDevice: ComposeDevice(xml, 'Device', TFhirDevice(resource));
    frtDeviceComponent: ComposeDeviceComponent(xml, 'DeviceComponent', TFhirDeviceComponent(resource));
    frtDeviceMetric: ComposeDeviceMetric(xml, 'DeviceMetric', TFhirDeviceMetric(resource));
    frtDeviceUseRequest: ComposeDeviceUseRequest(xml, 'DeviceUseRequest', TFhirDeviceUseRequest(resource));
    frtDeviceUseStatement: ComposeDeviceUseStatement(xml, 'DeviceUseStatement', TFhirDeviceUseStatement(resource));
    frtDiagnosticOrder: ComposeDiagnosticOrder(xml, 'DiagnosticOrder', TFhirDiagnosticOrder(resource));
    frtDiagnosticReport: ComposeDiagnosticReport(xml, 'DiagnosticReport', TFhirDiagnosticReport(resource));
    frtDocumentManifest: ComposeDocumentManifest(xml, 'DocumentManifest', TFhirDocumentManifest(resource));
    frtDocumentReference: ComposeDocumentReference(xml, 'DocumentReference', TFhirDocumentReference(resource));
    frtEligibilityRequest: ComposeEligibilityRequest(xml, 'EligibilityRequest', TFhirEligibilityRequest(resource));
    frtEligibilityResponse: ComposeEligibilityResponse(xml, 'EligibilityResponse', TFhirEligibilityResponse(resource));
    frtEncounter: ComposeEncounter(xml, 'Encounter', TFhirEncounter(resource));
    frtEnrollmentRequest: ComposeEnrollmentRequest(xml, 'EnrollmentRequest', TFhirEnrollmentRequest(resource));
    frtEnrollmentResponse: ComposeEnrollmentResponse(xml, 'EnrollmentResponse', TFhirEnrollmentResponse(resource));
    frtEpisodeOfCare: ComposeEpisodeOfCare(xml, 'EpisodeOfCare', TFhirEpisodeOfCare(resource));
    frtExplanationOfBenefit: ComposeExplanationOfBenefit(xml, 'ExplanationOfBenefit', TFhirExplanationOfBenefit(resource));
    frtFamilyMemberHistory: ComposeFamilyMemberHistory(xml, 'FamilyMemberHistory', TFhirFamilyMemberHistory(resource));
    frtFlag: ComposeFlag(xml, 'Flag', TFhirFlag(resource));
    frtGoal: ComposeGoal(xml, 'Goal', TFhirGoal(resource));
    frtGroup: ComposeGroup(xml, 'Group', TFhirGroup(resource));
    frtHealthcareService: ComposeHealthcareService(xml, 'HealthcareService', TFhirHealthcareService(resource));
    frtImagingObjectSelection: ComposeImagingObjectSelection(xml, 'ImagingObjectSelection', TFhirImagingObjectSelection(resource));
    frtImagingStudy: ComposeImagingStudy(xml, 'ImagingStudy', TFhirImagingStudy(resource));
    frtImmunization: ComposeImmunization(xml, 'Immunization', TFhirImmunization(resource));
    frtImmunizationRecommendation: ComposeImmunizationRecommendation(xml, 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource));
    frtImplementationGuide: ComposeImplementationGuide(xml, 'ImplementationGuide', TFhirImplementationGuide(resource));
    frtList: ComposeList(xml, 'List', TFhirList(resource));
    frtLocation: ComposeLocation(xml, 'Location', TFhirLocation(resource));
    frtMedia: ComposeMedia(xml, 'Media', TFhirMedia(resource));
    frtMedication: ComposeMedication(xml, 'Medication', TFhirMedication(resource));
    frtMedicationAdministration: ComposeMedicationAdministration(xml, 'MedicationAdministration', TFhirMedicationAdministration(resource));
    frtMedicationDispense: ComposeMedicationDispense(xml, 'MedicationDispense', TFhirMedicationDispense(resource));
    frtMedicationOrder: ComposeMedicationOrder(xml, 'MedicationOrder', TFhirMedicationOrder(resource));
    frtMedicationStatement: ComposeMedicationStatement(xml, 'MedicationStatement', TFhirMedicationStatement(resource));
    frtMessageHeader: ComposeMessageHeader(xml, 'MessageHeader', TFhirMessageHeader(resource));
    frtNamingSystem: ComposeNamingSystem(xml, 'NamingSystem', TFhirNamingSystem(resource));
    frtNutritionOrder: ComposeNutritionOrder(xml, 'NutritionOrder', TFhirNutritionOrder(resource));
    frtObservation: ComposeObservation(xml, 'Observation', TFhirObservation(resource));
    frtOperationDefinition: ComposeOperationDefinition(xml, 'OperationDefinition', TFhirOperationDefinition(resource));
    frtOperationOutcome: ComposeOperationOutcome(xml, 'OperationOutcome', TFhirOperationOutcome(resource));
    frtOrder: ComposeOrder(xml, 'Order', TFhirOrder(resource));
    frtOrderResponse: ComposeOrderResponse(xml, 'OrderResponse', TFhirOrderResponse(resource));
    frtOrganization: ComposeOrganization(xml, 'Organization', TFhirOrganization(resource));
    frtPatient: ComposePatient(xml, 'Patient', TFhirPatient(resource));
    frtPaymentNotice: ComposePaymentNotice(xml, 'PaymentNotice', TFhirPaymentNotice(resource));
    frtPaymentReconciliation: ComposePaymentReconciliation(xml, 'PaymentReconciliation', TFhirPaymentReconciliation(resource));
    frtPerson: ComposePerson(xml, 'Person', TFhirPerson(resource));
    frtPractitioner: ComposePractitioner(xml, 'Practitioner', TFhirPractitioner(resource));
    frtProcedure: ComposeProcedure(xml, 'Procedure', TFhirProcedure(resource));
    frtProcedureRequest: ComposeProcedureRequest(xml, 'ProcedureRequest', TFhirProcedureRequest(resource));
    frtProcessRequest: ComposeProcessRequest(xml, 'ProcessRequest', TFhirProcessRequest(resource));
    frtProcessResponse: ComposeProcessResponse(xml, 'ProcessResponse', TFhirProcessResponse(resource));
    frtProvenance: ComposeProvenance(xml, 'Provenance', TFhirProvenance(resource));
    frtQuestionnaire: ComposeQuestionnaire(xml, 'Questionnaire', TFhirQuestionnaire(resource));
    frtQuestionnaireResponse: ComposeQuestionnaireResponse(xml, 'QuestionnaireResponse', TFhirQuestionnaireResponse(resource));
    frtReferralRequest: ComposeReferralRequest(xml, 'ReferralRequest', TFhirReferralRequest(resource));
    frtRelatedPerson: ComposeRelatedPerson(xml, 'RelatedPerson', TFhirRelatedPerson(resource));
    frtRiskAssessment: ComposeRiskAssessment(xml, 'RiskAssessment', TFhirRiskAssessment(resource));
    frtSchedule: ComposeSchedule(xml, 'Schedule', TFhirSchedule(resource));
    frtSearchParameter: ComposeSearchParameter(xml, 'SearchParameter', TFhirSearchParameter(resource));
    frtSlot: ComposeSlot(xml, 'Slot', TFhirSlot(resource));
    frtSpecimen: ComposeSpecimen(xml, 'Specimen', TFhirSpecimen(resource));
    frtStructureDefinition: ComposeStructureDefinition(xml, 'StructureDefinition', TFhirStructureDefinition(resource));
    frtSubscription: ComposeSubscription(xml, 'Subscription', TFhirSubscription(resource));
    frtSubstance: ComposeSubstance(xml, 'Substance', TFhirSubstance(resource));
    frtSupplyDelivery: ComposeSupplyDelivery(xml, 'SupplyDelivery', TFhirSupplyDelivery(resource));
    frtSupplyRequest: ComposeSupplyRequest(xml, 'SupplyRequest', TFhirSupplyRequest(resource));
    frtTestScript: ComposeTestScript(xml, 'TestScript', TFhirTestScript(resource));
    frtValueSet: ComposeValueSet(xml, 'ValueSet', TFhirValueSet(resource));
    frtVisionPrescription: ComposeVisionPrescription(xml, 'VisionPrescription', TFhirVisionPrescription(resource));
  else
    raise Exception.create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;

function TFHIRJsonParser.ParseResource(jsn : TJsonObject) : TFhirResource;
var
  s : String;
begin
  s := jsn['resourceType'];
  if s = 'Parameters' Then
    result := ParseParameters(jsn)
  else if s = 'Account' Then
    result := ParseAccount(jsn)
  else if s = 'AllergyIntolerance' Then
    result := ParseAllergyIntolerance(jsn)
  else if s = 'Appointment' Then
    result := ParseAppointment(jsn)
  else if s = 'AppointmentResponse' Then
    result := ParseAppointmentResponse(jsn)
  else if s = 'AuditEvent' Then
    result := ParseAuditEvent(jsn)
  else if s = 'Basic' Then
    result := ParseBasic(jsn)
  else if s = 'Binary' Then
    result := ParseBinary(jsn)
  else if s = 'BodySite' Then
    result := ParseBodySite(jsn)
  else if s = 'Bundle' Then
    result := ParseBundle(jsn)
  else if s = 'CarePlan' Then
    result := ParseCarePlan(jsn)
  else if s = 'Claim' Then
    result := ParseClaim(jsn)
  else if s = 'ClaimResponse' Then
    result := ParseClaimResponse(jsn)
  else if s = 'ClinicalImpression' Then
    result := ParseClinicalImpression(jsn)
  else if s = 'Communication' Then
    result := ParseCommunication(jsn)
  else if s = 'CommunicationRequest' Then
    result := ParseCommunicationRequest(jsn)
  else if s = 'Composition' Then
    result := ParseComposition(jsn)
  else if s = 'ConceptMap' Then
    result := ParseConceptMap(jsn)
  else if s = 'Condition' Then
    result := ParseCondition(jsn)
  else if s = 'Conformance' Then
    result := ParseConformance(jsn)
  else if s = 'Contract' Then
    result := ParseContract(jsn)
  else if s = 'Coverage' Then
    result := ParseCoverage(jsn)
  else if s = 'DataElement' Then
    result := ParseDataElement(jsn)
  else if s = 'DetectedIssue' Then
    result := ParseDetectedIssue(jsn)
  else if s = 'Device' Then
    result := ParseDevice(jsn)
  else if s = 'DeviceComponent' Then
    result := ParseDeviceComponent(jsn)
  else if s = 'DeviceMetric' Then
    result := ParseDeviceMetric(jsn)
  else if s = 'DeviceUseRequest' Then
    result := ParseDeviceUseRequest(jsn)
  else if s = 'DeviceUseStatement' Then
    result := ParseDeviceUseStatement(jsn)
  else if s = 'DiagnosticOrder' Then
    result := ParseDiagnosticOrder(jsn)
  else if s = 'DiagnosticReport' Then
    result := ParseDiagnosticReport(jsn)
  else if s = 'DocumentManifest' Then
    result := ParseDocumentManifest(jsn)
  else if s = 'DocumentReference' Then
    result := ParseDocumentReference(jsn)
  else if s = 'EligibilityRequest' Then
    result := ParseEligibilityRequest(jsn)
  else if s = 'EligibilityResponse' Then
    result := ParseEligibilityResponse(jsn)
  else if s = 'Encounter' Then
    result := ParseEncounter(jsn)
  else if s = 'EnrollmentRequest' Then
    result := ParseEnrollmentRequest(jsn)
  else if s = 'EnrollmentResponse' Then
    result := ParseEnrollmentResponse(jsn)
  else if s = 'EpisodeOfCare' Then
    result := ParseEpisodeOfCare(jsn)
  else if s = 'ExplanationOfBenefit' Then
    result := ParseExplanationOfBenefit(jsn)
  else if s = 'FamilyMemberHistory' Then
    result := ParseFamilyMemberHistory(jsn)
  else if s = 'Flag' Then
    result := ParseFlag(jsn)
  else if s = 'Goal' Then
    result := ParseGoal(jsn)
  else if s = 'Group' Then
    result := ParseGroup(jsn)
  else if s = 'HealthcareService' Then
    result := ParseHealthcareService(jsn)
  else if s = 'ImagingObjectSelection' Then
    result := ParseImagingObjectSelection(jsn)
  else if s = 'ImagingStudy' Then
    result := ParseImagingStudy(jsn)
  else if s = 'Immunization' Then
    result := ParseImmunization(jsn)
  else if s = 'ImmunizationRecommendation' Then
    result := ParseImmunizationRecommendation(jsn)
  else if s = 'ImplementationGuide' Then
    result := ParseImplementationGuide(jsn)
  else if s = 'List' Then
    result := ParseList(jsn)
  else if s = 'Location' Then
    result := ParseLocation(jsn)
  else if s = 'Media' Then
    result := ParseMedia(jsn)
  else if s = 'Medication' Then
    result := ParseMedication(jsn)
  else if s = 'MedicationAdministration' Then
    result := ParseMedicationAdministration(jsn)
  else if s = 'MedicationDispense' Then
    result := ParseMedicationDispense(jsn)
  else if s = 'MedicationOrder' Then
    result := ParseMedicationOrder(jsn)
  else if s = 'MedicationStatement' Then
    result := ParseMedicationStatement(jsn)
  else if s = 'MessageHeader' Then
    result := ParseMessageHeader(jsn)
  else if s = 'NamingSystem' Then
    result := ParseNamingSystem(jsn)
  else if s = 'NutritionOrder' Then
    result := ParseNutritionOrder(jsn)
  else if s = 'Observation' Then
    result := ParseObservation(jsn)
  else if s = 'OperationDefinition' Then
    result := ParseOperationDefinition(jsn)
  else if s = 'OperationOutcome' Then
    result := ParseOperationOutcome(jsn)
  else if s = 'Order' Then
    result := ParseOrder(jsn)
  else if s = 'OrderResponse' Then
    result := ParseOrderResponse(jsn)
  else if s = 'Organization' Then
    result := ParseOrganization(jsn)
  else if s = 'Patient' Then
    result := ParsePatient(jsn)
  else if s = 'PaymentNotice' Then
    result := ParsePaymentNotice(jsn)
  else if s = 'PaymentReconciliation' Then
    result := ParsePaymentReconciliation(jsn)
  else if s = 'Person' Then
    result := ParsePerson(jsn)
  else if s = 'Practitioner' Then
    result := ParsePractitioner(jsn)
  else if s = 'Procedure' Then
    result := ParseProcedure(jsn)
  else if s = 'ProcedureRequest' Then
    result := ParseProcedureRequest(jsn)
  else if s = 'ProcessRequest' Then
    result := ParseProcessRequest(jsn)
  else if s = 'ProcessResponse' Then
    result := ParseProcessResponse(jsn)
  else if s = 'Provenance' Then
    result := ParseProvenance(jsn)
  else if s = 'Questionnaire' Then
    result := ParseQuestionnaire(jsn)
  else if s = 'QuestionnaireResponse' Then
    result := ParseQuestionnaireResponse(jsn)
  else if s = 'ReferralRequest' Then
    result := ParseReferralRequest(jsn)
  else if s = 'RelatedPerson' Then
    result := ParseRelatedPerson(jsn)
  else if s = 'RiskAssessment' Then
    result := ParseRiskAssessment(jsn)
  else if s = 'Schedule' Then
    result := ParseSchedule(jsn)
  else if s = 'SearchParameter' Then
    result := ParseSearchParameter(jsn)
  else if s = 'Slot' Then
    result := ParseSlot(jsn)
  else if s = 'Specimen' Then
    result := ParseSpecimen(jsn)
  else if s = 'StructureDefinition' Then
    result := ParseStructureDefinition(jsn)
  else if s = 'Subscription' Then
    result := ParseSubscription(jsn)
  else if s = 'Substance' Then
    result := ParseSubstance(jsn)
  else if s = 'SupplyDelivery' Then
    result := ParseSupplyDelivery(jsn)
  else if s = 'SupplyRequest' Then
    result := ParseSupplyRequest(jsn)
  else if s = 'TestScript' Then
    result := ParseTestScript(jsn)
  else if s = 'ValueSet' Then
    result := ParseValueSet(jsn)
  else if s = 'VisionPrescription' Then
    result := ParseVisionPrescription(jsn)
  else
    raise Exception.create('error: the element '+s+' is not a valid resource name');
end;

function TFHIRJsonParser.ParseFragment(jsn : TJsonObject; type_ : String) : TFhirBase;
begin
   if (type_ = 'TFhirElement') then
    result := parseElement(jsn)
  else if (type_ = 'TFhirBackboneElement') then
    result := parseBackboneElement(jsn)
  else if (type_ = 'TFhirParameters') then
    result := parseParameters(jsn)
  else if (type_ = 'TFhirExtension') then
    result := parseExtension(jsn)
  else if (type_ = 'TFhirNarrative') then
    result := parseNarrative(jsn)
  else if (type_ = 'TFhirPeriod') then
    result := parsePeriod(jsn)
  else if (type_ = 'TFhirCoding') then
    result := parseCoding(jsn)
  else if (type_ = 'TFhirRange') then
    result := parseRange(jsn)
  else if (type_ = 'TFhirAttachment') then
    result := parseAttachment(jsn)
  else if (type_ = 'TFhirQuantity') then
    result := parseQuantity(jsn)
  else if (type_ = 'TFhirAnnotation') then
    result := parseAnnotation(jsn)
  else if (type_ = 'TFhirRatio') then
    result := parseRatio(jsn)
  else if (type_ = 'TFhirSampledData') then
    result := parseSampledData(jsn)
  else if (type_ = 'TFhirCodeableConcept') then
    result := parseCodeableConcept(jsn)
  else if (type_ = 'TFhirReference') then
    result := parseReference(jsn)
  else if (type_ = 'TFhirIdentifier') then
    result := parseIdentifier(jsn)
  else if (type_ = 'TFhirSignature') then
    result := parseSignature(jsn)
  else if (type_ = 'TFhirTiming') then
    result := parseTiming(jsn)
  else if (type_ = 'TFhirElementDefinition') then
    result := parseElementDefinition(jsn)
  else if (type_ = 'TFhirHumanName') then
    result := parseHumanName(jsn)
  else if (type_ = 'TFhirAddress') then
    result := parseAddress(jsn)
  else if (type_ = 'TFhirMeta') then
    result := parseMeta(jsn)
  else if (type_ = 'TFhirContactPoint') then
    result := parseContactPoint(jsn)
  else if (type_ = 'TFhirAccount') then
    result := parseAccount(jsn)
  else if (type_ = 'TFhirAllergyIntolerance') then
    result := parseAllergyIntolerance(jsn)
  else if (type_ = 'TFhirAppointment') then
    result := parseAppointment(jsn)
  else if (type_ = 'TFhirAppointmentResponse') then
    result := parseAppointmentResponse(jsn)
  else if (type_ = 'TFhirAuditEvent') then
    result := parseAuditEvent(jsn)
  else if (type_ = 'TFhirBasic') then
    result := parseBasic(jsn)
  else if (type_ = 'TFhirBinary') then
    result := parseBinary(jsn)
  else if (type_ = 'TFhirBodySite') then
    result := parseBodySite(jsn)
  else if (type_ = 'TFhirBundle') then
    result := parseBundle(jsn)
  else if (type_ = 'TFhirCarePlan') then
    result := parseCarePlan(jsn)
  else if (type_ = 'TFhirClaim') then
    result := parseClaim(jsn)
  else if (type_ = 'TFhirClaimResponse') then
    result := parseClaimResponse(jsn)
  else if (type_ = 'TFhirClinicalImpression') then
    result := parseClinicalImpression(jsn)
  else if (type_ = 'TFhirCommunication') then
    result := parseCommunication(jsn)
  else if (type_ = 'TFhirCommunicationRequest') then
    result := parseCommunicationRequest(jsn)
  else if (type_ = 'TFhirComposition') then
    result := parseComposition(jsn)
  else if (type_ = 'TFhirConceptMap') then
    result := parseConceptMap(jsn)
  else if (type_ = 'TFhirCondition') then
    result := parseCondition(jsn)
  else if (type_ = 'TFhirConformance') then
    result := parseConformance(jsn)
  else if (type_ = 'TFhirContract') then
    result := parseContract(jsn)
  else if (type_ = 'TFhirCoverage') then
    result := parseCoverage(jsn)
  else if (type_ = 'TFhirDataElement') then
    result := parseDataElement(jsn)
  else if (type_ = 'TFhirDetectedIssue') then
    result := parseDetectedIssue(jsn)
  else if (type_ = 'TFhirDevice') then
    result := parseDevice(jsn)
  else if (type_ = 'TFhirDeviceComponent') then
    result := parseDeviceComponent(jsn)
  else if (type_ = 'TFhirDeviceMetric') then
    result := parseDeviceMetric(jsn)
  else if (type_ = 'TFhirDeviceUseRequest') then
    result := parseDeviceUseRequest(jsn)
  else if (type_ = 'TFhirDeviceUseStatement') then
    result := parseDeviceUseStatement(jsn)
  else if (type_ = 'TFhirDiagnosticOrder') then
    result := parseDiagnosticOrder(jsn)
  else if (type_ = 'TFhirDiagnosticReport') then
    result := parseDiagnosticReport(jsn)
  else if (type_ = 'TFhirDocumentManifest') then
    result := parseDocumentManifest(jsn)
  else if (type_ = 'TFhirDocumentReference') then
    result := parseDocumentReference(jsn)
  else if (type_ = 'TFhirEligibilityRequest') then
    result := parseEligibilityRequest(jsn)
  else if (type_ = 'TFhirEligibilityResponse') then
    result := parseEligibilityResponse(jsn)
  else if (type_ = 'TFhirEncounter') then
    result := parseEncounter(jsn)
  else if (type_ = 'TFhirEnrollmentRequest') then
    result := parseEnrollmentRequest(jsn)
  else if (type_ = 'TFhirEnrollmentResponse') then
    result := parseEnrollmentResponse(jsn)
  else if (type_ = 'TFhirEpisodeOfCare') then
    result := parseEpisodeOfCare(jsn)
  else if (type_ = 'TFhirExplanationOfBenefit') then
    result := parseExplanationOfBenefit(jsn)
  else if (type_ = 'TFhirFamilyMemberHistory') then
    result := parseFamilyMemberHistory(jsn)
  else if (type_ = 'TFhirFlag') then
    result := parseFlag(jsn)
  else if (type_ = 'TFhirGoal') then
    result := parseGoal(jsn)
  else if (type_ = 'TFhirGroup') then
    result := parseGroup(jsn)
  else if (type_ = 'TFhirHealthcareService') then
    result := parseHealthcareService(jsn)
  else if (type_ = 'TFhirImagingObjectSelection') then
    result := parseImagingObjectSelection(jsn)
  else if (type_ = 'TFhirImagingStudy') then
    result := parseImagingStudy(jsn)
  else if (type_ = 'TFhirImmunization') then
    result := parseImmunization(jsn)
  else if (type_ = 'TFhirImmunizationRecommendation') then
    result := parseImmunizationRecommendation(jsn)
  else if (type_ = 'TFhirImplementationGuide') then
    result := parseImplementationGuide(jsn)
  else if (type_ = 'TFhirList') then
    result := parseList(jsn)
  else if (type_ = 'TFhirLocation') then
    result := parseLocation(jsn)
  else if (type_ = 'TFhirMedia') then
    result := parseMedia(jsn)
  else if (type_ = 'TFhirMedication') then
    result := parseMedication(jsn)
  else if (type_ = 'TFhirMedicationAdministration') then
    result := parseMedicationAdministration(jsn)
  else if (type_ = 'TFhirMedicationDispense') then
    result := parseMedicationDispense(jsn)
  else if (type_ = 'TFhirMedicationOrder') then
    result := parseMedicationOrder(jsn)
  else if (type_ = 'TFhirMedicationStatement') then
    result := parseMedicationStatement(jsn)
  else if (type_ = 'TFhirMessageHeader') then
    result := parseMessageHeader(jsn)
  else if (type_ = 'TFhirNamingSystem') then
    result := parseNamingSystem(jsn)
  else if (type_ = 'TFhirNutritionOrder') then
    result := parseNutritionOrder(jsn)
  else if (type_ = 'TFhirObservation') then
    result := parseObservation(jsn)
  else if (type_ = 'TFhirOperationDefinition') then
    result := parseOperationDefinition(jsn)
  else if (type_ = 'TFhirOperationOutcome') then
    result := parseOperationOutcome(jsn)
  else if (type_ = 'TFhirOrder') then
    result := parseOrder(jsn)
  else if (type_ = 'TFhirOrderResponse') then
    result := parseOrderResponse(jsn)
  else if (type_ = 'TFhirOrganization') then
    result := parseOrganization(jsn)
  else if (type_ = 'TFhirPatient') then
    result := parsePatient(jsn)
  else if (type_ = 'TFhirPaymentNotice') then
    result := parsePaymentNotice(jsn)
  else if (type_ = 'TFhirPaymentReconciliation') then
    result := parsePaymentReconciliation(jsn)
  else if (type_ = 'TFhirPerson') then
    result := parsePerson(jsn)
  else if (type_ = 'TFhirPractitioner') then
    result := parsePractitioner(jsn)
  else if (type_ = 'TFhirProcedure') then
    result := parseProcedure(jsn)
  else if (type_ = 'TFhirProcedureRequest') then
    result := parseProcedureRequest(jsn)
  else if (type_ = 'TFhirProcessRequest') then
    result := parseProcessRequest(jsn)
  else if (type_ = 'TFhirProcessResponse') then
    result := parseProcessResponse(jsn)
  else if (type_ = 'TFhirProvenance') then
    result := parseProvenance(jsn)
  else if (type_ = 'TFhirQuestionnaire') then
    result := parseQuestionnaire(jsn)
  else if (type_ = 'TFhirQuestionnaireResponse') then
    result := parseQuestionnaireResponse(jsn)
  else if (type_ = 'TFhirReferralRequest') then
    result := parseReferralRequest(jsn)
  else if (type_ = 'TFhirRelatedPerson') then
    result := parseRelatedPerson(jsn)
  else if (type_ = 'TFhirRiskAssessment') then
    result := parseRiskAssessment(jsn)
  else if (type_ = 'TFhirSchedule') then
    result := parseSchedule(jsn)
  else if (type_ = 'TFhirSearchParameter') then
    result := parseSearchParameter(jsn)
  else if (type_ = 'TFhirSlot') then
    result := parseSlot(jsn)
  else if (type_ = 'TFhirSpecimen') then
    result := parseSpecimen(jsn)
  else if (type_ = 'TFhirStructureDefinition') then
    result := parseStructureDefinition(jsn)
  else if (type_ = 'TFhirSubscription') then
    result := parseSubscription(jsn)
  else if (type_ = 'TFhirSubstance') then
    result := parseSubstance(jsn)
  else if (type_ = 'TFhirSupplyDelivery') then
    result := parseSupplyDelivery(jsn)
  else if (type_ = 'TFhirSupplyRequest') then
    result := parseSupplyRequest(jsn)
  else if (type_ = 'TFhirTestScript') then
    result := parseTestScript(jsn)
  else if (type_ = 'TFhirValueSet') then
    result := parseValueSet(jsn)
  else if (type_ = 'TFhirVisionPrescription') then
    result := parseVisionPrescription(jsn)
  else
    raise Exception.create('error: the element '+type_+' is not a valid fragment name');
end;

function TFHIRXmlParser.ParseFragment(element : IXMLDOMElement) : TFhirBase;
begin
   if SameText(element.NodeName, 'TFhirElement') then
    result := parseElement(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirBackboneElement') then
    result := parseBackboneElement(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirParameters') then
    result := parseParameters(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirExtension') then
    result := parseExtension(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirNarrative') then
    result := parseNarrative(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirPeriod') then
    result := parsePeriod(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCoding') then
    result := parseCoding(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirRange') then
    result := parseRange(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAttachment') then
    result := parseAttachment(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirQuantity') then
    result := parseQuantity(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAnnotation') then
    result := parseAnnotation(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirRatio') then
    result := parseRatio(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSampledData') then
    result := parseSampledData(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCodeableConcept') then
    result := parseCodeableConcept(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirReference') then
    result := parseReference(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirIdentifier') then
    result := parseIdentifier(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSignature') then
    result := parseSignature(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirTiming') then
    result := parseTiming(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirElementDefinition') then
    result := parseElementDefinition(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirHumanName') then
    result := parseHumanName(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAddress') then
    result := parseAddress(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirMeta') then
    result := parseMeta(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirContactPoint') then
    result := parseContactPoint(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAccount') then
    result := parseAccount(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAllergyIntolerance') then
    result := parseAllergyIntolerance(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAppointment') then
    result := parseAppointment(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAppointmentResponse') then
    result := parseAppointmentResponse(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAuditEvent') then
    result := parseAuditEvent(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirBasic') then
    result := parseBasic(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirBinary') then
    result := parseBinary(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirBodySite') then
    result := parseBodySite(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirBundle') then
    result := parseBundle(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCarePlan') then
    result := parseCarePlan(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirClaim') then
    result := parseClaim(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirClaimResponse') then
    result := parseClaimResponse(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirClinicalImpression') then
    result := parseClinicalImpression(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCommunication') then
    result := parseCommunication(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCommunicationRequest') then
    result := parseCommunicationRequest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirComposition') then
    result := parseComposition(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirConceptMap') then
    result := parseConceptMap(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCondition') then
    result := parseCondition(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirConformance') then
    result := parseConformance(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirContract') then
    result := parseContract(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCoverage') then
    result := parseCoverage(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDataElement') then
    result := parseDataElement(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDetectedIssue') then
    result := parseDetectedIssue(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDevice') then
    result := parseDevice(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDeviceComponent') then
    result := parseDeviceComponent(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDeviceMetric') then
    result := parseDeviceMetric(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDeviceUseRequest') then
    result := parseDeviceUseRequest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDeviceUseStatement') then
    result := parseDeviceUseStatement(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDiagnosticOrder') then
    result := parseDiagnosticOrder(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDiagnosticReport') then
    result := parseDiagnosticReport(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDocumentManifest') then
    result := parseDocumentManifest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirDocumentReference') then
    result := parseDocumentReference(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirEligibilityRequest') then
    result := parseEligibilityRequest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirEligibilityResponse') then
    result := parseEligibilityResponse(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirEncounter') then
    result := parseEncounter(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirEnrollmentRequest') then
    result := parseEnrollmentRequest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirEnrollmentResponse') then
    result := parseEnrollmentResponse(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirEpisodeOfCare') then
    result := parseEpisodeOfCare(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirExplanationOfBenefit') then
    result := parseExplanationOfBenefit(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirFamilyMemberHistory') then
    result := parseFamilyMemberHistory(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirFlag') then
    result := parseFlag(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirGoal') then
    result := parseGoal(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirGroup') then
    result := parseGroup(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirHealthcareService') then
    result := parseHealthcareService(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirImagingObjectSelection') then
    result := parseImagingObjectSelection(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirImagingStudy') then
    result := parseImagingStudy(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirImmunization') then
    result := parseImmunization(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirImmunizationRecommendation') then
    result := parseImmunizationRecommendation(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirImplementationGuide') then
    result := parseImplementationGuide(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirList') then
    result := parseList(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirLocation') then
    result := parseLocation(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirMedia') then
    result := parseMedia(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirMedication') then
    result := parseMedication(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirMedicationAdministration') then
    result := parseMedicationAdministration(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirMedicationDispense') then
    result := parseMedicationDispense(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirMedicationOrder') then
    result := parseMedicationOrder(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirMedicationStatement') then
    result := parseMedicationStatement(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirMessageHeader') then
    result := parseMessageHeader(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirNamingSystem') then
    result := parseNamingSystem(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirNutritionOrder') then
    result := parseNutritionOrder(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirObservation') then
    result := parseObservation(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirOperationDefinition') then
    result := parseOperationDefinition(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirOperationOutcome') then
    result := parseOperationOutcome(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirOrder') then
    result := parseOrder(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirOrderResponse') then
    result := parseOrderResponse(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirOrganization') then
    result := parseOrganization(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirPatient') then
    result := parsePatient(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirPaymentNotice') then
    result := parsePaymentNotice(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirPaymentReconciliation') then
    result := parsePaymentReconciliation(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirPerson') then
    result := parsePerson(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirPractitioner') then
    result := parsePractitioner(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirProcedure') then
    result := parseProcedure(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirProcedureRequest') then
    result := parseProcedureRequest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirProcessRequest') then
    result := parseProcessRequest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirProcessResponse') then
    result := parseProcessResponse(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirProvenance') then
    result := parseProvenance(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirQuestionnaire') then
    result := parseQuestionnaire(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirQuestionnaireResponse') then
    result := parseQuestionnaireResponse(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirReferralRequest') then
    result := parseReferralRequest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirRelatedPerson') then
    result := parseRelatedPerson(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirRiskAssessment') then
    result := parseRiskAssessment(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSchedule') then
    result := parseSchedule(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSearchParameter') then
    result := parseSearchParameter(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSlot') then
    result := parseSlot(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSpecimen') then
    result := parseSpecimen(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirStructureDefinition') then
    result := parseStructureDefinition(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSubscription') then
    result := parseSubscription(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSubstance') then
    result := parseSubstance(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSupplyDelivery') then
    result := parseSupplyDelivery(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSupplyRequest') then
    result := parseSupplyRequest(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirTestScript') then
    result := parseTestScript(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirValueSet') then
    result := parseValueSet(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirVisionPrescription') then
    result := parseVisionPrescription(element, element.nodeName)
  else
    raise Exception.create('error: the element '+element.nodeName+' is not a valid fragment name');
end;

function TFHIRJsonParser.ParseDataType(jsn : TJsonObject; name : String; type_ : TFHIRTypeClass) : TFHIRType;
begin
   if (type_ = TFhirExtension) then
    result := parseExtension(jsn)
  else if (type_ = TFhirNarrative) then
    result := parseNarrative(jsn)
  else if (type_ = TFhirPeriod) then
    result := parsePeriod(jsn)
  else if (type_ = TFhirCoding) then
    result := parseCoding(jsn)
  else if (type_ = TFhirRange) then
    result := parseRange(jsn)
  else if (type_ = TFhirAttachment) then
    result := parseAttachment(jsn)
  else if (type_ = TFhirQuantity) then
    result := parseQuantity(jsn)
  else if (type_ = TFhirAnnotation) then
    result := parseAnnotation(jsn)
  else if (type_ = TFhirRatio) then
    result := parseRatio(jsn)
  else if (type_ = TFhirSampledData) then
    result := parseSampledData(jsn)
  else if (type_ = TFhirCodeableConcept) then
    result := parseCodeableConcept(jsn)
  else if (type_ = TFhirReference) then
    result := parseReference(jsn)
  else if (type_ = TFhirIdentifier) then
    result := parseIdentifier(jsn)
  else if (type_ = TFhirSignature) then
    result := parseSignature(jsn)
  else if (type_ = TFhirTiming) then
    result := parseTiming(jsn)
  else if (type_ = TFhirElementDefinition) then
    result := parseElementDefinition(jsn)
  else if (type_ = TFhirHumanName) then
    result := parseHumanName(jsn)
  else if (type_ = TFhirAddress) then
    result := parseAddress(jsn)
  else if (type_ = TFhirMeta) then
    result := parseMeta(jsn)
  else if (type_ = TFhirContactPoint) then
    result := parseContactPoint(jsn)
  else
    raise Exception.create('Unknown Type');
end;

function TFHIRXmlParser.ParseDataType(element : IXMLDOMElement; name : String; type_ : TFHIRTypeClass) : TFhirType;
begin
    if (name <> '') and (name <> element.baseName) then
    raise Exception.Create('Expected Name mismatch : expected "'+name+'"+, but found "'+element.baseName+'"');
 if (type_ = TFhirExtension) then
    result := parseExtension(element, name)
  else if (type_ = TFhirNarrative) then
    result := parseNarrative(element, name)
  else if (type_ = TFhirPeriod) then
    result := parsePeriod(element, name)
  else if (type_ = TFhirCoding) then
    result := parseCoding(element, name)
  else if (type_ = TFhirRange) then
    result := parseRange(element, name)
  else if (type_ = TFhirAttachment) then
    result := parseAttachment(element, name)
  else if (type_ = TFhirQuantity) then
    result := parseQuantity(element, name)
  else if (type_ = TFhirAnnotation) then
    result := parseAnnotation(element, name)
  else if (type_ = TFhirRatio) then
    result := parseRatio(element, name)
  else if (type_ = TFhirSampledData) then
    result := parseSampledData(element, name)
  else if (type_ = TFhirCodeableConcept) then
    result := parseCodeableConcept(element, name)
  else if (type_ = TFhirReference) then
    result := parseReference(element, name)
  else if (type_ = TFhirIdentifier) then
    result := parseIdentifier(element, name)
  else if (type_ = TFhirSignature) then
    result := parseSignature(element, name)
  else if (type_ = TFhirTiming) then
    result := parseTiming(element, name)
  else if (type_ = TFhirElementDefinition) then
    result := parseElementDefinition(element, name)
  else if (type_ = TFhirHumanName) then
    result := parseHumanName(element, name)
  else if (type_ = TFhirAddress) then
    result := parseAddress(element, name)
  else if (type_ = TFhirMeta) then
    result := parseMeta(element, name)
  else if (type_ = TFhirContactPoint) then
    result := parseContactPoint(element, name)
  else
    raise Exception.create('Unknown Type');
end;

procedure TFHIRXmlComposer.ComposeBase(xml : TXmlBuilder; name : String; base : TFHIRBase);
begin
   if (base is TFhirInteger) then
    composeInteger(xml, name,  TFhirInteger(base))
  else if (base is TFhirDateTime) then
    composeDateTime(xml, name,  TFhirDateTime(base))
  else if (base is TFhirDate) then
    composeDate(xml, name,  TFhirDate(base))
  else if (base is TFhirDecimal) then
    composeDecimal(xml, name,  TFhirDecimal(base))
  else if (base is TFhirUri) then
    composeUri(xml, name,  TFhirUri(base))
  else if (base is TFhirBase64Binary) then
    composeBase64Binary(xml, name,  TFhirBase64Binary(base))
  else if (base is TFhirTime) then
    composeTime(xml, name,  TFhirTime(base))
  else if (base is TFhirString) then
    composeString(xml, name,  TFhirString(base))
  else if (base is TFhirBoolean) then
    composeBoolean(xml, name,  TFhirBoolean(base))
  else if (base is TFhirInstant) then
    composeInstant(xml, name,  TFhirInstant(base))
  else if (base is TFhirMarkdown) then
    composeMarkdown(xml, name,  TFhirMarkdown(base))
  else if (base is TFhirUnsignedInt) then
    composeUnsignedInt(xml, name,  TFhirUnsignedInt(base))
  else if (base is TFhirCode) then
    composeCode(xml, name,  TFhirCode(base))
  else if (base is TFhirId) then
    composeId(xml, name,  TFhirId(base))
  else if (base is TFhirOid) then
    composeOid(xml, name,  TFhirOid(base))
  else if (base is TFhirPositiveInt) then
    composePositiveInt(xml, name,  TFhirPositiveInt(base))
  else if (base is TFhirUuid) then
    composeUuid(xml, name,  TFhirUuid(base))
  else if (base is TFhirParametersParameter) then
    composeParametersParameter(xml, name,  TFhirParametersParameter(base))
  else if (base is TFhirParameters) then
    composeParameters(xml, name,  TFhirParameters(base))
  else if (base is TFhirExtension) then
    composeExtension(xml, name,  TFhirExtension(base))
  else if (base is TFhirNarrative) then
    composeNarrative(xml, name,  TFhirNarrative(base))
  else if (base is TFhirPeriod) then
    composePeriod(xml, name,  TFhirPeriod(base))
  else if (base is TFhirCoding) then
    composeCoding(xml, name,  TFhirCoding(base))
  else if (base is TFhirRange) then
    composeRange(xml, name,  TFhirRange(base))
  else if (base is TFhirAttachment) then
    composeAttachment(xml, name,  TFhirAttachment(base))
  else if (base is TFhirQuantity) then
    composeQuantity(xml, name,  TFhirQuantity(base))
  else if (base is TFhirAnnotation) then
    composeAnnotation(xml, name,  TFhirAnnotation(base))
  else if (base is TFhirRatio) then
    composeRatio(xml, name,  TFhirRatio(base))
  else if (base is TFhirSampledData) then
    composeSampledData(xml, name,  TFhirSampledData(base))
  else if (base is TFhirCodeableConcept) then
    composeCodeableConcept(xml, name,  TFhirCodeableConcept(base))
  else if (base is TFhirReference) then
    composeReference(xml, name,  TFhirReference(base))
  else if (base is TFhirIdentifier) then
    composeIdentifier(xml, name,  TFhirIdentifier(base))
  else if (base is TFhirSignature) then
    composeSignature(xml, name,  TFhirSignature(base))
  else if (base is TFhirTimingRepeat) then
    composeTimingRepeat(xml, name,  TFhirTimingRepeat(base))
  else if (base is TFhirTiming) then
    composeTiming(xml, name,  TFhirTiming(base))
  else if (base is TFhirElementDefinitionSlicing) then
    composeElementDefinitionSlicing(xml, name,  TFhirElementDefinitionSlicing(base))
  else if (base is TFhirElementDefinitionBase) then
    composeElementDefinitionBase(xml, name,  TFhirElementDefinitionBase(base))
  else if (base is TFhirElementDefinitionType) then
    composeElementDefinitionType(xml, name,  TFhirElementDefinitionType(base))
  else if (base is TFhirElementDefinitionConstraint) then
    composeElementDefinitionConstraint(xml, name,  TFhirElementDefinitionConstraint(base))
  else if (base is TFhirElementDefinitionBinding) then
    composeElementDefinitionBinding(xml, name,  TFhirElementDefinitionBinding(base))
  else if (base is TFhirElementDefinitionMapping) then
    composeElementDefinitionMapping(xml, name,  TFhirElementDefinitionMapping(base))
  else if (base is TFhirElementDefinition) then
    composeElementDefinition(xml, name,  TFhirElementDefinition(base))
  else if (base is TFhirHumanName) then
    composeHumanName(xml, name,  TFhirHumanName(base))
  else if (base is TFhirAddress) then
    composeAddress(xml, name,  TFhirAddress(base))
  else if (base is TFhirMeta) then
    composeMeta(xml, name,  TFhirMeta(base))
  else if (base is TFhirContactPoint) then
    composeContactPoint(xml, name,  TFhirContactPoint(base))
  else if (base is TFhirAccount) then
    composeAccount(xml, name,  TFhirAccount(base))
  else if (base is TFhirAllergyIntoleranceReaction) then
    composeAllergyIntoleranceReaction(xml, name,  TFhirAllergyIntoleranceReaction(base))
  else if (base is TFhirAllergyIntolerance) then
    composeAllergyIntolerance(xml, name,  TFhirAllergyIntolerance(base))
  else if (base is TFhirAppointmentParticipant) then
    composeAppointmentParticipant(xml, name,  TFhirAppointmentParticipant(base))
  else if (base is TFhirAppointment) then
    composeAppointment(xml, name,  TFhirAppointment(base))
  else if (base is TFhirAppointmentResponse) then
    composeAppointmentResponse(xml, name,  TFhirAppointmentResponse(base))
  else if (base is TFhirAuditEventEvent) then
    composeAuditEventEvent(xml, name,  TFhirAuditEventEvent(base))
  else if (base is TFhirAuditEventParticipant) then
    composeAuditEventParticipant(xml, name,  TFhirAuditEventParticipant(base))
  else if (base is TFhirAuditEventParticipantNetwork) then
    composeAuditEventParticipantNetwork(xml, name,  TFhirAuditEventParticipantNetwork(base))
  else if (base is TFhirAuditEventSource) then
    composeAuditEventSource(xml, name,  TFhirAuditEventSource(base))
  else if (base is TFhirAuditEventObject) then
    composeAuditEventObject(xml, name,  TFhirAuditEventObject(base))
  else if (base is TFhirAuditEventObjectDetail) then
    composeAuditEventObjectDetail(xml, name,  TFhirAuditEventObjectDetail(base))
  else if (base is TFhirAuditEvent) then
    composeAuditEvent(xml, name,  TFhirAuditEvent(base))
  else if (base is TFhirBasic) then
    composeBasic(xml, name,  TFhirBasic(base))
  else if (base is TFhirBinary) then
    composeBinary(xml, name,  TFhirBinary(base))
  else if (base is TFhirBodySite) then
    composeBodySite(xml, name,  TFhirBodySite(base))
  else if (base is TFhirBundleLink) then
    composeBundleLink(xml, name,  TFhirBundleLink(base))
  else if (base is TFhirBundleEntry) then
    composeBundleEntry(xml, name,  TFhirBundleEntry(base))
  else if (base is TFhirBundleEntrySearch) then
    composeBundleEntrySearch(xml, name,  TFhirBundleEntrySearch(base))
  else if (base is TFhirBundleEntryRequest) then
    composeBundleEntryRequest(xml, name,  TFhirBundleEntryRequest(base))
  else if (base is TFhirBundleEntryResponse) then
    composeBundleEntryResponse(xml, name,  TFhirBundleEntryResponse(base))
  else if (base is TFhirBundle) then
    composeBundle(xml, name,  TFhirBundle(base))
  else if (base is TFhirCarePlanRelatedPlan) then
    composeCarePlanRelatedPlan(xml, name,  TFhirCarePlanRelatedPlan(base))
  else if (base is TFhirCarePlanParticipant) then
    composeCarePlanParticipant(xml, name,  TFhirCarePlanParticipant(base))
  else if (base is TFhirCarePlanActivity) then
    composeCarePlanActivity(xml, name,  TFhirCarePlanActivity(base))
  else if (base is TFhirCarePlanActivityDetail) then
    composeCarePlanActivityDetail(xml, name,  TFhirCarePlanActivityDetail(base))
  else if (base is TFhirCarePlan) then
    composeCarePlan(xml, name,  TFhirCarePlan(base))
  else if (base is TFhirClaimPayee) then
    composeClaimPayee(xml, name,  TFhirClaimPayee(base))
  else if (base is TFhirClaimDiagnosis) then
    composeClaimDiagnosis(xml, name,  TFhirClaimDiagnosis(base))
  else if (base is TFhirClaimCoverage) then
    composeClaimCoverage(xml, name,  TFhirClaimCoverage(base))
  else if (base is TFhirClaimItem) then
    composeClaimItem(xml, name,  TFhirClaimItem(base))
  else if (base is TFhirClaimItemDetail) then
    composeClaimItemDetail(xml, name,  TFhirClaimItemDetail(base))
  else if (base is TFhirClaimItemDetailSubDetail) then
    composeClaimItemDetailSubDetail(xml, name,  TFhirClaimItemDetailSubDetail(base))
  else if (base is TFhirClaimItemProsthesis) then
    composeClaimItemProsthesis(xml, name,  TFhirClaimItemProsthesis(base))
  else if (base is TFhirClaimMissingTeeth) then
    composeClaimMissingTeeth(xml, name,  TFhirClaimMissingTeeth(base))
  else if (base is TFhirClaim) then
    composeClaim(xml, name,  TFhirClaim(base))
  else if (base is TFhirClaimResponseItem) then
    composeClaimResponseItem(xml, name,  TFhirClaimResponseItem(base))
  else if (base is TFhirClaimResponseItemAdjudication) then
    composeClaimResponseItemAdjudication(xml, name,  TFhirClaimResponseItemAdjudication(base))
  else if (base is TFhirClaimResponseItemDetail) then
    composeClaimResponseItemDetail(xml, name,  TFhirClaimResponseItemDetail(base))
  else if (base is TFhirClaimResponseItemDetailAdjudication) then
    composeClaimResponseItemDetailAdjudication(xml, name,  TFhirClaimResponseItemDetailAdjudication(base))
  else if (base is TFhirClaimResponseItemDetailSubDetail) then
    composeClaimResponseItemDetailSubDetail(xml, name,  TFhirClaimResponseItemDetailSubDetail(base))
  else if (base is TFhirClaimResponseItemDetailSubDetailAdjudication) then
    composeClaimResponseItemDetailSubDetailAdjudication(xml, name,  TFhirClaimResponseItemDetailSubDetailAdjudication(base))
  else if (base is TFhirClaimResponseAddItem) then
    composeClaimResponseAddItem(xml, name,  TFhirClaimResponseAddItem(base))
  else if (base is TFhirClaimResponseAddItemAdjudication) then
    composeClaimResponseAddItemAdjudication(xml, name,  TFhirClaimResponseAddItemAdjudication(base))
  else if (base is TFhirClaimResponseAddItemDetail) then
    composeClaimResponseAddItemDetail(xml, name,  TFhirClaimResponseAddItemDetail(base))
  else if (base is TFhirClaimResponseAddItemDetailAdjudication) then
    composeClaimResponseAddItemDetailAdjudication(xml, name,  TFhirClaimResponseAddItemDetailAdjudication(base))
  else if (base is TFhirClaimResponseError) then
    composeClaimResponseError(xml, name,  TFhirClaimResponseError(base))
  else if (base is TFhirClaimResponseNote) then
    composeClaimResponseNote(xml, name,  TFhirClaimResponseNote(base))
  else if (base is TFhirClaimResponseCoverage) then
    composeClaimResponseCoverage(xml, name,  TFhirClaimResponseCoverage(base))
  else if (base is TFhirClaimResponse) then
    composeClaimResponse(xml, name,  TFhirClaimResponse(base))
  else if (base is TFhirClinicalImpressionInvestigations) then
    composeClinicalImpressionInvestigations(xml, name,  TFhirClinicalImpressionInvestigations(base))
  else if (base is TFhirClinicalImpressionFinding) then
    composeClinicalImpressionFinding(xml, name,  TFhirClinicalImpressionFinding(base))
  else if (base is TFhirClinicalImpressionRuledOut) then
    composeClinicalImpressionRuledOut(xml, name,  TFhirClinicalImpressionRuledOut(base))
  else if (base is TFhirClinicalImpression) then
    composeClinicalImpression(xml, name,  TFhirClinicalImpression(base))
  else if (base is TFhirCommunicationPayload) then
    composeCommunicationPayload(xml, name,  TFhirCommunicationPayload(base))
  else if (base is TFhirCommunication) then
    composeCommunication(xml, name,  TFhirCommunication(base))
  else if (base is TFhirCommunicationRequestPayload) then
    composeCommunicationRequestPayload(xml, name,  TFhirCommunicationRequestPayload(base))
  else if (base is TFhirCommunicationRequest) then
    composeCommunicationRequest(xml, name,  TFhirCommunicationRequest(base))
  else if (base is TFhirCompositionAttester) then
    composeCompositionAttester(xml, name,  TFhirCompositionAttester(base))
  else if (base is TFhirCompositionEvent) then
    composeCompositionEvent(xml, name,  TFhirCompositionEvent(base))
  else if (base is TFhirCompositionSection) then
    composeCompositionSection(xml, name,  TFhirCompositionSection(base))
  else if (base is TFhirComposition) then
    composeComposition(xml, name,  TFhirComposition(base))
  else if (base is TFhirConceptMapContact) then
    composeConceptMapContact(xml, name,  TFhirConceptMapContact(base))
  else if (base is TFhirConceptMapElement) then
    composeConceptMapElement(xml, name,  TFhirConceptMapElement(base))
  else if (base is TFhirConceptMapElementTarget) then
    composeConceptMapElementTarget(xml, name,  TFhirConceptMapElementTarget(base))
  else if (base is TFhirConceptMapElementTargetDependsOn) then
    composeConceptMapElementTargetDependsOn(xml, name,  TFhirConceptMapElementTargetDependsOn(base))
  else if (base is TFhirConceptMap) then
    composeConceptMap(xml, name,  TFhirConceptMap(base))
  else if (base is TFhirConditionStage) then
    composeConditionStage(xml, name,  TFhirConditionStage(base))
  else if (base is TFhirConditionEvidence) then
    composeConditionEvidence(xml, name,  TFhirConditionEvidence(base))
  else if (base is TFhirCondition) then
    composeCondition(xml, name,  TFhirCondition(base))
  else if (base is TFhirConformanceContact) then
    composeConformanceContact(xml, name,  TFhirConformanceContact(base))
  else if (base is TFhirConformanceSoftware) then
    composeConformanceSoftware(xml, name,  TFhirConformanceSoftware(base))
  else if (base is TFhirConformanceImplementation) then
    composeConformanceImplementation(xml, name,  TFhirConformanceImplementation(base))
  else if (base is TFhirConformanceRest) then
    composeConformanceRest(xml, name,  TFhirConformanceRest(base))
  else if (base is TFhirConformanceRestSecurity) then
    composeConformanceRestSecurity(xml, name,  TFhirConformanceRestSecurity(base))
  else if (base is TFhirConformanceRestSecurityCertificate) then
    composeConformanceRestSecurityCertificate(xml, name,  TFhirConformanceRestSecurityCertificate(base))
  else if (base is TFhirConformanceRestResource) then
    composeConformanceRestResource(xml, name,  TFhirConformanceRestResource(base))
  else if (base is TFhirConformanceRestResourceInteraction) then
    composeConformanceRestResourceInteraction(xml, name,  TFhirConformanceRestResourceInteraction(base))
  else if (base is TFhirConformanceRestResourceSearchParam) then
    composeConformanceRestResourceSearchParam(xml, name,  TFhirConformanceRestResourceSearchParam(base))
  else if (base is TFhirConformanceRestInteraction) then
    composeConformanceRestInteraction(xml, name,  TFhirConformanceRestInteraction(base))
  else if (base is TFhirConformanceRestOperation) then
    composeConformanceRestOperation(xml, name,  TFhirConformanceRestOperation(base))
  else if (base is TFhirConformanceMessaging) then
    composeConformanceMessaging(xml, name,  TFhirConformanceMessaging(base))
  else if (base is TFhirConformanceMessagingEndpoint) then
    composeConformanceMessagingEndpoint(xml, name,  TFhirConformanceMessagingEndpoint(base))
  else if (base is TFhirConformanceMessagingEvent) then
    composeConformanceMessagingEvent(xml, name,  TFhirConformanceMessagingEvent(base))
  else if (base is TFhirConformanceDocument) then
    composeConformanceDocument(xml, name,  TFhirConformanceDocument(base))
  else if (base is TFhirConformance) then
    composeConformance(xml, name,  TFhirConformance(base))
  else if (base is TFhirContractActor) then
    composeContractActor(xml, name,  TFhirContractActor(base))
  else if (base is TFhirContractValuedItem) then
    composeContractValuedItem(xml, name,  TFhirContractValuedItem(base))
  else if (base is TFhirContractSigner) then
    composeContractSigner(xml, name,  TFhirContractSigner(base))
  else if (base is TFhirContractTerm) then
    composeContractTerm(xml, name,  TFhirContractTerm(base))
  else if (base is TFhirContractTermActor) then
    composeContractTermActor(xml, name,  TFhirContractTermActor(base))
  else if (base is TFhirContractTermValuedItem) then
    composeContractTermValuedItem(xml, name,  TFhirContractTermValuedItem(base))
  else if (base is TFhirContractFriendly) then
    composeContractFriendly(xml, name,  TFhirContractFriendly(base))
  else if (base is TFhirContractLegal) then
    composeContractLegal(xml, name,  TFhirContractLegal(base))
  else if (base is TFhirContractRule) then
    composeContractRule(xml, name,  TFhirContractRule(base))
  else if (base is TFhirContract) then
    composeContract(xml, name,  TFhirContract(base))
  else if (base is TFhirCoverage) then
    composeCoverage(xml, name,  TFhirCoverage(base))
  else if (base is TFhirDataElementContact) then
    composeDataElementContact(xml, name,  TFhirDataElementContact(base))
  else if (base is TFhirDataElementMapping) then
    composeDataElementMapping(xml, name,  TFhirDataElementMapping(base))
  else if (base is TFhirDataElement) then
    composeDataElement(xml, name,  TFhirDataElement(base))
  else if (base is TFhirDetectedIssueMitigation) then
    composeDetectedIssueMitigation(xml, name,  TFhirDetectedIssueMitigation(base))
  else if (base is TFhirDetectedIssue) then
    composeDetectedIssue(xml, name,  TFhirDetectedIssue(base))
  else if (base is TFhirDevice) then
    composeDevice(xml, name,  TFhirDevice(base))
  else if (base is TFhirDeviceComponentProductionSpecification) then
    composeDeviceComponentProductionSpecification(xml, name,  TFhirDeviceComponentProductionSpecification(base))
  else if (base is TFhirDeviceComponent) then
    composeDeviceComponent(xml, name,  TFhirDeviceComponent(base))
  else if (base is TFhirDeviceMetricCalibration) then
    composeDeviceMetricCalibration(xml, name,  TFhirDeviceMetricCalibration(base))
  else if (base is TFhirDeviceMetric) then
    composeDeviceMetric(xml, name,  TFhirDeviceMetric(base))
  else if (base is TFhirDeviceUseRequest) then
    composeDeviceUseRequest(xml, name,  TFhirDeviceUseRequest(base))
  else if (base is TFhirDeviceUseStatement) then
    composeDeviceUseStatement(xml, name,  TFhirDeviceUseStatement(base))
  else if (base is TFhirDiagnosticOrderEvent) then
    composeDiagnosticOrderEvent(xml, name,  TFhirDiagnosticOrderEvent(base))
  else if (base is TFhirDiagnosticOrderItem) then
    composeDiagnosticOrderItem(xml, name,  TFhirDiagnosticOrderItem(base))
  else if (base is TFhirDiagnosticOrder) then
    composeDiagnosticOrder(xml, name,  TFhirDiagnosticOrder(base))
  else if (base is TFhirDiagnosticReportImage) then
    composeDiagnosticReportImage(xml, name,  TFhirDiagnosticReportImage(base))
  else if (base is TFhirDiagnosticReport) then
    composeDiagnosticReport(xml, name,  TFhirDiagnosticReport(base))
  else if (base is TFhirDocumentManifestContent) then
    composeDocumentManifestContent(xml, name,  TFhirDocumentManifestContent(base))
  else if (base is TFhirDocumentManifestRelated) then
    composeDocumentManifestRelated(xml, name,  TFhirDocumentManifestRelated(base))
  else if (base is TFhirDocumentManifest) then
    composeDocumentManifest(xml, name,  TFhirDocumentManifest(base))
  else if (base is TFhirDocumentReferenceRelatesTo) then
    composeDocumentReferenceRelatesTo(xml, name,  TFhirDocumentReferenceRelatesTo(base))
  else if (base is TFhirDocumentReferenceContent) then
    composeDocumentReferenceContent(xml, name,  TFhirDocumentReferenceContent(base))
  else if (base is TFhirDocumentReferenceContext) then
    composeDocumentReferenceContext(xml, name,  TFhirDocumentReferenceContext(base))
  else if (base is TFhirDocumentReferenceContextRelated) then
    composeDocumentReferenceContextRelated(xml, name,  TFhirDocumentReferenceContextRelated(base))
  else if (base is TFhirDocumentReference) then
    composeDocumentReference(xml, name,  TFhirDocumentReference(base))
  else if (base is TFhirEligibilityRequest) then
    composeEligibilityRequest(xml, name,  TFhirEligibilityRequest(base))
  else if (base is TFhirEligibilityResponse) then
    composeEligibilityResponse(xml, name,  TFhirEligibilityResponse(base))
  else if (base is TFhirEncounterStatusHistory) then
    composeEncounterStatusHistory(xml, name,  TFhirEncounterStatusHistory(base))
  else if (base is TFhirEncounterParticipant) then
    composeEncounterParticipant(xml, name,  TFhirEncounterParticipant(base))
  else if (base is TFhirEncounterHospitalization) then
    composeEncounterHospitalization(xml, name,  TFhirEncounterHospitalization(base))
  else if (base is TFhirEncounterLocation) then
    composeEncounterLocation(xml, name,  TFhirEncounterLocation(base))
  else if (base is TFhirEncounter) then
    composeEncounter(xml, name,  TFhirEncounter(base))
  else if (base is TFhirEnrollmentRequest) then
    composeEnrollmentRequest(xml, name,  TFhirEnrollmentRequest(base))
  else if (base is TFhirEnrollmentResponse) then
    composeEnrollmentResponse(xml, name,  TFhirEnrollmentResponse(base))
  else if (base is TFhirEpisodeOfCareStatusHistory) then
    composeEpisodeOfCareStatusHistory(xml, name,  TFhirEpisodeOfCareStatusHistory(base))
  else if (base is TFhirEpisodeOfCareCareTeam) then
    composeEpisodeOfCareCareTeam(xml, name,  TFhirEpisodeOfCareCareTeam(base))
  else if (base is TFhirEpisodeOfCare) then
    composeEpisodeOfCare(xml, name,  TFhirEpisodeOfCare(base))
  else if (base is TFhirExplanationOfBenefit) then
    composeExplanationOfBenefit(xml, name,  TFhirExplanationOfBenefit(base))
  else if (base is TFhirFamilyMemberHistoryCondition) then
    composeFamilyMemberHistoryCondition(xml, name,  TFhirFamilyMemberHistoryCondition(base))
  else if (base is TFhirFamilyMemberHistory) then
    composeFamilyMemberHistory(xml, name,  TFhirFamilyMemberHistory(base))
  else if (base is TFhirFlag) then
    composeFlag(xml, name,  TFhirFlag(base))
  else if (base is TFhirGoalOutcome) then
    composeGoalOutcome(xml, name,  TFhirGoalOutcome(base))
  else if (base is TFhirGoal) then
    composeGoal(xml, name,  TFhirGoal(base))
  else if (base is TFhirGroupCharacteristic) then
    composeGroupCharacteristic(xml, name,  TFhirGroupCharacteristic(base))
  else if (base is TFhirGroupMember) then
    composeGroupMember(xml, name,  TFhirGroupMember(base))
  else if (base is TFhirGroup) then
    composeGroup(xml, name,  TFhirGroup(base))
  else if (base is TFhirHealthcareServiceServiceType) then
    composeHealthcareServiceServiceType(xml, name,  TFhirHealthcareServiceServiceType(base))
  else if (base is TFhirHealthcareServiceAvailableTime) then
    composeHealthcareServiceAvailableTime(xml, name,  TFhirHealthcareServiceAvailableTime(base))
  else if (base is TFhirHealthcareServiceNotAvailable) then
    composeHealthcareServiceNotAvailable(xml, name,  TFhirHealthcareServiceNotAvailable(base))
  else if (base is TFhirHealthcareService) then
    composeHealthcareService(xml, name,  TFhirHealthcareService(base))
  else if (base is TFhirImagingObjectSelectionStudy) then
    composeImagingObjectSelectionStudy(xml, name,  TFhirImagingObjectSelectionStudy(base))
  else if (base is TFhirImagingObjectSelectionStudySeries) then
    composeImagingObjectSelectionStudySeries(xml, name,  TFhirImagingObjectSelectionStudySeries(base))
  else if (base is TFhirImagingObjectSelectionStudySeriesInstance) then
    composeImagingObjectSelectionStudySeriesInstance(xml, name,  TFhirImagingObjectSelectionStudySeriesInstance(base))
  else if (base is TFhirImagingObjectSelectionStudySeriesInstanceFrames) then
    composeImagingObjectSelectionStudySeriesInstanceFrames(xml, name,  TFhirImagingObjectSelectionStudySeriesInstanceFrames(base))
  else if (base is TFhirImagingObjectSelection) then
    composeImagingObjectSelection(xml, name,  TFhirImagingObjectSelection(base))
  else if (base is TFhirImagingStudySeries) then
    composeImagingStudySeries(xml, name,  TFhirImagingStudySeries(base))
  else if (base is TFhirImagingStudySeriesInstance) then
    composeImagingStudySeriesInstance(xml, name,  TFhirImagingStudySeriesInstance(base))
  else if (base is TFhirImagingStudy) then
    composeImagingStudy(xml, name,  TFhirImagingStudy(base))
  else if (base is TFhirImmunizationExplanation) then
    composeImmunizationExplanation(xml, name,  TFhirImmunizationExplanation(base))
  else if (base is TFhirImmunizationReaction) then
    composeImmunizationReaction(xml, name,  TFhirImmunizationReaction(base))
  else if (base is TFhirImmunizationVaccinationProtocol) then
    composeImmunizationVaccinationProtocol(xml, name,  TFhirImmunizationVaccinationProtocol(base))
  else if (base is TFhirImmunization) then
    composeImmunization(xml, name,  TFhirImmunization(base))
  else if (base is TFhirImmunizationRecommendationRecommendation) then
    composeImmunizationRecommendationRecommendation(xml, name,  TFhirImmunizationRecommendationRecommendation(base))
  else if (base is TFhirImmunizationRecommendationRecommendationDateCriterion) then
    composeImmunizationRecommendationRecommendationDateCriterion(xml, name,  TFhirImmunizationRecommendationRecommendationDateCriterion(base))
  else if (base is TFhirImmunizationRecommendationRecommendationProtocol) then
    composeImmunizationRecommendationRecommendationProtocol(xml, name,  TFhirImmunizationRecommendationRecommendationProtocol(base))
  else if (base is TFhirImmunizationRecommendation) then
    composeImmunizationRecommendation(xml, name,  TFhirImmunizationRecommendation(base))
  else if (base is TFhirImplementationGuideContact) then
    composeImplementationGuideContact(xml, name,  TFhirImplementationGuideContact(base))
  else if (base is TFhirImplementationGuideDependency) then
    composeImplementationGuideDependency(xml, name,  TFhirImplementationGuideDependency(base))
  else if (base is TFhirImplementationGuidePackage) then
    composeImplementationGuidePackage(xml, name,  TFhirImplementationGuidePackage(base))
  else if (base is TFhirImplementationGuidePackageResource) then
    composeImplementationGuidePackageResource(xml, name,  TFhirImplementationGuidePackageResource(base))
  else if (base is TFhirImplementationGuideGlobal) then
    composeImplementationGuideGlobal(xml, name,  TFhirImplementationGuideGlobal(base))
  else if (base is TFhirImplementationGuidePage) then
    composeImplementationGuidePage(xml, name,  TFhirImplementationGuidePage(base))
  else if (base is TFhirImplementationGuide) then
    composeImplementationGuide(xml, name,  TFhirImplementationGuide(base))
  else if (base is TFhirListEntry) then
    composeListEntry(xml, name,  TFhirListEntry(base))
  else if (base is TFhirList) then
    composeList(xml, name,  TFhirList(base))
  else if (base is TFhirLocationPosition) then
    composeLocationPosition(xml, name,  TFhirLocationPosition(base))
  else if (base is TFhirLocation) then
    composeLocation(xml, name,  TFhirLocation(base))
  else if (base is TFhirMedia) then
    composeMedia(xml, name,  TFhirMedia(base))
  else if (base is TFhirMedicationProduct) then
    composeMedicationProduct(xml, name,  TFhirMedicationProduct(base))
  else if (base is TFhirMedicationProductIngredient) then
    composeMedicationProductIngredient(xml, name,  TFhirMedicationProductIngredient(base))
  else if (base is TFhirMedicationProductBatch) then
    composeMedicationProductBatch(xml, name,  TFhirMedicationProductBatch(base))
  else if (base is TFhirMedicationPackage) then
    composeMedicationPackage(xml, name,  TFhirMedicationPackage(base))
  else if (base is TFhirMedicationPackageContent) then
    composeMedicationPackageContent(xml, name,  TFhirMedicationPackageContent(base))
  else if (base is TFhirMedication) then
    composeMedication(xml, name,  TFhirMedication(base))
  else if (base is TFhirMedicationAdministrationDosage) then
    composeMedicationAdministrationDosage(xml, name,  TFhirMedicationAdministrationDosage(base))
  else if (base is TFhirMedicationAdministration) then
    composeMedicationAdministration(xml, name,  TFhirMedicationAdministration(base))
  else if (base is TFhirMedicationDispenseDosageInstruction) then
    composeMedicationDispenseDosageInstruction(xml, name,  TFhirMedicationDispenseDosageInstruction(base))
  else if (base is TFhirMedicationDispenseSubstitution) then
    composeMedicationDispenseSubstitution(xml, name,  TFhirMedicationDispenseSubstitution(base))
  else if (base is TFhirMedicationDispense) then
    composeMedicationDispense(xml, name,  TFhirMedicationDispense(base))
  else if (base is TFhirMedicationOrderDosageInstruction) then
    composeMedicationOrderDosageInstruction(xml, name,  TFhirMedicationOrderDosageInstruction(base))
  else if (base is TFhirMedicationOrderDispenseRequest) then
    composeMedicationOrderDispenseRequest(xml, name,  TFhirMedicationOrderDispenseRequest(base))
  else if (base is TFhirMedicationOrderSubstitution) then
    composeMedicationOrderSubstitution(xml, name,  TFhirMedicationOrderSubstitution(base))
  else if (base is TFhirMedicationOrder) then
    composeMedicationOrder(xml, name,  TFhirMedicationOrder(base))
  else if (base is TFhirMedicationStatementDosage) then
    composeMedicationStatementDosage(xml, name,  TFhirMedicationStatementDosage(base))
  else if (base is TFhirMedicationStatement) then
    composeMedicationStatement(xml, name,  TFhirMedicationStatement(base))
  else if (base is TFhirMessageHeaderResponse) then
    composeMessageHeaderResponse(xml, name,  TFhirMessageHeaderResponse(base))
  else if (base is TFhirMessageHeaderSource) then
    composeMessageHeaderSource(xml, name,  TFhirMessageHeaderSource(base))
  else if (base is TFhirMessageHeaderDestination) then
    composeMessageHeaderDestination(xml, name,  TFhirMessageHeaderDestination(base))
  else if (base is TFhirMessageHeader) then
    composeMessageHeader(xml, name,  TFhirMessageHeader(base))
  else if (base is TFhirNamingSystemContact) then
    composeNamingSystemContact(xml, name,  TFhirNamingSystemContact(base))
  else if (base is TFhirNamingSystemUniqueId) then
    composeNamingSystemUniqueId(xml, name,  TFhirNamingSystemUniqueId(base))
  else if (base is TFhirNamingSystem) then
    composeNamingSystem(xml, name,  TFhirNamingSystem(base))
  else if (base is TFhirNutritionOrderOralDiet) then
    composeNutritionOrderOralDiet(xml, name,  TFhirNutritionOrderOralDiet(base))
  else if (base is TFhirNutritionOrderOralDietNutrient) then
    composeNutritionOrderOralDietNutrient(xml, name,  TFhirNutritionOrderOralDietNutrient(base))
  else if (base is TFhirNutritionOrderOralDietTexture) then
    composeNutritionOrderOralDietTexture(xml, name,  TFhirNutritionOrderOralDietTexture(base))
  else if (base is TFhirNutritionOrderSupplement) then
    composeNutritionOrderSupplement(xml, name,  TFhirNutritionOrderSupplement(base))
  else if (base is TFhirNutritionOrderEnteralFormula) then
    composeNutritionOrderEnteralFormula(xml, name,  TFhirNutritionOrderEnteralFormula(base))
  else if (base is TFhirNutritionOrderEnteralFormulaAdministration) then
    composeNutritionOrderEnteralFormulaAdministration(xml, name,  TFhirNutritionOrderEnteralFormulaAdministration(base))
  else if (base is TFhirNutritionOrder) then
    composeNutritionOrder(xml, name,  TFhirNutritionOrder(base))
  else if (base is TFhirObservationReferenceRange) then
    composeObservationReferenceRange(xml, name,  TFhirObservationReferenceRange(base))
  else if (base is TFhirObservationRelated) then
    composeObservationRelated(xml, name,  TFhirObservationRelated(base))
  else if (base is TFhirObservationComponent) then
    composeObservationComponent(xml, name,  TFhirObservationComponent(base))
  else if (base is TFhirObservation) then
    composeObservation(xml, name,  TFhirObservation(base))
  else if (base is TFhirOperationDefinitionContact) then
    composeOperationDefinitionContact(xml, name,  TFhirOperationDefinitionContact(base))
  else if (base is TFhirOperationDefinitionParameter) then
    composeOperationDefinitionParameter(xml, name,  TFhirOperationDefinitionParameter(base))
  else if (base is TFhirOperationDefinitionParameterBinding) then
    composeOperationDefinitionParameterBinding(xml, name,  TFhirOperationDefinitionParameterBinding(base))
  else if (base is TFhirOperationDefinition) then
    composeOperationDefinition(xml, name,  TFhirOperationDefinition(base))
  else if (base is TFhirOperationOutcomeIssue) then
    composeOperationOutcomeIssue(xml, name,  TFhirOperationOutcomeIssue(base))
  else if (base is TFhirOperationOutcome) then
    composeOperationOutcome(xml, name,  TFhirOperationOutcome(base))
  else if (base is TFhirOrderWhen) then
    composeOrderWhen(xml, name,  TFhirOrderWhen(base))
  else if (base is TFhirOrder) then
    composeOrder(xml, name,  TFhirOrder(base))
  else if (base is TFhirOrderResponse) then
    composeOrderResponse(xml, name,  TFhirOrderResponse(base))
  else if (base is TFhirOrganizationContact) then
    composeOrganizationContact(xml, name,  TFhirOrganizationContact(base))
  else if (base is TFhirOrganization) then
    composeOrganization(xml, name,  TFhirOrganization(base))
  else if (base is TFhirPatientContact) then
    composePatientContact(xml, name,  TFhirPatientContact(base))
  else if (base is TFhirPatientAnimal) then
    composePatientAnimal(xml, name,  TFhirPatientAnimal(base))
  else if (base is TFhirPatientCommunication) then
    composePatientCommunication(xml, name,  TFhirPatientCommunication(base))
  else if (base is TFhirPatientLink) then
    composePatientLink(xml, name,  TFhirPatientLink(base))
  else if (base is TFhirPatient) then
    composePatient(xml, name,  TFhirPatient(base))
  else if (base is TFhirPaymentNotice) then
    composePaymentNotice(xml, name,  TFhirPaymentNotice(base))
  else if (base is TFhirPaymentReconciliationDetail) then
    composePaymentReconciliationDetail(xml, name,  TFhirPaymentReconciliationDetail(base))
  else if (base is TFhirPaymentReconciliationNote) then
    composePaymentReconciliationNote(xml, name,  TFhirPaymentReconciliationNote(base))
  else if (base is TFhirPaymentReconciliation) then
    composePaymentReconciliation(xml, name,  TFhirPaymentReconciliation(base))
  else if (base is TFhirPersonLink) then
    composePersonLink(xml, name,  TFhirPersonLink(base))
  else if (base is TFhirPerson) then
    composePerson(xml, name,  TFhirPerson(base))
  else if (base is TFhirPractitionerPractitionerRole) then
    composePractitionerPractitionerRole(xml, name,  TFhirPractitionerPractitionerRole(base))
  else if (base is TFhirPractitionerQualification) then
    composePractitionerQualification(xml, name,  TFhirPractitionerQualification(base))
  else if (base is TFhirPractitioner) then
    composePractitioner(xml, name,  TFhirPractitioner(base))
  else if (base is TFhirProcedurePerformer) then
    composeProcedurePerformer(xml, name,  TFhirProcedurePerformer(base))
  else if (base is TFhirProcedureFocalDevice) then
    composeProcedureFocalDevice(xml, name,  TFhirProcedureFocalDevice(base))
  else if (base is TFhirProcedure) then
    composeProcedure(xml, name,  TFhirProcedure(base))
  else if (base is TFhirProcedureRequest) then
    composeProcedureRequest(xml, name,  TFhirProcedureRequest(base))
  else if (base is TFhirProcessRequestItem) then
    composeProcessRequestItem(xml, name,  TFhirProcessRequestItem(base))
  else if (base is TFhirProcessRequest) then
    composeProcessRequest(xml, name,  TFhirProcessRequest(base))
  else if (base is TFhirProcessResponseNotes) then
    composeProcessResponseNotes(xml, name,  TFhirProcessResponseNotes(base))
  else if (base is TFhirProcessResponse) then
    composeProcessResponse(xml, name,  TFhirProcessResponse(base))
  else if (base is TFhirProvenanceAgent) then
    composeProvenanceAgent(xml, name,  TFhirProvenanceAgent(base))
  else if (base is TFhirProvenanceAgentRelatedAgent) then
    composeProvenanceAgentRelatedAgent(xml, name,  TFhirProvenanceAgentRelatedAgent(base))
  else if (base is TFhirProvenanceEntity) then
    composeProvenanceEntity(xml, name,  TFhirProvenanceEntity(base))
  else if (base is TFhirProvenance) then
    composeProvenance(xml, name,  TFhirProvenance(base))
  else if (base is TFhirQuestionnaireGroup) then
    composeQuestionnaireGroup(xml, name,  TFhirQuestionnaireGroup(base))
  else if (base is TFhirQuestionnaireGroupQuestion) then
    composeQuestionnaireGroupQuestion(xml, name,  TFhirQuestionnaireGroupQuestion(base))
  else if (base is TFhirQuestionnaire) then
    composeQuestionnaire(xml, name,  TFhirQuestionnaire(base))
  else if (base is TFhirQuestionnaireResponseGroup) then
    composeQuestionnaireResponseGroup(xml, name,  TFhirQuestionnaireResponseGroup(base))
  else if (base is TFhirQuestionnaireResponseGroupQuestion) then
    composeQuestionnaireResponseGroupQuestion(xml, name,  TFhirQuestionnaireResponseGroupQuestion(base))
  else if (base is TFhirQuestionnaireResponseGroupQuestionAnswer) then
    composeQuestionnaireResponseGroupQuestionAnswer(xml, name,  TFhirQuestionnaireResponseGroupQuestionAnswer(base))
  else if (base is TFhirQuestionnaireResponse) then
    composeQuestionnaireResponse(xml, name,  TFhirQuestionnaireResponse(base))
  else if (base is TFhirReferralRequest) then
    composeReferralRequest(xml, name,  TFhirReferralRequest(base))
  else if (base is TFhirRelatedPerson) then
    composeRelatedPerson(xml, name,  TFhirRelatedPerson(base))
  else if (base is TFhirRiskAssessmentPrediction) then
    composeRiskAssessmentPrediction(xml, name,  TFhirRiskAssessmentPrediction(base))
  else if (base is TFhirRiskAssessment) then
    composeRiskAssessment(xml, name,  TFhirRiskAssessment(base))
  else if (base is TFhirSchedule) then
    composeSchedule(xml, name,  TFhirSchedule(base))
  else if (base is TFhirSearchParameterContact) then
    composeSearchParameterContact(xml, name,  TFhirSearchParameterContact(base))
  else if (base is TFhirSearchParameter) then
    composeSearchParameter(xml, name,  TFhirSearchParameter(base))
  else if (base is TFhirSlot) then
    composeSlot(xml, name,  TFhirSlot(base))
  else if (base is TFhirSpecimenCollection) then
    composeSpecimenCollection(xml, name,  TFhirSpecimenCollection(base))
  else if (base is TFhirSpecimenTreatment) then
    composeSpecimenTreatment(xml, name,  TFhirSpecimenTreatment(base))
  else if (base is TFhirSpecimenContainer) then
    composeSpecimenContainer(xml, name,  TFhirSpecimenContainer(base))
  else if (base is TFhirSpecimen) then
    composeSpecimen(xml, name,  TFhirSpecimen(base))
  else if (base is TFhirStructureDefinitionContact) then
    composeStructureDefinitionContact(xml, name,  TFhirStructureDefinitionContact(base))
  else if (base is TFhirStructureDefinitionMapping) then
    composeStructureDefinitionMapping(xml, name,  TFhirStructureDefinitionMapping(base))
  else if (base is TFhirStructureDefinitionSnapshot) then
    composeStructureDefinitionSnapshot(xml, name,  TFhirStructureDefinitionSnapshot(base))
  else if (base is TFhirStructureDefinitionDifferential) then
    composeStructureDefinitionDifferential(xml, name,  TFhirStructureDefinitionDifferential(base))
  else if (base is TFhirStructureDefinition) then
    composeStructureDefinition(xml, name,  TFhirStructureDefinition(base))
  else if (base is TFhirSubscriptionChannel) then
    composeSubscriptionChannel(xml, name,  TFhirSubscriptionChannel(base))
  else if (base is TFhirSubscription) then
    composeSubscription(xml, name,  TFhirSubscription(base))
  else if (base is TFhirSubstanceInstance) then
    composeSubstanceInstance(xml, name,  TFhirSubstanceInstance(base))
  else if (base is TFhirSubstanceIngredient) then
    composeSubstanceIngredient(xml, name,  TFhirSubstanceIngredient(base))
  else if (base is TFhirSubstance) then
    composeSubstance(xml, name,  TFhirSubstance(base))
  else if (base is TFhirSupplyDelivery) then
    composeSupplyDelivery(xml, name,  TFhirSupplyDelivery(base))
  else if (base is TFhirSupplyRequestWhen) then
    composeSupplyRequestWhen(xml, name,  TFhirSupplyRequestWhen(base))
  else if (base is TFhirSupplyRequest) then
    composeSupplyRequest(xml, name,  TFhirSupplyRequest(base))
  else if (base is TFhirTestScriptContact) then
    composeTestScriptContact(xml, name,  TFhirTestScriptContact(base))
  else if (base is TFhirTestScriptMetadata) then
    composeTestScriptMetadata(xml, name,  TFhirTestScriptMetadata(base))
  else if (base is TFhirTestScriptMetadataLink) then
    composeTestScriptMetadataLink(xml, name,  TFhirTestScriptMetadataLink(base))
  else if (base is TFhirTestScriptMetadataCapability) then
    composeTestScriptMetadataCapability(xml, name,  TFhirTestScriptMetadataCapability(base))
  else if (base is TFhirTestScriptFixture) then
    composeTestScriptFixture(xml, name,  TFhirTestScriptFixture(base))
  else if (base is TFhirTestScriptVariable) then
    composeTestScriptVariable(xml, name,  TFhirTestScriptVariable(base))
  else if (base is TFhirTestScriptSetup) then
    composeTestScriptSetup(xml, name,  TFhirTestScriptSetup(base))
  else if (base is TFhirTestScriptSetupAction) then
    composeTestScriptSetupAction(xml, name,  TFhirTestScriptSetupAction(base))
  else if (base is TFhirTestScriptSetupActionOperation) then
    composeTestScriptSetupActionOperation(xml, name,  TFhirTestScriptSetupActionOperation(base))
  else if (base is TFhirTestScriptSetupActionOperationRequestHeader) then
    composeTestScriptSetupActionOperationRequestHeader(xml, name,  TFhirTestScriptSetupActionOperationRequestHeader(base))
  else if (base is TFhirTestScriptSetupActionAssert) then
    composeTestScriptSetupActionAssert(xml, name,  TFhirTestScriptSetupActionAssert(base))
  else if (base is TFhirTestScriptTest) then
    composeTestScriptTest(xml, name,  TFhirTestScriptTest(base))
  else if (base is TFhirTestScriptTestAction) then
    composeTestScriptTestAction(xml, name,  TFhirTestScriptTestAction(base))
  else if (base is TFhirTestScriptTeardown) then
    composeTestScriptTeardown(xml, name,  TFhirTestScriptTeardown(base))
  else if (base is TFhirTestScriptTeardownAction) then
    composeTestScriptTeardownAction(xml, name,  TFhirTestScriptTeardownAction(base))
  else if (base is TFhirTestScript) then
    composeTestScript(xml, name,  TFhirTestScript(base))
  else if (base is TFhirValueSetContact) then
    composeValueSetContact(xml, name,  TFhirValueSetContact(base))
  else if (base is TFhirValueSetCodeSystem) then
    composeValueSetCodeSystem(xml, name,  TFhirValueSetCodeSystem(base))
  else if (base is TFhirValueSetCodeSystemConcept) then
    composeValueSetCodeSystemConcept(xml, name,  TFhirValueSetCodeSystemConcept(base))
  else if (base is TFhirValueSetCodeSystemConceptDesignation) then
    composeValueSetCodeSystemConceptDesignation(xml, name,  TFhirValueSetCodeSystemConceptDesignation(base))
  else if (base is TFhirValueSetCompose) then
    composeValueSetCompose(xml, name,  TFhirValueSetCompose(base))
  else if (base is TFhirValueSetComposeInclude) then
    composeValueSetComposeInclude(xml, name,  TFhirValueSetComposeInclude(base))
  else if (base is TFhirValueSetComposeIncludeConcept) then
    composeValueSetComposeIncludeConcept(xml, name,  TFhirValueSetComposeIncludeConcept(base))
  else if (base is TFhirValueSetComposeIncludeFilter) then
    composeValueSetComposeIncludeFilter(xml, name,  TFhirValueSetComposeIncludeFilter(base))
  else if (base is TFhirValueSetExpansion) then
    composeValueSetExpansion(xml, name,  TFhirValueSetExpansion(base))
  else if (base is TFhirValueSetExpansionParameter) then
    composeValueSetExpansionParameter(xml, name,  TFhirValueSetExpansionParameter(base))
  else if (base is TFhirValueSetExpansionContains) then
    composeValueSetExpansionContains(xml, name,  TFhirValueSetExpansionContains(base))
  else if (base is TFhirValueSet) then
    composeValueSet(xml, name,  TFhirValueSet(base))
  else if (base is TFhirVisionPrescriptionDispense) then
    composeVisionPrescriptionDispense(xml, name,  TFhirVisionPrescriptionDispense(base))
  else if (base is TFhirVisionPrescription) then
    composeVisionPrescription(xml, name,  TFhirVisionPrescription(base))
  else
    raise Exception.create('Unknown Type '+base.className);
end;

procedure TFHIRJsonComposer.ComposeBase(json: TJSONWriter; name: String; base: TFHIRBase);
begin
   if (base is TFhirInteger) then
    composeIntegerValue(json, name, TFhirInteger(base), false)
  else if (base is TFhirDateTime) then
    composeDateTimeValue(json, name, TFhirDateTime(base), false)
  else if (base is TFhirDate) then
    composeDateValue(json, name, TFhirDate(base), false)
  else if (base is TFhirDecimal) then
    composeDecimalValue(json, name, TFhirDecimal(base), false)
  else if (base is TFhirUri) then
    composeUriValue(json, name, TFhirUri(base), false)
  else if (base is TFhirBase64Binary) then
    composeBase64BinaryValue(json, name, TFhirBase64Binary(base), false)
  else if (base is TFhirTime) then
    composeTimeValue(json, name, TFhirTime(base), false)
  else if (base is TFhirString) then
    composeStringValue(json, name, TFhirString(base), false)
  else if (base is TFhirBoolean) then
    composeBooleanValue(json, name, TFhirBoolean(base), false)
  else if (base is TFhirInstant) then
    composeInstantValue(json, name, TFhirInstant(base), false)
  else if (base is TFhirMarkdown) then
    composeMarkdownValue(json, name, TFhirMarkdown(base), false)
  else if (base is TFhirUnsignedInt) then
    composeUnsignedIntValue(json, name, TFhirUnsignedInt(base), false)
  else if (base is TFhirCode) then
    composeCodeValue(json, name, TFhirCode(base), false)
  else if (base is TFhirId) then
    composeIdValue(json, name, TFhirId(base), false)
  else if (base is TFhirOid) then
    composeOidValue(json, name, TFhirOid(base), false)
  else if (base is TFhirPositiveInt) then
    composePositiveIntValue(json, name, TFhirPositiveInt(base), false)
  else if (base is TFhirUuid) then
    composeUuidValue(json, name, TFhirUuid(base), false)
  else if (base is TFhirParametersParameter) then
    composeParametersParameter(json, name, TFhirParametersParameter(base), false)
  else if (base is TFhirParameters) then
    composeParameters(json, name, TFhirParameters(base), false)
  else if (base is TFhirExtension) then
    composeExtension(json, name, TFhirExtension(base), false)
  else if (base is TFhirNarrative) then
    composeNarrative(json, name, TFhirNarrative(base), false)
  else if (base is TFhirPeriod) then
    composePeriod(json, name, TFhirPeriod(base), false)
  else if (base is TFhirCoding) then
    composeCoding(json, name, TFhirCoding(base), false)
  else if (base is TFhirRange) then
    composeRange(json, name, TFhirRange(base), false)
  else if (base is TFhirAttachment) then
    composeAttachment(json, name, TFhirAttachment(base), false)
  else if (base is TFhirQuantity) then
    composeQuantity(json, name, TFhirQuantity(base), false)
  else if (base is TFhirAnnotation) then
    composeAnnotation(json, name, TFhirAnnotation(base), false)
  else if (base is TFhirRatio) then
    composeRatio(json, name, TFhirRatio(base), false)
  else if (base is TFhirSampledData) then
    composeSampledData(json, name, TFhirSampledData(base), false)
  else if (base is TFhirCodeableConcept) then
    composeCodeableConcept(json, name, TFhirCodeableConcept(base), false)
  else if (base is TFhirReference) then
    composeReference(json, name, TFhirReference(base), false)
  else if (base is TFhirIdentifier) then
    composeIdentifier(json, name, TFhirIdentifier(base), false)
  else if (base is TFhirSignature) then
    composeSignature(json, name, TFhirSignature(base), false)
  else if (base is TFhirTimingRepeat) then
    composeTimingRepeat(json, name, TFhirTimingRepeat(base), false)
  else if (base is TFhirTiming) then
    composeTiming(json, name, TFhirTiming(base), false)
  else if (base is TFhirElementDefinitionSlicing) then
    composeElementDefinitionSlicing(json, name, TFhirElementDefinitionSlicing(base), false)
  else if (base is TFhirElementDefinitionBase) then
    composeElementDefinitionBase(json, name, TFhirElementDefinitionBase(base), false)
  else if (base is TFhirElementDefinitionType) then
    composeElementDefinitionType(json, name, TFhirElementDefinitionType(base), false)
  else if (base is TFhirElementDefinitionConstraint) then
    composeElementDefinitionConstraint(json, name, TFhirElementDefinitionConstraint(base), false)
  else if (base is TFhirElementDefinitionBinding) then
    composeElementDefinitionBinding(json, name, TFhirElementDefinitionBinding(base), false)
  else if (base is TFhirElementDefinitionMapping) then
    composeElementDefinitionMapping(json, name, TFhirElementDefinitionMapping(base), false)
  else if (base is TFhirElementDefinition) then
    composeElementDefinition(json, name, TFhirElementDefinition(base), false)
  else if (base is TFhirHumanName) then
    composeHumanName(json, name, TFhirHumanName(base), false)
  else if (base is TFhirAddress) then
    composeAddress(json, name, TFhirAddress(base), false)
  else if (base is TFhirMeta) then
    composeMeta(json, name, TFhirMeta(base), false)
  else if (base is TFhirContactPoint) then
    composeContactPoint(json, name, TFhirContactPoint(base), false)
  else if (base is TFhirAccount) then
    composeAccount(json, name, TFhirAccount(base), false)
  else if (base is TFhirAllergyIntoleranceReaction) then
    composeAllergyIntoleranceReaction(json, name, TFhirAllergyIntoleranceReaction(base), false)
  else if (base is TFhirAllergyIntolerance) then
    composeAllergyIntolerance(json, name, TFhirAllergyIntolerance(base), false)
  else if (base is TFhirAppointmentParticipant) then
    composeAppointmentParticipant(json, name, TFhirAppointmentParticipant(base), false)
  else if (base is TFhirAppointment) then
    composeAppointment(json, name, TFhirAppointment(base), false)
  else if (base is TFhirAppointmentResponse) then
    composeAppointmentResponse(json, name, TFhirAppointmentResponse(base), false)
  else if (base is TFhirAuditEventEvent) then
    composeAuditEventEvent(json, name, TFhirAuditEventEvent(base), false)
  else if (base is TFhirAuditEventParticipant) then
    composeAuditEventParticipant(json, name, TFhirAuditEventParticipant(base), false)
  else if (base is TFhirAuditEventParticipantNetwork) then
    composeAuditEventParticipantNetwork(json, name, TFhirAuditEventParticipantNetwork(base), false)
  else if (base is TFhirAuditEventSource) then
    composeAuditEventSource(json, name, TFhirAuditEventSource(base), false)
  else if (base is TFhirAuditEventObject) then
    composeAuditEventObject(json, name, TFhirAuditEventObject(base), false)
  else if (base is TFhirAuditEventObjectDetail) then
    composeAuditEventObjectDetail(json, name, TFhirAuditEventObjectDetail(base), false)
  else if (base is TFhirAuditEvent) then
    composeAuditEvent(json, name, TFhirAuditEvent(base), false)
  else if (base is TFhirBasic) then
    composeBasic(json, name, TFhirBasic(base), false)
  else if (base is TFhirBinary) then
    composeBinary(json, name, TFhirBinary(base), false)
  else if (base is TFhirBodySite) then
    composeBodySite(json, name, TFhirBodySite(base), false)
  else if (base is TFhirBundleLink) then
    composeBundleLink(json, name, TFhirBundleLink(base), false)
  else if (base is TFhirBundleEntry) then
    composeBundleEntry(json, name, TFhirBundleEntry(base), false)
  else if (base is TFhirBundleEntrySearch) then
    composeBundleEntrySearch(json, name, TFhirBundleEntrySearch(base), false)
  else if (base is TFhirBundleEntryRequest) then
    composeBundleEntryRequest(json, name, TFhirBundleEntryRequest(base), false)
  else if (base is TFhirBundleEntryResponse) then
    composeBundleEntryResponse(json, name, TFhirBundleEntryResponse(base), false)
  else if (base is TFhirBundle) then
    composeBundle(json, name, TFhirBundle(base), false)
  else if (base is TFhirCarePlanRelatedPlan) then
    composeCarePlanRelatedPlan(json, name, TFhirCarePlanRelatedPlan(base), false)
  else if (base is TFhirCarePlanParticipant) then
    composeCarePlanParticipant(json, name, TFhirCarePlanParticipant(base), false)
  else if (base is TFhirCarePlanActivity) then
    composeCarePlanActivity(json, name, TFhirCarePlanActivity(base), false)
  else if (base is TFhirCarePlanActivityDetail) then
    composeCarePlanActivityDetail(json, name, TFhirCarePlanActivityDetail(base), false)
  else if (base is TFhirCarePlan) then
    composeCarePlan(json, name, TFhirCarePlan(base), false)
  else if (base is TFhirClaimPayee) then
    composeClaimPayee(json, name, TFhirClaimPayee(base), false)
  else if (base is TFhirClaimDiagnosis) then
    composeClaimDiagnosis(json, name, TFhirClaimDiagnosis(base), false)
  else if (base is TFhirClaimCoverage) then
    composeClaimCoverage(json, name, TFhirClaimCoverage(base), false)
  else if (base is TFhirClaimItem) then
    composeClaimItem(json, name, TFhirClaimItem(base), false)
  else if (base is TFhirClaimItemDetail) then
    composeClaimItemDetail(json, name, TFhirClaimItemDetail(base), false)
  else if (base is TFhirClaimItemDetailSubDetail) then
    composeClaimItemDetailSubDetail(json, name, TFhirClaimItemDetailSubDetail(base), false)
  else if (base is TFhirClaimItemProsthesis) then
    composeClaimItemProsthesis(json, name, TFhirClaimItemProsthesis(base), false)
  else if (base is TFhirClaimMissingTeeth) then
    composeClaimMissingTeeth(json, name, TFhirClaimMissingTeeth(base), false)
  else if (base is TFhirClaim) then
    composeClaim(json, name, TFhirClaim(base), false)
  else if (base is TFhirClaimResponseItem) then
    composeClaimResponseItem(json, name, TFhirClaimResponseItem(base), false)
  else if (base is TFhirClaimResponseItemAdjudication) then
    composeClaimResponseItemAdjudication(json, name, TFhirClaimResponseItemAdjudication(base), false)
  else if (base is TFhirClaimResponseItemDetail) then
    composeClaimResponseItemDetail(json, name, TFhirClaimResponseItemDetail(base), false)
  else if (base is TFhirClaimResponseItemDetailAdjudication) then
    composeClaimResponseItemDetailAdjudication(json, name, TFhirClaimResponseItemDetailAdjudication(base), false)
  else if (base is TFhirClaimResponseItemDetailSubDetail) then
    composeClaimResponseItemDetailSubDetail(json, name, TFhirClaimResponseItemDetailSubDetail(base), false)
  else if (base is TFhirClaimResponseItemDetailSubDetailAdjudication) then
    composeClaimResponseItemDetailSubDetailAdjudication(json, name, TFhirClaimResponseItemDetailSubDetailAdjudication(base), false)
  else if (base is TFhirClaimResponseAddItem) then
    composeClaimResponseAddItem(json, name, TFhirClaimResponseAddItem(base), false)
  else if (base is TFhirClaimResponseAddItemAdjudication) then
    composeClaimResponseAddItemAdjudication(json, name, TFhirClaimResponseAddItemAdjudication(base), false)
  else if (base is TFhirClaimResponseAddItemDetail) then
    composeClaimResponseAddItemDetail(json, name, TFhirClaimResponseAddItemDetail(base), false)
  else if (base is TFhirClaimResponseAddItemDetailAdjudication) then
    composeClaimResponseAddItemDetailAdjudication(json, name, TFhirClaimResponseAddItemDetailAdjudication(base), false)
  else if (base is TFhirClaimResponseError) then
    composeClaimResponseError(json, name, TFhirClaimResponseError(base), false)
  else if (base is TFhirClaimResponseNote) then
    composeClaimResponseNote(json, name, TFhirClaimResponseNote(base), false)
  else if (base is TFhirClaimResponseCoverage) then
    composeClaimResponseCoverage(json, name, TFhirClaimResponseCoverage(base), false)
  else if (base is TFhirClaimResponse) then
    composeClaimResponse(json, name, TFhirClaimResponse(base), false)
  else if (base is TFhirClinicalImpressionInvestigations) then
    composeClinicalImpressionInvestigations(json, name, TFhirClinicalImpressionInvestigations(base), false)
  else if (base is TFhirClinicalImpressionFinding) then
    composeClinicalImpressionFinding(json, name, TFhirClinicalImpressionFinding(base), false)
  else if (base is TFhirClinicalImpressionRuledOut) then
    composeClinicalImpressionRuledOut(json, name, TFhirClinicalImpressionRuledOut(base), false)
  else if (base is TFhirClinicalImpression) then
    composeClinicalImpression(json, name, TFhirClinicalImpression(base), false)
  else if (base is TFhirCommunicationPayload) then
    composeCommunicationPayload(json, name, TFhirCommunicationPayload(base), false)
  else if (base is TFhirCommunication) then
    composeCommunication(json, name, TFhirCommunication(base), false)
  else if (base is TFhirCommunicationRequestPayload) then
    composeCommunicationRequestPayload(json, name, TFhirCommunicationRequestPayload(base), false)
  else if (base is TFhirCommunicationRequest) then
    composeCommunicationRequest(json, name, TFhirCommunicationRequest(base), false)
  else if (base is TFhirCompositionAttester) then
    composeCompositionAttester(json, name, TFhirCompositionAttester(base), false)
  else if (base is TFhirCompositionEvent) then
    composeCompositionEvent(json, name, TFhirCompositionEvent(base), false)
  else if (base is TFhirCompositionSection) then
    composeCompositionSection(json, name, TFhirCompositionSection(base), false)
  else if (base is TFhirComposition) then
    composeComposition(json, name, TFhirComposition(base), false)
  else if (base is TFhirConceptMapContact) then
    composeConceptMapContact(json, name, TFhirConceptMapContact(base), false)
  else if (base is TFhirConceptMapElement) then
    composeConceptMapElement(json, name, TFhirConceptMapElement(base), false)
  else if (base is TFhirConceptMapElementTarget) then
    composeConceptMapElementTarget(json, name, TFhirConceptMapElementTarget(base), false)
  else if (base is TFhirConceptMapElementTargetDependsOn) then
    composeConceptMapElementTargetDependsOn(json, name, TFhirConceptMapElementTargetDependsOn(base), false)
  else if (base is TFhirConceptMap) then
    composeConceptMap(json, name, TFhirConceptMap(base), false)
  else if (base is TFhirConditionStage) then
    composeConditionStage(json, name, TFhirConditionStage(base), false)
  else if (base is TFhirConditionEvidence) then
    composeConditionEvidence(json, name, TFhirConditionEvidence(base), false)
  else if (base is TFhirCondition) then
    composeCondition(json, name, TFhirCondition(base), false)
  else if (base is TFhirConformanceContact) then
    composeConformanceContact(json, name, TFhirConformanceContact(base), false)
  else if (base is TFhirConformanceSoftware) then
    composeConformanceSoftware(json, name, TFhirConformanceSoftware(base), false)
  else if (base is TFhirConformanceImplementation) then
    composeConformanceImplementation(json, name, TFhirConformanceImplementation(base), false)
  else if (base is TFhirConformanceRest) then
    composeConformanceRest(json, name, TFhirConformanceRest(base), false)
  else if (base is TFhirConformanceRestSecurity) then
    composeConformanceRestSecurity(json, name, TFhirConformanceRestSecurity(base), false)
  else if (base is TFhirConformanceRestSecurityCertificate) then
    composeConformanceRestSecurityCertificate(json, name, TFhirConformanceRestSecurityCertificate(base), false)
  else if (base is TFhirConformanceRestResource) then
    composeConformanceRestResource(json, name, TFhirConformanceRestResource(base), false)
  else if (base is TFhirConformanceRestResourceInteraction) then
    composeConformanceRestResourceInteraction(json, name, TFhirConformanceRestResourceInteraction(base), false)
  else if (base is TFhirConformanceRestResourceSearchParam) then
    composeConformanceRestResourceSearchParam(json, name, TFhirConformanceRestResourceSearchParam(base), false)
  else if (base is TFhirConformanceRestInteraction) then
    composeConformanceRestInteraction(json, name, TFhirConformanceRestInteraction(base), false)
  else if (base is TFhirConformanceRestOperation) then
    composeConformanceRestOperation(json, name, TFhirConformanceRestOperation(base), false)
  else if (base is TFhirConformanceMessaging) then
    composeConformanceMessaging(json, name, TFhirConformanceMessaging(base), false)
  else if (base is TFhirConformanceMessagingEndpoint) then
    composeConformanceMessagingEndpoint(json, name, TFhirConformanceMessagingEndpoint(base), false)
  else if (base is TFhirConformanceMessagingEvent) then
    composeConformanceMessagingEvent(json, name, TFhirConformanceMessagingEvent(base), false)
  else if (base is TFhirConformanceDocument) then
    composeConformanceDocument(json, name, TFhirConformanceDocument(base), false)
  else if (base is TFhirConformance) then
    composeConformance(json, name, TFhirConformance(base), false)
  else if (base is TFhirContractActor) then
    composeContractActor(json, name, TFhirContractActor(base), false)
  else if (base is TFhirContractValuedItem) then
    composeContractValuedItem(json, name, TFhirContractValuedItem(base), false)
  else if (base is TFhirContractSigner) then
    composeContractSigner(json, name, TFhirContractSigner(base), false)
  else if (base is TFhirContractTerm) then
    composeContractTerm(json, name, TFhirContractTerm(base), false)
  else if (base is TFhirContractTermActor) then
    composeContractTermActor(json, name, TFhirContractTermActor(base), false)
  else if (base is TFhirContractTermValuedItem) then
    composeContractTermValuedItem(json, name, TFhirContractTermValuedItem(base), false)
  else if (base is TFhirContractFriendly) then
    composeContractFriendly(json, name, TFhirContractFriendly(base), false)
  else if (base is TFhirContractLegal) then
    composeContractLegal(json, name, TFhirContractLegal(base), false)
  else if (base is TFhirContractRule) then
    composeContractRule(json, name, TFhirContractRule(base), false)
  else if (base is TFhirContract) then
    composeContract(json, name, TFhirContract(base), false)
  else if (base is TFhirCoverage) then
    composeCoverage(json, name, TFhirCoverage(base), false)
  else if (base is TFhirDataElementContact) then
    composeDataElementContact(json, name, TFhirDataElementContact(base), false)
  else if (base is TFhirDataElementMapping) then
    composeDataElementMapping(json, name, TFhirDataElementMapping(base), false)
  else if (base is TFhirDataElement) then
    composeDataElement(json, name, TFhirDataElement(base), false)
  else if (base is TFhirDetectedIssueMitigation) then
    composeDetectedIssueMitigation(json, name, TFhirDetectedIssueMitigation(base), false)
  else if (base is TFhirDetectedIssue) then
    composeDetectedIssue(json, name, TFhirDetectedIssue(base), false)
  else if (base is TFhirDevice) then
    composeDevice(json, name, TFhirDevice(base), false)
  else if (base is TFhirDeviceComponentProductionSpecification) then
    composeDeviceComponentProductionSpecification(json, name, TFhirDeviceComponentProductionSpecification(base), false)
  else if (base is TFhirDeviceComponent) then
    composeDeviceComponent(json, name, TFhirDeviceComponent(base), false)
  else if (base is TFhirDeviceMetricCalibration) then
    composeDeviceMetricCalibration(json, name, TFhirDeviceMetricCalibration(base), false)
  else if (base is TFhirDeviceMetric) then
    composeDeviceMetric(json, name, TFhirDeviceMetric(base), false)
  else if (base is TFhirDeviceUseRequest) then
    composeDeviceUseRequest(json, name, TFhirDeviceUseRequest(base), false)
  else if (base is TFhirDeviceUseStatement) then
    composeDeviceUseStatement(json, name, TFhirDeviceUseStatement(base), false)
  else if (base is TFhirDiagnosticOrderEvent) then
    composeDiagnosticOrderEvent(json, name, TFhirDiagnosticOrderEvent(base), false)
  else if (base is TFhirDiagnosticOrderItem) then
    composeDiagnosticOrderItem(json, name, TFhirDiagnosticOrderItem(base), false)
  else if (base is TFhirDiagnosticOrder) then
    composeDiagnosticOrder(json, name, TFhirDiagnosticOrder(base), false)
  else if (base is TFhirDiagnosticReportImage) then
    composeDiagnosticReportImage(json, name, TFhirDiagnosticReportImage(base), false)
  else if (base is TFhirDiagnosticReport) then
    composeDiagnosticReport(json, name, TFhirDiagnosticReport(base), false)
  else if (base is TFhirDocumentManifestContent) then
    composeDocumentManifestContent(json, name, TFhirDocumentManifestContent(base), false)
  else if (base is TFhirDocumentManifestRelated) then
    composeDocumentManifestRelated(json, name, TFhirDocumentManifestRelated(base), false)
  else if (base is TFhirDocumentManifest) then
    composeDocumentManifest(json, name, TFhirDocumentManifest(base), false)
  else if (base is TFhirDocumentReferenceRelatesTo) then
    composeDocumentReferenceRelatesTo(json, name, TFhirDocumentReferenceRelatesTo(base), false)
  else if (base is TFhirDocumentReferenceContent) then
    composeDocumentReferenceContent(json, name, TFhirDocumentReferenceContent(base), false)
  else if (base is TFhirDocumentReferenceContext) then
    composeDocumentReferenceContext(json, name, TFhirDocumentReferenceContext(base), false)
  else if (base is TFhirDocumentReferenceContextRelated) then
    composeDocumentReferenceContextRelated(json, name, TFhirDocumentReferenceContextRelated(base), false)
  else if (base is TFhirDocumentReference) then
    composeDocumentReference(json, name, TFhirDocumentReference(base), false)
  else if (base is TFhirEligibilityRequest) then
    composeEligibilityRequest(json, name, TFhirEligibilityRequest(base), false)
  else if (base is TFhirEligibilityResponse) then
    composeEligibilityResponse(json, name, TFhirEligibilityResponse(base), false)
  else if (base is TFhirEncounterStatusHistory) then
    composeEncounterStatusHistory(json, name, TFhirEncounterStatusHistory(base), false)
  else if (base is TFhirEncounterParticipant) then
    composeEncounterParticipant(json, name, TFhirEncounterParticipant(base), false)
  else if (base is TFhirEncounterHospitalization) then
    composeEncounterHospitalization(json, name, TFhirEncounterHospitalization(base), false)
  else if (base is TFhirEncounterLocation) then
    composeEncounterLocation(json, name, TFhirEncounterLocation(base), false)
  else if (base is TFhirEncounter) then
    composeEncounter(json, name, TFhirEncounter(base), false)
  else if (base is TFhirEnrollmentRequest) then
    composeEnrollmentRequest(json, name, TFhirEnrollmentRequest(base), false)
  else if (base is TFhirEnrollmentResponse) then
    composeEnrollmentResponse(json, name, TFhirEnrollmentResponse(base), false)
  else if (base is TFhirEpisodeOfCareStatusHistory) then
    composeEpisodeOfCareStatusHistory(json, name, TFhirEpisodeOfCareStatusHistory(base), false)
  else if (base is TFhirEpisodeOfCareCareTeam) then
    composeEpisodeOfCareCareTeam(json, name, TFhirEpisodeOfCareCareTeam(base), false)
  else if (base is TFhirEpisodeOfCare) then
    composeEpisodeOfCare(json, name, TFhirEpisodeOfCare(base), false)
  else if (base is TFhirExplanationOfBenefit) then
    composeExplanationOfBenefit(json, name, TFhirExplanationOfBenefit(base), false)
  else if (base is TFhirFamilyMemberHistoryCondition) then
    composeFamilyMemberHistoryCondition(json, name, TFhirFamilyMemberHistoryCondition(base), false)
  else if (base is TFhirFamilyMemberHistory) then
    composeFamilyMemberHistory(json, name, TFhirFamilyMemberHistory(base), false)
  else if (base is TFhirFlag) then
    composeFlag(json, name, TFhirFlag(base), false)
  else if (base is TFhirGoalOutcome) then
    composeGoalOutcome(json, name, TFhirGoalOutcome(base), false)
  else if (base is TFhirGoal) then
    composeGoal(json, name, TFhirGoal(base), false)
  else if (base is TFhirGroupCharacteristic) then
    composeGroupCharacteristic(json, name, TFhirGroupCharacteristic(base), false)
  else if (base is TFhirGroupMember) then
    composeGroupMember(json, name, TFhirGroupMember(base), false)
  else if (base is TFhirGroup) then
    composeGroup(json, name, TFhirGroup(base), false)
  else if (base is TFhirHealthcareServiceServiceType) then
    composeHealthcareServiceServiceType(json, name, TFhirHealthcareServiceServiceType(base), false)
  else if (base is TFhirHealthcareServiceAvailableTime) then
    composeHealthcareServiceAvailableTime(json, name, TFhirHealthcareServiceAvailableTime(base), false)
  else if (base is TFhirHealthcareServiceNotAvailable) then
    composeHealthcareServiceNotAvailable(json, name, TFhirHealthcareServiceNotAvailable(base), false)
  else if (base is TFhirHealthcareService) then
    composeHealthcareService(json, name, TFhirHealthcareService(base), false)
  else if (base is TFhirImagingObjectSelectionStudy) then
    composeImagingObjectSelectionStudy(json, name, TFhirImagingObjectSelectionStudy(base), false)
  else if (base is TFhirImagingObjectSelectionStudySeries) then
    composeImagingObjectSelectionStudySeries(json, name, TFhirImagingObjectSelectionStudySeries(base), false)
  else if (base is TFhirImagingObjectSelectionStudySeriesInstance) then
    composeImagingObjectSelectionStudySeriesInstance(json, name, TFhirImagingObjectSelectionStudySeriesInstance(base), false)
  else if (base is TFhirImagingObjectSelectionStudySeriesInstanceFrames) then
    composeImagingObjectSelectionStudySeriesInstanceFrames(json, name, TFhirImagingObjectSelectionStudySeriesInstanceFrames(base), false)
  else if (base is TFhirImagingObjectSelection) then
    composeImagingObjectSelection(json, name, TFhirImagingObjectSelection(base), false)
  else if (base is TFhirImagingStudySeries) then
    composeImagingStudySeries(json, name, TFhirImagingStudySeries(base), false)
  else if (base is TFhirImagingStudySeriesInstance) then
    composeImagingStudySeriesInstance(json, name, TFhirImagingStudySeriesInstance(base), false)
  else if (base is TFhirImagingStudy) then
    composeImagingStudy(json, name, TFhirImagingStudy(base), false)
  else if (base is TFhirImmunizationExplanation) then
    composeImmunizationExplanation(json, name, TFhirImmunizationExplanation(base), false)
  else if (base is TFhirImmunizationReaction) then
    composeImmunizationReaction(json, name, TFhirImmunizationReaction(base), false)
  else if (base is TFhirImmunizationVaccinationProtocol) then
    composeImmunizationVaccinationProtocol(json, name, TFhirImmunizationVaccinationProtocol(base), false)
  else if (base is TFhirImmunization) then
    composeImmunization(json, name, TFhirImmunization(base), false)
  else if (base is TFhirImmunizationRecommendationRecommendation) then
    composeImmunizationRecommendationRecommendation(json, name, TFhirImmunizationRecommendationRecommendation(base), false)
  else if (base is TFhirImmunizationRecommendationRecommendationDateCriterion) then
    composeImmunizationRecommendationRecommendationDateCriterion(json, name, TFhirImmunizationRecommendationRecommendationDateCriterion(base), false)
  else if (base is TFhirImmunizationRecommendationRecommendationProtocol) then
    composeImmunizationRecommendationRecommendationProtocol(json, name, TFhirImmunizationRecommendationRecommendationProtocol(base), false)
  else if (base is TFhirImmunizationRecommendation) then
    composeImmunizationRecommendation(json, name, TFhirImmunizationRecommendation(base), false)
  else if (base is TFhirImplementationGuideContact) then
    composeImplementationGuideContact(json, name, TFhirImplementationGuideContact(base), false)
  else if (base is TFhirImplementationGuideDependency) then
    composeImplementationGuideDependency(json, name, TFhirImplementationGuideDependency(base), false)
  else if (base is TFhirImplementationGuidePackage) then
    composeImplementationGuidePackage(json, name, TFhirImplementationGuidePackage(base), false)
  else if (base is TFhirImplementationGuidePackageResource) then
    composeImplementationGuidePackageResource(json, name, TFhirImplementationGuidePackageResource(base), false)
  else if (base is TFhirImplementationGuideGlobal) then
    composeImplementationGuideGlobal(json, name, TFhirImplementationGuideGlobal(base), false)
  else if (base is TFhirImplementationGuidePage) then
    composeImplementationGuidePage(json, name, TFhirImplementationGuidePage(base), false)
  else if (base is TFhirImplementationGuide) then
    composeImplementationGuide(json, name, TFhirImplementationGuide(base), false)
  else if (base is TFhirListEntry) then
    composeListEntry(json, name, TFhirListEntry(base), false)
  else if (base is TFhirList) then
    composeList(json, name, TFhirList(base), false)
  else if (base is TFhirLocationPosition) then
    composeLocationPosition(json, name, TFhirLocationPosition(base), false)
  else if (base is TFhirLocation) then
    composeLocation(json, name, TFhirLocation(base), false)
  else if (base is TFhirMedia) then
    composeMedia(json, name, TFhirMedia(base), false)
  else if (base is TFhirMedicationProduct) then
    composeMedicationProduct(json, name, TFhirMedicationProduct(base), false)
  else if (base is TFhirMedicationProductIngredient) then
    composeMedicationProductIngredient(json, name, TFhirMedicationProductIngredient(base), false)
  else if (base is TFhirMedicationProductBatch) then
    composeMedicationProductBatch(json, name, TFhirMedicationProductBatch(base), false)
  else if (base is TFhirMedicationPackage) then
    composeMedicationPackage(json, name, TFhirMedicationPackage(base), false)
  else if (base is TFhirMedicationPackageContent) then
    composeMedicationPackageContent(json, name, TFhirMedicationPackageContent(base), false)
  else if (base is TFhirMedication) then
    composeMedication(json, name, TFhirMedication(base), false)
  else if (base is TFhirMedicationAdministrationDosage) then
    composeMedicationAdministrationDosage(json, name, TFhirMedicationAdministrationDosage(base), false)
  else if (base is TFhirMedicationAdministration) then
    composeMedicationAdministration(json, name, TFhirMedicationAdministration(base), false)
  else if (base is TFhirMedicationDispenseDosageInstruction) then
    composeMedicationDispenseDosageInstruction(json, name, TFhirMedicationDispenseDosageInstruction(base), false)
  else if (base is TFhirMedicationDispenseSubstitution) then
    composeMedicationDispenseSubstitution(json, name, TFhirMedicationDispenseSubstitution(base), false)
  else if (base is TFhirMedicationDispense) then
    composeMedicationDispense(json, name, TFhirMedicationDispense(base), false)
  else if (base is TFhirMedicationOrderDosageInstruction) then
    composeMedicationOrderDosageInstruction(json, name, TFhirMedicationOrderDosageInstruction(base), false)
  else if (base is TFhirMedicationOrderDispenseRequest) then
    composeMedicationOrderDispenseRequest(json, name, TFhirMedicationOrderDispenseRequest(base), false)
  else if (base is TFhirMedicationOrderSubstitution) then
    composeMedicationOrderSubstitution(json, name, TFhirMedicationOrderSubstitution(base), false)
  else if (base is TFhirMedicationOrder) then
    composeMedicationOrder(json, name, TFhirMedicationOrder(base), false)
  else if (base is TFhirMedicationStatementDosage) then
    composeMedicationStatementDosage(json, name, TFhirMedicationStatementDosage(base), false)
  else if (base is TFhirMedicationStatement) then
    composeMedicationStatement(json, name, TFhirMedicationStatement(base), false)
  else if (base is TFhirMessageHeaderResponse) then
    composeMessageHeaderResponse(json, name, TFhirMessageHeaderResponse(base), false)
  else if (base is TFhirMessageHeaderSource) then
    composeMessageHeaderSource(json, name, TFhirMessageHeaderSource(base), false)
  else if (base is TFhirMessageHeaderDestination) then
    composeMessageHeaderDestination(json, name, TFhirMessageHeaderDestination(base), false)
  else if (base is TFhirMessageHeader) then
    composeMessageHeader(json, name, TFhirMessageHeader(base), false)
  else if (base is TFhirNamingSystemContact) then
    composeNamingSystemContact(json, name, TFhirNamingSystemContact(base), false)
  else if (base is TFhirNamingSystemUniqueId) then
    composeNamingSystemUniqueId(json, name, TFhirNamingSystemUniqueId(base), false)
  else if (base is TFhirNamingSystem) then
    composeNamingSystem(json, name, TFhirNamingSystem(base), false)
  else if (base is TFhirNutritionOrderOralDiet) then
    composeNutritionOrderOralDiet(json, name, TFhirNutritionOrderOralDiet(base), false)
  else if (base is TFhirNutritionOrderOralDietNutrient) then
    composeNutritionOrderOralDietNutrient(json, name, TFhirNutritionOrderOralDietNutrient(base), false)
  else if (base is TFhirNutritionOrderOralDietTexture) then
    composeNutritionOrderOralDietTexture(json, name, TFhirNutritionOrderOralDietTexture(base), false)
  else if (base is TFhirNutritionOrderSupplement) then
    composeNutritionOrderSupplement(json, name, TFhirNutritionOrderSupplement(base), false)
  else if (base is TFhirNutritionOrderEnteralFormula) then
    composeNutritionOrderEnteralFormula(json, name, TFhirNutritionOrderEnteralFormula(base), false)
  else if (base is TFhirNutritionOrderEnteralFormulaAdministration) then
    composeNutritionOrderEnteralFormulaAdministration(json, name, TFhirNutritionOrderEnteralFormulaAdministration(base), false)
  else if (base is TFhirNutritionOrder) then
    composeNutritionOrder(json, name, TFhirNutritionOrder(base), false)
  else if (base is TFhirObservationReferenceRange) then
    composeObservationReferenceRange(json, name, TFhirObservationReferenceRange(base), false)
  else if (base is TFhirObservationRelated) then
    composeObservationRelated(json, name, TFhirObservationRelated(base), false)
  else if (base is TFhirObservationComponent) then
    composeObservationComponent(json, name, TFhirObservationComponent(base), false)
  else if (base is TFhirObservation) then
    composeObservation(json, name, TFhirObservation(base), false)
  else if (base is TFhirOperationDefinitionContact) then
    composeOperationDefinitionContact(json, name, TFhirOperationDefinitionContact(base), false)
  else if (base is TFhirOperationDefinitionParameter) then
    composeOperationDefinitionParameter(json, name, TFhirOperationDefinitionParameter(base), false)
  else if (base is TFhirOperationDefinitionParameterBinding) then
    composeOperationDefinitionParameterBinding(json, name, TFhirOperationDefinitionParameterBinding(base), false)
  else if (base is TFhirOperationDefinition) then
    composeOperationDefinition(json, name, TFhirOperationDefinition(base), false)
  else if (base is TFhirOperationOutcomeIssue) then
    composeOperationOutcomeIssue(json, name, TFhirOperationOutcomeIssue(base), false)
  else if (base is TFhirOperationOutcome) then
    composeOperationOutcome(json, name, TFhirOperationOutcome(base), false)
  else if (base is TFhirOrderWhen) then
    composeOrderWhen(json, name, TFhirOrderWhen(base), false)
  else if (base is TFhirOrder) then
    composeOrder(json, name, TFhirOrder(base), false)
  else if (base is TFhirOrderResponse) then
    composeOrderResponse(json, name, TFhirOrderResponse(base), false)
  else if (base is TFhirOrganizationContact) then
    composeOrganizationContact(json, name, TFhirOrganizationContact(base), false)
  else if (base is TFhirOrganization) then
    composeOrganization(json, name, TFhirOrganization(base), false)
  else if (base is TFhirPatientContact) then
    composePatientContact(json, name, TFhirPatientContact(base), false)
  else if (base is TFhirPatientAnimal) then
    composePatientAnimal(json, name, TFhirPatientAnimal(base), false)
  else if (base is TFhirPatientCommunication) then
    composePatientCommunication(json, name, TFhirPatientCommunication(base), false)
  else if (base is TFhirPatientLink) then
    composePatientLink(json, name, TFhirPatientLink(base), false)
  else if (base is TFhirPatient) then
    composePatient(json, name, TFhirPatient(base), false)
  else if (base is TFhirPaymentNotice) then
    composePaymentNotice(json, name, TFhirPaymentNotice(base), false)
  else if (base is TFhirPaymentReconciliationDetail) then
    composePaymentReconciliationDetail(json, name, TFhirPaymentReconciliationDetail(base), false)
  else if (base is TFhirPaymentReconciliationNote) then
    composePaymentReconciliationNote(json, name, TFhirPaymentReconciliationNote(base), false)
  else if (base is TFhirPaymentReconciliation) then
    composePaymentReconciliation(json, name, TFhirPaymentReconciliation(base), false)
  else if (base is TFhirPersonLink) then
    composePersonLink(json, name, TFhirPersonLink(base), false)
  else if (base is TFhirPerson) then
    composePerson(json, name, TFhirPerson(base), false)
  else if (base is TFhirPractitionerPractitionerRole) then
    composePractitionerPractitionerRole(json, name, TFhirPractitionerPractitionerRole(base), false)
  else if (base is TFhirPractitionerQualification) then
    composePractitionerQualification(json, name, TFhirPractitionerQualification(base), false)
  else if (base is TFhirPractitioner) then
    composePractitioner(json, name, TFhirPractitioner(base), false)
  else if (base is TFhirProcedurePerformer) then
    composeProcedurePerformer(json, name, TFhirProcedurePerformer(base), false)
  else if (base is TFhirProcedureFocalDevice) then
    composeProcedureFocalDevice(json, name, TFhirProcedureFocalDevice(base), false)
  else if (base is TFhirProcedure) then
    composeProcedure(json, name, TFhirProcedure(base), false)
  else if (base is TFhirProcedureRequest) then
    composeProcedureRequest(json, name, TFhirProcedureRequest(base), false)
  else if (base is TFhirProcessRequestItem) then
    composeProcessRequestItem(json, name, TFhirProcessRequestItem(base), false)
  else if (base is TFhirProcessRequest) then
    composeProcessRequest(json, name, TFhirProcessRequest(base), false)
  else if (base is TFhirProcessResponseNotes) then
    composeProcessResponseNotes(json, name, TFhirProcessResponseNotes(base), false)
  else if (base is TFhirProcessResponse) then
    composeProcessResponse(json, name, TFhirProcessResponse(base), false)
  else if (base is TFhirProvenanceAgent) then
    composeProvenanceAgent(json, name, TFhirProvenanceAgent(base), false)
  else if (base is TFhirProvenanceAgentRelatedAgent) then
    composeProvenanceAgentRelatedAgent(json, name, TFhirProvenanceAgentRelatedAgent(base), false)
  else if (base is TFhirProvenanceEntity) then
    composeProvenanceEntity(json, name, TFhirProvenanceEntity(base), false)
  else if (base is TFhirProvenance) then
    composeProvenance(json, name, TFhirProvenance(base), false)
  else if (base is TFhirQuestionnaireGroup) then
    composeQuestionnaireGroup(json, name, TFhirQuestionnaireGroup(base), false)
  else if (base is TFhirQuestionnaireGroupQuestion) then
    composeQuestionnaireGroupQuestion(json, name, TFhirQuestionnaireGroupQuestion(base), false)
  else if (base is TFhirQuestionnaire) then
    composeQuestionnaire(json, name, TFhirQuestionnaire(base), false)
  else if (base is TFhirQuestionnaireResponseGroup) then
    composeQuestionnaireResponseGroup(json, name, TFhirQuestionnaireResponseGroup(base), false)
  else if (base is TFhirQuestionnaireResponseGroupQuestion) then
    composeQuestionnaireResponseGroupQuestion(json, name, TFhirQuestionnaireResponseGroupQuestion(base), false)
  else if (base is TFhirQuestionnaireResponseGroupQuestionAnswer) then
    composeQuestionnaireResponseGroupQuestionAnswer(json, name, TFhirQuestionnaireResponseGroupQuestionAnswer(base), false)
  else if (base is TFhirQuestionnaireResponse) then
    composeQuestionnaireResponse(json, name, TFhirQuestionnaireResponse(base), false)
  else if (base is TFhirReferralRequest) then
    composeReferralRequest(json, name, TFhirReferralRequest(base), false)
  else if (base is TFhirRelatedPerson) then
    composeRelatedPerson(json, name, TFhirRelatedPerson(base), false)
  else if (base is TFhirRiskAssessmentPrediction) then
    composeRiskAssessmentPrediction(json, name, TFhirRiskAssessmentPrediction(base), false)
  else if (base is TFhirRiskAssessment) then
    composeRiskAssessment(json, name, TFhirRiskAssessment(base), false)
  else if (base is TFhirSchedule) then
    composeSchedule(json, name, TFhirSchedule(base), false)
  else if (base is TFhirSearchParameterContact) then
    composeSearchParameterContact(json, name, TFhirSearchParameterContact(base), false)
  else if (base is TFhirSearchParameter) then
    composeSearchParameter(json, name, TFhirSearchParameter(base), false)
  else if (base is TFhirSlot) then
    composeSlot(json, name, TFhirSlot(base), false)
  else if (base is TFhirSpecimenCollection) then
    composeSpecimenCollection(json, name, TFhirSpecimenCollection(base), false)
  else if (base is TFhirSpecimenTreatment) then
    composeSpecimenTreatment(json, name, TFhirSpecimenTreatment(base), false)
  else if (base is TFhirSpecimenContainer) then
    composeSpecimenContainer(json, name, TFhirSpecimenContainer(base), false)
  else if (base is TFhirSpecimen) then
    composeSpecimen(json, name, TFhirSpecimen(base), false)
  else if (base is TFhirStructureDefinitionContact) then
    composeStructureDefinitionContact(json, name, TFhirStructureDefinitionContact(base), false)
  else if (base is TFhirStructureDefinitionMapping) then
    composeStructureDefinitionMapping(json, name, TFhirStructureDefinitionMapping(base), false)
  else if (base is TFhirStructureDefinitionSnapshot) then
    composeStructureDefinitionSnapshot(json, name, TFhirStructureDefinitionSnapshot(base), false)
  else if (base is TFhirStructureDefinitionDifferential) then
    composeStructureDefinitionDifferential(json, name, TFhirStructureDefinitionDifferential(base), false)
  else if (base is TFhirStructureDefinition) then
    composeStructureDefinition(json, name, TFhirStructureDefinition(base), false)
  else if (base is TFhirSubscriptionChannel) then
    composeSubscriptionChannel(json, name, TFhirSubscriptionChannel(base), false)
  else if (base is TFhirSubscription) then
    composeSubscription(json, name, TFhirSubscription(base), false)
  else if (base is TFhirSubstanceInstance) then
    composeSubstanceInstance(json, name, TFhirSubstanceInstance(base), false)
  else if (base is TFhirSubstanceIngredient) then
    composeSubstanceIngredient(json, name, TFhirSubstanceIngredient(base), false)
  else if (base is TFhirSubstance) then
    composeSubstance(json, name, TFhirSubstance(base), false)
  else if (base is TFhirSupplyDelivery) then
    composeSupplyDelivery(json, name, TFhirSupplyDelivery(base), false)
  else if (base is TFhirSupplyRequestWhen) then
    composeSupplyRequestWhen(json, name, TFhirSupplyRequestWhen(base), false)
  else if (base is TFhirSupplyRequest) then
    composeSupplyRequest(json, name, TFhirSupplyRequest(base), false)
  else if (base is TFhirTestScriptContact) then
    composeTestScriptContact(json, name, TFhirTestScriptContact(base), false)
  else if (base is TFhirTestScriptMetadata) then
    composeTestScriptMetadata(json, name, TFhirTestScriptMetadata(base), false)
  else if (base is TFhirTestScriptMetadataLink) then
    composeTestScriptMetadataLink(json, name, TFhirTestScriptMetadataLink(base), false)
  else if (base is TFhirTestScriptMetadataCapability) then
    composeTestScriptMetadataCapability(json, name, TFhirTestScriptMetadataCapability(base), false)
  else if (base is TFhirTestScriptFixture) then
    composeTestScriptFixture(json, name, TFhirTestScriptFixture(base), false)
  else if (base is TFhirTestScriptVariable) then
    composeTestScriptVariable(json, name, TFhirTestScriptVariable(base), false)
  else if (base is TFhirTestScriptSetup) then
    composeTestScriptSetup(json, name, TFhirTestScriptSetup(base), false)
  else if (base is TFhirTestScriptSetupAction) then
    composeTestScriptSetupAction(json, name, TFhirTestScriptSetupAction(base), false)
  else if (base is TFhirTestScriptSetupActionOperation) then
    composeTestScriptSetupActionOperation(json, name, TFhirTestScriptSetupActionOperation(base), false)
  else if (base is TFhirTestScriptSetupActionOperationRequestHeader) then
    composeTestScriptSetupActionOperationRequestHeader(json, name, TFhirTestScriptSetupActionOperationRequestHeader(base), false)
  else if (base is TFhirTestScriptSetupActionAssert) then
    composeTestScriptSetupActionAssert(json, name, TFhirTestScriptSetupActionAssert(base), false)
  else if (base is TFhirTestScriptTest) then
    composeTestScriptTest(json, name, TFhirTestScriptTest(base), false)
  else if (base is TFhirTestScriptTestAction) then
    composeTestScriptTestAction(json, name, TFhirTestScriptTestAction(base), false)
  else if (base is TFhirTestScriptTeardown) then
    composeTestScriptTeardown(json, name, TFhirTestScriptTeardown(base), false)
  else if (base is TFhirTestScriptTeardownAction) then
    composeTestScriptTeardownAction(json, name, TFhirTestScriptTeardownAction(base), false)
  else if (base is TFhirTestScript) then
    composeTestScript(json, name, TFhirTestScript(base), false)
  else if (base is TFhirValueSetContact) then
    composeValueSetContact(json, name, TFhirValueSetContact(base), false)
  else if (base is TFhirValueSetCodeSystem) then
    composeValueSetCodeSystem(json, name, TFhirValueSetCodeSystem(base), false)
  else if (base is TFhirValueSetCodeSystemConcept) then
    composeValueSetCodeSystemConcept(json, name, TFhirValueSetCodeSystemConcept(base), false)
  else if (base is TFhirValueSetCodeSystemConceptDesignation) then
    composeValueSetCodeSystemConceptDesignation(json, name, TFhirValueSetCodeSystemConceptDesignation(base), false)
  else if (base is TFhirValueSetCompose) then
    composeValueSetCompose(json, name, TFhirValueSetCompose(base), false)
  else if (base is TFhirValueSetComposeInclude) then
    composeValueSetComposeInclude(json, name, TFhirValueSetComposeInclude(base), false)
  else if (base is TFhirValueSetComposeIncludeConcept) then
    composeValueSetComposeIncludeConcept(json, name, TFhirValueSetComposeIncludeConcept(base), false)
  else if (base is TFhirValueSetComposeIncludeFilter) then
    composeValueSetComposeIncludeFilter(json, name, TFhirValueSetComposeIncludeFilter(base), false)
  else if (base is TFhirValueSetExpansion) then
    composeValueSetExpansion(json, name, TFhirValueSetExpansion(base), false)
  else if (base is TFhirValueSetExpansionParameter) then
    composeValueSetExpansionParameter(json, name, TFhirValueSetExpansionParameter(base), false)
  else if (base is TFhirValueSetExpansionContains) then
    composeValueSetExpansionContains(json, name, TFhirValueSetExpansionContains(base), false)
  else if (base is TFhirValueSet) then
    composeValueSet(json, name, TFhirValueSet(base), false)
  else if (base is TFhirVisionPrescriptionDispense) then
    composeVisionPrescriptionDispense(json, name, TFhirVisionPrescriptionDispense(base), false)
  else if (base is TFhirVisionPrescription) then
    composeVisionPrescription(json, name, TFhirVisionPrescription(base), false)
  else
    raise Exception.create('Unknown Type '+base.className);
end;

procedure TFHIRJsonComposer.ComposeResource(json : TJSONWriter; resource: TFhirResource; links : TFhirBundleLinkList);
begin
  if (resource = nil) Then
    Raise Exception.Create('error - resource is nil');
  json.value('resourceType', CODES_TFhirResourceType[resource.ResourceType]);
  Case resource.ResourceType of
    frtParameters: ComposeParameters(json, 'Parameters', TFhirParameters(resource));
    frtAccount: ComposeAccount(json, 'Account', TFhirAccount(resource));
    frtAllergyIntolerance: ComposeAllergyIntolerance(json, 'AllergyIntolerance', TFhirAllergyIntolerance(resource));
    frtAppointment: ComposeAppointment(json, 'Appointment', TFhirAppointment(resource));
    frtAppointmentResponse: ComposeAppointmentResponse(json, 'AppointmentResponse', TFhirAppointmentResponse(resource));
    frtAuditEvent: ComposeAuditEvent(json, 'AuditEvent', TFhirAuditEvent(resource));
    frtBasic: ComposeBasic(json, 'Basic', TFhirBasic(resource));
    frtBinary: ComposeBinary(json, 'Binary', TFhirBinary(resource));
    frtBodySite: ComposeBodySite(json, 'BodySite', TFhirBodySite(resource));
    frtBundle: ComposeBundle(json, 'Bundle', TFhirBundle(resource));
    frtCarePlan: ComposeCarePlan(json, 'CarePlan', TFhirCarePlan(resource));
    frtClaim: ComposeClaim(json, 'Claim', TFhirClaim(resource));
    frtClaimResponse: ComposeClaimResponse(json, 'ClaimResponse', TFhirClaimResponse(resource));
    frtClinicalImpression: ComposeClinicalImpression(json, 'ClinicalImpression', TFhirClinicalImpression(resource));
    frtCommunication: ComposeCommunication(json, 'Communication', TFhirCommunication(resource));
    frtCommunicationRequest: ComposeCommunicationRequest(json, 'CommunicationRequest', TFhirCommunicationRequest(resource));
    frtComposition: ComposeComposition(json, 'Composition', TFhirComposition(resource));
    frtConceptMap: ComposeConceptMap(json, 'ConceptMap', TFhirConceptMap(resource));
    frtCondition: ComposeCondition(json, 'Condition', TFhirCondition(resource));
    frtConformance: ComposeConformance(json, 'Conformance', TFhirConformance(resource));
    frtContract: ComposeContract(json, 'Contract', TFhirContract(resource));
    frtCoverage: ComposeCoverage(json, 'Coverage', TFhirCoverage(resource));
    frtDataElement: ComposeDataElement(json, 'DataElement', TFhirDataElement(resource));
    frtDetectedIssue: ComposeDetectedIssue(json, 'DetectedIssue', TFhirDetectedIssue(resource));
    frtDevice: ComposeDevice(json, 'Device', TFhirDevice(resource));
    frtDeviceComponent: ComposeDeviceComponent(json, 'DeviceComponent', TFhirDeviceComponent(resource));
    frtDeviceMetric: ComposeDeviceMetric(json, 'DeviceMetric', TFhirDeviceMetric(resource));
    frtDeviceUseRequest: ComposeDeviceUseRequest(json, 'DeviceUseRequest', TFhirDeviceUseRequest(resource));
    frtDeviceUseStatement: ComposeDeviceUseStatement(json, 'DeviceUseStatement', TFhirDeviceUseStatement(resource));
    frtDiagnosticOrder: ComposeDiagnosticOrder(json, 'DiagnosticOrder', TFhirDiagnosticOrder(resource));
    frtDiagnosticReport: ComposeDiagnosticReport(json, 'DiagnosticReport', TFhirDiagnosticReport(resource));
    frtDocumentManifest: ComposeDocumentManifest(json, 'DocumentManifest', TFhirDocumentManifest(resource));
    frtDocumentReference: ComposeDocumentReference(json, 'DocumentReference', TFhirDocumentReference(resource));
    frtEligibilityRequest: ComposeEligibilityRequest(json, 'EligibilityRequest', TFhirEligibilityRequest(resource));
    frtEligibilityResponse: ComposeEligibilityResponse(json, 'EligibilityResponse', TFhirEligibilityResponse(resource));
    frtEncounter: ComposeEncounter(json, 'Encounter', TFhirEncounter(resource));
    frtEnrollmentRequest: ComposeEnrollmentRequest(json, 'EnrollmentRequest', TFhirEnrollmentRequest(resource));
    frtEnrollmentResponse: ComposeEnrollmentResponse(json, 'EnrollmentResponse', TFhirEnrollmentResponse(resource));
    frtEpisodeOfCare: ComposeEpisodeOfCare(json, 'EpisodeOfCare', TFhirEpisodeOfCare(resource));
    frtExplanationOfBenefit: ComposeExplanationOfBenefit(json, 'ExplanationOfBenefit', TFhirExplanationOfBenefit(resource));
    frtFamilyMemberHistory: ComposeFamilyMemberHistory(json, 'FamilyMemberHistory', TFhirFamilyMemberHistory(resource));
    frtFlag: ComposeFlag(json, 'Flag', TFhirFlag(resource));
    frtGoal: ComposeGoal(json, 'Goal', TFhirGoal(resource));
    frtGroup: ComposeGroup(json, 'Group', TFhirGroup(resource));
    frtHealthcareService: ComposeHealthcareService(json, 'HealthcareService', TFhirHealthcareService(resource));
    frtImagingObjectSelection: ComposeImagingObjectSelection(json, 'ImagingObjectSelection', TFhirImagingObjectSelection(resource));
    frtImagingStudy: ComposeImagingStudy(json, 'ImagingStudy', TFhirImagingStudy(resource));
    frtImmunization: ComposeImmunization(json, 'Immunization', TFhirImmunization(resource));
    frtImmunizationRecommendation: ComposeImmunizationRecommendation(json, 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource));
    frtImplementationGuide: ComposeImplementationGuide(json, 'ImplementationGuide', TFhirImplementationGuide(resource));
    frtList: ComposeList(json, 'List', TFhirList(resource));
    frtLocation: ComposeLocation(json, 'Location', TFhirLocation(resource));
    frtMedia: ComposeMedia(json, 'Media', TFhirMedia(resource));
    frtMedication: ComposeMedication(json, 'Medication', TFhirMedication(resource));
    frtMedicationAdministration: ComposeMedicationAdministration(json, 'MedicationAdministration', TFhirMedicationAdministration(resource));
    frtMedicationDispense: ComposeMedicationDispense(json, 'MedicationDispense', TFhirMedicationDispense(resource));
    frtMedicationOrder: ComposeMedicationOrder(json, 'MedicationOrder', TFhirMedicationOrder(resource));
    frtMedicationStatement: ComposeMedicationStatement(json, 'MedicationStatement', TFhirMedicationStatement(resource));
    frtMessageHeader: ComposeMessageHeader(json, 'MessageHeader', TFhirMessageHeader(resource));
    frtNamingSystem: ComposeNamingSystem(json, 'NamingSystem', TFhirNamingSystem(resource));
    frtNutritionOrder: ComposeNutritionOrder(json, 'NutritionOrder', TFhirNutritionOrder(resource));
    frtObservation: ComposeObservation(json, 'Observation', TFhirObservation(resource));
    frtOperationDefinition: ComposeOperationDefinition(json, 'OperationDefinition', TFhirOperationDefinition(resource));
    frtOperationOutcome: ComposeOperationOutcome(json, 'OperationOutcome', TFhirOperationOutcome(resource));
    frtOrder: ComposeOrder(json, 'Order', TFhirOrder(resource));
    frtOrderResponse: ComposeOrderResponse(json, 'OrderResponse', TFhirOrderResponse(resource));
    frtOrganization: ComposeOrganization(json, 'Organization', TFhirOrganization(resource));
    frtPatient: ComposePatient(json, 'Patient', TFhirPatient(resource));
    frtPaymentNotice: ComposePaymentNotice(json, 'PaymentNotice', TFhirPaymentNotice(resource));
    frtPaymentReconciliation: ComposePaymentReconciliation(json, 'PaymentReconciliation', TFhirPaymentReconciliation(resource));
    frtPerson: ComposePerson(json, 'Person', TFhirPerson(resource));
    frtPractitioner: ComposePractitioner(json, 'Practitioner', TFhirPractitioner(resource));
    frtProcedure: ComposeProcedure(json, 'Procedure', TFhirProcedure(resource));
    frtProcedureRequest: ComposeProcedureRequest(json, 'ProcedureRequest', TFhirProcedureRequest(resource));
    frtProcessRequest: ComposeProcessRequest(json, 'ProcessRequest', TFhirProcessRequest(resource));
    frtProcessResponse: ComposeProcessResponse(json, 'ProcessResponse', TFhirProcessResponse(resource));
    frtProvenance: ComposeProvenance(json, 'Provenance', TFhirProvenance(resource));
    frtQuestionnaire: ComposeQuestionnaire(json, 'Questionnaire', TFhirQuestionnaire(resource));
    frtQuestionnaireResponse: ComposeQuestionnaireResponse(json, 'QuestionnaireResponse', TFhirQuestionnaireResponse(resource));
    frtReferralRequest: ComposeReferralRequest(json, 'ReferralRequest', TFhirReferralRequest(resource));
    frtRelatedPerson: ComposeRelatedPerson(json, 'RelatedPerson', TFhirRelatedPerson(resource));
    frtRiskAssessment: ComposeRiskAssessment(json, 'RiskAssessment', TFhirRiskAssessment(resource));
    frtSchedule: ComposeSchedule(json, 'Schedule', TFhirSchedule(resource));
    frtSearchParameter: ComposeSearchParameter(json, 'SearchParameter', TFhirSearchParameter(resource));
    frtSlot: ComposeSlot(json, 'Slot', TFhirSlot(resource));
    frtSpecimen: ComposeSpecimen(json, 'Specimen', TFhirSpecimen(resource));
    frtStructureDefinition: ComposeStructureDefinition(json, 'StructureDefinition', TFhirStructureDefinition(resource));
    frtSubscription: ComposeSubscription(json, 'Subscription', TFhirSubscription(resource));
    frtSubstance: ComposeSubstance(json, 'Substance', TFhirSubstance(resource));
    frtSupplyDelivery: ComposeSupplyDelivery(json, 'SupplyDelivery', TFhirSupplyDelivery(resource));
    frtSupplyRequest: ComposeSupplyRequest(json, 'SupplyRequest', TFhirSupplyRequest(resource));
    frtTestScript: ComposeTestScript(json, 'TestScript', TFhirTestScript(resource));
    frtValueSet: ComposeValueSet(json, 'ValueSet', TFhirValueSet(resource));
    frtVisionPrescription: ComposeVisionPrescription(json, 'VisionPrescription', TFhirVisionPrescription(resource));
  else
    raise Exception.create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;

procedure TFHIRRDFComposer.ComposeResource(parent : TRDFComplex; resource : TFhirResource);
var
  this : TRDFComplex;
begin
  if (resource = nil) Then
    Raise Exception.Create('error - resource is nil');
  this := parent;
  Case resource.ResourceType of
    frtParameters: ComposeParameters(this, '', 'Parameters', TFhirParameters(resource), -1);
    frtAccount: ComposeAccount(this, '', 'Account', TFhirAccount(resource), -1);
    frtAllergyIntolerance: ComposeAllergyIntolerance(this, '', 'AllergyIntolerance', TFhirAllergyIntolerance(resource), -1);
    frtAppointment: ComposeAppointment(this, '', 'Appointment', TFhirAppointment(resource), -1);
    frtAppointmentResponse: ComposeAppointmentResponse(this, '', 'AppointmentResponse', TFhirAppointmentResponse(resource), -1);
    frtAuditEvent: ComposeAuditEvent(this, '', 'AuditEvent', TFhirAuditEvent(resource), -1);
    frtBasic: ComposeBasic(this, '', 'Basic', TFhirBasic(resource), -1);
    frtBinary: ComposeBinary(this, '', 'Binary', TFhirBinary(resource), -1);
    frtBodySite: ComposeBodySite(this, '', 'BodySite', TFhirBodySite(resource), -1);
    frtBundle: ComposeBundle(this, '', 'Bundle', TFhirBundle(resource), -1);
    frtCarePlan: ComposeCarePlan(this, '', 'CarePlan', TFhirCarePlan(resource), -1);
    frtClaim: ComposeClaim(this, '', 'Claim', TFhirClaim(resource), -1);
    frtClaimResponse: ComposeClaimResponse(this, '', 'ClaimResponse', TFhirClaimResponse(resource), -1);
    frtClinicalImpression: ComposeClinicalImpression(this, '', 'ClinicalImpression', TFhirClinicalImpression(resource), -1);
    frtCommunication: ComposeCommunication(this, '', 'Communication', TFhirCommunication(resource), -1);
    frtCommunicationRequest: ComposeCommunicationRequest(this, '', 'CommunicationRequest', TFhirCommunicationRequest(resource), -1);
    frtComposition: ComposeComposition(this, '', 'Composition', TFhirComposition(resource), -1);
    frtConceptMap: ComposeConceptMap(this, '', 'ConceptMap', TFhirConceptMap(resource), -1);
    frtCondition: ComposeCondition(this, '', 'Condition', TFhirCondition(resource), -1);
    frtConformance: ComposeConformance(this, '', 'Conformance', TFhirConformance(resource), -1);
    frtContract: ComposeContract(this, '', 'Contract', TFhirContract(resource), -1);
    frtCoverage: ComposeCoverage(this, '', 'Coverage', TFhirCoverage(resource), -1);
    frtDataElement: ComposeDataElement(this, '', 'DataElement', TFhirDataElement(resource), -1);
    frtDetectedIssue: ComposeDetectedIssue(this, '', 'DetectedIssue', TFhirDetectedIssue(resource), -1);
    frtDevice: ComposeDevice(this, '', 'Device', TFhirDevice(resource), -1);
    frtDeviceComponent: ComposeDeviceComponent(this, '', 'DeviceComponent', TFhirDeviceComponent(resource), -1);
    frtDeviceMetric: ComposeDeviceMetric(this, '', 'DeviceMetric', TFhirDeviceMetric(resource), -1);
    frtDeviceUseRequest: ComposeDeviceUseRequest(this, '', 'DeviceUseRequest', TFhirDeviceUseRequest(resource), -1);
    frtDeviceUseStatement: ComposeDeviceUseStatement(this, '', 'DeviceUseStatement', TFhirDeviceUseStatement(resource), -1);
    frtDiagnosticOrder: ComposeDiagnosticOrder(this, '', 'DiagnosticOrder', TFhirDiagnosticOrder(resource), -1);
    frtDiagnosticReport: ComposeDiagnosticReport(this, '', 'DiagnosticReport', TFhirDiagnosticReport(resource), -1);
    frtDocumentManifest: ComposeDocumentManifest(this, '', 'DocumentManifest', TFhirDocumentManifest(resource), -1);
    frtDocumentReference: ComposeDocumentReference(this, '', 'DocumentReference', TFhirDocumentReference(resource), -1);
    frtEligibilityRequest: ComposeEligibilityRequest(this, '', 'EligibilityRequest', TFhirEligibilityRequest(resource), -1);
    frtEligibilityResponse: ComposeEligibilityResponse(this, '', 'EligibilityResponse', TFhirEligibilityResponse(resource), -1);
    frtEncounter: ComposeEncounter(this, '', 'Encounter', TFhirEncounter(resource), -1);
    frtEnrollmentRequest: ComposeEnrollmentRequest(this, '', 'EnrollmentRequest', TFhirEnrollmentRequest(resource), -1);
    frtEnrollmentResponse: ComposeEnrollmentResponse(this, '', 'EnrollmentResponse', TFhirEnrollmentResponse(resource), -1);
    frtEpisodeOfCare: ComposeEpisodeOfCare(this, '', 'EpisodeOfCare', TFhirEpisodeOfCare(resource), -1);
    frtExplanationOfBenefit: ComposeExplanationOfBenefit(this, '', 'ExplanationOfBenefit', TFhirExplanationOfBenefit(resource), -1);
    frtFamilyMemberHistory: ComposeFamilyMemberHistory(this, '', 'FamilyMemberHistory', TFhirFamilyMemberHistory(resource), -1);
    frtFlag: ComposeFlag(this, '', 'Flag', TFhirFlag(resource), -1);
    frtGoal: ComposeGoal(this, '', 'Goal', TFhirGoal(resource), -1);
    frtGroup: ComposeGroup(this, '', 'Group', TFhirGroup(resource), -1);
    frtHealthcareService: ComposeHealthcareService(this, '', 'HealthcareService', TFhirHealthcareService(resource), -1);
    frtImagingObjectSelection: ComposeImagingObjectSelection(this, '', 'ImagingObjectSelection', TFhirImagingObjectSelection(resource), -1);
    frtImagingStudy: ComposeImagingStudy(this, '', 'ImagingStudy', TFhirImagingStudy(resource), -1);
    frtImmunization: ComposeImmunization(this, '', 'Immunization', TFhirImmunization(resource), -1);
    frtImmunizationRecommendation: ComposeImmunizationRecommendation(this, '', 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource), -1);
    frtImplementationGuide: ComposeImplementationGuide(this, '', 'ImplementationGuide', TFhirImplementationGuide(resource), -1);
    frtList: ComposeList(this, '', 'List', TFhirList(resource), -1);
    frtLocation: ComposeLocation(this, '', 'Location', TFhirLocation(resource), -1);
    frtMedia: ComposeMedia(this, '', 'Media', TFhirMedia(resource), -1);
    frtMedication: ComposeMedication(this, '', 'Medication', TFhirMedication(resource), -1);
    frtMedicationAdministration: ComposeMedicationAdministration(this, '', 'MedicationAdministration', TFhirMedicationAdministration(resource), -1);
    frtMedicationDispense: ComposeMedicationDispense(this, '', 'MedicationDispense', TFhirMedicationDispense(resource), -1);
    frtMedicationOrder: ComposeMedicationOrder(this, '', 'MedicationOrder', TFhirMedicationOrder(resource), -1);
    frtMedicationStatement: ComposeMedicationStatement(this, '', 'MedicationStatement', TFhirMedicationStatement(resource), -1);
    frtMessageHeader: ComposeMessageHeader(this, '', 'MessageHeader', TFhirMessageHeader(resource), -1);
    frtNamingSystem: ComposeNamingSystem(this, '', 'NamingSystem', TFhirNamingSystem(resource), -1);
    frtNutritionOrder: ComposeNutritionOrder(this, '', 'NutritionOrder', TFhirNutritionOrder(resource), -1);
    frtObservation: ComposeObservation(this, '', 'Observation', TFhirObservation(resource), -1);
    frtOperationDefinition: ComposeOperationDefinition(this, '', 'OperationDefinition', TFhirOperationDefinition(resource), -1);
    frtOperationOutcome: ComposeOperationOutcome(this, '', 'OperationOutcome', TFhirOperationOutcome(resource), -1);
    frtOrder: ComposeOrder(this, '', 'Order', TFhirOrder(resource), -1);
    frtOrderResponse: ComposeOrderResponse(this, '', 'OrderResponse', TFhirOrderResponse(resource), -1);
    frtOrganization: ComposeOrganization(this, '', 'Organization', TFhirOrganization(resource), -1);
    frtPatient: ComposePatient(this, '', 'Patient', TFhirPatient(resource), -1);
    frtPaymentNotice: ComposePaymentNotice(this, '', 'PaymentNotice', TFhirPaymentNotice(resource), -1);
    frtPaymentReconciliation: ComposePaymentReconciliation(this, '', 'PaymentReconciliation', TFhirPaymentReconciliation(resource), -1);
    frtPerson: ComposePerson(this, '', 'Person', TFhirPerson(resource), -1);
    frtPractitioner: ComposePractitioner(this, '', 'Practitioner', TFhirPractitioner(resource), -1);
    frtProcedure: ComposeProcedure(this, '', 'Procedure', TFhirProcedure(resource), -1);
    frtProcedureRequest: ComposeProcedureRequest(this, '', 'ProcedureRequest', TFhirProcedureRequest(resource), -1);
    frtProcessRequest: ComposeProcessRequest(this, '', 'ProcessRequest', TFhirProcessRequest(resource), -1);
    frtProcessResponse: ComposeProcessResponse(this, '', 'ProcessResponse', TFhirProcessResponse(resource), -1);
    frtProvenance: ComposeProvenance(this, '', 'Provenance', TFhirProvenance(resource), -1);
    frtQuestionnaire: ComposeQuestionnaire(this, '', 'Questionnaire', TFhirQuestionnaire(resource), -1);
    frtQuestionnaireResponse: ComposeQuestionnaireResponse(this, '', 'QuestionnaireResponse', TFhirQuestionnaireResponse(resource), -1);
    frtReferralRequest: ComposeReferralRequest(this, '', 'ReferralRequest', TFhirReferralRequest(resource), -1);
    frtRelatedPerson: ComposeRelatedPerson(this, '', 'RelatedPerson', TFhirRelatedPerson(resource), -1);
    frtRiskAssessment: ComposeRiskAssessment(this, '', 'RiskAssessment', TFhirRiskAssessment(resource), -1);
    frtSchedule: ComposeSchedule(this, '', 'Schedule', TFhirSchedule(resource), -1);
    frtSearchParameter: ComposeSearchParameter(this, '', 'SearchParameter', TFhirSearchParameter(resource), -1);
    frtSlot: ComposeSlot(this, '', 'Slot', TFhirSlot(resource), -1);
    frtSpecimen: ComposeSpecimen(this, '', 'Specimen', TFhirSpecimen(resource), -1);
    frtStructureDefinition: ComposeStructureDefinition(this, '', 'StructureDefinition', TFhirStructureDefinition(resource), -1);
    frtSubscription: ComposeSubscription(this, '', 'Subscription', TFhirSubscription(resource), -1);
    frtSubstance: ComposeSubstance(this, '', 'Substance', TFhirSubstance(resource), -1);
    frtSupplyDelivery: ComposeSupplyDelivery(this, '', 'SupplyDelivery', TFhirSupplyDelivery(resource), -1);
    frtSupplyRequest: ComposeSupplyRequest(this, '', 'SupplyRequest', TFhirSupplyRequest(resource), -1);
    frtTestScript: ComposeTestScript(this, '', 'TestScript', TFhirTestScript(resource), -1);
    frtValueSet: ComposeValueSet(this, '', 'ValueSet', TFhirValueSet(resource), -1);
    frtVisionPrescription: ComposeVisionPrescription(this, '', 'VisionPrescription', TFhirVisionPrescription(resource), -1);
  else
    raise Exception.create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;


end.

