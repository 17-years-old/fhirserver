unit FHIR.R2.Turtle;

{$I fhir.inc}

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

interface

// FHIR v1.0.2 generated 2015-10-24T07:41:03+11:00

uses
  SysUtils, Classes, FHIR.Support.Strings, FHIR.Support.DateTime, FHIR.Support.Decimal, FHIR.Base.Parser, FHIR.Base.Objects, FHIR.R2.ParserBase, FHIR.R2.Resources, FHIR.R2.Constants, FHIR.R2.Types, FHIR.Support.Collections, FHIR.Support.Turtle;

Type

  TFHIRTurtleParser = class (TFHIRTurtleParserBase2)
  protected
    function ParseElement(obj : TTurtleComplex) : TFhirElement; overload;

    procedure ParseElementProperties(obj : TTurtleComplex; element : TFhirElement);
    procedure ParseBackboneElementProperties(obj : TTurtleComplex; element : TFhirBackboneElement); overload;
    function ParseBackboneElement(obj : TTurtleComplex) : TFhirBackboneElement; overload;

    function ParseEnum(obj : TTurtleComplex; Const aNames, aSystems : Array Of String) : TFHIREnum; overload;
    function ParseDateTime(obj : TTurtleComplex) : TFHIRDateTime; overload;
    function ParseDate(obj : TTurtleComplex) : TFHIRDate; overload;
    function ParseString(obj : TTurtleComplex) : TFHIRString; overload;
    function ParseInteger(obj : TTurtleComplex) : TFHIRInteger; overload;
    function ParseUri(obj : TTurtleComplex) : TFHIRUri; overload;
    function ParseInstant(obj : TTurtleComplex) : TFHIRInstant; overload;
    function ParseBoolean(obj : TTurtleComplex) : TFHIRBoolean; overload;
    function ParseBase64Binary(obj : TTurtleComplex) : TFHIRBase64Binary; overload;
    function ParseTime(obj : TTurtleComplex) : TFHIRTime; overload;
    function ParseDecimal(obj : TTurtleComplex) : TFHIRDecimal; overload;
    function ParseCode(obj : TTurtleComplex) : TFHIRCode; overload;
    function ParseOid(obj : TTurtleComplex) : TFHIROid; overload;
    function ParseUuid(obj : TTurtleComplex) : TFHIRUuid; overload;
    function ParseMarkdown(obj : TTurtleComplex) : TFHIRMarkdown; overload;
    function ParseUnsignedInt(obj : TTurtleComplex) : TFHIRUnsignedInt; overload;
    function ParseId(obj : TTurtleComplex) : TFHIRId; overload;
    function ParsePositiveInt(obj : TTurtleComplex) : TFHIRPositiveInt; overload;

    procedure ParseResourceProperties(obj : TTurtleComplex; resource : TFhirResource);
{$IFDEF FHIR_PARAMETERS}
    function ParseParametersParameter(obj : TTurtleComplex) : TFhirParametersParameter; overload; {b\}
    procedure ParseParametersParameterProperties(obj : TTurtleComplex; result : TFhirParametersParameter); overload; {b\}
    function ParseParameters(obj : TTurtleComplex) : TFhirParameters; overload;
    procedure ParseParametersProperties(obj : TTurtleComplex; result : TFhirParameters); overload;
{$ENDIF FHIR_PARAMETERS}
    procedure ParseDomainResourceProperties(obj : TTurtleComplex; resource : TFhirDomainResource);

    function ParseExtension(obj : TTurtleComplex) : TFhirExtension; overload;
    procedure ParseExtensionProperties(obj : TTurtleComplex; result : TFhirExtension); overload;
    function ParseNarrative(obj : TTurtleComplex) : TFhirNarrative; overload;
    procedure ParseNarrativeProperties(obj : TTurtleComplex; result : TFhirNarrative); overload;
    function ParseIdentifier(obj : TTurtleComplex) : TFhirIdentifier; overload;
    procedure ParseIdentifierProperties(obj : TTurtleComplex; result : TFhirIdentifier); overload;
    function ParseCoding(obj : TTurtleComplex) : TFhirCoding; overload;
    procedure ParseCodingProperties(obj : TTurtleComplex; result : TFhirCoding); overload;
    function ParseReference(obj : TTurtleComplex) : TFhirReference; overload;
    procedure ParseReferenceProperties(obj : TTurtleComplex; result : TFhirReference); overload;
    function ParseSignature(obj : TTurtleComplex) : TFhirSignature; overload;
    procedure ParseSignatureProperties(obj : TTurtleComplex; result : TFhirSignature); overload;
    function ParseSampledData(obj : TTurtleComplex) : TFhirSampledData; overload;
    procedure ParseSampledDataProperties(obj : TTurtleComplex; result : TFhirSampledData); overload;
    function ParsePeriod(obj : TTurtleComplex) : TFhirPeriod; overload;
    procedure ParsePeriodProperties(obj : TTurtleComplex; result : TFhirPeriod); overload;
    function ParseQuantity(obj : TTurtleComplex) : TFhirQuantity; overload;
    procedure ParseQuantityProperties(obj : TTurtleComplex; result : TFhirQuantity); overload;
    function ParseAttachment(obj : TTurtleComplex) : TFhirAttachment; overload;
    procedure ParseAttachmentProperties(obj : TTurtleComplex; result : TFhirAttachment); overload;
    function ParseRatio(obj : TTurtleComplex) : TFhirRatio; overload;
    procedure ParseRatioProperties(obj : TTurtleComplex; result : TFhirRatio); overload;
    function ParseRange(obj : TTurtleComplex) : TFhirRange; overload;
    procedure ParseRangeProperties(obj : TTurtleComplex; result : TFhirRange); overload;
    function ParseAnnotation(obj : TTurtleComplex) : TFhirAnnotation; overload;
    procedure ParseAnnotationProperties(obj : TTurtleComplex; result : TFhirAnnotation); overload;
    function ParseCodeableConcept(obj : TTurtleComplex) : TFhirCodeableConcept; overload;
    procedure ParseCodeableConceptProperties(obj : TTurtleComplex; result : TFhirCodeableConcept); overload;
    function ParseHumanName(obj : TTurtleComplex) : TFhirHumanName; overload;
    procedure ParseHumanNameProperties(obj : TTurtleComplex; result : TFhirHumanName); overload;
    function ParseMeta(obj : TTurtleComplex) : TFhirMeta; overload;
    procedure ParseMetaProperties(obj : TTurtleComplex; result : TFhirMeta); overload;
    function ParseContactPoint(obj : TTurtleComplex) : TFhirContactPoint; overload;
    procedure ParseContactPointProperties(obj : TTurtleComplex; result : TFhirContactPoint); overload;
    function ParseAddress(obj : TTurtleComplex) : TFhirAddress; overload;
    procedure ParseAddressProperties(obj : TTurtleComplex; result : TFhirAddress); overload;
    function ParseElementDefinitionSlicing(obj : TTurtleComplex) : TFhirElementDefinitionSlicing; overload; {b\}
    procedure ParseElementDefinitionSlicingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionSlicing); overload; {b\}
    function ParseElementDefinitionBase(obj : TTurtleComplex) : TFhirElementDefinitionBase; overload; {b\}
    procedure ParseElementDefinitionBaseProperties(obj : TTurtleComplex; result : TFhirElementDefinitionBase); overload; {b\}
    function ParseElementDefinitionType(obj : TTurtleComplex) : TFhirElementDefinitionType; overload; {b\}
    procedure ParseElementDefinitionTypeProperties(obj : TTurtleComplex; result : TFhirElementDefinitionType); overload; {b\}
    function ParseElementDefinitionConstraint(obj : TTurtleComplex) : TFhirElementDefinitionConstraint; overload; {b\}
    procedure ParseElementDefinitionConstraintProperties(obj : TTurtleComplex; result : TFhirElementDefinitionConstraint); overload; {b\}
    function ParseElementDefinitionBinding(obj : TTurtleComplex) : TFhirElementDefinitionBinding; overload; {b\}
    procedure ParseElementDefinitionBindingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionBinding); overload; {b\}
    function ParseElementDefinitionMapping(obj : TTurtleComplex) : TFhirElementDefinitionMapping; overload; {b\}
    procedure ParseElementDefinitionMappingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionMapping); overload; {b\}
    function ParseElementDefinition(obj : TTurtleComplex) : TFhirElementDefinition; overload;
    procedure ParseElementDefinitionProperties(obj : TTurtleComplex; result : TFhirElementDefinition); overload;
    function ParseTimingRepeat(obj : TTurtleComplex) : TFhirTimingRepeat; overload; {b\}
    procedure ParseTimingRepeatProperties(obj : TTurtleComplex; result : TFhirTimingRepeat); overload; {b\}
    function ParseTiming(obj : TTurtleComplex) : TFhirTiming; overload;
    procedure ParseTimingProperties(obj : TTurtleComplex; result : TFhirTiming); overload;

{$IFDEF FHIR_ACCOUNT}
    function ParseAccount(obj : TTurtleComplex) : TFhirAccount; overload;
    procedure ParseAccountProperties(obj : TTurtleComplex; result : TFhirAccount); overload;
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    function ParseAllergyIntoleranceReaction(obj : TTurtleComplex) : TFhirAllergyIntoleranceReaction; overload; {b\}
    procedure ParseAllergyIntoleranceReactionProperties(obj : TTurtleComplex; result : TFhirAllergyIntoleranceReaction); overload; {b\}
    function ParseAllergyIntolerance(obj : TTurtleComplex) : TFhirAllergyIntolerance; overload;
    procedure ParseAllergyIntoleranceProperties(obj : TTurtleComplex; result : TFhirAllergyIntolerance); overload;
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    function ParseAppointmentParticipant(obj : TTurtleComplex) : TFhirAppointmentParticipant; overload; {b\}
    procedure ParseAppointmentParticipantProperties(obj : TTurtleComplex; result : TFhirAppointmentParticipant); overload; {b\}
    function ParseAppointment(obj : TTurtleComplex) : TFhirAppointment; overload;
    procedure ParseAppointmentProperties(obj : TTurtleComplex; result : TFhirAppointment); overload;
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    function ParseAppointmentResponse(obj : TTurtleComplex) : TFhirAppointmentResponse; overload;
    procedure ParseAppointmentResponseProperties(obj : TTurtleComplex; result : TFhirAppointmentResponse); overload;
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
    function ParseAuditEventEvent(obj : TTurtleComplex) : TFhirAuditEventEvent; overload; {b\}
    procedure ParseAuditEventEventProperties(obj : TTurtleComplex; result : TFhirAuditEventEvent); overload; {b\}
    function ParseAuditEventParticipant(obj : TTurtleComplex) : TFhirAuditEventParticipant; overload; {b\}
    procedure ParseAuditEventParticipantProperties(obj : TTurtleComplex; result : TFhirAuditEventParticipant); overload; {b\}
    function ParseAuditEventParticipantNetwork(obj : TTurtleComplex) : TFhirAuditEventParticipantNetwork; overload; {b\}
    procedure ParseAuditEventParticipantNetworkProperties(obj : TTurtleComplex; result : TFhirAuditEventParticipantNetwork); overload; {b\}
    function ParseAuditEventSource(obj : TTurtleComplex) : TFhirAuditEventSource; overload; {b\}
    procedure ParseAuditEventSourceProperties(obj : TTurtleComplex; result : TFhirAuditEventSource); overload; {b\}
    function ParseAuditEventObject(obj : TTurtleComplex) : TFhirAuditEventObject; overload; {b\}
    procedure ParseAuditEventObjectProperties(obj : TTurtleComplex; result : TFhirAuditEventObject); overload; {b\}
    function ParseAuditEventObjectDetail(obj : TTurtleComplex) : TFhirAuditEventObjectDetail; overload; {b\}
    procedure ParseAuditEventObjectDetailProperties(obj : TTurtleComplex; result : TFhirAuditEventObjectDetail); overload; {b\}
    function ParseAuditEvent(obj : TTurtleComplex) : TFhirAuditEvent; overload;
    procedure ParseAuditEventProperties(obj : TTurtleComplex; result : TFhirAuditEvent); overload;
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    function ParseBasic(obj : TTurtleComplex) : TFhirBasic; overload;
    procedure ParseBasicProperties(obj : TTurtleComplex; result : TFhirBasic); overload;
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    function ParseBinary(obj : TTurtleComplex) : TFhirBinary; overload;
    procedure ParseBinaryProperties(obj : TTurtleComplex; result : TFhirBinary); overload;
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
    function ParseBodySite(obj : TTurtleComplex) : TFhirBodySite; overload;
    procedure ParseBodySiteProperties(obj : TTurtleComplex; result : TFhirBodySite); overload;
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
    function ParseBundleLink(obj : TTurtleComplex) : TFhirBundleLink; overload; {b\}
    procedure ParseBundleLinkProperties(obj : TTurtleComplex; result : TFhirBundleLink); overload; {b\}
    function ParseBundleEntry(obj : TTurtleComplex) : TFhirBundleEntry; overload; {b\}
    procedure ParseBundleEntryProperties(obj : TTurtleComplex; result : TFhirBundleEntry); overload; {b\}
    function ParseBundleEntrySearch(obj : TTurtleComplex) : TFhirBundleEntrySearch; overload; {b\}
    procedure ParseBundleEntrySearchProperties(obj : TTurtleComplex; result : TFhirBundleEntrySearch); overload; {b\}
    function ParseBundleEntryRequest(obj : TTurtleComplex) : TFhirBundleEntryRequest; overload; {b\}
    procedure ParseBundleEntryRequestProperties(obj : TTurtleComplex; result : TFhirBundleEntryRequest); overload; {b\}
    function ParseBundleEntryResponse(obj : TTurtleComplex) : TFhirBundleEntryResponse; overload; {b\}
    procedure ParseBundleEntryResponseProperties(obj : TTurtleComplex; result : TFhirBundleEntryResponse); overload; {b\}
    function ParseBundle(obj : TTurtleComplex) : TFhirBundle; overload;
    procedure ParseBundleProperties(obj : TTurtleComplex; result : TFhirBundle); overload;
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
    function ParseCarePlanRelatedPlan(obj : TTurtleComplex) : TFhirCarePlanRelatedPlan; overload; {b\}
    procedure ParseCarePlanRelatedPlanProperties(obj : TTurtleComplex; result : TFhirCarePlanRelatedPlan); overload; {b\}
    function ParseCarePlanParticipant(obj : TTurtleComplex) : TFhirCarePlanParticipant; overload; {b\}
    procedure ParseCarePlanParticipantProperties(obj : TTurtleComplex; result : TFhirCarePlanParticipant); overload; {b\}
    function ParseCarePlanActivity(obj : TTurtleComplex) : TFhirCarePlanActivity; overload; {b\}
    procedure ParseCarePlanActivityProperties(obj : TTurtleComplex; result : TFhirCarePlanActivity); overload; {b\}
    function ParseCarePlanActivityDetail(obj : TTurtleComplex) : TFhirCarePlanActivityDetail; overload; {b\}
    procedure ParseCarePlanActivityDetailProperties(obj : TTurtleComplex; result : TFhirCarePlanActivityDetail); overload; {b\}
    function ParseCarePlan(obj : TTurtleComplex) : TFhirCarePlan; overload;
    procedure ParseCarePlanProperties(obj : TTurtleComplex; result : TFhirCarePlan); overload;
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
    function ParseClaimPayee(obj : TTurtleComplex) : TFhirClaimPayee; overload; {b\}
    procedure ParseClaimPayeeProperties(obj : TTurtleComplex; result : TFhirClaimPayee); overload; {b\}
    function ParseClaimDiagnosis(obj : TTurtleComplex) : TFhirClaimDiagnosis; overload; {b\}
    procedure ParseClaimDiagnosisProperties(obj : TTurtleComplex; result : TFhirClaimDiagnosis); overload; {b\}
    function ParseClaimCoverage(obj : TTurtleComplex) : TFhirClaimCoverage; overload; {b\}
    procedure ParseClaimCoverageProperties(obj : TTurtleComplex; result : TFhirClaimCoverage); overload; {b\}
    function ParseClaimItem(obj : TTurtleComplex) : TFhirClaimItem; overload; {b\}
    procedure ParseClaimItemProperties(obj : TTurtleComplex; result : TFhirClaimItem); overload; {b\}
    function ParseClaimItemDetail(obj : TTurtleComplex) : TFhirClaimItemDetail; overload; {b\}
    procedure ParseClaimItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimItemDetail); overload; {b\}
    function ParseClaimItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimItemDetailSubDetail; overload; {b\}
    procedure ParseClaimItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirClaimItemDetailSubDetail); overload; {b\}
    function ParseClaimItemProsthesis(obj : TTurtleComplex) : TFhirClaimItemProsthesis; overload; {b\}
    procedure ParseClaimItemProsthesisProperties(obj : TTurtleComplex; result : TFhirClaimItemProsthesis); overload; {b\}
    function ParseClaimMissingTeeth(obj : TTurtleComplex) : TFhirClaimMissingTeeth; overload; {b\}
    procedure ParseClaimMissingTeethProperties(obj : TTurtleComplex; result : TFhirClaimMissingTeeth); overload; {b\}
    function ParseClaim(obj : TTurtleComplex) : TFhirClaim; overload;
    procedure ParseClaimProperties(obj : TTurtleComplex; result : TFhirClaim); overload;
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    function ParseClaimResponseItem(obj : TTurtleComplex) : TFhirClaimResponseItem; overload; {b\}
    procedure ParseClaimResponseItemProperties(obj : TTurtleComplex; result : TFhirClaimResponseItem); overload; {b\}
    function ParseClaimResponseItemAdjudication(obj : TTurtleComplex) : TFhirClaimResponseItemAdjudication; overload; {b\}
    procedure ParseClaimResponseItemAdjudicationProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemAdjudication); overload; {b\}
    function ParseClaimResponseItemDetail(obj : TTurtleComplex) : TFhirClaimResponseItemDetail; overload; {b\}
    procedure ParseClaimResponseItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemDetail); overload; {b\}
    function ParseClaimResponseItemDetailAdjudication(obj : TTurtleComplex) : TFhirClaimResponseItemDetailAdjudication; overload; {b\}
    procedure ParseClaimResponseItemDetailAdjudicationProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemDetailAdjudication); overload; {b\}
    function ParseClaimResponseItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimResponseItemDetailSubDetail; overload; {b\}
    procedure ParseClaimResponseItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemDetailSubDetail); overload; {b\}
    function ParseClaimResponseItemDetailSubDetailAdjudication(obj : TTurtleComplex) : TFhirClaimResponseItemDetailSubDetailAdjudication; overload; {b\}
    procedure ParseClaimResponseItemDetailSubDetailAdjudicationProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemDetailSubDetailAdjudication); overload; {b\}
    function ParseClaimResponseAddItem(obj : TTurtleComplex) : TFhirClaimResponseAddItem; overload; {b\}
    procedure ParseClaimResponseAddItemProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItem); overload; {b\}
    function ParseClaimResponseAddItemAdjudication(obj : TTurtleComplex) : TFhirClaimResponseAddItemAdjudication; overload; {b\}
    procedure ParseClaimResponseAddItemAdjudicationProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItemAdjudication); overload; {b\}
    function ParseClaimResponseAddItemDetail(obj : TTurtleComplex) : TFhirClaimResponseAddItemDetail; overload; {b\}
    procedure ParseClaimResponseAddItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItemDetail); overload; {b\}
    function ParseClaimResponseAddItemDetailAdjudication(obj : TTurtleComplex) : TFhirClaimResponseAddItemDetailAdjudication; overload; {b\}
    procedure ParseClaimResponseAddItemDetailAdjudicationProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItemDetailAdjudication); overload; {b\}
    function ParseClaimResponseError(obj : TTurtleComplex) : TFhirClaimResponseError; overload; {b\}
    procedure ParseClaimResponseErrorProperties(obj : TTurtleComplex; result : TFhirClaimResponseError); overload; {b\}
    function ParseClaimResponseNote(obj : TTurtleComplex) : TFhirClaimResponseNote; overload; {b\}
    procedure ParseClaimResponseNoteProperties(obj : TTurtleComplex; result : TFhirClaimResponseNote); overload; {b\}
    function ParseClaimResponseCoverage(obj : TTurtleComplex) : TFhirClaimResponseCoverage; overload; {b\}
    procedure ParseClaimResponseCoverageProperties(obj : TTurtleComplex; result : TFhirClaimResponseCoverage); overload; {b\}
    function ParseClaimResponse(obj : TTurtleComplex) : TFhirClaimResponse; overload;
    procedure ParseClaimResponseProperties(obj : TTurtleComplex; result : TFhirClaimResponse); overload;
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    function ParseClinicalImpressionInvestigations(obj : TTurtleComplex) : TFhirClinicalImpressionInvestigations; overload; {b\}
    procedure ParseClinicalImpressionInvestigationsProperties(obj : TTurtleComplex; result : TFhirClinicalImpressionInvestigations); overload; {b\}
    function ParseClinicalImpressionFinding(obj : TTurtleComplex) : TFhirClinicalImpressionFinding; overload; {b\}
    procedure ParseClinicalImpressionFindingProperties(obj : TTurtleComplex; result : TFhirClinicalImpressionFinding); overload; {b\}
    function ParseClinicalImpressionRuledOut(obj : TTurtleComplex) : TFhirClinicalImpressionRuledOut; overload; {b\}
    procedure ParseClinicalImpressionRuledOutProperties(obj : TTurtleComplex; result : TFhirClinicalImpressionRuledOut); overload; {b\}
    function ParseClinicalImpression(obj : TTurtleComplex) : TFhirClinicalImpression; overload;
    procedure ParseClinicalImpressionProperties(obj : TTurtleComplex; result : TFhirClinicalImpression); overload;
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
    function ParseCommunicationPayload(obj : TTurtleComplex) : TFhirCommunicationPayload; overload; {b\}
    procedure ParseCommunicationPayloadProperties(obj : TTurtleComplex; result : TFhirCommunicationPayload); overload; {b\}
    function ParseCommunication(obj : TTurtleComplex) : TFhirCommunication; overload;
    procedure ParseCommunicationProperties(obj : TTurtleComplex; result : TFhirCommunication); overload;
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    function ParseCommunicationRequestPayload(obj : TTurtleComplex) : TFhirCommunicationRequestPayload; overload; {b\}
    procedure ParseCommunicationRequestPayloadProperties(obj : TTurtleComplex; result : TFhirCommunicationRequestPayload); overload; {b\}
    function ParseCommunicationRequest(obj : TTurtleComplex) : TFhirCommunicationRequest; overload;
    procedure ParseCommunicationRequestProperties(obj : TTurtleComplex; result : TFhirCommunicationRequest); overload;
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
    function ParseCompositionAttester(obj : TTurtleComplex) : TFhirCompositionAttester; overload; {b\}
    procedure ParseCompositionAttesterProperties(obj : TTurtleComplex; result : TFhirCompositionAttester); overload; {b\}
    function ParseCompositionEvent(obj : TTurtleComplex) : TFhirCompositionEvent; overload; {b\}
    procedure ParseCompositionEventProperties(obj : TTurtleComplex; result : TFhirCompositionEvent); overload; {b\}
    function ParseCompositionSection(obj : TTurtleComplex) : TFhirCompositionSection; overload; {b\}
    procedure ParseCompositionSectionProperties(obj : TTurtleComplex; result : TFhirCompositionSection); overload; {b\}
    function ParseComposition(obj : TTurtleComplex) : TFhirComposition; overload;
    procedure ParseCompositionProperties(obj : TTurtleComplex; result : TFhirComposition); overload;
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    function ParseConceptMapContact(obj : TTurtleComplex) : TFhirConceptMapContact; overload; {b\}
    procedure ParseConceptMapContactProperties(obj : TTurtleComplex; result : TFhirConceptMapContact); overload; {b\}
    function ParseConceptMapElement(obj : TTurtleComplex) : TFhirConceptMapElement; overload; {b\}
    procedure ParseConceptMapElementProperties(obj : TTurtleComplex; result : TFhirConceptMapElement); overload; {b\}
    function ParseConceptMapElementTarget(obj : TTurtleComplex) : TFhirConceptMapElementTarget; overload; {b\}
    procedure ParseConceptMapElementTargetProperties(obj : TTurtleComplex; result : TFhirConceptMapElementTarget); overload; {b\}
    function ParseConceptMapElementTargetDependsOn(obj : TTurtleComplex) : TFhirConceptMapElementTargetDependsOn; overload; {b\}
    procedure ParseConceptMapElementTargetDependsOnProperties(obj : TTurtleComplex; result : TFhirConceptMapElementTargetDependsOn); overload; {b\}
    function ParseConceptMap(obj : TTurtleComplex) : TFhirConceptMap; overload;
    procedure ParseConceptMapProperties(obj : TTurtleComplex; result : TFhirConceptMap); overload;
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    function ParseConditionStage(obj : TTurtleComplex) : TFhirConditionStage; overload; {b\}
    procedure ParseConditionStageProperties(obj : TTurtleComplex; result : TFhirConditionStage); overload; {b\}
    function ParseConditionEvidence(obj : TTurtleComplex) : TFhirConditionEvidence; overload; {b\}
    procedure ParseConditionEvidenceProperties(obj : TTurtleComplex; result : TFhirConditionEvidence); overload; {b\}
    function ParseCondition(obj : TTurtleComplex) : TFhirCondition; overload;
    procedure ParseConditionProperties(obj : TTurtleComplex; result : TFhirCondition); overload;
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
    function ParseConformanceContact(obj : TTurtleComplex) : TFhirConformanceContact; overload; {b\}
    procedure ParseConformanceContactProperties(obj : TTurtleComplex; result : TFhirConformanceContact); overload; {b\}
    function ParseConformanceSoftware(obj : TTurtleComplex) : TFhirConformanceSoftware; overload; {b\}
    procedure ParseConformanceSoftwareProperties(obj : TTurtleComplex; result : TFhirConformanceSoftware); overload; {b\}
    function ParseConformanceImplementation(obj : TTurtleComplex) : TFhirConformanceImplementation; overload; {b\}
    procedure ParseConformanceImplementationProperties(obj : TTurtleComplex; result : TFhirConformanceImplementation); overload; {b\}
    function ParseConformanceRest(obj : TTurtleComplex) : TFhirConformanceRest; overload; {b\}
    procedure ParseConformanceRestProperties(obj : TTurtleComplex; result : TFhirConformanceRest); overload; {b\}
    function ParseConformanceRestSecurity(obj : TTurtleComplex) : TFhirConformanceRestSecurity; overload; {b\}
    procedure ParseConformanceRestSecurityProperties(obj : TTurtleComplex; result : TFhirConformanceRestSecurity); overload; {b\}
    function ParseConformanceRestSecurityCertificate(obj : TTurtleComplex) : TFhirConformanceRestSecurityCertificate; overload; {b\}
    procedure ParseConformanceRestSecurityCertificateProperties(obj : TTurtleComplex; result : TFhirConformanceRestSecurityCertificate); overload; {b\}
    function ParseConformanceRestResource(obj : TTurtleComplex) : TFhirConformanceRestResource; overload; {b\}
    procedure ParseConformanceRestResourceProperties(obj : TTurtleComplex; result : TFhirConformanceRestResource); overload; {b\}
    function ParseConformanceRestResourceInteraction(obj : TTurtleComplex) : TFhirConformanceRestResourceInteraction; overload; {b\}
    procedure ParseConformanceRestResourceInteractionProperties(obj : TTurtleComplex; result : TFhirConformanceRestResourceInteraction); overload; {b\}
    function ParseConformanceRestResourceSearchParam(obj : TTurtleComplex) : TFhirConformanceRestResourceSearchParam; overload; {b\}
    procedure ParseConformanceRestResourceSearchParamProperties(obj : TTurtleComplex; result : TFhirConformanceRestResourceSearchParam); overload; {b\}
    function ParseConformanceRestInteraction(obj : TTurtleComplex) : TFhirConformanceRestInteraction; overload; {b\}
    procedure ParseConformanceRestInteractionProperties(obj : TTurtleComplex; result : TFhirConformanceRestInteraction); overload; {b\}
    function ParseConformanceRestOperation(obj : TTurtleComplex) : TFhirConformanceRestOperation; overload; {b\}
    procedure ParseConformanceRestOperationProperties(obj : TTurtleComplex; result : TFhirConformanceRestOperation); overload; {b\}
    function ParseConformanceMessaging(obj : TTurtleComplex) : TFhirConformanceMessaging; overload; {b\}
    procedure ParseConformanceMessagingProperties(obj : TTurtleComplex; result : TFhirConformanceMessaging); overload; {b\}
    function ParseConformanceMessagingEndpoint(obj : TTurtleComplex) : TFhirConformanceMessagingEndpoint; overload; {b\}
    procedure ParseConformanceMessagingEndpointProperties(obj : TTurtleComplex; result : TFhirConformanceMessagingEndpoint); overload; {b\}
    function ParseConformanceMessagingEvent(obj : TTurtleComplex) : TFhirConformanceMessagingEvent; overload; {b\}
    procedure ParseConformanceMessagingEventProperties(obj : TTurtleComplex; result : TFhirConformanceMessagingEvent); overload; {b\}
    function ParseConformanceDocument(obj : TTurtleComplex) : TFhirConformanceDocument; overload; {b\}
    procedure ParseConformanceDocumentProperties(obj : TTurtleComplex; result : TFhirConformanceDocument); overload; {b\}
    function ParseConformance(obj : TTurtleComplex) : TFhirConformance; overload;
    procedure ParseConformanceProperties(obj : TTurtleComplex; result : TFhirConformance); overload;
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
    function ParseContractActor(obj : TTurtleComplex) : TFhirContractActor; overload; {b\}
    procedure ParseContractActorProperties(obj : TTurtleComplex; result : TFhirContractActor); overload; {b\}
    function ParseContractValuedItem(obj : TTurtleComplex) : TFhirContractValuedItem; overload; {b\}
    procedure ParseContractValuedItemProperties(obj : TTurtleComplex; result : TFhirContractValuedItem); overload; {b\}
    function ParseContractSigner(obj : TTurtleComplex) : TFhirContractSigner; overload; {b\}
    procedure ParseContractSignerProperties(obj : TTurtleComplex; result : TFhirContractSigner); overload; {b\}
    function ParseContractTerm(obj : TTurtleComplex) : TFhirContractTerm; overload; {b\}
    procedure ParseContractTermProperties(obj : TTurtleComplex; result : TFhirContractTerm); overload; {b\}
    function ParseContractTermActor(obj : TTurtleComplex) : TFhirContractTermActor; overload; {b\}
    procedure ParseContractTermActorProperties(obj : TTurtleComplex; result : TFhirContractTermActor); overload; {b\}
    function ParseContractTermValuedItem(obj : TTurtleComplex) : TFhirContractTermValuedItem; overload; {b\}
    procedure ParseContractTermValuedItemProperties(obj : TTurtleComplex; result : TFhirContractTermValuedItem); overload; {b\}
    function ParseContractFriendly(obj : TTurtleComplex) : TFhirContractFriendly; overload; {b\}
    procedure ParseContractFriendlyProperties(obj : TTurtleComplex; result : TFhirContractFriendly); overload; {b\}
    function ParseContractLegal(obj : TTurtleComplex) : TFhirContractLegal; overload; {b\}
    procedure ParseContractLegalProperties(obj : TTurtleComplex; result : TFhirContractLegal); overload; {b\}
    function ParseContractRule(obj : TTurtleComplex) : TFhirContractRule; overload; {b\}
    procedure ParseContractRuleProperties(obj : TTurtleComplex; result : TFhirContractRule); overload; {b\}
    function ParseContract(obj : TTurtleComplex) : TFhirContract; overload;
    procedure ParseContractProperties(obj : TTurtleComplex; result : TFhirContract); overload;
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    function ParseCoverage(obj : TTurtleComplex) : TFhirCoverage; overload;
    procedure ParseCoverageProperties(obj : TTurtleComplex; result : TFhirCoverage); overload;
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
    function ParseDataElementContact(obj : TTurtleComplex) : TFhirDataElementContact; overload; {b\}
    procedure ParseDataElementContactProperties(obj : TTurtleComplex; result : TFhirDataElementContact); overload; {b\}
    function ParseDataElementMapping(obj : TTurtleComplex) : TFhirDataElementMapping; overload; {b\}
    procedure ParseDataElementMappingProperties(obj : TTurtleComplex; result : TFhirDataElementMapping); overload; {b\}
    function ParseDataElement(obj : TTurtleComplex) : TFhirDataElement; overload;
    procedure ParseDataElementProperties(obj : TTurtleComplex; result : TFhirDataElement); overload;
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
    function ParseDetectedIssueMitigation(obj : TTurtleComplex) : TFhirDetectedIssueMitigation; overload; {b\}
    procedure ParseDetectedIssueMitigationProperties(obj : TTurtleComplex; result : TFhirDetectedIssueMitigation); overload; {b\}
    function ParseDetectedIssue(obj : TTurtleComplex) : TFhirDetectedIssue; overload;
    procedure ParseDetectedIssueProperties(obj : TTurtleComplex; result : TFhirDetectedIssue); overload;
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    function ParseDevice(obj : TTurtleComplex) : TFhirDevice; overload;
    procedure ParseDeviceProperties(obj : TTurtleComplex; result : TFhirDevice); overload;
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
    function ParseDeviceComponentProductionSpecification(obj : TTurtleComplex) : TFhirDeviceComponentProductionSpecification; overload; {b\}
    procedure ParseDeviceComponentProductionSpecificationProperties(obj : TTurtleComplex; result : TFhirDeviceComponentProductionSpecification); overload; {b\}
    function ParseDeviceComponent(obj : TTurtleComplex) : TFhirDeviceComponent; overload;
    procedure ParseDeviceComponentProperties(obj : TTurtleComplex; result : TFhirDeviceComponent); overload;
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
    function ParseDeviceMetricCalibration(obj : TTurtleComplex) : TFhirDeviceMetricCalibration; overload; {b\}
    procedure ParseDeviceMetricCalibrationProperties(obj : TTurtleComplex; result : TFhirDeviceMetricCalibration); overload; {b\}
    function ParseDeviceMetric(obj : TTurtleComplex) : TFhirDeviceMetric; overload;
    procedure ParseDeviceMetricProperties(obj : TTurtleComplex; result : TFhirDeviceMetric); overload;
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
    function ParseDeviceUseRequest(obj : TTurtleComplex) : TFhirDeviceUseRequest; overload;
    procedure ParseDeviceUseRequestProperties(obj : TTurtleComplex; result : TFhirDeviceUseRequest); overload;
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
    function ParseDeviceUseStatement(obj : TTurtleComplex) : TFhirDeviceUseStatement; overload;
    procedure ParseDeviceUseStatementProperties(obj : TTurtleComplex; result : TFhirDeviceUseStatement); overload;
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
    function ParseDiagnosticOrderEvent(obj : TTurtleComplex) : TFhirDiagnosticOrderEvent; overload; {b\}
    procedure ParseDiagnosticOrderEventProperties(obj : TTurtleComplex; result : TFhirDiagnosticOrderEvent); overload; {b\}
    function ParseDiagnosticOrderItem(obj : TTurtleComplex) : TFhirDiagnosticOrderItem; overload; {b\}
    procedure ParseDiagnosticOrderItemProperties(obj : TTurtleComplex; result : TFhirDiagnosticOrderItem); overload; {b\}
    function ParseDiagnosticOrder(obj : TTurtleComplex) : TFhirDiagnosticOrder; overload;
    procedure ParseDiagnosticOrderProperties(obj : TTurtleComplex; result : TFhirDiagnosticOrder); overload;
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    function ParseDiagnosticReportImage(obj : TTurtleComplex) : TFhirDiagnosticReportImage; overload; {b\}
    procedure ParseDiagnosticReportImageProperties(obj : TTurtleComplex; result : TFhirDiagnosticReportImage); overload; {b\}
    function ParseDiagnosticReport(obj : TTurtleComplex) : TFhirDiagnosticReport; overload;
    procedure ParseDiagnosticReportProperties(obj : TTurtleComplex; result : TFhirDiagnosticReport); overload;
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    function ParseDocumentManifestContent(obj : TTurtleComplex) : TFhirDocumentManifestContent; overload; {b\}
    procedure ParseDocumentManifestContentProperties(obj : TTurtleComplex; result : TFhirDocumentManifestContent); overload; {b\}
    function ParseDocumentManifestRelated(obj : TTurtleComplex) : TFhirDocumentManifestRelated; overload; {b\}
    procedure ParseDocumentManifestRelatedProperties(obj : TTurtleComplex; result : TFhirDocumentManifestRelated); overload; {b\}
    function ParseDocumentManifest(obj : TTurtleComplex) : TFhirDocumentManifest; overload;
    procedure ParseDocumentManifestProperties(obj : TTurtleComplex; result : TFhirDocumentManifest); overload;
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    function ParseDocumentReferenceRelatesTo(obj : TTurtleComplex) : TFhirDocumentReferenceRelatesTo; overload; {b\}
    procedure ParseDocumentReferenceRelatesToProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceRelatesTo); overload; {b\}
    function ParseDocumentReferenceContent(obj : TTurtleComplex) : TFhirDocumentReferenceContent; overload; {b\}
    procedure ParseDocumentReferenceContentProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceContent); overload; {b\}
    function ParseDocumentReferenceContext(obj : TTurtleComplex) : TFhirDocumentReferenceContext; overload; {b\}
    procedure ParseDocumentReferenceContextProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceContext); overload; {b\}
    function ParseDocumentReferenceContextRelated(obj : TTurtleComplex) : TFhirDocumentReferenceContextRelated; overload; {b\}
    procedure ParseDocumentReferenceContextRelatedProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceContextRelated); overload; {b\}
    function ParseDocumentReference(obj : TTurtleComplex) : TFhirDocumentReference; overload;
    procedure ParseDocumentReferenceProperties(obj : TTurtleComplex; result : TFhirDocumentReference); overload;
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
    function ParseEligibilityRequest(obj : TTurtleComplex) : TFhirEligibilityRequest; overload;
    procedure ParseEligibilityRequestProperties(obj : TTurtleComplex; result : TFhirEligibilityRequest); overload;
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
    function ParseEligibilityResponse(obj : TTurtleComplex) : TFhirEligibilityResponse; overload;
    procedure ParseEligibilityResponseProperties(obj : TTurtleComplex; result : TFhirEligibilityResponse); overload;
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
    function ParseEncounterStatusHistory(obj : TTurtleComplex) : TFhirEncounterStatusHistory; overload; {b\}
    procedure ParseEncounterStatusHistoryProperties(obj : TTurtleComplex; result : TFhirEncounterStatusHistory); overload; {b\}
    function ParseEncounterParticipant(obj : TTurtleComplex) : TFhirEncounterParticipant; overload; {b\}
    procedure ParseEncounterParticipantProperties(obj : TTurtleComplex; result : TFhirEncounterParticipant); overload; {b\}
    function ParseEncounterHospitalization(obj : TTurtleComplex) : TFhirEncounterHospitalization; overload; {b\}
    procedure ParseEncounterHospitalizationProperties(obj : TTurtleComplex; result : TFhirEncounterHospitalization); overload; {b\}
    function ParseEncounterLocation(obj : TTurtleComplex) : TFhirEncounterLocation; overload; {b\}
    procedure ParseEncounterLocationProperties(obj : TTurtleComplex; result : TFhirEncounterLocation); overload; {b\}
    function ParseEncounter(obj : TTurtleComplex) : TFhirEncounter; overload;
    procedure ParseEncounterProperties(obj : TTurtleComplex; result : TFhirEncounter); overload;
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    function ParseEnrollmentRequest(obj : TTurtleComplex) : TFhirEnrollmentRequest; overload;
    procedure ParseEnrollmentRequestProperties(obj : TTurtleComplex; result : TFhirEnrollmentRequest); overload;
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    function ParseEnrollmentResponse(obj : TTurtleComplex) : TFhirEnrollmentResponse; overload;
    procedure ParseEnrollmentResponseProperties(obj : TTurtleComplex; result : TFhirEnrollmentResponse); overload;
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    function ParseEpisodeOfCareStatusHistory(obj : TTurtleComplex) : TFhirEpisodeOfCareStatusHistory; overload; {b\}
    procedure ParseEpisodeOfCareStatusHistoryProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCareStatusHistory); overload; {b\}
    function ParseEpisodeOfCareCareTeam(obj : TTurtleComplex) : TFhirEpisodeOfCareCareTeam; overload; {b\}
    procedure ParseEpisodeOfCareCareTeamProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCareCareTeam); overload; {b\}
    function ParseEpisodeOfCare(obj : TTurtleComplex) : TFhirEpisodeOfCare; overload;
    procedure ParseEpisodeOfCareProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCare); overload;
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    function ParseExplanationOfBenefit(obj : TTurtleComplex) : TFhirExplanationOfBenefit; overload;
    procedure ParseExplanationOfBenefitProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefit); overload;
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    function ParseFamilyMemberHistoryCondition(obj : TTurtleComplex) : TFhirFamilyMemberHistoryCondition; overload; {b\}
    procedure ParseFamilyMemberHistoryConditionProperties(obj : TTurtleComplex; result : TFhirFamilyMemberHistoryCondition); overload; {b\}
    function ParseFamilyMemberHistory(obj : TTurtleComplex) : TFhirFamilyMemberHistory; overload;
    procedure ParseFamilyMemberHistoryProperties(obj : TTurtleComplex; result : TFhirFamilyMemberHistory); overload;
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    function ParseFlag(obj : TTurtleComplex) : TFhirFlag; overload;
    procedure ParseFlagProperties(obj : TTurtleComplex; result : TFhirFlag); overload;
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
    function ParseGoalOutcome(obj : TTurtleComplex) : TFhirGoalOutcome; overload; {b\}
    procedure ParseGoalOutcomeProperties(obj : TTurtleComplex; result : TFhirGoalOutcome); overload; {b\}
    function ParseGoal(obj : TTurtleComplex) : TFhirGoal; overload;
    procedure ParseGoalProperties(obj : TTurtleComplex; result : TFhirGoal); overload;
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
    function ParseGroupCharacteristic(obj : TTurtleComplex) : TFhirGroupCharacteristic; overload; {b\}
    procedure ParseGroupCharacteristicProperties(obj : TTurtleComplex; result : TFhirGroupCharacteristic); overload; {b\}
    function ParseGroupMember(obj : TTurtleComplex) : TFhirGroupMember; overload; {b\}
    procedure ParseGroupMemberProperties(obj : TTurtleComplex; result : TFhirGroupMember); overload; {b\}
    function ParseGroup(obj : TTurtleComplex) : TFhirGroup; overload;
    procedure ParseGroupProperties(obj : TTurtleComplex; result : TFhirGroup); overload;
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
    function ParseHealthcareServiceServiceType(obj : TTurtleComplex) : TFhirHealthcareServiceServiceType; overload; {b\}
    procedure ParseHealthcareServiceServiceTypeProperties(obj : TTurtleComplex; result : TFhirHealthcareServiceServiceType); overload; {b\}
    function ParseHealthcareServiceAvailableTime(obj : TTurtleComplex) : TFhirHealthcareServiceAvailableTime; overload; {b\}
    procedure ParseHealthcareServiceAvailableTimeProperties(obj : TTurtleComplex; result : TFhirHealthcareServiceAvailableTime); overload; {b\}
    function ParseHealthcareServiceNotAvailable(obj : TTurtleComplex) : TFhirHealthcareServiceNotAvailable; overload; {b\}
    procedure ParseHealthcareServiceNotAvailableProperties(obj : TTurtleComplex; result : TFhirHealthcareServiceNotAvailable); overload; {b\}
    function ParseHealthcareService(obj : TTurtleComplex) : TFhirHealthcareService; overload;
    procedure ParseHealthcareServiceProperties(obj : TTurtleComplex; result : TFhirHealthcareService); overload;
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
    function ParseImagingObjectSelectionStudy(obj : TTurtleComplex) : TFhirImagingObjectSelectionStudy; overload; {b\}
    procedure ParseImagingObjectSelectionStudyProperties(obj : TTurtleComplex; result : TFhirImagingObjectSelectionStudy); overload; {b\}
    function ParseImagingObjectSelectionStudySeries(obj : TTurtleComplex) : TFhirImagingObjectSelectionStudySeries; overload; {b\}
    procedure ParseImagingObjectSelectionStudySeriesProperties(obj : TTurtleComplex; result : TFhirImagingObjectSelectionStudySeries); overload; {b\}
    function ParseImagingObjectSelectionStudySeriesInstance(obj : TTurtleComplex) : TFhirImagingObjectSelectionStudySeriesInstance; overload; {b\}
    procedure ParseImagingObjectSelectionStudySeriesInstanceProperties(obj : TTurtleComplex; result : TFhirImagingObjectSelectionStudySeriesInstance); overload; {b\}
    function ParseImagingObjectSelectionStudySeriesInstanceFrames(obj : TTurtleComplex) : TFhirImagingObjectSelectionStudySeriesInstanceFrames; overload; {b\}
    procedure ParseImagingObjectSelectionStudySeriesInstanceFramesProperties(obj : TTurtleComplex; result : TFhirImagingObjectSelectionStudySeriesInstanceFrames); overload; {b\}
    function ParseImagingObjectSelection(obj : TTurtleComplex) : TFhirImagingObjectSelection; overload;
    procedure ParseImagingObjectSelectionProperties(obj : TTurtleComplex; result : TFhirImagingObjectSelection); overload;
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
    function ParseImagingStudySeries(obj : TTurtleComplex) : TFhirImagingStudySeries; overload; {b\}
    procedure ParseImagingStudySeriesProperties(obj : TTurtleComplex; result : TFhirImagingStudySeries); overload; {b\}
    function ParseImagingStudySeriesInstance(obj : TTurtleComplex) : TFhirImagingStudySeriesInstance; overload; {b\}
    procedure ParseImagingStudySeriesInstanceProperties(obj : TTurtleComplex; result : TFhirImagingStudySeriesInstance); overload; {b\}
    function ParseImagingStudy(obj : TTurtleComplex) : TFhirImagingStudy; overload;
    procedure ParseImagingStudyProperties(obj : TTurtleComplex; result : TFhirImagingStudy); overload;
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    function ParseImmunizationExplanation(obj : TTurtleComplex) : TFhirImmunizationExplanation; overload; {b\}
    procedure ParseImmunizationExplanationProperties(obj : TTurtleComplex; result : TFhirImmunizationExplanation); overload; {b\}
    function ParseImmunizationReaction(obj : TTurtleComplex) : TFhirImmunizationReaction; overload; {b\}
    procedure ParseImmunizationReactionProperties(obj : TTurtleComplex; result : TFhirImmunizationReaction); overload; {b\}
    function ParseImmunizationVaccinationProtocol(obj : TTurtleComplex) : TFhirImmunizationVaccinationProtocol; overload; {b\}
    procedure ParseImmunizationVaccinationProtocolProperties(obj : TTurtleComplex; result : TFhirImmunizationVaccinationProtocol); overload; {b\}
    function ParseImmunization(obj : TTurtleComplex) : TFhirImmunization; overload;
    procedure ParseImmunizationProperties(obj : TTurtleComplex; result : TFhirImmunization); overload;
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    function ParseImmunizationRecommendationRecommendation(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendation; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendationRecommendation); overload; {b\}
    function ParseImmunizationRecommendationRecommendationDateCriterion(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendationDateCriterion; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationDateCriterionProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendationRecommendationDateCriterion); overload; {b\}
    function ParseImmunizationRecommendationRecommendationProtocol(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendationProtocol; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationProtocolProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendationRecommendationProtocol); overload; {b\}
    function ParseImmunizationRecommendation(obj : TTurtleComplex) : TFhirImmunizationRecommendation; overload;
    procedure ParseImmunizationRecommendationProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendation); overload;
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    function ParseImplementationGuideContact(obj : TTurtleComplex) : TFhirImplementationGuideContact; overload; {b\}
    procedure ParseImplementationGuideContactProperties(obj : TTurtleComplex; result : TFhirImplementationGuideContact); overload; {b\}
    function ParseImplementationGuideDependency(obj : TTurtleComplex) : TFhirImplementationGuideDependency; overload; {b\}
    procedure ParseImplementationGuideDependencyProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDependency); overload; {b\}
    function ParseImplementationGuidePackage(obj : TTurtleComplex) : TFhirImplementationGuidePackage; overload; {b\}
    procedure ParseImplementationGuidePackageProperties(obj : TTurtleComplex; result : TFhirImplementationGuidePackage); overload; {b\}
    function ParseImplementationGuidePackageResource(obj : TTurtleComplex) : TFhirImplementationGuidePackageResource; overload; {b\}
    procedure ParseImplementationGuidePackageResourceProperties(obj : TTurtleComplex; result : TFhirImplementationGuidePackageResource); overload; {b\}
    function ParseImplementationGuideGlobal(obj : TTurtleComplex) : TFhirImplementationGuideGlobal; overload; {b\}
    procedure ParseImplementationGuideGlobalProperties(obj : TTurtleComplex; result : TFhirImplementationGuideGlobal); overload; {b\}
    function ParseImplementationGuidePage(obj : TTurtleComplex) : TFhirImplementationGuidePage; overload; {b\}
    procedure ParseImplementationGuidePageProperties(obj : TTurtleComplex; result : TFhirImplementationGuidePage); overload; {b\}
    function ParseImplementationGuide(obj : TTurtleComplex) : TFhirImplementationGuide; overload;
    procedure ParseImplementationGuideProperties(obj : TTurtleComplex; result : TFhirImplementationGuide); overload;
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
    function ParseListEntry(obj : TTurtleComplex) : TFhirListEntry; overload; {b\}
    procedure ParseListEntryProperties(obj : TTurtleComplex; result : TFhirListEntry); overload; {b\}
    function ParseList(obj : TTurtleComplex) : TFhirList; overload;
    procedure ParseListProperties(obj : TTurtleComplex; result : TFhirList); overload;
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    function ParseLocationPosition(obj : TTurtleComplex) : TFhirLocationPosition; overload; {b\}
    procedure ParseLocationPositionProperties(obj : TTurtleComplex; result : TFhirLocationPosition); overload; {b\}
    function ParseLocation(obj : TTurtleComplex) : TFhirLocation; overload;
    procedure ParseLocationProperties(obj : TTurtleComplex; result : TFhirLocation); overload;
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
    function ParseMedia(obj : TTurtleComplex) : TFhirMedia; overload;
    procedure ParseMediaProperties(obj : TTurtleComplex; result : TFhirMedia); overload;
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
    function ParseMedicationProduct(obj : TTurtleComplex) : TFhirMedicationProduct; overload; {b\}
    procedure ParseMedicationProductProperties(obj : TTurtleComplex; result : TFhirMedicationProduct); overload; {b\}
    function ParseMedicationProductIngredient(obj : TTurtleComplex) : TFhirMedicationProductIngredient; overload; {b\}
    procedure ParseMedicationProductIngredientProperties(obj : TTurtleComplex; result : TFhirMedicationProductIngredient); overload; {b\}
    function ParseMedicationProductBatch(obj : TTurtleComplex) : TFhirMedicationProductBatch; overload; {b\}
    procedure ParseMedicationProductBatchProperties(obj : TTurtleComplex; result : TFhirMedicationProductBatch); overload; {b\}
    function ParseMedicationPackage(obj : TTurtleComplex) : TFhirMedicationPackage; overload; {b\}
    procedure ParseMedicationPackageProperties(obj : TTurtleComplex; result : TFhirMedicationPackage); overload; {b\}
    function ParseMedicationPackageContent(obj : TTurtleComplex) : TFhirMedicationPackageContent; overload; {b\}
    procedure ParseMedicationPackageContentProperties(obj : TTurtleComplex; result : TFhirMedicationPackageContent); overload; {b\}
    function ParseMedication(obj : TTurtleComplex) : TFhirMedication; overload;
    procedure ParseMedicationProperties(obj : TTurtleComplex; result : TFhirMedication); overload;
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    function ParseMedicationAdministrationDosage(obj : TTurtleComplex) : TFhirMedicationAdministrationDosage; overload; {b\}
    procedure ParseMedicationAdministrationDosageProperties(obj : TTurtleComplex; result : TFhirMedicationAdministrationDosage); overload; {b\}
    function ParseMedicationAdministration(obj : TTurtleComplex) : TFhirMedicationAdministration; overload;
    procedure ParseMedicationAdministrationProperties(obj : TTurtleComplex; result : TFhirMedicationAdministration); overload;
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    function ParseMedicationDispenseDosageInstruction(obj : TTurtleComplex) : TFhirMedicationDispenseDosageInstruction; overload; {b\}
    procedure ParseMedicationDispenseDosageInstructionProperties(obj : TTurtleComplex; result : TFhirMedicationDispenseDosageInstruction); overload; {b\}
    function ParseMedicationDispenseSubstitution(obj : TTurtleComplex) : TFhirMedicationDispenseSubstitution; overload; {b\}
    procedure ParseMedicationDispenseSubstitutionProperties(obj : TTurtleComplex; result : TFhirMedicationDispenseSubstitution); overload; {b\}
    function ParseMedicationDispense(obj : TTurtleComplex) : TFhirMedicationDispense; overload;
    procedure ParseMedicationDispenseProperties(obj : TTurtleComplex; result : TFhirMedicationDispense); overload;
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
    function ParseMedicationOrderDosageInstruction(obj : TTurtleComplex) : TFhirMedicationOrderDosageInstruction; overload; {b\}
    procedure ParseMedicationOrderDosageInstructionProperties(obj : TTurtleComplex; result : TFhirMedicationOrderDosageInstruction); overload; {b\}
    function ParseMedicationOrderDispenseRequest(obj : TTurtleComplex) : TFhirMedicationOrderDispenseRequest; overload; {b\}
    procedure ParseMedicationOrderDispenseRequestProperties(obj : TTurtleComplex; result : TFhirMedicationOrderDispenseRequest); overload; {b\}
    function ParseMedicationOrderSubstitution(obj : TTurtleComplex) : TFhirMedicationOrderSubstitution; overload; {b\}
    procedure ParseMedicationOrderSubstitutionProperties(obj : TTurtleComplex; result : TFhirMedicationOrderSubstitution); overload; {b\}
    function ParseMedicationOrder(obj : TTurtleComplex) : TFhirMedicationOrder; overload;
    procedure ParseMedicationOrderProperties(obj : TTurtleComplex; result : TFhirMedicationOrder); overload;
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
    function ParseMedicationStatementDosage(obj : TTurtleComplex) : TFhirMedicationStatementDosage; overload; {b\}
    procedure ParseMedicationStatementDosageProperties(obj : TTurtleComplex; result : TFhirMedicationStatementDosage); overload; {b\}
    function ParseMedicationStatement(obj : TTurtleComplex) : TFhirMedicationStatement; overload;
    procedure ParseMedicationStatementProperties(obj : TTurtleComplex; result : TFhirMedicationStatement); overload;
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
    function ParseMessageHeaderResponse(obj : TTurtleComplex) : TFhirMessageHeaderResponse; overload; {b\}
    procedure ParseMessageHeaderResponseProperties(obj : TTurtleComplex; result : TFhirMessageHeaderResponse); overload; {b\}
    function ParseMessageHeaderSource(obj : TTurtleComplex) : TFhirMessageHeaderSource; overload; {b\}
    procedure ParseMessageHeaderSourceProperties(obj : TTurtleComplex; result : TFhirMessageHeaderSource); overload; {b\}
    function ParseMessageHeaderDestination(obj : TTurtleComplex) : TFhirMessageHeaderDestination; overload; {b\}
    procedure ParseMessageHeaderDestinationProperties(obj : TTurtleComplex; result : TFhirMessageHeaderDestination); overload; {b\}
    function ParseMessageHeader(obj : TTurtleComplex) : TFhirMessageHeader; overload;
    procedure ParseMessageHeaderProperties(obj : TTurtleComplex; result : TFhirMessageHeader); overload;
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
    function ParseNamingSystemContact(obj : TTurtleComplex) : TFhirNamingSystemContact; overload; {b\}
    procedure ParseNamingSystemContactProperties(obj : TTurtleComplex; result : TFhirNamingSystemContact); overload; {b\}
    function ParseNamingSystemUniqueId(obj : TTurtleComplex) : TFhirNamingSystemUniqueId; overload; {b\}
    procedure ParseNamingSystemUniqueIdProperties(obj : TTurtleComplex; result : TFhirNamingSystemUniqueId); overload; {b\}
    function ParseNamingSystem(obj : TTurtleComplex) : TFhirNamingSystem; overload;
    procedure ParseNamingSystemProperties(obj : TTurtleComplex; result : TFhirNamingSystem); overload;
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
    function ParseNutritionOrderOralDiet(obj : TTurtleComplex) : TFhirNutritionOrderOralDiet; overload; {b\}
    procedure ParseNutritionOrderOralDietProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDiet); overload; {b\}
    function ParseNutritionOrderOralDietNutrient(obj : TTurtleComplex) : TFhirNutritionOrderOralDietNutrient; overload; {b\}
    procedure ParseNutritionOrderOralDietNutrientProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDietNutrient); overload; {b\}
    function ParseNutritionOrderOralDietTexture(obj : TTurtleComplex) : TFhirNutritionOrderOralDietTexture; overload; {b\}
    procedure ParseNutritionOrderOralDietTextureProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDietTexture); overload; {b\}
    function ParseNutritionOrderSupplement(obj : TTurtleComplex) : TFhirNutritionOrderSupplement; overload; {b\}
    procedure ParseNutritionOrderSupplementProperties(obj : TTurtleComplex; result : TFhirNutritionOrderSupplement); overload; {b\}
    function ParseNutritionOrderEnteralFormula(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormula; overload; {b\}
    procedure ParseNutritionOrderEnteralFormulaProperties(obj : TTurtleComplex; result : TFhirNutritionOrderEnteralFormula); overload; {b\}
    function ParseNutritionOrderEnteralFormulaAdministration(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormulaAdministration; overload; {b\}
    procedure ParseNutritionOrderEnteralFormulaAdministrationProperties(obj : TTurtleComplex; result : TFhirNutritionOrderEnteralFormulaAdministration); overload; {b\}
    function ParseNutritionOrder(obj : TTurtleComplex) : TFhirNutritionOrder; overload;
    procedure ParseNutritionOrderProperties(obj : TTurtleComplex; result : TFhirNutritionOrder); overload;
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
    function ParseObservationReferenceRange(obj : TTurtleComplex) : TFhirObservationReferenceRange; overload; {b\}
    procedure ParseObservationReferenceRangeProperties(obj : TTurtleComplex; result : TFhirObservationReferenceRange); overload; {b\}
    function ParseObservationRelated(obj : TTurtleComplex) : TFhirObservationRelated; overload; {b\}
    procedure ParseObservationRelatedProperties(obj : TTurtleComplex; result : TFhirObservationRelated); overload; {b\}
    function ParseObservationComponent(obj : TTurtleComplex) : TFhirObservationComponent; overload; {b\}
    procedure ParseObservationComponentProperties(obj : TTurtleComplex; result : TFhirObservationComponent); overload; {b\}
    function ParseObservation(obj : TTurtleComplex) : TFhirObservation; overload;
    procedure ParseObservationProperties(obj : TTurtleComplex; result : TFhirObservation); overload;
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    function ParseOperationDefinitionContact(obj : TTurtleComplex) : TFhirOperationDefinitionContact; overload; {b\}
    procedure ParseOperationDefinitionContactProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionContact); overload; {b\}
    function ParseOperationDefinitionParameter(obj : TTurtleComplex) : TFhirOperationDefinitionParameter; overload; {b\}
    procedure ParseOperationDefinitionParameterProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionParameter); overload; {b\}
    function ParseOperationDefinitionParameterBinding(obj : TTurtleComplex) : TFhirOperationDefinitionParameterBinding; overload; {b\}
    procedure ParseOperationDefinitionParameterBindingProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionParameterBinding); overload; {b\}
    function ParseOperationDefinition(obj : TTurtleComplex) : TFhirOperationDefinition; overload;
    procedure ParseOperationDefinitionProperties(obj : TTurtleComplex; result : TFhirOperationDefinition); overload;
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    function ParseOperationOutcomeIssue(obj : TTurtleComplex) : TFhirOperationOutcomeIssue; overload; {b\}
    procedure ParseOperationOutcomeIssueProperties(obj : TTurtleComplex; result : TFhirOperationOutcomeIssue); overload; {b\}
    function ParseOperationOutcome(obj : TTurtleComplex) : TFhirOperationOutcome; overload;
    procedure ParseOperationOutcomeProperties(obj : TTurtleComplex; result : TFhirOperationOutcome); overload;
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
    function ParseOrderWhen(obj : TTurtleComplex) : TFhirOrderWhen; overload; {b\}
    procedure ParseOrderWhenProperties(obj : TTurtleComplex; result : TFhirOrderWhen); overload; {b\}
    function ParseOrder(obj : TTurtleComplex) : TFhirOrder; overload;
    procedure ParseOrderProperties(obj : TTurtleComplex; result : TFhirOrder); overload;
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
    function ParseOrderResponse(obj : TTurtleComplex) : TFhirOrderResponse; overload;
    procedure ParseOrderResponseProperties(obj : TTurtleComplex; result : TFhirOrderResponse); overload;
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
    function ParseOrganizationContact(obj : TTurtleComplex) : TFhirOrganizationContact; overload; {b\}
    procedure ParseOrganizationContactProperties(obj : TTurtleComplex; result : TFhirOrganizationContact); overload; {b\}
    function ParseOrganization(obj : TTurtleComplex) : TFhirOrganization; overload;
    procedure ParseOrganizationProperties(obj : TTurtleComplex; result : TFhirOrganization); overload;
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
    function ParsePatientContact(obj : TTurtleComplex) : TFhirPatientContact; overload; {b\}
    procedure ParsePatientContactProperties(obj : TTurtleComplex; result : TFhirPatientContact); overload; {b\}
    function ParsePatientAnimal(obj : TTurtleComplex) : TFhirPatientAnimal; overload; {b\}
    procedure ParsePatientAnimalProperties(obj : TTurtleComplex; result : TFhirPatientAnimal); overload; {b\}
    function ParsePatientCommunication(obj : TTurtleComplex) : TFhirPatientCommunication; overload; {b\}
    procedure ParsePatientCommunicationProperties(obj : TTurtleComplex; result : TFhirPatientCommunication); overload; {b\}
    function ParsePatientLink(obj : TTurtleComplex) : TFhirPatientLink; overload; {b\}
    procedure ParsePatientLinkProperties(obj : TTurtleComplex; result : TFhirPatientLink); overload; {b\}
    function ParsePatient(obj : TTurtleComplex) : TFhirPatient; overload;
    procedure ParsePatientProperties(obj : TTurtleComplex; result : TFhirPatient); overload;
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    function ParsePaymentNotice(obj : TTurtleComplex) : TFhirPaymentNotice; overload;
    procedure ParsePaymentNoticeProperties(obj : TTurtleComplex; result : TFhirPaymentNotice); overload;
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    function ParsePaymentReconciliationDetail(obj : TTurtleComplex) : TFhirPaymentReconciliationDetail; overload; {b\}
    procedure ParsePaymentReconciliationDetailProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliationDetail); overload; {b\}
    function ParsePaymentReconciliationNote(obj : TTurtleComplex) : TFhirPaymentReconciliationNote; overload; {b\}
    procedure ParsePaymentReconciliationNoteProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliationNote); overload; {b\}
    function ParsePaymentReconciliation(obj : TTurtleComplex) : TFhirPaymentReconciliation; overload;
    procedure ParsePaymentReconciliationProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliation); overload;
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
    function ParsePersonLink(obj : TTurtleComplex) : TFhirPersonLink; overload; {b\}
    procedure ParsePersonLinkProperties(obj : TTurtleComplex; result : TFhirPersonLink); overload; {b\}
    function ParsePerson(obj : TTurtleComplex) : TFhirPerson; overload;
    procedure ParsePersonProperties(obj : TTurtleComplex; result : TFhirPerson); overload;
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
    function ParsePractitionerPractitionerRole(obj : TTurtleComplex) : TFhirPractitionerPractitionerRole; overload; {b\}
    procedure ParsePractitionerPractitionerRoleProperties(obj : TTurtleComplex; result : TFhirPractitionerPractitionerRole); overload; {b\}
    function ParsePractitionerQualification(obj : TTurtleComplex) : TFhirPractitionerQualification; overload; {b\}
    procedure ParsePractitionerQualificationProperties(obj : TTurtleComplex; result : TFhirPractitionerQualification); overload; {b\}
    function ParsePractitioner(obj : TTurtleComplex) : TFhirPractitioner; overload;
    procedure ParsePractitionerProperties(obj : TTurtleComplex; result : TFhirPractitioner); overload;
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
    function ParseProcedurePerformer(obj : TTurtleComplex) : TFhirProcedurePerformer; overload; {b\}
    procedure ParseProcedurePerformerProperties(obj : TTurtleComplex; result : TFhirProcedurePerformer); overload; {b\}
    function ParseProcedureFocalDevice(obj : TTurtleComplex) : TFhirProcedureFocalDevice; overload; {b\}
    procedure ParseProcedureFocalDeviceProperties(obj : TTurtleComplex; result : TFhirProcedureFocalDevice); overload; {b\}
    function ParseProcedure(obj : TTurtleComplex) : TFhirProcedure; overload;
    procedure ParseProcedureProperties(obj : TTurtleComplex; result : TFhirProcedure); overload;
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
    function ParseProcedureRequest(obj : TTurtleComplex) : TFhirProcedureRequest; overload;
    procedure ParseProcedureRequestProperties(obj : TTurtleComplex; result : TFhirProcedureRequest); overload;
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
    function ParseProcessRequestItem(obj : TTurtleComplex) : TFhirProcessRequestItem; overload; {b\}
    procedure ParseProcessRequestItemProperties(obj : TTurtleComplex; result : TFhirProcessRequestItem); overload; {b\}
    function ParseProcessRequest(obj : TTurtleComplex) : TFhirProcessRequest; overload;
    procedure ParseProcessRequestProperties(obj : TTurtleComplex; result : TFhirProcessRequest); overload;
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
    function ParseProcessResponseNotes(obj : TTurtleComplex) : TFhirProcessResponseNotes; overload; {b\}
    procedure ParseProcessResponseNotesProperties(obj : TTurtleComplex; result : TFhirProcessResponseNotes); overload; {b\}
    function ParseProcessResponse(obj : TTurtleComplex) : TFhirProcessResponse; overload;
    procedure ParseProcessResponseProperties(obj : TTurtleComplex; result : TFhirProcessResponse); overload;
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
    function ParseProvenanceAgent(obj : TTurtleComplex) : TFhirProvenanceAgent; overload; {b\}
    procedure ParseProvenanceAgentProperties(obj : TTurtleComplex; result : TFhirProvenanceAgent); overload; {b\}
    function ParseProvenanceAgentRelatedAgent(obj : TTurtleComplex) : TFhirProvenanceAgentRelatedAgent; overload; {b\}
    procedure ParseProvenanceAgentRelatedAgentProperties(obj : TTurtleComplex; result : TFhirProvenanceAgentRelatedAgent); overload; {b\}
    function ParseProvenanceEntity(obj : TTurtleComplex) : TFhirProvenanceEntity; overload; {b\}
    procedure ParseProvenanceEntityProperties(obj : TTurtleComplex; result : TFhirProvenanceEntity); overload; {b\}
    function ParseProvenance(obj : TTurtleComplex) : TFhirProvenance; overload;
    procedure ParseProvenanceProperties(obj : TTurtleComplex; result : TFhirProvenance); overload;
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    function ParseQuestionnaireGroup(obj : TTurtleComplex) : TFhirQuestionnaireGroup; overload; {b\}
    procedure ParseQuestionnaireGroupProperties(obj : TTurtleComplex; result : TFhirQuestionnaireGroup); overload; {b\}
    function ParseQuestionnaireGroupQuestion(obj : TTurtleComplex) : TFhirQuestionnaireGroupQuestion; overload; {b\}
    procedure ParseQuestionnaireGroupQuestionProperties(obj : TTurtleComplex; result : TFhirQuestionnaireGroupQuestion); overload; {b\}
    function ParseQuestionnaire(obj : TTurtleComplex) : TFhirQuestionnaire; overload;
    procedure ParseQuestionnaireProperties(obj : TTurtleComplex; result : TFhirQuestionnaire); overload;
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    function ParseQuestionnaireResponseGroup(obj : TTurtleComplex) : TFhirQuestionnaireResponseGroup; overload; {b\}
    procedure ParseQuestionnaireResponseGroupProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponseGroup); overload; {b\}
    function ParseQuestionnaireResponseGroupQuestion(obj : TTurtleComplex) : TFhirQuestionnaireResponseGroupQuestion; overload; {b\}
    procedure ParseQuestionnaireResponseGroupQuestionProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponseGroupQuestion); overload; {b\}
    function ParseQuestionnaireResponseGroupQuestionAnswer(obj : TTurtleComplex) : TFhirQuestionnaireResponseGroupQuestionAnswer; overload; {b\}
    procedure ParseQuestionnaireResponseGroupQuestionAnswerProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponseGroupQuestionAnswer); overload; {b\}
    function ParseQuestionnaireResponse(obj : TTurtleComplex) : TFhirQuestionnaireResponse; overload;
    procedure ParseQuestionnaireResponseProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponse); overload;
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
    function ParseReferralRequest(obj : TTurtleComplex) : TFhirReferralRequest; overload;
    procedure ParseReferralRequestProperties(obj : TTurtleComplex; result : TFhirReferralRequest); overload;
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
    function ParseRelatedPerson(obj : TTurtleComplex) : TFhirRelatedPerson; overload;
    procedure ParseRelatedPersonProperties(obj : TTurtleComplex; result : TFhirRelatedPerson); overload;
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
    function ParseRiskAssessmentPrediction(obj : TTurtleComplex) : TFhirRiskAssessmentPrediction; overload; {b\}
    procedure ParseRiskAssessmentPredictionProperties(obj : TTurtleComplex; result : TFhirRiskAssessmentPrediction); overload; {b\}
    function ParseRiskAssessment(obj : TTurtleComplex) : TFhirRiskAssessment; overload;
    procedure ParseRiskAssessmentProperties(obj : TTurtleComplex; result : TFhirRiskAssessment); overload;
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
    function ParseSchedule(obj : TTurtleComplex) : TFhirSchedule; overload;
    procedure ParseScheduleProperties(obj : TTurtleComplex; result : TFhirSchedule); overload;
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    function ParseSearchParameterContact(obj : TTurtleComplex) : TFhirSearchParameterContact; overload; {b\}
    procedure ParseSearchParameterContactProperties(obj : TTurtleComplex; result : TFhirSearchParameterContact); overload; {b\}
    function ParseSearchParameter(obj : TTurtleComplex) : TFhirSearchParameter; overload;
    procedure ParseSearchParameterProperties(obj : TTurtleComplex; result : TFhirSearchParameter); overload;
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
    function ParseSlot(obj : TTurtleComplex) : TFhirSlot; overload;
    procedure ParseSlotProperties(obj : TTurtleComplex; result : TFhirSlot); overload;
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    function ParseSpecimenCollection(obj : TTurtleComplex) : TFhirSpecimenCollection; overload; {b\}
    procedure ParseSpecimenCollectionProperties(obj : TTurtleComplex; result : TFhirSpecimenCollection); overload; {b\}
    function ParseSpecimenTreatment(obj : TTurtleComplex) : TFhirSpecimenTreatment; overload; {b\}
    procedure ParseSpecimenTreatmentProperties(obj : TTurtleComplex; result : TFhirSpecimenTreatment); overload; {b\}
    function ParseSpecimenContainer(obj : TTurtleComplex) : TFhirSpecimenContainer; overload; {b\}
    procedure ParseSpecimenContainerProperties(obj : TTurtleComplex; result : TFhirSpecimenContainer); overload; {b\}
    function ParseSpecimen(obj : TTurtleComplex) : TFhirSpecimen; overload;
    procedure ParseSpecimenProperties(obj : TTurtleComplex; result : TFhirSpecimen); overload;
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    function ParseStructureDefinitionContact(obj : TTurtleComplex) : TFhirStructureDefinitionContact; overload; {b\}
    procedure ParseStructureDefinitionContactProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionContact); overload; {b\}
    function ParseStructureDefinitionMapping(obj : TTurtleComplex) : TFhirStructureDefinitionMapping; overload; {b\}
    procedure ParseStructureDefinitionMappingProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionMapping); overload; {b\}
    function ParseStructureDefinitionSnapshot(obj : TTurtleComplex) : TFhirStructureDefinitionSnapshot; overload; {b\}
    procedure ParseStructureDefinitionSnapshotProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionSnapshot); overload; {b\}
    function ParseStructureDefinitionDifferential(obj : TTurtleComplex) : TFhirStructureDefinitionDifferential; overload; {b\}
    procedure ParseStructureDefinitionDifferentialProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionDifferential); overload; {b\}
    function ParseStructureDefinition(obj : TTurtleComplex) : TFhirStructureDefinition; overload;
    procedure ParseStructureDefinitionProperties(obj : TTurtleComplex; result : TFhirStructureDefinition); overload;
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
    function ParseSubscriptionChannel(obj : TTurtleComplex) : TFhirSubscriptionChannel; overload; {b\}
    procedure ParseSubscriptionChannelProperties(obj : TTurtleComplex; result : TFhirSubscriptionChannel); overload; {b\}
    function ParseSubscription(obj : TTurtleComplex) : TFhirSubscription; overload;
    procedure ParseSubscriptionProperties(obj : TTurtleComplex; result : TFhirSubscription); overload;
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
    function ParseSubstanceInstance(obj : TTurtleComplex) : TFhirSubstanceInstance; overload; {b\}
    procedure ParseSubstanceInstanceProperties(obj : TTurtleComplex; result : TFhirSubstanceInstance); overload; {b\}
    function ParseSubstanceIngredient(obj : TTurtleComplex) : TFhirSubstanceIngredient; overload; {b\}
    procedure ParseSubstanceIngredientProperties(obj : TTurtleComplex; result : TFhirSubstanceIngredient); overload; {b\}
    function ParseSubstance(obj : TTurtleComplex) : TFhirSubstance; overload;
    procedure ParseSubstanceProperties(obj : TTurtleComplex; result : TFhirSubstance); overload;
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
    function ParseSupplyDelivery(obj : TTurtleComplex) : TFhirSupplyDelivery; overload;
    procedure ParseSupplyDeliveryProperties(obj : TTurtleComplex; result : TFhirSupplyDelivery); overload;
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    function ParseSupplyRequestWhen(obj : TTurtleComplex) : TFhirSupplyRequestWhen; overload; {b\}
    procedure ParseSupplyRequestWhenProperties(obj : TTurtleComplex; result : TFhirSupplyRequestWhen); overload; {b\}
    function ParseSupplyRequest(obj : TTurtleComplex) : TFhirSupplyRequest; overload;
    procedure ParseSupplyRequestProperties(obj : TTurtleComplex; result : TFhirSupplyRequest); overload;
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
    function ParseTestScriptContact(obj : TTurtleComplex) : TFhirTestScriptContact; overload; {b\}
    procedure ParseTestScriptContactProperties(obj : TTurtleComplex; result : TFhirTestScriptContact); overload; {b\}
    function ParseTestScriptMetadata(obj : TTurtleComplex) : TFhirTestScriptMetadata; overload; {b\}
    procedure ParseTestScriptMetadataProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadata); overload; {b\}
    function ParseTestScriptMetadataLink(obj : TTurtleComplex) : TFhirTestScriptMetadataLink; overload; {b\}
    procedure ParseTestScriptMetadataLinkProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadataLink); overload; {b\}
    function ParseTestScriptMetadataCapability(obj : TTurtleComplex) : TFhirTestScriptMetadataCapability; overload; {b\}
    procedure ParseTestScriptMetadataCapabilityProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadataCapability); overload; {b\}
    function ParseTestScriptFixture(obj : TTurtleComplex) : TFhirTestScriptFixture; overload; {b\}
    procedure ParseTestScriptFixtureProperties(obj : TTurtleComplex; result : TFhirTestScriptFixture); overload; {b\}
    function ParseTestScriptVariable(obj : TTurtleComplex) : TFhirTestScriptVariable; overload; {b\}
    procedure ParseTestScriptVariableProperties(obj : TTurtleComplex; result : TFhirTestScriptVariable); overload; {b\}
    function ParseTestScriptSetup(obj : TTurtleComplex) : TFhirTestScriptSetup; overload; {b\}
    procedure ParseTestScriptSetupProperties(obj : TTurtleComplex; result : TFhirTestScriptSetup); overload; {b\}
    function ParseTestScriptSetupAction(obj : TTurtleComplex) : TFhirTestScriptSetupAction; overload; {b\}
    procedure ParseTestScriptSetupActionProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupAction); overload; {b\}
    function ParseTestScriptSetupActionOperation(obj : TTurtleComplex) : TFhirTestScriptSetupActionOperation; overload; {b\}
    procedure ParseTestScriptSetupActionOperationProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionOperation); overload; {b\}
    function ParseTestScriptSetupActionOperationRequestHeader(obj : TTurtleComplex) : TFhirTestScriptSetupActionOperationRequestHeader; overload; {b\}
    procedure ParseTestScriptSetupActionOperationRequestHeaderProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionOperationRequestHeader); overload; {b\}
    function ParseTestScriptSetupActionAssert(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssert; overload; {b\}
    procedure ParseTestScriptSetupActionAssertProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionAssert); overload; {b\}
    function ParseTestScriptTest(obj : TTurtleComplex) : TFhirTestScriptTest; overload; {b\}
    procedure ParseTestScriptTestProperties(obj : TTurtleComplex; result : TFhirTestScriptTest); overload; {b\}
    function ParseTestScriptTestAction(obj : TTurtleComplex) : TFhirTestScriptTestAction; overload; {b\}
    procedure ParseTestScriptTestActionProperties(obj : TTurtleComplex; result : TFhirTestScriptTestAction); overload; {b\}
    function ParseTestScriptTeardown(obj : TTurtleComplex) : TFhirTestScriptTeardown; overload; {b\}
    procedure ParseTestScriptTeardownProperties(obj : TTurtleComplex; result : TFhirTestScriptTeardown); overload; {b\}
    function ParseTestScriptTeardownAction(obj : TTurtleComplex) : TFhirTestScriptTeardownAction; overload; {b\}
    procedure ParseTestScriptTeardownActionProperties(obj : TTurtleComplex; result : TFhirTestScriptTeardownAction); overload; {b\}
    function ParseTestScript(obj : TTurtleComplex) : TFhirTestScript; overload;
    procedure ParseTestScriptProperties(obj : TTurtleComplex; result : TFhirTestScript); overload;
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
    function ParseValueSetContact(obj : TTurtleComplex) : TFhirValueSetContact; overload; {b\}
    procedure ParseValueSetContactProperties(obj : TTurtleComplex; result : TFhirValueSetContact); overload; {b\}
    function ParseValueSetCodeSystem(obj : TTurtleComplex) : TFhirValueSetCodeSystem; overload; {b\}
    procedure ParseValueSetCodeSystemProperties(obj : TTurtleComplex; result : TFhirValueSetCodeSystem); overload; {b\}
    function ParseValueSetCodeSystemConcept(obj : TTurtleComplex) : TFhirValueSetCodeSystemConcept; overload; {b\}
    procedure ParseValueSetCodeSystemConceptProperties(obj : TTurtleComplex; result : TFhirValueSetCodeSystemConcept); overload; {b\}
    function ParseValueSetCodeSystemConceptDesignation(obj : TTurtleComplex) : TFhirValueSetCodeSystemConceptDesignation; overload; {b\}
    procedure ParseValueSetCodeSystemConceptDesignationProperties(obj : TTurtleComplex; result : TFhirValueSetCodeSystemConceptDesignation); overload; {b\}
    function ParseValueSetCompose(obj : TTurtleComplex) : TFhirValueSetCompose; overload; {b\}
    procedure ParseValueSetComposeProperties(obj : TTurtleComplex; result : TFhirValueSetCompose); overload; {b\}
    function ParseValueSetComposeInclude(obj : TTurtleComplex) : TFhirValueSetComposeInclude; overload; {b\}
    procedure ParseValueSetComposeIncludeProperties(obj : TTurtleComplex; result : TFhirValueSetComposeInclude); overload; {b\}
    function ParseValueSetComposeIncludeConcept(obj : TTurtleComplex) : TFhirValueSetComposeIncludeConcept; overload; {b\}
    procedure ParseValueSetComposeIncludeConceptProperties(obj : TTurtleComplex; result : TFhirValueSetComposeIncludeConcept); overload; {b\}
    function ParseValueSetComposeIncludeFilter(obj : TTurtleComplex) : TFhirValueSetComposeIncludeFilter; overload; {b\}
    procedure ParseValueSetComposeIncludeFilterProperties(obj : TTurtleComplex; result : TFhirValueSetComposeIncludeFilter); overload; {b\}
    function ParseValueSetExpansion(obj : TTurtleComplex) : TFhirValueSetExpansion; overload; {b\}
    procedure ParseValueSetExpansionProperties(obj : TTurtleComplex; result : TFhirValueSetExpansion); overload; {b\}
    function ParseValueSetExpansionParameter(obj : TTurtleComplex) : TFhirValueSetExpansionParameter; overload; {b\}
    procedure ParseValueSetExpansionParameterProperties(obj : TTurtleComplex; result : TFhirValueSetExpansionParameter); overload; {b\}
    function ParseValueSetExpansionContains(obj : TTurtleComplex) : TFhirValueSetExpansionContains; overload; {b\}
    procedure ParseValueSetExpansionContainsProperties(obj : TTurtleComplex; result : TFhirValueSetExpansionContains); overload; {b\}
    function ParseValueSet(obj : TTurtleComplex) : TFhirValueSet; overload;
    procedure ParseValueSetProperties(obj : TTurtleComplex; result : TFhirValueSet); overload;
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    function ParseVisionPrescriptionDispense(obj : TTurtleComplex) : TFhirVisionPrescriptionDispense; overload; {b\}
    procedure ParseVisionPrescriptionDispenseProperties(obj : TTurtleComplex; result : TFhirVisionPrescriptionDispense); overload; {b\}
    function ParseVisionPrescription(obj : TTurtleComplex) : TFhirVisionPrescription; overload;
    procedure ParseVisionPrescriptionProperties(obj : TTurtleComplex; result : TFhirVisionPrescription); overload;
{$ENDIF FHIR_VISIONPRESCRIPTION}
    function ParseResource(obj : TTurtleComplex) : TFhirResource; override;
    function ParseDataType(obj : TTurtleComplex; name : String; type_ : TFHIRTypeClass) : TFHIRType; override;
  public
    function ParseFragment(obj : TTurtleComplex; type_ : String) : TFHIRObject;  overload;
  end;

  TFHIRTurtleComposer = class (TFHIRTurtleComposerBase2)
  protected
    procedure ComposeElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElement; useType : boolean; index : integer);


    procedure ComposeBackboneElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBackboneElement; useType : boolean; index : integer);


    Procedure ComposeEnum(parent :  TTurtleComplex; parentType, name : String; value : TFhirEnum; Const aNames, aSystems : Array Of String; useType : boolean; index : integer);
    Procedure ComposeDateTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirDateTime; useType : boolean; index : integer);
    Procedure ComposeDate(parent :  TTurtleComplex; parentType, name : String; value : TFhirDate; useType : boolean; index : integer);
    Procedure ComposeString(parent :  TTurtleComplex; parentType, name : String; value : TFhirString; useType : boolean; index : integer);
    Procedure ComposeInteger(parent :  TTurtleComplex; parentType, name : String; value : TFhirInteger; useType : boolean; index : integer);
    Procedure ComposeUri(parent :  TTurtleComplex; parentType, name : String; value : TFhirUri; useType : boolean; index : integer);
    Procedure ComposeInstant(parent :  TTurtleComplex; parentType, name : String; value : TFhirInstant; useType : boolean; index : integer);
    Procedure ComposeBoolean(parent :  TTurtleComplex; parentType, name : String; value : TFhirBoolean; useType : boolean; index : integer);
    Procedure ComposeBase64Binary(parent :  TTurtleComplex; parentType, name : String; value : TFhirBase64Binary; useType : boolean; index : integer);
    Procedure ComposeTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirTime; useType : boolean; index : integer);
    Procedure ComposeDecimal(parent :  TTurtleComplex; parentType, name : String; value : TFhirDecimal; useType : boolean; index : integer);
    Procedure ComposeCode(parent :  TTurtleComplex; parentType, name : String; value : TFhirCode; useType : boolean; index : integer);
    Procedure ComposeOid(parent :  TTurtleComplex; parentType, name : String; value : TFhirOid; useType : boolean; index : integer);
    Procedure ComposeUuid(parent :  TTurtleComplex; parentType, name : String; value : TFhirUuid; useType : boolean; index : integer);
    Procedure ComposeMarkdown(parent :  TTurtleComplex; parentType, name : String; value : TFhirMarkdown; useType : boolean; index : integer);
    Procedure ComposeUnsignedInt(parent :  TTurtleComplex; parentType, name : String; value : TFhirUnsignedInt; useType : boolean; index : integer);
    Procedure ComposeId(parent :  TTurtleComplex; parentType, name : String; value : TFhirId; useType : boolean; index : integer);
    Procedure ComposePositiveInt(parent :  TTurtleComplex; parentType, name : String; value : TFhirPositiveInt; useType : boolean; index : integer);


    Procedure ComposeResource(this : TTurtleComplex; parentType, name : String; elem : TFhirResource; useType : boolean; index : integer); overload;
{$IFDEF FHIR_PARAMETERS}
    procedure ComposeParametersParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirParametersParameter; useType : boolean; index : integer);
    procedure ComposeParameters(parent :  TTurtleComplex; parentType, name : String; elem : TFhirParameters; useType : boolean; index : integer);
{$ENDIF FHIR_PARAMETERS}
    Procedure ComposeDomainResource(this : TTurtleComplex; parentType, name : String; elem : TFhirDomainResource; useType : boolean; index : integer); overload;


    procedure ComposeExtension(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExtension; useType : boolean; index : integer);
    procedure ComposeNarrative(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNarrative; useType : boolean; index : integer);
    procedure ComposeIdentifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirIdentifier; useType : boolean; index : integer);
    procedure ComposeCoding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoding; useType : boolean; index : integer);
    procedure ComposeReference(parent :  TTurtleComplex; parentType, name : String; elem : TFhirReference; useType : boolean; index : integer);
    procedure ComposeSignature(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSignature; useType : boolean; index : integer);
    procedure ComposeSampledData(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSampledData; useType : boolean; index : integer);
    procedure ComposePeriod(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPeriod; useType : boolean; index : integer);
    procedure ComposeQuantity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuantity; useType : boolean; index : integer);
    procedure ComposeAttachment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAttachment; useType : boolean; index : integer);
    procedure ComposeRatio(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRatio; useType : boolean; index : integer);
    procedure ComposeRange(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRange; useType : boolean; index : integer);
    procedure ComposeAnnotation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAnnotation; useType : boolean; index : integer);
    procedure ComposeCodeableConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeableConcept; useType : boolean; index : integer);
    procedure ComposeHumanName(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHumanName; useType : boolean; index : integer);
    procedure ComposeMeta(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeta; useType : boolean; index : integer);
    procedure ComposeContactPoint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContactPoint; useType : boolean; index : integer);
    procedure ComposeAddress(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAddress; useType : boolean; index : integer);
    procedure ComposeElementDefinitionSlicing(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionSlicing; useType : boolean; index : integer);
    procedure ComposeElementDefinitionBase(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionBase; useType : boolean; index : integer);
    procedure ComposeElementDefinitionType(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionType; useType : boolean; index : integer);
    procedure ComposeElementDefinitionConstraint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionConstraint; useType : boolean; index : integer);
    procedure ComposeElementDefinitionBinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionBinding; useType : boolean; index : integer);
    procedure ComposeElementDefinitionMapping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionMapping; useType : boolean; index : integer);
    procedure ComposeElementDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinition; useType : boolean; index : integer);
    procedure ComposeTimingRepeat(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTimingRepeat; useType : boolean; index : integer);
    procedure ComposeTiming(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTiming; useType : boolean; index : integer);


{$IFDEF FHIR_ACCOUNT}
    procedure ComposeAccount(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAccount; useType : boolean; index : integer);
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    procedure ComposeAllergyIntoleranceReaction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAllergyIntoleranceReaction; useType : boolean; index : integer);
    procedure ComposeAllergyIntolerance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAllergyIntolerance; useType : boolean; index : integer);
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    procedure ComposeAppointmentParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointmentParticipant; useType : boolean; index : integer);
    procedure ComposeAppointment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointment; useType : boolean; index : integer);
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    procedure ComposeAppointmentResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointmentResponse; useType : boolean; index : integer);
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
    procedure ComposeAuditEventEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventEvent; useType : boolean; index : integer);
    procedure ComposeAuditEventParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventParticipant; useType : boolean; index : integer);
    procedure ComposeAuditEventParticipantNetwork(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventParticipantNetwork; useType : boolean; index : integer);
    procedure ComposeAuditEventSource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventSource; useType : boolean; index : integer);
    procedure ComposeAuditEventObject(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventObject; useType : boolean; index : integer);
    procedure ComposeAuditEventObjectDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventObjectDetail; useType : boolean; index : integer);
    procedure ComposeAuditEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEvent; useType : boolean; index : integer);
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    procedure ComposeBasic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBasic; useType : boolean; index : integer);
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    procedure ComposeBinary(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBinary; useType : boolean; index : integer);
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
    procedure ComposeBodySite(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBodySite; useType : boolean; index : integer);
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
    procedure ComposeBundleLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleLink; useType : boolean; index : integer);
    procedure ComposeBundleEntry(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntry; useType : boolean; index : integer);
    procedure ComposeBundleEntrySearch(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntrySearch; useType : boolean; index : integer);
    procedure ComposeBundleEntryRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntryRequest; useType : boolean; index : integer);
    procedure ComposeBundleEntryResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntryResponse; useType : boolean; index : integer);
    procedure ComposeBundle(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundle; useType : boolean; index : integer);
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
    procedure ComposeCarePlanRelatedPlan(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlanRelatedPlan; useType : boolean; index : integer);
    procedure ComposeCarePlanParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlanParticipant; useType : boolean; index : integer);
    procedure ComposeCarePlanActivity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlanActivity; useType : boolean; index : integer);
    procedure ComposeCarePlanActivityDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlanActivityDetail; useType : boolean; index : integer);
    procedure ComposeCarePlan(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlan; useType : boolean; index : integer);
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
    procedure ComposeClaimPayee(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimPayee; useType : boolean; index : integer);
    procedure ComposeClaimDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimDiagnosis; useType : boolean; index : integer);
    procedure ComposeClaimCoverage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimCoverage; useType : boolean; index : integer);
    procedure ComposeClaimItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItem; useType : boolean; index : integer);
    procedure ComposeClaimItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItemDetail; useType : boolean; index : integer);
    procedure ComposeClaimItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItemDetailSubDetail; useType : boolean; index : integer);
    procedure ComposeClaimItemProsthesis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItemProsthesis; useType : boolean; index : integer);
    procedure ComposeClaimMissingTeeth(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimMissingTeeth; useType : boolean; index : integer);
    procedure ComposeClaim(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaim; useType : boolean; index : integer);
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    procedure ComposeClaimResponseItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItem; useType : boolean; index : integer);
    procedure ComposeClaimResponseItemAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemAdjudication; useType : boolean; index : integer);
    procedure ComposeClaimResponseItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemDetail; useType : boolean; index : integer);
    procedure ComposeClaimResponseItemDetailAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemDetailAdjudication; useType : boolean; index : integer);
    procedure ComposeClaimResponseItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemDetailSubDetail; useType : boolean; index : integer);
    procedure ComposeClaimResponseItemDetailSubDetailAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemDetailSubDetailAdjudication; useType : boolean; index : integer);
    procedure ComposeClaimResponseAddItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItem; useType : boolean; index : integer);
    procedure ComposeClaimResponseAddItemAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItemAdjudication; useType : boolean; index : integer);
    procedure ComposeClaimResponseAddItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItemDetail; useType : boolean; index : integer);
    procedure ComposeClaimResponseAddItemDetailAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItemDetailAdjudication; useType : boolean; index : integer);
    procedure ComposeClaimResponseError(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseError; useType : boolean; index : integer);
    procedure ComposeClaimResponseNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseNote; useType : boolean; index : integer);
    procedure ComposeClaimResponseCoverage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseCoverage; useType : boolean; index : integer);
    procedure ComposeClaimResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponse; useType : boolean; index : integer);
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    procedure ComposeClinicalImpressionInvestigations(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpressionInvestigations; useType : boolean; index : integer);
    procedure ComposeClinicalImpressionFinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpressionFinding; useType : boolean; index : integer);
    procedure ComposeClinicalImpressionRuledOut(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpressionRuledOut; useType : boolean; index : integer);
    procedure ComposeClinicalImpression(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpression; useType : boolean; index : integer);
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
    procedure ComposeCommunicationPayload(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationPayload; useType : boolean; index : integer);
    procedure ComposeCommunication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunication; useType : boolean; index : integer);
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    procedure ComposeCommunicationRequestPayload(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationRequestPayload; useType : boolean; index : integer);
    procedure ComposeCommunicationRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationRequest; useType : boolean; index : integer);
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
    procedure ComposeCompositionAttester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionAttester; useType : boolean; index : integer);
    procedure ComposeCompositionEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionEvent; useType : boolean; index : integer);
    procedure ComposeCompositionSection(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionSection; useType : boolean; index : integer);
    procedure ComposeComposition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirComposition; useType : boolean; index : integer);
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    procedure ComposeConceptMapContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapContact; useType : boolean; index : integer);
    procedure ComposeConceptMapElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapElement; useType : boolean; index : integer);
    procedure ComposeConceptMapElementTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapElementTarget; useType : boolean; index : integer);
    procedure ComposeConceptMapElementTargetDependsOn(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapElementTargetDependsOn; useType : boolean; index : integer);
    procedure ComposeConceptMap(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMap; useType : boolean; index : integer);
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    procedure ComposeConditionStage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConditionStage; useType : boolean; index : integer);
    procedure ComposeConditionEvidence(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConditionEvidence; useType : boolean; index : integer);
    procedure ComposeCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCondition; useType : boolean; index : integer);
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
    procedure ComposeConformanceContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceContact; useType : boolean; index : integer);
    procedure ComposeConformanceSoftware(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceSoftware; useType : boolean; index : integer);
    procedure ComposeConformanceImplementation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceImplementation; useType : boolean; index : integer);
    procedure ComposeConformanceRest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceRest; useType : boolean; index : integer);
    procedure ComposeConformanceRestSecurity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceRestSecurity; useType : boolean; index : integer);
    procedure ComposeConformanceRestSecurityCertificate(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceRestSecurityCertificate; useType : boolean; index : integer);
    procedure ComposeConformanceRestResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceRestResource; useType : boolean; index : integer);
    procedure ComposeConformanceRestResourceInteraction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceRestResourceInteraction; useType : boolean; index : integer);
    procedure ComposeConformanceRestResourceSearchParam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceRestResourceSearchParam; useType : boolean; index : integer);
    procedure ComposeConformanceRestInteraction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceRestInteraction; useType : boolean; index : integer);
    procedure ComposeConformanceRestOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceRestOperation; useType : boolean; index : integer);
    procedure ComposeConformanceMessaging(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceMessaging; useType : boolean; index : integer);
    procedure ComposeConformanceMessagingEndpoint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceMessagingEndpoint; useType : boolean; index : integer);
    procedure ComposeConformanceMessagingEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceMessagingEvent; useType : boolean; index : integer);
    procedure ComposeConformanceDocument(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceDocument; useType : boolean; index : integer);
    procedure ComposeConformance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformance; useType : boolean; index : integer);
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
    procedure ComposeContractActor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractActor; useType : boolean; index : integer);
    procedure ComposeContractValuedItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractValuedItem; useType : boolean; index : integer);
    procedure ComposeContractSigner(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractSigner; useType : boolean; index : integer);
    procedure ComposeContractTerm(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTerm; useType : boolean; index : integer);
    procedure ComposeContractTermActor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermActor; useType : boolean; index : integer);
    procedure ComposeContractTermValuedItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermValuedItem; useType : boolean; index : integer);
    procedure ComposeContractFriendly(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractFriendly; useType : boolean; index : integer);
    procedure ComposeContractLegal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractLegal; useType : boolean; index : integer);
    procedure ComposeContractRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractRule; useType : boolean; index : integer);
    procedure ComposeContract(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContract; useType : boolean; index : integer);
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    procedure ComposeCoverage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverage; useType : boolean; index : integer);
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
    procedure ComposeDataElementContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataElementContact; useType : boolean; index : integer);
    procedure ComposeDataElementMapping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataElementMapping; useType : boolean; index : integer);
    procedure ComposeDataElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataElement; useType : boolean; index : integer);
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
    procedure ComposeDetectedIssueMitigation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDetectedIssueMitigation; useType : boolean; index : integer);
    procedure ComposeDetectedIssue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDetectedIssue; useType : boolean; index : integer);
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    procedure ComposeDevice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDevice; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
    procedure ComposeDeviceComponentProductionSpecification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceComponentProductionSpecification; useType : boolean; index : integer);
    procedure ComposeDeviceComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceComponent; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
    procedure ComposeDeviceMetricCalibration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceMetricCalibration; useType : boolean; index : integer);
    procedure ComposeDeviceMetric(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceMetric; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
    procedure ComposeDeviceUseRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceUseRequest; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
    procedure ComposeDeviceUseStatement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceUseStatement; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
    procedure ComposeDiagnosticOrderEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticOrderEvent; useType : boolean; index : integer);
    procedure ComposeDiagnosticOrderItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticOrderItem; useType : boolean; index : integer);
    procedure ComposeDiagnosticOrder(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticOrder; useType : boolean; index : integer);
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    procedure ComposeDiagnosticReportImage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticReportImage; useType : boolean; index : integer);
    procedure ComposeDiagnosticReport(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticReport; useType : boolean; index : integer);
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    procedure ComposeDocumentManifestContent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentManifestContent; useType : boolean; index : integer);
    procedure ComposeDocumentManifestRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentManifestRelated; useType : boolean; index : integer);
    procedure ComposeDocumentManifest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentManifest; useType : boolean; index : integer);
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    procedure ComposeDocumentReferenceRelatesTo(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceRelatesTo; useType : boolean; index : integer);
    procedure ComposeDocumentReferenceContent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceContent; useType : boolean; index : integer);
    procedure ComposeDocumentReferenceContext(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceContext; useType : boolean; index : integer);
    procedure ComposeDocumentReferenceContextRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceContextRelated; useType : boolean; index : integer);
    procedure ComposeDocumentReference(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReference; useType : boolean; index : integer);
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
    procedure ComposeEligibilityRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEligibilityRequest; useType : boolean; index : integer);
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
    procedure ComposeEligibilityResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEligibilityResponse; useType : boolean; index : integer);
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
    procedure ComposeEncounterStatusHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterStatusHistory; useType : boolean; index : integer);
    procedure ComposeEncounterParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterParticipant; useType : boolean; index : integer);
    procedure ComposeEncounterHospitalization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterHospitalization; useType : boolean; index : integer);
    procedure ComposeEncounterLocation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterLocation; useType : boolean; index : integer);
    procedure ComposeEncounter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounter; useType : boolean; index : integer);
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    procedure ComposeEnrollmentRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEnrollmentRequest; useType : boolean; index : integer);
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    procedure ComposeEnrollmentResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEnrollmentResponse; useType : boolean; index : integer);
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    procedure ComposeEpisodeOfCareStatusHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCareStatusHistory; useType : boolean; index : integer);
    procedure ComposeEpisodeOfCareCareTeam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCareCareTeam; useType : boolean; index : integer);
    procedure ComposeEpisodeOfCare(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCare; useType : boolean; index : integer);
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    procedure ComposeExplanationOfBenefit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefit; useType : boolean; index : integer);
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    procedure ComposeFamilyMemberHistoryCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFamilyMemberHistoryCondition; useType : boolean; index : integer);
    procedure ComposeFamilyMemberHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFamilyMemberHistory; useType : boolean; index : integer);
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    procedure ComposeFlag(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFlag; useType : boolean; index : integer);
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
    procedure ComposeGoalOutcome(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGoalOutcome; useType : boolean; index : integer);
    procedure ComposeGoal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGoal; useType : boolean; index : integer);
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
    procedure ComposeGroupCharacteristic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroupCharacteristic; useType : boolean; index : integer);
    procedure ComposeGroupMember(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroupMember; useType : boolean; index : integer);
    procedure ComposeGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroup; useType : boolean; index : integer);
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
    procedure ComposeHealthcareServiceServiceType(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareServiceServiceType; useType : boolean; index : integer);
    procedure ComposeHealthcareServiceAvailableTime(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareServiceAvailableTime; useType : boolean; index : integer);
    procedure ComposeHealthcareServiceNotAvailable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareServiceNotAvailable; useType : boolean; index : integer);
    procedure ComposeHealthcareService(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareService; useType : boolean; index : integer);
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
    procedure ComposeImagingObjectSelectionStudy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingObjectSelectionStudy; useType : boolean; index : integer);
    procedure ComposeImagingObjectSelectionStudySeries(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingObjectSelectionStudySeries; useType : boolean; index : integer);
    procedure ComposeImagingObjectSelectionStudySeriesInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingObjectSelectionStudySeriesInstance; useType : boolean; index : integer);
    procedure ComposeImagingObjectSelectionStudySeriesInstanceFrames(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames; useType : boolean; index : integer);
    procedure ComposeImagingObjectSelection(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingObjectSelection; useType : boolean; index : integer);
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
    procedure ComposeImagingStudySeries(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudySeries; useType : boolean; index : integer);
    procedure ComposeImagingStudySeriesInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudySeriesInstance; useType : boolean; index : integer);
    procedure ComposeImagingStudy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudy; useType : boolean; index : integer);
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    procedure ComposeImmunizationExplanation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationExplanation; useType : boolean; index : integer);
    procedure ComposeImmunizationReaction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationReaction; useType : boolean; index : integer);
    procedure ComposeImmunizationVaccinationProtocol(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationVaccinationProtocol; useType : boolean; index : integer);
    procedure ComposeImmunization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunization; useType : boolean; index : integer);
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    procedure ComposeImmunizationRecommendationRecommendation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendation; useType : boolean; index : integer);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendationDateCriterion; useType : boolean; index : integer);
    procedure ComposeImmunizationRecommendationRecommendationProtocol(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendationProtocol; useType : boolean; index : integer);
    procedure ComposeImmunizationRecommendation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendation; useType : boolean; index : integer);
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    procedure ComposeImplementationGuideContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideContact; useType : boolean; index : integer);
    procedure ComposeImplementationGuideDependency(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDependency; useType : boolean; index : integer);
    procedure ComposeImplementationGuidePackage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuidePackage; useType : boolean; index : integer);
    procedure ComposeImplementationGuidePackageResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuidePackageResource; useType : boolean; index : integer);
    procedure ComposeImplementationGuideGlobal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideGlobal; useType : boolean; index : integer);
    procedure ComposeImplementationGuidePage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuidePage; useType : boolean; index : integer);
    procedure ComposeImplementationGuide(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuide; useType : boolean; index : integer);
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
    procedure ComposeListEntry(parent :  TTurtleComplex; parentType, name : String; elem : TFhirListEntry; useType : boolean; index : integer);
    procedure ComposeList(parent :  TTurtleComplex; parentType, name : String; elem : TFhirList; useType : boolean; index : integer);
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    procedure ComposeLocationPosition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLocationPosition; useType : boolean; index : integer);
    procedure ComposeLocation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLocation; useType : boolean; index : integer);
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
    procedure ComposeMedia(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedia; useType : boolean; index : integer);
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
    procedure ComposeMedicationProduct(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationProduct; useType : boolean; index : integer);
    procedure ComposeMedicationProductIngredient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationProductIngredient; useType : boolean; index : integer);
    procedure ComposeMedicationProductBatch(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationProductBatch; useType : boolean; index : integer);
    procedure ComposeMedicationPackage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationPackage; useType : boolean; index : integer);
    procedure ComposeMedicationPackageContent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationPackageContent; useType : boolean; index : integer);
    procedure ComposeMedication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedication; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    procedure ComposeMedicationAdministrationDosage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationAdministrationDosage; useType : boolean; index : integer);
    procedure ComposeMedicationAdministration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationAdministration; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    procedure ComposeMedicationDispenseDosageInstruction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispenseDosageInstruction; useType : boolean; index : integer);
    procedure ComposeMedicationDispenseSubstitution(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispenseSubstitution; useType : boolean; index : integer);
    procedure ComposeMedicationDispense(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispense; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
    procedure ComposeMedicationOrderDosageInstruction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationOrderDosageInstruction; useType : boolean; index : integer);
    procedure ComposeMedicationOrderDispenseRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationOrderDispenseRequest; useType : boolean; index : integer);
    procedure ComposeMedicationOrderSubstitution(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationOrderSubstitution; useType : boolean; index : integer);
    procedure ComposeMedicationOrder(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationOrder; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
    procedure ComposeMedicationStatementDosage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationStatementDosage; useType : boolean; index : integer);
    procedure ComposeMedicationStatement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationStatement; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
    procedure ComposeMessageHeaderResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderResponse; useType : boolean; index : integer);
    procedure ComposeMessageHeaderSource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderSource; useType : boolean; index : integer);
    procedure ComposeMessageHeaderDestination(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderDestination; useType : boolean; index : integer);
    procedure ComposeMessageHeader(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeader; useType : boolean; index : integer);
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
    procedure ComposeNamingSystemContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNamingSystemContact; useType : boolean; index : integer);
    procedure ComposeNamingSystemUniqueId(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNamingSystemUniqueId; useType : boolean; index : integer);
    procedure ComposeNamingSystem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNamingSystem; useType : boolean; index : integer);
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
    procedure ComposeNutritionOrderOralDiet(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDiet; useType : boolean; index : integer);
    procedure ComposeNutritionOrderOralDietNutrient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDietNutrient; useType : boolean; index : integer);
    procedure ComposeNutritionOrderOralDietTexture(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDietTexture; useType : boolean; index : integer);
    procedure ComposeNutritionOrderSupplement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderSupplement; useType : boolean; index : integer);
    procedure ComposeNutritionOrderEnteralFormula(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderEnteralFormula; useType : boolean; index : integer);
    procedure ComposeNutritionOrderEnteralFormulaAdministration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderEnteralFormulaAdministration; useType : boolean; index : integer);
    procedure ComposeNutritionOrder(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrder; useType : boolean; index : integer);
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
    procedure ComposeObservationReferenceRange(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationReferenceRange; useType : boolean; index : integer);
    procedure ComposeObservationRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationRelated; useType : boolean; index : integer);
    procedure ComposeObservationComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationComponent; useType : boolean; index : integer);
    procedure ComposeObservation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservation; useType : boolean; index : integer);
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    procedure ComposeOperationDefinitionContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionContact; useType : boolean; index : integer);
    procedure ComposeOperationDefinitionParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionParameter; useType : boolean; index : integer);
    procedure ComposeOperationDefinitionParameterBinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionParameterBinding; useType : boolean; index : integer);
    procedure ComposeOperationDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    procedure ComposeOperationOutcomeIssue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationOutcomeIssue; useType : boolean; index : integer);
    procedure ComposeOperationOutcome(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationOutcome; useType : boolean; index : integer);
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
    procedure ComposeOrderWhen(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrderWhen; useType : boolean; index : integer);
    procedure ComposeOrder(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrder; useType : boolean; index : integer);
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
    procedure ComposeOrderResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrderResponse; useType : boolean; index : integer);
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
    procedure ComposeOrganizationContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrganizationContact; useType : boolean; index : integer);
    procedure ComposeOrganization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrganization; useType : boolean; index : integer);
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
    procedure ComposePatientContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientContact; useType : boolean; index : integer);
    procedure ComposePatientAnimal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientAnimal; useType : boolean; index : integer);
    procedure ComposePatientCommunication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientCommunication; useType : boolean; index : integer);
    procedure ComposePatientLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientLink; useType : boolean; index : integer);
    procedure ComposePatient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatient; useType : boolean; index : integer);
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    procedure ComposePaymentNotice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentNotice; useType : boolean; index : integer);
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    procedure ComposePaymentReconciliationDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliationDetail; useType : boolean; index : integer);
    procedure ComposePaymentReconciliationNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliationNote; useType : boolean; index : integer);
    procedure ComposePaymentReconciliation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliation; useType : boolean; index : integer);
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
    procedure ComposePersonLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPersonLink; useType : boolean; index : integer);
    procedure ComposePerson(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPerson; useType : boolean; index : integer);
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
    procedure ComposePractitionerPractitionerRole(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerPractitionerRole; useType : boolean; index : integer);
    procedure ComposePractitionerQualification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerQualification; useType : boolean; index : integer);
    procedure ComposePractitioner(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitioner; useType : boolean; index : integer);
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
    procedure ComposeProcedurePerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedurePerformer; useType : boolean; index : integer);
    procedure ComposeProcedureFocalDevice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedureFocalDevice; useType : boolean; index : integer);
    procedure ComposeProcedure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedure; useType : boolean; index : integer);
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
    procedure ComposeProcedureRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedureRequest; useType : boolean; index : integer);
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
    procedure ComposeProcessRequestItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcessRequestItem; useType : boolean; index : integer);
    procedure ComposeProcessRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcessRequest; useType : boolean; index : integer);
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
    procedure ComposeProcessResponseNotes(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcessResponseNotes; useType : boolean; index : integer);
    procedure ComposeProcessResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcessResponse; useType : boolean; index : integer);
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
    procedure ComposeProvenanceAgent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenanceAgent; useType : boolean; index : integer);
    procedure ComposeProvenanceAgentRelatedAgent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenanceAgentRelatedAgent; useType : boolean; index : integer);
    procedure ComposeProvenanceEntity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenanceEntity; useType : boolean; index : integer);
    procedure ComposeProvenance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenance; useType : boolean; index : integer);
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    procedure ComposeQuestionnaireGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireGroup; useType : boolean; index : integer);
    procedure ComposeQuestionnaireGroupQuestion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireGroupQuestion; useType : boolean; index : integer);
    procedure ComposeQuestionnaire(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaire; useType : boolean; index : integer);
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    procedure ComposeQuestionnaireResponseGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponseGroup; useType : boolean; index : integer);
    procedure ComposeQuestionnaireResponseGroupQuestion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponseGroupQuestion; useType : boolean; index : integer);
    procedure ComposeQuestionnaireResponseGroupQuestionAnswer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponseGroupQuestionAnswer; useType : boolean; index : integer);
    procedure ComposeQuestionnaireResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponse; useType : boolean; index : integer);
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
    procedure ComposeReferralRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirReferralRequest; useType : boolean; index : integer);
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
    procedure ComposeRelatedPerson(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRelatedPerson; useType : boolean; index : integer);
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
    procedure ComposeRiskAssessmentPrediction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskAssessmentPrediction; useType : boolean; index : integer);
    procedure ComposeRiskAssessment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskAssessment; useType : boolean; index : integer);
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
    procedure ComposeSchedule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSchedule; useType : boolean; index : integer);
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    procedure ComposeSearchParameterContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSearchParameterContact; useType : boolean; index : integer);
    procedure ComposeSearchParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSearchParameter; useType : boolean; index : integer);
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
    procedure ComposeSlot(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSlot; useType : boolean; index : integer);
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    procedure ComposeSpecimenCollection(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenCollection; useType : boolean; index : integer);
    procedure ComposeSpecimenTreatment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenTreatment; useType : boolean; index : integer);
    procedure ComposeSpecimenContainer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenContainer; useType : boolean; index : integer);
    procedure ComposeSpecimen(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimen; useType : boolean; index : integer);
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    procedure ComposeStructureDefinitionContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionContact; useType : boolean; index : integer);
    procedure ComposeStructureDefinitionMapping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionMapping; useType : boolean; index : integer);
    procedure ComposeStructureDefinitionSnapshot(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionSnapshot; useType : boolean; index : integer);
    procedure ComposeStructureDefinitionDifferential(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionDifferential; useType : boolean; index : integer);
    procedure ComposeStructureDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
    procedure ComposeSubscriptionChannel(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubscriptionChannel; useType : boolean; index : integer);
    procedure ComposeSubscription(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubscription; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
    procedure ComposeSubstanceInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceInstance; useType : boolean; index : integer);
    procedure ComposeSubstanceIngredient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceIngredient; useType : boolean; index : integer);
    procedure ComposeSubstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstance; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
    procedure ComposeSupplyDelivery(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyDelivery; useType : boolean; index : integer);
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    procedure ComposeSupplyRequestWhen(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyRequestWhen; useType : boolean; index : integer);
    procedure ComposeSupplyRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyRequest; useType : boolean; index : integer);
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
    procedure ComposeTestScriptContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptContact; useType : boolean; index : integer);
    procedure ComposeTestScriptMetadata(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadata; useType : boolean; index : integer);
    procedure ComposeTestScriptMetadataLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadataLink; useType : boolean; index : integer);
    procedure ComposeTestScriptMetadataCapability(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadataCapability; useType : boolean; index : integer);
    procedure ComposeTestScriptFixture(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptFixture; useType : boolean; index : integer);
    procedure ComposeTestScriptVariable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptVariable; useType : boolean; index : integer);
    procedure ComposeTestScriptSetup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetup; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupAction; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupActionOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionOperation; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupActionOperationRequestHeader(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionOperationRequestHeader; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupActionAssert(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssert; useType : boolean; index : integer);
    procedure ComposeTestScriptTest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTest; useType : boolean; index : integer);
    procedure ComposeTestScriptTestAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTestAction; useType : boolean; index : integer);
    procedure ComposeTestScriptTeardown(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTeardown; useType : boolean; index : integer);
    procedure ComposeTestScriptTeardownAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTeardownAction; useType : boolean; index : integer);
    procedure ComposeTestScript(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScript; useType : boolean; index : integer);
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
    procedure ComposeValueSetContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetContact; useType : boolean; index : integer);
    procedure ComposeValueSetCodeSystem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetCodeSystem; useType : boolean; index : integer);
    procedure ComposeValueSetCodeSystemConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetCodeSystemConcept; useType : boolean; index : integer);
    procedure ComposeValueSetCodeSystemConceptDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetCodeSystemConceptDesignation; useType : boolean; index : integer);
    procedure ComposeValueSetCompose(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetCompose; useType : boolean; index : integer);
    procedure ComposeValueSetComposeInclude(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeInclude; useType : boolean; index : integer);
    procedure ComposeValueSetComposeIncludeConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeConcept; useType : boolean; index : integer);
    procedure ComposeValueSetComposeIncludeFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeFilter; useType : boolean; index : integer);
    procedure ComposeValueSetExpansion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansion; useType : boolean; index : integer);
    procedure ComposeValueSetExpansionParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansionParameter; useType : boolean; index : integer);
    procedure ComposeValueSetExpansionContains(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansionContains; useType : boolean; index : integer);
    procedure ComposeValueSet(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSet; useType : boolean; index : integer);
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    procedure ComposeVisionPrescriptionDispense(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVisionPrescriptionDispense; useType : boolean; index : integer);
    procedure ComposeVisionPrescription(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVisionPrescription; useType : boolean; index : integer);
{$ENDIF FHIR_VISIONPRESCRIPTION}
  
    procedure ComposeResource(parent :  TTurtleComplex; resource : TFhirResource); overload; override;
  end;


implementation

{ TFHIRTurtleParser }

function TFHIRTurtleParser.ParseElement(obj : TTurtleComplex) : TFhirElement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElement.create;
  try
    ParseElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleComposer.ComposeElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
    this := parent;
  if (index > -1)  then
    this.addPredicate('fhir:index', inttostr(index), 'int');
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(this, 'Element', 'id', elem.idElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(this, 'Element', 'extension', elem.extensionList[i], false, i);{x.d3}
end;

procedure TFHIRTurtleParser.ParseElementProperties(obj : TTurtleComplex; element : TFhirElement);
var
  item : TTurtleComplex;
begin
  element.LocationStart := obj.Start;
  element.LocationEnd := obj.Stop;
  element.idElement := ParseId(obj.complex('http://hl7.org/fhir/Element.id'));{q1}
  for item in obj.complexes('http://hl7.org/fhir/Element.extension') do
    element.extensionList.Add(parseExtension(item));
end;

procedure TFHIRTurtleParser.ParseBackboneElementProperties(obj : TTurtleComplex; element : TFhirBackboneElement);
var
  item : TTurtleComplex;
begin
  parseElementProperties(obj, element);
  for item in obj.complexes('http://hl7.org/fhir/Element.modifierExtension') do
    element.modifierExtensionList.Add(parseExtension(item));
end;

function TFHIRTurtleParser.ParseBackboneElement(obj : TTurtleComplex) : TFhirBackboneElement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBackboneElement.create;
  try
    ParseBackboneElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleComposer.ComposeBackboneElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBackboneElement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BackboneElement'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(this, 'BackboneElement', 'modifierExtension', elem.modifierExtensionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseEnum(obj : TTurtleComplex; Const aNames, aSystems : Array Of String) : TFHIREnum;
var
  i : integer;
  value : String;
begin
  if obj = nil then
    exit(nil);

  if (obj.has('http://hl7.org/fhir/value')) then
    value := obj.stringLiteral('http://hl7.org/fhir/value');
  i := StringArrayIndexOfSensitive(aNames, value);
  if (value <> '') and (i < 0) then
    raise Exception.create('unknown code: '+value+' from a set of choices of '+StringArrayToCommaString(aNames));
  result := TFHIREnum.create;
  try
    result.value := value;
    result.system := aSystems[i];
    parseElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeEnum(parent :  TTurtleComplex; parentType, name : String; value : TFhirEnum; Const aNames, aSystems : Array Of String; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:code');
  this.addPredicate('fhir:value', ttlLiteral(value.value));
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseDateTime(obj : TTurtleComplex) : TFHIRDateTime;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDateTime.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := toTDateTimeEx(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeDateTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirDateTime; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:dateTime');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), dateXsdType(value.value));
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseDate(obj : TTurtleComplex) : TFHIRDate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDate.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := toTDateTimeEx(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeDate(parent :  TTurtleComplex; parentType, name : String; value : TFhirDate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:date');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), dateXsdType(value.value));
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseString(obj : TTurtleComplex) : TFHIRString;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirString.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeString(parent :  TTurtleComplex; parentType, name : String; value : TFhirString; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:string');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:string');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseInteger(obj : TTurtleComplex) : TFHIRInteger;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInteger.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeInteger(parent :  TTurtleComplex; parentType, name : String; value : TFhirInteger; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:integer');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:int');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseUri(obj : TTurtleComplex) : TFHIRUri;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirUri.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeUri(parent :  TTurtleComplex; parentType, name : String; value : TFhirUri; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:uri');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:anyURI');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseInstant(obj : TTurtleComplex) : TFHIRInstant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInstant.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := toTDateTimeEx(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeInstant(parent :  TTurtleComplex; parentType, name : String; value : TFhirInstant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:instant');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:dateTime');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseBoolean(obj : TTurtleComplex) : TFHIRBoolean;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBoolean.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
     result.value := StringToBoolean(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeBoolean(parent :  TTurtleComplex; parentType, name : String; value : TFhirBoolean; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:boolean');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:boolean');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseBase64Binary(obj : TTurtleComplex) : TFHIRBase64Binary;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBase64Binary.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := toTBytes(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeBase64Binary(parent :  TTurtleComplex; parentType, name : String; value : TFhirBase64Binary; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:base64Binary');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:base64Binary');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseTime(obj : TTurtleComplex) : TFHIRTime;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTime.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirTime; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:time');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:time');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseDecimal(obj : TTurtleComplex) : TFHIRDecimal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDecimal.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeDecimal(parent :  TTurtleComplex; parentType, name : String; value : TFhirDecimal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:decimal');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:decimal');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseCode(obj : TTurtleComplex) : TFHIRCode;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCode.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeCode(parent :  TTurtleComplex; parentType, name : String; value : TFhirCode; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:code');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:token');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseOid(obj : TTurtleComplex) : TFHIROid;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOid.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeOid(parent :  TTurtleComplex; parentType, name : String; value : TFhirOid; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:oid');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:anyURI');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseUuid(obj : TTurtleComplex) : TFHIRUuid;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirUuid.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeUuid(parent :  TTurtleComplex; parentType, name : String; value : TFhirUuid; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:uuid');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:anyURI');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseMarkdown(obj : TTurtleComplex) : TFHIRMarkdown;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMarkdown.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeMarkdown(parent :  TTurtleComplex; parentType, name : String; value : TFhirMarkdown; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:markdown');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:string');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseUnsignedInt(obj : TTurtleComplex) : TFHIRUnsignedInt;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirUnsignedInt.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeUnsignedInt(parent :  TTurtleComplex; parentType, name : String; value : TFhirUnsignedInt; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:unsignedInt');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:nonNegativeInteger');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseId(obj : TTurtleComplex) : TFHIRId;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirId.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeId(parent :  TTurtleComplex; parentType, name : String; value : TFhirId; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:id');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:string');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParsePositiveInt(obj : TTurtleComplex) : TFHIRPositiveInt;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPositiveInt.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposePositiveInt(parent :  TTurtleComplex; parentType, name : String; value : TFhirPositiveInt; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:positiveInt');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:positiveInteger');
  composeElement(this, parentType, name, value, false, index);
end;

procedure TFHIRTurtleParser.ParseResourceProperties(obj : TTurtleComplex; resource : TFhirResource);
begin
  resource.LocationStart := obj.Start;
  resource.LocationEnd := obj.Stop;
  resource.idElement := ParseId(obj.complex('http://hl7.org/fhir/Resource.id'));{q1}
  resource.meta := ParseMeta(obj.complex('http://hl7.org/fhir/Resource.meta'));{q3b}
  resource.implicitRulesElement := ParseUri(obj.complex('http://hl7.org/fhir/Resource.implicitRules'));{q1}
  resource.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/Resource.language'));{q1}
end;

Procedure TFHIRTurtleComposer.ComposeResource(this : TTurtleComplex; parentType, name : String; elem : TFhirResource; useType : boolean; index : integer);
begin
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(this, 'Resource', 'id', elem.idElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('meta') then
    ComposeMeta(this, 'Resource', 'meta', elem.metaElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implicitRules') then
    ComposeUri(this, 'Resource', 'implicitRules', elem.implicitRulesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('language') then
    ComposeCode(this, 'Resource', 'language', elem.languageElement, false, -1);{x.2ea}
end;

{$IFDEF FHIR_PARAMETERS}
function TFHIRTurtleParser.ParseParametersParameter(obj : TTurtleComplex) : TFhirParametersParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirParametersParameter.create;
  try
    ParseParametersParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseParametersParameterProperties(obj : TTurtleComplex; result : TFhirParametersParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Parameters.parameter.name'));{q1}
//t.6    if jsn.has('valueCode') or jsn.has('_valueCode') then
        result.value := ParseCode(jsn['valueCode'], jsn.vObj['_valueCode']);
//t.6    if jsn.has('valueOid') or jsn.has('_valueOid') then
        result.value := ParseOid(jsn['valueOid'], jsn.vObj['_valueOid']);
//t.6    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
        result.value := ParseUuid(jsn['valueUuid'], jsn.vObj['_valueUuid']);
//t.6    if jsn.has('valueMarkdown') or jsn.has('_valueMarkdown') then
        result.value := ParseMarkdown(jsn['valueMarkdown'], jsn.vObj['_valueMarkdown']);
//t.6    if jsn.has('valueUnsignedInt') or jsn.has('_valueUnsignedInt') then
        result.value := ParseUnsignedInt(jsn['valueUnsignedInt'], jsn.vObj['_valueUnsignedInt']);
//t.6    if jsn.has('valueId') or jsn.has('_valueId') then
        result.value := ParseId(jsn['valueId'], jsn.vObj['_valueId']);
//t.6    if jsn.has('valuePositiveInt') or jsn.has('_valuePositiveInt') then
        result.value := ParsePositiveInt(jsn['valuePositiveInt'], jsn.vObj['_valuePositiveInt']);
//t.6    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
        result.value := ParseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
//t.6    if jsn.has('valueDate') or jsn.has('_valueDate') then
        result.value := ParseDate(jsn['valueDate'], jsn.vObj['_valueDate']);
//t.6    if jsn.has('valueString') or jsn.has('_valueString') then
        result.value := ParseString(jsn['valueString'], jsn.vObj['_valueString']);
//t.6    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
        result.value := ParseInteger(jsn['valueInteger'], jsn.vObj['_valueInteger']);
//t.6    if jsn.has('valueUri') or jsn.has('_valueUri') then
        result.value := ParseUri(jsn['valueUri'], jsn.vObj['_valueUri']);
//t.6    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
        result.value := ParseInstant(jsn['valueInstant'], jsn.vObj['_valueInstant']);
//t.6    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
        result.value := ParseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
//t.6    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
        result.value := ParseBase64Binary(jsn['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
//t.6    if jsn.has('valueTime') or jsn.has('_valueTime') then
        result.value := ParseTime(jsn['valueTime'], jsn.vObj['_valueTime']);
//t.6    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
        result.value := ParseDecimal(jsn['valueDecimal'], jsn.vObj['_valueDecimal']);
    if obj.has('valueIdentifier') {a7} then
        result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if obj.has('valueCoding') {a7} then
        result.value := ParseCoding(jsn.vObj['valueCoding']);
    if obj.has('valueReference') {a7} then
        result.value := ParseReference(jsn.vObj['valueReference']);
    if obj.has('valueSignature') {a7} then
        result.value := ParseSignature(jsn.vObj['valueSignature']);
    if obj.has('valueSampledData') {a7} then
        result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if obj.has('valuePeriod') {a7} then
        result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if obj.has('valueQuantity') {a7} then
        result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if obj.has('valueAttachment') {a7} then
        result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if obj.has('valueRatio') {a7} then
        result.value := ParseRatio(jsn.vObj['valueRatio']);
    if obj.has('valueRange') {a7} then
        result.value := ParseRange(jsn.vObj['valueRange']);
    if obj.has('valueAnnotation') {a7} then
        result.value := ParseAnnotation(jsn.vObj['valueAnnotation']);
    if obj.has('valueCodeableConcept') {a7} then
        result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
//t.5    if jsn.has('valueHumanName') {a9} then
        result.value := ParseHumanName(jsn.vObj['valueHumanName']);
//t.5    if jsn.has('valueMeta') {a9} then
        result.value := ParseMeta(jsn.vObj['valueMeta']);
//t.5    if jsn.has('valueContactPoint') {a9} then
        result.value := ParseContactPoint(jsn.vObj['valueContactPoint']);
//t.5    if jsn.has('valueAddress') {a9} then
        result.value := ParseAddress(jsn.vObj['valueAddress']);
//t.5    if jsn.has('valueElementDefinition') {a9} then
        result.value := ParseElementDefinition(jsn.vObj['valueElementDefinition']);
//t.5    if jsn.has('valueTiming') {a9} then
        result.value := ParseTiming(jsn.vObj['valueTiming']);
    result.resource := ParseInnerResource(obj.predicate('http://hl7.org/fhir/Parameters.parameter.resource'));{q3a}
    for item in obj.complexes('http://hl7.org/fhir/Parameters.parameter.part') do
      result.partList.Add(parseParametersParameter(item));
end;

procedure TFHIRTurtleComposer.ComposeParametersParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirParametersParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ParametersParameter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Parameters.parameter', 'name', elem.nameElement, false, -1);{x.2ea}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) {1} then
    ComposeCode(this, 'Parameters.parameter', 'valueCode', TFhirCode(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) {1} then
    ComposeOid(this, 'Parameters.parameter', 'valueOid', TFhirOid(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUuid) {1} then
    ComposeUuid(this, 'Parameters.parameter', 'valueUuid', TFhirUuid(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) {1} then
    ComposeMarkdown(this, 'Parameters.parameter', 'valueMarkdown', TFhirMarkdown(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(this, 'Parameters.parameter', 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) {1} then
    ComposeId(this, 'Parameters.parameter', 'valueId', TFhirId(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) {1} then
    ComposePositiveInt(this, 'Parameters.parameter', 'valuePositiveInt', TFhirPositiveInt(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) {1} then
    ComposeDateTime(this, 'Parameters.parameter', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) {1} then
    ComposeDate(this, 'Parameters.parameter', 'valueDate', TFhirDate(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) {1} then
    ComposeString(this, 'Parameters.parameter', 'valueString', TFhirString(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) {1} then
    ComposeInteger(this, 'Parameters.parameter', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) {1} then
    ComposeUri(this, 'Parameters.parameter', 'valueUri', TFhirUri(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) {1} then
    ComposeInstant(this, 'Parameters.parameter', 'valueInstant', TFhirInstant(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) {1} then
    ComposeBoolean(this, 'Parameters.parameter', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) {1} then
    ComposeBase64Binary(this, 'Parameters.parameter', 'valueBase64Binary', TFhirBase64Binary(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) {1} then
    ComposeTime(this, 'Parameters.parameter', 'valueTime', TFhirTime(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) {1} then
    ComposeDecimal(this, 'Parameters.parameter', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirIdentifier) {8} then
    ComposeIdentifier(this, 'Parameters.parameter', 'valueIdentifier', TFhirIdentifier(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirCoding) {8} then
    ComposeCoding(this, 'Parameters.parameter', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirReference) {8} then
    ComposeReference(this, 'Parameters.parameter', 'valueReference', TFhirReference(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirSignature) {8} then
    ComposeSignature(this, 'Parameters.parameter', 'valueSignature', TFhirSignature(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirSampledData) {8} then
    ComposeSampledData(this, 'Parameters.parameter', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirPeriod) {8} then
    ComposePeriod(this, 'Parameters.parameter', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirQuantity) {8} then
    ComposeQuantity(this, 'Parameters.parameter', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAttachment) {8} then
    ComposeAttachment(this, 'Parameters.parameter', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirRatio) {8} then
    ComposeRatio(this, 'Parameters.parameter', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirRange) {8} then
    ComposeRange(this, 'Parameters.parameter', 'valueRange', TFhirRange(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAnnotation) {8} then
    ComposeAnnotation(this, 'Parameters.parameter', 'valueAnnotation', TFhirAnnotation(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(this, 'Parameters.parameter', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirHumanName) {9} then
    ComposeHumanName(this, 'Parameters.parameter', 'valueHumanName', TFhirHumanName(elem.value), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirMeta) {9} then
    ComposeMeta(this, 'Parameters.parameter', 'valueMeta', TFhirMeta(elem.value), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirContactPoint) {9} then
    ComposeContactPoint(this, 'Parameters.parameter', 'valueContactPoint', TFhirContactPoint(elem.value), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAddress) {9} then
    ComposeAddress(this, 'Parameters.parameter', 'valueAddress', TFhirAddress(elem.value), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirElementDefinition) {9} then
    ComposeElementDefinition(this, 'Parameters.parameter', 'valueElementDefinition', TFhirElementDefinition(elem.value), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirTiming) {9} then
    ComposeTiming(this, 'Parameters.parameter', 'valueTiming', TFhirTiming(elem.value), true, -1);{x.d6}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(this, 'Parameters.parameter', 'resource', elem.resourceElement, false, -1);{x.2ec}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.partList.Count - 1 do
      ComposeParametersParameter(this, 'Parameters.parameter', 'part', elem.partList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseParameters(obj : TTurtleComplex) : TFhirParameters;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirParameters.create;
  try
    ParseParametersProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseParametersProperties(obj : TTurtleComplex; result : TFhirParameters);
var
  item : TTurtleComplex;
begin
    ParseResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Parameters.parameter') do
      result.parameterList.Add(parseParametersParameter(item));
end;

procedure TFHIRTurtleComposer.ComposeParameters(parent :  TTurtleComplex; parentType, name : String; elem : TFhirParameters; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Parameters'); {z}
  end;
  composeResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and doCompose('parameter') then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeParametersParameter(this, 'Parameters', 'parameter', elem.parameterList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PARAMETERS}
procedure TFHIRTurtleParser.ParseDomainResourceProperties(obj : TTurtleComplex; resource : TFhirDomainResource);
var
  item : TTurtleComplex;
begin
  ParseResourceProperties(obj, resource);
  resource.text := ParseNarrative(obj.complex('http://hl7.org/fhir/DomainResource.text'));{q3b}
  for item in obj.complexes('http://hl7.org/fhir/DomainResource.contained') do
    resource.containedList.Add(parseInnerResource(item));
  for item in obj.complexes('http://hl7.org/fhir/DomainResource.extension') do
    resource.extensionList.Add(parseExtension(item));
  for item in obj.complexes('http://hl7.org/fhir/DomainResource.modifierExtension') do
    resource.modifierExtensionList.Add(parseExtension(item));
end;

Procedure TFHIRTurtleComposer.ComposeDomainResource(this : TTurtleComplex; parentType, name : String; elem : TFhirDomainResource; useType : boolean; index : integer);
var
  i : integer{z.c};
begin
  ComposeResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soText]) and doCompose('text') then
    ComposeNarrative(this, 'DomainResource', 'text', elem.textElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('contained') then
    for i := 0 to elem.containedList.Count - 1 do
      ComposeInnerResource(this, 'DomainResource', 'contained', elem.containedList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('extension') then
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(this, 'DomainResource', 'extension', elem.extensionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('modifierExtension') then
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(this, 'DomainResource', 'modifierExtension', elem.modifierExtensionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExtension(obj : TTurtleComplex) : TFhirExtension;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExtension.create;
  try
    ParseExtensionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExtensionProperties(obj : TTurtleComplex; result : TFhirExtension);
var
  item : TTurtleComplex;
begin
    ParseTypeProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Extension.url'));{q1}
//t.6    if jsn.has('valueCode') or jsn.has('_valueCode') then
        result.value := ParseCode(jsn['valueCode'], jsn.vObj['_valueCode']);
//t.6    if jsn.has('valueOid') or jsn.has('_valueOid') then
        result.value := ParseOid(jsn['valueOid'], jsn.vObj['_valueOid']);
//t.6    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
        result.value := ParseUuid(jsn['valueUuid'], jsn.vObj['_valueUuid']);
//t.6    if jsn.has('valueMarkdown') or jsn.has('_valueMarkdown') then
        result.value := ParseMarkdown(jsn['valueMarkdown'], jsn.vObj['_valueMarkdown']);
//t.6    if jsn.has('valueUnsignedInt') or jsn.has('_valueUnsignedInt') then
        result.value := ParseUnsignedInt(jsn['valueUnsignedInt'], jsn.vObj['_valueUnsignedInt']);
//t.6    if jsn.has('valueId') or jsn.has('_valueId') then
        result.value := ParseId(jsn['valueId'], jsn.vObj['_valueId']);
//t.6    if jsn.has('valuePositiveInt') or jsn.has('_valuePositiveInt') then
        result.value := ParsePositiveInt(jsn['valuePositiveInt'], jsn.vObj['_valuePositiveInt']);
//t.6    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
        result.value := ParseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
//t.6    if jsn.has('valueDate') or jsn.has('_valueDate') then
        result.value := ParseDate(jsn['valueDate'], jsn.vObj['_valueDate']);
//t.6    if jsn.has('valueString') or jsn.has('_valueString') then
        result.value := ParseString(jsn['valueString'], jsn.vObj['_valueString']);
//t.6    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
        result.value := ParseInteger(jsn['valueInteger'], jsn.vObj['_valueInteger']);
//t.6    if jsn.has('valueUri') or jsn.has('_valueUri') then
        result.value := ParseUri(jsn['valueUri'], jsn.vObj['_valueUri']);
//t.6    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
        result.value := ParseInstant(jsn['valueInstant'], jsn.vObj['_valueInstant']);
//t.6    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
        result.value := ParseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
//t.6    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
        result.value := ParseBase64Binary(jsn['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
//t.6    if jsn.has('valueTime') or jsn.has('_valueTime') then
        result.value := ParseTime(jsn['valueTime'], jsn.vObj['_valueTime']);
//t.6    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
        result.value := ParseDecimal(jsn['valueDecimal'], jsn.vObj['_valueDecimal']);
    if obj.has('valueIdentifier') {a7} then
        result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if obj.has('valueCoding') {a7} then
        result.value := ParseCoding(jsn.vObj['valueCoding']);
    if obj.has('valueReference') {a7} then
        result.value := ParseReference(jsn.vObj['valueReference']);
    if obj.has('valueSignature') {a7} then
        result.value := ParseSignature(jsn.vObj['valueSignature']);
    if obj.has('valueSampledData') {a7} then
        result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if obj.has('valuePeriod') {a7} then
        result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if obj.has('valueQuantity') {a7} then
        result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if obj.has('valueAttachment') {a7} then
        result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if obj.has('valueRatio') {a7} then
        result.value := ParseRatio(jsn.vObj['valueRatio']);
    if obj.has('valueRange') {a7} then
        result.value := ParseRange(jsn.vObj['valueRange']);
    if obj.has('valueAnnotation') {a7} then
        result.value := ParseAnnotation(jsn.vObj['valueAnnotation']);
    if obj.has('valueCodeableConcept') {a7} then
        result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
//t.5    if jsn.has('valueHumanName') {a9} then
        result.value := ParseHumanName(jsn.vObj['valueHumanName']);
//t.5    if jsn.has('valueMeta') {a9} then
        result.value := ParseMeta(jsn.vObj['valueMeta']);
//t.5    if jsn.has('valueContactPoint') {a9} then
        result.value := ParseContactPoint(jsn.vObj['valueContactPoint']);
//t.5    if jsn.has('valueAddress') {a9} then
        result.value := ParseAddress(jsn.vObj['valueAddress']);
//t.5    if jsn.has('valueElementDefinition') {a9} then
        result.value := ParseElementDefinition(jsn.vObj['valueElementDefinition']);
//t.5    if jsn.has('valueTiming') {a9} then
        result.value := ParseTiming(jsn.vObj['valueTiming']);
end;

procedure TFHIRTurtleComposer.ComposeExtension(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExtension; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Extension'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeUri(this, 'Extension', 'url', elem.urlElement, false, -1);{x.2ea}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) {1} then
    ComposeCode(this, 'Extension', 'valueCode', TFhirCode(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) {1} then
    ComposeOid(this, 'Extension', 'valueOid', TFhirOid(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUuid) {1} then
    ComposeUuid(this, 'Extension', 'valueUuid', TFhirUuid(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) {1} then
    ComposeMarkdown(this, 'Extension', 'valueMarkdown', TFhirMarkdown(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(this, 'Extension', 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) {1} then
    ComposeId(this, 'Extension', 'valueId', TFhirId(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) {1} then
    ComposePositiveInt(this, 'Extension', 'valuePositiveInt', TFhirPositiveInt(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) {1} then
    ComposeDateTime(this, 'Extension', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) {1} then
    ComposeDate(this, 'Extension', 'valueDate', TFhirDate(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) {1} then
    ComposeString(this, 'Extension', 'valueString', TFhirString(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) {1} then
    ComposeInteger(this, 'Extension', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) {1} then
    ComposeUri(this, 'Extension', 'valueUri', TFhirUri(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) {1} then
    ComposeInstant(this, 'Extension', 'valueInstant', TFhirInstant(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) {1} then
    ComposeBoolean(this, 'Extension', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) {1} then
    ComposeBase64Binary(this, 'Extension', 'valueBase64Binary', TFhirBase64Binary(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) {1} then
    ComposeTime(this, 'Extension', 'valueTime', TFhirTime(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) {1} then
    ComposeDecimal(this, 'Extension', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirIdentifier) {8} then
    ComposeIdentifier(this, 'Extension', 'valueIdentifier', TFhirIdentifier(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirCoding) {8} then
    ComposeCoding(this, 'Extension', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirReference) {8} then
    ComposeReference(this, 'Extension', 'valueReference', TFhirReference(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirSignature) {8} then
    ComposeSignature(this, 'Extension', 'valueSignature', TFhirSignature(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirSampledData) {8} then
    ComposeSampledData(this, 'Extension', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirPeriod) {8} then
    ComposePeriod(this, 'Extension', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirQuantity) {8} then
    ComposeQuantity(this, 'Extension', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAttachment) {8} then
    ComposeAttachment(this, 'Extension', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirRatio) {8} then
    ComposeRatio(this, 'Extension', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirRange) {8} then
    ComposeRange(this, 'Extension', 'valueRange', TFhirRange(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAnnotation) {8} then
    ComposeAnnotation(this, 'Extension', 'valueAnnotation', TFhirAnnotation(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(this, 'Extension', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirHumanName) {9} then
    ComposeHumanName(this, 'Extension', 'valueHumanName', TFhirHumanName(elem.value), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirMeta) {9} then
    ComposeMeta(this, 'Extension', 'valueMeta', TFhirMeta(elem.value), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirContactPoint) {9} then
    ComposeContactPoint(this, 'Extension', 'valueContactPoint', TFhirContactPoint(elem.value), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAddress) {9} then
    ComposeAddress(this, 'Extension', 'valueAddress', TFhirAddress(elem.value), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirElementDefinition) {9} then
    ComposeElementDefinition(this, 'Extension', 'valueElementDefinition', TFhirElementDefinition(elem.value), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirTiming) {9} then
    ComposeTiming(this, 'Extension', 'valueTiming', TFhirTiming(elem.value), true, -1);{x.d6}
end;

function TFHIRTurtleParser.ParseNarrative(obj : TTurtleComplex) : TFhirNarrative;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNarrative.create;
  try
    ParseNarrativeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNarrativeProperties(obj : TTurtleComplex; result : TFhirNarrative);
begin
    ParseTypeProperties(obj, result);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Narrative.status'), CODES_TFhirNarrativeStatusEnum, SYSTEMS_TFhirNarrativeStatusEnum);
    result.div_ := ParseXHtmlNode(obj.stringLiteral('http://hl7.org/fhir/Narrative.div'));{q2}
end;

procedure TFHIRTurtleComposer.ComposeNarrative(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNarrative; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Narrative'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Narrative', 'status', elem.StatusElement, CODES_TFhirNarrativeStatusEnum, SYSTEMS_TFhirNarrativeStatusEnum, false, -1);{x.d4}
  ComposeXHtmlNode(this, 'Narrative', 'div', elem.div_Element, false, -1);{x.2eb}
end;

function TFHIRTurtleParser.ParseIdentifier(obj : TTurtleComplex) : TFhirIdentifier;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirIdentifier.create;
  try
    ParseIdentifierProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseIdentifierProperties(obj : TTurtleComplex; result : TFhirIdentifier);
begin
    ParseTypeProperties(obj, result);
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/Identifier.use'), CODES_TFhirIdentifierUseEnum, SYSTEMS_TFhirIdentifierUseEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Identifier.type'));{q3b}
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/Identifier.system'));{q1}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/Identifier.value'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Identifier.period'));{q3b}
    result.assigner := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Identifier.assigner'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeIdentifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirIdentifier; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Identifier'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'Identifier', 'use', elem.UseElement, CODES_TFhirIdentifierUseEnum, SYSTEMS_TFhirIdentifierUseEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'Identifier', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Identifier', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Identifier', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(this, 'Identifier', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Identifier', 'assigner', elem.assignerElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCoding(obj : TTurtleComplex) : TFhirCoding;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoding.create;
  try
    ParseCodingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodingProperties(obj : TTurtleComplex; result : TFhirCoding);
begin
    ParseTypeProperties(obj, result);
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/Coding.system'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Coding.version'));{q1}
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/Coding.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/Coding.display'));{q1}
    result.userSelectedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Coding.userSelected'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCoding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoding; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Coding'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Coding', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Coding', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Coding', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Coding', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBoolean(this, 'Coding', 'userSelected', elem.userSelectedElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseReference(obj : TTurtleComplex) : TFhirReference;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirReference.create;
  try
    ParseReferenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseReferenceProperties(obj : TTurtleComplex; result : TFhirReference);
begin
    ParseTypeProperties(obj, result);
    result.referenceElement := ParseString(obj.complex('http://hl7.org/fhir/Reference.reference'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/Reference.display'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeReference(parent :  TTurtleComplex; parentType, name : String; elem : TFhirReference; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Reference'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Reference', 'reference', elem.referenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Reference', 'display', elem.displayElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseSignature(obj : TTurtleComplex) : TFhirSignature;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSignature.create;
  try
    ParseSignatureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSignatureProperties(obj : TTurtleComplex; result : TFhirSignature);
var
  item : TTurtleComplex;
begin
    ParseTypeProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Signature.type') do
      result.type_List.Add(parseCoding(item));
    result.whenElement := ParseInstant(obj.complex('http://hl7.org/fhir/Signature.when'));{q1}
    if obj.has('http://hl7.org/fhir/Signature.whoReference', item) {a3} then
      result.who := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Signature.whoUri', item) then
      result.who := parseUri(item);
    result.contentTypeElement := ParseCode(obj.complex('http://hl7.org/fhir/Signature.contentType'));{q1}
    result.blobElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Signature.blob'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSignature(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSignature; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Signature'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(this, 'Signature', 'type', elem.type_List[i], false, i);{x.d3}
  ComposeInstant(this, 'Signature', 'when', elem.whenElement, false, -1);{x.2ea}
  if (elem.who is TFhirReference) {2} then
    ComposeReference(this, 'Signature', 'whoReference', TFhirReference(elem.who), false,-1){x.d8}
  else if (elem.who is TFhirUri) {6} then
    ComposeUri(this, 'Signature', 'whoUri', TFhirUri(elem.who), false, -1);{x.d9}
  ComposeCode(this, 'Signature', 'contentType', elem.contentTypeElement, false, -1);{x.2ea}
  ComposeBase64Binary(this, 'Signature', 'blob', elem.blobElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseSampledData(obj : TTurtleComplex) : TFhirSampledData;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSampledData.create;
  try
    ParseSampledDataProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSampledDataProperties(obj : TTurtleComplex; result : TFhirSampledData);
begin
    ParseTypeProperties(obj, result);
    result.origin := ParseQuantity(obj.complex('http://hl7.org/fhir/SampledData.origin'));{q3b}
    result.periodElement := ParseDecimal(obj.complex('http://hl7.org/fhir/SampledData.period'));{q1}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/SampledData.factor'));{q1}
    result.lowerLimitElement := ParseDecimal(obj.complex('http://hl7.org/fhir/SampledData.lowerLimit'));{q1}
    result.upperLimitElement := ParseDecimal(obj.complex('http://hl7.org/fhir/SampledData.upperLimit'));{q1}
    result.dimensionsElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/SampledData.dimensions'));{q1}
    result.dataElement := ParseString(obj.complex('http://hl7.org/fhir/SampledData.data'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSampledData(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSampledData; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SampledData'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeQuantity(this, 'SampledData', 'origin', elem.originElement, false, -1);{x.2f}
  ComposeDecimal(this, 'SampledData', 'period', elem.periodElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.factor <> '1')) then
    ComposeDecimal(this, 'SampledData', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'SampledData', 'lowerLimit', elem.lowerLimitElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'SampledData', 'upperLimit', elem.upperLimitElement, false, -1);{x.2ea}
  ComposePositiveInt(this, 'SampledData', 'dimensions', elem.dimensionsElement, false, -1);{x.2ea}
  ComposeString(this, 'SampledData', 'data', elem.dataElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParsePeriod(obj : TTurtleComplex) : TFhirPeriod;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPeriod.create;
  try
    ParsePeriodProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePeriodProperties(obj : TTurtleComplex; result : TFhirPeriod);
begin
    ParseTypeProperties(obj, result);
    result.startElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Period.start'));{q1}
    result.end_Element := ParseDateTime(obj.complex('http://hl7.org/fhir/Period.end'));{q1}
end;

procedure TFHIRTurtleComposer.ComposePeriod(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPeriod; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Period'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(this, 'Period', 'start', elem.startElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(this, 'Period', 'end', elem.end_Element, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseQuantity(obj : TTurtleComplex) : TFhirQuantity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuantity.create;
  try
    ParseQuantityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuantityProperties(obj : TTurtleComplex; result : TFhirQuantity);
begin
    ParseTypeProperties(obj, result);
    result.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Quantity.value'));{q1}
    result.comparatorElement := ParseEnum(obj.complex('http://hl7.org/fhir/Quantity.comparator'), CODES_TFhirQuantityComparatorEnum, SYSTEMS_TFhirQuantityComparatorEnum);
    result.unit_Element := ParseString(obj.complex('http://hl7.org/fhir/Quantity.unit'));{q1}
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/Quantity.system'));{q1}
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/Quantity.code'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeQuantity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuantity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
var
  cb, c : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Quantity'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'Quantity', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'Quantity', 'comparator', elem.ComparatorElement, CODES_TFhirQuantityComparatorEnum, SYSTEMS_TFhirQuantityComparatorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Quantity', 'unit', elem.unit_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Quantity', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Quantity', 'code', elem.codeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseAttachment(obj : TTurtleComplex) : TFhirAttachment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAttachment.create;
  try
    ParseAttachmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAttachmentProperties(obj : TTurtleComplex; result : TFhirAttachment);
begin
    ParseTypeProperties(obj, result);
    result.contentTypeElement := ParseCode(obj.complex('http://hl7.org/fhir/Attachment.contentType'));{q1}
    result.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/Attachment.language'));{q1}
    result.dataElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Attachment.data'));{q1}
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Attachment.url'));{q1}
    result.sizeElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Attachment.size'));{q1}
    result.hashElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Attachment.hash'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Attachment.title'));{q1}
    result.creationElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Attachment.creation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeAttachment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAttachment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Attachment'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Attachment', 'contentType', elem.contentTypeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Attachment', 'language', elem.languageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(this, 'Attachment', 'data', elem.dataElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Attachment', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedInt(this, 'Attachment', 'size', elem.sizeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(this, 'Attachment', 'hash', elem.hashElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Attachment', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(this, 'Attachment', 'creation', elem.creationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseRatio(obj : TTurtleComplex) : TFhirRatio;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRatio.create;
  try
    ParseRatioProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRatioProperties(obj : TTurtleComplex; result : TFhirRatio);
begin
    ParseTypeProperties(obj, result);
    result.numerator := ParseQuantity(obj.complex('http://hl7.org/fhir/Ratio.numerator'));{q3b}
    result.denominator := ParseQuantity(obj.complex('http://hl7.org/fhir/Ratio.denominator'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeRatio(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRatio; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Ratio'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Ratio', 'numerator', elem.numeratorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Ratio', 'denominator', elem.denominatorElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseRange(obj : TTurtleComplex) : TFhirRange;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRange.create;
  try
    ParseRangeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRangeProperties(obj : TTurtleComplex; result : TFhirRange);
begin
    ParseTypeProperties(obj, result);
    result.low := ParseQuantity(obj.complex('http://hl7.org/fhir/Range.low'));{q3b}
    result.high := ParseQuantity(obj.complex('http://hl7.org/fhir/Range.high'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeRange(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRange; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Range'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Range', 'low', elem.lowElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Range', 'high', elem.highElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseAnnotation(obj : TTurtleComplex) : TFhirAnnotation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAnnotation.create;
  try
    ParseAnnotationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAnnotationProperties(obj : TTurtleComplex; result : TFhirAnnotation);
var
  item : TTurtleComplex;
begin
    ParseTypeProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Annotation.authorReference', item) {a3} then
      result.author := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Annotation.authorString', item) then
      result.author := parseString(item);
    result.timeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Annotation.time'));{q1}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Annotation.text'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeAnnotation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAnnotation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Annotation'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirReference) {2} then
    ComposeReference(this, 'Annotation', 'authorReference', TFhirReference(elem.author), false,-1){x.d8}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirString) {6} then
    ComposeString(this, 'Annotation', 'authorString', TFhirString(elem.author), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(this, 'Annotation', 'time', elem.timeElement, false, -1);{x.2ea}
  ComposeString(this, 'Annotation', 'text', elem.textElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCodeableConcept(obj : TTurtleComplex) : TFhirCodeableConcept;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeableConcept.create;
  try
    ParseCodeableConceptProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeableConceptProperties(obj : TTurtleComplex; result : TFhirCodeableConcept);
var
  item : TTurtleComplex;
begin
    ParseTypeProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CodeableConcept.coding') do
      result.codingList.Add(parseCoding(item));
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/CodeableConcept.text'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCodeableConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeableConcept; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeableConcept'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.codingList.Count - 1 do
      ComposeCoding(this, 'CodeableConcept', 'coding', elem.codingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'CodeableConcept', 'text', elem.textElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseHumanName(obj : TTurtleComplex) : TFhirHumanName;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirHumanName.create;
  try
    ParseHumanNameProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseHumanNameProperties(obj : TTurtleComplex; result : TFhirHumanName);
var
  item : TTurtleComplex;
begin
    ParseStructureProperties(obj, result);
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/HumanName.use'), CODES_TFhirNameUseEnum, SYSTEMS_TFhirNameUseEnum);
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/HumanName.text'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/HumanName.family') do
      result.familyList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/HumanName.given') do
      result.givenList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/HumanName.prefix') do
      result.prefixList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/HumanName.suffix') do
      result.suffixList.Add(parseString(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/HumanName.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeHumanName(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHumanName; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:HumanName'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'HumanName', 'use', elem.UseElement, CODES_TFhirNameUseEnum, SYSTEMS_TFhirNameUseEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'HumanName', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.familyList.Count - 1 do
      ComposeString(this, 'HumanName', 'family', elem.familyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.givenList.Count - 1 do
      ComposeString(this, 'HumanName', 'given', elem.givenList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.prefixList.Count - 1 do
      ComposeString(this, 'HumanName', 'prefix', elem.prefixList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.suffixList.Count - 1 do
      ComposeString(this, 'HumanName', 'suffix', elem.suffixList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(this, 'HumanName', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMeta(obj : TTurtleComplex) : TFhirMeta;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeta.create;
  try
    ParseMetaProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMetaProperties(obj : TTurtleComplex; result : TFhirMeta);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.versionIdElement := ParseId(obj.complex('http://hl7.org/fhir/Meta.versionId'));{q1}
    result.lastUpdatedElement := ParseInstant(obj.complex('http://hl7.org/fhir/Meta.lastUpdated'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Meta.profile') do
      result.profileList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/Meta.security') do
      result.securityList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Meta.tag') do
      result.tagList.Add(parseCoding(item));
end;

procedure TFHIRTurtleComposer.ComposeMeta(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeta; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Meta'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(this, 'Meta', 'versionId', elem.versionIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(this, 'Meta', 'lastUpdated', elem.lastUpdatedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeUri(this, 'Meta', 'profile', elem.profileList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.securityList.Count - 1 do
      ComposeCoding(this, 'Meta', 'security', elem.securityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.tagList.Count - 1 do
      ComposeCoding(this, 'Meta', 'tag', elem.tagList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseContactPoint(obj : TTurtleComplex) : TFhirContactPoint;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContactPoint.create;
  try
    ParseContactPointProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContactPointProperties(obj : TTurtleComplex; result : TFhirContactPoint);
begin
    ParseStructureProperties(obj, result);
    result.systemElement := ParseEnum(obj.complex('http://hl7.org/fhir/ContactPoint.system'), CODES_TFhirContactPointSystemEnum, SYSTEMS_TFhirContactPointSystemEnum);
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/ContactPoint.value'));{q1}
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/ContactPoint.use'), CODES_TFhirContactPointUseEnum, SYSTEMS_TFhirContactPointUseEnum);
    result.rankElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ContactPoint.rank'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/ContactPoint.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeContactPoint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContactPoint; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContactPoint'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'ContactPoint', 'system', elem.SystemElement, CODES_TFhirContactPointSystemEnum, SYSTEMS_TFhirContactPointSystemEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ContactPoint', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'ContactPoint', 'use', elem.UseElement, CODES_TFhirContactPointUseEnum, SYSTEMS_TFhirContactPointUseEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveInt(this, 'ContactPoint', 'rank', elem.rankElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(this, 'ContactPoint', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseAddress(obj : TTurtleComplex) : TFhirAddress;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAddress.create;
  try
    ParseAddressProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAddressProperties(obj : TTurtleComplex; result : TFhirAddress);
var
  item : TTurtleComplex;
begin
    ParseStructureProperties(obj, result);
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/Address.use'), CODES_TFhirAddressUseEnum, SYSTEMS_TFhirAddressUseEnum);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Address.type'), CODES_TFhirAddressTypeEnum, SYSTEMS_TFhirAddressTypeEnum);
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Address.text'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Address.line') do
      result.lineList.Add(parseString(item));
    result.cityElement := ParseString(obj.complex('http://hl7.org/fhir/Address.city'));{q1}
    result.districtElement := ParseString(obj.complex('http://hl7.org/fhir/Address.district'));{q1}
    result.stateElement := ParseString(obj.complex('http://hl7.org/fhir/Address.state'));{q1}
    result.postalCodeElement := ParseString(obj.complex('http://hl7.org/fhir/Address.postalCode'));{q1}
    result.countryElement := ParseString(obj.complex('http://hl7.org/fhir/Address.country'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Address.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeAddress(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAddress; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Address'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'Address', 'use', elem.UseElement, CODES_TFhirAddressUseEnum, SYSTEMS_TFhirAddressUseEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'Address', 'type', elem.Type_Element, CODES_TFhirAddressTypeEnum, SYSTEMS_TFhirAddressTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.lineList.Count - 1 do
      ComposeString(this, 'Address', 'line', elem.lineList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'city', elem.cityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'district', elem.districtElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'state', elem.stateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'postalCode', elem.postalCodeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'country', elem.countryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(this, 'Address', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseElementDefinitionSlicing(obj : TTurtleComplex) : TFhirElementDefinitionSlicing;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionSlicing.create;
  try
    ParseElementDefinitionSlicingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionSlicingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionSlicing);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.slicing.discriminator') do
      result.discriminatorList.Add(parseString(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.description'));{q1}
    result.orderedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.ordered'));{q1}
    result.rulesElement := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.rules'), CODES_TFhirResourceSlicingRulesEnum, SYSTEMS_TFhirResourceSlicingRulesEnum);
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionSlicing(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionSlicing; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionSlicing'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.discriminatorList.Count - 1 do
      ComposeString(this, 'ElementDefinition.slicing', 'discriminator', elem.discriminatorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition.slicing', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.ordered <> false)) then
    ComposeBoolean(this, 'ElementDefinition.slicing', 'ordered', elem.orderedElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ElementDefinition.slicing', 'rules', elem.RulesElement, CODES_TFhirResourceSlicingRulesEnum, SYSTEMS_TFhirResourceSlicingRulesEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseElementDefinitionBase(obj : TTurtleComplex) : TFhirElementDefinitionBase;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionBase.create;
  try
    ParseElementDefinitionBaseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionBaseProperties(obj : TTurtleComplex; result : TFhirElementDefinitionBase);
begin
    ParseElementProperties(obj, result);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.base.path'));{q1}
    result.minElement := ParseInteger(obj.complex('http://hl7.org/fhir/ElementDefinition.base.min'));{q1}
    result.maxElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.base.max'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionBase(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionBase; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionBase'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeString(this, 'ElementDefinition.base', 'path', elem.pathElement, false, -1);{x.2ea}
  ComposeInteger(this, 'ElementDefinition.base', 'min', elem.minElement, false, -1);{x.2ea}
  ComposeString(this, 'ElementDefinition.base', 'max', elem.maxElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseElementDefinitionType(obj : TTurtleComplex) : TFhirElementDefinitionType;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionType.create;
  try
    ParseElementDefinitionTypeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionTypeProperties(obj : TTurtleComplex; result : TFhirElementDefinitionType);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ElementDefinition.type.code'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.type.profile') do
      result.profileList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.type.aggregation') do
      result.aggregationList.Add(parseEnum(item, CODES_TFhirResourceAggregationModeEnum, SYSTEMS_TFhirResourceAggregationModeEnum));
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionType(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionType; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionType'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeCode(this, 'ElementDefinition.type', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeUri(this, 'ElementDefinition.type', 'profile', elem.profileList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.aggregationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition.type', 'aggregation', elem.aggregationList[i], CODES_TFhirResourceAggregationModeEnum, SYSTEMS_TFhirResourceAggregationModeEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.aggregationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition.type', 'aggregation', elem.aggregationList[i], CODES_TFhirResourceAggregationModeEnum, SYSTEMS_TFhirResourceAggregationModeEnum, false, i);{x.d2}
end;

function TFHIRTurtleParser.ParseElementDefinitionConstraint(obj : TTurtleComplex) : TFhirElementDefinitionConstraint;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionConstraint.create;
  try
    ParseElementDefinitionConstraintProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionConstraintProperties(obj : TTurtleComplex; result : TFhirElementDefinitionConstraint);
begin
    ParseElementProperties(obj, result);
    result.keyElement := ParseId(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.key'));{q1}
    result.requirementsElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.requirements'));{q1}
    result.severityElement := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.severity'), CODES_TFhirConstraintSeverityEnum, SYSTEMS_TFhirConstraintSeverityEnum);
    result.humanElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.human'));{q1}
    result.xpathElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.xpath'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionConstraint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionConstraint; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionConstraint'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeId(this, 'ElementDefinition.constraint', 'key', elem.keyElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition.constraint', 'requirements', elem.requirementsElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ElementDefinition.constraint', 'severity', elem.SeverityElement, CODES_TFhirConstraintSeverityEnum, SYSTEMS_TFhirConstraintSeverityEnum, false, -1);{x.d4}
  ComposeString(this, 'ElementDefinition.constraint', 'human', elem.humanElement, false, -1);{x.2ea}
  ComposeString(this, 'ElementDefinition.constraint', 'xpath', elem.xpathElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseElementDefinitionBinding(obj : TTurtleComplex) : TFhirElementDefinitionBinding;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionBinding.create;
  try
    ParseElementDefinitionBindingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionBindingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionBinding);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.strengthElement := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.binding.strength'), CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.binding.description'));{q1}
    if obj.has('http://hl7.org/fhir/ElementDefinition.binding.valueSetReference', item) {a3} then
      result.valueSet := ParseReference(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.binding.valueSetUri', item) then
      result.valueSet := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionBinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionBinding; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionBinding'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'ElementDefinition.binding', 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition.binding', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirReference) {2} then
    ComposeReference(this, 'ElementDefinition.binding', 'valueSetReference', TFhirReference(elem.valueSet), false,-1){x.d8}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirUri) {6} then
    ComposeUri(this, 'ElementDefinition.binding', 'valueSetUri', TFhirUri(elem.valueSet), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseElementDefinitionMapping(obj : TTurtleComplex) : TFhirElementDefinitionMapping;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionMapping.create;
  try
    ParseElementDefinitionMappingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionMappingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionMapping);
begin
    ParseElementProperties(obj, result);
    result.identityElement := ParseId(obj.complex('http://hl7.org/fhir/ElementDefinition.mapping.identity'));{q1}
    result.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/ElementDefinition.mapping.language'));{q1}
    result.mapElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.mapping.map'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionMapping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionMapping; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionMapping'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeId(this, 'ElementDefinition.mapping', 'identity', elem.identityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'ElementDefinition.mapping', 'language', elem.languageElement, false, -1);{x.2ea}
  ComposeString(this, 'ElementDefinition.mapping', 'map', elem.mapElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseElementDefinition(obj : TTurtleComplex) : TFhirElementDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinition.create;
  try
    ParseElementDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionProperties(obj : TTurtleComplex; result : TFhirElementDefinition);
var
  item : TTurtleComplex;
begin
    ParseTypeProperties(obj, result);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.path'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.representation') do
      result.representationList.Add(parseEnum(item, CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum));
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.name'));{q1}
    result.label_Element := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.label'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.code') do
      result.codeList.Add(parseCoding(item));
    result.slicing := ParseElementDefinitionSlicing(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing'));{q3b}
    result.shortElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.short'));{q1}
    result.definitionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.definition'));{q1}
    result.commentsElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.comments'));{q1}
    result.requirementsElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.requirements'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.alias') do
      result.aliasList.Add(parseString(item));
    result.minElement := ParseInteger(obj.complex('http://hl7.org/fhir/ElementDefinition.min'));{q1}
    result.maxElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.max'));{q1}
    result.base := ParseElementDefinitionBase(obj.complex('http://hl7.org/fhir/ElementDefinition.base'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.type') do
      result.type_List.Add(parseElementDefinitionType(item));
    result.nameReferenceElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.nameReference'));{q1}
//t.6    if jsn.has('defaultValueCode') or jsn.has('_defaultValueCode') then
        result.defaultValue := ParseCode(jsn['defaultValueCode'], jsn.vObj['_defaultValueCode']);
//t.6    if jsn.has('defaultValueOid') or jsn.has('_defaultValueOid') then
        result.defaultValue := ParseOid(jsn['defaultValueOid'], jsn.vObj['_defaultValueOid']);
//t.6    if jsn.has('defaultValueUuid') or jsn.has('_defaultValueUuid') then
        result.defaultValue := ParseUuid(jsn['defaultValueUuid'], jsn.vObj['_defaultValueUuid']);
//t.6    if jsn.has('defaultValueMarkdown') or jsn.has('_defaultValueMarkdown') then
        result.defaultValue := ParseMarkdown(jsn['defaultValueMarkdown'], jsn.vObj['_defaultValueMarkdown']);
//t.6    if jsn.has('defaultValueUnsignedInt') or jsn.has('_defaultValueUnsignedInt') then
        result.defaultValue := ParseUnsignedInt(jsn['defaultValueUnsignedInt'], jsn.vObj['_defaultValueUnsignedInt']);
//t.6    if jsn.has('defaultValueId') or jsn.has('_defaultValueId') then
        result.defaultValue := ParseId(jsn['defaultValueId'], jsn.vObj['_defaultValueId']);
//t.6    if jsn.has('defaultValuePositiveInt') or jsn.has('_defaultValuePositiveInt') then
        result.defaultValue := ParsePositiveInt(jsn['defaultValuePositiveInt'], jsn.vObj['_defaultValuePositiveInt']);
//t.6    if jsn.has('defaultValueDateTime') or jsn.has('_defaultValueDateTime') then
        result.defaultValue := ParseDateTime(jsn['defaultValueDateTime'], jsn.vObj['_defaultValueDateTime']);
//t.6    if jsn.has('defaultValueDate') or jsn.has('_defaultValueDate') then
        result.defaultValue := ParseDate(jsn['defaultValueDate'], jsn.vObj['_defaultValueDate']);
//t.6    if jsn.has('defaultValueString') or jsn.has('_defaultValueString') then
        result.defaultValue := ParseString(jsn['defaultValueString'], jsn.vObj['_defaultValueString']);
//t.6    if jsn.has('defaultValueInteger') or jsn.has('_defaultValueInteger') then
        result.defaultValue := ParseInteger(jsn['defaultValueInteger'], jsn.vObj['_defaultValueInteger']);
//t.6    if jsn.has('defaultValueUri') or jsn.has('_defaultValueUri') then
        result.defaultValue := ParseUri(jsn['defaultValueUri'], jsn.vObj['_defaultValueUri']);
//t.6    if jsn.has('defaultValueInstant') or jsn.has('_defaultValueInstant') then
        result.defaultValue := ParseInstant(jsn['defaultValueInstant'], jsn.vObj['_defaultValueInstant']);
//t.6    if jsn.has('defaultValueBoolean') or jsn.has('_defaultValueBoolean') then
        result.defaultValue := ParseBoolean(jsn['defaultValueBoolean'], jsn.vObj['_defaultValueBoolean']);
//t.6    if jsn.has('defaultValueBase64Binary') or jsn.has('_defaultValueBase64Binary') then
        result.defaultValue := ParseBase64Binary(jsn['defaultValueBase64Binary'], jsn.vObj['_defaultValueBase64Binary']);
//t.6    if jsn.has('defaultValueTime') or jsn.has('_defaultValueTime') then
        result.defaultValue := ParseTime(jsn['defaultValueTime'], jsn.vObj['_defaultValueTime']);
//t.6    if jsn.has('defaultValueDecimal') or jsn.has('_defaultValueDecimal') then
        result.defaultValue := ParseDecimal(jsn['defaultValueDecimal'], jsn.vObj['_defaultValueDecimal']);
    if obj.has('defaultValueIdentifier') {a7} then
        result.defaultValue := ParseIdentifier(jsn.vObj['defaultValueIdentifier']);
    if obj.has('defaultValueCoding') {a7} then
        result.defaultValue := ParseCoding(jsn.vObj['defaultValueCoding']);
    if obj.has('defaultValueReference') {a7} then
        result.defaultValue := ParseReference(jsn.vObj['defaultValueReference']);
    if obj.has('defaultValueSignature') {a7} then
        result.defaultValue := ParseSignature(jsn.vObj['defaultValueSignature']);
    if obj.has('defaultValueSampledData') {a7} then
        result.defaultValue := ParseSampledData(jsn.vObj['defaultValueSampledData']);
    if obj.has('defaultValuePeriod') {a7} then
        result.defaultValue := ParsePeriod(jsn.vObj['defaultValuePeriod']);
    if obj.has('defaultValueQuantity') {a7} then
        result.defaultValue := ParseQuantity(jsn.vObj['defaultValueQuantity']);
    if obj.has('defaultValueAttachment') {a7} then
        result.defaultValue := ParseAttachment(jsn.vObj['defaultValueAttachment']);
    if obj.has('defaultValueRatio') {a7} then
        result.defaultValue := ParseRatio(jsn.vObj['defaultValueRatio']);
    if obj.has('defaultValueRange') {a7} then
        result.defaultValue := ParseRange(jsn.vObj['defaultValueRange']);
    if obj.has('defaultValueAnnotation') {a7} then
        result.defaultValue := ParseAnnotation(jsn.vObj['defaultValueAnnotation']);
    if obj.has('defaultValueCodeableConcept') {a7} then
        result.defaultValue := ParseCodeableConcept(jsn.vObj['defaultValueCodeableConcept']);
//t.5    if jsn.has('defaultValueHumanName') {a9} then
        result.defaultValue := ParseHumanName(jsn.vObj['defaultValueHumanName']);
//t.5    if jsn.has('defaultValueMeta') {a9} then
        result.defaultValue := ParseMeta(jsn.vObj['defaultValueMeta']);
//t.5    if jsn.has('defaultValueContactPoint') {a9} then
        result.defaultValue := ParseContactPoint(jsn.vObj['defaultValueContactPoint']);
//t.5    if jsn.has('defaultValueAddress') {a9} then
        result.defaultValue := ParseAddress(jsn.vObj['defaultValueAddress']);
//t.5    if jsn.has('defaultValueElementDefinition') {a9} then
        result.defaultValue := ParseElementDefinition(jsn.vObj['defaultValueElementDefinition']);
//t.5    if jsn.has('defaultValueTiming') {a9} then
        result.defaultValue := ParseTiming(jsn.vObj['defaultValueTiming']);
    result.meaningWhenMissingElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.meaningWhenMissing'));{q1}
//t.6    if jsn.has('fixedCode') or jsn.has('_fixedCode') then
        result.fixed := ParseCode(jsn['fixedCode'], jsn.vObj['_fixedCode']);
//t.6    if jsn.has('fixedOid') or jsn.has('_fixedOid') then
        result.fixed := ParseOid(jsn['fixedOid'], jsn.vObj['_fixedOid']);
//t.6    if jsn.has('fixedUuid') or jsn.has('_fixedUuid') then
        result.fixed := ParseUuid(jsn['fixedUuid'], jsn.vObj['_fixedUuid']);
//t.6    if jsn.has('fixedMarkdown') or jsn.has('_fixedMarkdown') then
        result.fixed := ParseMarkdown(jsn['fixedMarkdown'], jsn.vObj['_fixedMarkdown']);
//t.6    if jsn.has('fixedUnsignedInt') or jsn.has('_fixedUnsignedInt') then
        result.fixed := ParseUnsignedInt(jsn['fixedUnsignedInt'], jsn.vObj['_fixedUnsignedInt']);
//t.6    if jsn.has('fixedId') or jsn.has('_fixedId') then
        result.fixed := ParseId(jsn['fixedId'], jsn.vObj['_fixedId']);
//t.6    if jsn.has('fixedPositiveInt') or jsn.has('_fixedPositiveInt') then
        result.fixed := ParsePositiveInt(jsn['fixedPositiveInt'], jsn.vObj['_fixedPositiveInt']);
//t.6    if jsn.has('fixedDateTime') or jsn.has('_fixedDateTime') then
        result.fixed := ParseDateTime(jsn['fixedDateTime'], jsn.vObj['_fixedDateTime']);
//t.6    if jsn.has('fixedDate') or jsn.has('_fixedDate') then
        result.fixed := ParseDate(jsn['fixedDate'], jsn.vObj['_fixedDate']);
//t.6    if jsn.has('fixedString') or jsn.has('_fixedString') then
        result.fixed := ParseString(jsn['fixedString'], jsn.vObj['_fixedString']);
//t.6    if jsn.has('fixedInteger') or jsn.has('_fixedInteger') then
        result.fixed := ParseInteger(jsn['fixedInteger'], jsn.vObj['_fixedInteger']);
//t.6    if jsn.has('fixedUri') or jsn.has('_fixedUri') then
        result.fixed := ParseUri(jsn['fixedUri'], jsn.vObj['_fixedUri']);
//t.6    if jsn.has('fixedInstant') or jsn.has('_fixedInstant') then
        result.fixed := ParseInstant(jsn['fixedInstant'], jsn.vObj['_fixedInstant']);
//t.6    if jsn.has('fixedBoolean') or jsn.has('_fixedBoolean') then
        result.fixed := ParseBoolean(jsn['fixedBoolean'], jsn.vObj['_fixedBoolean']);
//t.6    if jsn.has('fixedBase64Binary') or jsn.has('_fixedBase64Binary') then
        result.fixed := ParseBase64Binary(jsn['fixedBase64Binary'], jsn.vObj['_fixedBase64Binary']);
//t.6    if jsn.has('fixedTime') or jsn.has('_fixedTime') then
        result.fixed := ParseTime(jsn['fixedTime'], jsn.vObj['_fixedTime']);
//t.6    if jsn.has('fixedDecimal') or jsn.has('_fixedDecimal') then
        result.fixed := ParseDecimal(jsn['fixedDecimal'], jsn.vObj['_fixedDecimal']);
    if obj.has('fixedIdentifier') {a7} then
        result.fixed := ParseIdentifier(jsn.vObj['fixedIdentifier']);
    if obj.has('fixedCoding') {a7} then
        result.fixed := ParseCoding(jsn.vObj['fixedCoding']);
    if obj.has('fixedReference') {a7} then
        result.fixed := ParseReference(jsn.vObj['fixedReference']);
    if obj.has('fixedSignature') {a7} then
        result.fixed := ParseSignature(jsn.vObj['fixedSignature']);
    if obj.has('fixedSampledData') {a7} then
        result.fixed := ParseSampledData(jsn.vObj['fixedSampledData']);
    if obj.has('fixedPeriod') {a7} then
        result.fixed := ParsePeriod(jsn.vObj['fixedPeriod']);
    if obj.has('fixedQuantity') {a7} then
        result.fixed := ParseQuantity(jsn.vObj['fixedQuantity']);
    if obj.has('fixedAttachment') {a7} then
        result.fixed := ParseAttachment(jsn.vObj['fixedAttachment']);
    if obj.has('fixedRatio') {a7} then
        result.fixed := ParseRatio(jsn.vObj['fixedRatio']);
    if obj.has('fixedRange') {a7} then
        result.fixed := ParseRange(jsn.vObj['fixedRange']);
    if obj.has('fixedAnnotation') {a7} then
        result.fixed := ParseAnnotation(jsn.vObj['fixedAnnotation']);
    if obj.has('fixedCodeableConcept') {a7} then
        result.fixed := ParseCodeableConcept(jsn.vObj['fixedCodeableConcept']);
//t.5    if jsn.has('fixedHumanName') {a9} then
        result.fixed := ParseHumanName(jsn.vObj['fixedHumanName']);
//t.5    if jsn.has('fixedMeta') {a9} then
        result.fixed := ParseMeta(jsn.vObj['fixedMeta']);
//t.5    if jsn.has('fixedContactPoint') {a9} then
        result.fixed := ParseContactPoint(jsn.vObj['fixedContactPoint']);
//t.5    if jsn.has('fixedAddress') {a9} then
        result.fixed := ParseAddress(jsn.vObj['fixedAddress']);
//t.5    if jsn.has('fixedElementDefinition') {a9} then
        result.fixed := ParseElementDefinition(jsn.vObj['fixedElementDefinition']);
//t.5    if jsn.has('fixedTiming') {a9} then
        result.fixed := ParseTiming(jsn.vObj['fixedTiming']);
//t.6    if jsn.has('patternCode') or jsn.has('_patternCode') then
        result.pattern := ParseCode(jsn['patternCode'], jsn.vObj['_patternCode']);
//t.6    if jsn.has('patternOid') or jsn.has('_patternOid') then
        result.pattern := ParseOid(jsn['patternOid'], jsn.vObj['_patternOid']);
//t.6    if jsn.has('patternUuid') or jsn.has('_patternUuid') then
        result.pattern := ParseUuid(jsn['patternUuid'], jsn.vObj['_patternUuid']);
//t.6    if jsn.has('patternMarkdown') or jsn.has('_patternMarkdown') then
        result.pattern := ParseMarkdown(jsn['patternMarkdown'], jsn.vObj['_patternMarkdown']);
//t.6    if jsn.has('patternUnsignedInt') or jsn.has('_patternUnsignedInt') then
        result.pattern := ParseUnsignedInt(jsn['patternUnsignedInt'], jsn.vObj['_patternUnsignedInt']);
//t.6    if jsn.has('patternId') or jsn.has('_patternId') then
        result.pattern := ParseId(jsn['patternId'], jsn.vObj['_patternId']);
//t.6    if jsn.has('patternPositiveInt') or jsn.has('_patternPositiveInt') then
        result.pattern := ParsePositiveInt(jsn['patternPositiveInt'], jsn.vObj['_patternPositiveInt']);
//t.6    if jsn.has('patternDateTime') or jsn.has('_patternDateTime') then
        result.pattern := ParseDateTime(jsn['patternDateTime'], jsn.vObj['_patternDateTime']);
//t.6    if jsn.has('patternDate') or jsn.has('_patternDate') then
        result.pattern := ParseDate(jsn['patternDate'], jsn.vObj['_patternDate']);
//t.6    if jsn.has('patternString') or jsn.has('_patternString') then
        result.pattern := ParseString(jsn['patternString'], jsn.vObj['_patternString']);
//t.6    if jsn.has('patternInteger') or jsn.has('_patternInteger') then
        result.pattern := ParseInteger(jsn['patternInteger'], jsn.vObj['_patternInteger']);
//t.6    if jsn.has('patternUri') or jsn.has('_patternUri') then
        result.pattern := ParseUri(jsn['patternUri'], jsn.vObj['_patternUri']);
//t.6    if jsn.has('patternInstant') or jsn.has('_patternInstant') then
        result.pattern := ParseInstant(jsn['patternInstant'], jsn.vObj['_patternInstant']);
//t.6    if jsn.has('patternBoolean') or jsn.has('_patternBoolean') then
        result.pattern := ParseBoolean(jsn['patternBoolean'], jsn.vObj['_patternBoolean']);
//t.6    if jsn.has('patternBase64Binary') or jsn.has('_patternBase64Binary') then
        result.pattern := ParseBase64Binary(jsn['patternBase64Binary'], jsn.vObj['_patternBase64Binary']);
//t.6    if jsn.has('patternTime') or jsn.has('_patternTime') then
        result.pattern := ParseTime(jsn['patternTime'], jsn.vObj['_patternTime']);
//t.6    if jsn.has('patternDecimal') or jsn.has('_patternDecimal') then
        result.pattern := ParseDecimal(jsn['patternDecimal'], jsn.vObj['_patternDecimal']);
    if obj.has('patternIdentifier') {a7} then
        result.pattern := ParseIdentifier(jsn.vObj['patternIdentifier']);
    if obj.has('patternCoding') {a7} then
        result.pattern := ParseCoding(jsn.vObj['patternCoding']);
    if obj.has('patternReference') {a7} then
        result.pattern := ParseReference(jsn.vObj['patternReference']);
    if obj.has('patternSignature') {a7} then
        result.pattern := ParseSignature(jsn.vObj['patternSignature']);
    if obj.has('patternSampledData') {a7} then
        result.pattern := ParseSampledData(jsn.vObj['patternSampledData']);
    if obj.has('patternPeriod') {a7} then
        result.pattern := ParsePeriod(jsn.vObj['patternPeriod']);
    if obj.has('patternQuantity') {a7} then
        result.pattern := ParseQuantity(jsn.vObj['patternQuantity']);
    if obj.has('patternAttachment') {a7} then
        result.pattern := ParseAttachment(jsn.vObj['patternAttachment']);
    if obj.has('patternRatio') {a7} then
        result.pattern := ParseRatio(jsn.vObj['patternRatio']);
    if obj.has('patternRange') {a7} then
        result.pattern := ParseRange(jsn.vObj['patternRange']);
    if obj.has('patternAnnotation') {a7} then
        result.pattern := ParseAnnotation(jsn.vObj['patternAnnotation']);
    if obj.has('patternCodeableConcept') {a7} then
        result.pattern := ParseCodeableConcept(jsn.vObj['patternCodeableConcept']);
//t.5    if jsn.has('patternHumanName') {a9} then
        result.pattern := ParseHumanName(jsn.vObj['patternHumanName']);
//t.5    if jsn.has('patternMeta') {a9} then
        result.pattern := ParseMeta(jsn.vObj['patternMeta']);
//t.5    if jsn.has('patternContactPoint') {a9} then
        result.pattern := ParseContactPoint(jsn.vObj['patternContactPoint']);
//t.5    if jsn.has('patternAddress') {a9} then
        result.pattern := ParseAddress(jsn.vObj['patternAddress']);
//t.5    if jsn.has('patternElementDefinition') {a9} then
        result.pattern := ParseElementDefinition(jsn.vObj['patternElementDefinition']);
//t.5    if jsn.has('patternTiming') {a9} then
        result.pattern := ParseTiming(jsn.vObj['patternTiming']);
//t.6    if jsn.has('exampleCode') or jsn.has('_exampleCode') then
        result.example := ParseCode(jsn['exampleCode'], jsn.vObj['_exampleCode']);
//t.6    if jsn.has('exampleOid') or jsn.has('_exampleOid') then
        result.example := ParseOid(jsn['exampleOid'], jsn.vObj['_exampleOid']);
//t.6    if jsn.has('exampleUuid') or jsn.has('_exampleUuid') then
        result.example := ParseUuid(jsn['exampleUuid'], jsn.vObj['_exampleUuid']);
//t.6    if jsn.has('exampleMarkdown') or jsn.has('_exampleMarkdown') then
        result.example := ParseMarkdown(jsn['exampleMarkdown'], jsn.vObj['_exampleMarkdown']);
//t.6    if jsn.has('exampleUnsignedInt') or jsn.has('_exampleUnsignedInt') then
        result.example := ParseUnsignedInt(jsn['exampleUnsignedInt'], jsn.vObj['_exampleUnsignedInt']);
//t.6    if jsn.has('exampleId') or jsn.has('_exampleId') then
        result.example := ParseId(jsn['exampleId'], jsn.vObj['_exampleId']);
//t.6    if jsn.has('examplePositiveInt') or jsn.has('_examplePositiveInt') then
        result.example := ParsePositiveInt(jsn['examplePositiveInt'], jsn.vObj['_examplePositiveInt']);
//t.6    if jsn.has('exampleDateTime') or jsn.has('_exampleDateTime') then
        result.example := ParseDateTime(jsn['exampleDateTime'], jsn.vObj['_exampleDateTime']);
//t.6    if jsn.has('exampleDate') or jsn.has('_exampleDate') then
        result.example := ParseDate(jsn['exampleDate'], jsn.vObj['_exampleDate']);
//t.6    if jsn.has('exampleString') or jsn.has('_exampleString') then
        result.example := ParseString(jsn['exampleString'], jsn.vObj['_exampleString']);
//t.6    if jsn.has('exampleInteger') or jsn.has('_exampleInteger') then
        result.example := ParseInteger(jsn['exampleInteger'], jsn.vObj['_exampleInteger']);
//t.6    if jsn.has('exampleUri') or jsn.has('_exampleUri') then
        result.example := ParseUri(jsn['exampleUri'], jsn.vObj['_exampleUri']);
//t.6    if jsn.has('exampleInstant') or jsn.has('_exampleInstant') then
        result.example := ParseInstant(jsn['exampleInstant'], jsn.vObj['_exampleInstant']);
//t.6    if jsn.has('exampleBoolean') or jsn.has('_exampleBoolean') then
        result.example := ParseBoolean(jsn['exampleBoolean'], jsn.vObj['_exampleBoolean']);
//t.6    if jsn.has('exampleBase64Binary') or jsn.has('_exampleBase64Binary') then
        result.example := ParseBase64Binary(jsn['exampleBase64Binary'], jsn.vObj['_exampleBase64Binary']);
//t.6    if jsn.has('exampleTime') or jsn.has('_exampleTime') then
        result.example := ParseTime(jsn['exampleTime'], jsn.vObj['_exampleTime']);
//t.6    if jsn.has('exampleDecimal') or jsn.has('_exampleDecimal') then
        result.example := ParseDecimal(jsn['exampleDecimal'], jsn.vObj['_exampleDecimal']);
    if obj.has('exampleIdentifier') {a7} then
        result.example := ParseIdentifier(jsn.vObj['exampleIdentifier']);
    if obj.has('exampleCoding') {a7} then
        result.example := ParseCoding(jsn.vObj['exampleCoding']);
    if obj.has('exampleReference') {a7} then
        result.example := ParseReference(jsn.vObj['exampleReference']);
    if obj.has('exampleSignature') {a7} then
        result.example := ParseSignature(jsn.vObj['exampleSignature']);
    if obj.has('exampleSampledData') {a7} then
        result.example := ParseSampledData(jsn.vObj['exampleSampledData']);
    if obj.has('examplePeriod') {a7} then
        result.example := ParsePeriod(jsn.vObj['examplePeriod']);
    if obj.has('exampleQuantity') {a7} then
        result.example := ParseQuantity(jsn.vObj['exampleQuantity']);
    if obj.has('exampleAttachment') {a7} then
        result.example := ParseAttachment(jsn.vObj['exampleAttachment']);
    if obj.has('exampleRatio') {a7} then
        result.example := ParseRatio(jsn.vObj['exampleRatio']);
    if obj.has('exampleRange') {a7} then
        result.example := ParseRange(jsn.vObj['exampleRange']);
    if obj.has('exampleAnnotation') {a7} then
        result.example := ParseAnnotation(jsn.vObj['exampleAnnotation']);
    if obj.has('exampleCodeableConcept') {a7} then
        result.example := ParseCodeableConcept(jsn.vObj['exampleCodeableConcept']);
//t.5    if jsn.has('exampleHumanName') {a9} then
        result.example := ParseHumanName(jsn.vObj['exampleHumanName']);
//t.5    if jsn.has('exampleMeta') {a9} then
        result.example := ParseMeta(jsn.vObj['exampleMeta']);
//t.5    if jsn.has('exampleContactPoint') {a9} then
        result.example := ParseContactPoint(jsn.vObj['exampleContactPoint']);
//t.5    if jsn.has('exampleAddress') {a9} then
        result.example := ParseAddress(jsn.vObj['exampleAddress']);
//t.5    if jsn.has('exampleElementDefinition') {a9} then
        result.example := ParseElementDefinition(jsn.vObj['exampleElementDefinition']);
//t.5    if jsn.has('exampleTiming') {a9} then
        result.example := ParseTiming(jsn.vObj['exampleTiming']);
//t.6    if jsn.has('minValueCode') or jsn.has('_minValueCode') then
        result.minValue := ParseCode(jsn['minValueCode'], jsn.vObj['_minValueCode']);
//t.6    if jsn.has('minValueOid') or jsn.has('_minValueOid') then
        result.minValue := ParseOid(jsn['minValueOid'], jsn.vObj['_minValueOid']);
//t.6    if jsn.has('minValueUuid') or jsn.has('_minValueUuid') then
        result.minValue := ParseUuid(jsn['minValueUuid'], jsn.vObj['_minValueUuid']);
//t.6    if jsn.has('minValueMarkdown') or jsn.has('_minValueMarkdown') then
        result.minValue := ParseMarkdown(jsn['minValueMarkdown'], jsn.vObj['_minValueMarkdown']);
//t.6    if jsn.has('minValueUnsignedInt') or jsn.has('_minValueUnsignedInt') then
        result.minValue := ParseUnsignedInt(jsn['minValueUnsignedInt'], jsn.vObj['_minValueUnsignedInt']);
//t.6    if jsn.has('minValueId') or jsn.has('_minValueId') then
        result.minValue := ParseId(jsn['minValueId'], jsn.vObj['_minValueId']);
//t.6    if jsn.has('minValuePositiveInt') or jsn.has('_minValuePositiveInt') then
        result.minValue := ParsePositiveInt(jsn['minValuePositiveInt'], jsn.vObj['_minValuePositiveInt']);
//t.6    if jsn.has('minValueDateTime') or jsn.has('_minValueDateTime') then
        result.minValue := ParseDateTime(jsn['minValueDateTime'], jsn.vObj['_minValueDateTime']);
//t.6    if jsn.has('minValueDate') or jsn.has('_minValueDate') then
        result.minValue := ParseDate(jsn['minValueDate'], jsn.vObj['_minValueDate']);
//t.6    if jsn.has('minValueString') or jsn.has('_minValueString') then
        result.minValue := ParseString(jsn['minValueString'], jsn.vObj['_minValueString']);
//t.6    if jsn.has('minValueInteger') or jsn.has('_minValueInteger') then
        result.minValue := ParseInteger(jsn['minValueInteger'], jsn.vObj['_minValueInteger']);
//t.6    if jsn.has('minValueUri') or jsn.has('_minValueUri') then
        result.minValue := ParseUri(jsn['minValueUri'], jsn.vObj['_minValueUri']);
//t.6    if jsn.has('minValueInstant') or jsn.has('_minValueInstant') then
        result.minValue := ParseInstant(jsn['minValueInstant'], jsn.vObj['_minValueInstant']);
//t.6    if jsn.has('minValueBoolean') or jsn.has('_minValueBoolean') then
        result.minValue := ParseBoolean(jsn['minValueBoolean'], jsn.vObj['_minValueBoolean']);
//t.6    if jsn.has('minValueBase64Binary') or jsn.has('_minValueBase64Binary') then
        result.minValue := ParseBase64Binary(jsn['minValueBase64Binary'], jsn.vObj['_minValueBase64Binary']);
//t.6    if jsn.has('minValueTime') or jsn.has('_minValueTime') then
        result.minValue := ParseTime(jsn['minValueTime'], jsn.vObj['_minValueTime']);
//t.6    if jsn.has('minValueDecimal') or jsn.has('_minValueDecimal') then
        result.minValue := ParseDecimal(jsn['minValueDecimal'], jsn.vObj['_minValueDecimal']);
    if obj.has('minValueIdentifier') {a7} then
        result.minValue := ParseIdentifier(jsn.vObj['minValueIdentifier']);
    if obj.has('minValueCoding') {a7} then
        result.minValue := ParseCoding(jsn.vObj['minValueCoding']);
    if obj.has('minValueReference') {a7} then
        result.minValue := ParseReference(jsn.vObj['minValueReference']);
    if obj.has('minValueSignature') {a7} then
        result.minValue := ParseSignature(jsn.vObj['minValueSignature']);
    if obj.has('minValueSampledData') {a7} then
        result.minValue := ParseSampledData(jsn.vObj['minValueSampledData']);
    if obj.has('minValuePeriod') {a7} then
        result.minValue := ParsePeriod(jsn.vObj['minValuePeriod']);
    if obj.has('minValueQuantity') {a7} then
        result.minValue := ParseQuantity(jsn.vObj['minValueQuantity']);
    if obj.has('minValueAttachment') {a7} then
        result.minValue := ParseAttachment(jsn.vObj['minValueAttachment']);
    if obj.has('minValueRatio') {a7} then
        result.minValue := ParseRatio(jsn.vObj['minValueRatio']);
    if obj.has('minValueRange') {a7} then
        result.minValue := ParseRange(jsn.vObj['minValueRange']);
    if obj.has('minValueAnnotation') {a7} then
        result.minValue := ParseAnnotation(jsn.vObj['minValueAnnotation']);
    if obj.has('minValueCodeableConcept') {a7} then
        result.minValue := ParseCodeableConcept(jsn.vObj['minValueCodeableConcept']);
//t.5    if jsn.has('minValueHumanName') {a9} then
        result.minValue := ParseHumanName(jsn.vObj['minValueHumanName']);
//t.5    if jsn.has('minValueMeta') {a9} then
        result.minValue := ParseMeta(jsn.vObj['minValueMeta']);
//t.5    if jsn.has('minValueContactPoint') {a9} then
        result.minValue := ParseContactPoint(jsn.vObj['minValueContactPoint']);
//t.5    if jsn.has('minValueAddress') {a9} then
        result.minValue := ParseAddress(jsn.vObj['minValueAddress']);
//t.5    if jsn.has('minValueElementDefinition') {a9} then
        result.minValue := ParseElementDefinition(jsn.vObj['minValueElementDefinition']);
//t.5    if jsn.has('minValueTiming') {a9} then
        result.minValue := ParseTiming(jsn.vObj['minValueTiming']);
//t.6    if jsn.has('maxValueCode') or jsn.has('_maxValueCode') then
        result.maxValue := ParseCode(jsn['maxValueCode'], jsn.vObj['_maxValueCode']);
//t.6    if jsn.has('maxValueOid') or jsn.has('_maxValueOid') then
        result.maxValue := ParseOid(jsn['maxValueOid'], jsn.vObj['_maxValueOid']);
//t.6    if jsn.has('maxValueUuid') or jsn.has('_maxValueUuid') then
        result.maxValue := ParseUuid(jsn['maxValueUuid'], jsn.vObj['_maxValueUuid']);
//t.6    if jsn.has('maxValueMarkdown') or jsn.has('_maxValueMarkdown') then
        result.maxValue := ParseMarkdown(jsn['maxValueMarkdown'], jsn.vObj['_maxValueMarkdown']);
//t.6    if jsn.has('maxValueUnsignedInt') or jsn.has('_maxValueUnsignedInt') then
        result.maxValue := ParseUnsignedInt(jsn['maxValueUnsignedInt'], jsn.vObj['_maxValueUnsignedInt']);
//t.6    if jsn.has('maxValueId') or jsn.has('_maxValueId') then
        result.maxValue := ParseId(jsn['maxValueId'], jsn.vObj['_maxValueId']);
//t.6    if jsn.has('maxValuePositiveInt') or jsn.has('_maxValuePositiveInt') then
        result.maxValue := ParsePositiveInt(jsn['maxValuePositiveInt'], jsn.vObj['_maxValuePositiveInt']);
//t.6    if jsn.has('maxValueDateTime') or jsn.has('_maxValueDateTime') then
        result.maxValue := ParseDateTime(jsn['maxValueDateTime'], jsn.vObj['_maxValueDateTime']);
//t.6    if jsn.has('maxValueDate') or jsn.has('_maxValueDate') then
        result.maxValue := ParseDate(jsn['maxValueDate'], jsn.vObj['_maxValueDate']);
//t.6    if jsn.has('maxValueString') or jsn.has('_maxValueString') then
        result.maxValue := ParseString(jsn['maxValueString'], jsn.vObj['_maxValueString']);
//t.6    if jsn.has('maxValueInteger') or jsn.has('_maxValueInteger') then
        result.maxValue := ParseInteger(jsn['maxValueInteger'], jsn.vObj['_maxValueInteger']);
//t.6    if jsn.has('maxValueUri') or jsn.has('_maxValueUri') then
        result.maxValue := ParseUri(jsn['maxValueUri'], jsn.vObj['_maxValueUri']);
//t.6    if jsn.has('maxValueInstant') or jsn.has('_maxValueInstant') then
        result.maxValue := ParseInstant(jsn['maxValueInstant'], jsn.vObj['_maxValueInstant']);
//t.6    if jsn.has('maxValueBoolean') or jsn.has('_maxValueBoolean') then
        result.maxValue := ParseBoolean(jsn['maxValueBoolean'], jsn.vObj['_maxValueBoolean']);
//t.6    if jsn.has('maxValueBase64Binary') or jsn.has('_maxValueBase64Binary') then
        result.maxValue := ParseBase64Binary(jsn['maxValueBase64Binary'], jsn.vObj['_maxValueBase64Binary']);
//t.6    if jsn.has('maxValueTime') or jsn.has('_maxValueTime') then
        result.maxValue := ParseTime(jsn['maxValueTime'], jsn.vObj['_maxValueTime']);
//t.6    if jsn.has('maxValueDecimal') or jsn.has('_maxValueDecimal') then
        result.maxValue := ParseDecimal(jsn['maxValueDecimal'], jsn.vObj['_maxValueDecimal']);
    if obj.has('maxValueIdentifier') {a7} then
        result.maxValue := ParseIdentifier(jsn.vObj['maxValueIdentifier']);
    if obj.has('maxValueCoding') {a7} then
        result.maxValue := ParseCoding(jsn.vObj['maxValueCoding']);
    if obj.has('maxValueReference') {a7} then
        result.maxValue := ParseReference(jsn.vObj['maxValueReference']);
    if obj.has('maxValueSignature') {a7} then
        result.maxValue := ParseSignature(jsn.vObj['maxValueSignature']);
    if obj.has('maxValueSampledData') {a7} then
        result.maxValue := ParseSampledData(jsn.vObj['maxValueSampledData']);
    if obj.has('maxValuePeriod') {a7} then
        result.maxValue := ParsePeriod(jsn.vObj['maxValuePeriod']);
    if obj.has('maxValueQuantity') {a7} then
        result.maxValue := ParseQuantity(jsn.vObj['maxValueQuantity']);
    if obj.has('maxValueAttachment') {a7} then
        result.maxValue := ParseAttachment(jsn.vObj['maxValueAttachment']);
    if obj.has('maxValueRatio') {a7} then
        result.maxValue := ParseRatio(jsn.vObj['maxValueRatio']);
    if obj.has('maxValueRange') {a7} then
        result.maxValue := ParseRange(jsn.vObj['maxValueRange']);
    if obj.has('maxValueAnnotation') {a7} then
        result.maxValue := ParseAnnotation(jsn.vObj['maxValueAnnotation']);
    if obj.has('maxValueCodeableConcept') {a7} then
        result.maxValue := ParseCodeableConcept(jsn.vObj['maxValueCodeableConcept']);
//t.5    if jsn.has('maxValueHumanName') {a9} then
        result.maxValue := ParseHumanName(jsn.vObj['maxValueHumanName']);
//t.5    if jsn.has('maxValueMeta') {a9} then
        result.maxValue := ParseMeta(jsn.vObj['maxValueMeta']);
//t.5    if jsn.has('maxValueContactPoint') {a9} then
        result.maxValue := ParseContactPoint(jsn.vObj['maxValueContactPoint']);
//t.5    if jsn.has('maxValueAddress') {a9} then
        result.maxValue := ParseAddress(jsn.vObj['maxValueAddress']);
//t.5    if jsn.has('maxValueElementDefinition') {a9} then
        result.maxValue := ParseElementDefinition(jsn.vObj['maxValueElementDefinition']);
//t.5    if jsn.has('maxValueTiming') {a9} then
        result.maxValue := ParseTiming(jsn.vObj['maxValueTiming']);
    result.maxLengthElement := ParseInteger(obj.complex('http://hl7.org/fhir/ElementDefinition.maxLength'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.condition') do
      result.conditionList.Add(parseId(item));
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.constraint') do
      result.constraintList.Add(parseElementDefinitionConstraint(item));
    result.mustSupportElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.mustSupport'));{q1}
    result.isModifierElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.isModifier'));{q1}
    result.isSummaryElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.isSummary'));{q1}
    result.binding := ParseElementDefinitionBinding(obj.complex('http://hl7.org/fhir/ElementDefinition.binding'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.mapping') do
      result.mappingList.Add(parseElementDefinitionMapping(item));
end;

procedure TFHIRTurtleComposer.ComposeElementDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinition'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeString(this, 'ElementDefinition', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.representationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition', 'representation', elem.representationList[i], CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.representationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition', 'representation', elem.representationList[i], CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'label', elem.label_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(this, 'ElementDefinition', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionSlicing(this, 'ElementDefinition', 'slicing', elem.slicingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'short', elem.shortElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(this, 'ElementDefinition', 'definition', elem.definitionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(this, 'ElementDefinition', 'comments', elem.commentsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(this, 'ElementDefinition', 'requirements', elem.requirementsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.aliasList.Count - 1 do
      ComposeString(this, 'ElementDefinition', 'alias', elem.aliasList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInteger(this, 'ElementDefinition', 'min', elem.minElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'max', elem.maxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBase(this, 'ElementDefinition', 'base', elem.baseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeElementDefinitionType(this, 'ElementDefinition', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'nameReference', elem.nameReferenceElement, false, -1);{x.2ea}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCode) {1} then
    ComposeCode(this, 'ElementDefinition', 'defaultValueCode', TFhirCode(elem.defaultValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirOid) {1} then
    ComposeOid(this, 'ElementDefinition', 'defaultValueOid', TFhirOid(elem.defaultValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUuid) {1} then
    ComposeUuid(this, 'ElementDefinition', 'defaultValueUuid', TFhirUuid(elem.defaultValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMarkdown) {1} then
    ComposeMarkdown(this, 'ElementDefinition', 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirId) {1} then
    ComposeId(this, 'ElementDefinition', 'defaultValueId', TFhirId(elem.defaultValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirPositiveInt) {1} then
    ComposePositiveInt(this, 'ElementDefinition', 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDateTime) {1} then
    ComposeDateTime(this, 'ElementDefinition', 'defaultValueDateTime', TFhirDateTime(elem.defaultValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDate) {1} then
    ComposeDate(this, 'ElementDefinition', 'defaultValueDate', TFhirDate(elem.defaultValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirString) {1} then
    ComposeString(this, 'ElementDefinition', 'defaultValueString', TFhirString(elem.defaultValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInteger) {1} then
    ComposeInteger(this, 'ElementDefinition', 'defaultValueInteger', TFhirInteger(elem.defaultValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUri) {1} then
    ComposeUri(this, 'ElementDefinition', 'defaultValueUri', TFhirUri(elem.defaultValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInstant) {1} then
    ComposeInstant(this, 'ElementDefinition', 'defaultValueInstant', TFhirInstant(elem.defaultValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBoolean) {1} then
    ComposeBoolean(this, 'ElementDefinition', 'defaultValueBoolean', TFhirBoolean(elem.defaultValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBase64Binary) {1} then
    ComposeBase64Binary(this, 'ElementDefinition', 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTime) {1} then
    ComposeTime(this, 'ElementDefinition', 'defaultValueTime', TFhirTime(elem.defaultValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDecimal) {1} then
    ComposeDecimal(this, 'ElementDefinition', 'defaultValueDecimal', TFhirDecimal(elem.defaultValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirIdentifier) {8} then
    ComposeIdentifier(this, 'ElementDefinition', 'defaultValueIdentifier', TFhirIdentifier(elem.defaultValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirCoding) {8} then
    ComposeCoding(this, 'ElementDefinition', 'defaultValueCoding', TFhirCoding(elem.defaultValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirReference) {8} then
    ComposeReference(this, 'ElementDefinition', 'defaultValueReference', TFhirReference(elem.defaultValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirSignature) {8} then
    ComposeSignature(this, 'ElementDefinition', 'defaultValueSignature', TFhirSignature(elem.defaultValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirSampledData) {8} then
    ComposeSampledData(this, 'ElementDefinition', 'defaultValueSampledData', TFhirSampledData(elem.defaultValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirPeriod) {8} then
    ComposePeriod(this, 'ElementDefinition', 'defaultValuePeriod', TFhirPeriod(elem.defaultValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirQuantity) {8} then
    ComposeQuantity(this, 'ElementDefinition', 'defaultValueQuantity', TFhirQuantity(elem.defaultValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirAttachment) {8} then
    ComposeAttachment(this, 'ElementDefinition', 'defaultValueAttachment', TFhirAttachment(elem.defaultValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirRatio) {8} then
    ComposeRatio(this, 'ElementDefinition', 'defaultValueRatio', TFhirRatio(elem.defaultValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirRange) {8} then
    ComposeRange(this, 'ElementDefinition', 'defaultValueRange', TFhirRange(elem.defaultValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirAnnotation) {8} then
    ComposeAnnotation(this, 'ElementDefinition', 'defaultValueAnnotation', TFhirAnnotation(elem.defaultValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'defaultValueCodeableConcept', TFhirCodeableConcept(elem.defaultValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirHumanName) {9} then
    ComposeHumanName(this, 'ElementDefinition', 'defaultValueHumanName', TFhirHumanName(elem.defaultValue), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirMeta) {9} then
    ComposeMeta(this, 'ElementDefinition', 'defaultValueMeta', TFhirMeta(elem.defaultValue), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirContactPoint) {9} then
    ComposeContactPoint(this, 'ElementDefinition', 'defaultValueContactPoint', TFhirContactPoint(elem.defaultValue), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirAddress) {9} then
    ComposeAddress(this, 'ElementDefinition', 'defaultValueAddress', TFhirAddress(elem.defaultValue), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirElementDefinition) {9} then
    ComposeElementDefinition(this, 'ElementDefinition', 'defaultValueElementDefinition', TFhirElementDefinition(elem.defaultValue), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirTiming) {9} then
    ComposeTiming(this, 'ElementDefinition', 'defaultValueTiming', TFhirTiming(elem.defaultValue), true, -1);{x.d6}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(this, 'ElementDefinition', 'meaningWhenMissing', elem.meaningWhenMissingElement, false, -1);{x.2ea}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCode) {1} then
    ComposeCode(this, 'ElementDefinition', 'fixedCode', TFhirCode(elem.fixed), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirOid) {1} then
    ComposeOid(this, 'ElementDefinition', 'fixedOid', TFhirOid(elem.fixed), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUuid) {1} then
    ComposeUuid(this, 'ElementDefinition', 'fixedUuid', TFhirUuid(elem.fixed), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMarkdown) {1} then
    ComposeMarkdown(this, 'ElementDefinition', 'fixedMarkdown', TFhirMarkdown(elem.fixed), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'fixedUnsignedInt', TFhirUnsignedInt(elem.fixed), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirId) {1} then
    ComposeId(this, 'ElementDefinition', 'fixedId', TFhirId(elem.fixed), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirPositiveInt) {1} then
    ComposePositiveInt(this, 'ElementDefinition', 'fixedPositiveInt', TFhirPositiveInt(elem.fixed), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDateTime) {1} then
    ComposeDateTime(this, 'ElementDefinition', 'fixedDateTime', TFhirDateTime(elem.fixed), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDate) {1} then
    ComposeDate(this, 'ElementDefinition', 'fixedDate', TFhirDate(elem.fixed), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirString) {1} then
    ComposeString(this, 'ElementDefinition', 'fixedString', TFhirString(elem.fixed), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInteger) {1} then
    ComposeInteger(this, 'ElementDefinition', 'fixedInteger', TFhirInteger(elem.fixed), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUri) {1} then
    ComposeUri(this, 'ElementDefinition', 'fixedUri', TFhirUri(elem.fixed), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInstant) {1} then
    ComposeInstant(this, 'ElementDefinition', 'fixedInstant', TFhirInstant(elem.fixed), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBoolean) {1} then
    ComposeBoolean(this, 'ElementDefinition', 'fixedBoolean', TFhirBoolean(elem.fixed), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBase64Binary) {1} then
    ComposeBase64Binary(this, 'ElementDefinition', 'fixedBase64Binary', TFhirBase64Binary(elem.fixed), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTime) {1} then
    ComposeTime(this, 'ElementDefinition', 'fixedTime', TFhirTime(elem.fixed), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDecimal) {1} then
    ComposeDecimal(this, 'ElementDefinition', 'fixedDecimal', TFhirDecimal(elem.fixed), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirIdentifier) {8} then
    ComposeIdentifier(this, 'ElementDefinition', 'fixedIdentifier', TFhirIdentifier(elem.fixed), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirCoding) {8} then
    ComposeCoding(this, 'ElementDefinition', 'fixedCoding', TFhirCoding(elem.fixed), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirReference) {8} then
    ComposeReference(this, 'ElementDefinition', 'fixedReference', TFhirReference(elem.fixed), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirSignature) {8} then
    ComposeSignature(this, 'ElementDefinition', 'fixedSignature', TFhirSignature(elem.fixed), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirSampledData) {8} then
    ComposeSampledData(this, 'ElementDefinition', 'fixedSampledData', TFhirSampledData(elem.fixed), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirPeriod) {8} then
    ComposePeriod(this, 'ElementDefinition', 'fixedPeriod', TFhirPeriod(elem.fixed), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirQuantity) {8} then
    ComposeQuantity(this, 'ElementDefinition', 'fixedQuantity', TFhirQuantity(elem.fixed), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirAttachment) {8} then
    ComposeAttachment(this, 'ElementDefinition', 'fixedAttachment', TFhirAttachment(elem.fixed), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirRatio) {8} then
    ComposeRatio(this, 'ElementDefinition', 'fixedRatio', TFhirRatio(elem.fixed), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirRange) {8} then
    ComposeRange(this, 'ElementDefinition', 'fixedRange', TFhirRange(elem.fixed), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirAnnotation) {8} then
    ComposeAnnotation(this, 'ElementDefinition', 'fixedAnnotation', TFhirAnnotation(elem.fixed), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'fixedCodeableConcept', TFhirCodeableConcept(elem.fixed), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirHumanName) {9} then
    ComposeHumanName(this, 'ElementDefinition', 'fixedHumanName', TFhirHumanName(elem.fixed), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirMeta) {9} then
    ComposeMeta(this, 'ElementDefinition', 'fixedMeta', TFhirMeta(elem.fixed), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirContactPoint) {9} then
    ComposeContactPoint(this, 'ElementDefinition', 'fixedContactPoint', TFhirContactPoint(elem.fixed), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirAddress) {9} then
    ComposeAddress(this, 'ElementDefinition', 'fixedAddress', TFhirAddress(elem.fixed), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirElementDefinition) {9} then
    ComposeElementDefinition(this, 'ElementDefinition', 'fixedElementDefinition', TFhirElementDefinition(elem.fixed), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirTiming) {9} then
    ComposeTiming(this, 'ElementDefinition', 'fixedTiming', TFhirTiming(elem.fixed), true, -1);{x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCode) {1} then
    ComposeCode(this, 'ElementDefinition', 'patternCode', TFhirCode(elem.pattern), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirOid) {1} then
    ComposeOid(this, 'ElementDefinition', 'patternOid', TFhirOid(elem.pattern), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUuid) {1} then
    ComposeUuid(this, 'ElementDefinition', 'patternUuid', TFhirUuid(elem.pattern), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMarkdown) {1} then
    ComposeMarkdown(this, 'ElementDefinition', 'patternMarkdown', TFhirMarkdown(elem.pattern), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'patternUnsignedInt', TFhirUnsignedInt(elem.pattern), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirId) {1} then
    ComposeId(this, 'ElementDefinition', 'patternId', TFhirId(elem.pattern), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirPositiveInt) {1} then
    ComposePositiveInt(this, 'ElementDefinition', 'patternPositiveInt', TFhirPositiveInt(elem.pattern), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDateTime) {1} then
    ComposeDateTime(this, 'ElementDefinition', 'patternDateTime', TFhirDateTime(elem.pattern), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDate) {1} then
    ComposeDate(this, 'ElementDefinition', 'patternDate', TFhirDate(elem.pattern), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirString) {1} then
    ComposeString(this, 'ElementDefinition', 'patternString', TFhirString(elem.pattern), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInteger) {1} then
    ComposeInteger(this, 'ElementDefinition', 'patternInteger', TFhirInteger(elem.pattern), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUri) {1} then
    ComposeUri(this, 'ElementDefinition', 'patternUri', TFhirUri(elem.pattern), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInstant) {1} then
    ComposeInstant(this, 'ElementDefinition', 'patternInstant', TFhirInstant(elem.pattern), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBoolean) {1} then
    ComposeBoolean(this, 'ElementDefinition', 'patternBoolean', TFhirBoolean(elem.pattern), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBase64Binary) {1} then
    ComposeBase64Binary(this, 'ElementDefinition', 'patternBase64Binary', TFhirBase64Binary(elem.pattern), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTime) {1} then
    ComposeTime(this, 'ElementDefinition', 'patternTime', TFhirTime(elem.pattern), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDecimal) {1} then
    ComposeDecimal(this, 'ElementDefinition', 'patternDecimal', TFhirDecimal(elem.pattern), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirIdentifier) {8} then
    ComposeIdentifier(this, 'ElementDefinition', 'patternIdentifier', TFhirIdentifier(elem.pattern), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirCoding) {8} then
    ComposeCoding(this, 'ElementDefinition', 'patternCoding', TFhirCoding(elem.pattern), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirReference) {8} then
    ComposeReference(this, 'ElementDefinition', 'patternReference', TFhirReference(elem.pattern), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirSignature) {8} then
    ComposeSignature(this, 'ElementDefinition', 'patternSignature', TFhirSignature(elem.pattern), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirSampledData) {8} then
    ComposeSampledData(this, 'ElementDefinition', 'patternSampledData', TFhirSampledData(elem.pattern), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirPeriod) {8} then
    ComposePeriod(this, 'ElementDefinition', 'patternPeriod', TFhirPeriod(elem.pattern), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirQuantity) {8} then
    ComposeQuantity(this, 'ElementDefinition', 'patternQuantity', TFhirQuantity(elem.pattern), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirAttachment) {8} then
    ComposeAttachment(this, 'ElementDefinition', 'patternAttachment', TFhirAttachment(elem.pattern), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirRatio) {8} then
    ComposeRatio(this, 'ElementDefinition', 'patternRatio', TFhirRatio(elem.pattern), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirRange) {8} then
    ComposeRange(this, 'ElementDefinition', 'patternRange', TFhirRange(elem.pattern), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirAnnotation) {8} then
    ComposeAnnotation(this, 'ElementDefinition', 'patternAnnotation', TFhirAnnotation(elem.pattern), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'patternCodeableConcept', TFhirCodeableConcept(elem.pattern), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirHumanName) {9} then
    ComposeHumanName(this, 'ElementDefinition', 'patternHumanName', TFhirHumanName(elem.pattern), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirMeta) {9} then
    ComposeMeta(this, 'ElementDefinition', 'patternMeta', TFhirMeta(elem.pattern), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirContactPoint) {9} then
    ComposeContactPoint(this, 'ElementDefinition', 'patternContactPoint', TFhirContactPoint(elem.pattern), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirAddress) {9} then
    ComposeAddress(this, 'ElementDefinition', 'patternAddress', TFhirAddress(elem.pattern), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirElementDefinition) {9} then
    ComposeElementDefinition(this, 'ElementDefinition', 'patternElementDefinition', TFhirElementDefinition(elem.pattern), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirTiming) {9} then
    ComposeTiming(this, 'ElementDefinition', 'patternTiming', TFhirTiming(elem.pattern), true, -1);{x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirCode) {1} then
    ComposeCode(this, 'ElementDefinition', 'exampleCode', TFhirCode(elem.example), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirOid) {1} then
    ComposeOid(this, 'ElementDefinition', 'exampleOid', TFhirOid(elem.example), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUuid) {1} then
    ComposeUuid(this, 'ElementDefinition', 'exampleUuid', TFhirUuid(elem.example), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirMarkdown) {1} then
    ComposeMarkdown(this, 'ElementDefinition', 'exampleMarkdown', TFhirMarkdown(elem.example), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'exampleUnsignedInt', TFhirUnsignedInt(elem.example), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirId) {1} then
    ComposeId(this, 'ElementDefinition', 'exampleId', TFhirId(elem.example), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirPositiveInt) {1} then
    ComposePositiveInt(this, 'ElementDefinition', 'examplePositiveInt', TFhirPositiveInt(elem.example), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDateTime) {1} then
    ComposeDateTime(this, 'ElementDefinition', 'exampleDateTime', TFhirDateTime(elem.example), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDate) {1} then
    ComposeDate(this, 'ElementDefinition', 'exampleDate', TFhirDate(elem.example), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirString) {1} then
    ComposeString(this, 'ElementDefinition', 'exampleString', TFhirString(elem.example), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirInteger) {1} then
    ComposeInteger(this, 'ElementDefinition', 'exampleInteger', TFhirInteger(elem.example), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUri) {1} then
    ComposeUri(this, 'ElementDefinition', 'exampleUri', TFhirUri(elem.example), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirInstant) {1} then
    ComposeInstant(this, 'ElementDefinition', 'exampleInstant', TFhirInstant(elem.example), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirBoolean) {1} then
    ComposeBoolean(this, 'ElementDefinition', 'exampleBoolean', TFhirBoolean(elem.example), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirBase64Binary) {1} then
    ComposeBase64Binary(this, 'ElementDefinition', 'exampleBase64Binary', TFhirBase64Binary(elem.example), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirTime) {1} then
    ComposeTime(this, 'ElementDefinition', 'exampleTime', TFhirTime(elem.example), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDecimal) {1} then
    ComposeDecimal(this, 'ElementDefinition', 'exampleDecimal', TFhirDecimal(elem.example), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirIdentifier) {8} then
    ComposeIdentifier(this, 'ElementDefinition', 'exampleIdentifier', TFhirIdentifier(elem.example), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirCoding) {8} then
    ComposeCoding(this, 'ElementDefinition', 'exampleCoding', TFhirCoding(elem.example), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirReference) {8} then
    ComposeReference(this, 'ElementDefinition', 'exampleReference', TFhirReference(elem.example), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirSignature) {8} then
    ComposeSignature(this, 'ElementDefinition', 'exampleSignature', TFhirSignature(elem.example), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirSampledData) {8} then
    ComposeSampledData(this, 'ElementDefinition', 'exampleSampledData', TFhirSampledData(elem.example), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirPeriod) {8} then
    ComposePeriod(this, 'ElementDefinition', 'examplePeriod', TFhirPeriod(elem.example), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirQuantity) {8} then
    ComposeQuantity(this, 'ElementDefinition', 'exampleQuantity', TFhirQuantity(elem.example), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirAttachment) {8} then
    ComposeAttachment(this, 'ElementDefinition', 'exampleAttachment', TFhirAttachment(elem.example), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirRatio) {8} then
    ComposeRatio(this, 'ElementDefinition', 'exampleRatio', TFhirRatio(elem.example), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirRange) {8} then
    ComposeRange(this, 'ElementDefinition', 'exampleRange', TFhirRange(elem.example), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirAnnotation) {8} then
    ComposeAnnotation(this, 'ElementDefinition', 'exampleAnnotation', TFhirAnnotation(elem.example), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'exampleCodeableConcept', TFhirCodeableConcept(elem.example), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirHumanName) {9} then
    ComposeHumanName(this, 'ElementDefinition', 'exampleHumanName', TFhirHumanName(elem.example), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirMeta) {9} then
    ComposeMeta(this, 'ElementDefinition', 'exampleMeta', TFhirMeta(elem.example), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirContactPoint) {9} then
    ComposeContactPoint(this, 'ElementDefinition', 'exampleContactPoint', TFhirContactPoint(elem.example), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirAddress) {9} then
    ComposeAddress(this, 'ElementDefinition', 'exampleAddress', TFhirAddress(elem.example), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirElementDefinition) {9} then
    ComposeElementDefinition(this, 'ElementDefinition', 'exampleElementDefinition', TFhirElementDefinition(elem.example), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirTiming) {9} then
    ComposeTiming(this, 'ElementDefinition', 'exampleTiming', TFhirTiming(elem.example), true, -1);{x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirCode) {1} then
    ComposeCode(this, 'ElementDefinition', 'minValueCode', TFhirCode(elem.minValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirOid) {1} then
    ComposeOid(this, 'ElementDefinition', 'minValueOid', TFhirOid(elem.minValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUuid) {1} then
    ComposeUuid(this, 'ElementDefinition', 'minValueUuid', TFhirUuid(elem.minValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirMarkdown) {1} then
    ComposeMarkdown(this, 'ElementDefinition', 'minValueMarkdown', TFhirMarkdown(elem.minValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'minValueUnsignedInt', TFhirUnsignedInt(elem.minValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirId) {1} then
    ComposeId(this, 'ElementDefinition', 'minValueId', TFhirId(elem.minValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirPositiveInt) {1} then
    ComposePositiveInt(this, 'ElementDefinition', 'minValuePositiveInt', TFhirPositiveInt(elem.minValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDateTime) {1} then
    ComposeDateTime(this, 'ElementDefinition', 'minValueDateTime', TFhirDateTime(elem.minValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDate) {1} then
    ComposeDate(this, 'ElementDefinition', 'minValueDate', TFhirDate(elem.minValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirString) {1} then
    ComposeString(this, 'ElementDefinition', 'minValueString', TFhirString(elem.minValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInteger) {1} then
    ComposeInteger(this, 'ElementDefinition', 'minValueInteger', TFhirInteger(elem.minValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUri) {1} then
    ComposeUri(this, 'ElementDefinition', 'minValueUri', TFhirUri(elem.minValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInstant) {1} then
    ComposeInstant(this, 'ElementDefinition', 'minValueInstant', TFhirInstant(elem.minValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirBoolean) {1} then
    ComposeBoolean(this, 'ElementDefinition', 'minValueBoolean', TFhirBoolean(elem.minValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirBase64Binary) {1} then
    ComposeBase64Binary(this, 'ElementDefinition', 'minValueBase64Binary', TFhirBase64Binary(elem.minValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirTime) {1} then
    ComposeTime(this, 'ElementDefinition', 'minValueTime', TFhirTime(elem.minValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDecimal) {1} then
    ComposeDecimal(this, 'ElementDefinition', 'minValueDecimal', TFhirDecimal(elem.minValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirIdentifier) {8} then
    ComposeIdentifier(this, 'ElementDefinition', 'minValueIdentifier', TFhirIdentifier(elem.minValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirCoding) {8} then
    ComposeCoding(this, 'ElementDefinition', 'minValueCoding', TFhirCoding(elem.minValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirReference) {8} then
    ComposeReference(this, 'ElementDefinition', 'minValueReference', TFhirReference(elem.minValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirSignature) {8} then
    ComposeSignature(this, 'ElementDefinition', 'minValueSignature', TFhirSignature(elem.minValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirSampledData) {8} then
    ComposeSampledData(this, 'ElementDefinition', 'minValueSampledData', TFhirSampledData(elem.minValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirPeriod) {8} then
    ComposePeriod(this, 'ElementDefinition', 'minValuePeriod', TFhirPeriod(elem.minValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirQuantity) {8} then
    ComposeQuantity(this, 'ElementDefinition', 'minValueQuantity', TFhirQuantity(elem.minValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirAttachment) {8} then
    ComposeAttachment(this, 'ElementDefinition', 'minValueAttachment', TFhirAttachment(elem.minValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirRatio) {8} then
    ComposeRatio(this, 'ElementDefinition', 'minValueRatio', TFhirRatio(elem.minValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirRange) {8} then
    ComposeRange(this, 'ElementDefinition', 'minValueRange', TFhirRange(elem.minValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirAnnotation) {8} then
    ComposeAnnotation(this, 'ElementDefinition', 'minValueAnnotation', TFhirAnnotation(elem.minValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'minValueCodeableConcept', TFhirCodeableConcept(elem.minValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirHumanName) {9} then
    ComposeHumanName(this, 'ElementDefinition', 'minValueHumanName', TFhirHumanName(elem.minValue), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirMeta) {9} then
    ComposeMeta(this, 'ElementDefinition', 'minValueMeta', TFhirMeta(elem.minValue), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirContactPoint) {9} then
    ComposeContactPoint(this, 'ElementDefinition', 'minValueContactPoint', TFhirContactPoint(elem.minValue), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirAddress) {9} then
    ComposeAddress(this, 'ElementDefinition', 'minValueAddress', TFhirAddress(elem.minValue), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirElementDefinition) {9} then
    ComposeElementDefinition(this, 'ElementDefinition', 'minValueElementDefinition', TFhirElementDefinition(elem.minValue), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirTiming) {9} then
    ComposeTiming(this, 'ElementDefinition', 'minValueTiming', TFhirTiming(elem.minValue), true, -1);{x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirCode) {1} then
    ComposeCode(this, 'ElementDefinition', 'maxValueCode', TFhirCode(elem.maxValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirOid) {1} then
    ComposeOid(this, 'ElementDefinition', 'maxValueOid', TFhirOid(elem.maxValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUuid) {1} then
    ComposeUuid(this, 'ElementDefinition', 'maxValueUuid', TFhirUuid(elem.maxValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirMarkdown) {1} then
    ComposeMarkdown(this, 'ElementDefinition', 'maxValueMarkdown', TFhirMarkdown(elem.maxValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'maxValueUnsignedInt', TFhirUnsignedInt(elem.maxValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirId) {1} then
    ComposeId(this, 'ElementDefinition', 'maxValueId', TFhirId(elem.maxValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirPositiveInt) {1} then
    ComposePositiveInt(this, 'ElementDefinition', 'maxValuePositiveInt', TFhirPositiveInt(elem.maxValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDateTime) {1} then
    ComposeDateTime(this, 'ElementDefinition', 'maxValueDateTime', TFhirDateTime(elem.maxValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDate) {1} then
    ComposeDate(this, 'ElementDefinition', 'maxValueDate', TFhirDate(elem.maxValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirString) {1} then
    ComposeString(this, 'ElementDefinition', 'maxValueString', TFhirString(elem.maxValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInteger) {1} then
    ComposeInteger(this, 'ElementDefinition', 'maxValueInteger', TFhirInteger(elem.maxValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUri) {1} then
    ComposeUri(this, 'ElementDefinition', 'maxValueUri', TFhirUri(elem.maxValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInstant) {1} then
    ComposeInstant(this, 'ElementDefinition', 'maxValueInstant', TFhirInstant(elem.maxValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirBoolean) {1} then
    ComposeBoolean(this, 'ElementDefinition', 'maxValueBoolean', TFhirBoolean(elem.maxValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirBase64Binary) {1} then
    ComposeBase64Binary(this, 'ElementDefinition', 'maxValueBase64Binary', TFhirBase64Binary(elem.maxValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirTime) {1} then
    ComposeTime(this, 'ElementDefinition', 'maxValueTime', TFhirTime(elem.maxValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDecimal) {1} then
    ComposeDecimal(this, 'ElementDefinition', 'maxValueDecimal', TFhirDecimal(elem.maxValue), false, -1){x.d7}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirIdentifier) {8} then
    ComposeIdentifier(this, 'ElementDefinition', 'maxValueIdentifier', TFhirIdentifier(elem.maxValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirCoding) {8} then
    ComposeCoding(this, 'ElementDefinition', 'maxValueCoding', TFhirCoding(elem.maxValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirReference) {8} then
    ComposeReference(this, 'ElementDefinition', 'maxValueReference', TFhirReference(elem.maxValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirSignature) {8} then
    ComposeSignature(this, 'ElementDefinition', 'maxValueSignature', TFhirSignature(elem.maxValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirSampledData) {8} then
    ComposeSampledData(this, 'ElementDefinition', 'maxValueSampledData', TFhirSampledData(elem.maxValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirPeriod) {8} then
    ComposePeriod(this, 'ElementDefinition', 'maxValuePeriod', TFhirPeriod(elem.maxValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirQuantity) {8} then
    ComposeQuantity(this, 'ElementDefinition', 'maxValueQuantity', TFhirQuantity(elem.maxValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirAttachment) {8} then
    ComposeAttachment(this, 'ElementDefinition', 'maxValueAttachment', TFhirAttachment(elem.maxValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirRatio) {8} then
    ComposeRatio(this, 'ElementDefinition', 'maxValueRatio', TFhirRatio(elem.maxValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirRange) {8} then
    ComposeRange(this, 'ElementDefinition', 'maxValueRange', TFhirRange(elem.maxValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirAnnotation) {8} then
    ComposeAnnotation(this, 'ElementDefinition', 'maxValueAnnotation', TFhirAnnotation(elem.maxValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'maxValueCodeableConcept', TFhirCodeableConcept(elem.maxValue), false, -1){x.d5}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirHumanName) {9} then
    ComposeHumanName(this, 'ElementDefinition', 'maxValueHumanName', TFhirHumanName(elem.maxValue), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirMeta) {9} then
    ComposeMeta(this, 'ElementDefinition', 'maxValueMeta', TFhirMeta(elem.maxValue), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirContactPoint) {9} then
    ComposeContactPoint(this, 'ElementDefinition', 'maxValueContactPoint', TFhirContactPoint(elem.maxValue), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirAddress) {9} then
    ComposeAddress(this, 'ElementDefinition', 'maxValueAddress', TFhirAddress(elem.maxValue), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirElementDefinition) {9} then
    ComposeElementDefinition(this, 'ElementDefinition', 'maxValueElementDefinition', TFhirElementDefinition(elem.maxValue), true, -1){x.d6}
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirTiming) {9} then
    ComposeTiming(this, 'ElementDefinition', 'maxValueTiming', TFhirTiming(elem.maxValue), true, -1);{x.d6}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInteger(this, 'ElementDefinition', 'maxLength', elem.maxLengthElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeId(this, 'ElementDefinition', 'condition', elem.conditionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.constraintList.Count - 1 do
      ComposeElementDefinitionConstraint(this, 'ElementDefinition', 'constraint', elem.constraintList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.mustSupport <> false)) then
    ComposeBoolean(this, 'ElementDefinition', 'mustSupport', elem.mustSupportElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.isModifier <> false)) then
    ComposeBoolean(this, 'ElementDefinition', 'isModifier', elem.isModifierElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.isSummary <> false)) then
    ComposeBoolean(this, 'ElementDefinition', 'isSummary', elem.isSummaryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBinding(this, 'ElementDefinition', 'binding', elem.bindingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeElementDefinitionMapping(this, 'ElementDefinition', 'mapping', elem.mappingList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTimingRepeat(obj : TTurtleComplex) : TFhirTimingRepeat;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTimingRepeat.create;
  try
    ParseTimingRepeatProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTimingRepeatProperties(obj : TTurtleComplex; result : TFhirTimingRepeat);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Timing.repeat.boundsQuantity', item) then
      result.bounds := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Timing.repeat.boundsRange', item) then
      result.bounds := parseRange(item);
    if obj.has('http://hl7.org/fhir/Timing.repeat.boundsPeriod', item) then
      result.bounds := parsePeriod(item);
    result.countElement := ParseInteger(obj.complex('http://hl7.org/fhir/Timing.repeat.count'));{q1}
    result.durationElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Timing.repeat.duration'));{q1}
    result.durationMaxElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Timing.repeat.durationMax'));{q1}
    result.durationUnitsElement := ParseEnum(obj.complex('http://hl7.org/fhir/Timing.repeat.durationUnits'), CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum);
    result.frequencyElement := ParseInteger(obj.complex('http://hl7.org/fhir/Timing.repeat.frequency'));{q1}
    result.frequencyMaxElement := ParseInteger(obj.complex('http://hl7.org/fhir/Timing.repeat.frequencyMax'));{q1}
    result.periodElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Timing.repeat.period'));{q1}
    result.periodMaxElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Timing.repeat.periodMax'));{q1}
    result.periodUnitsElement := ParseEnum(obj.complex('http://hl7.org/fhir/Timing.repeat.periodUnits'), CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum);
    result.whenElement := ParseEnum(obj.complex('http://hl7.org/fhir/Timing.repeat.when'), CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum);
end;

procedure TFHIRTurtleComposer.ComposeTimingRepeat(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTimingRepeat; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TimingRepeat'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Timing.repeat', 'boundsQuantity', TFhirQuantity(elem.bounds), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirRange) {6} then
    ComposeRange(this, 'Timing.repeat', 'boundsRange', TFhirRange(elem.bounds), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirPeriod) {6} then
    ComposePeriod(this, 'Timing.repeat', 'boundsPeriod', TFhirPeriod(elem.bounds), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'Timing.repeat', 'count', elem.countElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Timing.repeat', 'duration', elem.durationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Timing.repeat', 'durationMax', elem.durationMaxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Timing.repeat', 'durationUnits', elem.DurationUnitsElement, CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.frequency <> '1')) then
    ComposeInteger(this, 'Timing.repeat', 'frequency', elem.frequencyElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'Timing.repeat', 'frequencyMax', elem.frequencyMaxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Timing.repeat', 'period', elem.periodElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Timing.repeat', 'periodMax', elem.periodMaxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Timing.repeat', 'periodUnits', elem.PeriodUnitsElement, CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Timing.repeat', 'when', elem.WhenElement, CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseTiming(obj : TTurtleComplex) : TFhirTiming;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTiming.create;
  try
    ParseTimingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTimingProperties(obj : TTurtleComplex; result : TFhirTiming);
var
  item : TTurtleComplex;
begin
    ParseStructureProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Timing.event') do
      result.eventList.Add(parseDateTime(item));
    result.repeat_ := ParseTimingRepeat(obj.complex('http://hl7.org/fhir/Timing.repeat'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Timing.code'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTiming(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTiming; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Timing'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDateTime(this, 'Timing', 'event', elem.eventList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeTimingRepeat(this, 'Timing', 'repeat', elem.repeat_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'Timing', 'code', elem.codeElement, false, -1);{x.2f}
end;

{$IFDEF FHIR_ACCOUNT}
function TFHIRTurtleParser.ParseAccount(obj : TTurtleComplex) : TFhirAccount;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAccount.create;
  try
    ParseAccountProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAccountProperties(obj : TTurtleComplex; result : TFhirAccount);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Account.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Account.name'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Account.type'));{q3b}
    result.statusElement := ParseCode(obj.complex('http://hl7.org/fhir/Account.status'));{q1}
    result.activePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Account.activePeriod'));{q3b}
    result.currency := ParseCoding(obj.complex('http://hl7.org/fhir/Account.currency'));{q3b}
    result.balance := ParseQuantity(obj.complex('http://hl7.org/fhir/Account.balance'));{q3b}
    result.coveragePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Account.coveragePeriod'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Account.subject'));{q3b}
    result.owner := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Account.owner'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Account.description'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeAccount(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAccount; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Account'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Account', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Account', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Account', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeCode(this, 'Account', 'status', elem.statusElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('activePeriod') then
    ComposePeriod(this, 'Account', 'activePeriod', elem.activePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('currency') then
    ComposeCoding(this, 'Account', 'currency', elem.currencyElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('balance') then
    ComposeQuantity(this, 'Account', 'balance', elem.balanceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('coveragePeriod') then
    ComposePeriod(this, 'Account', 'coveragePeriod', elem.coveragePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'Account', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('owner') then
    ComposeReference{TFhirOrganization}(this, 'Account', 'owner', elem.ownerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'Account', 'description', elem.descriptionElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
function TFHIRTurtleParser.ParseAllergyIntoleranceReaction(obj : TTurtleComplex) : TFhirAllergyIntoleranceReaction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAllergyIntoleranceReaction.create;
  try
    ParseAllergyIntoleranceReactionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAllergyIntoleranceReactionProperties(obj : TTurtleComplex; result : TFhirAllergyIntoleranceReaction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.substance := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.substance'));{q3b}
    result.certaintyElement := ParseEnum(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.certainty'), CODES_TFhirReactionEventCertaintyEnum, SYSTEMS_TFhirReactionEventCertaintyEnum);
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.reaction.manifestation') do
      result.manifestationList.Add(parseCodeableConcept(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.description'));{q1}
    result.onsetElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.onset'));{q1}
    result.severityElement := ParseEnum(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.severity'), CODES_TFhirReactionEventSeverityEnum, SYSTEMS_TFhirReactionEventSeverityEnum);
    result.exposureRoute := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.exposureRoute'));{q3b}
    result.note := ParseAnnotation(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.note'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeAllergyIntoleranceReaction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAllergyIntoleranceReaction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AllergyIntoleranceReaction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AllergyIntolerance.reaction', 'substance', elem.substanceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'AllergyIntolerance.reaction', 'certainty', elem.CertaintyElement, CODES_TFhirReactionEventCertaintyEnum, SYSTEMS_TFhirReactionEventCertaintyEnum, false, -1);{x.d4}
  for i := 0 to elem.manifestationList.Count - 1 do
      ComposeCodeableConcept(this, 'AllergyIntolerance.reaction', 'manifestation', elem.manifestationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AllergyIntolerance.reaction', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'AllergyIntolerance.reaction', 'onset', elem.onsetElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'AllergyIntolerance.reaction', 'severity', elem.SeverityElement, CODES_TFhirReactionEventSeverityEnum, SYSTEMS_TFhirReactionEventSeverityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AllergyIntolerance.reaction', 'exposureRoute', elem.exposureRouteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(this, 'AllergyIntolerance.reaction', 'note', elem.noteElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseAllergyIntolerance(obj : TTurtleComplex) : TFhirAllergyIntolerance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAllergyIntolerance.create;
  try
    ParseAllergyIntoleranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAllergyIntoleranceProperties(obj : TTurtleComplex; result : TFhirAllergyIntolerance);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.onsetElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AllergyIntolerance.onset'));{q1}
    result.recordedDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AllergyIntolerance.recordedDate'));{q1}
    result.recorder := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/AllergyIntolerance.recorder'));{q3b}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/AllergyIntolerance.patient'));{q3b}
    result.reporter := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reporter'));{q3b}
    result.substance := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AllergyIntolerance.substance'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/AllergyIntolerance.status'), CODES_TFhirAllergyIntoleranceStatusEnum, SYSTEMS_TFhirAllergyIntoleranceStatusEnum);
    result.criticalityElement := ParseEnum(obj.complex('http://hl7.org/fhir/AllergyIntolerance.criticality'), CODES_TFhirAllergyIntoleranceCriticalityEnum, SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/AllergyIntolerance.type'), CODES_TFhirAllergyIntoleranceTypeEnum, SYSTEMS_TFhirAllergyIntoleranceTypeEnum);
    result.categoryElement := ParseEnum(obj.complex('http://hl7.org/fhir/AllergyIntolerance.category'), CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum);
    result.lastOccurenceElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AllergyIntolerance.lastOccurence'));{q1}
    result.note := ParseAnnotation(obj.complex('http://hl7.org/fhir/AllergyIntolerance.note'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.reaction') do
      result.reactionList.Add(parseAllergyIntoleranceReaction(item));
end;

procedure TFHIRTurtleComposer.ComposeAllergyIntolerance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAllergyIntolerance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AllergyIntolerance'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'AllergyIntolerance', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('onset') then
    ComposeDateTime(this, 'AllergyIntolerance', 'onset', elem.onsetElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedDate') then
    ComposeDateTime(this, 'AllergyIntolerance', 'recordedDate', elem.recordedDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recorder') then
    ComposeReference{Resource}(this, 'AllergyIntolerance', 'recorder', elem.recorderElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'AllergyIntolerance', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reporter') then
    ComposeReference{Resource}(this, 'AllergyIntolerance', 'reporter', elem.reporterElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'AllergyIntolerance', 'substance', elem.substanceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'AllergyIntolerance', 'status', elem.StatusElement, CODES_TFhirAllergyIntoleranceStatusEnum, SYSTEMS_TFhirAllergyIntoleranceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('criticality') then
    ComposeEnum(this, 'AllergyIntolerance', 'criticality', elem.CriticalityElement, CODES_TFhirAllergyIntoleranceCriticalityEnum, SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeEnum(this, 'AllergyIntolerance', 'type', elem.Type_Element, CODES_TFhirAllergyIntoleranceTypeEnum, SYSTEMS_TFhirAllergyIntoleranceTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeEnum(this, 'AllergyIntolerance', 'category', elem.CategoryElement, CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lastOccurence') then
    ComposeDateTime(this, 'AllergyIntolerance', 'lastOccurence', elem.lastOccurenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    ComposeAnnotation(this, 'AllergyIntolerance', 'note', elem.noteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('reaction') then
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeAllergyIntoleranceReaction(this, 'AllergyIntolerance', 'reaction', elem.reactionList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
function TFHIRTurtleParser.ParseAppointmentParticipant(obj : TTurtleComplex) : TFhirAppointmentParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAppointmentParticipant.create;
  try
    ParseAppointmentParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAppointmentParticipantProperties(obj : TTurtleComplex; result : TFhirAppointmentParticipant);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Appointment.participant.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.actor := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Appointment.participant.actor'));{q3b}
    result.requiredElement := ParseEnum(obj.complex('http://hl7.org/fhir/Appointment.participant.required'), CODES_TFhirParticipantrequiredEnum, SYSTEMS_TFhirParticipantrequiredEnum);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Appointment.participant.status'), CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum);
end;

procedure TFHIRTurtleComposer.ComposeAppointmentParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointmentParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AppointmentParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Appointment.participant', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Appointment.participant', 'actor', elem.actorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Appointment.participant', 'required', elem.RequiredElement, CODES_TFhirParticipantrequiredEnum, SYSTEMS_TFhirParticipantrequiredEnum, false, -1);{x.d4}
  ComposeEnum(this, 'Appointment.participant', 'status', elem.StatusElement, CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseAppointment(obj : TTurtleComplex) : TFhirAppointment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAppointment.create;
  try
    ParseAppointmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAppointmentProperties(obj : TTurtleComplex; result : TFhirAppointment);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Appointment.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Appointment.status'), CODES_TFhirAppointmentstatusEnum, SYSTEMS_TFhirAppointmentstatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Appointment.type'));{q3b}
    result.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Appointment.reason'));{q3b}
    result.priorityElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Appointment.priority'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Appointment.description'));{q1}
    result.startElement := ParseInstant(obj.complex('http://hl7.org/fhir/Appointment.start'));{q1}
    result.end_Element := ParseInstant(obj.complex('http://hl7.org/fhir/Appointment.end'));{q1}
    result.minutesDurationElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Appointment.minutesDuration'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Appointment.slot') do
      result.slotList.Add(parseReference{TFhirSlot}(item));
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/Appointment.comment'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Appointment.participant') do
      result.participantList.Add(parseAppointmentParticipant(item));
end;

procedure TFHIRTurtleComposer.ComposeAppointment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Appointment'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Appointment', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Appointment', 'status', elem.StatusElement, CODES_TFhirAppointmentstatusEnum, SYSTEMS_TFhirAppointmentstatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Appointment', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    ComposeCodeableConcept(this, 'Appointment', 'reason', elem.reasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeUnsignedInt(this, 'Appointment', 'priority', elem.priorityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeString(this, 'Appointment', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('start') then
    ComposeInstant(this, 'Appointment', 'start', elem.startElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstant(this, 'Appointment', 'end', elem.end_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('minutesDuration') then
    ComposePositiveInt(this, 'Appointment', 'minutesDuration', elem.minutesDurationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('slot') then
    for i := 0 to elem.slotList.Count - 1 do
      ComposeReference{TFhirSlot}(this, 'Appointment', 'slot', elem.slotList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(this, 'Appointment', 'comment', elem.commentElement, false, -1);{x.2ea}
  for i := 0 to elem.participantList.Count - 1 do
      ComposeAppointmentParticipant(this, 'Appointment', 'participant', elem.participantList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
function TFHIRTurtleParser.ParseAppointmentResponse(obj : TTurtleComplex) : TFhirAppointmentResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAppointmentResponse.create;
  try
    ParseAppointmentResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAppointmentResponseProperties(obj : TTurtleComplex; result : TFhirAppointmentResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/AppointmentResponse.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.appointment := ParseReference{TFhirAppointment}(obj.complex('http://hl7.org/fhir/AppointmentResponse.appointment'));{q3b}
    result.startElement := ParseInstant(obj.complex('http://hl7.org/fhir/AppointmentResponse.start'));{q1}
    result.end_Element := ParseInstant(obj.complex('http://hl7.org/fhir/AppointmentResponse.end'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/AppointmentResponse.participantType') do
      result.participantTypeList.Add(parseCodeableConcept(item));
    result.actor := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/AppointmentResponse.actor'));{q3b}
    result.participantStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/AppointmentResponse.participantStatus'), CODES_TFhirParticipantstatusEnum, SYSTEMS_TFhirParticipantstatusEnum);
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/AppointmentResponse.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeAppointmentResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointmentResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AppointmentResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'AppointmentResponse', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeReference{TFhirAppointment}(this, 'AppointmentResponse', 'appointment', elem.appointmentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('start') then
    ComposeInstant(this, 'AppointmentResponse', 'start', elem.startElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('end_') then
    ComposeInstant(this, 'AppointmentResponse', 'end', elem.end_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('participantType') then
    for i := 0 to elem.participantTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'AppointmentResponse', 'participantType', elem.participantTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('actor') then
    ComposeReference{Resource}(this, 'AppointmentResponse', 'actor', elem.actorElement, false, -1);{x.2f}
  ComposeEnum(this, 'AppointmentResponse', 'participantStatus', elem.ParticipantStatusElement, CODES_TFhirParticipantstatusEnum, SYSTEMS_TFhirParticipantstatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(this, 'AppointmentResponse', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
function TFHIRTurtleParser.ParseAuditEventEvent(obj : TTurtleComplex) : TFhirAuditEventEvent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventEvent.create;
  try
    ParseAuditEventEventProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventEventProperties(obj : TTurtleComplex; result : TFhirAuditEventEvent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/AuditEvent.event.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.event.subtype') do
      result.subtypeList.Add(parseCoding(item));
    result.actionElement := ParseEnum(obj.complex('http://hl7.org/fhir/AuditEvent.event.action'), CODES_TFhirAuditEventActionEnum, SYSTEMS_TFhirAuditEventActionEnum);
    result.dateTimeElement := ParseInstant(obj.complex('http://hl7.org/fhir/AuditEvent.event.dateTime'));{q1}
    result.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/AuditEvent.event.outcome'), CODES_TFhirAuditEventOutcomeEnum, SYSTEMS_TFhirAuditEventOutcomeEnum);
    result.outcomeDescElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.event.outcomeDesc'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.event.purposeOfEvent') do
      result.purposeOfEventList.Add(parseCoding(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEventEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventEvent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventEvent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'AuditEvent.event', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.subtypeList.Count - 1 do
      ComposeCoding(this, 'AuditEvent.event', 'subtype', elem.subtypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'AuditEvent.event', 'action', elem.ActionElement, CODES_TFhirAuditEventActionEnum, SYSTEMS_TFhirAuditEventActionEnum, false, -1);{x.d4}
  ComposeInstant(this, 'AuditEvent.event', 'dateTime', elem.dateTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'AuditEvent.event', 'outcome', elem.OutcomeElement, CODES_TFhirAuditEventOutcomeEnum, SYSTEMS_TFhirAuditEventOutcomeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'AuditEvent.event', 'outcomeDesc', elem.outcomeDescElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.purposeOfEventList.Count - 1 do
      ComposeCoding(this, 'AuditEvent.event', 'purposeOfEvent', elem.purposeOfEventList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseAuditEventParticipant(obj : TTurtleComplex) : TFhirAuditEventParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventParticipant.create;
  try
    ParseAuditEventParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventParticipantProperties(obj : TTurtleComplex; result : TFhirAuditEventParticipant);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.participant.role') do
      result.roleList.Add(parseCodeableConcept(item));
    result.reference := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/AuditEvent.participant.reference'));{q3b}
    result.userId := ParseIdentifier(obj.complex('http://hl7.org/fhir/AuditEvent.participant.userId'));{q3b}
    result.altIdElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.participant.altId'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.participant.name'));{q1}
    result.requestorElement := ParseBoolean(obj.complex('http://hl7.org/fhir/AuditEvent.participant.requestor'));{q1}
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/AuditEvent.participant.location'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.participant.policy') do
      result.policyList.Add(parseUri(item));
    result.media := ParseCoding(obj.complex('http://hl7.org/fhir/AuditEvent.participant.media'));{q3b}
    result.network := ParseAuditEventParticipantNetwork(obj.complex('http://hl7.org/fhir/AuditEvent.participant.network'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.participant.purposeOfUse') do
      result.purposeOfUseList.Add(parseCoding(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEventParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'AuditEvent.participant', 'role', elem.roleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'AuditEvent.participant', 'reference', elem.referenceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'AuditEvent.participant', 'userId', elem.userIdElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEvent.participant', 'altId', elem.altIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEvent.participant', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'AuditEvent.participant', 'requestor', elem.requestorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'AuditEvent.participant', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.policyList.Count - 1 do
      ComposeUri(this, 'AuditEvent.participant', 'policy', elem.policyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'AuditEvent.participant', 'media', elem.mediaElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeAuditEventParticipantNetwork(this, 'AuditEvent.participant', 'network', elem.networkElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.purposeOfUseList.Count - 1 do
      ComposeCoding(this, 'AuditEvent.participant', 'purposeOfUse', elem.purposeOfUseList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseAuditEventParticipantNetwork(obj : TTurtleComplex) : TFhirAuditEventParticipantNetwork;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventParticipantNetwork.create;
  try
    ParseAuditEventParticipantNetworkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventParticipantNetworkProperties(obj : TTurtleComplex; result : TFhirAuditEventParticipantNetwork);
begin
    ParseBackboneElementProperties(obj, result);
    result.addressElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.participant.network.address'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/AuditEvent.participant.network.type'), CODES_TFhirNetworkTypeEnum, SYSTEMS_TFhirNetworkTypeEnum);
end;

procedure TFHIRTurtleComposer.ComposeAuditEventParticipantNetwork(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventParticipantNetwork; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventParticipantNetwork'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEvent.participant.network', 'address', elem.addressElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'AuditEvent.participant.network', 'type', elem.Type_Element, CODES_TFhirNetworkTypeEnum, SYSTEMS_TFhirNetworkTypeEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseAuditEventSource(obj : TTurtleComplex) : TFhirAuditEventSource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventSource.create;
  try
    ParseAuditEventSourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventSourceProperties(obj : TTurtleComplex; result : TFhirAuditEventSource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.siteElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.source.site'));{q1}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/AuditEvent.source.identifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.source.type') do
      result.type_List.Add(parseCoding(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEventSource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventSource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventSource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEvent.source', 'site', elem.siteElement, false, -1);{x.2ea}
  ComposeIdentifier(this, 'AuditEvent.source', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(this, 'AuditEvent.source', 'type', elem.type_List[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseAuditEventObject(obj : TTurtleComplex) : TFhirAuditEventObject;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventObject.create;
  try
    ParseAuditEventObjectProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventObjectProperties(obj : TTurtleComplex; result : TFhirAuditEventObject);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/AuditEvent.object.identifier'));{q3b}
    result.reference := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/AuditEvent.object.reference'));{q3b}
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/AuditEvent.object.type'));{q3b}
    result.role := ParseCoding(obj.complex('http://hl7.org/fhir/AuditEvent.object.role'));{q3b}
    result.lifecycle := ParseCoding(obj.complex('http://hl7.org/fhir/AuditEvent.object.lifecycle'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.object.securityLabel') do
      result.securityLabelList.Add(parseCoding(item));
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.object.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.object.description'));{q1}
    result.queryElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/AuditEvent.object.query'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.object.detail') do
      result.detailList.Add(parseAuditEventObjectDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEventObject(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventObject; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventObject'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'AuditEvent.object', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'AuditEvent.object', 'reference', elem.referenceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'AuditEvent.object', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'AuditEvent.object', 'role', elem.roleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'AuditEvent.object', 'lifecycle', elem.lifecycleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(this, 'AuditEvent.object', 'securityLabel', elem.securityLabelList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'AuditEvent.object', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEvent.object', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(this, 'AuditEvent.object', 'query', elem.queryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeAuditEventObjectDetail(this, 'AuditEvent.object', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseAuditEventObjectDetail(obj : TTurtleComplex) : TFhirAuditEventObjectDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventObjectDetail.create;
  try
    ParseAuditEventObjectDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventObjectDetailProperties(obj : TTurtleComplex; result : TFhirAuditEventObjectDetail);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.object.detail.type'));{q1}
    result.valueElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/AuditEvent.object.detail.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeAuditEventObjectDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventObjectDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventObjectDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'AuditEvent.object.detail', 'type', elem.type_Element, false, -1);{x.2ea}
  ComposeBase64Binary(this, 'AuditEvent.object.detail', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseAuditEvent(obj : TTurtleComplex) : TFhirAuditEvent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEvent.create;
  try
    ParseAuditEventProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventProperties(obj : TTurtleComplex; result : TFhirAuditEvent);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.event := ParseAuditEventEvent(obj.complex('http://hl7.org/fhir/AuditEvent.event'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.participant') do
      result.participantList.Add(parseAuditEventParticipant(item));
    result.source := ParseAuditEventSource(obj.complex('http://hl7.org/fhir/AuditEvent.source'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.object') do
      result.object_List.Add(parseAuditEventObject(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEvent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEvent'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeAuditEventEvent(this, 'AuditEvent', 'event', elem.eventElement, false, -1);{x.2f}
  for i := 0 to elem.participantList.Count - 1 do
      ComposeAuditEventParticipant(this, 'AuditEvent', 'participant', elem.participantList[i], false, i);{x.d3}
  ComposeAuditEventSource(this, 'AuditEvent', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('object_') then
    for i := 0 to elem.object_List.Count - 1 do
      ComposeAuditEventObject(this, 'AuditEvent', 'object', elem.object_List[i], false, i);{x.d3}
end;

{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
function TFHIRTurtleParser.ParseBasic(obj : TTurtleComplex) : TFhirBasic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBasic.create;
  try
    ParseBasicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBasicProperties(obj : TTurtleComplex; result : TFhirBasic);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Basic.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Basic.code'));{q3b}
    result.subject := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Basic.subject'));{q3b}
    result.author := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Basic.author'));{q3b}
    result.createdElement := ParseDate(obj.complex('http://hl7.org/fhir/Basic.created'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeBasic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBasic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Basic'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Basic', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Basic', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirReference}(this, 'Basic', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(this, 'Basic', 'author', elem.authorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDate(this, 'Basic', 'created', elem.createdElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
function TFHIRTurtleParser.ParseBinary(obj : TTurtleComplex) : TFhirBinary;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBinary.create;
  try
    ParseBinaryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBinaryProperties(obj : TTurtleComplex; result : TFhirBinary);
begin
    ParseResourceProperties(obj, result);
    result.contentTypeElement := ParseCode(obj.complex('http://hl7.org/fhir/Binary.contentType'));{q1}
    result.contentElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Binary.content'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeBinary(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBinary; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Binary'); {z}
  end;
  composeResource(this, '', name, elem, false, index);
  ComposeCode(this, 'Binary', 'contentType', elem.contentTypeElement, false, -1);{x.2ea}
  ComposeBase64Binary(this, 'Binary', 'content', elem.contentElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
function TFHIRTurtleParser.ParseBodySite(obj : TTurtleComplex) : TFhirBodySite;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBodySite.create;
  try
    ParseBodySiteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBodySiteProperties(obj : TTurtleComplex; result : TFhirBodySite);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/BodySite.patient'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/BodySite.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/BodySite.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/BodySite.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/BodySite.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/BodySite.image') do
      result.imageList.Add(parseAttachment(item));
end;

procedure TFHIRTurtleComposer.ComposeBodySite(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBodySite; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BodySite'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeReference{TFhirPatient}(this, 'BodySite', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'BodySite', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'BodySite', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('modifier') then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'BodySite', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'BodySite', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('image') then
    for i := 0 to elem.imageList.Count - 1 do
      ComposeAttachment(this, 'BodySite', 'image', elem.imageList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
function TFHIRTurtleParser.ParseBundleLink(obj : TTurtleComplex) : TFhirBundleLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleLink.create;
  try
    ParseBundleLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleLinkProperties(obj : TTurtleComplex; result : TFhirBundleLink);
begin
    ParseBackboneElementProperties(obj, result);
    result.relationElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.link.relation'));{q1}
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Bundle.link.url'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeBundleLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleLink'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Bundle.link', 'relation', elem.relationElement, false, -1);{x.2ea}
  ComposeUri(this, 'Bundle.link', 'url', elem.urlElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseBundleEntry(obj : TTurtleComplex) : TFhirBundleEntry;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleEntry.create;
  try
    ParseBundleEntryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleEntryProperties(obj : TTurtleComplex; result : TFhirBundleEntry);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Bundle.entry.link') do
      result.link_List.Add(parseBundleLink(item));
    result.fullUrlElement := ParseUri(obj.complex('http://hl7.org/fhir/Bundle.entry.fullUrl'));{q1}
    result.resource := ParseInnerResource(obj.predicate('http://hl7.org/fhir/Bundle.entry.resource'));{q3a}
    result.search := ParseBundleEntrySearch(obj.complex('http://hl7.org/fhir/Bundle.entry.search'));{q3b}
    result.request := ParseBundleEntryRequest(obj.complex('http://hl7.org/fhir/Bundle.entry.request'));{q3b}
    result.response := ParseBundleEntryResponse(obj.complex('http://hl7.org/fhir/Bundle.entry.response'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeBundleEntry(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntry; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleEntry'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(this, 'Bundle.entry', 'link', elem.link_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Bundle.entry', 'fullUrl', elem.fullUrlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(this, 'Bundle.entry', 'resource', elem.resourceElement, false, -1);{x.2ec}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntrySearch(this, 'Bundle.entry', 'search', elem.searchElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryRequest(this, 'Bundle.entry', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryResponse(this, 'Bundle.entry', 'response', elem.responseElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseBundleEntrySearch(obj : TTurtleComplex) : TFhirBundleEntrySearch;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleEntrySearch.create;
  try
    ParseBundleEntrySearchProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleEntrySearchProperties(obj : TTurtleComplex; result : TFhirBundleEntrySearch);
begin
    ParseBackboneElementProperties(obj, result);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Bundle.entry.search.mode'), CODES_TFhirSearchEntryModeEnum, SYSTEMS_TFhirSearchEntryModeEnum);
    result.scoreElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Bundle.entry.search.score'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeBundleEntrySearch(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntrySearch; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleEntrySearch'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'Bundle.entry.search', 'mode', elem.ModeElement, CODES_TFhirSearchEntryModeEnum, SYSTEMS_TFhirSearchEntryModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'Bundle.entry.search', 'score', elem.scoreElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseBundleEntryRequest(obj : TTurtleComplex) : TFhirBundleEntryRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleEntryRequest.create;
  try
    ParseBundleEntryRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleEntryRequestProperties(obj : TTurtleComplex; result : TFhirBundleEntryRequest);
begin
    ParseBackboneElementProperties(obj, result);
    result.methodElement := ParseEnum(obj.complex('http://hl7.org/fhir/Bundle.entry.request.method'), CODES_TFhirHttpVerbEnum, SYSTEMS_TFhirHttpVerbEnum);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Bundle.entry.request.url'));{q1}
    result.ifNoneMatchElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.request.ifNoneMatch'));{q1}
    result.ifModifiedSinceElement := ParseInstant(obj.complex('http://hl7.org/fhir/Bundle.entry.request.ifModifiedSince'));{q1}
    result.ifMatchElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.request.ifMatch'));{q1}
    result.ifNoneExistElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.request.ifNoneExist'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeBundleEntryRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntryRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleEntryRequest'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Bundle.entry.request', 'method', elem.MethodElement, CODES_TFhirHttpVerbEnum, SYSTEMS_TFhirHttpVerbEnum, false, -1);{x.d4}
  ComposeUri(this, 'Bundle.entry.request', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Bundle.entry.request', 'ifNoneMatch', elem.ifNoneMatchElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(this, 'Bundle.entry.request', 'ifModifiedSince', elem.ifModifiedSinceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Bundle.entry.request', 'ifMatch', elem.ifMatchElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Bundle.entry.request', 'ifNoneExist', elem.ifNoneExistElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseBundleEntryResponse(obj : TTurtleComplex) : TFhirBundleEntryResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleEntryResponse.create;
  try
    ParseBundleEntryResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleEntryResponseProperties(obj : TTurtleComplex; result : TFhirBundleEntryResponse);
begin
    ParseBackboneElementProperties(obj, result);
    result.statusElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.response.status'));{q1}
    result.locationElement := ParseUri(obj.complex('http://hl7.org/fhir/Bundle.entry.response.location'));{q1}
    result.etagElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.response.etag'));{q1}
    result.lastModifiedElement := ParseInstant(obj.complex('http://hl7.org/fhir/Bundle.entry.response.lastModified'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeBundleEntryResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntryResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleEntryResponse'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Bundle.entry.response', 'status', elem.statusElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Bundle.entry.response', 'location', elem.locationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Bundle.entry.response', 'etag', elem.etagElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(this, 'Bundle.entry.response', 'lastModified', elem.lastModifiedElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseBundle(obj : TTurtleComplex) : TFhirBundle;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundle.create;
  try
    ParseBundleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleProperties(obj : TTurtleComplex; result : TFhirBundle);
var
  item : TTurtleComplex;
begin
    ParseResourceProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Bundle.type'), CODES_TFhirBundleTypeEnum, SYSTEMS_TFhirBundleTypeEnum);
    result.totalElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Bundle.total'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Bundle.link') do
      result.link_List.Add(parseBundleLink(item));
    for item in obj.complexes('http://hl7.org/fhir/Bundle.entry') do
      result.entryList.Add(parseBundleEntry(item));
    result.signature := ParseSignature(obj.complex('http://hl7.org/fhir/Bundle.signature'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeBundle(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundle; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Bundle'); {z}
  end;
  composeResource(this, '', name, elem, false, index);
  ComposeEnum(this, 'Bundle', 'type', elem.Type_Element, CODES_TFhirBundleTypeEnum, SYSTEMS_TFhirBundleTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData, soCount]) then
    ComposeUnsignedInt(this, 'Bundle', 'total', elem.totalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(this, 'Bundle', 'link', elem.link_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeBundleEntry(this, 'Bundle', 'entry', elem.entryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeSignature(this, 'Bundle', 'signature', elem.signatureElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
function TFHIRTurtleParser.ParseCarePlanRelatedPlan(obj : TTurtleComplex) : TFhirCarePlanRelatedPlan;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCarePlanRelatedPlan.create;
  try
    ParseCarePlanRelatedPlanProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCarePlanRelatedPlanProperties(obj : TTurtleComplex; result : TFhirCarePlanRelatedPlan);
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CarePlan.relatedPlan.code'), CODES_TFhirCarePlanRelationshipEnum, SYSTEMS_TFhirCarePlanRelationshipEnum);
    result.plan := ParseReference{TFhirCarePlan}(obj.complex('http://hl7.org/fhir/CarePlan.relatedPlan.plan'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCarePlanRelatedPlan(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlanRelatedPlan; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CarePlanRelatedPlan'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'CarePlan.relatedPlan', 'code', elem.CodeElement, CODES_TFhirCarePlanRelationshipEnum, SYSTEMS_TFhirCarePlanRelationshipEnum, false, -1);{x.d4}
  ComposeReference{TFhirCarePlan}(this, 'CarePlan.relatedPlan', 'plan', elem.planElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCarePlanParticipant(obj : TTurtleComplex) : TFhirCarePlanParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCarePlanParticipant.create;
  try
    ParseCarePlanParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCarePlanParticipantProperties(obj : TTurtleComplex; result : TFhirCarePlanParticipant);
begin
    ParseBackboneElementProperties(obj, result);
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CarePlan.participant.role'));{q3b}
    result.member := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/CarePlan.participant.member'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCarePlanParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlanParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CarePlanParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CarePlan.participant', 'role', elem.roleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'CarePlan.participant', 'member', elem.memberElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCarePlanActivity(obj : TTurtleComplex) : TFhirCarePlanActivity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCarePlanActivity.create;
  try
    ParseCarePlanActivityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCarePlanActivityProperties(obj : TTurtleComplex; result : TFhirCarePlanActivity);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.actionResulting') do
      result.actionResultingList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.progress') do
      result.progressList.Add(parseAnnotation(item));
    result.reference := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/CarePlan.activity.reference'));{q3b}
    result.detail := ParseCarePlanActivityDetail(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCarePlanActivity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlanActivity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CarePlanActivity'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actionResultingList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'CarePlan.activity', 'actionResulting', elem.actionResultingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.progressList.Count - 1 do
      ComposeAnnotation(this, 'CarePlan.activity', 'progress', elem.progressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'CarePlan.activity', 'reference', elem.referenceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCarePlanActivityDetail(this, 'CarePlan.activity', 'detail', elem.detailElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCarePlanActivityDetail(obj : TTurtleComplex) : TFhirCarePlanActivityDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCarePlanActivityDetail.create;
  try
    ParseCarePlanActivityDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCarePlanActivityDetailProperties(obj : TTurtleComplex; result : TFhirCarePlanActivityDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.category'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.detail.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.detail.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.detail.goal') do
      result.goalList.Add(parseReference{TFhirGoal}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.status'), CODES_TFhirCarePlanActivityStatusEnum, SYSTEMS_TFhirCarePlanActivityStatusEnum);
    result.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.statusReason'));{q3b}
    result.prohibitedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.prohibited'));{q1}
    if obj.has('http://hl7.org/fhir/CarePlan.activity.detail.scheduledTiming', item) then
      result.scheduled := parseTiming(item);
    if obj.has('http://hl7.org/fhir/CarePlan.activity.detail.scheduledPeriod', item) then
      result.scheduled := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/CarePlan.activity.detail.scheduledString', item) then
      result.scheduled := parseString(item);
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.location'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.detail.performer') do
      result.performerList.Add(parseReference{Resource}(item));
    if obj.has('http://hl7.org/fhir/CarePlan.activity.detail.productCodeableConcept', item) then
      result.product := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/CarePlan.activity.detail.productReference', item) {a3} then
      result.product := ParseReference(item);
    result.dailyAmount := ParseQuantity(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.dailyAmount'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.quantity'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.description'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCarePlanActivityDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlanActivityDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CarePlanActivityDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CarePlan.activity.detail', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CarePlan.activity.detail', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'CarePlan.activity.detail', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'CarePlan.activity.detail', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(this, 'CarePlan.activity.detail', 'goal', elem.goalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'CarePlan.activity.detail', 'status', elem.StatusElement, CODES_TFhirCarePlanActivityStatusEnum, SYSTEMS_TFhirCarePlanActivityStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CarePlan.activity.detail', 'statusReason', elem.statusReasonElement, false, -1);{x.2f}
  ComposeBoolean(this, 'CarePlan.activity.detail', 'prohibited', elem.prohibitedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirTiming) {6} then
    ComposeTiming(this, 'CarePlan.activity.detail', 'scheduledTiming', TFhirTiming(elem.scheduled), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(this, 'CarePlan.activity.detail', 'scheduledPeriod', TFhirPeriod(elem.scheduled), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirString) {6} then
    ComposeString(this, 'CarePlan.activity.detail', 'scheduledString', TFhirString(elem.scheduled), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'CarePlan.activity.detail', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(this, 'CarePlan.activity.detail', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.product is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'CarePlan.activity.detail', 'productCodeableConcept', TFhirCodeableConcept(elem.product), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.product is TFhirReference) {2} then
    ComposeReference(this, 'CarePlan.activity.detail', 'productReference', TFhirReference(elem.product), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'CarePlan.activity.detail', 'dailyAmount', elem.dailyAmountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'CarePlan.activity.detail', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CarePlan.activity.detail', 'description', elem.descriptionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCarePlan(obj : TTurtleComplex) : TFhirCarePlan;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCarePlan.create;
  try
    ParseCarePlanProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCarePlanProperties(obj : TTurtleComplex; result : TFhirCarePlan);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/CarePlan.subject'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CarePlan.status'), CODES_TFhirCarePlanStatusEnum, SYSTEMS_TFhirCarePlanStatusEnum);
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/CarePlan.context'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/CarePlan.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.author') do
      result.authorList.Add(parseReference{Resource}(item));
    result.modifiedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CarePlan.modified'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CarePlan.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.addresses') do
      result.addressesList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.support') do
      result.supportList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.relatedPlan') do
      result.relatedPlanList.Add(parseCarePlanRelatedPlan(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.participant') do
      result.participantList.Add(parseCarePlanParticipant(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.goal') do
      result.goalList.Add(parseReference{TFhirGoal}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity') do
      result.activityList.Add(parseCarePlanActivity(item));
    result.note := ParseAnnotation(obj.complex('http://hl7.org/fhir/CarePlan.note'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCarePlan(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlan; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CarePlan'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CarePlan', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'CarePlan', 'subject', elem.subjectElement, false, -1);{x.2f}
  ComposeEnum(this, 'CarePlan', 'status', elem.StatusElement, CODES_TFhirCarePlanStatusEnum, SYSTEMS_TFhirCarePlanStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'CarePlan', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'CarePlan', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(this, 'CarePlan', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('modified') then
    ComposeDateTime(this, 'CarePlan', 'modified', elem.modifiedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'CarePlan', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'CarePlan', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('addresses') then
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'CarePlan', 'addresses', elem.addressesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('support') then
    for i := 0 to elem.supportList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'CarePlan', 'support', elem.supportList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedPlan') then
    for i := 0 to elem.relatedPlanList.Count - 1 do
      ComposeCarePlanRelatedPlan(this, 'CarePlan', 'relatedPlan', elem.relatedPlanList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeCarePlanParticipant(this, 'CarePlan', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('goal') then
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(this, 'CarePlan', 'goal', elem.goalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('activity') then
    for i := 0 to elem.activityList.Count - 1 do
      ComposeCarePlanActivity(this, 'CarePlan', 'activity', elem.activityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    ComposeAnnotation(this, 'CarePlan', 'note', elem.noteElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
function TFHIRTurtleParser.ParseClaimPayee(obj : TTurtleComplex) : TFhirClaimPayee;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimPayee.create;
  try
    ParseClaimPayeeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimPayeeProperties(obj : TTurtleComplex; result : TFhirClaimPayee);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.payee.type'));{q3b}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Claim.payee.provider'));{q3b}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Claim.payee.organization'));{q3b}
    result.person := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Claim.payee.person'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimPayee(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimPayee; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimPayee'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'Claim.payee', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'Claim.payee', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Claim.payee', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'Claim.payee', 'person', elem.personElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimDiagnosis(obj : TTurtleComplex) : TFhirClaimDiagnosis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimDiagnosis.create;
  try
    ParseClaimDiagnosisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimDiagnosisProperties(obj : TTurtleComplex; result : TFhirClaimDiagnosis);
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.diagnosis.sequence'));{q1}
    result.diagnosis := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.diagnosis.diagnosis'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimDiagnosis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimDiagnosis'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.diagnosis', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeCoding(this, 'Claim.diagnosis', 'diagnosis', elem.diagnosisElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimCoverage(obj : TTurtleComplex) : TFhirClaimCoverage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimCoverage.create;
  try
    ParseClaimCoverageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimCoverageProperties(obj : TTurtleComplex; result : TFhirClaimCoverage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.coverage.sequence'));{q1}
    result.focalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Claim.coverage.focal'));{q1}
    result.coverage := ParseReference{TFhirCoverage}(obj.complex('http://hl7.org/fhir/Claim.coverage.coverage'));{q3b}
    result.businessArrangementElement := ParseString(obj.complex('http://hl7.org/fhir/Claim.coverage.businessArrangement'));{q1}
    result.relationship := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.coverage.relationship'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.coverage.preAuthRef') do
      result.preAuthRefList.Add(parseString(item));
    result.claimResponse := ParseReference{TFhirClaimResponse}(obj.complex('http://hl7.org/fhir/Claim.coverage.claimResponse'));{q3b}
    result.originalRuleset := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.coverage.originalRuleset'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimCoverage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimCoverage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimCoverage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.coverage', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'Claim.coverage', 'focal', elem.focalElement, false, -1);{x.2ea}
  ComposeReference{TFhirCoverage}(this, 'Claim.coverage', 'coverage', elem.coverageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Claim.coverage', 'businessArrangement', elem.businessArrangementElement, false, -1);{x.2ea}
  ComposeCoding(this, 'Claim.coverage', 'relationship', elem.relationshipElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.preAuthRefList.Count - 1 do
      ComposeString(this, 'Claim.coverage', 'preAuthRef', elem.preAuthRefList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaimResponse}(this, 'Claim.coverage', 'claimResponse', elem.claimResponseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'Claim.coverage', 'originalRuleset', elem.originalRulesetElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimItem(obj : TTurtleComplex) : TFhirClaimItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimItem.create;
  try
    ParseClaimItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimItemProperties(obj : TTurtleComplex; result : TFhirClaimItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.item.sequence'));{q1}
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.item.type'));{q3b}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Claim.item.provider'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.diagnosisLinkId') do
      result.diagnosisLinkIdList.Add(parsePositiveInt(item));
    result.service := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.item.service'));{q3b}
    result.serviceDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Claim.item.serviceDate'));{q1}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.quantity'));{q3b}
    result.unitPrice := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Claim.item.factor'));{q1}
    result.pointsElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Claim.item.points'));{q1}
    result.net := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.net'));{q3b}
    result.udi := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.item.udi'));{q3b}
    result.bodySite := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.item.bodySite'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.subSite') do
      result.subSiteList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.modifier') do
      result.modifierList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail') do
      result.detailList.Add(parseClaimItemDetail(item));
    result.prosthesis := ParseClaimItemProsthesis(obj.complex('http://hl7.org/fhir/Claim.item.prosthesis'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.item', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeCoding(this, 'Claim.item', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'Claim.item', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.diagnosisLinkIdList.Count - 1 do
      ComposePositiveInt(this, 'Claim.item', 'diagnosisLinkId', elem.diagnosisLinkIdList[i], false, i);{x.d3}
  ComposeCoding(this, 'Claim.item', 'service', elem.serviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'Claim.item', 'serviceDate', elem.serviceDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Claim.item', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Claim.item', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Claim.item', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Claim.item', 'points', elem.pointsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Claim.item', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'Claim.item', 'udi', elem.udiElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'Claim.item', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCoding(this, 'Claim.item', 'subSite', elem.subSiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCoding(this, 'Claim.item', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimItemDetail(this, 'Claim.item', 'detail', elem.detailList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClaimItemProsthesis(this, 'Claim.item', 'prosthesis', elem.prosthesisElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimItemDetail(obj : TTurtleComplex) : TFhirClaimItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimItemDetail.create;
  try
    ParseClaimItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.item.detail.sequence'));{q1}
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.item.detail.type'));{q3b}
    result.service := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.item.detail.service'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.detail.quantity'));{q3b}
    result.unitPrice := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.detail.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Claim.item.detail.factor'));{q1}
    result.pointsElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Claim.item.detail.points'));{q1}
    result.net := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.detail.net'));{q3b}
    result.udi := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.item.detail.udi'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.subDetail') do
      result.subDetailList.Add(parseClaimItemDetailSubDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimItemDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.item.detail', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeCoding(this, 'Claim.item.detail', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeCoding(this, 'Claim.item.detail', 'service', elem.serviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Claim.item.detail', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Claim.item.detail', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Claim.item.detail', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Claim.item.detail', 'points', elem.pointsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Claim.item.detail', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'Claim.item.detail', 'udi', elem.udiElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimItemDetailSubDetail(this, 'Claim.item.detail', 'subDetail', elem.subDetailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimItemDetailSubDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimItemDetailSubDetail.create;
  try
    ParseClaimItemDetailSubDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirClaimItemDetailSubDetail);
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.sequence'));{q1}
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.type'));{q3b}
    result.service := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.service'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.quantity'));{q3b}
    result.unitPrice := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.factor'));{q1}
    result.pointsElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.points'));{q1}
    result.net := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.net'));{q3b}
    result.udi := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.udi'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItemDetailSubDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimItemDetailSubDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.item.detail.subDetail', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeCoding(this, 'Claim.item.detail.subDetail', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeCoding(this, 'Claim.item.detail.subDetail', 'service', elem.serviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Claim.item.detail.subDetail', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Claim.item.detail.subDetail', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Claim.item.detail.subDetail', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Claim.item.detail.subDetail', 'points', elem.pointsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Claim.item.detail.subDetail', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'Claim.item.detail.subDetail', 'udi', elem.udiElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimItemProsthesis(obj : TTurtleComplex) : TFhirClaimItemProsthesis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimItemProsthesis.create;
  try
    ParseClaimItemProsthesisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimItemProsthesisProperties(obj : TTurtleComplex; result : TFhirClaimItemProsthesis);
begin
    ParseBackboneElementProperties(obj, result);
    result.initialElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Claim.item.prosthesis.initial'));{q1}
    result.priorDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Claim.item.prosthesis.priorDate'));{q1}
    result.priorMaterial := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.item.prosthesis.priorMaterial'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimItemProsthesis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItemProsthesis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimItemProsthesis'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Claim.item.prosthesis', 'initial', elem.initialElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'Claim.item.prosthesis', 'priorDate', elem.priorDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'Claim.item.prosthesis', 'priorMaterial', elem.priorMaterialElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimMissingTeeth(obj : TTurtleComplex) : TFhirClaimMissingTeeth;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimMissingTeeth.create;
  try
    ParseClaimMissingTeethProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimMissingTeethProperties(obj : TTurtleComplex; result : TFhirClaimMissingTeeth);
begin
    ParseBackboneElementProperties(obj, result);
    result.tooth := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.missingTeeth.tooth'));{q3b}
    result.reason := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.missingTeeth.reason'));{q3b}
    result.extractionDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Claim.missingTeeth.extractionDate'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeClaimMissingTeeth(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimMissingTeeth; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimMissingTeeth'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'Claim.missingTeeth', 'tooth', elem.toothElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'Claim.missingTeeth', 'reason', elem.reasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'Claim.missingTeeth', 'extractionDate', elem.extractionDateElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseClaim(obj : TTurtleComplex) : TFhirClaim;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaim.create;
  try
    ParseClaimProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimProperties(obj : TTurtleComplex; result : TFhirClaim);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Claim.type'), CODES_TFhirClaimTypeLinkEnum, SYSTEMS_TFhirClaimTypeLinkEnum);
    for item in obj.complexes('http://hl7.org/fhir/Claim.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.ruleset := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.ruleset'));{q3b}
    result.originalRuleset := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.originalRuleset'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Claim.created'));{q1}
    result.target := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Claim.target'));{q3b}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Claim.provider'));{q3b}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Claim.organization'));{q3b}
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/Claim.use'), CODES_TFhirClaimUseLinkEnum, SYSTEMS_TFhirClaimUseLinkEnum);
    result.priority := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.priority'));{q3b}
    result.fundsReserve := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.fundsReserve'));{q3b}
    result.enterer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Claim.enterer'));{q3b}
    result.facility := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Claim.facility'));{q3b}
    result.prescription := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Claim.prescription'));{q3b}
    result.originalPrescription := ParseReference{TFhirMedicationOrder}(obj.complex('http://hl7.org/fhir/Claim.originalPrescription'));{q3b}
    result.payee := ParseClaimPayee(obj.complex('http://hl7.org/fhir/Claim.payee'));{q3b}
    result.referral := ParseReference{TFhirReferralRequest}(obj.complex('http://hl7.org/fhir/Claim.referral'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.diagnosis') do
      result.diagnosisList.Add(parseClaimDiagnosis(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.condition') do
      result.conditionList.Add(parseCoding(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Claim.patient'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.coverage') do
      result.coverageList.Add(parseClaimCoverage(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.exception') do
      result.exceptionList.Add(parseCoding(item));
    result.schoolElement := ParseString(obj.complex('http://hl7.org/fhir/Claim.school'));{q1}
    result.accidentElement := ParseDate(obj.complex('http://hl7.org/fhir/Claim.accident'));{q1}
    result.accidentType := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.accidentType'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.interventionException') do
      result.interventionExceptionList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item') do
      result.itemList.Add(parseClaimItem(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.additionalMaterials') do
      result.additionalMaterialsList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.missingTeeth') do
      result.missingTeethList.Add(parseClaimMissingTeeth(item));
end;

procedure TFHIRTurtleComposer.ComposeClaim(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaim; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Claim'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeEnum(this, 'Claim', 'type', elem.Type_Element, CODES_TFhirClaimTypeLinkEnum, SYSTEMS_TFhirClaimTypeLinkEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Claim', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(this, 'Claim', 'ruleset', elem.rulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(this, 'Claim', 'originalRuleset', elem.originalRulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(this, 'Claim', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(this, 'Claim', 'target', elem.targetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(this, 'Claim', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'Claim', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('use') then
    ComposeEnum(this, 'Claim', 'use', elem.UseElement, CODES_TFhirClaimUseLinkEnum, SYSTEMS_TFhirClaimUseLinkEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeCoding(this, 'Claim', 'priority', elem.priorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fundsReserve') then
    ComposeCoding(this, 'Claim', 'fundsReserve', elem.fundsReserveElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(this, 'Claim', 'enterer', elem.entererElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('facility') then
    ComposeReference{TFhirLocation}(this, 'Claim', 'facility', elem.facilityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('prescription') then
    ComposeReference{Resource}(this, 'Claim', 'prescription', elem.prescriptionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalPrescription') then
    ComposeReference{TFhirMedicationOrder}(this, 'Claim', 'originalPrescription', elem.originalPrescriptionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payee') then
    ComposeClaimPayee(this, 'Claim', 'payee', elem.payeeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referral') then
    ComposeReference{TFhirReferralRequest}(this, 'Claim', 'referral', elem.referralElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('diagnosis') then
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeClaimDiagnosis(this, 'Claim', 'diagnosis', elem.diagnosisList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('condition') then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeCoding(this, 'Claim', 'condition', elem.conditionList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'Claim', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('coverage') then
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeClaimCoverage(this, 'Claim', 'coverage', elem.coverageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('exception') then
    for i := 0 to elem.exceptionList.Count - 1 do
      ComposeCoding(this, 'Claim', 'exception', elem.exceptionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('school') then
    ComposeString(this, 'Claim', 'school', elem.schoolElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accident') then
    ComposeDate(this, 'Claim', 'accident', elem.accidentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accidentType') then
    ComposeCoding(this, 'Claim', 'accidentType', elem.accidentTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('interventionException') then
    for i := 0 to elem.interventionExceptionList.Count - 1 do
      ComposeCoding(this, 'Claim', 'interventionException', elem.interventionExceptionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimItem(this, 'Claim', 'item', elem.itemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('additionalMaterials') then
    for i := 0 to elem.additionalMaterialsList.Count - 1 do
      ComposeCoding(this, 'Claim', 'additionalMaterials', elem.additionalMaterialsList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('missingTeeth') then
    for i := 0 to elem.missingTeethList.Count - 1 do
      ComposeClaimMissingTeeth(this, 'Claim', 'missingTeeth', elem.missingTeethList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
function TFHIRTurtleParser.ParseClaimResponseItem(obj : TTurtleComplex) : TFhirClaimResponseItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItem.create;
  try
    ParseClaimResponseItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemProperties(obj : TTurtleComplex; result : TFhirClaimResponseItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceLinkIdElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.item.sequenceLinkId'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.adjudication') do
      result.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail') do
      result.detailList.Add(parseClaimResponseItemDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ClaimResponse.item', 'sequenceLinkId', elem.sequenceLinkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.item', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.item', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseItemDetail(this, 'ClaimResponse.item', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimResponseItemAdjudication(obj : TTurtleComplex) : TFhirClaimResponseItemAdjudication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItemAdjudication.create;
  try
    ParseClaimResponseItemAdjudicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemAdjudicationProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemAdjudication);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.item.adjudication.code'));{q3b}
    result.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.item.adjudication.amount'));{q3b}
    result.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ClaimResponse.item.adjudication.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItemAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemAdjudication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItemAdjudication'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'ClaimResponse.item.adjudication', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponse.item.adjudication', 'amount', elem.amountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'ClaimResponse.item.adjudication', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseClaimResponseItemDetail(obj : TTurtleComplex) : TFhirClaimResponseItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItemDetail.create;
  try
    ParseClaimResponseItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceLinkIdElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.item.detail.sequenceLinkId'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.adjudication') do
      result.adjudicationList.Add(parseClaimResponseItemDetailAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail') do
      result.subDetailList.Add(parseClaimResponseItemDetailSubDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItemDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ClaimResponse.item.detail', 'sequenceLinkId', elem.sequenceLinkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemDetailAdjudication(this, 'ClaimResponse.item.detail', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetail(this, 'ClaimResponse.item.detail', 'subDetail', elem.subDetailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimResponseItemDetailAdjudication(obj : TTurtleComplex) : TFhirClaimResponseItemDetailAdjudication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItemDetailAdjudication.create;
  try
    ParseClaimResponseItemDetailAdjudicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemDetailAdjudicationProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemDetailAdjudication);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.item.detail.adjudication.code'));{q3b}
    result.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.item.detail.adjudication.amount'));{q3b}
    result.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ClaimResponse.item.detail.adjudication.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItemDetailAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemDetailAdjudication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItemDetailAdjudication'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'ClaimResponse.item.detail.adjudication', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponse.item.detail.adjudication', 'amount', elem.amountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'ClaimResponse.item.detail.adjudication', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseClaimResponseItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimResponseItemDetailSubDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    ParseClaimResponseItemDetailSubDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemDetailSubDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceLinkIdElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail.sequenceLinkId'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail.adjudication') do
      result.adjudicationList.Add(parseClaimResponseItemDetailSubDetailAdjudication(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemDetailSubDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItemDetailSubDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ClaimResponse.item.detail.subDetail', 'sequenceLinkId', elem.sequenceLinkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetailAdjudication(this, 'ClaimResponse.item.detail.subDetail', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimResponseItemDetailSubDetailAdjudication(obj : TTurtleComplex) : TFhirClaimResponseItemDetailSubDetailAdjudication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItemDetailSubDetailAdjudication.create;
  try
    ParseClaimResponseItemDetailSubDetailAdjudicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemDetailSubDetailAdjudicationProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemDetailSubDetailAdjudication);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail.adjudication.code'));{q3b}
    result.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail.adjudication.amount'));{q3b}
    result.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail.adjudication.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItemDetailSubDetailAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemDetailSubDetailAdjudication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItemDetailSubDetailAdjudication'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'ClaimResponse.item.detail.subDetail.adjudication', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponse.item.detail.subDetail.adjudication', 'amount', elem.amountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'ClaimResponse.item.detail.subDetail.adjudication', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseClaimResponseAddItem(obj : TTurtleComplex) : TFhirClaimResponseAddItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseAddItem.create;
  try
    ParseClaimResponseAddItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseAddItemProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.sequenceLinkId') do
      result.sequenceLinkIdList.Add(parsePositiveInt(item));
    result.service := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.service'));{q3b}
    result.fee := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.fee'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.noteNumberLinkId') do
      result.noteNumberLinkIdList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.adjudication') do
      result.adjudicationList.Add(parseClaimResponseAddItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail') do
      result.detailList.Add(parseClaimResponseAddItemDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseAddItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseAddItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.sequenceLinkIdList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.addItem', 'sequenceLinkId', elem.sequenceLinkIdList[i], false, i);{x.d3}
  ComposeCoding(this, 'ClaimResponse.addItem', 'service', elem.serviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponse.addItem', 'fee', elem.feeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.noteNumberLinkIdList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.addItem', 'noteNumberLinkId', elem.noteNumberLinkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseAddItemAdjudication(this, 'ClaimResponse.addItem', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseAddItemDetail(this, 'ClaimResponse.addItem', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimResponseAddItemAdjudication(obj : TTurtleComplex) : TFhirClaimResponseAddItemAdjudication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseAddItemAdjudication.create;
  try
    ParseClaimResponseAddItemAdjudicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseAddItemAdjudicationProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItemAdjudication);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.adjudication.code'));{q3b}
    result.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.adjudication.amount'));{q3b}
    result.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.adjudication.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseAddItemAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItemAdjudication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseAddItemAdjudication'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'ClaimResponse.addItem.adjudication', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponse.addItem.adjudication', 'amount', elem.amountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'ClaimResponse.addItem.adjudication', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseClaimResponseAddItemDetail(obj : TTurtleComplex) : TFhirClaimResponseAddItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseAddItemDetail.create;
  try
    ParseClaimResponseAddItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseAddItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.service := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.service'));{q3b}
    result.fee := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.fee'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.adjudication') do
      result.adjudicationList.Add(parseClaimResponseAddItemDetailAdjudication(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseAddItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseAddItemDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'ClaimResponse.addItem.detail', 'service', elem.serviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponse.addItem.detail', 'fee', elem.feeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseAddItemDetailAdjudication(this, 'ClaimResponse.addItem.detail', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimResponseAddItemDetailAdjudication(obj : TTurtleComplex) : TFhirClaimResponseAddItemDetailAdjudication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseAddItemDetailAdjudication.create;
  try
    ParseClaimResponseAddItemDetailAdjudicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseAddItemDetailAdjudicationProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItemDetailAdjudication);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.adjudication.code'));{q3b}
    result.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.adjudication.amount'));{q3b}
    result.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.adjudication.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseAddItemDetailAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItemDetailAdjudication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseAddItemDetailAdjudication'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'ClaimResponse.addItem.detail.adjudication', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ClaimResponse.addItem.detail.adjudication', 'amount', elem.amountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'ClaimResponse.addItem.detail.adjudication', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseClaimResponseError(obj : TTurtleComplex) : TFhirClaimResponseError;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseError.create;
  try
    ParseClaimResponseErrorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseErrorProperties(obj : TTurtleComplex; result : TFhirClaimResponseError);
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceLinkIdElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.error.sequenceLinkId'));{q1}
    result.detailSequenceLinkIdElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.error.detailSequenceLinkId'));{q1}
    result.subdetailSequenceLinkIdElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.error.subdetailSequenceLinkId'));{q1}
    result.code := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.error.code'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseError(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseError; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseError'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ClaimResponse.error', 'sequenceLinkId', elem.sequenceLinkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ClaimResponse.error', 'detailSequenceLinkId', elem.detailSequenceLinkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ClaimResponse.error', 'subdetailSequenceLinkId', elem.subdetailSequenceLinkIdElement, false, -1);{x.2ea}
  ComposeCoding(this, 'ClaimResponse.error', 'code', elem.codeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimResponseNote(obj : TTurtleComplex) : TFhirClaimResponseNote;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseNote.create;
  try
    ParseClaimResponseNoteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseNoteProperties(obj : TTurtleComplex; result : TFhirClaimResponseNote);
begin
    ParseBackboneElementProperties(obj, result);
    result.numberElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.note.number'));{q1}
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.note.type'));{q3b}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/ClaimResponse.note.text'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseNote; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseNote'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ClaimResponse.note', 'number', elem.numberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'ClaimResponse.note', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ClaimResponse.note', 'text', elem.textElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseClaimResponseCoverage(obj : TTurtleComplex) : TFhirClaimResponseCoverage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseCoverage.create;
  try
    ParseClaimResponseCoverageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseCoverageProperties(obj : TTurtleComplex; result : TFhirClaimResponseCoverage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.coverage.sequence'));{q1}
    result.focalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ClaimResponse.coverage.focal'));{q1}
    result.coverage := ParseReference{TFhirCoverage}(obj.complex('http://hl7.org/fhir/ClaimResponse.coverage.coverage'));{q3b}
    result.businessArrangementElement := ParseString(obj.complex('http://hl7.org/fhir/ClaimResponse.coverage.businessArrangement'));{q1}
    result.relationship := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.coverage.relationship'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.coverage.preAuthRef') do
      result.preAuthRefList.Add(parseString(item));
    result.claimResponse := ParseReference{TFhirClaimResponse}(obj.complex('http://hl7.org/fhir/ClaimResponse.coverage.claimResponse'));{q3b}
    result.originalRuleset := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.coverage.originalRuleset'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseCoverage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseCoverage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseCoverage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ClaimResponse.coverage', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'ClaimResponse.coverage', 'focal', elem.focalElement, false, -1);{x.2ea}
  ComposeReference{TFhirCoverage}(this, 'ClaimResponse.coverage', 'coverage', elem.coverageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ClaimResponse.coverage', 'businessArrangement', elem.businessArrangementElement, false, -1);{x.2ea}
  ComposeCoding(this, 'ClaimResponse.coverage', 'relationship', elem.relationshipElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.preAuthRefList.Count - 1 do
      ComposeString(this, 'ClaimResponse.coverage', 'preAuthRef', elem.preAuthRefList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaimResponse}(this, 'ClaimResponse.coverage', 'claimResponse', elem.claimResponseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'ClaimResponse.coverage', 'originalRuleset', elem.originalRulesetElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimResponse(obj : TTurtleComplex) : TFhirClaimResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponse.create;
  try
    ParseClaimResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseProperties(obj : TTurtleComplex; result : TFhirClaimResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.request := ParseReference{TFhirClaim}(obj.complex('http://hl7.org/fhir/ClaimResponse.request'));{q3b}
    result.ruleset := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.ruleset'));{q3b}
    result.originalRuleset := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.originalRuleset'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ClaimResponse.created'));{q1}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ClaimResponse.organization'));{q3b}
    result.requestProvider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ClaimResponse.requestProvider'));{q3b}
    result.requestOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ClaimResponse.requestOrganization'));{q3b}
    result.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ClaimResponse.outcome'), CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    result.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/ClaimResponse.disposition'));{q1}
    result.payeeType := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.payeeType'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item') do
      result.itemList.Add(parseClaimResponseItem(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem') do
      result.addItemList.Add(parseClaimResponseAddItem(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.error') do
      result.errorList.Add(parseClaimResponseError(item));
    result.totalCost := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.totalCost'));{q3b}
    result.unallocDeductable := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.unallocDeductable'));{q3b}
    result.totalBenefit := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.totalBenefit'));{q3b}
    result.paymentAdjustment := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.paymentAdjustment'));{q3b}
    result.paymentAdjustmentReason := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.paymentAdjustmentReason'));{q3b}
    result.paymentDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ClaimResponse.paymentDate'));{q1}
    result.paymentAmount := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.paymentAmount'));{q3b}
    result.paymentRef := ParseIdentifier(obj.complex('http://hl7.org/fhir/ClaimResponse.paymentRef'));{q3b}
    result.reserved := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.reserved'));{q3b}
    result.form := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.form'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.note') do
      result.noteList.Add(parseClaimResponseNote(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.coverage') do
      result.coverageList.Add(parseClaimResponseCoverage(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ClaimResponse', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirClaim}(this, 'ClaimResponse', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(this, 'ClaimResponse', 'ruleset', elem.rulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(this, 'ClaimResponse', 'originalRuleset', elem.originalRulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(this, 'ClaimResponse', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'ClaimResponse', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(this, 'ClaimResponse', 'requestProvider', elem.requestProviderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(this, 'ClaimResponse', 'requestOrganization', elem.requestOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnum(this, 'ClaimResponse', 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeString(this, 'ClaimResponse', 'disposition', elem.dispositionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payeeType') then
    ComposeCoding(this, 'ClaimResponse', 'payeeType', elem.payeeTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimResponseItem(this, 'ClaimResponse', 'item', elem.itemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('addItem') then
    for i := 0 to elem.addItemList.Count - 1 do
      ComposeClaimResponseAddItem(this, 'ClaimResponse', 'addItem', elem.addItemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('error') then
    for i := 0 to elem.errorList.Count - 1 do
      ComposeClaimResponseError(this, 'ClaimResponse', 'error', elem.errorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('totalCost') then
    ComposeQuantity(this, 'ClaimResponse', 'totalCost', elem.totalCostElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('unallocDeductable') then
    ComposeQuantity(this, 'ClaimResponse', 'unallocDeductable', elem.unallocDeductableElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('totalBenefit') then
    ComposeQuantity(this, 'ClaimResponse', 'totalBenefit', elem.totalBenefitElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentAdjustment') then
    ComposeQuantity(this, 'ClaimResponse', 'paymentAdjustment', elem.paymentAdjustmentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentAdjustmentReason') then
    ComposeCoding(this, 'ClaimResponse', 'paymentAdjustmentReason', elem.paymentAdjustmentReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentDate') then
    ComposeDate(this, 'ClaimResponse', 'paymentDate', elem.paymentDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentAmount') then
    ComposeQuantity(this, 'ClaimResponse', 'paymentAmount', elem.paymentAmountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentRef') then
    ComposeIdentifier(this, 'ClaimResponse', 'paymentRef', elem.paymentRefElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reserved') then
    ComposeCoding(this, 'ClaimResponse', 'reserved', elem.reservedElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('form') then
    ComposeCoding(this, 'ClaimResponse', 'form', elem.formElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeClaimResponseNote(this, 'ClaimResponse', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('coverage') then
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeClaimResponseCoverage(this, 'ClaimResponse', 'coverage', elem.coverageList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
function TFHIRTurtleParser.ParseClinicalImpressionInvestigations(obj : TTurtleComplex) : TFhirClinicalImpressionInvestigations;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalImpressionInvestigations.create;
  try
    ParseClinicalImpressionInvestigationsProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalImpressionInvestigationsProperties(obj : TTurtleComplex; result : TFhirClinicalImpressionInvestigations);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalImpression.investigations.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.investigations.item') do
      result.itemList.Add(parseReference{Resource}(item));
end;

procedure TFHIRTurtleComposer.ComposeClinicalImpressionInvestigations(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpressionInvestigations; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalImpressionInvestigations'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ClinicalImpression.investigations', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeReference{Resource}(this, 'ClinicalImpression.investigations', 'item', elem.itemList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClinicalImpressionFinding(obj : TTurtleComplex) : TFhirClinicalImpressionFinding;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalImpressionFinding.create;
  try
    ParseClinicalImpressionFindingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalImpressionFindingProperties(obj : TTurtleComplex; result : TFhirClinicalImpressionFinding);
begin
    ParseBackboneElementProperties(obj, result);
    result.item := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalImpression.finding.item'));{q3b}
    result.causeElement := ParseString(obj.complex('http://hl7.org/fhir/ClinicalImpression.finding.cause'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeClinicalImpressionFinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpressionFinding; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalImpressionFinding'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ClinicalImpression.finding', 'item', elem.itemElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ClinicalImpression.finding', 'cause', elem.causeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseClinicalImpressionRuledOut(obj : TTurtleComplex) : TFhirClinicalImpressionRuledOut;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalImpressionRuledOut.create;
  try
    ParseClinicalImpressionRuledOutProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalImpressionRuledOutProperties(obj : TTurtleComplex; result : TFhirClinicalImpressionRuledOut);
begin
    ParseBackboneElementProperties(obj, result);
    result.item := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalImpression.ruledOut.item'));{q3b}
    result.reasonElement := ParseString(obj.complex('http://hl7.org/fhir/ClinicalImpression.ruledOut.reason'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeClinicalImpressionRuledOut(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpressionRuledOut; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalImpressionRuledOut'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ClinicalImpression.ruledOut', 'item', elem.itemElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ClinicalImpression.ruledOut', 'reason', elem.reasonElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseClinicalImpression(obj : TTurtleComplex) : TFhirClinicalImpression;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalImpression.create;
  try
    ParseClinicalImpressionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalImpressionProperties(obj : TTurtleComplex; result : TFhirClinicalImpression);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ClinicalImpression.patient'));{q3b}
    result.assessor := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ClinicalImpression.assessor'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ClinicalImpression.status'), CODES_TFhirClinicalImpressionStatusEnum, SYSTEMS_TFhirClinicalImpressionStatusEnum);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ClinicalImpression.date'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ClinicalImpression.description'));{q1}
    result.previous := ParseReference{TFhirClinicalImpression}(obj.complex('http://hl7.org/fhir/ClinicalImpression.previous'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.problem') do
      result.problemList.Add(parseReference{Resource}(item));
    if obj.has('http://hl7.org/fhir/ClinicalImpression.triggerCodeableConcept', item) then
      result.trigger := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ClinicalImpression.triggerReference', item) {a3} then
      result.trigger := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.investigations') do
      result.investigationsList.Add(parseClinicalImpressionInvestigations(item));
    result.protocolElement := ParseUri(obj.complex('http://hl7.org/fhir/ClinicalImpression.protocol'));{q1}
    result.summaryElement := ParseString(obj.complex('http://hl7.org/fhir/ClinicalImpression.summary'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.finding') do
      result.findingList.Add(parseClinicalImpressionFinding(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.resolved') do
      result.resolvedList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.ruledOut') do
      result.ruledOutList.Add(parseClinicalImpressionRuledOut(item));
    result.prognosisElement := ParseString(obj.complex('http://hl7.org/fhir/ClinicalImpression.prognosis'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.plan') do
      result.planList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.action') do
      result.actionList.Add(parseReference{Resource}(item));
end;

procedure TFHIRTurtleComposer.ComposeClinicalImpression(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpression; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalImpression'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeReference{TFhirPatient}(this, 'ClinicalImpression', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('assessor') then
    ComposeReference{TFhirPractitioner}(this, 'ClinicalImpression', 'assessor', elem.assessorElement, false, -1);{x.2f}
  ComposeEnum(this, 'ClinicalImpression', 'status', elem.StatusElement, CODES_TFhirClinicalImpressionStatusEnum, SYSTEMS_TFhirClinicalImpressionStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ClinicalImpression', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'ClinicalImpression', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('previous') then
    ComposeReference{TFhirClinicalImpression}(this, 'ClinicalImpression', 'previous', elem.previousElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('problem') then
    for i := 0 to elem.problemList.Count - 1 do
      ComposeReference{Resource}(this, 'ClinicalImpression', 'problem', elem.problemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.trigger is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ClinicalImpression', 'triggerCodeableConcept', TFhirCodeableConcept(elem.trigger), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.trigger is TFhirReference) {2} then
    ComposeReference(this, 'ClinicalImpression', 'triggerReference', TFhirReference(elem.trigger), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) and doCompose('investigations') then
    for i := 0 to elem.investigationsList.Count - 1 do
      ComposeClinicalImpressionInvestigations(this, 'ClinicalImpression', 'investigations', elem.investigationsList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('protocol') then
    ComposeUri(this, 'ClinicalImpression', 'protocol', elem.protocolElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('summary') then
    ComposeString(this, 'ClinicalImpression', 'summary', elem.summaryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('finding') then
    for i := 0 to elem.findingList.Count - 1 do
      ComposeClinicalImpressionFinding(this, 'ClinicalImpression', 'finding', elem.findingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('resolved') then
    for i := 0 to elem.resolvedList.Count - 1 do
      ComposeCodeableConcept(this, 'ClinicalImpression', 'resolved', elem.resolvedList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('ruledOut') then
    for i := 0 to elem.ruledOutList.Count - 1 do
      ComposeClinicalImpressionRuledOut(this, 'ClinicalImpression', 'ruledOut', elem.ruledOutList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('prognosis') then
    ComposeString(this, 'ClinicalImpression', 'prognosis', elem.prognosisElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('plan') then
    for i := 0 to elem.planList.Count - 1 do
      ComposeReference{Resource}(this, 'ClinicalImpression', 'plan', elem.planList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('action') then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeReference{Resource}(this, 'ClinicalImpression', 'action', elem.actionList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
function TFHIRTurtleParser.ParseCommunicationPayload(obj : TTurtleComplex) : TFhirCommunicationPayload;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCommunicationPayload.create;
  try
    ParseCommunicationPayloadProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCommunicationPayloadProperties(obj : TTurtleComplex; result : TFhirCommunicationPayload);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Communication.payload.contentAttachment', item) then
      result.content := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Communication.payload.contentReference', item) {a3} then
      result.content := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Communication.payload.contentString', item) then
      result.content := parseString(item);
end;

procedure TFHIRTurtleComposer.ComposeCommunicationPayload(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationPayload; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CommunicationPayload'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Communication.payload', 'contentAttachment', TFhirAttachment(elem.content), false, -1){x.d9}
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'Communication.payload', 'contentReference', TFhirReference(elem.content), false,-1){x.d8}
  else if (elem.content is TFhirString) {6} then
    ComposeString(this, 'Communication.payload', 'contentString', TFhirString(elem.content), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseCommunication(obj : TTurtleComplex) : TFhirCommunication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCommunication.create;
  try
    ParseCommunicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCommunicationProperties(obj : TTurtleComplex; result : TFhirCommunication);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Communication.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Communication.category'));{q3b}
    result.sender := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Communication.sender'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Communication.recipient') do
      result.recipientList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.payload') do
      result.payloadList.Add(parseCommunicationPayload(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.medium') do
      result.mediumList.Add(parseCodeableConcept(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Communication.status'), CODES_TFhirCommunicationStatusEnum, SYSTEMS_TFhirCommunicationStatusEnum);
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Communication.encounter'));{q3b}
    result.sentElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Communication.sent'));{q1}
    result.receivedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Communication.received'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Communication.reason') do
      result.reasonList.Add(parseCodeableConcept(item));
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Communication.subject'));{q3b}
    result.requestDetail := ParseReference{TFhirCommunicationRequest}(obj.complex('http://hl7.org/fhir/Communication.requestDetail'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCommunication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Communication'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Communication', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'Communication', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sender') then
    ComposeReference{Resource}(this, 'Communication', 'sender', elem.senderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(this, 'Communication', 'recipient', elem.recipientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payload') then
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationPayload(this, 'Communication', 'payload', elem.payloadList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('medium') then
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(this, 'Communication', 'medium', elem.mediumList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Communication', 'status', elem.StatusElement, CODES_TFhirCommunicationStatusEnum, SYSTEMS_TFhirCommunicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Communication', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sent') then
    ComposeDateTime(this, 'Communication', 'sent', elem.sentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('received') then
    ComposeDateTime(this, 'Communication', 'received', elem.receivedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Communication', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'Communication', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestDetail') then
    ComposeReference{TFhirCommunicationRequest}(this, 'Communication', 'requestDetail', elem.requestDetailElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
function TFHIRTurtleParser.ParseCommunicationRequestPayload(obj : TTurtleComplex) : TFhirCommunicationRequestPayload;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCommunicationRequestPayload.create;
  try
    ParseCommunicationRequestPayloadProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCommunicationRequestPayloadProperties(obj : TTurtleComplex; result : TFhirCommunicationRequestPayload);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/CommunicationRequest.payload.contentAttachment', item) then
      result.content := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/CommunicationRequest.payload.contentReference', item) {a3} then
      result.content := ParseReference(item);
    if obj.has('http://hl7.org/fhir/CommunicationRequest.payload.contentString', item) then
      result.content := parseString(item);
end;

procedure TFHIRTurtleComposer.ComposeCommunicationRequestPayload(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationRequestPayload; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CommunicationRequestPayload'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'CommunicationRequest.payload', 'contentAttachment', TFhirAttachment(elem.content), false, -1){x.d9}
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'CommunicationRequest.payload', 'contentReference', TFhirReference(elem.content), false,-1){x.d8}
  else if (elem.content is TFhirString) {6} then
    ComposeString(this, 'CommunicationRequest.payload', 'contentString', TFhirString(elem.content), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseCommunicationRequest(obj : TTurtleComplex) : TFhirCommunicationRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCommunicationRequest.create;
  try
    ParseCommunicationRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCommunicationRequestProperties(obj : TTurtleComplex; result : TFhirCommunicationRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CommunicationRequest.category'));{q3b}
    result.sender := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/CommunicationRequest.sender'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.recipient') do
      result.recipientList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.payload') do
      result.payloadList.Add(parseCommunicationRequestPayload(item));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.medium') do
      result.mediumList.Add(parseCodeableConcept(item));
    result.requester := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/CommunicationRequest.requester'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CommunicationRequest.status'), CODES_TFhirCommunicationRequestStatusEnum, SYSTEMS_TFhirCommunicationRequestStatusEnum);
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/CommunicationRequest.encounter'));{q3b}
    if obj.has('http://hl7.org/fhir/CommunicationRequest.scheduledPeriod', item) then
      result.scheduled := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/CommunicationRequest.scheduledDateTime', item) then
      result.scheduled := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.reason') do
      result.reasonList.Add(parseCodeableConcept(item));
    result.requestedOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CommunicationRequest.requestedOn'));{q1}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/CommunicationRequest.subject'));{q3b}
    result.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CommunicationRequest.priority'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCommunicationRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CommunicationRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CommunicationRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'CommunicationRequest', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sender') then
    ComposeReference{Resource}(this, 'CommunicationRequest', 'sender', elem.senderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(this, 'CommunicationRequest', 'recipient', elem.recipientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payload') then
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationRequestPayload(this, 'CommunicationRequest', 'payload', elem.payloadList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('medium') then
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(this, 'CommunicationRequest', 'medium', elem.mediumList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{Resource}(this, 'CommunicationRequest', 'requester', elem.requesterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'CommunicationRequest', 'status', elem.StatusElement, CODES_TFhirCommunicationRequestStatusEnum, SYSTEMS_TFhirCommunicationRequestStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'CommunicationRequest', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(this, 'CommunicationRequest', 'scheduledPeriod', TFhirPeriod(elem.scheduled), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirDateTime) {6} then
    ComposeDateTime(this, 'CommunicationRequest', 'scheduledDateTime', TFhirDateTime(elem.scheduled), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'CommunicationRequest', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestedOn') then
    ComposeDateTime(this, 'CommunicationRequest', 'requestedOn', elem.requestedOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'CommunicationRequest', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeCodeableConcept(this, 'CommunicationRequest', 'priority', elem.priorityElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
function TFHIRTurtleParser.ParseCompositionAttester(obj : TTurtleComplex) : TFhirCompositionAttester;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompositionAttester.create;
  try
    ParseCompositionAttesterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionAttesterProperties(obj : TTurtleComplex; result : TFhirCompositionAttester);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Composition.attester.mode') do
      result.modeList.Add(parseEnum(item, CODES_TFhirCompositionAttestationModeEnum, SYSTEMS_TFhirCompositionAttestationModeEnum));
    result.timeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Composition.attester.time'));{q1}
    result.party := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Composition.attester.party'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCompositionAttester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionAttester; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompositionAttester'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.modeList.Count - 1 do
      ComposeEnum(this, 'Composition.attester', 'mode', elem.modeList[i], CODES_TFhirCompositionAttestationModeEnum, SYSTEMS_TFhirCompositionAttestationModeEnum, false, i); {x.d1}
  for i := 0 to elem.modeList.Count - 1 do
      ComposeEnum(this, 'Composition.attester', 'mode', elem.modeList[i], CODES_TFhirCompositionAttestationModeEnum, SYSTEMS_TFhirCompositionAttestationModeEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Composition.attester', 'time', elem.timeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Composition.attester', 'party', elem.partyElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCompositionEvent(obj : TTurtleComplex) : TFhirCompositionEvent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompositionEvent.create;
  try
    ParseCompositionEventProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionEventProperties(obj : TTurtleComplex; result : TFhirCompositionEvent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Composition.event.code') do
      result.codeList.Add(parseCodeableConcept(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Composition.event.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Composition.event.detail') do
      result.detailList.Add(parseReference{TFhirReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeCompositionEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionEvent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompositionEvent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'Composition.event', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Composition.event', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Composition.event', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCompositionSection(obj : TTurtleComplex) : TFhirCompositionSection;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompositionSection.create;
  try
    ParseCompositionSectionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionSectionProperties(obj : TTurtleComplex; result : TFhirCompositionSection);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Composition.section.title'));{q1}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.section.code'));{q3b}
    result.text := ParseNarrative(obj.complex('http://hl7.org/fhir/Composition.section.text'));{q3b}
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Composition.section.mode'), CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum);
    result.orderedBy := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.section.orderedBy'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Composition.section.entry') do
      result.entryList.Add(parseReference{TFhirReference}(item));
    result.emptyReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.section.emptyReason'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Composition.section.section') do
      result.sectionList.Add(parseCompositionSection(item));
end;

procedure TFHIRTurtleComposer.ComposeCompositionSection(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionSection; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompositionSection'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Composition.section', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Composition.section', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeNarrative(this, 'Composition.section', 'text', elem.textElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Composition.section', 'mode', elem.ModeElement, CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Composition.section', 'orderedBy', elem.orderedByElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Composition.section', 'entry', elem.entryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Composition.section', 'emptyReason', elem.emptyReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(this, 'Composition.section', 'section', elem.sectionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseComposition(obj : TTurtleComplex) : TFhirComposition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirComposition.create;
  try
    ParseCompositionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionProperties(obj : TTurtleComplex; result : TFhirComposition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Composition.identifier'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Composition.date'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.type'));{q3b}
    result.class_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.class'));{q3b}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Composition.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Composition.status'), CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum);
    result.confidentialityElement := ParseEnum(obj.complex('http://hl7.org/fhir/Composition.confidentiality'), CODES_TFhirV3ConfidentialityEnum, SYSTEMS_TFhirV3ConfidentialityEnum);
    result.subject := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Composition.subject'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Composition.author') do
      result.authorList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/Composition.attester') do
      result.attesterList.Add(parseCompositionAttester(item));
    result.custodian := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Composition.custodian'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Composition.event') do
      result.eventList.Add(parseCompositionEvent(item));
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Composition.encounter'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Composition.section') do
      result.sectionList.Add(parseCompositionSection(item));
end;

procedure TFHIRTurtleComposer.ComposeComposition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirComposition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Composition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'Composition', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeDateTime(this, 'Composition', 'date', elem.dateElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'Composition', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeCodeableConcept(this, 'Composition', 'class', elem.class_Element, false, -1);{x.2f}
  ComposeString(this, 'Composition', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Composition', 'status', elem.StatusElement, CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('confidentiality') then
    ComposeEnum(this, 'Composition', 'confidentiality', elem.ConfidentialityElement, CODES_TFhirV3ConfidentialityEnum, SYSTEMS_TFhirV3ConfidentialityEnum, false, -1);{x.d4}
  ComposeReference{TFhirReference}(this, 'Composition', 'subject', elem.subjectElement, false, -1);{x.2f}
  for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(this, 'Composition', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('attester') then
    for i := 0 to elem.attesterList.Count - 1 do
      ComposeCompositionAttester(this, 'Composition', 'attester', elem.attesterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('custodian') then
    ComposeReference{TFhirOrganization}(this, 'Composition', 'custodian', elem.custodianElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('event') then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCompositionEvent(this, 'Composition', 'event', elem.eventList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Composition', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('section') then
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(this, 'Composition', 'section', elem.sectionList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
function TFHIRTurtleParser.ParseConceptMapContact(obj : TTurtleComplex) : TFhirConceptMapContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapContact.create;
  try
    ParseConceptMapContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapContactProperties(obj : TTurtleComplex; result : TFhirConceptMapContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.contact.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.contact.telecom') do
      result.telecomList.Add(parseContactPoint(item));
end;

procedure TFHIRTurtleComposer.ComposeConceptMapContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapContact'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConceptMap.contact', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'ConceptMap.contact', 'telecom', elem.telecomList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseConceptMapElement(obj : TTurtleComplex) : TFhirConceptMapElement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapElement.create;
  try
    ParseConceptMapElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapElementProperties(obj : TTurtleComplex; result : TFhirConceptMapElement);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeSystemElement := ParseUri(obj.complex('http://hl7.org/fhir/ConceptMap.element.codeSystem'));{q1}
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ConceptMap.element.code'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.element.target') do
      result.targetList.Add(parseConceptMapElementTarget(item));
end;

procedure TFHIRTurtleComposer.ComposeConceptMapElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapElement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapElement'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ConceptMap.element', 'codeSystem', elem.codeSystemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ConceptMap.element', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.targetList.Count - 1 do
      ComposeConceptMapElementTarget(this, 'ConceptMap.element', 'target', elem.targetList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseConceptMapElementTarget(obj : TTurtleComplex) : TFhirConceptMapElementTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapElementTarget.create;
  try
    ParseConceptMapElementTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapElementTargetProperties(obj : TTurtleComplex; result : TFhirConceptMapElementTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeSystemElement := ParseUri(obj.complex('http://hl7.org/fhir/ConceptMap.element.target.codeSystem'));{q1}
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ConceptMap.element.target.code'));{q1}
    result.equivalenceElement := ParseEnum(obj.complex('http://hl7.org/fhir/ConceptMap.element.target.equivalence'), CODES_TFhirConceptMapEquivalenceEnum, SYSTEMS_TFhirConceptMapEquivalenceEnum);
    result.commentsElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.element.target.comments'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.element.target.dependsOn') do
      result.dependsOnList.Add(parseConceptMapElementTargetDependsOn(item));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.element.target.product') do
      result.productList.Add(parseConceptMapElementTargetDependsOn(item));
end;

procedure TFHIRTurtleComposer.ComposeConceptMapElementTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapElementTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapElementTarget'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ConceptMap.element.target', 'codeSystem', elem.codeSystemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ConceptMap.element.target', 'code', elem.codeElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ConceptMap.element.target', 'equivalence', elem.EquivalenceElement, CODES_TFhirConceptMapEquivalenceEnum, SYSTEMS_TFhirConceptMapEquivalenceEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.element.target', 'comments', elem.commentsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dependsOnList.Count - 1 do
      ComposeConceptMapElementTargetDependsOn(this, 'ConceptMap.element.target', 'dependsOn', elem.dependsOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.productList.Count - 1 do
      ComposeConceptMapElementTargetDependsOn(this, 'ConceptMap.element.target', 'product', elem.productList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseConceptMapElementTargetDependsOn(obj : TTurtleComplex) : TFhirConceptMapElementTargetDependsOn;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapElementTargetDependsOn.create;
  try
    ParseConceptMapElementTargetDependsOnProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapElementTargetDependsOnProperties(obj : TTurtleComplex; result : TFhirConceptMapElementTargetDependsOn);
begin
    ParseBackboneElementProperties(obj, result);
    result.elementElement := ParseUri(obj.complex('http://hl7.org/fhir/ConceptMap.element.target.dependsOn.element'));{q1}
    result.codeSystemElement := ParseUri(obj.complex('http://hl7.org/fhir/ConceptMap.element.target.dependsOn.codeSystem'));{q1}
    result.codeElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.element.target.dependsOn.code'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeConceptMapElementTargetDependsOn(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapElementTargetDependsOn; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapElementTargetDependsOn'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeUri(this, 'ConceptMap.element.target.dependsOn', 'element', elem.elementElement, false, -1);{x.2ea}
  ComposeUri(this, 'ConceptMap.element.target.dependsOn', 'codeSystem', elem.codeSystemElement, false, -1);{x.2ea}
  ComposeString(this, 'ConceptMap.element.target.dependsOn', 'code', elem.codeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseConceptMap(obj : TTurtleComplex) : TFhirConceptMap;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMap.create;
  try
    ParseConceptMapProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapProperties(obj : TTurtleComplex; result : TFhirConceptMap);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ConceptMap.url'));{q1}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/ConceptMap.identifier'));{q3b}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ConceptMap.status'), CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ConceptMap.experimental'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.contact') do
      result.contactList.Add(parseConceptMapContact(item));
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ConceptMap.date'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.useContext') do
      result.useContextList.Add(parseCodeableConcept(item));
    result.requirementsElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.requirements'));{q1}
    result.copyrightElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.copyright'));{q1}
    if obj.has('http://hl7.org/fhir/ConceptMap.sourceReference', item) {a3} then
      result.source := ParseReference(item);
    if obj.has('http://hl7.org/fhir/ConceptMap.sourceUri', item) then
      result.source := parseUri(item);
    if obj.has('http://hl7.org/fhir/ConceptMap.targetReference', item) {a3} then
      result.target := ParseReference(item);
    if obj.has('http://hl7.org/fhir/ConceptMap.targetUri', item) then
      result.target := parseUri(item);
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.element') do
      result.elementList.Add(parseConceptMapElement(item));
end;

procedure TFHIRTurtleComposer.ComposeConceptMap(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMap; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMap'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'ConceptMap', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'ConceptMap', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'ConceptMap', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'ConceptMap', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ConceptMap', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'ConceptMap', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'ConceptMap', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeConceptMapContact(this, 'ConceptMap', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ConceptMap', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'ConceptMap', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(this, 'ConceptMap', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeString(this, 'ConceptMap', 'requirements', elem.requirementsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeString(this, 'ConceptMap', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (elem.source is TFhirReference) {2} then
    ComposeReference(this, 'ConceptMap', 'sourceReference', TFhirReference(elem.source), false,-1){x.d8}
  else if (elem.source is TFhirUri) {6} then
    ComposeUri(this, 'ConceptMap', 'sourceUri', TFhirUri(elem.source), false, -1);{x.d9}
  if (elem.target is TFhirReference) {2} then
    ComposeReference(this, 'ConceptMap', 'targetReference', TFhirReference(elem.target), false,-1){x.d8}
  else if (elem.target is TFhirUri) {6} then
    ComposeUri(this, 'ConceptMap', 'targetUri', TFhirUri(elem.target), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('element') then
    for i := 0 to elem.elementList.Count - 1 do
      ComposeConceptMapElement(this, 'ConceptMap', 'element', elem.elementList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
function TFHIRTurtleParser.ParseConditionStage(obj : TTurtleComplex) : TFhirConditionStage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConditionStage.create;
  try
    ParseConditionStageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionStageProperties(obj : TTurtleComplex; result : TFhirConditionStage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.summary := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.stage.summary'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Condition.stage.assessment') do
      result.assessmentList.Add(parseReference{Resource}(item));
end;

procedure TFHIRTurtleComposer.ComposeConditionStage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConditionStage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConditionStage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Condition.stage', 'summary', elem.summaryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.assessmentList.Count - 1 do
      ComposeReference{Resource}(this, 'Condition.stage', 'assessment', elem.assessmentList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseConditionEvidence(obj : TTurtleComplex) : TFhirConditionEvidence;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConditionEvidence.create;
  try
    ParseConditionEvidenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionEvidenceProperties(obj : TTurtleComplex; result : TFhirConditionEvidence);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.evidence.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Condition.evidence.detail') do
      result.detailList.Add(parseReference{TFhirReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeConditionEvidence(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConditionEvidence; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConditionEvidence'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Condition.evidence', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Condition.evidence', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCondition(obj : TTurtleComplex) : TFhirCondition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCondition.create;
  try
    ParseConditionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionProperties(obj : TTurtleComplex; result : TFhirCondition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Condition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Condition.patient'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Condition.encounter'));{q3b}
    result.asserter := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Condition.asserter'));{q3b}
    result.dateRecordedElement := ParseDate(obj.complex('http://hl7.org/fhir/Condition.dateRecorded'));{q1}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.code'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.category'));{q3b}
    result.clinicalStatusElement := ParseCode(obj.complex('http://hl7.org/fhir/Condition.clinicalStatus'));{q1}
    result.verificationStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Condition.verificationStatus'), CODES_TFhirConditionVerStatusEnum, SYSTEMS_TFhirConditionVerStatusEnum);
    result.severity := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.severity'));{q3b}
    if obj.has('http://hl7.org/fhir/Condition.onsetQuantity', item) then
      result.onset := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Condition.onsetPeriod', item) then
      result.onset := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Condition.onsetRange', item) then
      result.onset := parseRange(item);
    if obj.has('http://hl7.org/fhir/Condition.onsetDateTime', item) then
      result.onset := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Condition.onsetString', item) then
      result.onset := parseString(item);
    if obj.has('http://hl7.org/fhir/Condition.abatementQuantity', item) then
      result.abatement := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Condition.abatementPeriod', item) then
      result.abatement := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Condition.abatementRange', item) then
      result.abatement := parseRange(item);
    if obj.has('http://hl7.org/fhir/Condition.abatementDateTime', item) then
      result.abatement := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Condition.abatementBoolean', item) then
      result.abatement := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Condition.abatementString', item) then
      result.abatement := parseString(item);
    result.stage := ParseConditionStage(obj.complex('http://hl7.org/fhir/Condition.stage'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Condition.evidence') do
      result.evidenceList.Add(parseConditionEvidence(item));
    for item in obj.complexes('http://hl7.org/fhir/Condition.bodySite') do
      result.bodySiteList.Add(parseCodeableConcept(item));
    result.notesElement := ParseString(obj.complex('http://hl7.org/fhir/Condition.notes'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCondition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Condition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Condition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'Condition', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Condition', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('asserter') then
    ComposeReference{Resource}(this, 'Condition', 'asserter', elem.asserterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateRecorded') then
    ComposeDate(this, 'Condition', 'dateRecorded', elem.dateRecordedElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'Condition', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'Condition', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalStatus') then
    ComposeCode(this, 'Condition', 'clinicalStatus', elem.clinicalStatusElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Condition', 'verificationStatus', elem.VerificationStatusElement, CODES_TFhirConditionVerStatusEnum, SYSTEMS_TFhirConditionVerStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('severity') then
    ComposeCodeableConcept(this, 'Condition', 'severity', elem.severityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Condition', 'onsetQuantity', TFhirQuantity(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(this, 'Condition', 'onsetPeriod', TFhirPeriod(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirRange) {6} then
    ComposeRange(this, 'Condition', 'onsetRange', TFhirRange(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Condition', 'onsetDateTime', TFhirDateTime(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirString) {6} then
    ComposeString(this, 'Condition', 'onsetString', TFhirString(elem.onset), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Condition', 'abatementQuantity', TFhirQuantity(elem.abatement), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirPeriod) {6} then
    ComposePeriod(this, 'Condition', 'abatementPeriod', TFhirPeriod(elem.abatement), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirRange) {6} then
    ComposeRange(this, 'Condition', 'abatementRange', TFhirRange(elem.abatement), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Condition', 'abatementDateTime', TFhirDateTime(elem.abatement), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Condition', 'abatementBoolean', TFhirBoolean(elem.abatement), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirString) {6} then
    ComposeString(this, 'Condition', 'abatementString', TFhirString(elem.abatement), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('stage') then
    ComposeConditionStage(this, 'Condition', 'stage', elem.stageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('evidence') then
    for i := 0 to elem.evidenceList.Count - 1 do
      ComposeConditionEvidence(this, 'Condition', 'evidence', elem.evidenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'Condition', 'bodySite', elem.bodySiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notes') then
    ComposeString(this, 'Condition', 'notes', elem.notesElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
function TFHIRTurtleParser.ParseConformanceContact(obj : TTurtleComplex) : TFhirConformanceContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConformanceContact.create;
  try
    ParseConformanceContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConformanceContactProperties(obj : TTurtleComplex; result : TFhirConformanceContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.contact.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Conformance.contact.telecom') do
      result.telecomList.Add(parseContactPoint(item));
end;

procedure TFHIRTurtleComposer.ComposeConformanceContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConformanceContact'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Conformance.contact', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Conformance.contact', 'telecom', elem.telecomList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseConformanceSoftware(obj : TTurtleComplex) : TFhirConformanceSoftware;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConformanceSoftware.create;
  try
    ParseConformanceSoftwareProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConformanceSoftwareProperties(obj : TTurtleComplex; result : TFhirConformanceSoftware);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.software.name'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.software.version'));{q1}
    result.releaseDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Conformance.software.releaseDate'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeConformanceSoftware(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceSoftware; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConformanceSoftware'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Conformance.software', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Conformance.software', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Conformance.software', 'releaseDate', elem.releaseDateElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseConformanceImplementation(obj : TTurtleComplex) : TFhirConformanceImplementation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConformanceImplementation.create;
  try
    ParseConformanceImplementationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConformanceImplementationProperties(obj : TTurtleComplex; result : TFhirConformanceImplementation);
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.implementation.description'));{q1}
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Conformance.implementation.url'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeConformanceImplementation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceImplementation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConformanceImplementation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Conformance.implementation', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Conformance.implementation', 'url', elem.urlElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseConformanceRest(obj : TTurtleComplex) : TFhirConformanceRest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConformanceRest.create;
  try
    ParseConformanceRestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConformanceRestProperties(obj : TTurtleComplex; result : TFhirConformanceRest);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Conformance.rest.mode'), CODES_TFhirRestfulConformanceModeEnum, SYSTEMS_TFhirRestfulConformanceModeEnum);
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.rest.documentation'));{q1}
    result.security := ParseConformanceRestSecurity(obj.complex('http://hl7.org/fhir/Conformance.rest.security'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Conformance.rest.resource') do
      result.resourceList.Add(parseConformanceRestResource(item));
    for item in obj.complexes('http://hl7.org/fhir/Conformance.rest.interaction') do
      result.interactionList.Add(parseConformanceRestInteraction(item));
    result.transactionModeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Conformance.rest.transactionMode'), CODES_TFhirTransactionModeEnum, SYSTEMS_TFhirTransactionModeEnum);
    for item in obj.complexes('http://hl7.org/fhir/Conformance.rest.searchParam') do
      result.searchParamList.Add(parseConformanceRestResourceSearchParam(item));
    for item in obj.complexes('http://hl7.org/fhir/Conformance.rest.operation') do
      result.operationList.Add(parseConformanceRestOperation(item));
    for item in obj.complexes('http://hl7.org/fhir/Conformance.rest.compartment') do
      result.compartmentList.Add(parseUri(item));
end;

procedure TFHIRTurtleComposer.ComposeConformanceRest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceRest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConformanceRest'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Conformance.rest', 'mode', elem.ModeElement, CODES_TFhirRestfulConformanceModeEnum, SYSTEMS_TFhirRestfulConformanceModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Conformance.rest', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeConformanceRestSecurity(this, 'Conformance.rest', 'security', elem.securityElement, false, -1);{x.2f}
  for i := 0 to elem.resourceList.Count - 1 do
      ComposeConformanceRestResource(this, 'Conformance.rest', 'resource', elem.resourceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeConformanceRestInteraction(this, 'Conformance.rest', 'interaction', elem.interactionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.transactionModeElement <> nil) and (elem.transactionModeElement.primitiveValue <> 'not-supported')) then
    ComposeEnum(this, 'Conformance.rest', 'transactionMode', elem.TransactionModeElement, CODES_TFhirTransactionModeEnum, SYSTEMS_TFhirTransactionModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeConformanceRestResourceSearchParam(this, 'Conformance.rest', 'searchParam', elem.searchParamList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.operationList.Count - 1 do
      ComposeConformanceRestOperation(this, 'Conformance.rest', 'operation', elem.operationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.compartmentList.Count - 1 do
      ComposeUri(this, 'Conformance.rest', 'compartment', elem.compartmentList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseConformanceRestSecurity(obj : TTurtleComplex) : TFhirConformanceRestSecurity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConformanceRestSecurity.create;
  try
    ParseConformanceRestSecurityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConformanceRestSecurityProperties(obj : TTurtleComplex; result : TFhirConformanceRestSecurity);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.corsElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Conformance.rest.security.cors'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Conformance.rest.security.service') do
      result.serviceList.Add(parseCodeableConcept(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.rest.security.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Conformance.rest.security.certificate') do
      result.certificateList.Add(parseConformanceRestSecurityCertificate(item));
end;

procedure TFHIRTurtleComposer.ComposeConformanceRestSecurity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceRestSecurity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConformanceRestSecurity'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Conformance.rest.security', 'cors', elem.corsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.serviceList.Count - 1 do
      ComposeCodeableConcept(this, 'Conformance.rest.security', 'service', elem.serviceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Conformance.rest.security', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.certificateList.Count - 1 do
      ComposeConformanceRestSecurityCertificate(this, 'Conformance.rest.security', 'certificate', elem.certificateList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseConformanceRestSecurityCertificate(obj : TTurtleComplex) : TFhirConformanceRestSecurityCertificate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    ParseConformanceRestSecurityCertificateProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConformanceRestSecurityCertificateProperties(obj : TTurtleComplex; result : TFhirConformanceRestSecurityCertificate);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseCode(obj.complex('http://hl7.org/fhir/Conformance.rest.security.certificate.type'));{q1}
    result.blobElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Conformance.rest.security.certificate.blob'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeConformanceRestSecurityCertificate(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceRestSecurityCertificate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConformanceRestSecurityCertificate'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'Conformance.rest.security.certificate', 'type', elem.type_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64Binary(this, 'Conformance.rest.security.certificate', 'blob', elem.blobElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseConformanceRestResource(obj : TTurtleComplex) : TFhirConformanceRestResource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConformanceRestResource.create;
  try
    ParseConformanceRestResourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConformanceRestResourceProperties(obj : TTurtleComplex; result : TFhirConformanceRestResource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Conformance.rest.resource.type'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.profile := ParseReference{TFhirStructureDefinition}(obj.complex('http://hl7.org/fhir/Conformance.rest.resource.profile'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Conformance.rest.resource.interaction') do
      result.interactionList.Add(parseConformanceRestResourceInteraction(item));
    result.versioningElement := ParseEnum(obj.complex('http://hl7.org/fhir/Conformance.rest.resource.versioning'), CODES_TFhirVersioningPolicyEnum, SYSTEMS_TFhirVersioningPolicyEnum);
    result.readHistoryElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Conformance.rest.resource.readHistory'));{q1}
    result.updateCreateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Conformance.rest.resource.updateCreate'));{q1}
    result.conditionalCreateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Conformance.rest.resource.conditionalCreate'));{q1}
    result.conditionalUpdateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Conformance.rest.resource.conditionalUpdate'));{q1}
    result.conditionalDeleteElement := ParseEnum(obj.complex('http://hl7.org/fhir/Conformance.rest.resource.conditionalDelete'), CODES_TFhirConditionalDeleteStatusEnum, SYSTEMS_TFhirConditionalDeleteStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Conformance.rest.resource.searchInclude') do
      result.searchIncludeList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/Conformance.rest.resource.searchRevInclude') do
      result.searchRevIncludeList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/Conformance.rest.resource.searchParam') do
      result.searchParamList.Add(parseConformanceRestResourceSearchParam(item));
end;

procedure TFHIRTurtleComposer.ComposeConformanceRestResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceRestResource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConformanceRestResource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Conformance.rest.resource', 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(this, 'Conformance.rest.resource', 'profile', elem.profileElement, false, -1);{x.2f}
  for i := 0 to elem.interactionList.Count - 1 do
      ComposeConformanceRestResourceInteraction(this, 'Conformance.rest.resource', 'interaction', elem.interactionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Conformance.rest.resource', 'versioning', elem.VersioningElement, CODES_TFhirVersioningPolicyEnum, SYSTEMS_TFhirVersioningPolicyEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Conformance.rest.resource', 'readHistory', elem.readHistoryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Conformance.rest.resource', 'updateCreate', elem.updateCreateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Conformance.rest.resource', 'conditionalCreate', elem.conditionalCreateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Conformance.rest.resource', 'conditionalUpdate', elem.conditionalUpdateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Conformance.rest.resource', 'conditionalDelete', elem.ConditionalDeleteElement, CODES_TFhirConditionalDeleteStatusEnum, SYSTEMS_TFhirConditionalDeleteStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchIncludeList.Count - 1 do
      ComposeString(this, 'Conformance.rest.resource', 'searchInclude', elem.searchIncludeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchRevIncludeList.Count - 1 do
      ComposeString(this, 'Conformance.rest.resource', 'searchRevInclude', elem.searchRevIncludeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeConformanceRestResourceSearchParam(this, 'Conformance.rest.resource', 'searchParam', elem.searchParamList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseConformanceRestResourceInteraction(obj : TTurtleComplex) : TFhirConformanceRestResourceInteraction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConformanceRestResourceInteraction.create;
  try
    ParseConformanceRestResourceInteractionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConformanceRestResourceInteractionProperties(obj : TTurtleComplex; result : TFhirConformanceRestResourceInteraction);
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Conformance.rest.resource.interaction.code'), CODES_TFhirTypeRestfulInteractionEnum, SYSTEMS_TFhirTypeRestfulInteractionEnum);
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.rest.resource.interaction.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeConformanceRestResourceInteraction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceRestResourceInteraction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConformanceRestResourceInteraction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Conformance.rest.resource.interaction', 'code', elem.CodeElement, CODES_TFhirTypeRestfulInteractionEnum, SYSTEMS_TFhirTypeRestfulInteractionEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Conformance.rest.resource.interaction', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseConformanceRestResourceSearchParam(obj : TTurtleComplex) : TFhirConformanceRestResourceSearchParam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    ParseConformanceRestResourceSearchParamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConformanceRestResourceSearchParamProperties(obj : TTurtleComplex; result : TFhirConformanceRestResourceSearchParam);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.rest.resource.searchParam.name'));{q1}
    result.definitionElement := ParseUri(obj.complex('http://hl7.org/fhir/Conformance.rest.resource.searchParam.definition'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Conformance.rest.resource.searchParam.type'), CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.rest.resource.searchParam.documentation'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Conformance.rest.resource.searchParam.target') do
      result.target.Add(parseEnum(item, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum));
    for item in obj.complexes('http://hl7.org/fhir/Conformance.rest.resource.searchParam.modifier') do
      result.modifierList.Add(parseEnum(item, CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum));
    for item in obj.complexes('http://hl7.org/fhir/Conformance.rest.resource.searchParam.chain') do
      result.chainList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeConformanceRestResourceSearchParam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceRestResourceSearchParam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConformanceRestResourceSearchParam'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Conformance.rest.resource.searchParam', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Conformance.rest.resource.searchParam', 'definition', elem.definitionElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Conformance.rest.resource.searchParam', 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Conformance.rest.resource.searchParam', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.target.Count - 1 do
      ComposeEnum(this, 'Conformance.rest.resource.searchParam', 'target', elem.target[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.target.Count - 1 do
      ComposeEnum(this, 'Conformance.rest.resource.searchParam', 'target', elem.target[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeEnum(this, 'Conformance.rest.resource.searchParam', 'modifier', elem.modifierList[i], CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeEnum(this, 'Conformance.rest.resource.searchParam', 'modifier', elem.modifierList[i], CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.chainList.Count - 1 do
      ComposeString(this, 'Conformance.rest.resource.searchParam', 'chain', elem.chainList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseConformanceRestInteraction(obj : TTurtleComplex) : TFhirConformanceRestInteraction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConformanceRestInteraction.create;
  try
    ParseConformanceRestInteractionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConformanceRestInteractionProperties(obj : TTurtleComplex; result : TFhirConformanceRestInteraction);
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Conformance.rest.interaction.code'), CODES_TFhirSystemRestfulInteractionEnum, SYSTEMS_TFhirSystemRestfulInteractionEnum);
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.rest.interaction.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeConformanceRestInteraction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceRestInteraction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConformanceRestInteraction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Conformance.rest.interaction', 'code', elem.CodeElement, CODES_TFhirSystemRestfulInteractionEnum, SYSTEMS_TFhirSystemRestfulInteractionEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Conformance.rest.interaction', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseConformanceRestOperation(obj : TTurtleComplex) : TFhirConformanceRestOperation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConformanceRestOperation.create;
  try
    ParseConformanceRestOperationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConformanceRestOperationProperties(obj : TTurtleComplex; result : TFhirConformanceRestOperation);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.rest.operation.name'));{q1}
    result.definition := ParseReference{TFhirOperationDefinition}(obj.complex('http://hl7.org/fhir/Conformance.rest.operation.definition'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeConformanceRestOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceRestOperation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConformanceRestOperation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Conformance.rest.operation', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeReference{TFhirOperationDefinition}(this, 'Conformance.rest.operation', 'definition', elem.definitionElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseConformanceMessaging(obj : TTurtleComplex) : TFhirConformanceMessaging;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConformanceMessaging.create;
  try
    ParseConformanceMessagingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConformanceMessagingProperties(obj : TTurtleComplex; result : TFhirConformanceMessaging);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Conformance.messaging.endpoint') do
      result.endpointList.Add(parseConformanceMessagingEndpoint(item));
    result.reliableCacheElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Conformance.messaging.reliableCache'));{q1}
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.messaging.documentation'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Conformance.messaging.event') do
      result.eventList.Add(parseConformanceMessagingEvent(item));
end;

procedure TFHIRTurtleComposer.ComposeConformanceMessaging(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceMessaging; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConformanceMessaging'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeConformanceMessagingEndpoint(this, 'Conformance.messaging', 'endpoint', elem.endpointList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'Conformance.messaging', 'reliableCache', elem.reliableCacheElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Conformance.messaging', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  for i := 0 to elem.eventList.Count - 1 do
      ComposeConformanceMessagingEvent(this, 'Conformance.messaging', 'event', elem.eventList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseConformanceMessagingEndpoint(obj : TTurtleComplex) : TFhirConformanceMessagingEndpoint;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConformanceMessagingEndpoint.create;
  try
    ParseConformanceMessagingEndpointProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConformanceMessagingEndpointProperties(obj : TTurtleComplex; result : TFhirConformanceMessagingEndpoint);
begin
    ParseBackboneElementProperties(obj, result);
    result.protocol := ParseCoding(obj.complex('http://hl7.org/fhir/Conformance.messaging.endpoint.protocol'));{q3b}
    result.addressElement := ParseUri(obj.complex('http://hl7.org/fhir/Conformance.messaging.endpoint.address'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeConformanceMessagingEndpoint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceMessagingEndpoint; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConformanceMessagingEndpoint'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'Conformance.messaging.endpoint', 'protocol', elem.protocolElement, false, -1);{x.2f}
  ComposeUri(this, 'Conformance.messaging.endpoint', 'address', elem.addressElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseConformanceMessagingEvent(obj : TTurtleComplex) : TFhirConformanceMessagingEvent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConformanceMessagingEvent.create;
  try
    ParseConformanceMessagingEventProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConformanceMessagingEventProperties(obj : TTurtleComplex; result : TFhirConformanceMessagingEvent);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCoding(obj.complex('http://hl7.org/fhir/Conformance.messaging.event.code'));{q3b}
    result.categoryElement := ParseEnum(obj.complex('http://hl7.org/fhir/Conformance.messaging.event.category'), CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Conformance.messaging.event.mode'), CODES_TFhirMessageConformanceEventModeEnum, SYSTEMS_TFhirMessageConformanceEventModeEnum);
    result.focusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Conformance.messaging.event.focus'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.request := ParseReference{TFhirStructureDefinition}(obj.complex('http://hl7.org/fhir/Conformance.messaging.event.request'));{q3b}
    result.response := ParseReference{TFhirStructureDefinition}(obj.complex('http://hl7.org/fhir/Conformance.messaging.event.response'));{q3b}
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.messaging.event.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeConformanceMessagingEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceMessagingEvent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConformanceMessagingEvent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'Conformance.messaging.event', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Conformance.messaging.event', 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum, false, -1);{x.d4}
  ComposeEnum(this, 'Conformance.messaging.event', 'mode', elem.ModeElement, CODES_TFhirMessageConformanceEventModeEnum, SYSTEMS_TFhirMessageConformanceEventModeEnum, false, -1);{x.d4}
  ComposeEnum(this, 'Conformance.messaging.event', 'focus', elem.FocusElement, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  ComposeReference{TFhirStructureDefinition}(this, 'Conformance.messaging.event', 'request', elem.requestElement, false, -1);{x.2f}
  ComposeReference{TFhirStructureDefinition}(this, 'Conformance.messaging.event', 'response', elem.responseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Conformance.messaging.event', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseConformanceDocument(obj : TTurtleComplex) : TFhirConformanceDocument;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConformanceDocument.create;
  try
    ParseConformanceDocumentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConformanceDocumentProperties(obj : TTurtleComplex; result : TFhirConformanceDocument);
begin
    ParseBackboneElementProperties(obj, result);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Conformance.document.mode'), CODES_TFhirDocumentModeEnum, SYSTEMS_TFhirDocumentModeEnum);
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.document.documentation'));{q1}
    result.profile := ParseReference{TFhirStructureDefinition}(obj.complex('http://hl7.org/fhir/Conformance.document.profile'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeConformanceDocument(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformanceDocument; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConformanceDocument'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Conformance.document', 'mode', elem.ModeElement, CODES_TFhirDocumentModeEnum, SYSTEMS_TFhirDocumentModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Conformance.document', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  ComposeReference{TFhirStructureDefinition}(this, 'Conformance.document', 'profile', elem.profileElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseConformance(obj : TTurtleComplex) : TFhirConformance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConformance.create;
  try
    ParseConformanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConformanceProperties(obj : TTurtleComplex; result : TFhirConformance);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Conformance.url'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Conformance.status'), CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Conformance.experimental'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Conformance.contact') do
      result.contactList.Add(parseConformanceContact(item));
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Conformance.date'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.description'));{q1}
    result.requirementsElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.requirements'));{q1}
    result.copyrightElement := ParseString(obj.complex('http://hl7.org/fhir/Conformance.copyright'));{q1}
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/Conformance.kind'), CODES_TFhirConformanceStatementKindEnum, SYSTEMS_TFhirConformanceStatementKindEnum);
    result.software := ParseConformanceSoftware(obj.complex('http://hl7.org/fhir/Conformance.software'));{q3b}
    result.implementation_ := ParseConformanceImplementation(obj.complex('http://hl7.org/fhir/Conformance.implementation'));{q3b}
    result.fhirVersionElement := ParseId(obj.complex('http://hl7.org/fhir/Conformance.fhirVersion'));{q1}
    result.acceptUnknownElement := ParseEnum(obj.complex('http://hl7.org/fhir/Conformance.acceptUnknown'), CODES_TFhirUnknownContentCodeEnum, SYSTEMS_TFhirUnknownContentCodeEnum);
    for item in obj.complexes('http://hl7.org/fhir/Conformance.format') do
      result.formatList.Add(parseCode(item));
    for item in obj.complexes('http://hl7.org/fhir/Conformance.profile') do
      result.profileList.Add(parseReference{TFhirStructureDefinition}(item));
    for item in obj.complexes('http://hl7.org/fhir/Conformance.rest') do
      result.restList.Add(parseConformanceRest(item));
    for item in obj.complexes('http://hl7.org/fhir/Conformance.messaging') do
      result.messagingList.Add(parseConformanceMessaging(item));
    for item in obj.complexes('http://hl7.org/fhir/Conformance.document') do
      result.documentList.Add(parseConformanceDocument(item));
end;

procedure TFHIRTurtleComposer.ComposeConformance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConformance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Conformance'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'Conformance', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'Conformance', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Conformance', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Conformance', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'Conformance', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'Conformance', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeConformanceContact(this, 'Conformance', 'contact', elem.contactList[i], false, i);{x.d3}
  ComposeDateTime(this, 'Conformance', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'Conformance', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeString(this, 'Conformance', 'requirements', elem.requirementsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeString(this, 'Conformance', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Conformance', 'kind', elem.KindElement, CODES_TFhirConformanceStatementKindEnum, SYSTEMS_TFhirConformanceStatementKindEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('software') then
    ComposeConformanceSoftware(this, 'Conformance', 'software', elem.softwareElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implementation_') then
    ComposeConformanceImplementation(this, 'Conformance', 'implementation', elem.implementation_Element, false, -1);{x.2f}
  ComposeId(this, 'Conformance', 'fhirVersion', elem.fhirVersionElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Conformance', 'acceptUnknown', elem.AcceptUnknownElement, CODES_TFhirUnknownContentCodeEnum, SYSTEMS_TFhirUnknownContentCodeEnum, false, -1);{x.d4}
  for i := 0 to elem.formatList.Count - 1 do
      ComposeCode(this, 'Conformance', 'format', elem.formatList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('profile') then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirStructureDefinition}(this, 'Conformance', 'profile', elem.profileList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('rest') then
    for i := 0 to elem.restList.Count - 1 do
      ComposeConformanceRest(this, 'Conformance', 'rest', elem.restList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('messaging') then
    for i := 0 to elem.messagingList.Count - 1 do
      ComposeConformanceMessaging(this, 'Conformance', 'messaging', elem.messagingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('document') then
    for i := 0 to elem.documentList.Count - 1 do
      ComposeConformanceDocument(this, 'Conformance', 'document', elem.documentList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
function TFHIRTurtleParser.ParseContractActor(obj : TTurtleComplex) : TFhirContractActor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractActor.create;
  try
    ParseContractActorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractActorProperties(obj : TTurtleComplex; result : TFhirContractActor);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.entity := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Contract.actor.entity'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.actor.role') do
      result.roleList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeContractActor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractActor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractActor'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'Contract.actor', 'entity', elem.entityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.actor', 'role', elem.roleList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseContractValuedItem(obj : TTurtleComplex) : TFhirContractValuedItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractValuedItem.create;
  try
    ParseContractValuedItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractValuedItemProperties(obj : TTurtleComplex; result : TFhirContractValuedItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Contract.valuedItem.entityCodeableConcept', item) then
      result.entity := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Contract.valuedItem.entityReference', item) {a3} then
      result.entity := ParseReference(item);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Contract.valuedItem.identifier'));{q3b}
    result.effectiveTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.valuedItem.effectiveTime'));{q1}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Contract.valuedItem.quantity'));{q3b}
    result.unitPrice := ParseQuantity(obj.complex('http://hl7.org/fhir/Contract.valuedItem.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Contract.valuedItem.factor'));{q1}
    result.pointsElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Contract.valuedItem.points'));{q1}
    result.net := ParseQuantity(obj.complex('http://hl7.org/fhir/Contract.valuedItem.net'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeContractValuedItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractValuedItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractValuedItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Contract.valuedItem', 'entityCodeableConcept', TFhirCodeableConcept(elem.entity), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) {2} then
    ComposeReference(this, 'Contract.valuedItem', 'entityReference', TFhirReference(elem.entity), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Contract.valuedItem', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Contract.valuedItem', 'effectiveTime', elem.effectiveTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Contract.valuedItem', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Contract.valuedItem', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Contract.valuedItem', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Contract.valuedItem', 'points', elem.pointsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Contract.valuedItem', 'net', elem.netElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseContractSigner(obj : TTurtleComplex) : TFhirContractSigner;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractSigner.create;
  try
    ParseContractSignerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractSignerProperties(obj : TTurtleComplex; result : TFhirContractSigner);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/Contract.signer.type'));{q3b}
    result.party := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Contract.signer.party'));{q3b}
    result.signatureElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.signer.signature'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeContractSigner(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractSigner; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractSigner'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'Contract.signer', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeReference{Resource}(this, 'Contract.signer', 'party', elem.partyElement, false, -1);{x.2f}
  ComposeString(this, 'Contract.signer', 'signature', elem.signatureElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseContractTerm(obj : TTurtleComplex) : TFhirContractTerm;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTerm.create;
  try
    ParseContractTermProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermProperties(obj : TTurtleComplex; result : TFhirContractTerm);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Contract.term.identifier'));{q3b}
    result.issuedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.term.issued'));{q1}
    result.applies := ParsePeriod(obj.complex('http://hl7.org/fhir/Contract.term.applies'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.type'));{q3b}
    result.subType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.subType'));{q3b}
    result.subject := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Contract.term.subject'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action') do
      result.actionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.actionReason') do
      result.actionReasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.actor') do
      result.actorList.Add(parseContractTermActor(item));
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.term.text'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.valuedItem') do
      result.valuedItemList.Add(parseContractTermValuedItem(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.group') do
      result.groupList.Add(parseContractTerm(item));
end;

procedure TFHIRTurtleComposer.ComposeContractTerm(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTerm; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTerm'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Contract.term', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Contract.term', 'issued', elem.issuedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Contract.term', 'applies', elem.appliesElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term', 'subType', elem.subTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'Contract.term', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term', 'action', elem.actionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term', 'actionReason', elem.actionReasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actorList.Count - 1 do
      ComposeContractTermActor(this, 'Contract.term', 'actor', elem.actorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Contract.term', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractTermValuedItem(this, 'Contract.term', 'valuedItem', elem.valuedItemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeContractTerm(this, 'Contract.term', 'group', elem.groupList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseContractTermActor(obj : TTurtleComplex) : TFhirContractTermActor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermActor.create;
  try
    ParseContractTermActorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermActorProperties(obj : TTurtleComplex; result : TFhirContractTermActor);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.entity := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Contract.term.actor.entity'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.actor.role') do
      result.roleList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeContractTermActor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermActor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermActor'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'Contract.term.actor', 'entity', elem.entityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term.actor', 'role', elem.roleList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseContractTermValuedItem(obj : TTurtleComplex) : TFhirContractTermValuedItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermValuedItem.create;
  try
    ParseContractTermValuedItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermValuedItemProperties(obj : TTurtleComplex; result : TFhirContractTermValuedItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Contract.term.valuedItem.entityCodeableConcept', item) then
      result.entity := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Contract.term.valuedItem.entityReference', item) {a3} then
      result.entity := ParseReference(item);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Contract.term.valuedItem.identifier'));{q3b}
    result.effectiveTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.term.valuedItem.effectiveTime'));{q1}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Contract.term.valuedItem.quantity'));{q3b}
    result.unitPrice := ParseQuantity(obj.complex('http://hl7.org/fhir/Contract.term.valuedItem.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Contract.term.valuedItem.factor'));{q1}
    result.pointsElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Contract.term.valuedItem.points'));{q1}
    result.net := ParseQuantity(obj.complex('http://hl7.org/fhir/Contract.term.valuedItem.net'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeContractTermValuedItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermValuedItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermValuedItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Contract.term.valuedItem', 'entityCodeableConcept', TFhirCodeableConcept(elem.entity), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) {2} then
    ComposeReference(this, 'Contract.term.valuedItem', 'entityReference', TFhirReference(elem.entity), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Contract.term.valuedItem', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Contract.term.valuedItem', 'effectiveTime', elem.effectiveTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Contract.term.valuedItem', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Contract.term.valuedItem', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Contract.term.valuedItem', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Contract.term.valuedItem', 'points', elem.pointsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Contract.term.valuedItem', 'net', elem.netElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseContractFriendly(obj : TTurtleComplex) : TFhirContractFriendly;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractFriendly.create;
  try
    ParseContractFriendlyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractFriendlyProperties(obj : TTurtleComplex; result : TFhirContractFriendly);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Contract.friendly.contentAttachment', item) then
      result.content := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Contract.friendly.contentReference', item) {a3} then
      result.content := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeContractFriendly(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractFriendly; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractFriendly'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract.friendly', 'contentAttachment', TFhirAttachment(elem.content), false, -1){x.d9}
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'Contract.friendly', 'contentReference', TFhirReference(elem.content), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseContractLegal(obj : TTurtleComplex) : TFhirContractLegal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractLegal.create;
  try
    ParseContractLegalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractLegalProperties(obj : TTurtleComplex; result : TFhirContractLegal);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Contract.legal.contentAttachment', item) then
      result.content := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Contract.legal.contentReference', item) {a3} then
      result.content := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeContractLegal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractLegal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractLegal'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract.legal', 'contentAttachment', TFhirAttachment(elem.content), false, -1){x.d9}
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'Contract.legal', 'contentReference', TFhirReference(elem.content), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseContractRule(obj : TTurtleComplex) : TFhirContractRule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractRule.create;
  try
    ParseContractRuleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractRuleProperties(obj : TTurtleComplex; result : TFhirContractRule);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Contract.rule.contentAttachment', item) then
      result.content := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Contract.rule.contentReference', item) {a3} then
      result.content := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeContractRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractRule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractRule'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract.rule', 'contentAttachment', TFhirAttachment(elem.content), false, -1){x.d9}
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'Contract.rule', 'contentReference', TFhirReference(elem.content), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseContract(obj : TTurtleComplex) : TFhirContract;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContract.create;
  try
    ParseContractProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractProperties(obj : TTurtleComplex; result : TFhirContract);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Contract.identifier'));{q3b}
    result.issuedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.issued'));{q1}
    result.applies := ParsePeriod(obj.complex('http://hl7.org/fhir/Contract.applies'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.subject') do
      result.subjectList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.authority') do
      result.authorityList.Add(parseReference{TFhirOrganization}(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.domain') do
      result.domainList.Add(parseReference{TFhirLocation}(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.subType') do
      result.subTypeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.action') do
      result.actionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.actionReason') do
      result.actionReasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.actor') do
      result.actorList.Add(parseContractActor(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.valuedItem') do
      result.valuedItemList.Add(parseContractValuedItem(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.signer') do
      result.signerList.Add(parseContractSigner(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term') do
      result.termList.Add(parseContractTerm(item));
    if obj.has('http://hl7.org/fhir/Contract.bindingAttachment', item) then
      result.binding := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Contract.bindingReference', item) {a3} then
      result.binding := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/Contract.friendly') do
      result.friendlyList.Add(parseContractFriendly(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.legal') do
      result.legalList.Add(parseContractLegal(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.rule') do
      result.ruleList.Add(parseContractRule(item));
end;

procedure TFHIRTurtleComposer.ComposeContract(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContract; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Contract'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'Contract', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeDateTime(this, 'Contract', 'issued', elem.issuedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('applies') then
    ComposePeriod(this, 'Contract', 'applies', elem.appliesElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Contract', 'subject', elem.subjectList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('authority') then
    for i := 0 to elem.authorityList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'Contract', 'authority', elem.authorityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('domain') then
    for i := 0 to elem.domainList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'Contract', 'domain', elem.domainList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Contract', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subType') then
    for i := 0 to elem.subTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract', 'subType', elem.subTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('action') then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract', 'action', elem.actionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('actionReason') then
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract', 'actionReason', elem.actionReasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('actor') then
    for i := 0 to elem.actorList.Count - 1 do
      ComposeContractActor(this, 'Contract', 'actor', elem.actorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('valuedItem') then
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractValuedItem(this, 'Contract', 'valuedItem', elem.valuedItemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('signer') then
    for i := 0 to elem.signerList.Count - 1 do
      ComposeContractSigner(this, 'Contract', 'signer', elem.signerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('term') then
    for i := 0 to elem.termList.Count - 1 do
      ComposeContractTerm(this, 'Contract', 'term', elem.termList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.binding is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract', 'bindingAttachment', TFhirAttachment(elem.binding), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.binding is TFhirReference) {2} then
    ComposeReference(this, 'Contract', 'bindingReference', TFhirReference(elem.binding), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) and doCompose('friendly') then
    for i := 0 to elem.friendlyList.Count - 1 do
      ComposeContractFriendly(this, 'Contract', 'friendly', elem.friendlyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('legal') then
    for i := 0 to elem.legalList.Count - 1 do
      ComposeContractLegal(this, 'Contract', 'legal', elem.legalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('rule') then
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeContractRule(this, 'Contract', 'rule', elem.ruleList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
function TFHIRTurtleParser.ParseCoverage(obj : TTurtleComplex) : TFhirCoverage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverage.create;
  try
    ParseCoverageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageProperties(obj : TTurtleComplex; result : TFhirCoverage);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.issuer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Coverage.issuer'));{q3b}
    result.bin := ParseIdentifier(obj.complex('http://hl7.org/fhir/Coverage.bin'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Coverage.period'));{q3b}
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/Coverage.type'));{q3b}
    result.subscriberId := ParseIdentifier(obj.complex('http://hl7.org/fhir/Coverage.subscriberId'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Coverage.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.groupElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.group'));{q1}
    result.planElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.plan'));{q1}
    result.subPlanElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.subPlan'));{q1}
    result.dependentElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Coverage.dependent'));{q1}
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Coverage.sequence'));{q1}
    result.subscriber := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Coverage.subscriber'));{q3b}
    result.network := ParseIdentifier(obj.complex('http://hl7.org/fhir/Coverage.network'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Coverage.contract') do
      result.contractList.Add(parseReference{TFhirContract}(item));
end;

procedure TFHIRTurtleComposer.ComposeCoverage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Coverage'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issuer') then
    ComposeReference{TFhirOrganization}(this, 'Coverage', 'issuer', elem.issuerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('bin') then
    ComposeIdentifier(this, 'Coverage', 'bin', elem.binElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'Coverage', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCoding(this, 'Coverage', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subscriberId') then
    ComposeIdentifier(this, 'Coverage', 'subscriberId', elem.subscriberIdElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Coverage', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('group') then
    ComposeString(this, 'Coverage', 'group', elem.groupElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('plan') then
    ComposeString(this, 'Coverage', 'plan', elem.planElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subPlan') then
    ComposeString(this, 'Coverage', 'subPlan', elem.subPlanElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dependent') then
    ComposePositiveInt(this, 'Coverage', 'dependent', elem.dependentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sequence') then
    ComposePositiveInt(this, 'Coverage', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('subscriber') then
    ComposeReference{TFhirPatient}(this, 'Coverage', 'subscriber', elem.subscriberElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('network') then
    ComposeIdentifier(this, 'Coverage', 'network', elem.networkElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('contract') then
    for i := 0 to elem.contractList.Count - 1 do
      ComposeReference{TFhirContract}(this, 'Coverage', 'contract', elem.contractList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
function TFHIRTurtleParser.ParseDataElementContact(obj : TTurtleComplex) : TFhirDataElementContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDataElementContact.create;
  try
    ParseDataElementContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDataElementContactProperties(obj : TTurtleComplex; result : TFhirDataElementContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/DataElement.contact.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DataElement.contact.telecom') do
      result.telecomList.Add(parseContactPoint(item));
end;

procedure TFHIRTurtleComposer.ComposeDataElementContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataElementContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DataElementContact'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DataElement.contact', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'DataElement.contact', 'telecom', elem.telecomList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseDataElementMapping(obj : TTurtleComplex) : TFhirDataElementMapping;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDataElementMapping.create;
  try
    ParseDataElementMappingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDataElementMappingProperties(obj : TTurtleComplex; result : TFhirDataElementMapping);
begin
    ParseBackboneElementProperties(obj, result);
    result.identityElement := ParseId(obj.complex('http://hl7.org/fhir/DataElement.mapping.identity'));{q1}
    result.uriElement := ParseUri(obj.complex('http://hl7.org/fhir/DataElement.mapping.uri'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/DataElement.mapping.name'));{q1}
    result.commentsElement := ParseString(obj.complex('http://hl7.org/fhir/DataElement.mapping.comments'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeDataElementMapping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataElementMapping; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DataElementMapping'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'DataElement.mapping', 'identity', elem.identityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'DataElement.mapping', 'uri', elem.uriElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DataElement.mapping', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DataElement.mapping', 'comments', elem.commentsElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseDataElement(obj : TTurtleComplex) : TFhirDataElement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDataElement.create;
  try
    ParseDataElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDataElementProperties(obj : TTurtleComplex; result : TFhirDataElement);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/DataElement.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DataElement.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/DataElement.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/DataElement.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DataElement.status'), CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/DataElement.experimental'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/DataElement.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DataElement.contact') do
      result.contactList.Add(parseDataElementContact(item));
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DataElement.date'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DataElement.useContext') do
      result.useContextList.Add(parseCodeableConcept(item));
    result.copyrightElement := ParseString(obj.complex('http://hl7.org/fhir/DataElement.copyright'));{q1}
    result.stringencyElement := ParseEnum(obj.complex('http://hl7.org/fhir/DataElement.stringency'), CODES_TFhirDataelementStringencyEnum, SYSTEMS_TFhirDataelementStringencyEnum);
    for item in obj.complexes('http://hl7.org/fhir/DataElement.mapping') do
      result.mappingList.Add(parseDataElementMapping(item));
    for item in obj.complexes('http://hl7.org/fhir/DataElement.element') do
      result.elementList.Add(parseElementDefinition(item));
end;

procedure TFHIRTurtleComposer.ComposeDataElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataElement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DataElement'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'DataElement', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DataElement', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'DataElement', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'DataElement', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'DataElement', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'DataElement', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'DataElement', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeDataElementContact(this, 'DataElement', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'DataElement', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(this, 'DataElement', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeString(this, 'DataElement', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('stringency') then
    ComposeEnum(this, 'DataElement', 'stringency', elem.StringencyElement, CODES_TFhirDataelementStringencyEnum, SYSTEMS_TFhirDataelementStringencyEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('mapping') then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeDataElementMapping(this, 'DataElement', 'mapping', elem.mappingList[i], false, i);{x.d3}
  for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(this, 'DataElement', 'element', elem.elementList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
function TFHIRTurtleParser.ParseDetectedIssueMitigation(obj : TTurtleComplex) : TFhirDetectedIssueMitigation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDetectedIssueMitigation.create;
  try
    ParseDetectedIssueMitigationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDetectedIssueMitigationProperties(obj : TTurtleComplex; result : TFhirDetectedIssueMitigation);
begin
    ParseBackboneElementProperties(obj, result);
    result.action := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DetectedIssue.mitigation.action'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DetectedIssue.mitigation.date'));{q1}
    result.author := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/DetectedIssue.mitigation.author'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDetectedIssueMitigation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDetectedIssueMitigation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DetectedIssueMitigation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'DetectedIssue.mitigation', 'action', elem.actionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'DetectedIssue.mitigation', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'DetectedIssue.mitigation', 'author', elem.authorElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDetectedIssue(obj : TTurtleComplex) : TFhirDetectedIssue;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDetectedIssue.create;
  try
    ParseDetectedIssueProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDetectedIssueProperties(obj : TTurtleComplex; result : TFhirDetectedIssue);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/DetectedIssue.patient'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DetectedIssue.category'));{q3b}
    result.severityElement := ParseEnum(obj.complex('http://hl7.org/fhir/DetectedIssue.severity'), CODES_TFhirDetectedissueSeverityEnum, SYSTEMS_TFhirDetectedissueSeverityEnum);
    for item in obj.complexes('http://hl7.org/fhir/DetectedIssue.implicated') do
      result.implicatedList.Add(parseReference{TFhirReference}(item));
    result.detailElement := ParseString(obj.complex('http://hl7.org/fhir/DetectedIssue.detail'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DetectedIssue.date'));{q1}
    result.author := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DetectedIssue.author'));{q3b}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DetectedIssue.identifier'));{q3b}
    result.referenceElement := ParseUri(obj.complex('http://hl7.org/fhir/DetectedIssue.reference'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DetectedIssue.mitigation') do
      result.mitigationList.Add(parseDetectedIssueMitigation(item));
end;

procedure TFHIRTurtleComposer.ComposeDetectedIssue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDetectedIssue; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DetectedIssue'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'DetectedIssue', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'DetectedIssue', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('severity') then
    ComposeEnum(this, 'DetectedIssue', 'severity', elem.SeverityElement, CODES_TFhirDetectedissueSeverityEnum, SYSTEMS_TFhirDetectedissueSeverityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implicated') then
    for i := 0 to elem.implicatedList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'DetectedIssue', 'implicated', elem.implicatedList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('detail') then
    ComposeString(this, 'DetectedIssue', 'detail', elem.detailElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'DetectedIssue', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(this, 'DetectedIssue', 'author', elem.authorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'DetectedIssue', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('reference') then
    ComposeUri(this, 'DetectedIssue', 'reference', elem.referenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('mitigation') then
    for i := 0 to elem.mitigationList.Count - 1 do
      ComposeDetectedIssueMitigation(this, 'DetectedIssue', 'mitigation', elem.mitigationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
function TFHIRTurtleParser.ParseDevice(obj : TTurtleComplex) : TFhirDevice;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDevice.create;
  try
    ParseDeviceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceProperties(obj : TTurtleComplex; result : TFhirDevice);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Device.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Device.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Device.note') do
      result.noteList.Add(parseAnnotation(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Device.status'), CODES_TFhirDevicestatusEnum, SYSTEMS_TFhirDevicestatusEnum);
    result.manufacturerElement := ParseString(obj.complex('http://hl7.org/fhir/Device.manufacturer'));{q1}
    result.modelElement := ParseString(obj.complex('http://hl7.org/fhir/Device.model'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Device.version'));{q1}
    result.manufactureDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Device.manufactureDate'));{q1}
    result.expiryElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Device.expiry'));{q1}
    result.udiElement := ParseString(obj.complex('http://hl7.org/fhir/Device.udi'));{q1}
    result.lotNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Device.lotNumber'));{q1}
    result.owner := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Device.owner'));{q3b}
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Device.location'));{q3b}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Device.patient'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Device.contact') do
      result.contactList.Add(parseContactPoint(item));
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Device.url'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeDevice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDevice; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Device'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Device', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Device', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Device', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Device', 'status', elem.StatusElement, CODES_TFhirDevicestatusEnum, SYSTEMS_TFhirDevicestatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('manufacturer') then
    ComposeString(this, 'Device', 'manufacturer', elem.manufacturerElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('model') then
    ComposeString(this, 'Device', 'model', elem.modelElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('version') then
    ComposeString(this, 'Device', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('manufactureDate') then
    ComposeDateTime(this, 'Device', 'manufactureDate', elem.manufactureDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('expiry') then
    ComposeDateTime(this, 'Device', 'expiry', elem.expiryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('udi') then
    ComposeString(this, 'Device', 'udi', elem.udiElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeString(this, 'Device', 'lotNumber', elem.lotNumberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('owner') then
    ComposeReference{TFhirOrganization}(this, 'Device', 'owner', elem.ownerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'Device', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'Device', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(this, 'Device', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUri(this, 'Device', 'url', elem.urlElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
function TFHIRTurtleParser.ParseDeviceComponentProductionSpecification(obj : TTurtleComplex) : TFhirDeviceComponentProductionSpecification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceComponentProductionSpecification.create;
  try
    ParseDeviceComponentProductionSpecificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceComponentProductionSpecificationProperties(obj : TTurtleComplex; result : TFhirDeviceComponentProductionSpecification);
begin
    ParseBackboneElementProperties(obj, result);
    result.specType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceComponent.productionSpecification.specType'));{q3b}
    result.componentId := ParseIdentifier(obj.complex('http://hl7.org/fhir/DeviceComponent.productionSpecification.componentId'));{q3b}
    result.productionSpecElement := ParseString(obj.complex('http://hl7.org/fhir/DeviceComponent.productionSpecification.productionSpec'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeDeviceComponentProductionSpecification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceComponentProductionSpecification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceComponentProductionSpecification'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DeviceComponent.productionSpecification', 'specType', elem.specTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'DeviceComponent.productionSpecification', 'componentId', elem.componentIdElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DeviceComponent.productionSpecification', 'productionSpec', elem.productionSpecElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseDeviceComponent(obj : TTurtleComplex) : TFhirDeviceComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceComponent.create;
  try
    ParseDeviceComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceComponentProperties(obj : TTurtleComplex; result : TFhirDeviceComponent);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceComponent.type'));{q3b}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DeviceComponent.identifier'));{q3b}
    result.lastSystemChangeElement := ParseInstant(obj.complex('http://hl7.org/fhir/DeviceComponent.lastSystemChange'));{q1}
    result.source := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/DeviceComponent.source'));{q3b}
    result.parent := ParseReference{TFhirDeviceComponent}(obj.complex('http://hl7.org/fhir/DeviceComponent.parent'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceComponent.operationalStatus') do
      result.operationalStatusList.Add(parseCodeableConcept(item));
    result.parameterGroup := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceComponent.parameterGroup'));{q3b}
    result.measurementPrincipleElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceComponent.measurementPrinciple'), CODES_TFhirMeasurementPrincipleEnum, SYSTEMS_TFhirMeasurementPrincipleEnum);
    for item in obj.complexes('http://hl7.org/fhir/DeviceComponent.productionSpecification') do
      result.productionSpecificationList.Add(parseDeviceComponentProductionSpecification(item));
    result.languageCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceComponent.languageCode'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDeviceComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceComponent'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'DeviceComponent', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeIdentifier(this, 'DeviceComponent', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeInstant(this, 'DeviceComponent', 'lastSystemChange', elem.lastSystemChangeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirDevice}(this, 'DeviceComponent', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') then
    ComposeReference{TFhirDeviceComponent}(this, 'DeviceComponent', 'parent', elem.parentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') then
    for i := 0 to elem.operationalStatusList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceComponent', 'operationalStatus', elem.operationalStatusList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parameterGroup') then
    ComposeCodeableConcept(this, 'DeviceComponent', 'parameterGroup', elem.parameterGroupElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('measurementPrinciple') then
    ComposeEnum(this, 'DeviceComponent', 'measurementPrinciple', elem.MeasurementPrincipleElement, CODES_TFhirMeasurementPrincipleEnum, SYSTEMS_TFhirMeasurementPrincipleEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('productionSpecification') then
    for i := 0 to elem.productionSpecificationList.Count - 1 do
      ComposeDeviceComponentProductionSpecification(this, 'DeviceComponent', 'productionSpecification', elem.productionSpecificationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('languageCode') then
    ComposeCodeableConcept(this, 'DeviceComponent', 'languageCode', elem.languageCodeElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
function TFHIRTurtleParser.ParseDeviceMetricCalibration(obj : TTurtleComplex) : TFhirDeviceMetricCalibration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceMetricCalibration.create;
  try
    ParseDeviceMetricCalibrationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceMetricCalibrationProperties(obj : TTurtleComplex; result : TFhirDeviceMetricCalibration);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.calibration.type'), CODES_TFhirMetricCalibrationTypeEnum, SYSTEMS_TFhirMetricCalibrationTypeEnum);
    result.stateElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.calibration.state'), CODES_TFhirMetricCalibrationStateEnum, SYSTEMS_TFhirMetricCalibrationStateEnum);
    result.timeElement := ParseInstant(obj.complex('http://hl7.org/fhir/DeviceMetric.calibration.time'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeDeviceMetricCalibration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceMetricCalibration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceMetricCalibration'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'DeviceMetric.calibration', 'type', elem.Type_Element, CODES_TFhirMetricCalibrationTypeEnum, SYSTEMS_TFhirMetricCalibrationTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'DeviceMetric.calibration', 'state', elem.StateElement, CODES_TFhirMetricCalibrationStateEnum, SYSTEMS_TFhirMetricCalibrationStateEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'DeviceMetric.calibration', 'time', elem.timeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseDeviceMetric(obj : TTurtleComplex) : TFhirDeviceMetric;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceMetric.create;
  try
    ParseDeviceMetricProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceMetricProperties(obj : TTurtleComplex; result : TFhirDeviceMetric);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceMetric.type'));{q3b}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DeviceMetric.identifier'));{q3b}
    result.unit_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceMetric.unit'));{q3b}
    result.source := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/DeviceMetric.source'));{q3b}
    result.parent := ParseReference{TFhirDeviceComponent}(obj.complex('http://hl7.org/fhir/DeviceMetric.parent'));{q3b}
    result.operationalStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.operationalStatus'), CODES_TFhirMetricOperationalStatusEnum, SYSTEMS_TFhirMetricOperationalStatusEnum);
    result.colorElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.color'), CODES_TFhirMetricColorEnum, SYSTEMS_TFhirMetricColorEnum);
    result.categoryElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.category'), CODES_TFhirMetricCategoryEnum, SYSTEMS_TFhirMetricCategoryEnum);
    result.measurementPeriod := ParseTiming(obj.complex('http://hl7.org/fhir/DeviceMetric.measurementPeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceMetric.calibration') do
      result.calibrationList.Add(parseDeviceMetricCalibration(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceMetric(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceMetric; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceMetric'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'DeviceMetric', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeIdentifier(this, 'DeviceMetric', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('unit_') then
    ComposeCodeableConcept(this, 'DeviceMetric', 'unit', elem.unit_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirDevice}(this, 'DeviceMetric', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') then
    ComposeReference{TFhirDeviceComponent}(this, 'DeviceMetric', 'parent', elem.parentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') then
    ComposeEnum(this, 'DeviceMetric', 'operationalStatus', elem.OperationalStatusElement, CODES_TFhirMetricOperationalStatusEnum, SYSTEMS_TFhirMetricOperationalStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('color') then
    ComposeEnum(this, 'DeviceMetric', 'color', elem.ColorElement, CODES_TFhirMetricColorEnum, SYSTEMS_TFhirMetricColorEnum, false, -1);{x.d4}
  ComposeEnum(this, 'DeviceMetric', 'category', elem.CategoryElement, CODES_TFhirMetricCategoryEnum, SYSTEMS_TFhirMetricCategoryEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('measurementPeriod') then
    ComposeTiming(this, 'DeviceMetric', 'measurementPeriod', elem.measurementPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('calibration') then
    for i := 0 to elem.calibrationList.Count - 1 do
      ComposeDeviceMetricCalibration(this, 'DeviceMetric', 'calibration', elem.calibrationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
function TFHIRTurtleParser.ParseDeviceUseRequest(obj : TTurtleComplex) : TFhirDeviceUseRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceUseRequest.create;
  try
    ParseDeviceUseRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceUseRequestProperties(obj : TTurtleComplex; result : TFhirDeviceUseRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    if obj.has('http://hl7.org/fhir/DeviceUseRequest.bodySiteCodeableConcept', item) then
      result.bodySite := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/DeviceUseRequest.bodySiteReference', item) {a3} then
      result.bodySite := ParseReference(item);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceUseRequest.status'), CODES_TFhirDeviceUseRequestStatusEnum, SYSTEMS_TFhirDeviceUseRequestStatusEnum);
    result.device := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/DeviceUseRequest.device'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/DeviceUseRequest.encounter'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceUseRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceUseRequest.indication') do
      result.indicationList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceUseRequest.notes') do
      result.notesList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceUseRequest.prnReason') do
      result.prnReasonList.Add(parseCodeableConcept(item));
    result.orderedOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DeviceUseRequest.orderedOn'));{q1}
    result.recordedOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DeviceUseRequest.recordedOn'));{q1}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/DeviceUseRequest.subject'));{q3b}
    if obj.has('http://hl7.org/fhir/DeviceUseRequest.timingTiming', item) then
      result.timing := parseTiming(item);
    if obj.has('http://hl7.org/fhir/DeviceUseRequest.timingPeriod', item) then
      result.timing := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/DeviceUseRequest.timingDateTime', item) then
      result.timing := parseDateTime(item);
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceUseRequest.priority'), CODES_TFhirDeviceUseRequestPriorityEnum, SYSTEMS_TFhirDeviceUseRequestPriorityEnum);
end;

procedure TFHIRTurtleComposer.ComposeDeviceUseRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceUseRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceUseRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'DeviceUseRequest', 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirReference) {2} then
    ComposeReference(this, 'DeviceUseRequest', 'bodySiteReference', TFhirReference(elem.bodySite), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'DeviceUseRequest', 'status', elem.StatusElement, CODES_TFhirDeviceUseRequestStatusEnum, SYSTEMS_TFhirDeviceUseRequestStatusEnum, false, -1);{x.d4}
  ComposeReference{TFhirDevice}(this, 'DeviceUseRequest', 'device', elem.deviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'DeviceUseRequest', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DeviceUseRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('indication') then
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceUseRequest', 'indication', elem.indicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notes') then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeString(this, 'DeviceUseRequest', 'notes', elem.notesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('prnReason') then
    for i := 0 to elem.prnReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceUseRequest', 'prnReason', elem.prnReasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderedOn') then
    ComposeDateTime(this, 'DeviceUseRequest', 'orderedOn', elem.orderedOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedOn') then
    ComposeDateTime(this, 'DeviceUseRequest', 'recordedOn', elem.recordedOnElement, false, -1);{x.2ea}
  ComposeReference{TFhirPatient}(this, 'DeviceUseRequest', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'DeviceUseRequest', 'timingTiming', TFhirTiming(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'DeviceUseRequest', 'timingPeriod', TFhirPeriod(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DeviceUseRequest', 'timingDateTime', TFhirDateTime(elem.timing), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(this, 'DeviceUseRequest', 'priority', elem.PriorityElement, CODES_TFhirDeviceUseRequestPriorityEnum, SYSTEMS_TFhirDeviceUseRequestPriorityEnum, false, -1);{x.d4}
end;

{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
function TFHIRTurtleParser.ParseDeviceUseStatement(obj : TTurtleComplex) : TFhirDeviceUseStatement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceUseStatement.create;
  try
    ParseDeviceUseStatementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceUseStatementProperties(obj : TTurtleComplex; result : TFhirDeviceUseStatement);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    if obj.has('http://hl7.org/fhir/DeviceUseStatement.bodySiteCodeableConcept', item) then
      result.bodySite := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/DeviceUseStatement.bodySiteReference', item) {a3} then
      result.bodySite := ParseReference(item);
    result.whenUsed := ParsePeriod(obj.complex('http://hl7.org/fhir/DeviceUseStatement.whenUsed'));{q3b}
    result.device := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/DeviceUseStatement.device'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceUseStatement.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceUseStatement.indication') do
      result.indicationList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceUseStatement.notes') do
      result.notesList.Add(parseString(item));
    result.recordedOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DeviceUseStatement.recordedOn'));{q1}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/DeviceUseStatement.subject'));{q3b}
    if obj.has('http://hl7.org/fhir/DeviceUseStatement.timingTiming', item) then
      result.timing := parseTiming(item);
    if obj.has('http://hl7.org/fhir/DeviceUseStatement.timingPeriod', item) then
      result.timing := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/DeviceUseStatement.timingDateTime', item) then
      result.timing := parseDateTime(item);
end;

procedure TFHIRTurtleComposer.ComposeDeviceUseStatement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceUseStatement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceUseStatement'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'DeviceUseStatement', 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirReference) {2} then
    ComposeReference(this, 'DeviceUseStatement', 'bodySiteReference', TFhirReference(elem.bodySite), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenUsed') then
    ComposePeriod(this, 'DeviceUseStatement', 'whenUsed', elem.whenUsedElement, false, -1);{x.2f}
  ComposeReference{TFhirDevice}(this, 'DeviceUseStatement', 'device', elem.deviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DeviceUseStatement', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('indication') then
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceUseStatement', 'indication', elem.indicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notes') then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeString(this, 'DeviceUseStatement', 'notes', elem.notesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedOn') then
    ComposeDateTime(this, 'DeviceUseStatement', 'recordedOn', elem.recordedOnElement, false, -1);{x.2ea}
  ComposeReference{TFhirPatient}(this, 'DeviceUseStatement', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'DeviceUseStatement', 'timingTiming', TFhirTiming(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'DeviceUseStatement', 'timingPeriod', TFhirPeriod(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DeviceUseStatement', 'timingDateTime', TFhirDateTime(elem.timing), false, -1);{x.d9}
end;

{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
function TFHIRTurtleParser.ParseDiagnosticOrderEvent(obj : TTurtleComplex) : TFhirDiagnosticOrderEvent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDiagnosticOrderEvent.create;
  try
    ParseDiagnosticOrderEventProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDiagnosticOrderEventProperties(obj : TTurtleComplex; result : TFhirDiagnosticOrderEvent);
begin
    ParseBackboneElementProperties(obj, result);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DiagnosticOrder.event.status'), CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum);
    result.description := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DiagnosticOrder.event.description'));{q3b}
    result.dateTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DiagnosticOrder.event.dateTime'));{q1}
    result.actor := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DiagnosticOrder.event.actor'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDiagnosticOrderEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticOrderEvent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DiagnosticOrderEvent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'DiagnosticOrder.event', 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DiagnosticOrder.event', 'description', elem.descriptionElement, false, -1);{x.2f}
  ComposeDateTime(this, 'DiagnosticOrder.event', 'dateTime', elem.dateTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'DiagnosticOrder.event', 'actor', elem.actorElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDiagnosticOrderItem(obj : TTurtleComplex) : TFhirDiagnosticOrderItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDiagnosticOrderItem.create;
  try
    ParseDiagnosticOrderItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDiagnosticOrderItemProperties(obj : TTurtleComplex; result : TFhirDiagnosticOrderItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DiagnosticOrder.item.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticOrder.item.specimen') do
      result.specimenList.Add(parseReference{TFhirSpecimen}(item));
    result.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DiagnosticOrder.item.bodySite'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DiagnosticOrder.item.status'), CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticOrder.item.event') do
      result.eventList.Add(parseDiagnosticOrderEvent(item));
end;

procedure TFHIRTurtleComposer.ComposeDiagnosticOrderItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticOrderItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DiagnosticOrderItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'DiagnosticOrder.item', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(this, 'DiagnosticOrder.item', 'specimen', elem.specimenList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'DiagnosticOrder.item', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'DiagnosticOrder.item', 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(this, 'DiagnosticOrder.item', 'event', elem.eventList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseDiagnosticOrder(obj : TTurtleComplex) : TFhirDiagnosticOrder;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDiagnosticOrder.create;
  try
    ParseDiagnosticOrderProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDiagnosticOrderProperties(obj : TTurtleComplex; result : TFhirDiagnosticOrder);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DiagnosticOrder.subject'));{q3b}
    result.orderer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/DiagnosticOrder.orderer'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticOrder.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/DiagnosticOrder.encounter'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticOrder.reason') do
      result.reasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticOrder.supportingInformation') do
      result.supportingInformationList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticOrder.specimen') do
      result.specimenList.Add(parseReference{TFhirSpecimen}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DiagnosticOrder.status'), CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum);
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/DiagnosticOrder.priority'), CODES_TFhirDiagnosticOrderPriorityEnum, SYSTEMS_TFhirDiagnosticOrderPriorityEnum);
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticOrder.event') do
      result.eventList.Add(parseDiagnosticOrderEvent(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticOrder.item') do
      result.itemList.Add(parseDiagnosticOrderItem(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticOrder.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeDiagnosticOrder(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticOrder; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DiagnosticOrder'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'DiagnosticOrder', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderer') then
    ComposeReference{TFhirPractitioner}(this, 'DiagnosticOrder', 'orderer', elem.ordererElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DiagnosticOrder', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'DiagnosticOrder', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'DiagnosticOrder', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{Resource}(this, 'DiagnosticOrder', 'supportingInformation', elem.supportingInformationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('specimen') then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(this, 'DiagnosticOrder', 'specimen', elem.specimenList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'DiagnosticOrder', 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(this, 'DiagnosticOrder', 'priority', elem.PriorityElement, CODES_TFhirDiagnosticOrderPriorityEnum, SYSTEMS_TFhirDiagnosticOrderPriorityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('event') then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(this, 'DiagnosticOrder', 'event', elem.eventList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeDiagnosticOrderItem(this, 'DiagnosticOrder', 'item', elem.itemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'DiagnosticOrder', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
function TFHIRTurtleParser.ParseDiagnosticReportImage(obj : TTurtleComplex) : TFhirDiagnosticReportImage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDiagnosticReportImage.create;
  try
    ParseDiagnosticReportImageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDiagnosticReportImageProperties(obj : TTurtleComplex; result : TFhirDiagnosticReportImage);
begin
    ParseBackboneElementProperties(obj, result);
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/DiagnosticReport.image.comment'));{q1}
    result.link_ := ParseReference{TFhirMedia}(obj.complex('http://hl7.org/fhir/DiagnosticReport.image.link'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDiagnosticReportImage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticReportImage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DiagnosticReportImage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DiagnosticReport.image', 'comment', elem.commentElement, false, -1);{x.2ea}
  ComposeReference{TFhirMedia}(this, 'DiagnosticReport.image', 'link', elem.link_Element, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDiagnosticReport(obj : TTurtleComplex) : TFhirDiagnosticReport;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDiagnosticReport.create;
  try
    ParseDiagnosticReportProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDiagnosticReportProperties(obj : TTurtleComplex; result : TFhirDiagnosticReport);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DiagnosticReport.status'), CODES_TFhirDiagnosticReportStatusEnum, SYSTEMS_TFhirDiagnosticReportStatusEnum);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DiagnosticReport.category'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DiagnosticReport.code'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DiagnosticReport.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/DiagnosticReport.encounter'));{q3b}
    if obj.has('http://hl7.org/fhir/DiagnosticReport.effectivePeriod', item) then
      result.effective := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/DiagnosticReport.effectiveDateTime', item) then
      result.effective := parseDateTime(item);
    result.issuedElement := ParseInstant(obj.complex('http://hl7.org/fhir/DiagnosticReport.issued'));{q1}
    result.performer := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DiagnosticReport.performer'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.request') do
      result.requestList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.specimen') do
      result.specimenList.Add(parseReference{TFhirSpecimen}(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.result') do
      result.resultList.Add(parseReference{TFhirObservation}(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.imagingStudy') do
      result.imagingStudyList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.image') do
      result.imageList.Add(parseDiagnosticReportImage(item));
    result.conclusionElement := ParseString(obj.complex('http://hl7.org/fhir/DiagnosticReport.conclusion'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.codedDiagnosis') do
      result.codedDiagnosisList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.presentedForm') do
      result.presentedFormList.Add(parseAttachment(item));
end;

procedure TFHIRTurtleComposer.ComposeDiagnosticReport(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticReport; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DiagnosticReport'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DiagnosticReport', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'DiagnosticReport', 'status', elem.StatusElement, CODES_TFhirDiagnosticReportStatusEnum, SYSTEMS_TFhirDiagnosticReportStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'DiagnosticReport', 'category', elem.categoryElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'DiagnosticReport', 'code', elem.codeElement, false, -1);{x.2f}
  ComposeReference{Resource}(this, 'DiagnosticReport', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'DiagnosticReport', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'DiagnosticReport', 'effectivePeriod', TFhirPeriod(elem.effective), false, -1){x.d9}
  else if (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DiagnosticReport', 'effectiveDateTime', TFhirDateTime(elem.effective), false, -1);{x.d9}
  ComposeInstant(this, 'DiagnosticReport', 'issued', elem.issuedElement, false, -1);{x.2ea}
  ComposeReference{Resource}(this, 'DiagnosticReport', 'performer', elem.performerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    for i := 0 to elem.requestList.Count - 1 do
      ComposeReference{Resource}(this, 'DiagnosticReport', 'request', elem.requestList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('specimen') then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(this, 'DiagnosticReport', 'specimen', elem.specimenList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('result') then
    for i := 0 to elem.resultList.Count - 1 do
      ComposeReference{TFhirObservation}(this, 'DiagnosticReport', 'result', elem.resultList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('imagingStudy') then
    for i := 0 to elem.imagingStudyList.Count - 1 do
      ComposeReference{Resource}(this, 'DiagnosticReport', 'imagingStudy', elem.imagingStudyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('image') then
    for i := 0 to elem.imageList.Count - 1 do
      ComposeDiagnosticReportImage(this, 'DiagnosticReport', 'image', elem.imageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('conclusion') then
    ComposeString(this, 'DiagnosticReport', 'conclusion', elem.conclusionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('codedDiagnosis') then
    for i := 0 to elem.codedDiagnosisList.Count - 1 do
      ComposeCodeableConcept(this, 'DiagnosticReport', 'codedDiagnosis', elem.codedDiagnosisList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('presentedForm') then
    for i := 0 to elem.presentedFormList.Count - 1 do
      ComposeAttachment(this, 'DiagnosticReport', 'presentedForm', elem.presentedFormList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
function TFHIRTurtleParser.ParseDocumentManifestContent(obj : TTurtleComplex) : TFhirDocumentManifestContent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentManifestContent.create;
  try
    ParseDocumentManifestContentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentManifestContentProperties(obj : TTurtleComplex; result : TFhirDocumentManifestContent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/DocumentManifest.content.pAttachment', item) then
      result.p := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/DocumentManifest.content.pReference', item) {a3} then
      result.p := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeDocumentManifestContent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentManifestContent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentManifestContent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.p is TFhirAttachment) {6} then
    ComposeAttachment(this, 'DocumentManifest.content', 'pAttachment', TFhirAttachment(elem.p), false, -1){x.d9}
  else if (elem.p is TFhirReference) {2} then
    ComposeReference(this, 'DocumentManifest.content', 'pReference', TFhirReference(elem.p), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseDocumentManifestRelated(obj : TTurtleComplex) : TFhirDocumentManifestRelated;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentManifestRelated.create;
  try
    ParseDocumentManifestRelatedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentManifestRelatedProperties(obj : TTurtleComplex; result : TFhirDocumentManifestRelated);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DocumentManifest.related.identifier'));{q3b}
    result.ref := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/DocumentManifest.related.ref'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDocumentManifestRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentManifestRelated; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentManifestRelated'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'DocumentManifest.related', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'DocumentManifest.related', 'ref', elem.refElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDocumentManifest(obj : TTurtleComplex) : TFhirDocumentManifest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentManifest.create;
  try
    ParseDocumentManifestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentManifestProperties(obj : TTurtleComplex; result : TFhirDocumentManifest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.masterIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DocumentManifest.masterIdentifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DocumentManifest.subject'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.recipient') do
      result.recipientList.Add(parseReference{Resource}(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentManifest.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.author') do
      result.authorList.Add(parseReference{Resource}(item));
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DocumentManifest.created'));{q1}
    result.sourceElement := ParseUri(obj.complex('http://hl7.org/fhir/DocumentManifest.source'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DocumentManifest.status'), CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/DocumentManifest.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.content') do
      result.contentList.Add(parseDocumentManifestContent(item));
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.related') do
      result.relatedList.Add(parseDocumentManifestRelated(item));
end;

procedure TFHIRTurtleComposer.ComposeDocumentManifest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentManifest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentManifest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('masterIdentifier') then
    ComposeIdentifier(this, 'DocumentManifest', 'masterIdentifier', elem.masterIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DocumentManifest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'DocumentManifest', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(this, 'DocumentManifest', 'recipient', elem.recipientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'DocumentManifest', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(this, 'DocumentManifest', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(this, 'DocumentManifest', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeUri(this, 'DocumentManifest', 'source', elem.sourceElement, false, -1);{x.2ea}
  ComposeEnum(this, 'DocumentManifest', 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'DocumentManifest', 'description', elem.descriptionElement, false, -1);{x.2ea}
  for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentManifestContent(this, 'DocumentManifest', 'content', elem.contentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('related') then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentManifestRelated(this, 'DocumentManifest', 'related', elem.relatedList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
function TFHIRTurtleParser.ParseDocumentReferenceRelatesTo(obj : TTurtleComplex) : TFhirDocumentReferenceRelatesTo;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    ParseDocumentReferenceRelatesToProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceRelatesToProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceRelatesTo);
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/DocumentReference.relatesTo.code'), CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum);
    result.target := ParseReference{TFhirDocumentReference}(obj.complex('http://hl7.org/fhir/DocumentReference.relatesTo.target'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDocumentReferenceRelatesTo(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceRelatesTo; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReferenceRelatesTo'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'DocumentReference.relatesTo', 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum, false, -1);{x.d4}
  ComposeReference{TFhirDocumentReference}(this, 'DocumentReference.relatesTo', 'target', elem.targetElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDocumentReferenceContent(obj : TTurtleComplex) : TFhirDocumentReferenceContent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReferenceContent.create;
  try
    ParseDocumentReferenceContentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceContentProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceContent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.attachment := ParseAttachment(obj.complex('http://hl7.org/fhir/DocumentReference.content.attachment'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.content.format') do
      result.formatList.Add(parseCoding(item));
end;

procedure TFHIRTurtleComposer.ComposeDocumentReferenceContent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceContent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReferenceContent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeAttachment(this, 'DocumentReference.content', 'attachment', elem.attachmentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.formatList.Count - 1 do
      ComposeCoding(this, 'DocumentReference.content', 'format', elem.formatList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseDocumentReferenceContext(obj : TTurtleComplex) : TFhirDocumentReferenceContext;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReferenceContext.create;
  try
    ParseDocumentReferenceContextProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceContextProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceContext);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/DocumentReference.context.encounter'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.context.event') do
      result.eventList.Add(parseCodeableConcept(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/DocumentReference.context.period'));{q3b}
    result.facilityType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentReference.context.facilityType'));{q3b}
    result.practiceSetting := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentReference.context.practiceSetting'));{q3b}
    result.sourcePatientInfo := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/DocumentReference.context.sourcePatientInfo'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.context.related') do
      result.relatedList.Add(parseDocumentReferenceContextRelated(item));
end;

procedure TFHIRTurtleComposer.ComposeDocumentReferenceContext(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceContext; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReferenceContext'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'DocumentReference.context', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCodeableConcept(this, 'DocumentReference.context', 'event', elem.eventList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'DocumentReference.context', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DocumentReference.context', 'facilityType', elem.facilityTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DocumentReference.context', 'practiceSetting', elem.practiceSettingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'DocumentReference.context', 'sourcePatientInfo', elem.sourcePatientInfoElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentReferenceContextRelated(this, 'DocumentReference.context', 'related', elem.relatedList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseDocumentReferenceContextRelated(obj : TTurtleComplex) : TFhirDocumentReferenceContextRelated;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReferenceContextRelated.create;
  try
    ParseDocumentReferenceContextRelatedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceContextRelatedProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceContextRelated);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DocumentReference.context.related.identifier'));{q3b}
    result.ref := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/DocumentReference.context.related.ref'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDocumentReferenceContextRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceContextRelated; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReferenceContextRelated'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'DocumentReference.context.related', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'DocumentReference.context.related', 'ref', elem.refElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDocumentReference(obj : TTurtleComplex) : TFhirDocumentReference;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReference.create;
  try
    ParseDocumentReferenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceProperties(obj : TTurtleComplex; result : TFhirDocumentReference);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.masterIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DocumentReference.masterIdentifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DocumentReference.subject'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentReference.type'));{q3b}
    result.class_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentReference.class'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.author') do
      result.authorList.Add(parseReference{Resource}(item));
    result.custodian := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/DocumentReference.custodian'));{q3b}
    result.authenticator := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DocumentReference.authenticator'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DocumentReference.created'));{q1}
    result.indexedElement := ParseInstant(obj.complex('http://hl7.org/fhir/DocumentReference.indexed'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DocumentReference.status'), CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum);
    result.docStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentReference.docStatus'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.relatesTo') do
      result.relatesToList.Add(parseDocumentReferenceRelatesTo(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/DocumentReference.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.securityLabel') do
      result.securityLabelList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.content') do
      result.contentList.Add(parseDocumentReferenceContent(item));
    result.context := ParseDocumentReferenceContext(obj.complex('http://hl7.org/fhir/DocumentReference.context'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDocumentReference(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReference; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReference'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('masterIdentifier') then
    ComposeIdentifier(this, 'DocumentReference', 'masterIdentifier', elem.masterIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DocumentReference', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'DocumentReference', 'subject', elem.subjectElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'DocumentReference', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeCodeableConcept(this, 'DocumentReference', 'class', elem.class_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(this, 'DocumentReference', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('custodian') then
    ComposeReference{TFhirOrganization}(this, 'DocumentReference', 'custodian', elem.custodianElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authenticator') then
    ComposeReference{Resource}(this, 'DocumentReference', 'authenticator', elem.authenticatorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(this, 'DocumentReference', 'created', elem.createdElement, false, -1);{x.2ea}
  ComposeInstant(this, 'DocumentReference', 'indexed', elem.indexedElement, false, -1);{x.2ea}
  ComposeEnum(this, 'DocumentReference', 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('docStatus') then
    ComposeCodeableConcept(this, 'DocumentReference', 'docStatus', elem.docStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relatesTo') then
    for i := 0 to elem.relatesToList.Count - 1 do
      ComposeDocumentReferenceRelatesTo(this, 'DocumentReference', 'relatesTo', elem.relatesToList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'DocumentReference', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('securityLabel') then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCodeableConcept(this, 'DocumentReference', 'securityLabel', elem.securityLabelList[i], false, i);{x.d3}
  for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentReferenceContent(this, 'DocumentReference', 'content', elem.contentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeDocumentReferenceContext(this, 'DocumentReference', 'context', elem.contextElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
function TFHIRTurtleParser.ParseEligibilityRequest(obj : TTurtleComplex) : TFhirEligibilityRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEligibilityRequest.create;
  try
    ParseEligibilityRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEligibilityRequestProperties(obj : TTurtleComplex; result : TFhirEligibilityRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/EligibilityRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.ruleset := ParseCoding(obj.complex('http://hl7.org/fhir/EligibilityRequest.ruleset'));{q3b}
    result.originalRuleset := ParseCoding(obj.complex('http://hl7.org/fhir/EligibilityRequest.originalRuleset'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/EligibilityRequest.created'));{q1}
    result.target := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EligibilityRequest.target'));{q3b}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/EligibilityRequest.provider'));{q3b}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EligibilityRequest.organization'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEligibilityRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEligibilityRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EligibilityRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EligibilityRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(this, 'EligibilityRequest', 'ruleset', elem.rulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(this, 'EligibilityRequest', 'originalRuleset', elem.originalRulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(this, 'EligibilityRequest', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(this, 'EligibilityRequest', 'target', elem.targetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(this, 'EligibilityRequest', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'EligibilityRequest', 'organization', elem.organizationElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
function TFHIRTurtleParser.ParseEligibilityResponse(obj : TTurtleComplex) : TFhirEligibilityResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEligibilityResponse.create;
  try
    ParseEligibilityResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEligibilityResponseProperties(obj : TTurtleComplex; result : TFhirEligibilityResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/EligibilityResponse.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.request := ParseReference{TFhirEligibilityRequest}(obj.complex('http://hl7.org/fhir/EligibilityResponse.request'));{q3b}
    result.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/EligibilityResponse.outcome'), CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    result.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/EligibilityResponse.disposition'));{q1}
    result.ruleset := ParseCoding(obj.complex('http://hl7.org/fhir/EligibilityResponse.ruleset'));{q3b}
    result.originalRuleset := ParseCoding(obj.complex('http://hl7.org/fhir/EligibilityResponse.originalRuleset'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/EligibilityResponse.created'));{q1}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EligibilityResponse.organization'));{q3b}
    result.requestProvider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/EligibilityResponse.requestProvider'));{q3b}
    result.requestOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EligibilityResponse.requestOrganization'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEligibilityResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEligibilityResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EligibilityResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EligibilityResponse', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirEligibilityRequest}(this, 'EligibilityResponse', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnum(this, 'EligibilityResponse', 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeString(this, 'EligibilityResponse', 'disposition', elem.dispositionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(this, 'EligibilityResponse', 'ruleset', elem.rulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(this, 'EligibilityResponse', 'originalRuleset', elem.originalRulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(this, 'EligibilityResponse', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'EligibilityResponse', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(this, 'EligibilityResponse', 'requestProvider', elem.requestProviderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(this, 'EligibilityResponse', 'requestOrganization', elem.requestOrganizationElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
function TFHIRTurtleParser.ParseEncounterStatusHistory(obj : TTurtleComplex) : TFhirEncounterStatusHistory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterStatusHistory.create;
  try
    ParseEncounterStatusHistoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterStatusHistoryProperties(obj : TTurtleComplex; result : TFhirEncounterStatusHistory);
begin
    ParseBackboneElementProperties(obj, result);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Encounter.statusHistory.status'), CODES_TFhirEncounterStateEnum, SYSTEMS_TFhirEncounterStateEnum);
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.statusHistory.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEncounterStatusHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterStatusHistory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterStatusHistory'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Encounter.statusHistory', 'status', elem.StatusElement, CODES_TFhirEncounterStateEnum, SYSTEMS_TFhirEncounterStateEnum, false, -1);{x.d4}
  ComposePeriod(this, 'Encounter.statusHistory', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEncounterParticipant(obj : TTurtleComplex) : TFhirEncounterParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterParticipant.create;
  try
    ParseEncounterParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterParticipantProperties(obj : TTurtleComplex; result : TFhirEncounterParticipant);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Encounter.participant.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.participant.period'));{q3b}
    result.individual := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Encounter.participant.individual'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEncounterParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter.participant', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Encounter.participant', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Encounter.participant', 'individual', elem.individualElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEncounterHospitalization(obj : TTurtleComplex) : TFhirEncounterHospitalization;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterHospitalization.create;
  try
    ParseEncounterHospitalizationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterHospitalizationProperties(obj : TTurtleComplex; result : TFhirEncounterHospitalization);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.preAdmissionIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.preAdmissionIdentifier'));{q3b}
    result.origin := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.origin'));{q3b}
    result.admitSource := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.admitSource'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Encounter.hospitalization.admittingDiagnosis') do
      result.admittingDiagnosisList.Add(parseReference{TFhirCondition}(item));
    result.reAdmission := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.reAdmission'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Encounter.hospitalization.dietPreference') do
      result.dietPreferenceList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.hospitalization.specialCourtesy') do
      result.specialCourtesyList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.hospitalization.specialArrangement') do
      result.specialArrangementList.Add(parseCodeableConcept(item));
    result.destination := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.destination'));{q3b}
    result.dischargeDisposition := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.dischargeDisposition'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Encounter.hospitalization.dischargeDiagnosis') do
      result.dischargeDiagnosisList.Add(parseReference{TFhirCondition}(item));
end;

procedure TFHIRTurtleComposer.ComposeEncounterHospitalization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterHospitalization; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterHospitalization'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Encounter.hospitalization', 'preAdmissionIdentifier', elem.preAdmissionIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'Encounter.hospitalization', 'origin', elem.originElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter.hospitalization', 'admitSource', elem.admitSourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.admittingDiagnosisList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'Encounter.hospitalization', 'admittingDiagnosis', elem.admittingDiagnosisList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter.hospitalization', 'reAdmission', elem.reAdmissionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dietPreferenceList.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter.hospitalization', 'dietPreference', elem.dietPreferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.specialCourtesyList.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter.hospitalization', 'specialCourtesy', elem.specialCourtesyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.specialArrangementList.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter.hospitalization', 'specialArrangement', elem.specialArrangementList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'Encounter.hospitalization', 'destination', elem.destinationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter.hospitalization', 'dischargeDisposition', elem.dischargeDispositionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dischargeDiagnosisList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'Encounter.hospitalization', 'dischargeDiagnosis', elem.dischargeDiagnosisList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseEncounterLocation(obj : TTurtleComplex) : TFhirEncounterLocation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterLocation.create;
  try
    ParseEncounterLocationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterLocationProperties(obj : TTurtleComplex; result : TFhirEncounterLocation);
begin
    ParseBackboneElementProperties(obj, result);
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Encounter.location.location'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Encounter.location.status'), CODES_TFhirEncounterLocationStatusEnum, SYSTEMS_TFhirEncounterLocationStatusEnum);
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.location.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEncounterLocation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterLocation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterLocation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirLocation}(this, 'Encounter.location', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Encounter.location', 'status', elem.StatusElement, CODES_TFhirEncounterLocationStatusEnum, SYSTEMS_TFhirEncounterLocationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Encounter.location', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEncounter(obj : TTurtleComplex) : TFhirEncounter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounter.create;
  try
    ParseEncounterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterProperties(obj : TTurtleComplex; result : TFhirEncounter);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Encounter.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Encounter.status'), CODES_TFhirEncounterStateEnum, SYSTEMS_TFhirEncounterStateEnum);
    for item in obj.complexes('http://hl7.org/fhir/Encounter.statusHistory') do
      result.statusHistoryList.Add(parseEncounterStatusHistory(item));
    result.class_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Encounter.class'), CODES_TFhirEncounterClassEnum, SYSTEMS_TFhirEncounterClassEnum);
    for item in obj.complexes('http://hl7.org/fhir/Encounter.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.priority'));{q3b}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Encounter.patient'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Encounter.episodeOfCare') do
      result.episodeOfCareList.Add(parseReference{TFhirEpisodeOfCare}(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.incomingReferral') do
      result.incomingReferralList.Add(parseReference{TFhirReferralRequest}(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.participant') do
      result.participantList.Add(parseEncounterParticipant(item));
    result.appointment := ParseReference{TFhirAppointment}(obj.complex('http://hl7.org/fhir/Encounter.appointment'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.period'));{q3b}
    result.length := ParseQuantity(obj.complex('http://hl7.org/fhir/Encounter.length'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Encounter.reason') do
      result.reasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.indication') do
      result.indicationList.Add(parseReference{Resource}(item));
    result.hospitalization := ParseEncounterHospitalization(obj.complex('http://hl7.org/fhir/Encounter.hospitalization'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Encounter.location') do
      result.locationList.Add(parseEncounterLocation(item));
    result.serviceProvider := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Encounter.serviceProvider'));{q3b}
    result.partOf := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Encounter.partOf'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEncounter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Encounter'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Encounter', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Encounter', 'status', elem.StatusElement, CODES_TFhirEncounterStateEnum, SYSTEMS_TFhirEncounterStateEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('statusHistory') then
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEncounterStatusHistory(this, 'Encounter', 'statusHistory', elem.statusHistoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeEnum(this, 'Encounter', 'class', elem.Class_Element, CODES_TFhirEncounterClassEnum, SYSTEMS_TFhirEncounterClassEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeCodeableConcept(this, 'Encounter', 'priority', elem.priorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'Encounter', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('episodeOfCare') then
    for i := 0 to elem.episodeOfCareList.Count - 1 do
      ComposeReference{TFhirEpisodeOfCare}(this, 'Encounter', 'episodeOfCare', elem.episodeOfCareList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('incomingReferral') then
    for i := 0 to elem.incomingReferralList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(this, 'Encounter', 'incomingReferral', elem.incomingReferralList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeEncounterParticipant(this, 'Encounter', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('appointment') then
    ComposeReference{TFhirAppointment}(this, 'Encounter', 'appointment', elem.appointmentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(this, 'Encounter', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('length') then
    ComposeQuantity(this, 'Encounter', 'length', elem.lengthElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('indication') then
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeReference{Resource}(this, 'Encounter', 'indication', elem.indicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('hospitalization') then
    ComposeEncounterHospitalization(this, 'Encounter', 'hospitalization', elem.hospitalizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeEncounterLocation(this, 'Encounter', 'location', elem.locationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('serviceProvider') then
    ComposeReference{TFhirOrganization}(this, 'Encounter', 'serviceProvider', elem.serviceProviderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    ComposeReference{TFhirEncounter}(this, 'Encounter', 'partOf', elem.partOfElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
function TFHIRTurtleParser.ParseEnrollmentRequest(obj : TTurtleComplex) : TFhirEnrollmentRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEnrollmentRequest.create;
  try
    ParseEnrollmentRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEnrollmentRequestProperties(obj : TTurtleComplex; result : TFhirEnrollmentRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/EnrollmentRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.ruleset := ParseCoding(obj.complex('http://hl7.org/fhir/EnrollmentRequest.ruleset'));{q3b}
    result.originalRuleset := ParseCoding(obj.complex('http://hl7.org/fhir/EnrollmentRequest.originalRuleset'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/EnrollmentRequest.created'));{q1}
    result.target := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EnrollmentRequest.target'));{q3b}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/EnrollmentRequest.provider'));{q3b}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EnrollmentRequest.organization'));{q3b}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/EnrollmentRequest.subject'));{q3b}
    result.coverage := ParseReference{TFhirCoverage}(obj.complex('http://hl7.org/fhir/EnrollmentRequest.coverage'));{q3b}
    result.relationship := ParseCoding(obj.complex('http://hl7.org/fhir/EnrollmentRequest.relationship'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEnrollmentRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEnrollmentRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EnrollmentRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EnrollmentRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(this, 'EnrollmentRequest', 'ruleset', elem.rulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(this, 'EnrollmentRequest', 'originalRuleset', elem.originalRulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(this, 'EnrollmentRequest', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(this, 'EnrollmentRequest', 'target', elem.targetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(this, 'EnrollmentRequest', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'EnrollmentRequest', 'organization', elem.organizationElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'EnrollmentRequest', 'subject', elem.subjectElement, false, -1);{x.2f}
  ComposeReference{TFhirCoverage}(this, 'EnrollmentRequest', 'coverage', elem.coverageElement, false, -1);{x.2f}
  ComposeCoding(this, 'EnrollmentRequest', 'relationship', elem.relationshipElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
function TFHIRTurtleParser.ParseEnrollmentResponse(obj : TTurtleComplex) : TFhirEnrollmentResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEnrollmentResponse.create;
  try
    ParseEnrollmentResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEnrollmentResponseProperties(obj : TTurtleComplex; result : TFhirEnrollmentResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/EnrollmentResponse.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.request := ParseReference{TFhirEnrollmentRequest}(obj.complex('http://hl7.org/fhir/EnrollmentResponse.request'));{q3b}
    result.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/EnrollmentResponse.outcome'), CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    result.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/EnrollmentResponse.disposition'));{q1}
    result.ruleset := ParseCoding(obj.complex('http://hl7.org/fhir/EnrollmentResponse.ruleset'));{q3b}
    result.originalRuleset := ParseCoding(obj.complex('http://hl7.org/fhir/EnrollmentResponse.originalRuleset'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/EnrollmentResponse.created'));{q1}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EnrollmentResponse.organization'));{q3b}
    result.requestProvider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/EnrollmentResponse.requestProvider'));{q3b}
    result.requestOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EnrollmentResponse.requestOrganization'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEnrollmentResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEnrollmentResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EnrollmentResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EnrollmentResponse', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirEnrollmentRequest}(this, 'EnrollmentResponse', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnum(this, 'EnrollmentResponse', 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeString(this, 'EnrollmentResponse', 'disposition', elem.dispositionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(this, 'EnrollmentResponse', 'ruleset', elem.rulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(this, 'EnrollmentResponse', 'originalRuleset', elem.originalRulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(this, 'EnrollmentResponse', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'EnrollmentResponse', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(this, 'EnrollmentResponse', 'requestProvider', elem.requestProviderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(this, 'EnrollmentResponse', 'requestOrganization', elem.requestOrganizationElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
function TFHIRTurtleParser.ParseEpisodeOfCareStatusHistory(obj : TTurtleComplex) : TFhirEpisodeOfCareStatusHistory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEpisodeOfCareStatusHistory.create;
  try
    ParseEpisodeOfCareStatusHistoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEpisodeOfCareStatusHistoryProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCareStatusHistory);
begin
    ParseBackboneElementProperties(obj, result);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EpisodeOfCare.statusHistory.status'), CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum);
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/EpisodeOfCare.statusHistory.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEpisodeOfCareStatusHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCareStatusHistory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EpisodeOfCareStatusHistory'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'EpisodeOfCare.statusHistory', 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, false, -1);{x.d4}
  ComposePeriod(this, 'EpisodeOfCare.statusHistory', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEpisodeOfCareCareTeam(obj : TTurtleComplex) : TFhirEpisodeOfCareCareTeam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEpisodeOfCareCareTeam.create;
  try
    ParseEpisodeOfCareCareTeamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEpisodeOfCareCareTeamProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCareCareTeam);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.careTeam.role') do
      result.roleList.Add(parseCodeableConcept(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/EpisodeOfCare.careTeam.period'));{q3b}
    result.member := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/EpisodeOfCare.careTeam.member'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEpisodeOfCareCareTeam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCareCareTeam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EpisodeOfCareCareTeam'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'EpisodeOfCare.careTeam', 'role', elem.roleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'EpisodeOfCare.careTeam', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'EpisodeOfCare.careTeam', 'member', elem.memberElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEpisodeOfCare(obj : TTurtleComplex) : TFhirEpisodeOfCare;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEpisodeOfCare.create;
  try
    ParseEpisodeOfCareProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEpisodeOfCareProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCare);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EpisodeOfCare.status'), CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.statusHistory') do
      result.statusHistoryList.Add(parseEpisodeOfCareStatusHistory(item));
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.type') do
      result.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.condition') do
      result.conditionList.Add(parseReference{TFhirCondition}(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/EpisodeOfCare.patient'));{q3b}
    result.managingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EpisodeOfCare.managingOrganization'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/EpisodeOfCare.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.referralRequest') do
      result.referralRequestList.Add(parseReference{TFhirReferralRequest}(item));
    result.careManager := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/EpisodeOfCare.careManager'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.careTeam') do
      result.careTeamList.Add(parseEpisodeOfCareCareTeam(item));
end;

procedure TFHIRTurtleComposer.ComposeEpisodeOfCare(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCare; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EpisodeOfCare'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EpisodeOfCare', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'EpisodeOfCare', 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('statusHistory') then
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEpisodeOfCareStatusHistory(this, 'EpisodeOfCare', 'statusHistory', elem.statusHistoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'EpisodeOfCare', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('condition') then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'EpisodeOfCare', 'condition', elem.conditionList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'EpisodeOfCare', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'EpisodeOfCare', 'managingOrganization', elem.managingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'EpisodeOfCare', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('referralRequest') then
    for i := 0 to elem.referralRequestList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(this, 'EpisodeOfCare', 'referralRequest', elem.referralRequestList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('careManager') then
    ComposeReference{TFhirPractitioner}(this, 'EpisodeOfCare', 'careManager', elem.careManagerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('careTeam') then
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeEpisodeOfCareCareTeam(this, 'EpisodeOfCare', 'careTeam', elem.careTeamList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
function TFHIRTurtleParser.ParseExplanationOfBenefit(obj : TTurtleComplex) : TFhirExplanationOfBenefit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefit.create;
  try
    ParseExplanationOfBenefitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefit);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.request := ParseReference{TFhirClaim}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.request'));{q3b}
    result.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.outcome'), CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    result.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.disposition'));{q1}
    result.ruleset := ParseCoding(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.ruleset'));{q3b}
    result.originalRuleset := ParseCoding(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.originalRuleset'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.created'));{q1}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.organization'));{q3b}
    result.requestProvider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.requestProvider'));{q3b}
    result.requestOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.requestOrganization'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefit'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ExplanationOfBenefit', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirClaim}(this, 'ExplanationOfBenefit', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnum(this, 'ExplanationOfBenefit', 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeString(this, 'ExplanationOfBenefit', 'disposition', elem.dispositionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(this, 'ExplanationOfBenefit', 'ruleset', elem.rulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(this, 'ExplanationOfBenefit', 'originalRuleset', elem.originalRulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(this, 'ExplanationOfBenefit', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'ExplanationOfBenefit', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(this, 'ExplanationOfBenefit', 'requestProvider', elem.requestProviderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(this, 'ExplanationOfBenefit', 'requestOrganization', elem.requestOrganizationElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
function TFHIRTurtleParser.ParseFamilyMemberHistoryCondition(obj : TTurtleComplex) : TFhirFamilyMemberHistoryCondition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    ParseFamilyMemberHistoryConditionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseFamilyMemberHistoryConditionProperties(obj : TTurtleComplex; result : TFhirFamilyMemberHistoryCondition);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.condition.code'));{q3b}
    result.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.condition.outcome'));{q3b}
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.condition.onsetQuantity', item) then
      result.onset := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.condition.onsetRange', item) then
      result.onset := parseRange(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.condition.onsetPeriod', item) then
      result.onset := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.condition.onsetString', item) then
      result.onset := parseString(item);
    result.note := ParseAnnotation(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.condition.note'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeFamilyMemberHistoryCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFamilyMemberHistoryCondition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:FamilyMemberHistoryCondition'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'FamilyMemberHistory.condition', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'FamilyMemberHistory.condition', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirQuantity) {6} then
    ComposeQuantity(this, 'FamilyMemberHistory.condition', 'onsetQuantity', TFhirQuantity(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirRange) {6} then
    ComposeRange(this, 'FamilyMemberHistory.condition', 'onsetRange', TFhirRange(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(this, 'FamilyMemberHistory.condition', 'onsetPeriod', TFhirPeriod(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory.condition', 'onsetString', TFhirString(elem.onset), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(this, 'FamilyMemberHistory.condition', 'note', elem.noteElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseFamilyMemberHistory(obj : TTurtleComplex) : TFhirFamilyMemberHistory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirFamilyMemberHistory.create;
  try
    ParseFamilyMemberHistoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseFamilyMemberHistoryProperties(obj : TTurtleComplex; result : TFhirFamilyMemberHistory);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.patient'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.date'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.status'), CODES_TFhirHistoryStatusEnum, SYSTEMS_TFhirHistoryStatusEnum);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.name'));{q1}
    result.relationship := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.relationship'));{q3b}
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.bornPeriod', item) then
      result.born := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.bornDate', item) then
      result.born := parseDate(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.bornString', item) then
      result.born := parseString(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.ageQuantity', item) then
      result.age := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.ageRange', item) then
      result.age := parseRange(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.ageString', item) then
      result.age := parseString(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.deceasedQuantity', item) then
      result.deceased := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.deceasedRange', item) then
      result.deceased := parseRange(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.deceasedBoolean', item) then
      result.deceased := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.deceasedDate', item) then
      result.deceased := parseDate(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.deceasedString', item) then
      result.deceased := parseString(item);
    result.note := ParseAnnotation(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.note'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.condition') do
      result.conditionList.Add(parseFamilyMemberHistoryCondition(item));
end;

procedure TFHIRTurtleComposer.ComposeFamilyMemberHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFamilyMemberHistory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:FamilyMemberHistory'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'FamilyMemberHistory', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'FamilyMemberHistory', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'FamilyMemberHistory', 'date', elem.dateElement, false, -1);{x.2ea}
  ComposeEnum(this, 'FamilyMemberHistory', 'status', elem.StatusElement, CODES_TFhirHistoryStatusEnum, SYSTEMS_TFhirHistoryStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'FamilyMemberHistory', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'FamilyMemberHistory', 'relationship', elem.relationshipElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(this, 'FamilyMemberHistory', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and (elem.born is TFhirPeriod) {6} then
    ComposePeriod(this, 'FamilyMemberHistory', 'bornPeriod', TFhirPeriod(elem.born), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirDate) {6} then
    ComposeDate(this, 'FamilyMemberHistory', 'bornDate', TFhirDate(elem.born), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory', 'bornString', TFhirString(elem.born), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.age is TFhirQuantity) {6} then
    ComposeQuantity(this, 'FamilyMemberHistory', 'ageQuantity', TFhirQuantity(elem.age), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.age is TFhirRange) {6} then
    ComposeRange(this, 'FamilyMemberHistory', 'ageRange', TFhirRange(elem.age), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.age is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory', 'ageString', TFhirString(elem.age), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirQuantity) {6} then
    ComposeQuantity(this, 'FamilyMemberHistory', 'deceasedQuantity', TFhirQuantity(elem.deceased), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirRange) {6} then
    ComposeRange(this, 'FamilyMemberHistory', 'deceasedRange', TFhirRange(elem.deceased), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(this, 'FamilyMemberHistory', 'deceasedBoolean', TFhirBoolean(elem.deceased), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirDate) {6} then
    ComposeDate(this, 'FamilyMemberHistory', 'deceasedDate', TFhirDate(elem.deceased), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory', 'deceasedString', TFhirString(elem.deceased), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    ComposeAnnotation(this, 'FamilyMemberHistory', 'note', elem.noteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('condition') then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeFamilyMemberHistoryCondition(this, 'FamilyMemberHistory', 'condition', elem.conditionList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
function TFHIRTurtleParser.ParseFlag(obj : TTurtleComplex) : TFhirFlag;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirFlag.create;
  try
    ParseFlagProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseFlagProperties(obj : TTurtleComplex; result : TFhirFlag);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Flag.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Flag.category'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Flag.status'), CODES_TFhirFlagStatusEnum, SYSTEMS_TFhirFlagStatusEnum);
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Flag.period'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Flag.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Flag.encounter'));{q3b}
    result.author := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Flag.author'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Flag.code'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeFlag(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFlag; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Flag'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Flag', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'Flag', 'category', elem.categoryElement, false, -1);{x.2f}
  ComposeEnum(this, 'Flag', 'status', elem.StatusElement, CODES_TFhirFlagStatusEnum, SYSTEMS_TFhirFlagStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'Flag', 'period', elem.periodElement, false, -1);{x.2f}
  ComposeReference{Resource}(this, 'Flag', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Flag', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(this, 'Flag', 'author', elem.authorElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'Flag', 'code', elem.codeElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
function TFHIRTurtleParser.ParseGoalOutcome(obj : TTurtleComplex) : TFhirGoalOutcome;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGoalOutcome.create;
  try
    ParseGoalOutcomeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGoalOutcomeProperties(obj : TTurtleComplex; result : TFhirGoalOutcome);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Goal.outcome.resultCodeableConcept', item) then
      result.result := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Goal.outcome.resultReference', item) {a3} then
      result.result := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeGoalOutcome(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGoalOutcome; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GoalOutcome'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and (elem.result is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Goal.outcome', 'resultCodeableConcept', TFhirCodeableConcept(elem.result), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.result is TFhirReference) {2} then
    ComposeReference(this, 'Goal.outcome', 'resultReference', TFhirReference(elem.result), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseGoal(obj : TTurtleComplex) : TFhirGoal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGoal.create;
  try
    ParseGoalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGoalProperties(obj : TTurtleComplex; result : TFhirGoal);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Goal.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Goal.subject'));{q3b}
    if obj.has('http://hl7.org/fhir/Goal.startCodeableConcept', item) then
      result.start := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Goal.startDate', item) then
      result.start := parseDate(item);
    if obj.has('http://hl7.org/fhir/Goal.targetQuantity', item) then
      result.target := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Goal.targetDate', item) then
      result.target := parseDate(item);
    for item in obj.complexes('http://hl7.org/fhir/Goal.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Goal.description'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Goal.status'), CODES_TFhirGoalStatusEnum, SYSTEMS_TFhirGoalStatusEnum);
    result.statusDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Goal.statusDate'));{q1}
    result.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Goal.statusReason'));{q3b}
    result.author := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Goal.author'));{q3b}
    result.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Goal.priority'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Goal.addresses') do
      result.addressesList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/Goal.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Goal.outcome') do
      result.outcomeList.Add(parseGoalOutcome(item));
end;

procedure TFHIRTurtleComposer.ComposeGoal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGoal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Goal'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Goal', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'Goal', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Goal', 'startCodeableConcept', TFhirCodeableConcept(elem.start), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirDate) {6} then
    ComposeDate(this, 'Goal', 'startDate', TFhirDate(elem.start), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Goal', 'targetQuantity', TFhirQuantity(elem.target), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirDate) {6} then
    ComposeDate(this, 'Goal', 'targetDate', TFhirDate(elem.target), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Goal', 'category', elem.categoryList[i], false, i);{x.d3}
  ComposeString(this, 'Goal', 'description', elem.descriptionElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Goal', 'status', elem.StatusElement, CODES_TFhirGoalStatusEnum, SYSTEMS_TFhirGoalStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusDate') then
    ComposeDate(this, 'Goal', 'statusDate', elem.statusDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(this, 'Goal', 'statusReason', elem.statusReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(this, 'Goal', 'author', elem.authorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeCodeableConcept(this, 'Goal', 'priority', elem.priorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('addresses') then
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{Resource}(this, 'Goal', 'addresses', elem.addressesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Goal', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    for i := 0 to elem.outcomeList.Count - 1 do
      ComposeGoalOutcome(this, 'Goal', 'outcome', elem.outcomeList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
function TFHIRTurtleParser.ParseGroupCharacteristic(obj : TTurtleComplex) : TFhirGroupCharacteristic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGroupCharacteristic.create;
  try
    ParseGroupCharacteristicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGroupCharacteristicProperties(obj : TTurtleComplex; result : TFhirGroupCharacteristic);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Group.characteristic.code'));{q3b}
    if obj.has('http://hl7.org/fhir/Group.characteristic.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Group.characteristic.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Group.characteristic.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/Group.characteristic.valueBoolean', item) then
      result.value := parseBoolean(item);
    result.excludeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Group.characteristic.exclude'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Group.characteristic.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeGroupCharacteristic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroupCharacteristic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GroupCharacteristic'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Group.characteristic', 'code', elem.codeElement, false, -1);{x.2f}
  if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Group.characteristic', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Group.characteristic', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Group.characteristic', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Group.characteristic', 'valueBoolean', TFhirBoolean(elem.value), false, -1);{x.d9}
  ComposeBoolean(this, 'Group.characteristic', 'exclude', elem.excludeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Group.characteristic', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseGroupMember(obj : TTurtleComplex) : TFhirGroupMember;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGroupMember.create;
  try
    ParseGroupMemberProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGroupMemberProperties(obj : TTurtleComplex; result : TFhirGroupMember);
begin
    ParseBackboneElementProperties(obj, result);
    result.entity := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Group.member.entity'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Group.member.period'));{q3b}
    result.inactiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Group.member.inactive'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeGroupMember(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroupMember; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GroupMember'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'Group.member', 'entity', elem.entityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Group.member', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.inactive <> false)) then
    ComposeBoolean(this, 'Group.member', 'inactive', elem.inactiveElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseGroup(obj : TTurtleComplex) : TFhirGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGroup.create;
  try
    ParseGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGroupProperties(obj : TTurtleComplex; result : TFhirGroup);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Group.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Group.type'), CODES_TFhirGroupTypeEnum, SYSTEMS_TFhirGroupTypeEnum);
    result.actualElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Group.actual'));{q1}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Group.code'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Group.name'));{q1}
    result.quantityElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Group.quantity'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Group.characteristic') do
      result.characteristicList.Add(parseGroupCharacteristic(item));
    for item in obj.complexes('http://hl7.org/fhir/Group.member') do
      result.memberList.Add(parseGroupMember(item));
end;

procedure TFHIRTurtleComposer.ComposeGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Group'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Group', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Group', 'type', elem.Type_Element, CODES_TFhirGroupTypeEnum, SYSTEMS_TFhirGroupTypeEnum, false, -1);{x.d4}
  ComposeBoolean(this, 'Group', 'actual', elem.actualElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'Group', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Group', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeUnsignedInt(this, 'Group', 'quantity', elem.quantityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('characteristic') then
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeGroupCharacteristic(this, 'Group', 'characteristic', elem.characteristicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('member') then
    for i := 0 to elem.memberList.Count - 1 do
      ComposeGroupMember(this, 'Group', 'member', elem.memberList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
function TFHIRTurtleParser.ParseHealthcareServiceServiceType(obj : TTurtleComplex) : TFhirHealthcareServiceServiceType;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirHealthcareServiceServiceType.create;
  try
    ParseHealthcareServiceServiceTypeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseHealthcareServiceServiceTypeProperties(obj : TTurtleComplex; result : TFhirHealthcareServiceServiceType);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/HealthcareService.serviceType.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.serviceType.specialty') do
      result.specialtyList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeHealthcareServiceServiceType(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareServiceServiceType; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:HealthcareServiceServiceType'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'HealthcareService.serviceType', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService.serviceType', 'specialty', elem.specialtyList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseHealthcareServiceAvailableTime(obj : TTurtleComplex) : TFhirHealthcareServiceAvailableTime;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirHealthcareServiceAvailableTime.create;
  try
    ParseHealthcareServiceAvailableTimeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseHealthcareServiceAvailableTimeProperties(obj : TTurtleComplex; result : TFhirHealthcareServiceAvailableTime);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.availableTime.daysOfWeek') do
      result.daysOfWeekList.Add(parseEnum(item, CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum));
    result.allDayElement := ParseBoolean(obj.complex('http://hl7.org/fhir/HealthcareService.availableTime.allDay'));{q1}
    result.availableStartTimeElement := ParseTime(obj.complex('http://hl7.org/fhir/HealthcareService.availableTime.availableStartTime'));{q1}
    result.availableEndTimeElement := ParseTime(obj.complex('http://hl7.org/fhir/HealthcareService.availableTime.availableEndTime'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeHealthcareServiceAvailableTime(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareServiceAvailableTime; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:HealthcareServiceAvailableTime'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(this, 'HealthcareService.availableTime', 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(this, 'HealthcareService.availableTime', 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'HealthcareService.availableTime', 'allDay', elem.allDayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(this, 'HealthcareService.availableTime', 'availableStartTime', elem.availableStartTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(this, 'HealthcareService.availableTime', 'availableEndTime', elem.availableEndTimeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseHealthcareServiceNotAvailable(obj : TTurtleComplex) : TFhirHealthcareServiceNotAvailable;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirHealthcareServiceNotAvailable.create;
  try
    ParseHealthcareServiceNotAvailableProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseHealthcareServiceNotAvailableProperties(obj : TTurtleComplex; result : TFhirHealthcareServiceNotAvailable);
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.notAvailable.description'));{q1}
    result.during := ParsePeriod(obj.complex('http://hl7.org/fhir/HealthcareService.notAvailable.during'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeHealthcareServiceNotAvailable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareServiceNotAvailable; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:HealthcareServiceNotAvailable'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'HealthcareService.notAvailable', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'HealthcareService.notAvailable', 'during', elem.duringElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseHealthcareService(obj : TTurtleComplex) : TFhirHealthcareService;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirHealthcareService.create;
  try
    ParseHealthcareServiceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseHealthcareServiceProperties(obj : TTurtleComplex; result : TFhirHealthcareService);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.providedBy := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/HealthcareService.providedBy'));{q3b}
    result.serviceCategory := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/HealthcareService.serviceCategory'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.serviceType') do
      result.serviceTypeList.Add(parseHealthcareServiceServiceType(item));
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/HealthcareService.location'));{q3b}
    result.serviceNameElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.serviceName'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.comment'));{q1}
    result.extraDetailsElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.extraDetails'));{q1}
    result.photo := ParseAttachment(obj.complex('http://hl7.org/fhir/HealthcareService.photo'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.coverageArea') do
      result.coverageAreaList.Add(parseReference{TFhirLocation}(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.serviceProvisionCode') do
      result.serviceProvisionCodeList.Add(parseCodeableConcept(item));
    result.eligibility := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/HealthcareService.eligibility'));{q3b}
    result.eligibilityNoteElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.eligibilityNote'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.programName') do
      result.programNameList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.characteristic') do
      result.characteristicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.referralMethod') do
      result.referralMethodList.Add(parseCodeableConcept(item));
    result.publicKeyElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.publicKey'));{q1}
    result.appointmentRequiredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/HealthcareService.appointmentRequired'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.availableTime') do
      result.availableTimeList.Add(parseHealthcareServiceAvailableTime(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.notAvailable') do
      result.notAvailableList.Add(parseHealthcareServiceNotAvailable(item));
    result.availabilityExceptionsElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.availabilityExceptions'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeHealthcareService(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareService; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:HealthcareService'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'HealthcareService', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('providedBy') then
    ComposeReference{TFhirOrganization}(this, 'HealthcareService', 'providedBy', elem.providedByElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceCategory') then
    ComposeCodeableConcept(this, 'HealthcareService', 'serviceCategory', elem.serviceCategoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceType') then
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeHealthcareServiceServiceType(this, 'HealthcareService', 'serviceType', elem.serviceTypeList[i], false, i);{x.d3}
  ComposeReference{TFhirLocation}(this, 'HealthcareService', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceName') then
    ComposeString(this, 'HealthcareService', 'serviceName', elem.serviceNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comment') then
    ComposeString(this, 'HealthcareService', 'comment', elem.commentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('extraDetails') then
    ComposeString(this, 'HealthcareService', 'extraDetails', elem.extraDetailsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('photo') then
    ComposeAttachment(this, 'HealthcareService', 'photo', elem.photoElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'HealthcareService', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('coverageArea') then
    for i := 0 to elem.coverageAreaList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'HealthcareService', 'coverageArea', elem.coverageAreaList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('serviceProvisionCode') then
    for i := 0 to elem.serviceProvisionCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'serviceProvisionCode', elem.serviceProvisionCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('eligibility') then
    ComposeCodeableConcept(this, 'HealthcareService', 'eligibility', elem.eligibilityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('eligibilityNote') then
    ComposeString(this, 'HealthcareService', 'eligibilityNote', elem.eligibilityNoteElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('programName') then
    for i := 0 to elem.programNameList.Count - 1 do
      ComposeString(this, 'HealthcareService', 'programName', elem.programNameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('characteristic') then
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'characteristic', elem.characteristicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('referralMethod') then
    for i := 0 to elem.referralMethodList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'referralMethod', elem.referralMethodList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('publicKey') then
    ComposeString(this, 'HealthcareService', 'publicKey', elem.publicKeyElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('appointmentRequired') then
    ComposeBoolean(this, 'HealthcareService', 'appointmentRequired', elem.appointmentRequiredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('availableTime') then
    for i := 0 to elem.availableTimeList.Count - 1 do
      ComposeHealthcareServiceAvailableTime(this, 'HealthcareService', 'availableTime', elem.availableTimeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('notAvailable') then
    for i := 0 to elem.notAvailableList.Count - 1 do
      ComposeHealthcareServiceNotAvailable(this, 'HealthcareService', 'notAvailable', elem.notAvailableList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('availabilityExceptions') then
    ComposeString(this, 'HealthcareService', 'availabilityExceptions', elem.availabilityExceptionsElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
function TFHIRTurtleParser.ParseImagingObjectSelectionStudy(obj : TTurtleComplex) : TFhirImagingObjectSelectionStudy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingObjectSelectionStudy.create;
  try
    ParseImagingObjectSelectionStudyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingObjectSelectionStudyProperties(obj : TTurtleComplex; result : TFhirImagingObjectSelectionStudy);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.uidElement := ParseOid(obj.complex('http://hl7.org/fhir/ImagingObjectSelection.study.uid'));{q1}
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ImagingObjectSelection.study.url'));{q1}
    result.imagingStudy := ParseReference{TFhirImagingStudy}(obj.complex('http://hl7.org/fhir/ImagingObjectSelection.study.imagingStudy'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImagingObjectSelection.study.series') do
      result.seriesList.Add(parseImagingObjectSelectionStudySeries(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingObjectSelectionStudy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingObjectSelectionStudy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingObjectSelectionStudy'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeOid(this, 'ImagingObjectSelection.study', 'uid', elem.uidElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ImagingObjectSelection.study', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirImagingStudy}(this, 'ImagingObjectSelection.study', 'imagingStudy', elem.imagingStudyElement, false, -1);{x.2f}
  for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingObjectSelectionStudySeries(this, 'ImagingObjectSelection.study', 'series', elem.seriesList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImagingObjectSelectionStudySeries(obj : TTurtleComplex) : TFhirImagingObjectSelectionStudySeries;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingObjectSelectionStudySeries.create;
  try
    ParseImagingObjectSelectionStudySeriesProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingObjectSelectionStudySeriesProperties(obj : TTurtleComplex; result : TFhirImagingObjectSelectionStudySeries);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.uidElement := ParseOid(obj.complex('http://hl7.org/fhir/ImagingObjectSelection.study.series.uid'));{q1}
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ImagingObjectSelection.study.series.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImagingObjectSelection.study.series.instance') do
      result.instanceList.Add(parseImagingObjectSelectionStudySeriesInstance(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingObjectSelectionStudySeries(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingObjectSelectionStudySeries; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingObjectSelectionStudySeries'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(this, 'ImagingObjectSelection.study.series', 'uid', elem.uidElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ImagingObjectSelection.study.series', 'url', elem.urlElement, false, -1);{x.2ea}
  for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingObjectSelectionStudySeriesInstance(this, 'ImagingObjectSelection.study.series', 'instance', elem.instanceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImagingObjectSelectionStudySeriesInstance(obj : TTurtleComplex) : TFhirImagingObjectSelectionStudySeriesInstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingObjectSelectionStudySeriesInstance.create;
  try
    ParseImagingObjectSelectionStudySeriesInstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingObjectSelectionStudySeriesInstanceProperties(obj : TTurtleComplex; result : TFhirImagingObjectSelectionStudySeriesInstance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sopClassElement := ParseOid(obj.complex('http://hl7.org/fhir/ImagingObjectSelection.study.series.instance.sopClass'));{q1}
    result.uidElement := ParseOid(obj.complex('http://hl7.org/fhir/ImagingObjectSelection.study.series.instance.uid'));{q1}
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ImagingObjectSelection.study.series.instance.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImagingObjectSelection.study.series.instance.frames') do
      result.framesList.Add(parseImagingObjectSelectionStudySeriesInstanceFrames(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingObjectSelectionStudySeriesInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingObjectSelectionStudySeriesInstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingObjectSelectionStudySeriesInstance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeOid(this, 'ImagingObjectSelection.study.series.instance', 'sopClass', elem.sopClassElement, false, -1);{x.2ea}
  ComposeOid(this, 'ImagingObjectSelection.study.series.instance', 'uid', elem.uidElement, false, -1);{x.2ea}
  ComposeUri(this, 'ImagingObjectSelection.study.series.instance', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.framesList.Count - 1 do
      ComposeImagingObjectSelectionStudySeriesInstanceFrames(this, 'ImagingObjectSelection.study.series.instance', 'frames', elem.framesList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImagingObjectSelectionStudySeriesInstanceFrames(obj : TTurtleComplex) : TFhirImagingObjectSelectionStudySeriesInstanceFrames;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingObjectSelectionStudySeriesInstanceFrames.create;
  try
    ParseImagingObjectSelectionStudySeriesInstanceFramesProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingObjectSelectionStudySeriesInstanceFramesProperties(obj : TTurtleComplex; result : TFhirImagingObjectSelectionStudySeriesInstanceFrames);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ImagingObjectSelection.study.series.instance.frames.frameNumbers') do
      result.frameNumbersList.Add(parseUnsignedInt(item));
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ImagingObjectSelection.study.series.instance.frames.url'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImagingObjectSelectionStudySeriesInstanceFrames(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingObjectSelectionStudySeriesInstanceFrames'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.frameNumbersList.Count - 1 do
      ComposeUnsignedInt(this, 'ImagingObjectSelection.study.series.instance.frames', 'frameNumbers', elem.frameNumbersList[i], false, i);{x.d3}
  ComposeUri(this, 'ImagingObjectSelection.study.series.instance.frames', 'url', elem.urlElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImagingObjectSelection(obj : TTurtleComplex) : TFhirImagingObjectSelection;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingObjectSelection.create;
  try
    ParseImagingObjectSelectionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingObjectSelectionProperties(obj : TTurtleComplex; result : TFhirImagingObjectSelection);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.uidElement := ParseOid(obj.complex('http://hl7.org/fhir/ImagingObjectSelection.uid'));{q1}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ImagingObjectSelection.patient'));{q3b}
    result.title := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImagingObjectSelection.title'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImagingObjectSelection.description'));{q1}
    result.author := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ImagingObjectSelection.author'));{q3b}
    result.authoringTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImagingObjectSelection.authoringTime'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImagingObjectSelection.study') do
      result.studyList.Add(parseImagingObjectSelectionStudy(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingObjectSelection(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingObjectSelection; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingObjectSelection'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeOid(this, 'ImagingObjectSelection', 'uid', elem.uidElement, false, -1);{x.2ea}
  ComposeReference{TFhirPatient}(this, 'ImagingObjectSelection', 'patient', elem.patientElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'ImagingObjectSelection', 'title', elem.titleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'ImagingObjectSelection', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(this, 'ImagingObjectSelection', 'author', elem.authorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoringTime') then
    ComposeDateTime(this, 'ImagingObjectSelection', 'authoringTime', elem.authoringTimeElement, false, -1);{x.2ea}
  for i := 0 to elem.studyList.Count - 1 do
      ComposeImagingObjectSelectionStudy(this, 'ImagingObjectSelection', 'study', elem.studyList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
function TFHIRTurtleParser.ParseImagingStudySeries(obj : TTurtleComplex) : TFhirImagingStudySeries;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingStudySeries.create;
  try
    ParseImagingStudySeriesProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingStudySeriesProperties(obj : TTurtleComplex; result : TFhirImagingStudySeries);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.numberElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.series.number'));{q1}
    result.modality := ParseCoding(obj.complex('http://hl7.org/fhir/ImagingStudy.series.modality'));{q3b}
    result.uidElement := ParseOid(obj.complex('http://hl7.org/fhir/ImagingStudy.series.uid'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImagingStudy.series.description'));{q1}
    result.numberOfInstancesElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.series.numberOfInstances'));{q1}
    result.availabilityElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImagingStudy.series.availability'), CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ImagingStudy.series.url'));{q1}
    result.bodySite := ParseCoding(obj.complex('http://hl7.org/fhir/ImagingStudy.series.bodySite'));{q3b}
    result.laterality := ParseCoding(obj.complex('http://hl7.org/fhir/ImagingStudy.series.laterality'));{q3b}
    result.startedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImagingStudy.series.started'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.series.instance') do
      result.instanceList.Add(parseImagingStudySeriesInstance(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingStudySeries(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudySeries; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingStudySeries'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudy.series', 'number', elem.numberElement, false, -1);{x.2ea}
  ComposeCoding(this, 'ImagingStudy.series', 'modality', elem.modalityElement, false, -1);{x.2f}
  ComposeOid(this, 'ImagingStudy.series', 'uid', elem.uidElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImagingStudy.series', 'description', elem.descriptionElement, false, -1);{x.2ea}
  ComposeUnsignedInt(this, 'ImagingStudy.series', 'numberOfInstances', elem.numberOfInstancesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'ImagingStudy.series', 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ImagingStudy.series', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'ImagingStudy.series', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'ImagingStudy.series', 'laterality', elem.lateralityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ImagingStudy.series', 'started', elem.startedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingStudySeriesInstance(this, 'ImagingStudy.series', 'instance', elem.instanceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImagingStudySeriesInstance(obj : TTurtleComplex) : TFhirImagingStudySeriesInstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingStudySeriesInstance.create;
  try
    ParseImagingStudySeriesInstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingStudySeriesInstanceProperties(obj : TTurtleComplex; result : TFhirImagingStudySeriesInstance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.numberElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.series.instance.number'));{q1}
    result.uidElement := ParseOid(obj.complex('http://hl7.org/fhir/ImagingStudy.series.instance.uid'));{q1}
    result.sopClassElement := ParseOid(obj.complex('http://hl7.org/fhir/ImagingStudy.series.instance.sopClass'));{q1}
    result.type_Element := ParseString(obj.complex('http://hl7.org/fhir/ImagingStudy.series.instance.type'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ImagingStudy.series.instance.title'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.series.instance.content') do
      result.contentList.Add(parseAttachment(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingStudySeriesInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudySeriesInstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingStudySeriesInstance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudy.series.instance', 'number', elem.numberElement, false, -1);{x.2ea}
  ComposeOid(this, 'ImagingStudy.series.instance', 'uid', elem.uidElement, false, -1);{x.2ea}
  ComposeOid(this, 'ImagingStudy.series.instance', 'sopClass', elem.sopClassElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImagingStudy.series.instance', 'type', elem.type_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImagingStudy.series.instance', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.contentList.Count - 1 do
      ComposeAttachment(this, 'ImagingStudy.series.instance', 'content', elem.contentList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImagingStudy(obj : TTurtleComplex) : TFhirImagingStudy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingStudy.create;
  try
    ParseImagingStudyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingStudyProperties(obj : TTurtleComplex; result : TFhirImagingStudy);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.startedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImagingStudy.started'));{q1}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ImagingStudy.patient'));{q3b}
    result.uidElement := ParseOid(obj.complex('http://hl7.org/fhir/ImagingStudy.uid'));{q1}
    result.accession := ParseIdentifier(obj.complex('http://hl7.org/fhir/ImagingStudy.accession'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.order') do
      result.orderList.Add(parseReference{TFhirDiagnosticOrder}(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.modalityList') do
      result.modalityListList.Add(parseCoding(item));
    result.referrer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ImagingStudy.referrer'));{q3b}
    result.availabilityElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImagingStudy.availability'), CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ImagingStudy.url'));{q1}
    result.numberOfSeriesElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.numberOfSeries'));{q1}
    result.numberOfInstancesElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.numberOfInstances'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.procedure') do
      result.procedure_List.Add(parseReference{TFhirProcedure}(item));
    result.interpreter := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ImagingStudy.interpreter'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImagingStudy.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.series') do
      result.seriesList.Add(parseImagingStudySeries(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingStudy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingStudy'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('started') then
    ComposeDateTime(this, 'ImagingStudy', 'started', elem.startedElement, false, -1);{x.2ea}
  ComposeReference{TFhirPatient}(this, 'ImagingStudy', 'patient', elem.patientElement, false, -1);{x.2f}
  ComposeOid(this, 'ImagingStudy', 'uid', elem.uidElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accession') then
    ComposeIdentifier(this, 'ImagingStudy', 'accession', elem.accessionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ImagingStudy', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('order') then
    for i := 0 to elem.orderList.Count - 1 do
      ComposeReference{TFhirDiagnosticOrder}(this, 'ImagingStudy', 'order', elem.orderList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('modalityList') then
    for i := 0 to elem.modalityListList.Count - 1 do
      ComposeCoding(this, 'ImagingStudy', 'modalityList', elem.modalityListList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referrer') then
    ComposeReference{TFhirPractitioner}(this, 'ImagingStudy', 'referrer', elem.referrerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('availability') then
    ComposeEnum(this, 'ImagingStudy', 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'ImagingStudy', 'url', elem.urlElement, false, -1);{x.2ea}
  ComposeUnsignedInt(this, 'ImagingStudy', 'numberOfSeries', elem.numberOfSeriesElement, false, -1);{x.2ea}
  ComposeUnsignedInt(this, 'ImagingStudy', 'numberOfInstances', elem.numberOfInstancesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('procedure_') then
    for i := 0 to elem.procedure_List.Count - 1 do
      ComposeReference{TFhirProcedure}(this, 'ImagingStudy', 'procedure', elem.procedure_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('interpreter') then
    ComposeReference{TFhirPractitioner}(this, 'ImagingStudy', 'interpreter', elem.interpreterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'ImagingStudy', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('series') then
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingStudySeries(this, 'ImagingStudy', 'series', elem.seriesList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
function TFHIRTurtleParser.ParseImmunizationExplanation(obj : TTurtleComplex) : TFhirImmunizationExplanation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationExplanation.create;
  try
    ParseImmunizationExplanationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationExplanationProperties(obj : TTurtleComplex; result : TFhirImmunizationExplanation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Immunization.explanation.reason') do
      result.reasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.explanation.reasonNotGiven') do
      result.reasonNotGivenList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeImmunizationExplanation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationExplanation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationExplanation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Immunization.explanation', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(this, 'Immunization.explanation', 'reasonNotGiven', elem.reasonNotGivenList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImmunizationReaction(obj : TTurtleComplex) : TFhirImmunizationReaction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationReaction.create;
  try
    ParseImmunizationReactionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationReactionProperties(obj : TTurtleComplex; result : TFhirImmunizationReaction);
begin
    ParseBackboneElementProperties(obj, result);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Immunization.reaction.date'));{q1}
    result.detail := ParseReference{TFhirObservation}(obj.complex('http://hl7.org/fhir/Immunization.reaction.detail'));{q3b}
    result.reportedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Immunization.reaction.reported'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImmunizationReaction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationReaction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationReaction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Immunization.reaction', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirObservation}(this, 'Immunization.reaction', 'detail', elem.detailElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Immunization.reaction', 'reported', elem.reportedElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImmunizationVaccinationProtocol(obj : TTurtleComplex) : TFhirImmunizationVaccinationProtocol;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    ParseImmunizationVaccinationProtocolProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationVaccinationProtocolProperties(obj : TTurtleComplex; result : TFhirImmunizationVaccinationProtocol);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.doseSequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Immunization.vaccinationProtocol.doseSequence'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Immunization.vaccinationProtocol.description'));{q1}
    result.authority := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Immunization.vaccinationProtocol.authority'));{q3b}
    result.seriesElement := ParseString(obj.complex('http://hl7.org/fhir/Immunization.vaccinationProtocol.series'));{q1}
    result.seriesDosesElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Immunization.vaccinationProtocol.seriesDoses'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Immunization.vaccinationProtocol.targetDisease') do
      result.targetDiseaseList.Add(parseCodeableConcept(item));
    result.doseStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.vaccinationProtocol.doseStatus'));{q3b}
    result.doseStatusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.vaccinationProtocol.doseStatusReason'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeImmunizationVaccinationProtocol(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationVaccinationProtocol; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationVaccinationProtocol'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Immunization.vaccinationProtocol', 'doseSequence', elem.doseSequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Immunization.vaccinationProtocol', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Immunization.vaccinationProtocol', 'authority', elem.authorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Immunization.vaccinationProtocol', 'series', elem.seriesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Immunization.vaccinationProtocol', 'seriesDoses', elem.seriesDosesElement, false, -1);{x.2ea}
  for i := 0 to elem.targetDiseaseList.Count - 1 do
      ComposeCodeableConcept(this, 'Immunization.vaccinationProtocol', 'targetDisease', elem.targetDiseaseList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Immunization.vaccinationProtocol', 'doseStatus', elem.doseStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Immunization.vaccinationProtocol', 'doseStatusReason', elem.doseStatusReasonElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseImmunization(obj : TTurtleComplex) : TFhirImmunization;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunization.create;
  try
    ParseImmunizationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationProperties(obj : TTurtleComplex; result : TFhirImmunization);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Immunization.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Immunization.status'), CODES_TFhirMedicationAdminStatusEnum, SYSTEMS_TFhirMedicationAdminStatusEnum);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Immunization.date'));{q1}
    result.vaccineCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.vaccineCode'));{q3b}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Immunization.patient'));{q3b}
    result.wasNotGivenElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Immunization.wasNotGiven'));{q1}
    result.reportedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Immunization.reported'));{q1}
    result.performer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Immunization.performer'));{q3b}
    result.requester := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Immunization.requester'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Immunization.encounter'));{q3b}
    result.manufacturer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Immunization.manufacturer'));{q3b}
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Immunization.location'));{q3b}
    result.lotNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Immunization.lotNumber'));{q1}
    result.expirationDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Immunization.expirationDate'));{q1}
    result.site := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.site'));{q3b}
    result.route := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.route'));{q3b}
    result.doseQuantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Immunization.doseQuantity'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Immunization.note') do
      result.noteList.Add(parseAnnotation(item));
    result.explanation := ParseImmunizationExplanation(obj.complex('http://hl7.org/fhir/Immunization.explanation'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Immunization.reaction') do
      result.reactionList.Add(parseImmunizationReaction(item));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.vaccinationProtocol') do
      result.vaccinationProtocolList.Add(parseImmunizationVaccinationProtocol(item));
end;

procedure TFHIRTurtleComposer.ComposeImmunization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunization; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Immunization'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Immunization', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Immunization', 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum, SYSTEMS_TFhirMedicationAdminStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('date') then
    ComposeDateTime(this, 'Immunization', 'date', elem.dateElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'Immunization', 'vaccineCode', elem.vaccineCodeElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'Immunization', 'patient', elem.patientElement, false, -1);{x.2f}
  ComposeBoolean(this, 'Immunization', 'wasNotGiven', elem.wasNotGivenElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'Immunization', 'reported', elem.reportedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('performer') then
    ComposeReference{TFhirPractitioner}(this, 'Immunization', 'performer', elem.performerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('requester') then
    ComposeReference{TFhirPractitioner}(this, 'Immunization', 'requester', elem.requesterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Immunization', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('manufacturer') then
    ComposeReference{TFhirOrganization}(this, 'Immunization', 'manufacturer', elem.manufacturerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'Immunization', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeString(this, 'Immunization', 'lotNumber', elem.lotNumberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('expirationDate') then
    ComposeDate(this, 'Immunization', 'expirationDate', elem.expirationDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('site') then
    ComposeCodeableConcept(this, 'Immunization', 'site', elem.siteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('route') then
    ComposeCodeableConcept(this, 'Immunization', 'route', elem.routeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('doseQuantity') then
    ComposeQuantity(this, 'Immunization', 'doseQuantity', elem.doseQuantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Immunization', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('explanation') then
    ComposeImmunizationExplanation(this, 'Immunization', 'explanation', elem.explanationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('reaction') then
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeImmunizationReaction(this, 'Immunization', 'reaction', elem.reactionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('vaccinationProtocol') then
    for i := 0 to elem.vaccinationProtocolList.Count - 1 do
      ComposeImmunizationVaccinationProtocol(this, 'Immunization', 'vaccinationProtocol', elem.vaccinationProtocolList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
function TFHIRTurtleParser.ParseImmunizationRecommendationRecommendation(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    ParseImmunizationRecommendationRecommendationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationRecommendationRecommendationProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendationRecommendation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.date'));{q1}
    result.vaccineCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.vaccineCode'));{q3b}
    result.doseNumberElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.doseNumber'));{q1}
    result.forecastStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.forecastStatus'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.dateCriterion') do
      result.dateCriterionList.Add(parseImmunizationRecommendationRecommendationDateCriterion(item));
    result.protocol := ParseImmunizationRecommendationRecommendationProtocol(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.protocol'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.supportingImmunization') do
      result.supportingImmunizationList.Add(parseReference{TFhirImmunization}(item));
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.supportingPatientInformation') do
      result.supportingPatientInformationList.Add(parseReference{Resource}(item));
end;

procedure TFHIRTurtleComposer.ComposeImmunizationRecommendationRecommendation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationRecommendationRecommendation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeDateTime(this, 'ImmunizationRecommendation.recommendation', 'date', elem.dateElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation', 'vaccineCode', elem.vaccineCodeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ImmunizationRecommendation.recommendation', 'doseNumber', elem.doseNumberElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation', 'forecastStatus', elem.forecastStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dateCriterionList.Count - 1 do
      ComposeImmunizationRecommendationRecommendationDateCriterion(this, 'ImmunizationRecommendation.recommendation', 'dateCriterion', elem.dateCriterionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeImmunizationRecommendationRecommendationProtocol(this, 'ImmunizationRecommendation.recommendation', 'protocol', elem.protocolElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.supportingImmunizationList.Count - 1 do
      ComposeReference{TFhirImmunization}(this, 'ImmunizationRecommendation.recommendation', 'supportingImmunization', elem.supportingImmunizationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.supportingPatientInformationList.Count - 1 do
      ComposeReference{Resource}(this, 'ImmunizationRecommendation.recommendation', 'supportingPatientInformation', elem.supportingPatientInformationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImmunizationRecommendationRecommendationDateCriterion(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    ParseImmunizationRecommendationRecommendationDateCriterionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationRecommendationRecommendationDateCriterionProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.dateCriterion.code'));{q3b}
    result.valueElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.dateCriterion.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendationDateCriterion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationRecommendationRecommendationDateCriterion'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation.dateCriterion', 'code', elem.codeElement, false, -1);{x.2f}
  ComposeDateTime(this, 'ImmunizationRecommendation.recommendation.dateCriterion', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImmunizationRecommendationRecommendationProtocol(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    ParseImmunizationRecommendationRecommendationProtocolProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationRecommendationRecommendationProtocolProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendationRecommendationProtocol);
begin
    ParseBackboneElementProperties(obj, result);
    result.doseSequenceElement := ParseInteger(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.protocol.doseSequence'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.protocol.description'));{q1}
    result.authority := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.protocol.authority'));{q3b}
    result.seriesElement := ParseString(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.protocol.series'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImmunizationRecommendationRecommendationProtocol(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendationProtocol; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationRecommendationRecommendationProtocol'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'ImmunizationRecommendation.recommendation.protocol', 'doseSequence', elem.doseSequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImmunizationRecommendation.recommendation.protocol', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'ImmunizationRecommendation.recommendation.protocol', 'authority', elem.authorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImmunizationRecommendation.recommendation.protocol', 'series', elem.seriesElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImmunizationRecommendation(obj : TTurtleComplex) : TFhirImmunizationRecommendation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationRecommendation.create;
  try
    ParseImmunizationRecommendationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationRecommendationProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.patient'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation') do
      result.recommendationList.Add(parseImmunizationRecommendationRecommendation(item));
end;

procedure TFHIRTurtleComposer.ComposeImmunizationRecommendation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationRecommendation'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ImmunizationRecommendation', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'ImmunizationRecommendation', 'patient', elem.patientElement, false, -1);{x.2f}
  for i := 0 to elem.recommendationList.Count - 1 do
      ComposeImmunizationRecommendationRecommendation(this, 'ImmunizationRecommendation', 'recommendation', elem.recommendationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
function TFHIRTurtleParser.ParseImplementationGuideContact(obj : TTurtleComplex) : TFhirImplementationGuideContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideContact.create;
  try
    ParseImplementationGuideContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideContactProperties(obj : TTurtleComplex; result : TFhirImplementationGuideContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.contact.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.contact.telecom') do
      result.telecomList.Add(parseContactPoint(item));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideContact'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImplementationGuide.contact', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'ImplementationGuide.contact', 'telecom', elem.telecomList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImplementationGuideDependency(obj : TTurtleComplex) : TFhirImplementationGuideDependency;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideDependency.create;
  try
    ParseImplementationGuideDependencyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideDependencyProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDependency);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.dependency.type'), CODES_TFhirGuideDependencyTypeEnum, SYSTEMS_TFhirGuideDependencyTypeEnum);
    result.uriElement := ParseUri(obj.complex('http://hl7.org/fhir/ImplementationGuide.dependency.uri'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideDependency(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDependency; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideDependency'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'ImplementationGuide.dependency', 'type', elem.Type_Element, CODES_TFhirGuideDependencyTypeEnum, SYSTEMS_TFhirGuideDependencyTypeEnum, false, -1);{x.d4}
  ComposeUri(this, 'ImplementationGuide.dependency', 'uri', elem.uriElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImplementationGuidePackage(obj : TTurtleComplex) : TFhirImplementationGuidePackage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuidePackage.create;
  try
    ParseImplementationGuidePackageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuidePackageProperties(obj : TTurtleComplex; result : TFhirImplementationGuidePackage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.package.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.package.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.package.resource') do
      result.resourceList.Add(parseImplementationGuidePackageResource(item));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuidePackage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuidePackage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuidePackage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'ImplementationGuide.package', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuide.package', 'description', elem.descriptionElement, false, -1);{x.2ea}
  for i := 0 to elem.resourceList.Count - 1 do
      ComposeImplementationGuidePackageResource(this, 'ImplementationGuide.package', 'resource', elem.resourceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImplementationGuidePackageResource(obj : TTurtleComplex) : TFhirImplementationGuidePackageResource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuidePackageResource.create;
  try
    ParseImplementationGuidePackageResourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuidePackageResourceProperties(obj : TTurtleComplex; result : TFhirImplementationGuidePackageResource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.purposeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.package.resource.purpose'), CODES_TFhirGuideResourcePurposeEnum, SYSTEMS_TFhirGuideResourcePurposeEnum);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.package.resource.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.package.resource.description'));{q1}
    result.acronymElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.package.resource.acronym'));{q1}
    if obj.has('http://hl7.org/fhir/ImplementationGuide.package.resource.sourceReference', item) {a3} then
      result.source := ParseReference(item);
    if obj.has('http://hl7.org/fhir/ImplementationGuide.package.resource.sourceUri', item) then
      result.source := parseUri(item);
    result.exampleFor := ParseReference{TFhirStructureDefinition}(obj.complex('http://hl7.org/fhir/ImplementationGuide.package.resource.exampleFor'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuidePackageResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuidePackageResource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuidePackageResource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'ImplementationGuide.package.resource', 'purpose', elem.PurposeElement, CODES_TFhirGuideResourcePurposeEnum, SYSTEMS_TFhirGuideResourcePurposeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImplementationGuide.package.resource', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuide.package.resource', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuide.package.resource', 'acronym', elem.acronymElement, false, -1);{x.2ea}
  if (elem.source is TFhirReference) {2} then
    ComposeReference(this, 'ImplementationGuide.package.resource', 'sourceReference', TFhirReference(elem.source), false,-1){x.d8}
  else if (elem.source is TFhirUri) {6} then
    ComposeUri(this, 'ImplementationGuide.package.resource', 'sourceUri', TFhirUri(elem.source), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(this, 'ImplementationGuide.package.resource', 'exampleFor', elem.exampleForElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseImplementationGuideGlobal(obj : TTurtleComplex) : TFhirImplementationGuideGlobal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideGlobal.create;
  try
    ParseImplementationGuideGlobalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideGlobalProperties(obj : TTurtleComplex; result : TFhirImplementationGuideGlobal);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.global.type'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.profile := ParseReference{TFhirStructureDefinition}(obj.complex('http://hl7.org/fhir/ImplementationGuide.global.profile'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideGlobal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideGlobal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideGlobal'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'ImplementationGuide.global', 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  ComposeReference{TFhirStructureDefinition}(this, 'ImplementationGuide.global', 'profile', elem.profileElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseImplementationGuidePage(obj : TTurtleComplex) : TFhirImplementationGuidePage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuidePage.create;
  try
    ParseImplementationGuidePageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuidePageProperties(obj : TTurtleComplex; result : TFhirImplementationGuidePage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sourceElement := ParseUri(obj.complex('http://hl7.org/fhir/ImplementationGuide.page.source'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.page.name'));{q1}
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.page.kind'), CODES_TFhirGuidePageKindEnum, SYSTEMS_TFhirGuidePageKindEnum);
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.page.type') do
      result.type_.Add(parseEnum(item, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.page.package') do
      result.packageList.Add(parseString(item));
    result.formatElement := ParseCode(obj.complex('http://hl7.org/fhir/ImplementationGuide.page.format'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.page.page') do
      result.pageList.Add(parseImplementationGuidePage(item));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuidePage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuidePage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuidePage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeUri(this, 'ImplementationGuide.page', 'source', elem.sourceElement, false, -1);{x.2ea}
  ComposeString(this, 'ImplementationGuide.page', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ImplementationGuide.page', 'kind', elem.KindElement, CODES_TFhirGuidePageKindEnum, SYSTEMS_TFhirGuidePageKindEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_.Count - 1 do
      ComposeEnum(this, 'ImplementationGuide.page', 'type', elem.type_[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_.Count - 1 do
      ComposeEnum(this, 'ImplementationGuide.page', 'type', elem.type_[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.packageList.Count - 1 do
      ComposeString(this, 'ImplementationGuide.page', 'package', elem.packageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ImplementationGuide.page', 'format', elem.formatElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.pageList.Count - 1 do
      ComposeImplementationGuidePage(this, 'ImplementationGuide.page', 'page', elem.pageList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImplementationGuide(obj : TTurtleComplex) : TFhirImplementationGuide;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuide.create;
  try
    ParseImplementationGuideProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideProperties(obj : TTurtleComplex; result : TFhirImplementationGuide);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ImplementationGuide.url'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.status'), CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ImplementationGuide.experimental'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.contact') do
      result.contactList.Add(parseImplementationGuideContact(item));
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImplementationGuide.date'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.useContext') do
      result.useContextList.Add(parseCodeableConcept(item));
    result.copyrightElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.copyright'));{q1}
    result.fhirVersionElement := ParseId(obj.complex('http://hl7.org/fhir/ImplementationGuide.fhirVersion'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.dependency') do
      result.dependencyList.Add(parseImplementationGuideDependency(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.package') do
      result.packageList.Add(parseImplementationGuidePackage(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.global') do
      result.globalList.Add(parseImplementationGuideGlobal(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.binary') do
      result.binaryList.Add(parseUri(item));
    result.page := ParseImplementationGuidePage(obj.complex('http://hl7.org/fhir/ImplementationGuide.page'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuide(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuide; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuide'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeUri(this, 'ImplementationGuide', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'ImplementationGuide', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'ImplementationGuide', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ImplementationGuide', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'ImplementationGuide', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'ImplementationGuide', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeImplementationGuideContact(this, 'ImplementationGuide', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ImplementationGuide', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'ImplementationGuide', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(this, 'ImplementationGuide', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeString(this, 'ImplementationGuide', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fhirVersion') then
    ComposeId(this, 'ImplementationGuide', 'fhirVersion', elem.fhirVersionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dependency') then
    for i := 0 to elem.dependencyList.Count - 1 do
      ComposeImplementationGuideDependency(this, 'ImplementationGuide', 'dependency', elem.dependencyList[i], false, i);{x.d3}
  for i := 0 to elem.packageList.Count - 1 do
      ComposeImplementationGuidePackage(this, 'ImplementationGuide', 'package', elem.packageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('global') then
    for i := 0 to elem.globalList.Count - 1 do
      ComposeImplementationGuideGlobal(this, 'ImplementationGuide', 'global', elem.globalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('binary') then
    for i := 0 to elem.binaryList.Count - 1 do
      ComposeUri(this, 'ImplementationGuide', 'binary', elem.binaryList[i], false, i);{x.d3}
  ComposeImplementationGuidePage(this, 'ImplementationGuide', 'page', elem.pageElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
function TFHIRTurtleParser.ParseListEntry(obj : TTurtleComplex) : TFhirListEntry;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirListEntry.create;
  try
    ParseListEntryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseListEntryProperties(obj : TTurtleComplex; result : TFhirListEntry);
begin
    ParseBackboneElementProperties(obj, result);
    result.flag := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/List.entry.flag'));{q3b}
    result.deletedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/List.entry.deleted'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/List.entry.date'));{q1}
    result.item := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/List.entry.item'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeListEntry(parent :  TTurtleComplex; parentType, name : String; elem : TFhirListEntry; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ListEntry'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'List.entry', 'flag', elem.flagElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.deleted <> false)) then
    ComposeBoolean(this, 'List.entry', 'deleted', elem.deletedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'List.entry', 'date', elem.dateElement, false, -1);{x.2ea}
  ComposeReference{TFhirReference}(this, 'List.entry', 'item', elem.itemElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseList(obj : TTurtleComplex) : TFhirList;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirList.create;
  try
    ParseListProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseListProperties(obj : TTurtleComplex; result : TFhirList);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/List.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/List.title'));{q1}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/List.code'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/List.subject'));{q3b}
    result.source := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/List.source'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/List.encounter'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/List.status'), CODES_TFhirListStatusEnum, SYSTEMS_TFhirListStatusEnum);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/List.date'));{q1}
    result.orderedBy := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/List.orderedBy'));{q3b}
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/List.mode'), CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum);
    result.noteElement := ParseString(obj.complex('http://hl7.org/fhir/List.note'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/List.entry') do
      result.entryList.Add(parseListEntry(item));
    result.emptyReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/List.emptyReason'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeList(parent :  TTurtleComplex; parentType, name : String; elem : TFhirList; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:List'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'List', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'List', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'List', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'List', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{Resource}(this, 'List', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'List', 'encounter', elem.encounterElement, false, -1);{x.2f}
  ComposeEnum(this, 'List', 'status', elem.StatusElement, CODES_TFhirListStatusEnum, SYSTEMS_TFhirListStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'List', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('orderedBy') then
    ComposeCodeableConcept(this, 'List', 'orderedBy', elem.orderedByElement, false, -1);{x.2f}
  ComposeEnum(this, 'List', 'mode', elem.ModeElement, CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    ComposeString(this, 'List', 'note', elem.noteElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('entry') then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeListEntry(this, 'List', 'entry', elem.entryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('emptyReason') then
    ComposeCodeableConcept(this, 'List', 'emptyReason', elem.emptyReasonElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
function TFHIRTurtleParser.ParseLocationPosition(obj : TTurtleComplex) : TFhirLocationPosition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLocationPosition.create;
  try
    ParseLocationPositionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLocationPositionProperties(obj : TTurtleComplex; result : TFhirLocationPosition);
begin
    ParseBackboneElementProperties(obj, result);
    result.longitudeElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Location.position.longitude'));{q1}
    result.latitudeElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Location.position.latitude'));{q1}
    result.altitudeElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Location.position.altitude'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeLocationPosition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLocationPosition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:LocationPosition'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeDecimal(this, 'Location.position', 'longitude', elem.longitudeElement, false, -1);{x.2ea}
  ComposeDecimal(this, 'Location.position', 'latitude', elem.latitudeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Location.position', 'altitude', elem.altitudeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseLocation(obj : TTurtleComplex) : TFhirLocation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLocation.create;
  try
    ParseLocationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLocationProperties(obj : TTurtleComplex; result : TFhirLocation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Location.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Location.status'), CODES_TFhirLocationStatusEnum, SYSTEMS_TFhirLocationStatusEnum);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Location.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Location.description'));{q1}
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Location.mode'), CODES_TFhirLocationModeEnum, SYSTEMS_TFhirLocationModeEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Location.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Location.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.address := ParseAddress(obj.complex('http://hl7.org/fhir/Location.address'));{q3b}
    result.physicalType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Location.physicalType'));{q3b}
    result.position := ParseLocationPosition(obj.complex('http://hl7.org/fhir/Location.position'));{q3b}
    result.managingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Location.managingOrganization'));{q3b}
    result.partOf := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Location.partOf'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeLocation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLocation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Location'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Location', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Location', 'status', elem.StatusElement, CODES_TFhirLocationStatusEnum, SYSTEMS_TFhirLocationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Location', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'Location', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('mode') then
    ComposeEnum(this, 'Location', 'mode', elem.ModeElement, CODES_TFhirLocationModeEnum, SYSTEMS_TFhirLocationModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Location', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Location', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('address') then
    ComposeAddress(this, 'Location', 'address', elem.addressElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('physicalType') then
    ComposeCodeableConcept(this, 'Location', 'physicalType', elem.physicalTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('position') then
    ComposeLocationPosition(this, 'Location', 'position', elem.positionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'Location', 'managingOrganization', elem.managingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    ComposeReference{TFhirLocation}(this, 'Location', 'partOf', elem.partOfElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
function TFHIRTurtleParser.ParseMedia(obj : TTurtleComplex) : TFhirMedia;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedia.create;
  try
    ParseMediaProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMediaProperties(obj : TTurtleComplex; result : TFhirMedia);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Media.type'), CODES_TFhirDigitalMediaTypeEnum, SYSTEMS_TFhirDigitalMediaTypeEnum);
    result.subtype := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Media.subtype'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Media.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Media.subject'));{q3b}
    result.operator := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Media.operator'));{q3b}
    result.view := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Media.view'));{q3b}
    result.deviceNameElement := ParseString(obj.complex('http://hl7.org/fhir/Media.deviceName'));{q1}
    result.heightElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Media.height'));{q1}
    result.widthElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Media.width'));{q1}
    result.framesElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Media.frames'));{q1}
    result.durationElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Media.duration'));{q1}
    result.content := ParseAttachment(obj.complex('http://hl7.org/fhir/Media.content'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedia(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedia; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Media'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeEnum(this, 'Media', 'type', elem.Type_Element, CODES_TFhirDigitalMediaTypeEnum, SYSTEMS_TFhirDigitalMediaTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subtype') then
    ComposeCodeableConcept(this, 'Media', 'subtype', elem.subtypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Media', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'Media', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operator') then
    ComposeReference{TFhirPractitioner}(this, 'Media', 'operator', elem.operatorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('view') then
    ComposeCodeableConcept(this, 'Media', 'view', elem.viewElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('deviceName') then
    ComposeString(this, 'Media', 'deviceName', elem.deviceNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('height') then
    ComposePositiveInt(this, 'Media', 'height', elem.heightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('width') then
    ComposePositiveInt(this, 'Media', 'width', elem.widthElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.frames <> '1')) and doCompose('frames') then
    ComposePositiveInt(this, 'Media', 'frames', elem.framesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('duration') then
    ComposeUnsignedInt(this, 'Media', 'duration', elem.durationElement, false, -1);{x.2ea}
  ComposeAttachment(this, 'Media', 'content', elem.contentElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
function TFHIRTurtleParser.ParseMedicationProduct(obj : TTurtleComplex) : TFhirMedicationProduct;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationProduct.create;
  try
    ParseMedicationProductProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationProductProperties(obj : TTurtleComplex; result : TFhirMedicationProduct);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.form := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Medication.product.form'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Medication.product.ingredient') do
      result.ingredientList.Add(parseMedicationProductIngredient(item));
    for item in obj.complexes('http://hl7.org/fhir/Medication.product.batch') do
      result.batchList.Add(parseMedicationProductBatch(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationProduct(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationProduct; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationProduct'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Medication.product', 'form', elem.formElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeMedicationProductIngredient(this, 'Medication.product', 'ingredient', elem.ingredientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.batchList.Count - 1 do
      ComposeMedicationProductBatch(this, 'Medication.product', 'batch', elem.batchList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicationProductIngredient(obj : TTurtleComplex) : TFhirMedicationProductIngredient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationProductIngredient.create;
  try
    ParseMedicationProductIngredientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationProductIngredientProperties(obj : TTurtleComplex; result : TFhirMedicationProductIngredient);
begin
    ParseBackboneElementProperties(obj, result);
    result.item := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Medication.product.ingredient.item'));{q3b}
    result.amount := ParseRatio(obj.complex('http://hl7.org/fhir/Medication.product.ingredient.amount'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationProductIngredient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationProductIngredient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationProductIngredient'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'Medication.product.ingredient', 'item', elem.itemElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeRatio(this, 'Medication.product.ingredient', 'amount', elem.amountElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationProductBatch(obj : TTurtleComplex) : TFhirMedicationProductBatch;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationProductBatch.create;
  try
    ParseMedicationProductBatchProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationProductBatchProperties(obj : TTurtleComplex; result : TFhirMedicationProductBatch);
begin
    ParseBackboneElementProperties(obj, result);
    result.lotNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Medication.product.batch.lotNumber'));{q1}
    result.expirationDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Medication.product.batch.expirationDate'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMedicationProductBatch(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationProductBatch; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationProductBatch'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Medication.product.batch', 'lotNumber', elem.lotNumberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Medication.product.batch', 'expirationDate', elem.expirationDateElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMedicationPackage(obj : TTurtleComplex) : TFhirMedicationPackage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationPackage.create;
  try
    ParseMedicationPackageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationPackageProperties(obj : TTurtleComplex; result : TFhirMedicationPackage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.container := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Medication.package.container'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Medication.package.content') do
      result.contentList.Add(parseMedicationPackageContent(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationPackage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationPackage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationPackage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Medication.package', 'container', elem.containerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.contentList.Count - 1 do
      ComposeMedicationPackageContent(this, 'Medication.package', 'content', elem.contentList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicationPackageContent(obj : TTurtleComplex) : TFhirMedicationPackageContent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationPackageContent.create;
  try
    ParseMedicationPackageContentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationPackageContentProperties(obj : TTurtleComplex; result : TFhirMedicationPackageContent);
begin
    ParseBackboneElementProperties(obj, result);
    result.item := ParseReference{TFhirMedication}(obj.complex('http://hl7.org/fhir/Medication.package.content.item'));{q3b}
    result.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/Medication.package.content.amount'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationPackageContent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationPackageContent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationPackageContent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirMedication}(this, 'Medication.package.content', 'item', elem.itemElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Medication.package.content', 'amount', elem.amountElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedication(obj : TTurtleComplex) : TFhirMedication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedication.create;
  try
    ParseMedicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationProperties(obj : TTurtleComplex; result : TFhirMedication);
begin
    ParseDomainResourceProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Medication.code'));{q3b}
    result.isBrandElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Medication.isBrand'));{q1}
    result.manufacturer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Medication.manufacturer'));{q3b}
    result.product := ParseMedicationProduct(obj.complex('http://hl7.org/fhir/Medication.product'));{q3b}
    result.package := ParseMedicationPackage(obj.complex('http://hl7.org/fhir/Medication.package'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Medication'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'Medication', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('isBrand') then
    ComposeBoolean(this, 'Medication', 'isBrand', elem.isBrandElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('manufacturer') then
    ComposeReference{TFhirOrganization}(this, 'Medication', 'manufacturer', elem.manufacturerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('product') then
    ComposeMedicationProduct(this, 'Medication', 'product', elem.productElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('package') then
    ComposeMedicationPackage(this, 'Medication', 'package', elem.packageElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
function TFHIRTurtleParser.ParseMedicationAdministrationDosage(obj : TTurtleComplex) : TFhirMedicationAdministrationDosage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationAdministrationDosage.create;
  try
    ParseMedicationAdministrationDosageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationAdministrationDosageProperties(obj : TTurtleComplex; result : TFhirMedicationAdministrationDosage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.text'));{q1}
    if obj.has('http://hl7.org/fhir/MedicationAdministration.dosage.siteCodeableConcept', item) then
      result.site := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationAdministration.dosage.siteReference', item) {a3} then
      result.site := ParseReference(item);
    result.route := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.route'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.method'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.quantity'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationAdministration.dosage.rateRatio', item) then
      result.rate := parseRatio(item);
    if obj.has('http://hl7.org/fhir/MedicationAdministration.dosage.rateRange', item) then
      result.rate := parseRange(item);
end;

procedure TFHIRTurtleComposer.ComposeMedicationAdministrationDosage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationAdministrationDosage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationAdministrationDosage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MedicationAdministration.dosage', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationAdministration.dosage', 'siteCodeableConcept', TFhirCodeableConcept(elem.site), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) {2} then
    ComposeReference(this, 'MedicationAdministration.dosage', 'siteReference', TFhirReference(elem.site), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationAdministration.dosage', 'route', elem.routeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationAdministration.dosage', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'MedicationAdministration.dosage', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'MedicationAdministration.dosage', 'rateRatio', TFhirRatio(elem.rate), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(this, 'MedicationAdministration.dosage', 'rateRange', TFhirRange(elem.rate), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseMedicationAdministration(obj : TTurtleComplex) : TFhirMedicationAdministration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationAdministration.create;
  try
    ParseMedicationAdministrationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationAdministrationProperties(obj : TTurtleComplex; result : TFhirMedicationAdministration);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationAdministration.status'), CODES_TFhirMedicationAdminStatusEnum, SYSTEMS_TFhirMedicationAdminStatusEnum);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/MedicationAdministration.patient'));{q3b}
    result.practitioner := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MedicationAdministration.practitioner'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/MedicationAdministration.encounter'));{q3b}
    result.prescription := ParseReference{TFhirMedicationOrder}(obj.complex('http://hl7.org/fhir/MedicationAdministration.prescription'));{q3b}
    result.wasNotGivenElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MedicationAdministration.wasNotGiven'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.reasonNotGiven') do
      result.reasonNotGivenList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.reasonGiven') do
      result.reasonGivenList.Add(parseCodeableConcept(item));
    if obj.has('http://hl7.org/fhir/MedicationAdministration.effectiveTimePeriod', item) then
      result.effectiveTime := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/MedicationAdministration.effectiveTimeDateTime', item) then
      result.effectiveTime := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/MedicationAdministration.medicationCodeableConcept', item) then
      result.medication := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationAdministration.medicationReference', item) {a3} then
      result.medication := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.device') do
      result.deviceList.Add(parseReference{TFhirDevice}(item));
    result.noteElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationAdministration.note'));{q1}
    result.dosage := ParseMedicationAdministrationDosage(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationAdministration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationAdministration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationAdministration'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationAdministration', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'MedicationAdministration', 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum, SYSTEMS_TFhirMedicationAdminStatusEnum, false, -1);{x.d4}
  ComposeReference{TFhirPatient}(this, 'MedicationAdministration', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('practitioner') then
    ComposeReference{Resource}(this, 'MedicationAdministration', 'practitioner', elem.practitionerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'MedicationAdministration', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('prescription') then
    ComposeReference{TFhirMedicationOrder}(this, 'MedicationAdministration', 'prescription', elem.prescriptionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('wasNotGiven') then
    ComposeBoolean(this, 'MedicationAdministration', 'wasNotGiven', elem.wasNotGivenElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonNotGiven') then
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationAdministration', 'reasonNotGiven', elem.reasonNotGivenList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonGiven') then
    for i := 0 to elem.reasonGivenList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationAdministration', 'reasonGiven', elem.reasonGivenList[i], false, i);{x.d3}
  if (elem.effectiveTime is TFhirPeriod) {6} then
    ComposePeriod(this, 'MedicationAdministration', 'effectiveTimePeriod', TFhirPeriod(elem.effectiveTime), false, -1){x.d9}
  else if (elem.effectiveTime is TFhirDateTime) {6} then
    ComposeDateTime(this, 'MedicationAdministration', 'effectiveTimeDateTime', TFhirDateTime(elem.effectiveTime), false, -1);{x.d9}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationAdministration', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), false, -1){x.d9}
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationAdministration', 'medicationReference', TFhirReference(elem.medication), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('device') then
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'MedicationAdministration', 'device', elem.deviceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    ComposeString(this, 'MedicationAdministration', 'note', elem.noteElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dosage') then
    ComposeMedicationAdministrationDosage(this, 'MedicationAdministration', 'dosage', elem.dosageElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
function TFHIRTurtleParser.ParseMedicationDispenseDosageInstruction(obj : TTurtleComplex) : TFhirMedicationDispenseDosageInstruction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationDispenseDosageInstruction.create;
  try
    ParseMedicationDispenseDosageInstructionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationDispenseDosageInstructionProperties(obj : TTurtleComplex; result : TFhirMedicationDispenseDosageInstruction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationDispense.dosageInstruction.text'));{q1}
    result.additionalInstructions := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationDispense.dosageInstruction.additionalInstructions'));{q3b}
    result.timing := ParseTiming(obj.complex('http://hl7.org/fhir/MedicationDispense.dosageInstruction.timing'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationDispense.dosageInstruction.asNeededCodeableConcept', item) then
      result.asNeeded := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationDispense.dosageInstruction.asNeededBoolean', item) then
      result.asNeeded := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/MedicationDispense.dosageInstruction.siteCodeableConcept', item) then
      result.site := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationDispense.dosageInstruction.siteReference', item) {a3} then
      result.site := ParseReference(item);
    result.route := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationDispense.dosageInstruction.route'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationDispense.dosageInstruction.method'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationDispense.dosageInstruction.doseRange', item) then
      result.dose := parseRange(item);
    if obj.has('http://hl7.org/fhir/MedicationDispense.dosageInstruction.doseQuantity', item) then
      result.dose := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/MedicationDispense.dosageInstruction.rateRatio', item) then
      result.rate := parseRatio(item);
    if obj.has('http://hl7.org/fhir/MedicationDispense.dosageInstruction.rateRange', item) then
      result.rate := parseRange(item);
    result.maxDosePerPeriod := ParseRatio(obj.complex('http://hl7.org/fhir/MedicationDispense.dosageInstruction.maxDosePerPeriod'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationDispenseDosageInstruction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispenseDosageInstruction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationDispenseDosageInstruction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MedicationDispense.dosageInstruction', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationDispense.dosageInstruction', 'additionalInstructions', elem.additionalInstructionsElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(this, 'MedicationDispense.dosageInstruction', 'timing', elem.timingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationDispense.dosageInstruction', 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(this, 'MedicationDispense.dosageInstruction', 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationDispense.dosageInstruction', 'siteCodeableConcept', TFhirCodeableConcept(elem.site), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) {2} then
    ComposeReference(this, 'MedicationDispense.dosageInstruction', 'siteReference', TFhirReference(elem.site), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationDispense.dosageInstruction', 'route', elem.routeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationDispense.dosageInstruction', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirRange) {6} then
    ComposeRange(this, 'MedicationDispense.dosageInstruction', 'doseRange', TFhirRange(elem.dose), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MedicationDispense.dosageInstruction', 'doseQuantity', TFhirQuantity(elem.dose), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'MedicationDispense.dosageInstruction', 'rateRatio', TFhirRatio(elem.rate), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(this, 'MedicationDispense.dosageInstruction', 'rateRange', TFhirRange(elem.rate), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'MedicationDispense.dosageInstruction', 'maxDosePerPeriod', elem.maxDosePerPeriodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationDispenseSubstitution(obj : TTurtleComplex) : TFhirMedicationDispenseSubstitution;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationDispenseSubstitution.create;
  try
    ParseMedicationDispenseSubstitutionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationDispenseSubstitutionProperties(obj : TTurtleComplex; result : TFhirMedicationDispenseSubstitution);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationDispense.substitution.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.substitution.reason') do
      result.reasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.substitution.responsibleParty') do
      result.responsiblePartyList.Add(parseReference{TFhirPractitioner}(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationDispenseSubstitution(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispenseSubstitution; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationDispenseSubstitution'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicationDispense.substitution', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationDispense.substitution', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.responsiblePartyList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'MedicationDispense.substitution', 'responsibleParty', elem.responsiblePartyList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicationDispense(obj : TTurtleComplex) : TFhirMedicationDispense;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationDispense.create;
  try
    ParseMedicationDispenseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationDispenseProperties(obj : TTurtleComplex; result : TFhirMedicationDispense);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/MedicationDispense.identifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationDispense.status'), CODES_TFhirMedicationDispenseStatusEnum, SYSTEMS_TFhirMedicationDispenseStatusEnum);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/MedicationDispense.patient'));{q3b}
    result.dispenser := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MedicationDispense.dispenser'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.authorizingPrescription') do
      result.authorizingPrescriptionList.Add(parseReference{TFhirMedicationOrder}(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationDispense.type'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationDispense.quantity'));{q3b}
    result.daysSupply := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationDispense.daysSupply'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationDispense.medicationCodeableConcept', item) then
      result.medication := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationDispense.medicationReference', item) {a3} then
      result.medication := ParseReference(item);
    result.whenPreparedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationDispense.whenPrepared'));{q1}
    result.whenHandedOverElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationDispense.whenHandedOver'));{q1}
    result.destination := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/MedicationDispense.destination'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.receiver') do
      result.receiverList.Add(parseReference{Resource}(item));
    result.noteElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationDispense.note'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.dosageInstruction') do
      result.dosageInstructionList.Add(parseMedicationDispenseDosageInstruction(item));
    result.substitution := ParseMedicationDispenseSubstitution(obj.complex('http://hl7.org/fhir/MedicationDispense.substitution'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationDispense(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispense; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationDispense'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'MedicationDispense', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'MedicationDispense', 'status', elem.StatusElement, CODES_TFhirMedicationDispenseStatusEnum, SYSTEMS_TFhirMedicationDispenseStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'MedicationDispense', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dispenser') then
    ComposeReference{TFhirPractitioner}(this, 'MedicationDispense', 'dispenser', elem.dispenserElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authorizingPrescription') then
    for i := 0 to elem.authorizingPrescriptionList.Count - 1 do
      ComposeReference{TFhirMedicationOrder}(this, 'MedicationDispense', 'authorizingPrescription', elem.authorizingPrescriptionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'MedicationDispense', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeQuantity(this, 'MedicationDispense', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('daysSupply') then
    ComposeQuantity(this, 'MedicationDispense', 'daysSupply', elem.daysSupplyElement, false, -1);{x.2f}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationDispense', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), false, -1){x.d9}
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationDispense', 'medicationReference', TFhirReference(elem.medication), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenPrepared') then
    ComposeDateTime(this, 'MedicationDispense', 'whenPrepared', elem.whenPreparedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenHandedOver') then
    ComposeDateTime(this, 'MedicationDispense', 'whenHandedOver', elem.whenHandedOverElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('destination') then
    ComposeReference{TFhirLocation}(this, 'MedicationDispense', 'destination', elem.destinationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receiver') then
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{Resource}(this, 'MedicationDispense', 'receiver', elem.receiverList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    ComposeString(this, 'MedicationDispense', 'note', elem.noteElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dosageInstruction') then
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeMedicationDispenseDosageInstruction(this, 'MedicationDispense', 'dosageInstruction', elem.dosageInstructionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('substitution') then
    ComposeMedicationDispenseSubstitution(this, 'MedicationDispense', 'substitution', elem.substitutionElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
function TFHIRTurtleParser.ParseMedicationOrderDosageInstruction(obj : TTurtleComplex) : TFhirMedicationOrderDosageInstruction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationOrderDosageInstruction.create;
  try
    ParseMedicationOrderDosageInstructionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationOrderDosageInstructionProperties(obj : TTurtleComplex; result : TFhirMedicationOrderDosageInstruction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationOrder.dosageInstruction.text'));{q1}
    result.additionalInstructions := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationOrder.dosageInstruction.additionalInstructions'));{q3b}
    result.timing := ParseTiming(obj.complex('http://hl7.org/fhir/MedicationOrder.dosageInstruction.timing'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationOrder.dosageInstruction.asNeededCodeableConcept', item) then
      result.asNeeded := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationOrder.dosageInstruction.asNeededBoolean', item) then
      result.asNeeded := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/MedicationOrder.dosageInstruction.siteCodeableConcept', item) then
      result.site := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationOrder.dosageInstruction.siteReference', item) {a3} then
      result.site := ParseReference(item);
    result.route := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationOrder.dosageInstruction.route'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationOrder.dosageInstruction.method'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationOrder.dosageInstruction.doseRange', item) then
      result.dose := parseRange(item);
    if obj.has('http://hl7.org/fhir/MedicationOrder.dosageInstruction.doseQuantity', item) then
      result.dose := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/MedicationOrder.dosageInstruction.rateRatio', item) then
      result.rate := parseRatio(item);
    if obj.has('http://hl7.org/fhir/MedicationOrder.dosageInstruction.rateRange', item) then
      result.rate := parseRange(item);
    result.maxDosePerPeriod := ParseRatio(obj.complex('http://hl7.org/fhir/MedicationOrder.dosageInstruction.maxDosePerPeriod'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationOrderDosageInstruction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationOrderDosageInstruction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationOrderDosageInstruction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MedicationOrder.dosageInstruction', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationOrder.dosageInstruction', 'additionalInstructions', elem.additionalInstructionsElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(this, 'MedicationOrder.dosageInstruction', 'timing', elem.timingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationOrder.dosageInstruction', 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(this, 'MedicationOrder.dosageInstruction', 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationOrder.dosageInstruction', 'siteCodeableConcept', TFhirCodeableConcept(elem.site), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) {2} then
    ComposeReference(this, 'MedicationOrder.dosageInstruction', 'siteReference', TFhirReference(elem.site), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationOrder.dosageInstruction', 'route', elem.routeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationOrder.dosageInstruction', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirRange) {6} then
    ComposeRange(this, 'MedicationOrder.dosageInstruction', 'doseRange', TFhirRange(elem.dose), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MedicationOrder.dosageInstruction', 'doseQuantity', TFhirQuantity(elem.dose), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'MedicationOrder.dosageInstruction', 'rateRatio', TFhirRatio(elem.rate), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(this, 'MedicationOrder.dosageInstruction', 'rateRange', TFhirRange(elem.rate), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'MedicationOrder.dosageInstruction', 'maxDosePerPeriod', elem.maxDosePerPeriodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationOrderDispenseRequest(obj : TTurtleComplex) : TFhirMedicationOrderDispenseRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationOrderDispenseRequest.create;
  try
    ParseMedicationOrderDispenseRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationOrderDispenseRequestProperties(obj : TTurtleComplex; result : TFhirMedicationOrderDispenseRequest);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/MedicationOrder.dispenseRequest.medicationCodeableConcept', item) then
      result.medication := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationOrder.dispenseRequest.medicationReference', item) {a3} then
      result.medication := ParseReference(item);
    result.validityPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/MedicationOrder.dispenseRequest.validityPeriod'));{q3b}
    result.numberOfRepeatsAllowedElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/MedicationOrder.dispenseRequest.numberOfRepeatsAllowed'));{q1}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationOrder.dispenseRequest.quantity'));{q3b}
    result.expectedSupplyDuration := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationOrder.dispenseRequest.expectedSupplyDuration'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationOrderDispenseRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationOrderDispenseRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationOrderDispenseRequest'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationOrder.dispenseRequest', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationOrder.dispenseRequest', 'medicationReference', TFhirReference(elem.medication), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'MedicationOrder.dispenseRequest', 'validityPeriod', elem.validityPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'MedicationOrder.dispenseRequest', 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'MedicationOrder.dispenseRequest', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'MedicationOrder.dispenseRequest', 'expectedSupplyDuration', elem.expectedSupplyDurationElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationOrderSubstitution(obj : TTurtleComplex) : TFhirMedicationOrderSubstitution;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationOrderSubstitution.create;
  try
    ParseMedicationOrderSubstitutionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationOrderSubstitutionProperties(obj : TTurtleComplex; result : TFhirMedicationOrderSubstitution);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationOrder.substitution.type'));{q3b}
    result.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationOrder.substitution.reason'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationOrderSubstitution(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationOrderSubstitution; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationOrderSubstitution'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicationOrder.substitution', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationOrder.substitution', 'reason', elem.reasonElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationOrder(obj : TTurtleComplex) : TFhirMedicationOrder;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationOrder.create;
  try
    ParseMedicationOrderProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationOrderProperties(obj : TTurtleComplex; result : TFhirMedicationOrder);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicationOrder.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.dateWrittenElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationOrder.dateWritten'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationOrder.status'), CODES_TFhirMedicationOrderStatusEnum, SYSTEMS_TFhirMedicationOrderStatusEnum);
    result.dateEndedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationOrder.dateEnded'));{q1}
    result.reasonEnded := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationOrder.reasonEnded'));{q3b}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/MedicationOrder.patient'));{q3b}
    result.prescriber := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MedicationOrder.prescriber'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/MedicationOrder.encounter'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationOrder.reasonCodeableConcept', item) then
      result.reason := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationOrder.reasonReference', item) {a3} then
      result.reason := ParseReference(item);
    result.noteElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationOrder.note'));{q1}
    if obj.has('http://hl7.org/fhir/MedicationOrder.medicationCodeableConcept', item) then
      result.medication := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationOrder.medicationReference', item) {a3} then
      result.medication := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/MedicationOrder.dosageInstruction') do
      result.dosageInstructionList.Add(parseMedicationOrderDosageInstruction(item));
    result.dispenseRequest := ParseMedicationOrderDispenseRequest(obj.complex('http://hl7.org/fhir/MedicationOrder.dispenseRequest'));{q3b}
    result.substitution := ParseMedicationOrderSubstitution(obj.complex('http://hl7.org/fhir/MedicationOrder.substitution'));{q3b}
    result.priorPrescription := ParseReference{TFhirMedicationOrder}(obj.complex('http://hl7.org/fhir/MedicationOrder.priorPrescription'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationOrder(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationOrder; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationOrder'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationOrder', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateWritten') then
    ComposeDateTime(this, 'MedicationOrder', 'dateWritten', elem.dateWrittenElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'MedicationOrder', 'status', elem.StatusElement, CODES_TFhirMedicationOrderStatusEnum, SYSTEMS_TFhirMedicationOrderStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateEnded') then
    ComposeDateTime(this, 'MedicationOrder', 'dateEnded', elem.dateEndedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonEnded') then
    ComposeCodeableConcept(this, 'MedicationOrder', 'reasonEnded', elem.reasonEndedElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'MedicationOrder', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('prescriber') then
    ComposeReference{TFhirPractitioner}(this, 'MedicationOrder', 'prescriber', elem.prescriberElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'MedicationOrder', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationOrder', 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(this, 'MedicationOrder', 'reasonReference', TFhirReference(elem.reason), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    ComposeString(this, 'MedicationOrder', 'note', elem.noteElement, false, -1);{x.2ea}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationOrder', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), false, -1){x.d9}
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationOrder', 'medicationReference', TFhirReference(elem.medication), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dosageInstruction') then
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeMedicationOrderDosageInstruction(this, 'MedicationOrder', 'dosageInstruction', elem.dosageInstructionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dispenseRequest') then
    ComposeMedicationOrderDispenseRequest(this, 'MedicationOrder', 'dispenseRequest', elem.dispenseRequestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('substitution') then
    ComposeMedicationOrderSubstitution(this, 'MedicationOrder', 'substitution', elem.substitutionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priorPrescription') then
    ComposeReference{TFhirMedicationOrder}(this, 'MedicationOrder', 'priorPrescription', elem.priorPrescriptionElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
function TFHIRTurtleParser.ParseMedicationStatementDosage(obj : TTurtleComplex) : TFhirMedicationStatementDosage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationStatementDosage.create;
  try
    ParseMedicationStatementDosageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationStatementDosageProperties(obj : TTurtleComplex; result : TFhirMedicationStatementDosage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationStatement.dosage.text'));{q1}
    result.timing := ParseTiming(obj.complex('http://hl7.org/fhir/MedicationStatement.dosage.timing'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationStatement.dosage.asNeededCodeableConcept', item) then
      result.asNeeded := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationStatement.dosage.asNeededBoolean', item) then
      result.asNeeded := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/MedicationStatement.dosage.siteCodeableConcept', item) then
      result.site := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationStatement.dosage.siteReference', item) {a3} then
      result.site := ParseReference(item);
    result.route := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationStatement.dosage.route'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationStatement.dosage.method'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationStatement.dosage.quantityQuantity', item) then
      result.quantity := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/MedicationStatement.dosage.quantityRange', item) then
      result.quantity := parseRange(item);
    if obj.has('http://hl7.org/fhir/MedicationStatement.dosage.rateRatio', item) then
      result.rate := parseRatio(item);
    if obj.has('http://hl7.org/fhir/MedicationStatement.dosage.rateRange', item) then
      result.rate := parseRange(item);
    result.maxDosePerPeriod := ParseRatio(obj.complex('http://hl7.org/fhir/MedicationStatement.dosage.maxDosePerPeriod'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationStatementDosage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationStatementDosage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationStatementDosage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MedicationStatement.dosage', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(this, 'MedicationStatement.dosage', 'timing', elem.timingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationStatement.dosage', 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(this, 'MedicationStatement.dosage', 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationStatement.dosage', 'siteCodeableConcept', TFhirCodeableConcept(elem.site), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) {2} then
    ComposeReference(this, 'MedicationStatement.dosage', 'siteReference', TFhirReference(elem.site), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationStatement.dosage', 'route', elem.routeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationStatement.dosage', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MedicationStatement.dosage', 'quantityQuantity', TFhirQuantity(elem.quantity), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirRange) {6} then
    ComposeRange(this, 'MedicationStatement.dosage', 'quantityRange', TFhirRange(elem.quantity), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'MedicationStatement.dosage', 'rateRatio', TFhirRatio(elem.rate), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(this, 'MedicationStatement.dosage', 'rateRange', TFhirRange(elem.rate), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'MedicationStatement.dosage', 'maxDosePerPeriod', elem.maxDosePerPeriodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationStatement(obj : TTurtleComplex) : TFhirMedicationStatement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationStatement.create;
  try
    ParseMedicationStatementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationStatementProperties(obj : TTurtleComplex; result : TFhirMedicationStatement);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/MedicationStatement.patient'));{q3b}
    result.informationSource := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MedicationStatement.informationSource'));{q3b}
    result.dateAssertedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationStatement.dateAsserted'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationStatement.status'), CODES_TFhirMedicationStatementStatusEnum, SYSTEMS_TFhirMedicationStatementStatusEnum);
    result.wasNotTakenElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MedicationStatement.wasNotTaken'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.reasonNotTaken') do
      result.reasonNotTakenList.Add(parseCodeableConcept(item));
    if obj.has('http://hl7.org/fhir/MedicationStatement.reasonForUseCodeableConcept', item) then
      result.reasonForUse := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationStatement.reasonForUseReference', item) {a3} then
      result.reasonForUse := ParseReference(item);
    if obj.has('http://hl7.org/fhir/MedicationStatement.effectivePeriod', item) then
      result.effective := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/MedicationStatement.effectiveDateTime', item) then
      result.effective := parseDateTime(item);
    result.noteElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationStatement.note'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.supportingInformation') do
      result.supportingInformationList.Add(parseReference{TFhirReference}(item));
    if obj.has('http://hl7.org/fhir/MedicationStatement.medicationCodeableConcept', item) then
      result.medication := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationStatement.medicationReference', item) {a3} then
      result.medication := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.dosage') do
      result.dosageList.Add(parseMedicationStatementDosage(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationStatement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationStatement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationStatement'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationStatement', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'MedicationStatement', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('informationSource') then
    ComposeReference{Resource}(this, 'MedicationStatement', 'informationSource', elem.informationSourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateAsserted') then
    ComposeDateTime(this, 'MedicationStatement', 'dateAsserted', elem.dateAssertedElement, false, -1);{x.2ea}
  ComposeEnum(this, 'MedicationStatement', 'status', elem.StatusElement, CODES_TFhirMedicationStatementStatusEnum, SYSTEMS_TFhirMedicationStatementStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('wasNotTaken') then
    ComposeBoolean(this, 'MedicationStatement', 'wasNotTaken', elem.wasNotTakenElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonNotTaken') then
    for i := 0 to elem.reasonNotTakenList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationStatement', 'reasonNotTaken', elem.reasonNotTakenList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonForUse is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationStatement', 'reasonForUseCodeableConcept', TFhirCodeableConcept(elem.reasonForUse), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonForUse is TFhirReference) {2} then
    ComposeReference(this, 'MedicationStatement', 'reasonForUseReference', TFhirReference(elem.reasonForUse), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'MedicationStatement', 'effectivePeriod', TFhirPeriod(elem.effective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'MedicationStatement', 'effectiveDateTime', TFhirDateTime(elem.effective), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    ComposeString(this, 'MedicationStatement', 'note', elem.noteElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'MedicationStatement', 'supportingInformation', elem.supportingInformationList[i], false, i);{x.d3}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationStatement', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), false, -1){x.d9}
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationStatement', 'medicationReference', TFhirReference(elem.medication), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dosage') then
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeMedicationStatementDosage(this, 'MedicationStatement', 'dosage', elem.dosageList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
function TFHIRTurtleParser.ParseMessageHeaderResponse(obj : TTurtleComplex) : TFhirMessageHeaderResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageHeaderResponse.create;
  try
    ParseMessageHeaderResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageHeaderResponseProperties(obj : TTurtleComplex; result : TFhirMessageHeaderResponse);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifierElement := ParseId(obj.complex('http://hl7.org/fhir/MessageHeader.response.identifier'));{q1}
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/MessageHeader.response.code'), CODES_TFhirResponseCodeEnum, SYSTEMS_TFhirResponseCodeEnum);
    result.details := ParseReference{TFhirOperationOutcome}(obj.complex('http://hl7.org/fhir/MessageHeader.response.details'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMessageHeaderResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageHeaderResponse'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'MessageHeader.response', 'identifier', elem.identifierElement, false, -1);{x.2ea}
  ComposeEnum(this, 'MessageHeader.response', 'code', elem.CodeElement, CODES_TFhirResponseCodeEnum, SYSTEMS_TFhirResponseCodeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOperationOutcome}(this, 'MessageHeader.response', 'details', elem.detailsElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMessageHeaderSource(obj : TTurtleComplex) : TFhirMessageHeaderSource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageHeaderSource.create;
  try
    ParseMessageHeaderSourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageHeaderSourceProperties(obj : TTurtleComplex; result : TFhirMessageHeaderSource);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/MessageHeader.source.name'));{q1}
    result.softwareElement := ParseString(obj.complex('http://hl7.org/fhir/MessageHeader.source.software'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/MessageHeader.source.version'));{q1}
    result.contact := ParseContactPoint(obj.complex('http://hl7.org/fhir/MessageHeader.source.contact'));{q3b}
    result.endpointElement := ParseUri(obj.complex('http://hl7.org/fhir/MessageHeader.source.endpoint'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMessageHeaderSource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderSource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageHeaderSource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeader.source', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeader.source', 'software', elem.softwareElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeader.source', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeContactPoint(this, 'MessageHeader.source', 'contact', elem.contactElement, false, -1);{x.2f}
  ComposeUri(this, 'MessageHeader.source', 'endpoint', elem.endpointElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMessageHeaderDestination(obj : TTurtleComplex) : TFhirMessageHeaderDestination;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageHeaderDestination.create;
  try
    ParseMessageHeaderDestinationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageHeaderDestinationProperties(obj : TTurtleComplex; result : TFhirMessageHeaderDestination);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/MessageHeader.destination.name'));{q1}
    result.target := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/MessageHeader.destination.target'));{q3b}
    result.endpointElement := ParseUri(obj.complex('http://hl7.org/fhir/MessageHeader.destination.endpoint'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMessageHeaderDestination(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderDestination; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageHeaderDestination'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeader.destination', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(this, 'MessageHeader.destination', 'target', elem.targetElement, false, -1);{x.2f}
  ComposeUri(this, 'MessageHeader.destination', 'endpoint', elem.endpointElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMessageHeader(obj : TTurtleComplex) : TFhirMessageHeader;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageHeader.create;
  try
    ParseMessageHeaderProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageHeaderProperties(obj : TTurtleComplex; result : TFhirMessageHeader);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.timestampElement := ParseInstant(obj.complex('http://hl7.org/fhir/MessageHeader.timestamp'));{q1}
    result.event := ParseCoding(obj.complex('http://hl7.org/fhir/MessageHeader.event'));{q3b}
    result.response := ParseMessageHeaderResponse(obj.complex('http://hl7.org/fhir/MessageHeader.response'));{q3b}
    result.source := ParseMessageHeaderSource(obj.complex('http://hl7.org/fhir/MessageHeader.source'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MessageHeader.destination') do
      result.destinationList.Add(parseMessageHeaderDestination(item));
    result.enterer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MessageHeader.enterer'));{q3b}
    result.author := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MessageHeader.author'));{q3b}
    result.receiver := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MessageHeader.receiver'));{q3b}
    result.responsible := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MessageHeader.responsible'));{q3b}
    result.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MessageHeader.reason'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MessageHeader.data') do
      result.dataList.Add(parseReference{TFhirReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeMessageHeader(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeader; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageHeader'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeInstant(this, 'MessageHeader', 'timestamp', elem.timestampElement, false, -1);{x.2ea}
  ComposeCoding(this, 'MessageHeader', 'event', elem.eventElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('response') then
    ComposeMessageHeaderResponse(this, 'MessageHeader', 'response', elem.responseElement, false, -1);{x.2f}
  ComposeMessageHeaderSource(this, 'MessageHeader', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('destination') then
    for i := 0 to elem.destinationList.Count - 1 do
      ComposeMessageHeaderDestination(this, 'MessageHeader', 'destination', elem.destinationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(this, 'MessageHeader', 'enterer', elem.entererElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirPractitioner}(this, 'MessageHeader', 'author', elem.authorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receiver') then
    ComposeReference{Resource}(this, 'MessageHeader', 'receiver', elem.receiverElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('responsible') then
    ComposeReference{Resource}(this, 'MessageHeader', 'responsible', elem.responsibleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    ComposeCodeableConcept(this, 'MessageHeader', 'reason', elem.reasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('data') then
    for i := 0 to elem.dataList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'MessageHeader', 'data', elem.dataList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
function TFHIRTurtleParser.ParseNamingSystemContact(obj : TTurtleComplex) : TFhirNamingSystemContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNamingSystemContact.create;
  try
    ParseNamingSystemContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNamingSystemContactProperties(obj : TTurtleComplex; result : TFhirNamingSystemContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.contact.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.contact.telecom') do
      result.telecomList.Add(parseContactPoint(item));
end;

procedure TFHIRTurtleComposer.ComposeNamingSystemContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNamingSystemContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NamingSystemContact'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NamingSystem.contact', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'NamingSystem.contact', 'telecom', elem.telecomList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseNamingSystemUniqueId(obj : TTurtleComplex) : TFhirNamingSystemUniqueId;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNamingSystemUniqueId.create;
  try
    ParseNamingSystemUniqueIdProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNamingSystemUniqueIdProperties(obj : TTurtleComplex; result : TFhirNamingSystemUniqueId);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.type'), CODES_TFhirNamingsystemIdentifierTypeEnum, SYSTEMS_TFhirNamingsystemIdentifierTypeEnum);
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.value'));{q1}
    result.preferredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.preferred'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeNamingSystemUniqueId(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNamingSystemUniqueId; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NamingSystemUniqueId'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'NamingSystem.uniqueId', 'type', elem.Type_Element, CODES_TFhirNamingsystemIdentifierTypeEnum, SYSTEMS_TFhirNamingsystemIdentifierTypeEnum, false, -1);{x.d4}
  ComposeString(this, 'NamingSystem.uniqueId', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'NamingSystem.uniqueId', 'preferred', elem.preferredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'NamingSystem.uniqueId', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseNamingSystem(obj : TTurtleComplex) : TFhirNamingSystem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNamingSystem.create;
  try
    ParseNamingSystemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNamingSystemProperties(obj : TTurtleComplex; result : TFhirNamingSystem);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/NamingSystem.status'), CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/NamingSystem.kind'), CODES_TFhirNamingsystemTypeEnum, SYSTEMS_TFhirNamingsystemTypeEnum);
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.contact') do
      result.contactList.Add(parseNamingSystemContact(item));
    result.responsibleElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.responsible'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/NamingSystem.date'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NamingSystem.type'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.useContext') do
      result.useContextList.Add(parseCodeableConcept(item));
    result.usageElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.usage'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.uniqueId') do
      result.uniqueIdList.Add(parseNamingSystemUniqueId(item));
    result.replacedBy := ParseReference{TFhirNamingSystem}(obj.complex('http://hl7.org/fhir/NamingSystem.replacedBy'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeNamingSystem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNamingSystem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NamingSystem'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeString(this, 'NamingSystem', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'NamingSystem', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'NamingSystem', 'kind', elem.KindElement, CODES_TFhirNamingsystemTypeEnum, SYSTEMS_TFhirNamingsystemTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'NamingSystem', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeNamingSystemContact(this, 'NamingSystem', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('responsible') then
    ComposeString(this, 'NamingSystem', 'responsible', elem.responsibleElement, false, -1);{x.2ea}
  ComposeDateTime(this, 'NamingSystem', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'NamingSystem', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeString(this, 'NamingSystem', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(this, 'NamingSystem', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(this, 'NamingSystem', 'usage', elem.usageElement, false, -1);{x.2ea}
  for i := 0 to elem.uniqueIdList.Count - 1 do
      ComposeNamingSystemUniqueId(this, 'NamingSystem', 'uniqueId', elem.uniqueIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('replacedBy') then
    ComposeReference{TFhirNamingSystem}(this, 'NamingSystem', 'replacedBy', elem.replacedByElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
function TFHIRTurtleParser.ParseNutritionOrderOralDiet(obj : TTurtleComplex) : TFhirNutritionOrderOralDiet;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderOralDiet.create;
  try
    ParseNutritionOrderOralDietProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderOralDietProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDiet);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.type') do
      result.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.schedule') do
      result.scheduleList.Add(parseTiming(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.nutrient') do
      result.nutrientList.Add(parseNutritionOrderOralDietNutrient(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.texture') do
      result.textureList.Add(parseNutritionOrderOralDietTexture(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.fluidConsistencyType') do
      result.fluidConsistencyTypeList.Add(parseCodeableConcept(item));
    result.instructionElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.instruction'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderOralDiet(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDiet; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderOralDiet'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder.oralDiet', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(this, 'NutritionOrder.oralDiet', 'schedule', elem.scheduleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.nutrientList.Count - 1 do
      ComposeNutritionOrderOralDietNutrient(this, 'NutritionOrder.oralDiet', 'nutrient', elem.nutrientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.textureList.Count - 1 do
      ComposeNutritionOrderOralDietTexture(this, 'NutritionOrder.oralDiet', 'texture', elem.textureList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.fluidConsistencyTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder.oralDiet', 'fluidConsistencyType', elem.fluidConsistencyTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NutritionOrder.oralDiet', 'instruction', elem.instructionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseNutritionOrderOralDietNutrient(obj : TTurtleComplex) : TFhirNutritionOrderOralDietNutrient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    ParseNutritionOrderOralDietNutrientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderOralDietNutrientProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDietNutrient);
begin
    ParseBackboneElementProperties(obj, result);
    result.modifier := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.nutrient.modifier'));{q3b}
    result.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.nutrient.amount'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderOralDietNutrient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDietNutrient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderOralDietNutrient'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.oralDiet.nutrient', 'modifier', elem.modifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.oralDiet.nutrient', 'amount', elem.amountElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseNutritionOrderOralDietTexture(obj : TTurtleComplex) : TFhirNutritionOrderOralDietTexture;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    ParseNutritionOrderOralDietTextureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderOralDietTextureProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDietTexture);
begin
    ParseBackboneElementProperties(obj, result);
    result.modifier := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.texture.modifier'));{q3b}
    result.foodType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.texture.foodType'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderOralDietTexture(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDietTexture; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderOralDietTexture'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.oralDiet.texture', 'modifier', elem.modifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.oralDiet.texture', 'foodType', elem.foodTypeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseNutritionOrderSupplement(obj : TTurtleComplex) : TFhirNutritionOrderSupplement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderSupplement.create;
  try
    ParseNutritionOrderSupplementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderSupplementProperties(obj : TTurtleComplex; result : TFhirNutritionOrderSupplement);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.type'));{q3b}
    result.productNameElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.productName'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.supplement.schedule') do
      result.scheduleList.Add(parseTiming(item));
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.quantity'));{q3b}
    result.instructionElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.instruction'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderSupplement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderSupplement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderSupplement'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.supplement', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NutritionOrder.supplement', 'productName', elem.productNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(this, 'NutritionOrder.supplement', 'schedule', elem.scheduleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.supplement', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NutritionOrder.supplement', 'instruction', elem.instructionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseNutritionOrderEnteralFormula(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormula;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    ParseNutritionOrderEnteralFormulaProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderEnteralFormulaProperties(obj : TTurtleComplex; result : TFhirNutritionOrderEnteralFormula);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.baseFormulaType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.baseFormulaType'));{q3b}
    result.baseFormulaProductNameElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.baseFormulaProductName'));{q1}
    result.additiveType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.additiveType'));{q3b}
    result.additiveProductNameElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.additiveProductName'));{q1}
    result.caloricDensity := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.caloricDensity'));{q3b}
    result.routeofAdministration := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.routeofAdministration'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration') do
      result.administrationList.Add(parseNutritionOrderEnteralFormulaAdministration(item));
    result.maxVolumeToDeliver := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.maxVolumeToDeliver'));{q3b}
    result.administrationInstructionElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.administrationInstruction'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderEnteralFormula(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderEnteralFormula; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderEnteralFormula'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.enteralFormula', 'baseFormulaType', elem.baseFormulaTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NutritionOrder.enteralFormula', 'baseFormulaProductName', elem.baseFormulaProductNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.enteralFormula', 'additiveType', elem.additiveTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NutritionOrder.enteralFormula', 'additiveProductName', elem.additiveProductNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.enteralFormula', 'caloricDensity', elem.caloricDensityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.enteralFormula', 'routeofAdministration', elem.routeofAdministrationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.administrationList.Count - 1 do
      ComposeNutritionOrderEnteralFormulaAdministration(this, 'NutritionOrder.enteralFormula', 'administration', elem.administrationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.enteralFormula', 'maxVolumeToDeliver', elem.maxVolumeToDeliverElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NutritionOrder.enteralFormula', 'administrationInstruction', elem.administrationInstructionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseNutritionOrderEnteralFormulaAdministration(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    ParseNutritionOrderEnteralFormulaAdministrationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderEnteralFormulaAdministrationProperties(obj : TTurtleComplex; result : TFhirNutritionOrderEnteralFormulaAdministration);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.schedule := ParseTiming(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration.schedule'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration.quantity'));{q3b}
    if obj.has('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration.rateQuantity', item) then
      result.rate := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration.rateRatio', item) then
      result.rate := parseRatio(item);
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderEnteralFormulaAdministration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderEnteralFormulaAdministration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderEnteralFormulaAdministration'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTiming(this, 'NutritionOrder.enteralFormula.administration', 'schedule', elem.scheduleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.enteralFormula.administration', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirQuantity) {6} then
    ComposeQuantity(this, 'NutritionOrder.enteralFormula.administration', 'rateQuantity', TFhirQuantity(elem.rate), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'NutritionOrder.enteralFormula.administration', 'rateRatio', TFhirRatio(elem.rate), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseNutritionOrder(obj : TTurtleComplex) : TFhirNutritionOrder;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrder.create;
  try
    ParseNutritionOrderProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderProperties(obj : TTurtleComplex; result : TFhirNutritionOrder);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/NutritionOrder.patient'));{q3b}
    result.orderer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/NutritionOrder.orderer'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/NutritionOrder.encounter'));{q3b}
    result.dateTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/NutritionOrder.dateTime'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/NutritionOrder.status'), CODES_TFhirNutritionOrderStatusEnum, SYSTEMS_TFhirNutritionOrderStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.allergyIntolerance') do
      result.allergyIntoleranceList.Add(parseReference{TFhirAllergyIntolerance}(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.foodPreferenceModifier') do
      result.foodPreferenceModifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.excludeFoodModifier') do
      result.excludeFoodModifierList.Add(parseCodeableConcept(item));
    result.oralDiet := ParseNutritionOrderOralDiet(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.supplement') do
      result.supplementList.Add(parseNutritionOrderSupplement(item));
    result.enteralFormula := ParseNutritionOrderEnteralFormula(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrder(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrder; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrder'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeReference{TFhirPatient}(this, 'NutritionOrder', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderer') then
    ComposeReference{TFhirPractitioner}(this, 'NutritionOrder', 'orderer', elem.ordererElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'NutritionOrder', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'NutritionOrder', 'encounter', elem.encounterElement, false, -1);{x.2f}
  ComposeDateTime(this, 'NutritionOrder', 'dateTime', elem.dateTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'NutritionOrder', 'status', elem.StatusElement, CODES_TFhirNutritionOrderStatusEnum, SYSTEMS_TFhirNutritionOrderStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('allergyIntolerance') then
    for i := 0 to elem.allergyIntoleranceList.Count - 1 do
      ComposeReference{TFhirAllergyIntolerance}(this, 'NutritionOrder', 'allergyIntolerance', elem.allergyIntoleranceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('foodPreferenceModifier') then
    for i := 0 to elem.foodPreferenceModifierList.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder', 'foodPreferenceModifier', elem.foodPreferenceModifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('excludeFoodModifier') then
    for i := 0 to elem.excludeFoodModifierList.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder', 'excludeFoodModifier', elem.excludeFoodModifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('oralDiet') then
    ComposeNutritionOrderOralDiet(this, 'NutritionOrder', 'oralDiet', elem.oralDietElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('supplement') then
    for i := 0 to elem.supplementList.Count - 1 do
      ComposeNutritionOrderSupplement(this, 'NutritionOrder', 'supplement', elem.supplementList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('enteralFormula') then
    ComposeNutritionOrderEnteralFormula(this, 'NutritionOrder', 'enteralFormula', elem.enteralFormulaElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
function TFHIRTurtleParser.ParseObservationReferenceRange(obj : TTurtleComplex) : TFhirObservationReferenceRange;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationReferenceRange.create;
  try
    ParseObservationReferenceRangeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationReferenceRangeProperties(obj : TTurtleComplex; result : TFhirObservationReferenceRange);
begin
    ParseBackboneElementProperties(obj, result);
    result.low := ParseQuantity(obj.complex('http://hl7.org/fhir/Observation.referenceRange.low'));{q3b}
    result.high := ParseQuantity(obj.complex('http://hl7.org/fhir/Observation.referenceRange.high'));{q3b}
    result.meaning := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.referenceRange.meaning'));{q3b}
    result.age := ParseRange(obj.complex('http://hl7.org/fhir/Observation.referenceRange.age'));{q3b}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Observation.referenceRange.text'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeObservationReferenceRange(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationReferenceRange; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationReferenceRange'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Observation.referenceRange', 'low', elem.lowElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Observation.referenceRange', 'high', elem.highElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation.referenceRange', 'meaning', elem.meaningElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(this, 'Observation.referenceRange', 'age', elem.ageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Observation.referenceRange', 'text', elem.textElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseObservationRelated(obj : TTurtleComplex) : TFhirObservationRelated;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationRelated.create;
  try
    ParseObservationRelatedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationRelatedProperties(obj : TTurtleComplex; result : TFhirObservationRelated);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Observation.related.type'), CODES_TFhirObservationRelationshiptypesEnum, SYSTEMS_TFhirObservationRelationshiptypesEnum);
    result.target := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Observation.related.target'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeObservationRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationRelated; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationRelated'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Observation.related', 'type', elem.Type_Element, CODES_TFhirObservationRelationshiptypesEnum, SYSTEMS_TFhirObservationRelationshiptypesEnum, false, -1);{x.d4}
  ComposeReference{Resource}(this, 'Observation.related', 'target', elem.targetElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseObservationComponent(obj : TTurtleComplex) : TFhirObservationComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationComponent.create;
  try
    ParseObservationComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationComponentProperties(obj : TTurtleComplex; result : TFhirObservationComponent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.component.code'));{q3b}
    if obj.has('http://hl7.org/fhir/Observation.component.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueRatio', item) then
      result.value := parseRatio(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueSampledData', item) then
      result.value := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueDateTime', item) then
      result.value := parseDateTime(item);
    result.dataAbsentReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.component.dataAbsentReason'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Observation.component.referenceRange') do
      result.referenceRangeList.Add(parseObservationReferenceRange(item));
end;

procedure TFHIRTurtleComposer.ComposeObservationComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationComponent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Observation.component', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Observation.component', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Observation.component', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Observation.component', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Observation.component', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Observation.component', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Observation.component', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Observation.component', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'Observation.component', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Observation.component', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Observation.component', 'valueDateTime', TFhirDateTime(elem.value), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation.component', 'dataAbsentReason', elem.dataAbsentReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(this, 'Observation.component', 'referenceRange', elem.referenceRangeList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseObservation(obj : TTurtleComplex) : TFhirObservation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservation.create;
  try
    ParseObservationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationProperties(obj : TTurtleComplex; result : TFhirObservation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Observation.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Observation.status'), CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.category'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.code'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Observation.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Observation.encounter'));{q3b}
    if obj.has('http://hl7.org/fhir/Observation.effectivePeriod', item) then
      result.effective := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Observation.effectiveDateTime', item) then
      result.effective := parseDateTime(item);
    result.issuedElement := ParseInstant(obj.complex('http://hl7.org/fhir/Observation.issued'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Observation.performer') do
      result.performerList.Add(parseReference{Resource}(item));
    if obj.has('http://hl7.org/fhir/Observation.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Observation.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Observation.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/Observation.valueRatio', item) then
      result.value := parseRatio(item);
    if obj.has('http://hl7.org/fhir/Observation.valueSampledData', item) then
      result.value := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/Observation.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Observation.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Observation.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/Observation.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Observation.valueDateTime', item) then
      result.value := parseDateTime(item);
    result.dataAbsentReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.dataAbsentReason'));{q3b}
    result.interpretation := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.interpretation'));{q3b}
    result.commentsElement := ParseString(obj.complex('http://hl7.org/fhir/Observation.comments'));{q1}
    result.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.bodySite'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.method'));{q3b}
    result.specimen := ParseReference{TFhirSpecimen}(obj.complex('http://hl7.org/fhir/Observation.specimen'));{q3b}
    result.device := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Observation.device'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Observation.referenceRange') do
      result.referenceRangeList.Add(parseObservationReferenceRange(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.related') do
      result.relatedList.Add(parseObservationRelated(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.component') do
      result.componentList.Add(parseObservationComponent(item));
end;

procedure TFHIRTurtleComposer.ComposeObservation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Observation'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Observation', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Observation', 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'Observation', 'category', elem.categoryElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'Observation', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'Observation', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Observation', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'Observation', 'effectivePeriod', TFhirPeriod(elem.effective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Observation', 'effectiveDateTime', TFhirDateTime(elem.effective), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeInstant(this, 'Observation', 'issued', elem.issuedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(this, 'Observation', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Observation', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Observation', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Observation', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Observation', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Observation', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Observation', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Observation', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'Observation', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Observation', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Observation', 'valueDateTime', TFhirDateTime(elem.value), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('dataAbsentReason') then
    ComposeCodeableConcept(this, 'Observation', 'dataAbsentReason', elem.dataAbsentReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('interpretation') then
    ComposeCodeableConcept(this, 'Observation', 'interpretation', elem.interpretationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('comments') then
    ComposeString(this, 'Observation', 'comments', elem.commentsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('bodySite') then
    ComposeCodeableConcept(this, 'Observation', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('method') then
    ComposeCodeableConcept(this, 'Observation', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('specimen') then
    ComposeReference{TFhirSpecimen}(this, 'Observation', 'specimen', elem.specimenElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('device') then
    ComposeReference{Resource}(this, 'Observation', 'device', elem.deviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('referenceRange') then
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(this, 'Observation', 'referenceRange', elem.referenceRangeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('related') then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeObservationRelated(this, 'Observation', 'related', elem.relatedList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('component') then
    for i := 0 to elem.componentList.Count - 1 do
      ComposeObservationComponent(this, 'Observation', 'component', elem.componentList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
function TFHIRTurtleParser.ParseOperationDefinitionContact(obj : TTurtleComplex) : TFhirOperationDefinitionContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinitionContact.create;
  try
    ParseOperationDefinitionContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionContactProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.contact.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.contact.telecom') do
      result.telecomList.Add(parseContactPoint(item));
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinitionContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinitionContact'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'OperationDefinition.contact', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'OperationDefinition.contact', 'telecom', elem.telecomList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseOperationDefinitionParameter(obj : TTurtleComplex) : TFhirOperationDefinitionParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinitionParameter.create;
  try
    ParseOperationDefinitionParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionParameterProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseCode(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.name'));{q1}
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.use'), CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum);
    result.minElement := ParseInteger(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.min'));{q1}
    result.maxElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.max'));{q1}
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.documentation'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.type'), CODES_TFhirOperationParameterTypeEnum, SYSTEMS_TFhirOperationParameterTypeEnum);
    result.profile := ParseReference{TFhirStructureDefinition}(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.profile'));{q3b}
    result.binding := ParseOperationDefinitionParameterBinding(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.binding'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.parameter.part') do
      result.partList.Add(parseOperationDefinitionParameter(item));
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinitionParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinitionParameter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'OperationDefinition.parameter', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'OperationDefinition.parameter', 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum, false, -1);{x.d4}
  ComposeInteger(this, 'OperationDefinition.parameter', 'min', elem.minElement, false, -1);{x.2ea}
  ComposeString(this, 'OperationDefinition.parameter', 'max', elem.maxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'OperationDefinition.parameter', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'OperationDefinition.parameter', 'type', elem.Type_Element, CODES_TFhirOperationParameterTypeEnum, SYSTEMS_TFhirOperationParameterTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(this, 'OperationDefinition.parameter', 'profile', elem.profileElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeOperationDefinitionParameterBinding(this, 'OperationDefinition.parameter', 'binding', elem.bindingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.partList.Count - 1 do
      ComposeOperationDefinitionParameter(this, 'OperationDefinition.parameter', 'part', elem.partList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseOperationDefinitionParameterBinding(obj : TTurtleComplex) : TFhirOperationDefinitionParameterBinding;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinitionParameterBinding.create;
  try
    ParseOperationDefinitionParameterBindingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionParameterBindingProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionParameterBinding);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.strengthElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.binding.strength'), CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum);
    if obj.has('http://hl7.org/fhir/OperationDefinition.parameter.binding.valueSetReference', item) {a3} then
      result.valueSet := ParseReference(item);
    if obj.has('http://hl7.org/fhir/OperationDefinition.parameter.binding.valueSetUri', item) then
      result.valueSet := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinitionParameterBinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionParameterBinding; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinitionParameterBinding'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'OperationDefinition.parameter.binding', 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, false, -1);{x.d4}
  if (elem.valueSet is TFhirReference) {2} then
    ComposeReference(this, 'OperationDefinition.parameter.binding', 'valueSetReference', TFhirReference(elem.valueSet), false,-1){x.d8}
  else if (elem.valueSet is TFhirUri) {6} then
    ComposeUri(this, 'OperationDefinition.parameter.binding', 'valueSetUri', TFhirUri(elem.valueSet), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseOperationDefinition(obj : TTurtleComplex) : TFhirOperationDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinition.create;
  try
    ParseOperationDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionProperties(obj : TTurtleComplex; result : TFhirOperationDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/OperationDefinition.url'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.status'), CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.kind'), CODES_TFhirOperationKindEnum, SYSTEMS_TFhirOperationKindEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.experimental'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.contact') do
      result.contactList.Add(parseOperationDefinitionContact(item));
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/OperationDefinition.date'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.description'));{q1}
    result.requirementsElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.requirements'));{q1}
    result.idempotentElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.idempotent'));{q1}
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/OperationDefinition.code'));{q1}
    result.notesElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.notes'));{q1}
    result.base := ParseReference{TFhirOperationDefinition}(obj.complex('http://hl7.org/fhir/OperationDefinition.base'));{q3b}
    result.systemElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.system'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.type') do
      result.type_.Add(parseEnum(item, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum));
    result.instanceElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.instance'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.parameter') do
      result.parameterList.Add(parseOperationDefinitionParameter(item));
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUri(this, 'OperationDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('version') then
    ComposeString(this, 'OperationDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'OperationDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'OperationDefinition', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'OperationDefinition', 'kind', elem.KindElement, CODES_TFhirOperationKindEnum, SYSTEMS_TFhirOperationKindEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'OperationDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'OperationDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOperationDefinitionContact(this, 'OperationDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('date') then
    ComposeDateTime(this, 'OperationDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeString(this, 'OperationDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeString(this, 'OperationDefinition', 'requirements', elem.requirementsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('idempotent') then
    ComposeBoolean(this, 'OperationDefinition', 'idempotent', elem.idempotentElement, false, -1);{x.2ea}
  ComposeCode(this, 'OperationDefinition', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('notes') then
    ComposeString(this, 'OperationDefinition', 'notes', elem.notesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('base') then
    ComposeReference{TFhirOperationDefinition}(this, 'OperationDefinition', 'base', elem.baseElement, false, -1);{x.2f}
  ComposeBoolean(this, 'OperationDefinition', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    for i := 0 to elem.type_.Count - 1 do
      ComposeEnum(this, 'OperationDefinition', 'type', elem.type_[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    for i := 0 to elem.type_.Count - 1 do
      ComposeEnum(this, 'OperationDefinition', 'type', elem.type_[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i);{x.d2}
  ComposeBoolean(this, 'OperationDefinition', 'instance', elem.instanceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('parameter') then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeOperationDefinitionParameter(this, 'OperationDefinition', 'parameter', elem.parameterList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
function TFHIRTurtleParser.ParseOperationOutcomeIssue(obj : TTurtleComplex) : TFhirOperationOutcomeIssue;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationOutcomeIssue.create;
  try
    ParseOperationOutcomeIssueProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationOutcomeIssueProperties(obj : TTurtleComplex; result : TFhirOperationOutcomeIssue);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.severityElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationOutcome.issue.severity'), CODES_TFhirIssueSeverityEnum, SYSTEMS_TFhirIssueSeverityEnum);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationOutcome.issue.code'), CODES_TFhirIssueTypeEnum, SYSTEMS_TFhirIssueTypeEnum);
    result.details := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/OperationOutcome.issue.details'));{q3b}
    result.diagnosticsElement := ParseString(obj.complex('http://hl7.org/fhir/OperationOutcome.issue.diagnostics'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/OperationOutcome.issue.location') do
      result.locationList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeOperationOutcomeIssue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationOutcomeIssue; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationOutcomeIssue'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'OperationOutcome.issue', 'severity', elem.SeverityElement, CODES_TFhirIssueSeverityEnum, SYSTEMS_TFhirIssueSeverityEnum, false, -1);{x.d4}
  ComposeEnum(this, 'OperationOutcome.issue', 'code', elem.CodeElement, CODES_TFhirIssueTypeEnum, SYSTEMS_TFhirIssueTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'OperationOutcome.issue', 'details', elem.detailsElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'OperationOutcome.issue', 'diagnostics', elem.diagnosticsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeString(this, 'OperationOutcome.issue', 'location', elem.locationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseOperationOutcome(obj : TTurtleComplex) : TFhirOperationOutcome;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationOutcome.create;
  try
    ParseOperationOutcomeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationOutcomeProperties(obj : TTurtleComplex; result : TFhirOperationOutcome);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/OperationOutcome.issue') do
      result.issueList.Add(parseOperationOutcomeIssue(item));
end;

procedure TFHIRTurtleComposer.ComposeOperationOutcome(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationOutcome; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationOutcome'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  for i := 0 to elem.issueList.Count - 1 do
      ComposeOperationOutcomeIssue(this, 'OperationOutcome', 'issue', elem.issueList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
function TFHIRTurtleParser.ParseOrderWhen(obj : TTurtleComplex) : TFhirOrderWhen;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOrderWhen.create;
  try
    ParseOrderWhenProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOrderWhenProperties(obj : TTurtleComplex; result : TFhirOrderWhen);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Order.when.code'));{q3b}
    result.schedule := ParseTiming(obj.complex('http://hl7.org/fhir/Order.when.schedule'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeOrderWhen(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrderWhen; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OrderWhen'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Order.when', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(this, 'Order.when', 'schedule', elem.scheduleElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseOrder(obj : TTurtleComplex) : TFhirOrder;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOrder.create;
  try
    ParseOrderProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOrderProperties(obj : TTurtleComplex; result : TFhirOrder);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Order.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Order.date'));{q1}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Order.subject'));{q3b}
    result.source := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Order.source'));{q3b}
    result.target := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Order.target'));{q3b}
    if obj.has('http://hl7.org/fhir/Order.reasonCodeableConcept', item) then
      result.reason := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Order.reasonReference', item) {a3} then
      result.reason := ParseReference(item);
    result.when := ParseOrderWhen(obj.complex('http://hl7.org/fhir/Order.when'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Order.detail') do
      result.detailList.Add(parseReference{TFhirReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeOrder(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrder; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Order'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Order', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'Order', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'Order', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{Resource}(this, 'Order', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{Resource}(this, 'Order', 'target', elem.targetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Order', 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(this, 'Order', 'reasonReference', TFhirReference(elem.reason), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('when') then
    ComposeOrderWhen(this, 'Order', 'when', elem.whenElement, false, -1);{x.2f}
  for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Order', 'detail', elem.detailList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
function TFHIRTurtleParser.ParseOrderResponse(obj : TTurtleComplex) : TFhirOrderResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOrderResponse.create;
  try
    ParseOrderResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOrderResponseProperties(obj : TTurtleComplex; result : TFhirOrderResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/OrderResponse.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.request := ParseReference{TFhirOrder}(obj.complex('http://hl7.org/fhir/OrderResponse.request'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/OrderResponse.date'));{q1}
    result.who := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/OrderResponse.who'));{q3b}
    result.orderStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/OrderResponse.orderStatus'), CODES_TFhirOrderStatusEnum, SYSTEMS_TFhirOrderStatusEnum);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/OrderResponse.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/OrderResponse.fulfillment') do
      result.fulfillmentList.Add(parseReference{TFhirReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeOrderResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrderResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OrderResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'OrderResponse', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeReference{TFhirOrder}(this, 'OrderResponse', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'OrderResponse', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('who') then
    ComposeReference{Resource}(this, 'OrderResponse', 'who', elem.whoElement, false, -1);{x.2f}
  ComposeEnum(this, 'OrderResponse', 'orderStatus', elem.OrderStatusElement, CODES_TFhirOrderStatusEnum, SYSTEMS_TFhirOrderStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'OrderResponse', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fulfillment') then
    for i := 0 to elem.fulfillmentList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'OrderResponse', 'fulfillment', elem.fulfillmentList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
function TFHIRTurtleParser.ParseOrganizationContact(obj : TTurtleComplex) : TFhirOrganizationContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOrganizationContact.create;
  try
    ParseOrganizationContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOrganizationContactProperties(obj : TTurtleComplex; result : TFhirOrganizationContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.purpose := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Organization.contact.purpose'));{q3b}
    result.name := ParseHumanName(obj.complex('http://hl7.org/fhir/Organization.contact.name'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Organization.contact.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.address := ParseAddress(obj.complex('http://hl7.org/fhir/Organization.contact.address'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeOrganizationContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrganizationContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OrganizationContact'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Organization.contact', 'purpose', elem.purposeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(this, 'Organization.contact', 'name', elem.nameElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Organization.contact', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(this, 'Organization.contact', 'address', elem.addressElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseOrganization(obj : TTurtleComplex) : TFhirOrganization;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOrganization.create;
  try
    ParseOrganizationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOrganizationProperties(obj : TTurtleComplex; result : TFhirOrganization);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Organization.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Organization.active'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Organization.type'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Organization.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Organization.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    for item in obj.complexes('http://hl7.org/fhir/Organization.address') do
      result.addressList.Add(parseAddress(item));
    result.partOf := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Organization.partOf'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Organization.contact') do
      result.contactList.Add(parseOrganizationContact(item));
end;

procedure TFHIRTurtleComposer.ComposeOrganization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrganization; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Organization'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Organization', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(this, 'Organization', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Organization', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Organization', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Organization', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'Organization', 'address', elem.addressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    ComposeReference{TFhirOrganization}(this, 'Organization', 'partOf', elem.partOfElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOrganizationContact(this, 'Organization', 'contact', elem.contactList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
function TFHIRTurtleParser.ParsePatientContact(obj : TTurtleComplex) : TFhirPatientContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatientContact.create;
  try
    ParsePatientContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientContactProperties(obj : TTurtleComplex; result : TFhirPatientContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Patient.contact.relationship') do
      result.relationshipList.Add(parseCodeableConcept(item));
    result.name := ParseHumanName(obj.complex('http://hl7.org/fhir/Patient.contact.name'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Patient.contact.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.address := ParseAddress(obj.complex('http://hl7.org/fhir/Patient.contact.address'));{q3b}
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/Patient.contact.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Patient.contact.organization'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Patient.contact.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePatientContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PatientContact'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.relationshipList.Count - 1 do
      ComposeCodeableConcept(this, 'Patient.contact', 'relationship', elem.relationshipList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(this, 'Patient.contact', 'name', elem.nameElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Patient.contact', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(this, 'Patient.contact', 'address', elem.addressElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Patient.contact', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Patient.contact', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Patient.contact', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePatientAnimal(obj : TTurtleComplex) : TFhirPatientAnimal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatientAnimal.create;
  try
    ParsePatientAnimalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientAnimalProperties(obj : TTurtleComplex; result : TFhirPatientAnimal);
begin
    ParseBackboneElementProperties(obj, result);
    result.species := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Patient.animal.species'));{q3b}
    result.breed := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Patient.animal.breed'));{q3b}
    result.genderStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Patient.animal.genderStatus'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePatientAnimal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientAnimal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PatientAnimal'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Patient.animal', 'species', elem.speciesElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Patient.animal', 'breed', elem.breedElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Patient.animal', 'genderStatus', elem.genderStatusElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePatientCommunication(obj : TTurtleComplex) : TFhirPatientCommunication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatientCommunication.create;
  try
    ParsePatientCommunicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientCommunicationProperties(obj : TTurtleComplex; result : TFhirPatientCommunication);
begin
    ParseBackboneElementProperties(obj, result);
    result.language := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Patient.communication.language'));{q3b}
    result.preferredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Patient.communication.preferred'));{q1}
end;

procedure TFHIRTurtleComposer.ComposePatientCommunication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientCommunication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PatientCommunication'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Patient.communication', 'language', elem.languageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Patient.communication', 'preferred', elem.preferredElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParsePatientLink(obj : TTurtleComplex) : TFhirPatientLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatientLink.create;
  try
    ParsePatientLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientLinkProperties(obj : TTurtleComplex; result : TFhirPatientLink);
begin
    ParseBackboneElementProperties(obj, result);
    result.other := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Patient.link.other'));{q3b}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Patient.link.type'), CODES_TFhirLinkTypeEnum, SYSTEMS_TFhirLinkTypeEnum);
end;

procedure TFHIRTurtleComposer.ComposePatientLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PatientLink'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirPatient}(this, 'Patient.link', 'other', elem.otherElement, false, -1);{x.2f}
  ComposeEnum(this, 'Patient.link', 'type', elem.Type_Element, CODES_TFhirLinkTypeEnum, SYSTEMS_TFhirLinkTypeEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParsePatient(obj : TTurtleComplex) : TFhirPatient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatient.create;
  try
    ParsePatientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientProperties(obj : TTurtleComplex; result : TFhirPatient);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Patient.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Patient.active'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Patient.name') do
      result.nameList.Add(parseHumanName(item));
    for item in obj.complexes('http://hl7.org/fhir/Patient.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/Patient.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    result.birthDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Patient.birthDate'));{q1}
    if obj.has('http://hl7.org/fhir/Patient.deceasedBoolean', item) then
      result.deceased := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Patient.deceasedDateTime', item) then
      result.deceased := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/Patient.address') do
      result.addressList.Add(parseAddress(item));
    result.maritalStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Patient.maritalStatus'));{q3b}
    if obj.has('http://hl7.org/fhir/Patient.multipleBirthBoolean', item) then
      result.multipleBirth := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Patient.multipleBirthInteger', item) then
      result.multipleBirth := parseInteger(item);
    for item in obj.complexes('http://hl7.org/fhir/Patient.photo') do
      result.photoList.Add(parseAttachment(item));
    for item in obj.complexes('http://hl7.org/fhir/Patient.contact') do
      result.contactList.Add(parsePatientContact(item));
    result.animal := ParsePatientAnimal(obj.complex('http://hl7.org/fhir/Patient.animal'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Patient.communication') do
      result.communicationList.Add(parsePatientCommunication(item));
    for item in obj.complexes('http://hl7.org/fhir/Patient.careProvider') do
      result.careProviderList.Add(parseReference{Resource}(item));
    result.managingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Patient.managingOrganization'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Patient.link') do
      result.link_List.Add(parsePatientLink(item));
end;

procedure TFHIRTurtleComposer.ComposePatient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Patient'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Patient', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(this, 'Patient', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(this, 'Patient', 'name', elem.nameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Patient', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(this, 'Patient', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(this, 'Patient', 'birthDate', elem.birthDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Patient', 'deceasedBoolean', TFhirBoolean(elem.deceased), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Patient', 'deceasedDateTime', TFhirDateTime(elem.deceased), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'Patient', 'address', elem.addressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('maritalStatus') then
    ComposeCodeableConcept(this, 'Patient', 'maritalStatus', elem.maritalStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Patient', 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirInteger) {6} then
    ComposeInteger(this, 'Patient', 'multipleBirthInteger', TFhirInteger(elem.multipleBirth), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(this, 'Patient', 'photo', elem.photoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposePatientContact(this, 'Patient', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('animal') then
    ComposePatientAnimal(this, 'Patient', 'animal', elem.animalElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('communication') then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposePatientCommunication(this, 'Patient', 'communication', elem.communicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('careProvider') then
    for i := 0 to elem.careProviderList.Count - 1 do
      ComposeReference{Resource}(this, 'Patient', 'careProvider', elem.careProviderList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'Patient', 'managingOrganization', elem.managingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('link_') then
    for i := 0 to elem.link_List.Count - 1 do
      ComposePatientLink(this, 'Patient', 'link', elem.link_List[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
function TFHIRTurtleParser.ParsePaymentNotice(obj : TTurtleComplex) : TFhirPaymentNotice;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPaymentNotice.create;
  try
    ParsePaymentNoticeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePaymentNoticeProperties(obj : TTurtleComplex; result : TFhirPaymentNotice);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/PaymentNotice.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.ruleset := ParseCoding(obj.complex('http://hl7.org/fhir/PaymentNotice.ruleset'));{q3b}
    result.originalRuleset := ParseCoding(obj.complex('http://hl7.org/fhir/PaymentNotice.originalRuleset'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/PaymentNotice.created'));{q1}
    result.target := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/PaymentNotice.target'));{q3b}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/PaymentNotice.provider'));{q3b}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/PaymentNotice.organization'));{q3b}
    result.request := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/PaymentNotice.request'));{q3b}
    result.response := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/PaymentNotice.response'));{q3b}
    result.paymentStatus := ParseCoding(obj.complex('http://hl7.org/fhir/PaymentNotice.paymentStatus'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePaymentNotice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentNotice; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PaymentNotice'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PaymentNotice', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(this, 'PaymentNotice', 'ruleset', elem.rulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(this, 'PaymentNotice', 'originalRuleset', elem.originalRulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(this, 'PaymentNotice', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(this, 'PaymentNotice', 'target', elem.targetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(this, 'PaymentNotice', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'PaymentNotice', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirReference}(this, 'PaymentNotice', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('response') then
    ComposeReference{TFhirReference}(this, 'PaymentNotice', 'response', elem.responseElement, false, -1);{x.2f}
  ComposeCoding(this, 'PaymentNotice', 'paymentStatus', elem.paymentStatusElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
function TFHIRTurtleParser.ParsePaymentReconciliationDetail(obj : TTurtleComplex) : TFhirPaymentReconciliationDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPaymentReconciliationDetail.create;
  try
    ParsePaymentReconciliationDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePaymentReconciliationDetailProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliationDetail);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.type'));{q3b}
    result.request := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.request'));{q3b}
    result.responce := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.responce'));{q3b}
    result.submitter := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.submitter'));{q3b}
    result.payee := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.payee'));{q3b}
    result.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.date'));{q1}
    result.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.amount'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePaymentReconciliationDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliationDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PaymentReconciliationDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'PaymentReconciliation.detail', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'PaymentReconciliation.detail', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'PaymentReconciliation.detail', 'responce', elem.responceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'PaymentReconciliation.detail', 'submitter', elem.submitterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'PaymentReconciliation.detail', 'payee', elem.payeeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'PaymentReconciliation.detail', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'PaymentReconciliation.detail', 'amount', elem.amountElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePaymentReconciliationNote(obj : TTurtleComplex) : TFhirPaymentReconciliationNote;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPaymentReconciliationNote.create;
  try
    ParsePaymentReconciliationNoteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePaymentReconciliationNoteProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliationNote);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/PaymentReconciliation.note.type'));{q3b}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/PaymentReconciliation.note.text'));{q1}
end;

procedure TFHIRTurtleComposer.ComposePaymentReconciliationNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliationNote; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PaymentReconciliationNote'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'PaymentReconciliation.note', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'PaymentReconciliation.note', 'text', elem.textElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParsePaymentReconciliation(obj : TTurtleComplex) : TFhirPaymentReconciliation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPaymentReconciliation.create;
  try
    ParsePaymentReconciliationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePaymentReconciliationProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/PaymentReconciliation.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.request := ParseReference{TFhirProcessRequest}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.request'));{q3b}
    result.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/PaymentReconciliation.outcome'), CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    result.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/PaymentReconciliation.disposition'));{q1}
    result.ruleset := ParseCoding(obj.complex('http://hl7.org/fhir/PaymentReconciliation.ruleset'));{q3b}
    result.originalRuleset := ParseCoding(obj.complex('http://hl7.org/fhir/PaymentReconciliation.originalRuleset'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/PaymentReconciliation.created'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/PaymentReconciliation.period'));{q3b}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.organization'));{q3b}
    result.requestProvider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.requestProvider'));{q3b}
    result.requestOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.requestOrganization'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/PaymentReconciliation.detail') do
      result.detailList.Add(parsePaymentReconciliationDetail(item));
    result.form := ParseCoding(obj.complex('http://hl7.org/fhir/PaymentReconciliation.form'));{q3b}
    result.total := ParseQuantity(obj.complex('http://hl7.org/fhir/PaymentReconciliation.total'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/PaymentReconciliation.note') do
      result.noteList.Add(parsePaymentReconciliationNote(item));
end;

procedure TFHIRTurtleComposer.ComposePaymentReconciliation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PaymentReconciliation'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PaymentReconciliation', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirProcessRequest}(this, 'PaymentReconciliation', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnum(this, 'PaymentReconciliation', 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeString(this, 'PaymentReconciliation', 'disposition', elem.dispositionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(this, 'PaymentReconciliation', 'ruleset', elem.rulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(this, 'PaymentReconciliation', 'originalRuleset', elem.originalRulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(this, 'PaymentReconciliation', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'PaymentReconciliation', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'PaymentReconciliation', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(this, 'PaymentReconciliation', 'requestProvider', elem.requestProviderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(this, 'PaymentReconciliation', 'requestOrganization', elem.requestOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('detail') then
    for i := 0 to elem.detailList.Count - 1 do
      ComposePaymentReconciliationDetail(this, 'PaymentReconciliation', 'detail', elem.detailList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('form') then
    ComposeCoding(this, 'PaymentReconciliation', 'form', elem.formElement, false, -1);{x.2f}
  ComposeQuantity(this, 'PaymentReconciliation', 'total', elem.totalElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposePaymentReconciliationNote(this, 'PaymentReconciliation', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
function TFHIRTurtleParser.ParsePersonLink(obj : TTurtleComplex) : TFhirPersonLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPersonLink.create;
  try
    ParsePersonLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePersonLinkProperties(obj : TTurtleComplex; result : TFhirPersonLink);
begin
    ParseBackboneElementProperties(obj, result);
    result.target := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Person.link.target'));{q3b}
    result.assuranceElement := ParseEnum(obj.complex('http://hl7.org/fhir/Person.link.assurance'), CODES_TFhirIdentityAssuranceLevelEnum, SYSTEMS_TFhirIdentityAssuranceLevelEnum);
end;

procedure TFHIRTurtleComposer.ComposePersonLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPersonLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PersonLink'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'Person.link', 'target', elem.targetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Person.link', 'assurance', elem.AssuranceElement, CODES_TFhirIdentityAssuranceLevelEnum, SYSTEMS_TFhirIdentityAssuranceLevelEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParsePerson(obj : TTurtleComplex) : TFhirPerson;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPerson.create;
  try
    ParsePersonProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePersonProperties(obj : TTurtleComplex; result : TFhirPerson);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Person.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Person.name') do
      result.nameList.Add(parseHumanName(item));
    for item in obj.complexes('http://hl7.org/fhir/Person.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/Person.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    result.birthDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Person.birthDate'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Person.address') do
      result.addressList.Add(parseAddress(item));
    result.photo := ParseAttachment(obj.complex('http://hl7.org/fhir/Person.photo'));{q3b}
    result.managingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Person.managingOrganization'));{q3b}
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Person.active'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Person.link') do
      result.link_List.Add(parsePersonLink(item));
end;

procedure TFHIRTurtleComposer.ComposePerson(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPerson; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Person'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Person', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(this, 'Person', 'name', elem.nameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Person', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(this, 'Person', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(this, 'Person', 'birthDate', elem.birthDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'Person', 'address', elem.addressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    ComposeAttachment(this, 'Person', 'photo', elem.photoElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'Person', 'managingOrganization', elem.managingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBoolean(this, 'Person', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('link_') then
    for i := 0 to elem.link_List.Count - 1 do
      ComposePersonLink(this, 'Person', 'link', elem.link_List[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
function TFHIRTurtleParser.ParsePractitionerPractitionerRole(obj : TTurtleComplex) : TFhirPractitionerPractitionerRole;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPractitionerPractitionerRole.create;
  try
    ParsePractitionerPractitionerRoleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePractitionerPractitionerRoleProperties(obj : TTurtleComplex; result : TFhirPractitionerPractitionerRole);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.managingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Practitioner.practitionerRole.managingOrganization'));{q3b}
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Practitioner.practitionerRole.role'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.practitionerRole.specialty') do
      result.specialtyList.Add(parseCodeableConcept(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Practitioner.practitionerRole.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.practitionerRole.location') do
      result.locationList.Add(parseReference{TFhirLocation}(item));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.practitionerRole.healthcareService') do
      result.healthcareServiceList.Add(parseReference{TFhirHealthcareService}(item));
end;

procedure TFHIRTurtleComposer.ComposePractitionerPractitionerRole(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerPractitionerRole; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PractitionerPractitionerRole'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Practitioner.practitionerRole', 'managingOrganization', elem.managingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Practitioner.practitionerRole', 'role', elem.roleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'Practitioner.practitionerRole', 'specialty', elem.specialtyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Practitioner.practitionerRole', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'Practitioner.practitionerRole', 'location', elem.locationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.healthcareServiceList.Count - 1 do
      ComposeReference{TFhirHealthcareService}(this, 'Practitioner.practitionerRole', 'healthcareService', elem.healthcareServiceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParsePractitionerQualification(obj : TTurtleComplex) : TFhirPractitionerQualification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPractitionerQualification.create;
  try
    ParsePractitionerQualificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePractitionerQualificationProperties(obj : TTurtleComplex; result : TFhirPractitionerQualification);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.qualification.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Practitioner.qualification.code'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Practitioner.qualification.period'));{q3b}
    result.issuer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Practitioner.qualification.issuer'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePractitionerQualification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerQualification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PractitionerQualification'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Practitioner.qualification', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Practitioner.qualification', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Practitioner.qualification', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Practitioner.qualification', 'issuer', elem.issuerElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePractitioner(obj : TTurtleComplex) : TFhirPractitioner;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPractitioner.create;
  try
    ParsePractitionerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePractitionerProperties(obj : TTurtleComplex; result : TFhirPractitioner);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Practitioner.active'));{q1}
    result.name := ParseHumanName(obj.complex('http://hl7.org/fhir/Practitioner.name'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.address') do
      result.addressList.Add(parseAddress(item));
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/Practitioner.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    result.birthDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Practitioner.birthDate'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.photo') do
      result.photoList.Add(parseAttachment(item));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.practitionerRole') do
      result.practitionerRoleList.Add(parsePractitionerPractitionerRole(item));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.qualification') do
      result.qualificationList.Add(parsePractitionerQualification(item));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.communication') do
      result.communicationList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposePractitioner(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitioner; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Practitioner'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Practitioner', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(this, 'Practitioner', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeHumanName(this, 'Practitioner', 'name', elem.nameElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Practitioner', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'Practitioner', 'address', elem.addressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(this, 'Practitioner', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(this, 'Practitioner', 'birthDate', elem.birthDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(this, 'Practitioner', 'photo', elem.photoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('practitionerRole') then
    for i := 0 to elem.practitionerRoleList.Count - 1 do
      ComposePractitionerPractitionerRole(this, 'Practitioner', 'practitionerRole', elem.practitionerRoleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('qualification') then
    for i := 0 to elem.qualificationList.Count - 1 do
      ComposePractitionerQualification(this, 'Practitioner', 'qualification', elem.qualificationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('communication') then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(this, 'Practitioner', 'communication', elem.communicationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
function TFHIRTurtleParser.ParseProcedurePerformer(obj : TTurtleComplex) : TFhirProcedurePerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcedurePerformer.create;
  try
    ParseProcedurePerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcedurePerformerProperties(obj : TTurtleComplex; result : TFhirProcedurePerformer);
begin
    ParseBackboneElementProperties(obj, result);
    result.actor := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Procedure.performer.actor'));{q3b}
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.performer.role'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeProcedurePerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedurePerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcedurePerformer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Procedure.performer', 'actor', elem.actorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Procedure.performer', 'role', elem.roleElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseProcedureFocalDevice(obj : TTurtleComplex) : TFhirProcedureFocalDevice;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcedureFocalDevice.create;
  try
    ParseProcedureFocalDeviceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcedureFocalDeviceProperties(obj : TTurtleComplex; result : TFhirProcedureFocalDevice);
begin
    ParseBackboneElementProperties(obj, result);
    result.action := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.focalDevice.action'));{q3b}
    result.manipulated := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/Procedure.focalDevice.manipulated'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeProcedureFocalDevice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedureFocalDevice; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcedureFocalDevice'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Procedure.focalDevice', 'action', elem.actionElement, false, -1);{x.2f}
  ComposeReference{TFhirDevice}(this, 'Procedure.focalDevice', 'manipulated', elem.manipulatedElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseProcedure(obj : TTurtleComplex) : TFhirProcedure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcedure.create;
  try
    ParseProcedureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcedureProperties(obj : TTurtleComplex; result : TFhirProcedure);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Procedure.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Procedure.subject'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Procedure.status'), CODES_TFhirProcedureStatusEnum, SYSTEMS_TFhirProcedureStatusEnum);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.category'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.code'));{q3b}
    result.notPerformedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Procedure.notPerformed'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Procedure.reasonNotPerformed') do
      result.reasonNotPerformedList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.bodySite') do
      result.bodySiteList.Add(parseCodeableConcept(item));
    if obj.has('http://hl7.org/fhir/Procedure.reasonCodeableConcept', item) then
      result.reason := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Procedure.reasonReference', item) {a3} then
      result.reason := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/Procedure.performer') do
      result.performerList.Add(parseProcedurePerformer(item));
    if obj.has('http://hl7.org/fhir/Procedure.performedPeriod', item) then
      result.performed := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Procedure.performedDateTime', item) then
      result.performed := parseDateTime(item);
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Procedure.encounter'));{q3b}
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Procedure.location'));{q3b}
    result.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.outcome'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Procedure.report') do
      result.reportList.Add(parseReference{TFhirDiagnosticReport}(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.complication') do
      result.complicationList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.followUp') do
      result.followUpList.Add(parseCodeableConcept(item));
    result.request := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Procedure.request'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Procedure.notes') do
      result.notesList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.focalDevice') do
      result.focalDeviceList.Add(parseProcedureFocalDevice(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.used') do
      result.usedList.Add(parseReference{Resource}(item));
end;

procedure TFHIRTurtleComposer.ComposeProcedure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Procedure'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Procedure', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeReference{Resource}(this, 'Procedure', 'subject', elem.subjectElement, false, -1);{x.2f}
  ComposeEnum(this, 'Procedure', 'status', elem.StatusElement, CODES_TFhirProcedureStatusEnum, SYSTEMS_TFhirProcedureStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'Procedure', 'category', elem.categoryElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'Procedure', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.notPerformed <> false)) and doCompose('notPerformed') then
    ComposeBoolean(this, 'Procedure', 'notPerformed', elem.notPerformedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonNotPerformed') then
    for i := 0 to elem.reasonNotPerformedList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'reasonNotPerformed', elem.reasonNotPerformedList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'bodySite', elem.bodySiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Procedure', 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(this, 'Procedure', 'reasonReference', TFhirReference(elem.reason), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeProcedurePerformer(this, 'Procedure', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirPeriod) {6} then
    ComposePeriod(this, 'Procedure', 'performedPeriod', TFhirPeriod(elem.performed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Procedure', 'performedDateTime', TFhirDateTime(elem.performed), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Procedure', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'Procedure', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(this, 'Procedure', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('report') then
    for i := 0 to elem.reportList.Count - 1 do
      ComposeReference{TFhirDiagnosticReport}(this, 'Procedure', 'report', elem.reportList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('complication') then
    for i := 0 to elem.complicationList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'complication', elem.complicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('followUp') then
    for i := 0 to elem.followUpList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'followUp', elem.followUpList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{Resource}(this, 'Procedure', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('notes') then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeAnnotation(this, 'Procedure', 'notes', elem.notesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('focalDevice') then
    for i := 0 to elem.focalDeviceList.Count - 1 do
      ComposeProcedureFocalDevice(this, 'Procedure', 'focalDevice', elem.focalDeviceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('used') then
    for i := 0 to elem.usedList.Count - 1 do
      ComposeReference{Resource}(this, 'Procedure', 'used', elem.usedList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
function TFHIRTurtleParser.ParseProcedureRequest(obj : TTurtleComplex) : TFhirProcedureRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcedureRequest.create;
  try
    ParseProcedureRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcedureRequestProperties(obj : TTurtleComplex; result : TFhirProcedureRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ProcedureRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ProcedureRequest.subject'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ProcedureRequest.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ProcedureRequest.bodySite') do
      result.bodySiteList.Add(parseCodeableConcept(item));
    if obj.has('http://hl7.org/fhir/ProcedureRequest.reasonCodeableConcept', item) then
      result.reason := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ProcedureRequest.reasonReference', item) {a3} then
      result.reason := ParseReference(item);
    if obj.has('http://hl7.org/fhir/ProcedureRequest.scheduledPeriod', item) then
      result.scheduled := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ProcedureRequest.scheduledTiming', item) then
      result.scheduled := parseTiming(item);
    if obj.has('http://hl7.org/fhir/ProcedureRequest.scheduledDateTime', item) then
      result.scheduled := parseDateTime(item);
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/ProcedureRequest.encounter'));{q3b}
    result.performer := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ProcedureRequest.performer'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ProcedureRequest.status'), CODES_TFhirProcedureRequestStatusEnum, SYSTEMS_TFhirProcedureRequestStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/ProcedureRequest.notes') do
      result.notesList.Add(parseAnnotation(item));
    if obj.has('http://hl7.org/fhir/ProcedureRequest.asNeededCodeableConcept', item) then
      result.asNeeded := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ProcedureRequest.asNeededBoolean', item) then
      result.asNeeded := parseBoolean(item);
    result.orderedOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ProcedureRequest.orderedOn'));{q1}
    result.orderer := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ProcedureRequest.orderer'));{q3b}
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/ProcedureRequest.priority'), CODES_TFhirProcedureRequestPriorityEnum, SYSTEMS_TFhirProcedureRequestPriorityEnum);
end;

procedure TFHIRTurtleComposer.ComposeProcedureRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedureRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcedureRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ProcedureRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeReference{Resource}(this, 'ProcedureRequest', 'subject', elem.subjectElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'ProcedureRequest', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ProcedureRequest', 'bodySite', elem.bodySiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ProcedureRequest', 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(this, 'ProcedureRequest', 'reasonReference', TFhirReference(elem.reason), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(this, 'ProcedureRequest', 'scheduledPeriod', TFhirPeriod(elem.scheduled), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirTiming) {6} then
    ComposeTiming(this, 'ProcedureRequest', 'scheduledTiming', TFhirTiming(elem.scheduled), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ProcedureRequest', 'scheduledDateTime', TFhirDateTime(elem.scheduled), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'ProcedureRequest', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{Resource}(this, 'ProcedureRequest', 'performer', elem.performerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'ProcedureRequest', 'status', elem.StatusElement, CODES_TFhirProcedureRequestStatusEnum, SYSTEMS_TFhirProcedureRequestStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notes') then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeAnnotation(this, 'ProcedureRequest', 'notes', elem.notesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ProcedureRequest', 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ProcedureRequest', 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderedOn') then
    ComposeDateTime(this, 'ProcedureRequest', 'orderedOn', elem.orderedOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderer') then
    ComposeReference{Resource}(this, 'ProcedureRequest', 'orderer', elem.ordererElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(this, 'ProcedureRequest', 'priority', elem.PriorityElement, CODES_TFhirProcedureRequestPriorityEnum, SYSTEMS_TFhirProcedureRequestPriorityEnum, false, -1);{x.d4}
end;

{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
function TFHIRTurtleParser.ParseProcessRequestItem(obj : TTurtleComplex) : TFhirProcessRequestItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcessRequestItem.create;
  try
    ParseProcessRequestItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcessRequestItemProperties(obj : TTurtleComplex; result : TFhirProcessRequestItem);
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceLinkIdElement := ParseInteger(obj.complex('http://hl7.org/fhir/ProcessRequest.item.sequenceLinkId'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeProcessRequestItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcessRequestItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcessRequestItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeInteger(this, 'ProcessRequest.item', 'sequenceLinkId', elem.sequenceLinkIdElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseProcessRequest(obj : TTurtleComplex) : TFhirProcessRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcessRequest.create;
  try
    ParseProcessRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcessRequestProperties(obj : TTurtleComplex; result : TFhirProcessRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.actionElement := ParseEnum(obj.complex('http://hl7.org/fhir/ProcessRequest.action'), CODES_TFhirActionlistEnum, SYSTEMS_TFhirActionlistEnum);
    for item in obj.complexes('http://hl7.org/fhir/ProcessRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.ruleset := ParseCoding(obj.complex('http://hl7.org/fhir/ProcessRequest.ruleset'));{q3b}
    result.originalRuleset := ParseCoding(obj.complex('http://hl7.org/fhir/ProcessRequest.originalRuleset'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ProcessRequest.created'));{q1}
    result.target := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ProcessRequest.target'));{q3b}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ProcessRequest.provider'));{q3b}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ProcessRequest.organization'));{q3b}
    result.request := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/ProcessRequest.request'));{q3b}
    result.response := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/ProcessRequest.response'));{q3b}
    result.nullifyElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ProcessRequest.nullify'));{q1}
    result.referenceElement := ParseString(obj.complex('http://hl7.org/fhir/ProcessRequest.reference'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ProcessRequest.item') do
      result.itemList.Add(parseProcessRequestItem(item));
    for item in obj.complexes('http://hl7.org/fhir/ProcessRequest.include') do
      result.includeList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/ProcessRequest.exclude') do
      result.excludeList.Add(parseString(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/ProcessRequest.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeProcessRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcessRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcessRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeEnum(this, 'ProcessRequest', 'action', elem.ActionElement, CODES_TFhirActionlistEnum, SYSTEMS_TFhirActionlistEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ProcessRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(this, 'ProcessRequest', 'ruleset', elem.rulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(this, 'ProcessRequest', 'originalRuleset', elem.originalRulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(this, 'ProcessRequest', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(this, 'ProcessRequest', 'target', elem.targetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(this, 'ProcessRequest', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'ProcessRequest', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirReference}(this, 'ProcessRequest', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('response') then
    ComposeReference{TFhirReference}(this, 'ProcessRequest', 'response', elem.responseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('nullify') then
    ComposeBoolean(this, 'ProcessRequest', 'nullify', elem.nullifyElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reference') then
    ComposeString(this, 'ProcessRequest', 'reference', elem.referenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeProcessRequestItem(this, 'ProcessRequest', 'item', elem.itemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('include') then
    for i := 0 to elem.includeList.Count - 1 do
      ComposeString(this, 'ProcessRequest', 'include', elem.includeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('exclude') then
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeString(this, 'ProcessRequest', 'exclude', elem.excludeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'ProcessRequest', 'period', elem.periodElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
function TFHIRTurtleParser.ParseProcessResponseNotes(obj : TTurtleComplex) : TFhirProcessResponseNotes;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcessResponseNotes.create;
  try
    ParseProcessResponseNotesProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcessResponseNotesProperties(obj : TTurtleComplex; result : TFhirProcessResponseNotes);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/ProcessResponse.notes.type'));{q3b}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/ProcessResponse.notes.text'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeProcessResponseNotes(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcessResponseNotes; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcessResponseNotes'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'ProcessResponse.notes', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ProcessResponse.notes', 'text', elem.textElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseProcessResponse(obj : TTurtleComplex) : TFhirProcessResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcessResponse.create;
  try
    ParseProcessResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcessResponseProperties(obj : TTurtleComplex; result : TFhirProcessResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ProcessResponse.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.request := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/ProcessResponse.request'));{q3b}
    result.outcome := ParseCoding(obj.complex('http://hl7.org/fhir/ProcessResponse.outcome'));{q3b}
    result.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/ProcessResponse.disposition'));{q1}
    result.ruleset := ParseCoding(obj.complex('http://hl7.org/fhir/ProcessResponse.ruleset'));{q3b}
    result.originalRuleset := ParseCoding(obj.complex('http://hl7.org/fhir/ProcessResponse.originalRuleset'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ProcessResponse.created'));{q1}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ProcessResponse.organization'));{q3b}
    result.requestProvider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ProcessResponse.requestProvider'));{q3b}
    result.requestOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ProcessResponse.requestOrganization'));{q3b}
    result.form := ParseCoding(obj.complex('http://hl7.org/fhir/ProcessResponse.form'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ProcessResponse.notes') do
      result.notesList.Add(parseProcessResponseNotes(item));
    for item in obj.complexes('http://hl7.org/fhir/ProcessResponse.error') do
      result.errorList.Add(parseCoding(item));
end;

procedure TFHIRTurtleComposer.ComposeProcessResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcessResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcessResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ProcessResponse', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirReference}(this, 'ProcessResponse', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeCoding(this, 'ProcessResponse', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeString(this, 'ProcessResponse', 'disposition', elem.dispositionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(this, 'ProcessResponse', 'ruleset', elem.rulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(this, 'ProcessResponse', 'originalRuleset', elem.originalRulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(this, 'ProcessResponse', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'ProcessResponse', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(this, 'ProcessResponse', 'requestProvider', elem.requestProviderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(this, 'ProcessResponse', 'requestOrganization', elem.requestOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('form') then
    ComposeCoding(this, 'ProcessResponse', 'form', elem.formElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notes') then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeProcessResponseNotes(this, 'ProcessResponse', 'notes', elem.notesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('error') then
    for i := 0 to elem.errorList.Count - 1 do
      ComposeCoding(this, 'ProcessResponse', 'error', elem.errorList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
function TFHIRTurtleParser.ParseProvenanceAgent(obj : TTurtleComplex) : TFhirProvenanceAgent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProvenanceAgent.create;
  try
    ParseProvenanceAgentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProvenanceAgentProperties(obj : TTurtleComplex; result : TFhirProvenanceAgent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.role := ParseCoding(obj.complex('http://hl7.org/fhir/Provenance.agent.role'));{q3b}
    result.actor := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Provenance.agent.actor'));{q3b}
    result.userId := ParseIdentifier(obj.complex('http://hl7.org/fhir/Provenance.agent.userId'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Provenance.agent.relatedAgent') do
      result.relatedAgentList.Add(parseProvenanceAgentRelatedAgent(item));
end;

procedure TFHIRTurtleComposer.ComposeProvenanceAgent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenanceAgent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProvenanceAgent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'Provenance.agent', 'role', elem.roleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Provenance.agent', 'actor', elem.actorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Provenance.agent', 'userId', elem.userIdElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.relatedAgentList.Count - 1 do
      ComposeProvenanceAgentRelatedAgent(this, 'Provenance.agent', 'relatedAgent', elem.relatedAgentList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseProvenanceAgentRelatedAgent(obj : TTurtleComplex) : TFhirProvenanceAgentRelatedAgent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProvenanceAgentRelatedAgent.create;
  try
    ParseProvenanceAgentRelatedAgentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProvenanceAgentRelatedAgentProperties(obj : TTurtleComplex; result : TFhirProvenanceAgentRelatedAgent);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Provenance.agent.relatedAgent.type'));{q3b}
    result.targetElement := ParseUri(obj.complex('http://hl7.org/fhir/Provenance.agent.relatedAgent.target'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeProvenanceAgentRelatedAgent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenanceAgentRelatedAgent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProvenanceAgentRelatedAgent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Provenance.agent.relatedAgent', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeUri(this, 'Provenance.agent.relatedAgent', 'target', elem.targetElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseProvenanceEntity(obj : TTurtleComplex) : TFhirProvenanceEntity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProvenanceEntity.create;
  try
    ParseProvenanceEntityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProvenanceEntityProperties(obj : TTurtleComplex; result : TFhirProvenanceEntity);
begin
    ParseBackboneElementProperties(obj, result);
    result.roleElement := ParseEnum(obj.complex('http://hl7.org/fhir/Provenance.entity.role'), CODES_TFhirProvenanceEntityRoleEnum, SYSTEMS_TFhirProvenanceEntityRoleEnum);
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/Provenance.entity.type'));{q3b}
    result.referenceElement := ParseUri(obj.complex('http://hl7.org/fhir/Provenance.entity.reference'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/Provenance.entity.display'));{q1}
    result.agent := ParseProvenanceAgent(obj.complex('http://hl7.org/fhir/Provenance.entity.agent'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeProvenanceEntity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenanceEntity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProvenanceEntity'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Provenance.entity', 'role', elem.RoleElement, CODES_TFhirProvenanceEntityRoleEnum, SYSTEMS_TFhirProvenanceEntityRoleEnum, false, -1);{x.d4}
  ComposeCoding(this, 'Provenance.entity', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeUri(this, 'Provenance.entity', 'reference', elem.referenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Provenance.entity', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeProvenanceAgent(this, 'Provenance.entity', 'agent', elem.agentElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseProvenance(obj : TTurtleComplex) : TFhirProvenance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProvenance.create;
  try
    ParseProvenanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProvenanceProperties(obj : TTurtleComplex; result : TFhirProvenance);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Provenance.target') do
      result.targetList.Add(parseReference{TFhirReference}(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Provenance.period'));{q3b}
    result.recordedElement := ParseInstant(obj.complex('http://hl7.org/fhir/Provenance.recorded'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Provenance.reason') do
      result.reasonList.Add(parseCodeableConcept(item));
    result.activity := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Provenance.activity'));{q3b}
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Provenance.location'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Provenance.policy') do
      result.policyList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/Provenance.agent') do
      result.agentList.Add(parseProvenanceAgent(item));
    for item in obj.complexes('http://hl7.org/fhir/Provenance.entity') do
      result.entityList.Add(parseProvenanceEntity(item));
    for item in obj.complexes('http://hl7.org/fhir/Provenance.signature') do
      result.signatureList.Add(parseSignature(item));
end;

procedure TFHIRTurtleComposer.ComposeProvenance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Provenance'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  for i := 0 to elem.targetList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Provenance', 'target', elem.targetList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'Provenance', 'period', elem.periodElement, false, -1);{x.2f}
  ComposeInstant(this, 'Provenance', 'recorded', elem.recordedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Provenance', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('activity') then
    ComposeCodeableConcept(this, 'Provenance', 'activity', elem.activityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'Provenance', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('policy') then
    for i := 0 to elem.policyList.Count - 1 do
      ComposeUri(this, 'Provenance', 'policy', elem.policyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('agent') then
    for i := 0 to elem.agentList.Count - 1 do
      ComposeProvenanceAgent(this, 'Provenance', 'agent', elem.agentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('entity') then
    for i := 0 to elem.entityList.Count - 1 do
      ComposeProvenanceEntity(this, 'Provenance', 'entity', elem.entityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('signature') then
    for i := 0 to elem.signatureList.Count - 1 do
      ComposeSignature(this, 'Provenance', 'signature', elem.signatureList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
function TFHIRTurtleParser.ParseQuestionnaireGroup(obj : TTurtleComplex) : TFhirQuestionnaireGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireGroup.create;
  try
    ParseQuestionnaireGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireGroupProperties(obj : TTurtleComplex; result : TFhirQuestionnaireGroup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.linkIdElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.group.linkId'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.group.title'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.group.concept') do
      result.conceptList.Add(parseCoding(item));
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.group.text'));{q1}
    result.requiredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.group.required'));{q1}
    result.repeatsElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.group.repeats'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.group.group') do
      result.groupList.Add(parseQuestionnaireGroup(item));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.group.question') do
      result.questionList.Add(parseQuestionnaireGroupQuestion(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireGroup'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Questionnaire.group', 'linkId', elem.linkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Questionnaire.group', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCoding(this, 'Questionnaire.group', 'concept', elem.conceptList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Questionnaire.group', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.required <> false)) then
    ComposeBoolean(this, 'Questionnaire.group', 'required', elem.requiredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.repeats <> false)) then
    ComposeBoolean(this, 'Questionnaire.group', 'repeats', elem.repeatsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(this, 'Questionnaire.group', 'group', elem.groupList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.questionList.Count - 1 do
      ComposeQuestionnaireGroupQuestion(this, 'Questionnaire.group', 'question', elem.questionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseQuestionnaireGroupQuestion(obj : TTurtleComplex) : TFhirQuestionnaireGroupQuestion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireGroupQuestion.create;
  try
    ParseQuestionnaireGroupQuestionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireGroupQuestionProperties(obj : TTurtleComplex; result : TFhirQuestionnaireGroupQuestion);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.linkIdElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.group.question.linkId'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.group.question.concept') do
      result.conceptList.Add(parseCoding(item));
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.group.question.text'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Questionnaire.group.question.type'), CODES_TFhirAnswerFormatEnum, SYSTEMS_TFhirAnswerFormatEnum);
    result.requiredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.group.question.required'));{q1}
    result.repeatsElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.group.question.repeats'));{q1}
    result.options := ParseReference{TFhirValueSet}(obj.complex('http://hl7.org/fhir/Questionnaire.group.question.options'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.group.question.option') do
      result.optionList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.group.question.group') do
      result.groupList.Add(parseQuestionnaireGroup(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireGroupQuestion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireGroupQuestion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireGroupQuestion'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Questionnaire.group.question', 'linkId', elem.linkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCoding(this, 'Questionnaire.group.question', 'concept', elem.conceptList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Questionnaire.group.question', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Questionnaire.group.question', 'type', elem.Type_Element, CODES_TFhirAnswerFormatEnum, SYSTEMS_TFhirAnswerFormatEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.required <> false)) then
    ComposeBoolean(this, 'Questionnaire.group.question', 'required', elem.requiredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.repeats <> false)) then
    ComposeBoolean(this, 'Questionnaire.group.question', 'repeats', elem.repeatsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirValueSet}(this, 'Questionnaire.group.question', 'options', elem.optionsElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.optionList.Count - 1 do
      ComposeCoding(this, 'Questionnaire.group.question', 'option', elem.optionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(this, 'Questionnaire.group.question', 'group', elem.groupList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseQuestionnaire(obj : TTurtleComplex) : TFhirQuestionnaire;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaire.create;
  try
    ParseQuestionnaireProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireProperties(obj : TTurtleComplex; result : TFhirQuestionnaire);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.version'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Questionnaire.status'), CODES_TFhirQuestionnaireStatusEnum, SYSTEMS_TFhirQuestionnaireStatusEnum);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Questionnaire.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.subjectType') do
      result.subjectType.Add(parseEnum(item, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum));
    result.group := ParseQuestionnaireGroup(obj.complex('http://hl7.org/fhir/Questionnaire.group'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaire(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaire; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Questionnaire'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Questionnaire', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'Questionnaire', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Questionnaire', 'status', elem.StatusElement, CODES_TFhirQuestionnaireStatusEnum, SYSTEMS_TFhirQuestionnaireStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'Questionnaire', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'Questionnaire', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Questionnaire', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subjectType') then
    for i := 0 to elem.subjectType.Count - 1 do
      ComposeEnum(this, 'Questionnaire', 'subjectType', elem.subjectType[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subjectType') then
    for i := 0 to elem.subjectType.Count - 1 do
      ComposeEnum(this, 'Questionnaire', 'subjectType', elem.subjectType[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i);{x.d2}
  ComposeQuestionnaireGroup(this, 'Questionnaire', 'group', elem.groupElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
function TFHIRTurtleParser.ParseQuestionnaireResponseGroup(obj : TTurtleComplex) : TFhirQuestionnaireResponseGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireResponseGroup.create;
  try
    ParseQuestionnaireResponseGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireResponseGroupProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponseGroup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.linkIdElement := ParseString(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.group.linkId'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.group.title'));{q1}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.group.text'));{q1}
    result.subject := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.group.subject'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.group.group') do
      result.groupList.Add(parseQuestionnaireResponseGroup(item));
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.group.question') do
      result.questionList.Add(parseQuestionnaireResponseGroupQuestion(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireResponseGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponseGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireResponseGroup'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'QuestionnaireResponse.group', 'linkId', elem.linkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'QuestionnaireResponse.group', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'QuestionnaireResponse.group', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'QuestionnaireResponse.group', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireResponseGroup(this, 'QuestionnaireResponse.group', 'group', elem.groupList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.questionList.Count - 1 do
      ComposeQuestionnaireResponseGroupQuestion(this, 'QuestionnaireResponse.group', 'question', elem.questionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseQuestionnaireResponseGroupQuestion(obj : TTurtleComplex) : TFhirQuestionnaireResponseGroupQuestion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireResponseGroupQuestion.create;
  try
    ParseQuestionnaireResponseGroupQuestionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireResponseGroupQuestionProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponseGroupQuestion);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.linkIdElement := ParseString(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.group.question.linkId'));{q1}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.group.question.text'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.group.question.answer') do
      result.answerList.Add(parseQuestionnaireResponseGroupQuestionAnswer(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireResponseGroupQuestion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponseGroupQuestion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireResponseGroupQuestion'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'QuestionnaireResponse.group.question', 'linkId', elem.linkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'QuestionnaireResponse.group.question', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.answerList.Count - 1 do
      ComposeQuestionnaireResponseGroupQuestionAnswer(this, 'QuestionnaireResponse.group.question', 'answer', elem.answerList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseQuestionnaireResponseGroupQuestionAnswer(obj : TTurtleComplex) : TFhirQuestionnaireResponseGroupQuestionAnswer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireResponseGroupQuestionAnswer.create;
  try
    ParseQuestionnaireResponseGroupQuestionAnswerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireResponseGroupQuestionAnswerProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponseGroupQuestionAnswer);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.group.question.answer.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.group.question.answer.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.group.question.answer.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.group.question.answer.valueReference', item) {a3} then
      result.value := ParseReference(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.group.question.answer.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.group.question.answer.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.group.question.answer.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.group.question.answer.valueDate', item) then
      result.value := parseDate(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.group.question.answer.valueDateTime', item) then
      result.value := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.group.question.answer.valueInstant', item) then
      result.value := parseInstant(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.group.question.answer.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.group.question.answer.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.group.question.answer.valueUri', item) then
      result.value := parseUri(item);
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.group.question.answer.group') do
      result.groupList.Add(parseQuestionnaireResponseGroup(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireResponseGroupQuestionAnswer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponseGroupQuestionAnswer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireResponseGroupQuestionAnswer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'QuestionnaireResponse.group.question.answer', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'QuestionnaireResponse.group.question.answer', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'QuestionnaireResponse.group.question.answer', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) {2} then
    ComposeReference(this, 'QuestionnaireResponse.group.question.answer', 'valueReference', TFhirReference(elem.value), false,-1){x.d8}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'QuestionnaireResponse.group.question.answer', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'QuestionnaireResponse.group.question.answer', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'QuestionnaireResponse.group.question.answer', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'QuestionnaireResponse.group.question.answer', 'valueDate', TFhirDate(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'QuestionnaireResponse.group.question.answer', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInstant) {6} then
    ComposeInstant(this, 'QuestionnaireResponse.group.question.answer', 'valueInstant', TFhirInstant(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'QuestionnaireResponse.group.question.answer', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'QuestionnaireResponse.group.question.answer', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'QuestionnaireResponse.group.question.answer', 'valueUri', TFhirUri(elem.value), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireResponseGroup(this, 'QuestionnaireResponse.group.question.answer', 'group', elem.groupList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseQuestionnaireResponse(obj : TTurtleComplex) : TFhirQuestionnaireResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireResponse.create;
  try
    ParseQuestionnaireResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireResponseProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponse);
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.identifier'));{q3b}
    result.questionnaire := ParseReference{TFhirQuestionnaire}(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.questionnaire'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.status'), CODES_TFhirQuestionnaireAnswersStatusEnum, SYSTEMS_TFhirQuestionnaireAnswersStatusEnum);
    result.subject := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.subject'));{q3b}
    result.author := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.author'));{q3b}
    result.authoredElement := ParseDateTime(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.authored'));{q1}
    result.source := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.source'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.encounter'));{q3b}
    result.group := ParseQuestionnaireResponseGroup(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.group'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'QuestionnaireResponse', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('questionnaire') then
    ComposeReference{TFhirQuestionnaire}(this, 'QuestionnaireResponse', 'questionnaire', elem.questionnaireElement, false, -1);{x.2f}
  ComposeEnum(this, 'QuestionnaireResponse', 'status', elem.StatusElement, CODES_TFhirQuestionnaireAnswersStatusEnum, SYSTEMS_TFhirQuestionnaireAnswersStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirReference}(this, 'QuestionnaireResponse', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(this, 'QuestionnaireResponse', 'author', elem.authorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authored') then
    ComposeDateTime(this, 'QuestionnaireResponse', 'authored', elem.authoredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{Resource}(this, 'QuestionnaireResponse', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'QuestionnaireResponse', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('group') then
    ComposeQuestionnaireResponseGroup(this, 'QuestionnaireResponse', 'group', elem.groupElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
function TFHIRTurtleParser.ParseReferralRequest(obj : TTurtleComplex) : TFhirReferralRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirReferralRequest.create;
  try
    ParseReferralRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseReferralRequestProperties(obj : TTurtleComplex; result : TFhirReferralRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ReferralRequest.status'), CODES_TFhirReferralstatusEnum, SYSTEMS_TFhirReferralstatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/ReferralRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ReferralRequest.date'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ReferralRequest.type'));{q3b}
    result.specialty := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ReferralRequest.specialty'));{q3b}
    result.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ReferralRequest.priority'));{q3b}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ReferralRequest.patient'));{q3b}
    result.requester := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ReferralRequest.requester'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ReferralRequest.recipient') do
      result.recipientList.Add(parseReference{Resource}(item));
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/ReferralRequest.encounter'));{q3b}
    result.dateSentElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ReferralRequest.dateSent'));{q1}
    result.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ReferralRequest.reason'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ReferralRequest.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ReferralRequest.serviceRequested') do
      result.serviceRequestedList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ReferralRequest.supportingInformation') do
      result.supportingInformationList.Add(parseReference{TFhirReference}(item));
    result.fulfillmentTime := ParsePeriod(obj.complex('http://hl7.org/fhir/ReferralRequest.fulfillmentTime'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeReferralRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirReferralRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ReferralRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeEnum(this, 'ReferralRequest', 'status', elem.StatusElement, CODES_TFhirReferralstatusEnum, SYSTEMS_TFhirReferralstatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ReferralRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ReferralRequest', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'ReferralRequest', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('specialty') then
    ComposeCodeableConcept(this, 'ReferralRequest', 'specialty', elem.specialtyElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeCodeableConcept(this, 'ReferralRequest', 'priority', elem.priorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'ReferralRequest', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{Resource}(this, 'ReferralRequest', 'requester', elem.requesterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(this, 'ReferralRequest', 'recipient', elem.recipientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'ReferralRequest', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateSent') then
    ComposeDateTime(this, 'ReferralRequest', 'dateSent', elem.dateSentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    ComposeCodeableConcept(this, 'ReferralRequest', 'reason', elem.reasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeString(this, 'ReferralRequest', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceRequested') then
    for i := 0 to elem.serviceRequestedList.Count - 1 do
      ComposeCodeableConcept(this, 'ReferralRequest', 'serviceRequested', elem.serviceRequestedList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'ReferralRequest', 'supportingInformation', elem.supportingInformationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fulfillmentTime') then
    ComposePeriod(this, 'ReferralRequest', 'fulfillmentTime', elem.fulfillmentTimeElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
function TFHIRTurtleParser.ParseRelatedPerson(obj : TTurtleComplex) : TFhirRelatedPerson;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRelatedPerson.create;
  try
    ParseRelatedPersonProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRelatedPersonProperties(obj : TTurtleComplex; result : TFhirRelatedPerson);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/RelatedPerson.patient'));{q3b}
    result.relationship := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RelatedPerson.relationship'));{q3b}
    result.name := ParseHumanName(obj.complex('http://hl7.org/fhir/RelatedPerson.name'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/RelatedPerson.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    result.birthDateElement := ParseDate(obj.complex('http://hl7.org/fhir/RelatedPerson.birthDate'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.address') do
      result.addressList.Add(parseAddress(item));
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.photo') do
      result.photoList.Add(parseAttachment(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/RelatedPerson.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeRelatedPerson(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRelatedPerson; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RelatedPerson'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'RelatedPerson', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'RelatedPerson', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relationship') then
    ComposeCodeableConcept(this, 'RelatedPerson', 'relationship', elem.relationshipElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeHumanName(this, 'RelatedPerson', 'name', elem.nameElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'RelatedPerson', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(this, 'RelatedPerson', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(this, 'RelatedPerson', 'birthDate', elem.birthDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'RelatedPerson', 'address', elem.addressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(this, 'RelatedPerson', 'photo', elem.photoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(this, 'RelatedPerson', 'period', elem.periodElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
function TFHIRTurtleParser.ParseRiskAssessmentPrediction(obj : TTurtleComplex) : TFhirRiskAssessmentPrediction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRiskAssessmentPrediction.create;
  try
    ParseRiskAssessmentPredictionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRiskAssessmentPredictionProperties(obj : TTurtleComplex; result : TFhirRiskAssessmentPrediction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskAssessment.prediction.outcome'));{q3b}
    if obj.has('http://hl7.org/fhir/RiskAssessment.prediction.probabilityRange', item) then
      result.probability := parseRange(item);
    if obj.has('http://hl7.org/fhir/RiskAssessment.prediction.probabilityCodeableConcept', item) then
      result.probability := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/RiskAssessment.prediction.probabilityDecimal', item) then
      result.probability := parseDecimal(item);
    result.relativeRiskElement := ParseDecimal(obj.complex('http://hl7.org/fhir/RiskAssessment.prediction.relativeRisk'));{q1}
    if obj.has('http://hl7.org/fhir/RiskAssessment.prediction.whenPeriod', item) then
      result.when := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/RiskAssessment.prediction.whenRange', item) then
      result.when := parseRange(item);
    result.rationaleElement := ParseString(obj.complex('http://hl7.org/fhir/RiskAssessment.prediction.rationale'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeRiskAssessmentPrediction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskAssessmentPrediction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RiskAssessmentPrediction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'RiskAssessment.prediction', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirRange) {6} then
    ComposeRange(this, 'RiskAssessment.prediction', 'probabilityRange', TFhirRange(elem.probability), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'RiskAssessment.prediction', 'probabilityCodeableConcept', TFhirCodeableConcept(elem.probability), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirDecimal) {6} then
    ComposeDecimal(this, 'RiskAssessment.prediction', 'probabilityDecimal', TFhirDecimal(elem.probability), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'RiskAssessment.prediction', 'relativeRisk', elem.relativeRiskElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.when is TFhirPeriod) {6} then
    ComposePeriod(this, 'RiskAssessment.prediction', 'whenPeriod', TFhirPeriod(elem.when), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.when is TFhirRange) {6} then
    ComposeRange(this, 'RiskAssessment.prediction', 'whenRange', TFhirRange(elem.when), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RiskAssessment.prediction', 'rationale', elem.rationaleElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseRiskAssessment(obj : TTurtleComplex) : TFhirRiskAssessment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRiskAssessment.create;
  try
    ParseRiskAssessmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRiskAssessmentProperties(obj : TTurtleComplex; result : TFhirRiskAssessment);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/RiskAssessment.subject'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/RiskAssessment.date'));{q1}
    result.condition := ParseReference{TFhirCondition}(obj.complex('http://hl7.org/fhir/RiskAssessment.condition'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/RiskAssessment.encounter'));{q3b}
    result.performer := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/RiskAssessment.performer'));{q3b}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/RiskAssessment.identifier'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskAssessment.method'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/RiskAssessment.basis') do
      result.basisList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/RiskAssessment.prediction') do
      result.predictionList.Add(parseRiskAssessmentPrediction(item));
    result.mitigationElement := ParseString(obj.complex('http://hl7.org/fhir/RiskAssessment.mitigation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeRiskAssessment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskAssessment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RiskAssessment'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'RiskAssessment', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'RiskAssessment', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('condition') then
    ComposeReference{TFhirCondition}(this, 'RiskAssessment', 'condition', elem.conditionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'RiskAssessment', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{Resource}(this, 'RiskAssessment', 'performer', elem.performerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'RiskAssessment', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('method') then
    ComposeCodeableConcept(this, 'RiskAssessment', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('basis') then
    for i := 0 to elem.basisList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'RiskAssessment', 'basis', elem.basisList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('prediction') then
    for i := 0 to elem.predictionList.Count - 1 do
      ComposeRiskAssessmentPrediction(this, 'RiskAssessment', 'prediction', elem.predictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('mitigation') then
    ComposeString(this, 'RiskAssessment', 'mitigation', elem.mitigationElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
function TFHIRTurtleParser.ParseSchedule(obj : TTurtleComplex) : TFhirSchedule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSchedule.create;
  try
    ParseScheduleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseScheduleProperties(obj : TTurtleComplex; result : TFhirSchedule);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Schedule.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Schedule.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.actor := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Schedule.actor'));{q3b}
    result.planningHorizon := ParsePeriod(obj.complex('http://hl7.org/fhir/Schedule.planningHorizon'));{q3b}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/Schedule.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSchedule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSchedule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Schedule'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Schedule', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Schedule', 'type', elem.type_List[i], false, i);{x.d3}
  ComposeReference{Resource}(this, 'Schedule', 'actor', elem.actorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('planningHorizon') then
    ComposePeriod(this, 'Schedule', 'planningHorizon', elem.planningHorizonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(this, 'Schedule', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
function TFHIRTurtleParser.ParseSearchParameterContact(obj : TTurtleComplex) : TFhirSearchParameterContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSearchParameterContact.create;
  try
    ParseSearchParameterContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSearchParameterContactProperties(obj : TTurtleComplex; result : TFhirSearchParameterContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.contact.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.contact.telecom') do
      result.telecomList.Add(parseContactPoint(item));
end;

procedure TFHIRTurtleComposer.ComposeSearchParameterContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSearchParameterContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SearchParameterContact'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SearchParameter.contact', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'SearchParameter.contact', 'telecom', elem.telecomList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseSearchParameter(obj : TTurtleComplex) : TFhirSearchParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSearchParameter.create;
  try
    ParseSearchParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSearchParameterProperties(obj : TTurtleComplex; result : TFhirSearchParameter);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/SearchParameter.url'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/SearchParameter.status'), CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SearchParameter.experimental'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.contact') do
      result.contactList.Add(parseSearchParameterContact(item));
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/SearchParameter.date'));{q1}
    result.requirementsElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.requirements'));{q1}
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/SearchParameter.code'));{q1}
    result.baseElement := ParseEnum(obj.complex('http://hl7.org/fhir/SearchParameter.base'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/SearchParameter.type'), CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.description'));{q1}
    result.xpathElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.xpath'));{q1}
    result.xpathUsageElement := ParseEnum(obj.complex('http://hl7.org/fhir/SearchParameter.xpathUsage'), CODES_TFhirSearchXpathUsageEnum, SYSTEMS_TFhirSearchXpathUsageEnum);
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.target') do
      result.target.Add(parseEnum(item, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum));
end;

procedure TFHIRTurtleComposer.ComposeSearchParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSearchParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SearchParameter'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeUri(this, 'SearchParameter', 'url', elem.urlElement, false, -1);{x.2ea}
  ComposeString(this, 'SearchParameter', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'SearchParameter', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'SearchParameter', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'SearchParameter', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeSearchParameterContact(this, 'SearchParameter', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'SearchParameter', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeString(this, 'SearchParameter', 'requirements', elem.requirementsElement, false, -1);{x.2ea}
  ComposeCode(this, 'SearchParameter', 'code', elem.codeElement, false, -1);{x.2ea}
  ComposeEnum(this, 'SearchParameter', 'base', elem.BaseElement, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  ComposeEnum(this, 'SearchParameter', 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, false, -1);{x.d4}
  ComposeString(this, 'SearchParameter', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('xpath') then
    ComposeString(this, 'SearchParameter', 'xpath', elem.xpathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('xpathUsage') then
    ComposeEnum(this, 'SearchParameter', 'xpathUsage', elem.XpathUsageElement, CODES_TFhirSearchXpathUsageEnum, SYSTEMS_TFhirSearchXpathUsageEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('target') then
    for i := 0 to elem.target.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'target', elem.target[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) and doCompose('target') then
    for i := 0 to elem.target.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'target', elem.target[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i);{x.d2}
end;

{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
function TFHIRTurtleParser.ParseSlot(obj : TTurtleComplex) : TFhirSlot;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSlot.create;
  try
    ParseSlotProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSlotProperties(obj : TTurtleComplex; result : TFhirSlot);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Slot.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Slot.type'));{q3b}
    result.schedule := ParseReference{TFhirSchedule}(obj.complex('http://hl7.org/fhir/Slot.schedule'));{q3b}
    result.freeBusyTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Slot.freeBusyType'), CODES_TFhirSlotstatusEnum, SYSTEMS_TFhirSlotstatusEnum);
    result.startElement := ParseInstant(obj.complex('http://hl7.org/fhir/Slot.start'));{q1}
    result.end_Element := ParseInstant(obj.complex('http://hl7.org/fhir/Slot.end'));{q1}
    result.overbookedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Slot.overbooked'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/Slot.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSlot(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSlot; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Slot'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Slot', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Slot', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeReference{TFhirSchedule}(this, 'Slot', 'schedule', elem.scheduleElement, false, -1);{x.2f}
  ComposeEnum(this, 'Slot', 'freeBusyType', elem.FreeBusyTypeElement, CODES_TFhirSlotstatusEnum, SYSTEMS_TFhirSlotstatusEnum, false, -1);{x.d4}
  ComposeInstant(this, 'Slot', 'start', elem.startElement, false, -1);{x.2ea}
  ComposeInstant(this, 'Slot', 'end', elem.end_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('overbooked') then
    ComposeBoolean(this, 'Slot', 'overbooked', elem.overbookedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(this, 'Slot', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
function TFHIRTurtleParser.ParseSpecimenCollection(obj : TTurtleComplex) : TFhirSpecimenCollection;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenCollection.create;
  try
    ParseSpecimenCollectionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenCollectionProperties(obj : TTurtleComplex; result : TFhirSpecimenCollection);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.collector := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Specimen.collection.collector'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Specimen.collection.comment') do
      result.commentList.Add(parseString(item));
    if obj.has('http://hl7.org/fhir/Specimen.collection.collectedPeriod', item) then
      result.collected := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Specimen.collection.collectedDateTime', item) then
      result.collected := parseDateTime(item);
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Specimen.collection.quantity'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.collection.method'));{q3b}
    result.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.collection.bodySite'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSpecimenCollection(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenCollection; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenCollection'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'Specimen.collection', 'collector', elem.collectorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.commentList.Count - 1 do
      ComposeString(this, 'Specimen.collection', 'comment', elem.commentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirPeriod) {6} then
    ComposePeriod(this, 'Specimen.collection', 'collectedPeriod', TFhirPeriod(elem.collected), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Specimen.collection', 'collectedDateTime', TFhirDateTime(elem.collected), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Specimen.collection', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Specimen.collection', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Specimen.collection', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSpecimenTreatment(obj : TTurtleComplex) : TFhirSpecimenTreatment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenTreatment.create;
  try
    ParseSpecimenTreatmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenTreatmentProperties(obj : TTurtleComplex; result : TFhirSpecimenTreatment);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Specimen.treatment.description'));{q1}
    result.procedure_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.treatment.procedure'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Specimen.treatment.additive') do
      result.additiveList.Add(parseReference{TFhirSubstance}(item));
end;

procedure TFHIRTurtleComposer.ComposeSpecimenTreatment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenTreatment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenTreatment'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Specimen.treatment', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Specimen.treatment', 'procedure', elem.procedure_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.additiveList.Count - 1 do
      ComposeReference{TFhirSubstance}(this, 'Specimen.treatment', 'additive', elem.additiveList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseSpecimenContainer(obj : TTurtleComplex) : TFhirSpecimenContainer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenContainer.create;
  try
    ParseSpecimenContainerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenContainerProperties(obj : TTurtleComplex; result : TFhirSpecimenContainer);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Specimen.container.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Specimen.container.description'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.container.type'));{q3b}
    result.capacity := ParseQuantity(obj.complex('http://hl7.org/fhir/Specimen.container.capacity'));{q3b}
    result.specimenQuantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Specimen.container.specimenQuantity'));{q3b}
    if obj.has('http://hl7.org/fhir/Specimen.container.additiveCodeableConcept', item) then
      result.additive := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Specimen.container.additiveReference', item) {a3} then
      result.additive := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeSpecimenContainer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenContainer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenContainer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Specimen.container', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Specimen.container', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Specimen.container', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Specimen.container', 'capacity', elem.capacityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Specimen.container', 'specimenQuantity', elem.specimenQuantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Specimen.container', 'additiveCodeableConcept', TFhirCodeableConcept(elem.additive), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirReference) {2} then
    ComposeReference(this, 'Specimen.container', 'additiveReference', TFhirReference(elem.additive), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseSpecimen(obj : TTurtleComplex) : TFhirSpecimen;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimen.create;
  try
    ParseSpecimenProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenProperties(obj : TTurtleComplex; result : TFhirSpecimen);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Specimen.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Specimen.status'), CODES_TFhirSpecimenStatusEnum, SYSTEMS_TFhirSpecimenStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Specimen.parent') do
      result.parentList.Add(parseReference{TFhirSpecimen}(item));
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Specimen.subject'));{q3b}
    result.accessionIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Specimen.accessionIdentifier'));{q3b}
    result.receivedTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Specimen.receivedTime'));{q1}
    result.collection := ParseSpecimenCollection(obj.complex('http://hl7.org/fhir/Specimen.collection'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Specimen.treatment') do
      result.treatmentList.Add(parseSpecimenTreatment(item));
    for item in obj.complexes('http://hl7.org/fhir/Specimen.container') do
      result.containerList.Add(parseSpecimenContainer(item));
end;

procedure TFHIRTurtleComposer.ComposeSpecimen(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimen; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Specimen'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Specimen', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Specimen', 'status', elem.StatusElement, CODES_TFhirSpecimenStatusEnum, SYSTEMS_TFhirSpecimenStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Specimen', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('parent') then
    for i := 0 to elem.parentList.Count - 1 do
      ComposeReference{TFhirSpecimen}(this, 'Specimen', 'parent', elem.parentList[i], false, i);{x.d3}
  ComposeReference{Resource}(this, 'Specimen', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accessionIdentifier') then
    ComposeIdentifier(this, 'Specimen', 'accessionIdentifier', elem.accessionIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receivedTime') then
    ComposeDateTime(this, 'Specimen', 'receivedTime', elem.receivedTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('collection') then
    ComposeSpecimenCollection(this, 'Specimen', 'collection', elem.collectionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('treatment') then
    for i := 0 to elem.treatmentList.Count - 1 do
      ComposeSpecimenTreatment(this, 'Specimen', 'treatment', elem.treatmentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('container') then
    for i := 0 to elem.containerList.Count - 1 do
      ComposeSpecimenContainer(this, 'Specimen', 'container', elem.containerList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
function TFHIRTurtleParser.ParseStructureDefinitionContact(obj : TTurtleComplex) : TFhirStructureDefinitionContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinitionContact.create;
  try
    ParseStructureDefinitionContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionContactProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.contact.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.contact.telecom') do
      result.telecomList.Add(parseContactPoint(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinitionContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinitionContact'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureDefinition.contact', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'StructureDefinition.contact', 'telecom', elem.telecomList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseStructureDefinitionMapping(obj : TTurtleComplex) : TFhirStructureDefinitionMapping;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinitionMapping.create;
  try
    ParseStructureDefinitionMappingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionMappingProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionMapping);
begin
    ParseBackboneElementProperties(obj, result);
    result.identityElement := ParseId(obj.complex('http://hl7.org/fhir/StructureDefinition.mapping.identity'));{q1}
    result.uriElement := ParseUri(obj.complex('http://hl7.org/fhir/StructureDefinition.mapping.uri'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.mapping.name'));{q1}
    result.commentsElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.mapping.comments'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinitionMapping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionMapping; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinitionMapping'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'StructureDefinition.mapping', 'identity', elem.identityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'StructureDefinition.mapping', 'uri', elem.uriElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureDefinition.mapping', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureDefinition.mapping', 'comments', elem.commentsElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseStructureDefinitionSnapshot(obj : TTurtleComplex) : TFhirStructureDefinitionSnapshot;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinitionSnapshot.create;
  try
    ParseStructureDefinitionSnapshotProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionSnapshotProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionSnapshot);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.snapshot.element') do
      result.elementList.Add(parseElementDefinition(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinitionSnapshot(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionSnapshot; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinitionSnapshot'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(this, 'StructureDefinition.snapshot', 'element', elem.elementList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseStructureDefinitionDifferential(obj : TTurtleComplex) : TFhirStructureDefinitionDifferential;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinitionDifferential.create;
  try
    ParseStructureDefinitionDifferentialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionDifferentialProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionDifferential);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.differential.element') do
      result.elementList.Add(parseElementDefinition(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinitionDifferential(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionDifferential; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinitionDifferential'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(this, 'StructureDefinition.differential', 'element', elem.elementList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseStructureDefinition(obj : TTurtleComplex) : TFhirStructureDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinition.create;
  try
    ParseStructureDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionProperties(obj : TTurtleComplex; result : TFhirStructureDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/StructureDefinition.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.name'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.display'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureDefinition.status'), CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/StructureDefinition.experimental'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.contact') do
      result.contactList.Add(parseStructureDefinitionContact(item));
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/StructureDefinition.date'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.useContext') do
      result.useContextList.Add(parseCodeableConcept(item));
    result.requirementsElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.requirements'));{q1}
    result.copyrightElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.copyright'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.code') do
      result.codeList.Add(parseCoding(item));
    result.fhirVersionElement := ParseId(obj.complex('http://hl7.org/fhir/StructureDefinition.fhirVersion'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.mapping') do
      result.mappingList.Add(parseStructureDefinitionMapping(item));
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureDefinition.kind'), CODES_TFhirStructureDefinitionKindEnum, SYSTEMS_TFhirStructureDefinitionKindEnum);
    result.constrainedTypeElement := ParseCode(obj.complex('http://hl7.org/fhir/StructureDefinition.constrainedType'));{q1}
    result.abstractElement := ParseBoolean(obj.complex('http://hl7.org/fhir/StructureDefinition.abstract'));{q1}
    result.contextTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureDefinition.contextType'), CODES_TFhirExtensionContextEnum, SYSTEMS_TFhirExtensionContextEnum);
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.context') do
      result.contextList.Add(parseString(item));
    result.baseElement := ParseUri(obj.complex('http://hl7.org/fhir/StructureDefinition.base'));{q1}
    result.snapshot := ParseStructureDefinitionSnapshot(obj.complex('http://hl7.org/fhir/StructureDefinition.snapshot'));{q3b}
    result.differential := ParseStructureDefinitionDifferential(obj.complex('http://hl7.org/fhir/StructureDefinition.differential'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeUri(this, 'StructureDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'StructureDefinition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'StructureDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'StructureDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('display') then
    ComposeString(this, 'StructureDefinition', 'display', elem.displayElement, false, -1);{x.2ea}
  ComposeEnum(this, 'StructureDefinition', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'StructureDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'StructureDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeStructureDefinitionContact(this, 'StructureDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'StructureDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'StructureDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(this, 'StructureDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeString(this, 'StructureDefinition', 'requirements', elem.requirementsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeString(this, 'StructureDefinition', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(this, 'StructureDefinition', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fhirVersion') then
    ComposeId(this, 'StructureDefinition', 'fhirVersion', elem.fhirVersionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('mapping') then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeStructureDefinitionMapping(this, 'StructureDefinition', 'mapping', elem.mappingList[i], false, i);{x.d3}
  ComposeEnum(this, 'StructureDefinition', 'kind', elem.KindElement, CODES_TFhirStructureDefinitionKindEnum, SYSTEMS_TFhirStructureDefinitionKindEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('constrainedType') then
    ComposeCode(this, 'StructureDefinition', 'constrainedType', elem.constrainedTypeElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'StructureDefinition', 'abstract', elem.abstractElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contextType') then
    ComposeEnum(this, 'StructureDefinition', 'contextType', elem.ContextTypeElement, CODES_TFhirExtensionContextEnum, SYSTEMS_TFhirExtensionContextEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    for i := 0 to elem.contextList.Count - 1 do
      ComposeString(this, 'StructureDefinition', 'context', elem.contextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('base') then
    ComposeUri(this, 'StructureDefinition', 'base', elem.baseElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('snapshot') then
    ComposeStructureDefinitionSnapshot(this, 'StructureDefinition', 'snapshot', elem.snapshotElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('differential') then
    ComposeStructureDefinitionDifferential(this, 'StructureDefinition', 'differential', elem.differentialElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
function TFHIRTurtleParser.ParseSubscriptionChannel(obj : TTurtleComplex) : TFhirSubscriptionChannel;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubscriptionChannel.create;
  try
    ParseSubscriptionChannelProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubscriptionChannelProperties(obj : TTurtleComplex; result : TFhirSubscriptionChannel);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Subscription.channel.type'), CODES_TFhirSubscriptionChannelTypeEnum, SYSTEMS_TFhirSubscriptionChannelTypeEnum);
    result.endpointElement := ParseUri(obj.complex('http://hl7.org/fhir/Subscription.channel.endpoint'));{q1}
    result.payloadElement := ParseString(obj.complex('http://hl7.org/fhir/Subscription.channel.payload'));{q1}
    result.headerElement := ParseString(obj.complex('http://hl7.org/fhir/Subscription.channel.header'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSubscriptionChannel(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubscriptionChannel; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubscriptionChannel'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Subscription.channel', 'type', elem.Type_Element, CODES_TFhirSubscriptionChannelTypeEnum, SYSTEMS_TFhirSubscriptionChannelTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Subscription.channel', 'endpoint', elem.endpointElement, false, -1);{x.2ea}
  ComposeString(this, 'Subscription.channel', 'payload', elem.payloadElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Subscription.channel', 'header', elem.headerElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseSubscription(obj : TTurtleComplex) : TFhirSubscription;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubscription.create;
  try
    ParseSubscriptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubscriptionProperties(obj : TTurtleComplex; result : TFhirSubscription);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.criteriaElement := ParseString(obj.complex('http://hl7.org/fhir/Subscription.criteria'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Subscription.contact') do
      result.contactList.Add(parseContactPoint(item));
    result.reasonElement := ParseString(obj.complex('http://hl7.org/fhir/Subscription.reason'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Subscription.status'), CODES_TFhirSubscriptionStatusEnum, SYSTEMS_TFhirSubscriptionStatusEnum);
    result.errorElement := ParseString(obj.complex('http://hl7.org/fhir/Subscription.error'));{q1}
    result.channel := ParseSubscriptionChannel(obj.complex('http://hl7.org/fhir/Subscription.channel'));{q3b}
    result.end_Element := ParseInstant(obj.complex('http://hl7.org/fhir/Subscription.end'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Subscription.tag') do
      result.tagList.Add(parseCoding(item));
end;

procedure TFHIRTurtleComposer.ComposeSubscription(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubscription; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Subscription'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeString(this, 'Subscription', 'criteria', elem.criteriaElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(this, 'Subscription', 'contact', elem.contactList[i], false, i);{x.d3}
  ComposeString(this, 'Subscription', 'reason', elem.reasonElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Subscription', 'status', elem.StatusElement, CODES_TFhirSubscriptionStatusEnum, SYSTEMS_TFhirSubscriptionStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('error') then
    ComposeString(this, 'Subscription', 'error', elem.errorElement, false, -1);{x.2ea}
  ComposeSubscriptionChannel(this, 'Subscription', 'channel', elem.channelElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstant(this, 'Subscription', 'end', elem.end_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('tag') then
    for i := 0 to elem.tagList.Count - 1 do
      ComposeCoding(this, 'Subscription', 'tag', elem.tagList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
function TFHIRTurtleParser.ParseSubstanceInstance(obj : TTurtleComplex) : TFhirSubstanceInstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceInstance.create;
  try
    ParseSubstanceInstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceInstanceProperties(obj : TTurtleComplex; result : TFhirSubstanceInstance);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Substance.instance.identifier'));{q3b}
    result.expiryElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Substance.instance.expiry'));{q1}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Substance.instance.quantity'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceInstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceInstance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Substance.instance', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Substance.instance', 'expiry', elem.expiryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Substance.instance', 'quantity', elem.quantityElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSubstanceIngredient(obj : TTurtleComplex) : TFhirSubstanceIngredient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceIngredient.create;
  try
    ParseSubstanceIngredientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceIngredientProperties(obj : TTurtleComplex; result : TFhirSubstanceIngredient);
begin
    ParseBackboneElementProperties(obj, result);
    result.quantity := ParseRatio(obj.complex('http://hl7.org/fhir/Substance.ingredient.quantity'));{q3b}
    result.substance := ParseReference{TFhirSubstance}(obj.complex('http://hl7.org/fhir/Substance.ingredient.substance'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceIngredient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceIngredient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceIngredient'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'Substance.ingredient', 'quantity', elem.quantityElement, false, -1);{x.2f}
  ComposeReference{TFhirSubstance}(this, 'Substance.ingredient', 'substance', elem.substanceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSubstance(obj : TTurtleComplex) : TFhirSubstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstance.create;
  try
    ParseSubstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceProperties(obj : TTurtleComplex; result : TFhirSubstance);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Substance.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Substance.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Substance.code'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Substance.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Substance.instance') do
      result.instanceList.Add(parseSubstanceInstance(item));
    for item in obj.complexes('http://hl7.org/fhir/Substance.ingredient') do
      result.ingredientList.Add(parseSubstanceIngredient(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Substance'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Substance', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Substance', 'category', elem.categoryList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Substance', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'Substance', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instance') then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeSubstanceInstance(this, 'Substance', 'instance', elem.instanceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ingredient') then
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeSubstanceIngredient(this, 'Substance', 'ingredient', elem.ingredientList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
function TFHIRTurtleParser.ParseSupplyDelivery(obj : TTurtleComplex) : TFhirSupplyDelivery;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSupplyDelivery.create;
  try
    ParseSupplyDeliveryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSupplyDeliveryProperties(obj : TTurtleComplex; result : TFhirSupplyDelivery);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/SupplyDelivery.identifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/SupplyDelivery.status'), CODES_TFhirSupplydeliveryStatusEnum, SYSTEMS_TFhirSupplydeliveryStatusEnum);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/SupplyDelivery.patient'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SupplyDelivery.type'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/SupplyDelivery.quantity'));{q3b}
    result.suppliedItem := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/SupplyDelivery.suppliedItem'));{q3b}
    result.supplier := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/SupplyDelivery.supplier'));{q3b}
    result.whenPrepared := ParsePeriod(obj.complex('http://hl7.org/fhir/SupplyDelivery.whenPrepared'));{q3b}
    result.timeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/SupplyDelivery.time'));{q1}
    result.destination := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/SupplyDelivery.destination'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SupplyDelivery.receiver') do
      result.receiverList.Add(parseReference{TFhirPractitioner}(item));
end;

procedure TFHIRTurtleComposer.ComposeSupplyDelivery(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyDelivery; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SupplyDelivery'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'SupplyDelivery', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'SupplyDelivery', 'status', elem.StatusElement, CODES_TFhirSupplydeliveryStatusEnum, SYSTEMS_TFhirSupplydeliveryStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'SupplyDelivery', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'SupplyDelivery', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeQuantity(this, 'SupplyDelivery', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('suppliedItem') then
    ComposeReference{Resource}(this, 'SupplyDelivery', 'suppliedItem', elem.suppliedItemElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supplier') then
    ComposeReference{TFhirPractitioner}(this, 'SupplyDelivery', 'supplier', elem.supplierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenPrepared') then
    ComposePeriod(this, 'SupplyDelivery', 'whenPrepared', elem.whenPreparedElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('time') then
    ComposeDateTime(this, 'SupplyDelivery', 'time', elem.timeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('destination') then
    ComposeReference{TFhirLocation}(this, 'SupplyDelivery', 'destination', elem.destinationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receiver') then
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'SupplyDelivery', 'receiver', elem.receiverList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
function TFHIRTurtleParser.ParseSupplyRequestWhen(obj : TTurtleComplex) : TFhirSupplyRequestWhen;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSupplyRequestWhen.create;
  try
    ParseSupplyRequestWhenProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSupplyRequestWhenProperties(obj : TTurtleComplex; result : TFhirSupplyRequestWhen);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SupplyRequest.when.code'));{q3b}
    result.schedule := ParseTiming(obj.complex('http://hl7.org/fhir/SupplyRequest.when.schedule'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSupplyRequestWhen(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyRequestWhen; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SupplyRequestWhen'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SupplyRequest.when', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(this, 'SupplyRequest.when', 'schedule', elem.scheduleElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSupplyRequest(obj : TTurtleComplex) : TFhirSupplyRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSupplyRequest.create;
  try
    ParseSupplyRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSupplyRequestProperties(obj : TTurtleComplex; result : TFhirSupplyRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/SupplyRequest.patient'));{q3b}
    result.source := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/SupplyRequest.source'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/SupplyRequest.date'));{q1}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/SupplyRequest.identifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/SupplyRequest.status'), CODES_TFhirSupplyrequestStatusEnum, SYSTEMS_TFhirSupplyrequestStatusEnum);
    result.kind := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SupplyRequest.kind'));{q3b}
    result.orderedItem := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/SupplyRequest.orderedItem'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SupplyRequest.supplier') do
      result.supplierList.Add(parseReference{TFhirOrganization}(item));
    if obj.has('http://hl7.org/fhir/SupplyRequest.reasonCodeableConcept', item) then
      result.reason := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/SupplyRequest.reasonReference', item) {a3} then
      result.reason := ParseReference(item);
    result.when := ParseSupplyRequestWhen(obj.complex('http://hl7.org/fhir/SupplyRequest.when'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSupplyRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SupplyRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'SupplyRequest', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{Resource}(this, 'SupplyRequest', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'SupplyRequest', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'SupplyRequest', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'SupplyRequest', 'status', elem.StatusElement, CODES_TFhirSupplyrequestStatusEnum, SYSTEMS_TFhirSupplyrequestStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('kind') then
    ComposeCodeableConcept(this, 'SupplyRequest', 'kind', elem.kindElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderedItem') then
    ComposeReference{Resource}(this, 'SupplyRequest', 'orderedItem', elem.orderedItemElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supplier') then
    for i := 0 to elem.supplierList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'SupplyRequest', 'supplier', elem.supplierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SupplyRequest', 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(this, 'SupplyRequest', 'reasonReference', TFhirReference(elem.reason), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('when') then
    ComposeSupplyRequestWhen(this, 'SupplyRequest', 'when', elem.whenElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
function TFHIRTurtleParser.ParseTestScriptContact(obj : TTurtleComplex) : TFhirTestScriptContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptContact.create;
  try
    ParseTestScriptContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptContactProperties(obj : TTurtleComplex; result : TFhirTestScriptContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.contact.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.contact.telecom') do
      result.telecomList.Add(parseContactPoint(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptContact'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TestScript.contact', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'TestScript.contact', 'telecom', elem.telecomList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptMetadata(obj : TTurtleComplex) : TFhirTestScriptMetadata;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptMetadata.create;
  try
    ParseTestScriptMetadataProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptMetadataProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadata);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/TestScript.metadata.link') do
      result.link_List.Add(parseTestScriptMetadataLink(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.metadata.capability') do
      result.capabilityList.Add(parseTestScriptMetadataCapability(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptMetadata(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadata; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptMetadata'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeTestScriptMetadataLink(this, 'TestScript.metadata', 'link', elem.link_List[i], false, i);{x.d3}
  for i := 0 to elem.capabilityList.Count - 1 do
      ComposeTestScriptMetadataCapability(this, 'TestScript.metadata', 'capability', elem.capabilityList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptMetadataLink(obj : TTurtleComplex) : TFhirTestScriptMetadataLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptMetadataLink.create;
  try
    ParseTestScriptMetadataLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptMetadataLinkProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadataLink);
begin
    ParseBackboneElementProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/TestScript.metadata.link.url'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.metadata.link.description'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptMetadataLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadataLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptMetadataLink'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeUri(this, 'TestScript.metadata.link', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.metadata.link', 'description', elem.descriptionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptMetadataCapability(obj : TTurtleComplex) : TFhirTestScriptMetadataCapability;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptMetadataCapability.create;
  try
    ParseTestScriptMetadataCapabilityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptMetadataCapabilityProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadataCapability);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.requiredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.required'));{q1}
    result.validatedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.validated'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.description'));{q1}
    result.destinationElement := ParseInteger(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.destination'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.metadata.capability.link') do
      result.link_List.Add(parseUri(item));
    result.conformance := ParseReference{TFhirConformance}(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.conformance'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptMetadataCapability(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadataCapability; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptMetadataCapability'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.required <> false)) then
    ComposeBoolean(this, 'TestScript.metadata.capability', 'required', elem.requiredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.validated <> false)) then
    ComposeBoolean(this, 'TestScript.metadata.capability', 'validated', elem.validatedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.metadata.capability', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'TestScript.metadata.capability', 'destination', elem.destinationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeUri(this, 'TestScript.metadata.capability', 'link', elem.link_List[i], false, i);{x.d3}
  ComposeReference{TFhirConformance}(this, 'TestScript.metadata.capability', 'conformance', elem.conformanceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScriptFixture(obj : TTurtleComplex) : TFhirTestScriptFixture;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptFixture.create;
  try
    ParseTestScriptFixtureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptFixtureProperties(obj : TTurtleComplex; result : TFhirTestScriptFixture);
begin
    ParseBackboneElementProperties(obj, result);
    result.autocreateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.fixture.autocreate'));{q1}
    result.autodeleteElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.fixture.autodelete'));{q1}
    result.resource := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/TestScript.fixture.resource'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptFixture(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptFixture; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptFixture'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TestScript.fixture', 'autocreate', elem.autocreateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TestScript.fixture', 'autodelete', elem.autodeleteElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'TestScript.fixture', 'resource', elem.resourceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScriptVariable(obj : TTurtleComplex) : TFhirTestScriptVariable;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptVariable.create;
  try
    ParseTestScriptVariableProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptVariableProperties(obj : TTurtleComplex; result : TFhirTestScriptVariable);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.name'));{q1}
    result.headerFieldElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.headerField'));{q1}
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.path'));{q1}
    result.sourceIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.variable.sourceId'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptVariable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptVariable; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptVariable'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'TestScript.variable', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'headerField', elem.headerFieldElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.variable', 'sourceId', elem.sourceIdElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptSetup(obj : TTurtleComplex) : TFhirTestScriptSetup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetup.create;
  try
    ParseTestScriptSetupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupProperties(obj : TTurtleComplex; result : TFhirTestScriptSetup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.metadata := ParseTestScriptMetadata(obj.complex('http://hl7.org/fhir/TestScript.setup.metadata'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.setup.action') do
      result.actionList.Add(parseTestScriptSetupAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetup'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptMetadata(this, 'TestScript.setup', 'metadata', elem.metadataElement, false, -1);{x.2f}
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptSetupAction(this, 'TestScript.setup', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptSetupAction(obj : TTurtleComplex) : TFhirTestScriptSetupAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupAction.create;
  try
    ParseTestScriptSetupActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupAction);
begin
    ParseBackboneElementProperties(obj, result);
    result.operation := ParseTestScriptSetupActionOperation(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation'));{q3b}
    result.assert := ParseTestScriptSetupActionAssert(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(this, 'TestScript.setup.action', 'operation', elem.operationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(this, 'TestScript.setup.action', 'assert', elem.assertElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScriptSetupActionOperation(obj : TTurtleComplex) : TFhirTestScriptSetupActionOperation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupActionOperation.create;
  try
    ParseTestScriptSetupActionOperationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionOperationProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionOperation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.type'));{q3b}
    result.resourceElement := ParseCode(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.resource'));{q1}
    result.label_Element := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.label'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.description'));{q1}
    result.acceptElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.accept'), CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum);
    result.contentTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.contentType'), CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum);
    result.destinationElement := ParseInteger(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.destination'));{q1}
    result.encodeRequestUrlElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.encodeRequestUrl'));{q1}
    result.paramsElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.params'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.setup.action.operation.requestHeader') do
      result.requestHeaderList.Add(parseTestScriptSetupActionOperationRequestHeader(item));
    result.responseIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.responseId'));{q1}
    result.sourceIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.sourceId'));{q1}
    result.targetIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.targetId'));{q1}
    result.urlElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.url'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupActionOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionOperation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupActionOperation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'TestScript.setup.action.operation', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'TestScript.setup.action.operation', 'resource', elem.resourceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.operation', 'label', elem.label_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.operation', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.operation', 'accept', elem.AcceptElement, CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.operation', 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.destination <> '0')) then
    ComposeInteger(this, 'TestScript.setup.action.operation', 'destination', elem.destinationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.encodeRequestUrl <> true)) then
    ComposeBoolean(this, 'TestScript.setup.action.operation', 'encodeRequestUrl', elem.encodeRequestUrlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.operation', 'params', elem.paramsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.requestHeaderList.Count - 1 do
      ComposeTestScriptSetupActionOperationRequestHeader(this, 'TestScript.setup.action.operation', 'requestHeader', elem.requestHeaderList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.operation', 'responseId', elem.responseIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.operation', 'sourceId', elem.sourceIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.operation', 'targetId', elem.targetIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.operation', 'url', elem.urlElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptSetupActionOperationRequestHeader(obj : TTurtleComplex) : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupActionOperationRequestHeader.create;
  try
    ParseTestScriptSetupActionOperationRequestHeaderProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionOperationRequestHeaderProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionOperationRequestHeader);
begin
    ParseBackboneElementProperties(obj, result);
    result.fieldElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.requestHeader.field'));{q1}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.requestHeader.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupActionOperationRequestHeader(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionOperationRequestHeader; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupActionOperationRequestHeader'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'TestScript.setup.action.operation.requestHeader', 'field', elem.fieldElement, false, -1);{x.2ea}
  ComposeString(this, 'TestScript.setup.action.operation.requestHeader', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptSetupActionAssert(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssert;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupActionAssert.create;
  try
    ParseTestScriptSetupActionAssertProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionAssertProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionAssert);
begin
    ParseBackboneElementProperties(obj, result);
    result.label_Element := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.label'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.description'));{q1}
    result.directionElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.direction'), CODES_TFhirAssertDirectionCodesEnum, SYSTEMS_TFhirAssertDirectionCodesEnum);
    result.compareToSourceIdElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.compareToSourceId'));{q1}
    result.compareToSourcePathElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.compareToSourcePath'));{q1}
    result.contentTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.contentType'), CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum);
    result.headerFieldElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.headerField'));{q1}
    result.minimumIdElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.minimumId'));{q1}
    result.navigationLinksElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.navigationLinks'));{q1}
    result.operatorElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.operator'), CODES_TFhirAssertOperatorCodesEnum, SYSTEMS_TFhirAssertOperatorCodesEnum);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.path'));{q1}
    result.resourceElement := ParseCode(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.resource'));{q1}
    result.responseElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.response'), CODES_TFhirAssertResponseCodeTypesEnum, SYSTEMS_TFhirAssertResponseCodeTypesEnum);
    result.responseCodeElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.responseCode'));{q1}
    result.sourceIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.sourceId'));{q1}
    result.validateProfileIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.validateProfileId'));{q1}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.value'));{q1}
    result.warningOnlyElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.warningOnly'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupActionAssert(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssert; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupActionAssert'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'label', elem.label_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.assert', 'direction', elem.DirectionElement, CODES_TFhirAssertDirectionCodesEnum, SYSTEMS_TFhirAssertDirectionCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'compareToSourceId', elem.compareToSourceIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'compareToSourcePath', elem.compareToSourcePathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.assert', 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'headerField', elem.headerFieldElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'minimumId', elem.minimumIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TestScript.setup.action.assert', 'navigationLinks', elem.navigationLinksElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.assert', 'operator', elem.OperatorElement, CODES_TFhirAssertOperatorCodesEnum, SYSTEMS_TFhirAssertOperatorCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'TestScript.setup.action.assert', 'resource', elem.resourceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.assert', 'response', elem.ResponseElement, CODES_TFhirAssertResponseCodeTypesEnum, SYSTEMS_TFhirAssertResponseCodeTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'responseCode', elem.responseCodeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.assert', 'sourceId', elem.sourceIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.assert', 'validateProfileId', elem.validateProfileIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.warningOnly <> false)) then
    ComposeBoolean(this, 'TestScript.setup.action.assert', 'warningOnly', elem.warningOnlyElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptTest(obj : TTurtleComplex) : TFhirTestScriptTest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptTest.create;
  try
    ParseTestScriptTestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptTestProperties(obj : TTurtleComplex; result : TFhirTestScriptTest);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.test.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.test.description'));{q1}
    result.metadata := ParseTestScriptMetadata(obj.complex('http://hl7.org/fhir/TestScript.test.metadata'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.test.action') do
      result.actionList.Add(parseTestScriptTestAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptTest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptTest'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.test', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.test', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptMetadata(this, 'TestScript.test', 'metadata', elem.metadataElement, false, -1);{x.2f}
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTestAction(this, 'TestScript.test', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptTestAction(obj : TTurtleComplex) : TFhirTestScriptTestAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptTestAction.create;
  try
    ParseTestScriptTestActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptTestActionProperties(obj : TTurtleComplex; result : TFhirTestScriptTestAction);
begin
    ParseBackboneElementProperties(obj, result);
    result.operation := ParseTestScriptSetupActionOperation(obj.complex('http://hl7.org/fhir/TestScript.test.action.operation'));{q3b}
    result.assert := ParseTestScriptSetupActionAssert(obj.complex('http://hl7.org/fhir/TestScript.test.action.assert'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptTestAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTestAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptTestAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(this, 'TestScript.test.action', 'operation', elem.operationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(this, 'TestScript.test.action', 'assert', elem.assertElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScriptTeardown(obj : TTurtleComplex) : TFhirTestScriptTeardown;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptTeardown.create;
  try
    ParseTestScriptTeardownProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptTeardownProperties(obj : TTurtleComplex; result : TFhirTestScriptTeardown);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/TestScript.teardown.action') do
      result.actionList.Add(parseTestScriptTeardownAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptTeardown(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTeardown; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptTeardown'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTeardownAction(this, 'TestScript.teardown', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptTeardownAction(obj : TTurtleComplex) : TFhirTestScriptTeardownAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptTeardownAction.create;
  try
    ParseTestScriptTeardownActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptTeardownActionProperties(obj : TTurtleComplex; result : TFhirTestScriptTeardownAction);
begin
    ParseBackboneElementProperties(obj, result);
    result.operation := ParseTestScriptSetupActionOperation(obj.complex('http://hl7.org/fhir/TestScript.teardown.action.operation'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptTeardownAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTeardownAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptTeardownAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(this, 'TestScript.teardown.action', 'operation', elem.operationElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScript(obj : TTurtleComplex) : TFhirTestScript;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScript.create;
  try
    ParseTestScriptProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptProperties(obj : TTurtleComplex; result : TFhirTestScript);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/TestScript.url'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.status'), CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/TestScript.identifier'));{q3b}
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.experimental'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.contact') do
      result.contactList.Add(parseTestScriptContact(item));
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/TestScript.date'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.useContext') do
      result.useContextList.Add(parseCodeableConcept(item));
    result.requirementsElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.requirements'));{q1}
    result.copyrightElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.copyright'));{q1}
    result.metadata := ParseTestScriptMetadata(obj.complex('http://hl7.org/fhir/TestScript.metadata'));{q3b}
    result.multiserverElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.multiserver'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.fixture') do
      result.fixtureList.Add(parseTestScriptFixture(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.profile') do
      result.profileList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.variable') do
      result.variableList.Add(parseTestScriptVariable(item));
    result.setup := ParseTestScriptSetup(obj.complex('http://hl7.org/fhir/TestScript.setup'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.test') do
      result.testList.Add(parseTestScriptTest(item));
    result.teardown := ParseTestScriptTeardown(obj.complex('http://hl7.org/fhir/TestScript.teardown'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScript(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScript; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScript'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeUri(this, 'TestScript', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'TestScript', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'TestScript', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'TestScript', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'TestScript', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'TestScript', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'TestScript', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeTestScriptContact(this, 'TestScript', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'TestScript', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'TestScript', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(this, 'TestScript', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeString(this, 'TestScript', 'requirements', elem.requirementsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeString(this, 'TestScript', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('metadata') then
    ComposeTestScriptMetadata(this, 'TestScript', 'metadata', elem.metadataElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('multiserver') then
    ComposeBoolean(this, 'TestScript', 'multiserver', elem.multiserverElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('fixture') then
    for i := 0 to elem.fixtureList.Count - 1 do
      ComposeTestScriptFixture(this, 'TestScript', 'fixture', elem.fixtureList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('profile') then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'TestScript', 'profile', elem.profileList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('variable') then
    for i := 0 to elem.variableList.Count - 1 do
      ComposeTestScriptVariable(this, 'TestScript', 'variable', elem.variableList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('setup') then
    ComposeTestScriptSetup(this, 'TestScript', 'setup', elem.setupElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('test') then
    for i := 0 to elem.testList.Count - 1 do
      ComposeTestScriptTest(this, 'TestScript', 'test', elem.testList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('teardown') then
    ComposeTestScriptTeardown(this, 'TestScript', 'teardown', elem.teardownElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
function TFHIRTurtleParser.ParseValueSetContact(obj : TTurtleComplex) : TFhirValueSetContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetContact.create;
  try
    ParseValueSetContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetContactProperties(obj : TTurtleComplex; result : TFhirValueSetContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.contact.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.contact.telecom') do
      result.telecomList.Add(parseContactPoint(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetContact'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ValueSet.contact', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'ValueSet.contact', 'telecom', elem.telecomList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSetCodeSystem(obj : TTurtleComplex) : TFhirValueSetCodeSystem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetCodeSystem.create;
  try
    ParseValueSetCodeSystemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetCodeSystemProperties(obj : TTurtleComplex; result : TFhirValueSetCodeSystem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.codeSystem.system'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.codeSystem.version'));{q1}
    result.caseSensitiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.codeSystem.caseSensitive'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.codeSystem.concept') do
      result.conceptList.Add(parseValueSetCodeSystemConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetCodeSystem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetCodeSystem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetCodeSystem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeUri(this, 'ValueSet.codeSystem', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ValueSet.codeSystem', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ValueSet.codeSystem', 'caseSensitive', elem.caseSensitiveElement, false, -1);{x.2ea}
  for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetCodeSystemConcept(this, 'ValueSet.codeSystem', 'concept', elem.conceptList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSetCodeSystemConcept(obj : TTurtleComplex) : TFhirValueSetCodeSystemConcept;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetCodeSystemConcept.create;
  try
    ParseValueSetCodeSystemConceptProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetCodeSystemConceptProperties(obj : TTurtleComplex; result : TFhirValueSetCodeSystemConcept);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.codeSystem.concept.code'));{q1}
    result.abstractElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.codeSystem.concept.abstract'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.codeSystem.concept.display'));{q1}
    result.definitionElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.codeSystem.concept.definition'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.codeSystem.concept.designation') do
      result.designationList.Add(parseValueSetCodeSystemConceptDesignation(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.codeSystem.concept.concept') do
      result.conceptList.Add(parseValueSetCodeSystemConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetCodeSystemConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetCodeSystemConcept; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetCodeSystemConcept'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'ValueSet.codeSystem.concept', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.abstract <> false)) then
    ComposeBoolean(this, 'ValueSet.codeSystem.concept', 'abstract', elem.abstractElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet.codeSystem.concept', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet.codeSystem.concept', 'definition', elem.definitionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetCodeSystemConceptDesignation(this, 'ValueSet.codeSystem.concept', 'designation', elem.designationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetCodeSystemConcept(this, 'ValueSet.codeSystem.concept', 'concept', elem.conceptList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSetCodeSystemConceptDesignation(obj : TTurtleComplex) : TFhirValueSetCodeSystemConceptDesignation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetCodeSystemConceptDesignation.create;
  try
    ParseValueSetCodeSystemConceptDesignationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetCodeSystemConceptDesignationProperties(obj : TTurtleComplex; result : TFhirValueSetCodeSystemConceptDesignation);
begin
    ParseBackboneElementProperties(obj, result);
    result.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.codeSystem.concept.designation.language'));{q1}
    result.use := ParseCoding(obj.complex('http://hl7.org/fhir/ValueSet.codeSystem.concept.designation.use'));{q3b}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.codeSystem.concept.designation.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeValueSetCodeSystemConceptDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetCodeSystemConceptDesignation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetCodeSystemConceptDesignation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ValueSet.codeSystem.concept.designation', 'language', elem.languageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'ValueSet.codeSystem.concept.designation', 'use', elem.useElement, false, -1);{x.2f}
  ComposeString(this, 'ValueSet.codeSystem.concept.designation', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseValueSetCompose(obj : TTurtleComplex) : TFhirValueSetCompose;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetCompose.create;
  try
    ParseValueSetComposeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeProperties(obj : TTurtleComplex; result : TFhirValueSetCompose);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.import') do
      result.importList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include') do
      result.includeList.Add(parseValueSetComposeInclude(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.exclude') do
      result.excludeList.Add(parseValueSetComposeInclude(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetCompose(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetCompose; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetCompose'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.importList.Count - 1 do
      ComposeUri(this, 'ValueSet.compose', 'import', elem.importList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.includeList.Count - 1 do
      ComposeValueSetComposeInclude(this, 'ValueSet.compose', 'include', elem.includeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeValueSetComposeInclude(this, 'ValueSet.compose', 'exclude', elem.excludeList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSetComposeInclude(obj : TTurtleComplex) : TFhirValueSetComposeInclude;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetComposeInclude.create;
  try
    ParseValueSetComposeIncludeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeIncludeProperties(obj : TTurtleComplex; result : TFhirValueSetComposeInclude);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.system'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.version'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include.concept') do
      result.conceptList.Add(parseValueSetComposeIncludeConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include.filter') do
      result.filterList.Add(parseValueSetComposeIncludeFilter(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetComposeInclude(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeInclude; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetComposeInclude'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeUri(this, 'ValueSet.compose.include', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ValueSet.compose.include', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetComposeIncludeConcept(this, 'ValueSet.compose.include', 'concept', elem.conceptList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.filterList.Count - 1 do
      ComposeValueSetComposeIncludeFilter(this, 'ValueSet.compose.include', 'filter', elem.filterList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSetComposeIncludeConcept(obj : TTurtleComplex) : TFhirValueSetComposeIncludeConcept;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    ParseValueSetComposeIncludeConceptProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeIncludeConceptProperties(obj : TTurtleComplex; result : TFhirValueSetComposeIncludeConcept);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.concept.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.concept.display'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include.concept.designation') do
      result.designationList.Add(parseValueSetCodeSystemConceptDesignation(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetComposeIncludeConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeConcept; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetComposeIncludeConcept'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'ValueSet.compose.include.concept', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet.compose.include.concept', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetCodeSystemConceptDesignation(this, 'ValueSet.compose.include.concept', 'designation', elem.designationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSetComposeIncludeFilter(obj : TTurtleComplex) : TFhirValueSetComposeIncludeFilter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    ParseValueSetComposeIncludeFilterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeIncludeFilterProperties(obj : TTurtleComplex; result : TFhirValueSetComposeIncludeFilter);
begin
    ParseBackboneElementProperties(obj, result);
    result.property_Element := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.filter.property'));{q1}
    result.opElement := ParseEnum(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.filter.op'), CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum);
    result.valueElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.filter.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeValueSetComposeIncludeFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeFilter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetComposeIncludeFilter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'ValueSet.compose.include.filter', 'property', elem.property_Element, false, -1);{x.2ea}
  ComposeEnum(this, 'ValueSet.compose.include.filter', 'op', elem.OpElement, CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum, false, -1);{x.d4}
  ComposeCode(this, 'ValueSet.compose.include.filter', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseValueSetExpansion(obj : TTurtleComplex) : TFhirValueSetExpansion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetExpansion.create;
  try
    ParseValueSetExpansionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetExpansionProperties(obj : TTurtleComplex; result : TFhirValueSetExpansion);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.identifierElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.expansion.identifier'));{q1}
    result.timestampElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ValueSet.expansion.timestamp'));{q1}
    result.totalElement := ParseInteger(obj.complex('http://hl7.org/fhir/ValueSet.expansion.total'));{q1}
    result.offsetElement := ParseInteger(obj.complex('http://hl7.org/fhir/ValueSet.expansion.offset'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.parameter') do
      result.parameterList.Add(parseValueSetExpansionParameter(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.contains') do
      result.containsList.Add(parseValueSetExpansionContains(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetExpansion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetExpansion'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeUri(this, 'ValueSet.expansion', 'identifier', elem.identifierElement, false, -1);{x.2ea}
  ComposeDateTime(this, 'ValueSet.expansion', 'timestamp', elem.timestampElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'ValueSet.expansion', 'total', elem.totalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'ValueSet.expansion', 'offset', elem.offsetElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeValueSetExpansionParameter(this, 'ValueSet.expansion', 'parameter', elem.parameterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(this, 'ValueSet.expansion', 'contains', elem.containsList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSetExpansionParameter(obj : TTurtleComplex) : TFhirValueSetExpansionParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetExpansionParameter.create;
  try
    ParseValueSetExpansionParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetExpansionParameterProperties(obj : TTurtleComplex; result : TFhirValueSetExpansionParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.expansion.parameter.name'));{q1}
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueCode', item) then
      result.value := parseCode(item);
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueUri', item) then
      result.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeValueSetExpansionParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansionParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetExpansionParameter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'ValueSet.expansion.parameter', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCode) {6} then
    ComposeCode(this, 'ValueSet.expansion.parameter', 'valueCode', TFhirCode(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'ValueSet.expansion.parameter', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ValueSet.expansion.parameter', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'ValueSet.expansion.parameter', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ValueSet.expansion.parameter', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'ValueSet.expansion.parameter', 'valueUri', TFhirUri(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseValueSetExpansionContains(obj : TTurtleComplex) : TFhirValueSetExpansionContains;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetExpansionContains.create;
  try
    ParseValueSetExpansionContainsProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetExpansionContainsProperties(obj : TTurtleComplex; result : TFhirValueSetExpansionContains);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.system'));{q1}
    result.abstractElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.abstract'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.version'));{q1}
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.display'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.contains.contains') do
      result.containsList.Add(parseValueSetExpansionContains(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetExpansionContains(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansionContains; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetExpansionContains'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ValueSet.expansion.contains', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ValueSet.expansion.contains', 'abstract', elem.abstractElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet.expansion.contains', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ValueSet.expansion.contains', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet.expansion.contains', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(this, 'ValueSet.expansion.contains', 'contains', elem.containsList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSet(obj : TTurtleComplex) : TFhirValueSet;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSet.create;
  try
    ParseValueSetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetProperties(obj : TTurtleComplex; result : TFhirValueSet);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.url'));{q1}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/ValueSet.identifier'));{q3b}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ValueSet.status'), CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.experimental'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.contact') do
      result.contactList.Add(parseValueSetContact(item));
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ValueSet.date'));{q1}
    result.lockedDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ValueSet.lockedDate'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.useContext') do
      result.useContextList.Add(parseCodeableConcept(item));
    result.immutableElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.immutable'));{q1}
    result.requirementsElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.requirements'));{q1}
    result.copyrightElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.copyright'));{q1}
    result.extensibleElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.extensible'));{q1}
    result.codeSystem := ParseValueSetCodeSystem(obj.complex('http://hl7.org/fhir/ValueSet.codeSystem'));{q3b}
    result.compose := ParseValueSetCompose(obj.complex('http://hl7.org/fhir/ValueSet.compose'));{q3b}
    result.expansion := ParseValueSetExpansion(obj.complex('http://hl7.org/fhir/ValueSet.expansion'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeValueSet(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSet; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSet'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'ValueSet', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'ValueSet', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'ValueSet', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'ValueSet', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ValueSet', 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'ValueSet', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'ValueSet', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeValueSetContact(this, 'ValueSet', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ValueSet', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lockedDate') then
    ComposeDate(this, 'ValueSet', 'lockedDate', elem.lockedDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'ValueSet', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(this, 'ValueSet', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('immutable') then
    ComposeBoolean(this, 'ValueSet', 'immutable', elem.immutableElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeString(this, 'ValueSet', 'requirements', elem.requirementsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeString(this, 'ValueSet', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('extensible') then
    ComposeBoolean(this, 'ValueSet', 'extensible', elem.extensibleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('codeSystem') then
    ComposeValueSetCodeSystem(this, 'ValueSet', 'codeSystem', elem.codeSystemElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('compose') then
    ComposeValueSetCompose(this, 'ValueSet', 'compose', elem.composeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('expansion') then
    ComposeValueSetExpansion(this, 'ValueSet', 'expansion', elem.expansionElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
function TFHIRTurtleParser.ParseVisionPrescriptionDispense(obj : TTurtleComplex) : TFhirVisionPrescriptionDispense;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVisionPrescriptionDispense.create;
  try
    ParseVisionPrescriptionDispenseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVisionPrescriptionDispenseProperties(obj : TTurtleComplex; result : TFhirVisionPrescriptionDispense);
begin
    ParseBackboneElementProperties(obj, result);
    result.product := ParseCoding(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.product'));{q3b}
    result.eyeElement := ParseEnum(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.eye'), CODES_TFhirVisionEyeCodesEnum, SYSTEMS_TFhirVisionEyeCodesEnum);
    result.sphereElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.sphere'));{q1}
    result.cylinderElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.cylinder'));{q1}
    result.axisElement := ParseInteger(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.axis'));{q1}
    result.prismElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.prism'));{q1}
    result.baseElement := ParseEnum(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.base'), CODES_TFhirVisionBaseCodesEnum, SYSTEMS_TFhirVisionBaseCodesEnum);
    result.addElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.add'));{q1}
    result.powerElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.power'));{q1}
    result.backCurveElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.backCurve'));{q1}
    result.diameterElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.diameter'));{q1}
    result.duration := ParseQuantity(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.duration'));{q3b}
    result.colorElement := ParseString(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.color'));{q1}
    result.brandElement := ParseString(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.brand'));{q1}
    result.notesElement := ParseString(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.notes'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeVisionPrescriptionDispense(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVisionPrescriptionDispense; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VisionPrescriptionDispense'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'VisionPrescription.dispense', 'product', elem.productElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'VisionPrescription.dispense', 'eye', elem.EyeElement, CODES_TFhirVisionEyeCodesEnum, SYSTEMS_TFhirVisionEyeCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'VisionPrescription.dispense', 'sphere', elem.sphereElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'VisionPrescription.dispense', 'cylinder', elem.cylinderElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'VisionPrescription.dispense', 'axis', elem.axisElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'VisionPrescription.dispense', 'prism', elem.prismElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'VisionPrescription.dispense', 'base', elem.BaseElement, CODES_TFhirVisionBaseCodesEnum, SYSTEMS_TFhirVisionBaseCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'VisionPrescription.dispense', 'add', elem.addElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'VisionPrescription.dispense', 'power', elem.powerElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'VisionPrescription.dispense', 'backCurve', elem.backCurveElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'VisionPrescription.dispense', 'diameter', elem.diameterElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'VisionPrescription.dispense', 'duration', elem.durationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'VisionPrescription.dispense', 'color', elem.colorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'VisionPrescription.dispense', 'brand', elem.brandElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'VisionPrescription.dispense', 'notes', elem.notesElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseVisionPrescription(obj : TTurtleComplex) : TFhirVisionPrescription;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVisionPrescription.create;
  try
    ParseVisionPrescriptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVisionPrescriptionProperties(obj : TTurtleComplex; result : TFhirVisionPrescription);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/VisionPrescription.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.dateWrittenElement := ParseDateTime(obj.complex('http://hl7.org/fhir/VisionPrescription.dateWritten'));{q1}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/VisionPrescription.patient'));{q3b}
    result.prescriber := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/VisionPrescription.prescriber'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/VisionPrescription.encounter'));{q3b}
    if obj.has('http://hl7.org/fhir/VisionPrescription.reasonCodeableConcept', item) then
      result.reason := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/VisionPrescription.reasonReference', item) {a3} then
      result.reason := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/VisionPrescription.dispense') do
      result.dispenseList.Add(parseVisionPrescriptionDispense(item));
end;

procedure TFHIRTurtleComposer.ComposeVisionPrescription(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVisionPrescription; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VisionPrescription'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'VisionPrescription', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateWritten') then
    ComposeDateTime(this, 'VisionPrescription', 'dateWritten', elem.dateWrittenElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'VisionPrescription', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('prescriber') then
    ComposeReference{TFhirPractitioner}(this, 'VisionPrescription', 'prescriber', elem.prescriberElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'VisionPrescription', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'VisionPrescription', 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(this, 'VisionPrescription', 'reasonReference', TFhirReference(elem.reason), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dispense') then
    for i := 0 to elem.dispenseList.Count - 1 do
      ComposeVisionPrescriptionDispense(this, 'VisionPrescription', 'dispense', elem.dispenseList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_VISIONPRESCRIPTION}
function TFHIRTurtleParser.ParseFragment(obj : TTurtleComplex; type_ : String) : TFHIRObject;
begin
   if SameText(type_, 'Element') then
    result := parseElement(obj)
  else if SameText(type_, 'BackboneElement') then
    result := parseBackboneElement(obj)
{$IFDEF FHIR_PARAMETERS}
  else if SameText(type_, 'Parameters') then
    result := parseParameters(obj)
{$ENDIF FHIR_PARAMETERS}
  else if SameText(type_, 'Extension') then
    result := parseExtension(obj)
  else if SameText(type_, 'Narrative') then
    result := parseNarrative(obj)
  else if SameText(type_, 'Identifier') then
    result := parseIdentifier(obj)
  else if SameText(type_, 'Coding') then
    result := parseCoding(obj)
  else if SameText(type_, 'Reference') then
    result := parseReference(obj)
  else if SameText(type_, 'Signature') then
    result := parseSignature(obj)
  else if SameText(type_, 'SampledData') then
    result := parseSampledData(obj)
  else if SameText(type_, 'Period') then
    result := parsePeriod(obj)
  else if SameText(type_, 'Quantity') then
    result := parseQuantity(obj)
  else if SameText(type_, 'Attachment') then
    result := parseAttachment(obj)
  else if SameText(type_, 'Ratio') then
    result := parseRatio(obj)
  else if SameText(type_, 'Range') then
    result := parseRange(obj)
  else if SameText(type_, 'Annotation') then
    result := parseAnnotation(obj)
  else if SameText(type_, 'CodeableConcept') then
    result := parseCodeableConcept(obj)
  else if SameText(type_, 'HumanName') then
    result := parseHumanName(obj)
  else if SameText(type_, 'Meta') then
    result := parseMeta(obj)
  else if SameText(type_, 'ContactPoint') then
    result := parseContactPoint(obj)
  else if SameText(type_, 'Address') then
    result := parseAddress(obj)
  else if SameText(type_, 'ElementDefinition') then
    result := parseElementDefinition(obj)
  else if SameText(type_, 'Timing') then
    result := parseTiming(obj)
{$IFDEF FHIR_ACCOUNT}
  else if SameText(type_, 'Account') then
    result := parseAccount(obj)
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  else if SameText(type_, 'AllergyIntolerance') then
    result := parseAllergyIntolerance(obj)
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  else if SameText(type_, 'Appointment') then
    result := parseAppointment(obj)
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  else if SameText(type_, 'AppointmentResponse') then
    result := parseAppointmentResponse(obj)
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  else if SameText(type_, 'AuditEvent') then
    result := parseAuditEvent(obj)
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  else if SameText(type_, 'Basic') then
    result := parseBasic(obj)
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  else if SameText(type_, 'Binary') then
    result := parseBinary(obj)
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  else if SameText(type_, 'BodySite') then
    result := parseBodySite(obj)
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  else if SameText(type_, 'Bundle') then
    result := parseBundle(obj)
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
  else if SameText(type_, 'CarePlan') then
    result := parseCarePlan(obj)
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
  else if SameText(type_, 'Claim') then
    result := parseClaim(obj)
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  else if SameText(type_, 'ClaimResponse') then
    result := parseClaimResponse(obj)
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  else if SameText(type_, 'ClinicalImpression') then
    result := parseClinicalImpression(obj)
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
  else if SameText(type_, 'Communication') then
    result := parseCommunication(obj)
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  else if SameText(type_, 'CommunicationRequest') then
    result := parseCommunicationRequest(obj)
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
  else if SameText(type_, 'Composition') then
    result := parseComposition(obj)
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  else if SameText(type_, 'ConceptMap') then
    result := parseConceptMap(obj)
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  else if SameText(type_, 'Condition') then
    result := parseCondition(obj)
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
  else if SameText(type_, 'Conformance') then
    result := parseConformance(obj)
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
  else if SameText(type_, 'Contract') then
    result := parseContract(obj)
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  else if SameText(type_, 'Coverage') then
    result := parseCoverage(obj)
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  else if SameText(type_, 'DataElement') then
    result := parseDataElement(obj)
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  else if SameText(type_, 'DetectedIssue') then
    result := parseDetectedIssue(obj)
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  else if SameText(type_, 'Device') then
    result := parseDevice(obj)
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  else if SameText(type_, 'DeviceComponent') then
    result := parseDeviceComponent(obj)
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  else if SameText(type_, 'DeviceMetric') then
    result := parseDeviceMetric(obj)
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
  else if SameText(type_, 'DeviceUseRequest') then
    result := parseDeviceUseRequest(obj)
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  else if SameText(type_, 'DeviceUseStatement') then
    result := parseDeviceUseStatement(obj)
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
  else if SameText(type_, 'DiagnosticOrder') then
    result := parseDiagnosticOrder(obj)
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  else if SameText(type_, 'DiagnosticReport') then
    result := parseDiagnosticReport(obj)
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  else if SameText(type_, 'DocumentManifest') then
    result := parseDocumentManifest(obj)
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  else if SameText(type_, 'DocumentReference') then
    result := parseDocumentReference(obj)
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  else if SameText(type_, 'EligibilityRequest') then
    result := parseEligibilityRequest(obj)
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  else if SameText(type_, 'EligibilityResponse') then
    result := parseEligibilityResponse(obj)
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  else if SameText(type_, 'Encounter') then
    result := parseEncounter(obj)
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  else if SameText(type_, 'EnrollmentRequest') then
    result := parseEnrollmentRequest(obj)
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  else if SameText(type_, 'EnrollmentResponse') then
    result := parseEnrollmentResponse(obj)
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  else if SameText(type_, 'EpisodeOfCare') then
    result := parseEpisodeOfCare(obj)
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  else if SameText(type_, 'ExplanationOfBenefit') then
    result := parseExplanationOfBenefit(obj)
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  else if SameText(type_, 'FamilyMemberHistory') then
    result := parseFamilyMemberHistory(obj)
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  else if SameText(type_, 'Flag') then
    result := parseFlag(obj)
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  else if SameText(type_, 'Goal') then
    result := parseGoal(obj)
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
  else if SameText(type_, 'Group') then
    result := parseGroup(obj)
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  else if SameText(type_, 'HealthcareService') then
    result := parseHealthcareService(obj)
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
  else if SameText(type_, 'ImagingObjectSelection') then
    result := parseImagingObjectSelection(obj)
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
  else if SameText(type_, 'ImagingStudy') then
    result := parseImagingStudy(obj)
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  else if SameText(type_, 'Immunization') then
    result := parseImmunization(obj)
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  else if SameText(type_, 'ImmunizationRecommendation') then
    result := parseImmunizationRecommendation(obj)
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  else if SameText(type_, 'ImplementationGuide') then
    result := parseImplementationGuide(obj)
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
  else if SameText(type_, 'List') then
    result := parseList(obj)
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  else if SameText(type_, 'Location') then
    result := parseLocation(obj)
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
  else if SameText(type_, 'Media') then
    result := parseMedia(obj)
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  else if SameText(type_, 'Medication') then
    result := parseMedication(obj)
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  else if SameText(type_, 'MedicationAdministration') then
    result := parseMedicationAdministration(obj)
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  else if SameText(type_, 'MedicationDispense') then
    result := parseMedicationDispense(obj)
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
  else if SameText(type_, 'MedicationOrder') then
    result := parseMedicationOrder(obj)
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  else if SameText(type_, 'MedicationStatement') then
    result := parseMedicationStatement(obj)
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
  else if SameText(type_, 'MessageHeader') then
    result := parseMessageHeader(obj)
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  else if SameText(type_, 'NamingSystem') then
    result := parseNamingSystem(obj)
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  else if SameText(type_, 'NutritionOrder') then
    result := parseNutritionOrder(obj)
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  else if SameText(type_, 'Observation') then
    result := parseObservation(obj)
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  else if SameText(type_, 'OperationDefinition') then
    result := parseOperationDefinition(obj)
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  else if SameText(type_, 'OperationOutcome') then
    result := parseOperationOutcome(obj)
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
  else if SameText(type_, 'Order') then
    result := parseOrder(obj)
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
  else if SameText(type_, 'OrderResponse') then
    result := parseOrderResponse(obj)
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
  else if SameText(type_, 'Organization') then
    result := parseOrganization(obj)
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  else if SameText(type_, 'Patient') then
    result := parsePatient(obj)
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  else if SameText(type_, 'PaymentNotice') then
    result := parsePaymentNotice(obj)
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  else if SameText(type_, 'PaymentReconciliation') then
    result := parsePaymentReconciliation(obj)
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  else if SameText(type_, 'Person') then
    result := parsePerson(obj)
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  else if SameText(type_, 'Practitioner') then
    result := parsePractitioner(obj)
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
  else if SameText(type_, 'Procedure') then
    result := parseProcedure(obj)
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  else if SameText(type_, 'ProcedureRequest') then
    result := parseProcedureRequest(obj)
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  else if SameText(type_, 'ProcessRequest') then
    result := parseProcessRequest(obj)
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  else if SameText(type_, 'ProcessResponse') then
    result := parseProcessResponse(obj)
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  else if SameText(type_, 'Provenance') then
    result := parseProvenance(obj)
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  else if SameText(type_, 'Questionnaire') then
    result := parseQuestionnaire(obj)
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  else if SameText(type_, 'QuestionnaireResponse') then
    result := parseQuestionnaireResponse(obj)
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  else if SameText(type_, 'ReferralRequest') then
    result := parseReferralRequest(obj)
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  else if SameText(type_, 'RelatedPerson') then
    result := parseRelatedPerson(obj)
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
  else if SameText(type_, 'RiskAssessment') then
    result := parseRiskAssessment(obj)
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  else if SameText(type_, 'Schedule') then
    result := parseSchedule(obj)
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  else if SameText(type_, 'SearchParameter') then
    result := parseSearchParameter(obj)
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
  else if SameText(type_, 'Slot') then
    result := parseSlot(obj)
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  else if SameText(type_, 'Specimen') then
    result := parseSpecimen(obj)
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  else if SameText(type_, 'StructureDefinition') then
    result := parseStructureDefinition(obj)
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
  else if SameText(type_, 'Subscription') then
    result := parseSubscription(obj)
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  else if SameText(type_, 'Substance') then
    result := parseSubstance(obj)
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  else if SameText(type_, 'SupplyDelivery') then
    result := parseSupplyDelivery(obj)
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  else if SameText(type_, 'SupplyRequest') then
    result := parseSupplyRequest(obj)
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
  else if SameText(type_, 'TestScript') then
    result := parseTestScript(obj)
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  else if SameText(type_, 'ValueSet') then
    result := parseValueSet(obj)
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  else if SameText(type_, 'VisionPrescription') then
    result := parseVisionPrescription(obj)
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise Exception.create('error: the element '+type_+' is not a valid fragment name');
end;

function TFHIRTurtleParser.ParseDataType(obj : TTurtleComplex; name : String; type_ : TFHIRTypeClass) : TFHIRType;
begin
   if (type_ = TFhirExtension) then
    result := parseExtension(obj)
  else if (type_ = TFhirNarrative) then
    result := parseNarrative(obj)
  else if (type_ = TFhirIdentifier) then
    result := parseIdentifier(obj)
  else if (type_ = TFhirCoding) then
    result := parseCoding(obj)
  else if (type_ = TFhirReference) then
    result := parseReference(obj)
  else if (type_ = TFhirSignature) then
    result := parseSignature(obj)
  else if (type_ = TFhirSampledData) then
    result := parseSampledData(obj)
  else if (type_ = TFhirPeriod) then
    result := parsePeriod(obj)
  else if (type_ = TFhirQuantity) then
    result := parseQuantity(obj)
  else if (type_ = TFhirAttachment) then
    result := parseAttachment(obj)
  else if (type_ = TFhirRatio) then
    result := parseRatio(obj)
  else if (type_ = TFhirRange) then
    result := parseRange(obj)
  else if (type_ = TFhirAnnotation) then
    result := parseAnnotation(obj)
  else if (type_ = TFhirCodeableConcept) then
    result := parseCodeableConcept(obj)
  else if (type_ = TFhirHumanName) then
    result := parseHumanName(obj)
  else if (type_ = TFhirMeta) then
    result := parseMeta(obj)
  else if (type_ = TFhirContactPoint) then
    result := parseContactPoint(obj)
  else if (type_ = TFhirAddress) then
    result := parseAddress(obj)
  else if (type_ = TFhirElementDefinition) then
    result := parseElementDefinition(obj)
  else if (type_ = TFhirTiming) then
    result := parseTiming(obj)
  else
    raise Exception.create('Unknown Type');
end;

procedure TFHIRTurtleComposer.ComposeResource(parent : TTurtleComplex; resource : TFhirResource);
var
  this : TTurtleComplex;
begin
  if (resource = nil) Then
    Raise Exception.Create('error - resource is nil');
  this := parent;
  Case resource.ResourceType of
{$IFDEF FHIR_PARAMETERS}
    frtParameters: ComposeParameters(this, '', 'Parameters', TFhirParameters(resource), true, -1);
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_ACCOUNT}
  {$IFDEF FHIR_ACCOUNT}
     frtAccount: ComposeAccount(this, '', 'Account', TFhirAccount(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  {$IFDEF FHIR_ALLERGYINTOLERANCE}
     frtAllergyIntolerance: ComposeAllergyIntolerance(this, '', 'AllergyIntolerance', TFhirAllergyIntolerance(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  {$IFDEF FHIR_APPOINTMENT}
     frtAppointment: ComposeAppointment(this, '', 'Appointment', TFhirAppointment(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  {$IFDEF FHIR_APPOINTMENTRESPONSE}
     frtAppointmentResponse: ComposeAppointmentResponse(this, '', 'AppointmentResponse', TFhirAppointmentResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  {$IFDEF FHIR_AUDITEVENT}
     frtAuditEvent: ComposeAuditEvent(this, '', 'AuditEvent', TFhirAuditEvent(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  {$IFDEF FHIR_BASIC}
     frtBasic: ComposeBasic(this, '', 'Basic', TFhirBasic(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  {$IFDEF FHIR_BINARY}
     frtBinary: ComposeBinary(this, '', 'Binary', TFhirBinary(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  {$IFDEF FHIR_BODYSITE}
     frtBodySite: ComposeBodySite(this, '', 'BodySite', TFhirBodySite(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  {$IFDEF FHIR_BUNDLE}
     frtBundle: ComposeBundle(this, '', 'Bundle', TFhirBundle(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
  {$IFDEF FHIR_CAREPLAN}
     frtCarePlan: ComposeCarePlan(this, '', 'CarePlan', TFhirCarePlan(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
  {$IFDEF FHIR_CLAIM}
     frtClaim: ComposeClaim(this, '', 'Claim', TFhirClaim(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  {$IFDEF FHIR_CLAIMRESPONSE}
     frtClaimResponse: ComposeClaimResponse(this, '', 'ClaimResponse', TFhirClaimResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  {$IFDEF FHIR_CLINICALIMPRESSION}
     frtClinicalImpression: ComposeClinicalImpression(this, '', 'ClinicalImpression', TFhirClinicalImpression(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
  {$IFDEF FHIR_COMMUNICATION}
     frtCommunication: ComposeCommunication(this, '', 'Communication', TFhirCommunication(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  {$IFDEF FHIR_COMMUNICATIONREQUEST}
     frtCommunicationRequest: ComposeCommunicationRequest(this, '', 'CommunicationRequest', TFhirCommunicationRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
  {$IFDEF FHIR_COMPOSITION}
     frtComposition: ComposeComposition(this, '', 'Composition', TFhirComposition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  {$IFDEF FHIR_CONCEPTMAP}
     frtConceptMap: ComposeConceptMap(this, '', 'ConceptMap', TFhirConceptMap(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  {$IFDEF FHIR_CONDITION}
     frtCondition: ComposeCondition(this, '', 'Condition', TFhirCondition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
  {$IFDEF FHIR_CONFORMANCE}
     frtConformance: ComposeConformance(this, '', 'Conformance', TFhirConformance(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
  {$IFDEF FHIR_CONTRACT}
     frtContract: ComposeContract(this, '', 'Contract', TFhirContract(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  {$IFDEF FHIR_COVERAGE}
     frtCoverage: ComposeCoverage(this, '', 'Coverage', TFhirCoverage(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  {$IFDEF FHIR_DATAELEMENT}
     frtDataElement: ComposeDataElement(this, '', 'DataElement', TFhirDataElement(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  {$IFDEF FHIR_DETECTEDISSUE}
     frtDetectedIssue: ComposeDetectedIssue(this, '', 'DetectedIssue', TFhirDetectedIssue(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  {$IFDEF FHIR_DEVICE}
     frtDevice: ComposeDevice(this, '', 'Device', TFhirDevice(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  {$IFDEF FHIR_DEVICECOMPONENT}
     frtDeviceComponent: ComposeDeviceComponent(this, '', 'DeviceComponent', TFhirDeviceComponent(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  {$IFDEF FHIR_DEVICEMETRIC}
     frtDeviceMetric: ComposeDeviceMetric(this, '', 'DeviceMetric', TFhirDeviceMetric(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
  {$IFDEF FHIR_DEVICEUSEREQUEST}
     frtDeviceUseRequest: ComposeDeviceUseRequest(this, '', 'DeviceUseRequest', TFhirDeviceUseRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  {$IFDEF FHIR_DEVICEUSESTATEMENT}
     frtDeviceUseStatement: ComposeDeviceUseStatement(this, '', 'DeviceUseStatement', TFhirDeviceUseStatement(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
  {$IFDEF FHIR_DIAGNOSTICORDER}
     frtDiagnosticOrder: ComposeDiagnosticOrder(this, '', 'DiagnosticOrder', TFhirDiagnosticOrder(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  {$IFDEF FHIR_DIAGNOSTICREPORT}
     frtDiagnosticReport: ComposeDiagnosticReport(this, '', 'DiagnosticReport', TFhirDiagnosticReport(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  {$IFDEF FHIR_DOCUMENTMANIFEST}
     frtDocumentManifest: ComposeDocumentManifest(this, '', 'DocumentManifest', TFhirDocumentManifest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  {$IFDEF FHIR_DOCUMENTREFERENCE}
     frtDocumentReference: ComposeDocumentReference(this, '', 'DocumentReference', TFhirDocumentReference(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  {$IFDEF FHIR_ELIGIBILITYREQUEST}
     frtEligibilityRequest: ComposeEligibilityRequest(this, '', 'EligibilityRequest', TFhirEligibilityRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  {$IFDEF FHIR_ELIGIBILITYRESPONSE}
     frtEligibilityResponse: ComposeEligibilityResponse(this, '', 'EligibilityResponse', TFhirEligibilityResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  {$IFDEF FHIR_ENCOUNTER}
     frtEncounter: ComposeEncounter(this, '', 'Encounter', TFhirEncounter(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  {$IFDEF FHIR_ENROLLMENTREQUEST}
     frtEnrollmentRequest: ComposeEnrollmentRequest(this, '', 'EnrollmentRequest', TFhirEnrollmentRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  {$IFDEF FHIR_ENROLLMENTRESPONSE}
     frtEnrollmentResponse: ComposeEnrollmentResponse(this, '', 'EnrollmentResponse', TFhirEnrollmentResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  {$IFDEF FHIR_EPISODEOFCARE}
     frtEpisodeOfCare: ComposeEpisodeOfCare(this, '', 'EpisodeOfCare', TFhirEpisodeOfCare(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  {$IFDEF FHIR_EXPLANATIONOFBENEFIT}
     frtExplanationOfBenefit: ComposeExplanationOfBenefit(this, '', 'ExplanationOfBenefit', TFhirExplanationOfBenefit(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  {$IFDEF FHIR_FAMILYMEMBERHISTORY}
     frtFamilyMemberHistory: ComposeFamilyMemberHistory(this, '', 'FamilyMemberHistory', TFhirFamilyMemberHistory(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  {$IFDEF FHIR_FLAG}
     frtFlag: ComposeFlag(this, '', 'Flag', TFhirFlag(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  {$IFDEF FHIR_GOAL}
     frtGoal: ComposeGoal(this, '', 'Goal', TFhirGoal(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
  {$IFDEF FHIR_GROUP}
     frtGroup: ComposeGroup(this, '', 'Group', TFhirGroup(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  {$IFDEF FHIR_HEALTHCARESERVICE}
     frtHealthcareService: ComposeHealthcareService(this, '', 'HealthcareService', TFhirHealthcareService(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
  {$IFDEF FHIR_IMAGINGOBJECTSELECTION}
     frtImagingObjectSelection: ComposeImagingObjectSelection(this, '', 'ImagingObjectSelection', TFhirImagingObjectSelection(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
  {$IFDEF FHIR_IMAGINGSTUDY}
     frtImagingStudy: ComposeImagingStudy(this, '', 'ImagingStudy', TFhirImagingStudy(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  {$IFDEF FHIR_IMMUNIZATION}
     frtImmunization: ComposeImmunization(this, '', 'Immunization', TFhirImmunization(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  {$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
     frtImmunizationRecommendation: ComposeImmunizationRecommendation(this, '', 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  {$IFDEF FHIR_IMPLEMENTATIONGUIDE}
     frtImplementationGuide: ComposeImplementationGuide(this, '', 'ImplementationGuide', TFhirImplementationGuide(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
  {$IFDEF FHIR_LIST}
     frtList: ComposeList(this, '', 'List', TFhirList(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  {$IFDEF FHIR_LOCATION}
     frtLocation: ComposeLocation(this, '', 'Location', TFhirLocation(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
  {$IFDEF FHIR_MEDIA}
     frtMedia: ComposeMedia(this, '', 'Media', TFhirMedia(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  {$IFDEF FHIR_MEDICATION}
     frtMedication: ComposeMedication(this, '', 'Medication', TFhirMedication(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  {$IFDEF FHIR_MEDICATIONADMINISTRATION}
     frtMedicationAdministration: ComposeMedicationAdministration(this, '', 'MedicationAdministration', TFhirMedicationAdministration(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  {$IFDEF FHIR_MEDICATIONDISPENSE}
     frtMedicationDispense: ComposeMedicationDispense(this, '', 'MedicationDispense', TFhirMedicationDispense(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
  {$IFDEF FHIR_MEDICATIONORDER}
     frtMedicationOrder: ComposeMedicationOrder(this, '', 'MedicationOrder', TFhirMedicationOrder(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  {$IFDEF FHIR_MEDICATIONSTATEMENT}
     frtMedicationStatement: ComposeMedicationStatement(this, '', 'MedicationStatement', TFhirMedicationStatement(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
  {$IFDEF FHIR_MESSAGEHEADER}
     frtMessageHeader: ComposeMessageHeader(this, '', 'MessageHeader', TFhirMessageHeader(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  {$IFDEF FHIR_NAMINGSYSTEM}
     frtNamingSystem: ComposeNamingSystem(this, '', 'NamingSystem', TFhirNamingSystem(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  {$IFDEF FHIR_NUTRITIONORDER}
     frtNutritionOrder: ComposeNutritionOrder(this, '', 'NutritionOrder', TFhirNutritionOrder(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  {$IFDEF FHIR_OBSERVATION}
     frtObservation: ComposeObservation(this, '', 'Observation', TFhirObservation(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  {$IFDEF FHIR_OPERATIONDEFINITION}
     frtOperationDefinition: ComposeOperationDefinition(this, '', 'OperationDefinition', TFhirOperationDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  {$IFDEF FHIR_OPERATIONOUTCOME}
     frtOperationOutcome: ComposeOperationOutcome(this, '', 'OperationOutcome', TFhirOperationOutcome(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
  {$IFDEF FHIR_ORDER}
     frtOrder: ComposeOrder(this, '', 'Order', TFhirOrder(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
  {$IFDEF FHIR_ORDERRESPONSE}
     frtOrderResponse: ComposeOrderResponse(this, '', 'OrderResponse', TFhirOrderResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
  {$IFDEF FHIR_ORGANIZATION}
     frtOrganization: ComposeOrganization(this, '', 'Organization', TFhirOrganization(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  {$IFDEF FHIR_PATIENT}
     frtPatient: ComposePatient(this, '', 'Patient', TFhirPatient(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  {$IFDEF FHIR_PAYMENTNOTICE}
     frtPaymentNotice: ComposePaymentNotice(this, '', 'PaymentNotice', TFhirPaymentNotice(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  {$IFDEF FHIR_PAYMENTRECONCILIATION}
     frtPaymentReconciliation: ComposePaymentReconciliation(this, '', 'PaymentReconciliation', TFhirPaymentReconciliation(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  {$IFDEF FHIR_PERSON}
     frtPerson: ComposePerson(this, '', 'Person', TFhirPerson(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  {$IFDEF FHIR_PRACTITIONER}
     frtPractitioner: ComposePractitioner(this, '', 'Practitioner', TFhirPractitioner(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
  {$IFDEF FHIR_PROCEDURE}
     frtProcedure: ComposeProcedure(this, '', 'Procedure', TFhirProcedure(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  {$IFDEF FHIR_PROCEDUREREQUEST}
     frtProcedureRequest: ComposeProcedureRequest(this, '', 'ProcedureRequest', TFhirProcedureRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  {$IFDEF FHIR_PROCESSREQUEST}
     frtProcessRequest: ComposeProcessRequest(this, '', 'ProcessRequest', TFhirProcessRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  {$IFDEF FHIR_PROCESSRESPONSE}
     frtProcessResponse: ComposeProcessResponse(this, '', 'ProcessResponse', TFhirProcessResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  {$IFDEF FHIR_PROVENANCE}
     frtProvenance: ComposeProvenance(this, '', 'Provenance', TFhirProvenance(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  {$IFDEF FHIR_QUESTIONNAIRE}
     frtQuestionnaire: ComposeQuestionnaire(this, '', 'Questionnaire', TFhirQuestionnaire(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  {$IFDEF FHIR_QUESTIONNAIRERESPONSE}
     frtQuestionnaireResponse: ComposeQuestionnaireResponse(this, '', 'QuestionnaireResponse', TFhirQuestionnaireResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  {$IFDEF FHIR_REFERRALREQUEST}
     frtReferralRequest: ComposeReferralRequest(this, '', 'ReferralRequest', TFhirReferralRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  {$IFDEF FHIR_RELATEDPERSON}
     frtRelatedPerson: ComposeRelatedPerson(this, '', 'RelatedPerson', TFhirRelatedPerson(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
  {$IFDEF FHIR_RISKASSESSMENT}
     frtRiskAssessment: ComposeRiskAssessment(this, '', 'RiskAssessment', TFhirRiskAssessment(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  {$IFDEF FHIR_SCHEDULE}
     frtSchedule: ComposeSchedule(this, '', 'Schedule', TFhirSchedule(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  {$IFDEF FHIR_SEARCHPARAMETER}
     frtSearchParameter: ComposeSearchParameter(this, '', 'SearchParameter', TFhirSearchParameter(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
  {$IFDEF FHIR_SLOT}
     frtSlot: ComposeSlot(this, '', 'Slot', TFhirSlot(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  {$IFDEF FHIR_SPECIMEN}
     frtSpecimen: ComposeSpecimen(this, '', 'Specimen', TFhirSpecimen(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  {$IFDEF FHIR_STRUCTUREDEFINITION}
     frtStructureDefinition: ComposeStructureDefinition(this, '', 'StructureDefinition', TFhirStructureDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
  {$IFDEF FHIR_SUBSCRIPTION}
     frtSubscription: ComposeSubscription(this, '', 'Subscription', TFhirSubscription(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  {$IFDEF FHIR_SUBSTANCE}
     frtSubstance: ComposeSubstance(this, '', 'Substance', TFhirSubstance(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  {$IFDEF FHIR_SUPPLYDELIVERY}
     frtSupplyDelivery: ComposeSupplyDelivery(this, '', 'SupplyDelivery', TFhirSupplyDelivery(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  {$IFDEF FHIR_SUPPLYREQUEST}
     frtSupplyRequest: ComposeSupplyRequest(this, '', 'SupplyRequest', TFhirSupplyRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
  {$IFDEF FHIR_TESTSCRIPT}
     frtTestScript: ComposeTestScript(this, '', 'TestScript', TFhirTestScript(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  {$IFDEF FHIR_VALUESET}
     frtValueSet: ComposeValueSet(this, '', 'ValueSet', TFhirValueSet(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  {$IFDEF FHIR_VISIONPRESCRIPTION}
     frtVisionPrescription: ComposeVisionPrescription(this, '', 'VisionPrescription', TFhirVisionPrescription(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise Exception.create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;

function TFHIRTurtleParser.ParseResource(obj : TTurtleComplex) : TFhirResource;
var
  s : String;
begin
  s := rdfsType(obj);
 {$IFDEF FHIR_PARAMETERS}
  if s = 'Parameters' Then
    result := ParseParameters(obj)
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_ACCOUNT}
  {$IFDEF FHIR_ACCOUNT}
   else if s = 'Account' Then
    result := ParseAccount(obj) 
  {$ENDIF}
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  {$IFDEF FHIR_ALLERGYINTOLERANCE}
   else if s = 'AllergyIntolerance' Then
    result := ParseAllergyIntolerance(obj) 
  {$ENDIF}
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  {$IFDEF FHIR_APPOINTMENT}
   else if s = 'Appointment' Then
    result := ParseAppointment(obj) 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  {$IFDEF FHIR_APPOINTMENTRESPONSE}
   else if s = 'AppointmentResponse' Then
    result := ParseAppointmentResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  {$IFDEF FHIR_AUDITEVENT}
   else if s = 'AuditEvent' Then
    result := ParseAuditEvent(obj) 
  {$ENDIF}
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  {$IFDEF FHIR_BASIC}
   else if s = 'Basic' Then
    result := ParseBasic(obj) 
  {$ENDIF}
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  {$IFDEF FHIR_BINARY}
   else if s = 'Binary' Then
    result := ParseBinary(obj) 
  {$ENDIF}
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  {$IFDEF FHIR_BODYSITE}
   else if s = 'BodySite' Then
    result := ParseBodySite(obj) 
  {$ENDIF}
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  {$IFDEF FHIR_BUNDLE}
   else if s = 'Bundle' Then
    result := ParseBundle(obj) 
  {$ENDIF}
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
  {$IFDEF FHIR_CAREPLAN}
   else if s = 'CarePlan' Then
    result := ParseCarePlan(obj) 
  {$ENDIF}
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
  {$IFDEF FHIR_CLAIM}
   else if s = 'Claim' Then
    result := ParseClaim(obj) 
  {$ENDIF}
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  {$IFDEF FHIR_CLAIMRESPONSE}
   else if s = 'ClaimResponse' Then
    result := ParseClaimResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  {$IFDEF FHIR_CLINICALIMPRESSION}
   else if s = 'ClinicalImpression' Then
    result := ParseClinicalImpression(obj) 
  {$ENDIF}
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
  {$IFDEF FHIR_COMMUNICATION}
   else if s = 'Communication' Then
    result := ParseCommunication(obj) 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  {$IFDEF FHIR_COMMUNICATIONREQUEST}
   else if s = 'CommunicationRequest' Then
    result := ParseCommunicationRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
  {$IFDEF FHIR_COMPOSITION}
   else if s = 'Composition' Then
    result := ParseComposition(obj) 
  {$ENDIF}
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  {$IFDEF FHIR_CONCEPTMAP}
   else if s = 'ConceptMap' Then
    result := ParseConceptMap(obj) 
  {$ENDIF}
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  {$IFDEF FHIR_CONDITION}
   else if s = 'Condition' Then
    result := ParseCondition(obj) 
  {$ENDIF}
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
  {$IFDEF FHIR_CONFORMANCE}
   else if s = 'Conformance' Then
    result := ParseConformance(obj) 
  {$ENDIF}
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
  {$IFDEF FHIR_CONTRACT}
   else if s = 'Contract' Then
    result := ParseContract(obj) 
  {$ENDIF}
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  {$IFDEF FHIR_COVERAGE}
   else if s = 'Coverage' Then
    result := ParseCoverage(obj) 
  {$ENDIF}
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  {$IFDEF FHIR_DATAELEMENT}
   else if s = 'DataElement' Then
    result := ParseDataElement(obj) 
  {$ENDIF}
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  {$IFDEF FHIR_DETECTEDISSUE}
   else if s = 'DetectedIssue' Then
    result := ParseDetectedIssue(obj) 
  {$ENDIF}
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  {$IFDEF FHIR_DEVICE}
   else if s = 'Device' Then
    result := ParseDevice(obj) 
  {$ENDIF}
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  {$IFDEF FHIR_DEVICECOMPONENT}
   else if s = 'DeviceComponent' Then
    result := ParseDeviceComponent(obj) 
  {$ENDIF}
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  {$IFDEF FHIR_DEVICEMETRIC}
   else if s = 'DeviceMetric' Then
    result := ParseDeviceMetric(obj) 
  {$ENDIF}
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
  {$IFDEF FHIR_DEVICEUSEREQUEST}
   else if s = 'DeviceUseRequest' Then
    result := ParseDeviceUseRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  {$IFDEF FHIR_DEVICEUSESTATEMENT}
   else if s = 'DeviceUseStatement' Then
    result := ParseDeviceUseStatement(obj) 
  {$ENDIF}
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
  {$IFDEF FHIR_DIAGNOSTICORDER}
   else if s = 'DiagnosticOrder' Then
    result := ParseDiagnosticOrder(obj) 
  {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  {$IFDEF FHIR_DIAGNOSTICREPORT}
   else if s = 'DiagnosticReport' Then
    result := ParseDiagnosticReport(obj) 
  {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  {$IFDEF FHIR_DOCUMENTMANIFEST}
   else if s = 'DocumentManifest' Then
    result := ParseDocumentManifest(obj) 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  {$IFDEF FHIR_DOCUMENTREFERENCE}
   else if s = 'DocumentReference' Then
    result := ParseDocumentReference(obj) 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  {$IFDEF FHIR_ELIGIBILITYREQUEST}
   else if s = 'EligibilityRequest' Then
    result := ParseEligibilityRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  {$IFDEF FHIR_ELIGIBILITYRESPONSE}
   else if s = 'EligibilityResponse' Then
    result := ParseEligibilityResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  {$IFDEF FHIR_ENCOUNTER}
   else if s = 'Encounter' Then
    result := ParseEncounter(obj) 
  {$ENDIF}
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  {$IFDEF FHIR_ENROLLMENTREQUEST}
   else if s = 'EnrollmentRequest' Then
    result := ParseEnrollmentRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  {$IFDEF FHIR_ENROLLMENTRESPONSE}
   else if s = 'EnrollmentResponse' Then
    result := ParseEnrollmentResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  {$IFDEF FHIR_EPISODEOFCARE}
   else if s = 'EpisodeOfCare' Then
    result := ParseEpisodeOfCare(obj) 
  {$ENDIF}
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  {$IFDEF FHIR_EXPLANATIONOFBENEFIT}
   else if s = 'ExplanationOfBenefit' Then
    result := ParseExplanationOfBenefit(obj) 
  {$ENDIF}
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  {$IFDEF FHIR_FAMILYMEMBERHISTORY}
   else if s = 'FamilyMemberHistory' Then
    result := ParseFamilyMemberHistory(obj) 
  {$ENDIF}
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  {$IFDEF FHIR_FLAG}
   else if s = 'Flag' Then
    result := ParseFlag(obj) 
  {$ENDIF}
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  {$IFDEF FHIR_GOAL}
   else if s = 'Goal' Then
    result := ParseGoal(obj) 
  {$ENDIF}
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
  {$IFDEF FHIR_GROUP}
   else if s = 'Group' Then
    result := ParseGroup(obj) 
  {$ENDIF}
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  {$IFDEF FHIR_HEALTHCARESERVICE}
   else if s = 'HealthcareService' Then
    result := ParseHealthcareService(obj) 
  {$ENDIF}
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
  {$IFDEF FHIR_IMAGINGOBJECTSELECTION}
   else if s = 'ImagingObjectSelection' Then
    result := ParseImagingObjectSelection(obj) 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
  {$IFDEF FHIR_IMAGINGSTUDY}
   else if s = 'ImagingStudy' Then
    result := ParseImagingStudy(obj) 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  {$IFDEF FHIR_IMMUNIZATION}
   else if s = 'Immunization' Then
    result := ParseImmunization(obj) 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  {$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
   else if s = 'ImmunizationRecommendation' Then
    result := ParseImmunizationRecommendation(obj) 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  {$IFDEF FHIR_IMPLEMENTATIONGUIDE}
   else if s = 'ImplementationGuide' Then
    result := ParseImplementationGuide(obj) 
  {$ENDIF}
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
  {$IFDEF FHIR_LIST}
   else if s = 'List' Then
    result := ParseList(obj) 
  {$ENDIF}
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  {$IFDEF FHIR_LOCATION}
   else if s = 'Location' Then
    result := ParseLocation(obj) 
  {$ENDIF}
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
  {$IFDEF FHIR_MEDIA}
   else if s = 'Media' Then
    result := ParseMedia(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  {$IFDEF FHIR_MEDICATION}
   else if s = 'Medication' Then
    result := ParseMedication(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  {$IFDEF FHIR_MEDICATIONADMINISTRATION}
   else if s = 'MedicationAdministration' Then
    result := ParseMedicationAdministration(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  {$IFDEF FHIR_MEDICATIONDISPENSE}
   else if s = 'MedicationDispense' Then
    result := ParseMedicationDispense(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
  {$IFDEF FHIR_MEDICATIONORDER}
   else if s = 'MedicationOrder' Then
    result := ParseMedicationOrder(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  {$IFDEF FHIR_MEDICATIONSTATEMENT}
   else if s = 'MedicationStatement' Then
    result := ParseMedicationStatement(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
  {$IFDEF FHIR_MESSAGEHEADER}
   else if s = 'MessageHeader' Then
    result := ParseMessageHeader(obj) 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  {$IFDEF FHIR_NAMINGSYSTEM}
   else if s = 'NamingSystem' Then
    result := ParseNamingSystem(obj) 
  {$ENDIF}
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  {$IFDEF FHIR_NUTRITIONORDER}
   else if s = 'NutritionOrder' Then
    result := ParseNutritionOrder(obj) 
  {$ENDIF}
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  {$IFDEF FHIR_OBSERVATION}
   else if s = 'Observation' Then
    result := ParseObservation(obj) 
  {$ENDIF}
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  {$IFDEF FHIR_OPERATIONDEFINITION}
   else if s = 'OperationDefinition' Then
    result := ParseOperationDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  {$IFDEF FHIR_OPERATIONOUTCOME}
   else if s = 'OperationOutcome' Then
    result := ParseOperationOutcome(obj) 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
  {$IFDEF FHIR_ORDER}
   else if s = 'Order' Then
    result := ParseOrder(obj) 
  {$ENDIF}
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
  {$IFDEF FHIR_ORDERRESPONSE}
   else if s = 'OrderResponse' Then
    result := ParseOrderResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
  {$IFDEF FHIR_ORGANIZATION}
   else if s = 'Organization' Then
    result := ParseOrganization(obj) 
  {$ENDIF}
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  {$IFDEF FHIR_PATIENT}
   else if s = 'Patient' Then
    result := ParsePatient(obj) 
  {$ENDIF}
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  {$IFDEF FHIR_PAYMENTNOTICE}
   else if s = 'PaymentNotice' Then
    result := ParsePaymentNotice(obj) 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  {$IFDEF FHIR_PAYMENTRECONCILIATION}
   else if s = 'PaymentReconciliation' Then
    result := ParsePaymentReconciliation(obj) 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  {$IFDEF FHIR_PERSON}
   else if s = 'Person' Then
    result := ParsePerson(obj) 
  {$ENDIF}
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  {$IFDEF FHIR_PRACTITIONER}
   else if s = 'Practitioner' Then
    result := ParsePractitioner(obj) 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
  {$IFDEF FHIR_PROCEDURE}
   else if s = 'Procedure' Then
    result := ParseProcedure(obj) 
  {$ENDIF}
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  {$IFDEF FHIR_PROCEDUREREQUEST}
   else if s = 'ProcedureRequest' Then
    result := ParseProcedureRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  {$IFDEF FHIR_PROCESSREQUEST}
   else if s = 'ProcessRequest' Then
    result := ParseProcessRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  {$IFDEF FHIR_PROCESSRESPONSE}
   else if s = 'ProcessResponse' Then
    result := ParseProcessResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  {$IFDEF FHIR_PROVENANCE}
   else if s = 'Provenance' Then
    result := ParseProvenance(obj) 
  {$ENDIF}
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  {$IFDEF FHIR_QUESTIONNAIRE}
   else if s = 'Questionnaire' Then
    result := ParseQuestionnaire(obj) 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  {$IFDEF FHIR_QUESTIONNAIRERESPONSE}
   else if s = 'QuestionnaireResponse' Then
    result := ParseQuestionnaireResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  {$IFDEF FHIR_REFERRALREQUEST}
   else if s = 'ReferralRequest' Then
    result := ParseReferralRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  {$IFDEF FHIR_RELATEDPERSON}
   else if s = 'RelatedPerson' Then
    result := ParseRelatedPerson(obj) 
  {$ENDIF}
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
  {$IFDEF FHIR_RISKASSESSMENT}
   else if s = 'RiskAssessment' Then
    result := ParseRiskAssessment(obj) 
  {$ENDIF}
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  {$IFDEF FHIR_SCHEDULE}
   else if s = 'Schedule' Then
    result := ParseSchedule(obj) 
  {$ENDIF}
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  {$IFDEF FHIR_SEARCHPARAMETER}
   else if s = 'SearchParameter' Then
    result := ParseSearchParameter(obj) 
  {$ENDIF}
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
  {$IFDEF FHIR_SLOT}
   else if s = 'Slot' Then
    result := ParseSlot(obj) 
  {$ENDIF}
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  {$IFDEF FHIR_SPECIMEN}
   else if s = 'Specimen' Then
    result := ParseSpecimen(obj) 
  {$ENDIF}
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  {$IFDEF FHIR_STRUCTUREDEFINITION}
   else if s = 'StructureDefinition' Then
    result := ParseStructureDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
  {$IFDEF FHIR_SUBSCRIPTION}
   else if s = 'Subscription' Then
    result := ParseSubscription(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  {$IFDEF FHIR_SUBSTANCE}
   else if s = 'Substance' Then
    result := ParseSubstance(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  {$IFDEF FHIR_SUPPLYDELIVERY}
   else if s = 'SupplyDelivery' Then
    result := ParseSupplyDelivery(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  {$IFDEF FHIR_SUPPLYREQUEST}
   else if s = 'SupplyRequest' Then
    result := ParseSupplyRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
  {$IFDEF FHIR_TESTSCRIPT}
   else if s = 'TestScript' Then
    result := ParseTestScript(obj) 
  {$ENDIF}
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  {$IFDEF FHIR_VALUESET}
   else if s = 'ValueSet' Then
    result := ParseValueSet(obj) 
  {$ENDIF}
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  {$IFDEF FHIR_VISIONPRESCRIPTION}
   else if s = 'VisionPrescription' Then
    result := ParseVisionPrescription(obj) 
  {$ENDIF}
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise Exception.create('error: the element '+s+' is not a valid resource name');
end;


end.

